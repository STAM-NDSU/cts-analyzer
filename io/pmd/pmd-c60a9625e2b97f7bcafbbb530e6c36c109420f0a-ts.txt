/* *  */package test.net.sourceforge.pmd.jdbc;import com.mockobjects.sql.MockConnection;import com.mockobjects.sql.MockDriver;import com.mockobjects.sql.MockPreparedStatement;import com.mockobjects.sql.MockSingleRowResultSet;import junit.framework.TestCase;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.jdbc.JDBCReportListener;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.MockRule;import java.sql.Date;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JDBCReportListenerTest extends TestCase {    private MockDriver driver = null;    private MockPreparedStatement violInsert = null;    private MockPreparedStatement metInsert = null;    public void setUp() {driver = new MockDriver();try {    DriverManager.registerDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    public void tearDown() {try {    DriverManager.deregisterDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    private class MockInsertPMDRunsextends MockPreparedStatement    {private int runId = 0;public MockInsertPMDRuns( int projectId, int runId ) {    //    setExpectedQueryString("INSERT INTO PMD_RUNS (PROJECT_ID, RUN_DATE) VALUES (?, ?)");    addExpectedSetParameter( 1, projectId );    this.runId = runId;}public void setDate( int position, Date dateTime ) {    assertEquals("Date in wrong position.", 2, position);    assertTrue( "Didn't add the current date.",dateTime.getTime() > System.currentTimeMillis() - 5000);    assertTrue( "Set a future date.",dateTime.getTime() < System.currentTimeMillis() + 5000);}public ResultSet getGeneratedKeys() {    MockSingleRowResultSet RC = new MockSingleRowResultSet();    RC.addExpectedIndexedValues( new Object[] { new Integer(runId) });    return RC;}    }    private class MockPMDConxextends MockConnection    {public MockPMDConx( int projectId, int runId ) {    super();    setupAddPreparedStatement( new MockInsertPMDRuns( projectId, runId ) );    violInsert = new MockPreparedStatement();    setupAddPreparedStatement( violInsert );        metInsert = new MockPreparedStatement();    setupAddPreparedStatement( metInsert );}public PreparedStatement prepareStatement( String sql, int returnKeys )    throws SQLException{    assertEquals( "Not set to return generated keys.",   returnKeys, Statement.RETURN_GENERATED_KEYS );    return prepareStatement( sql );}    }    public JDBCReportListener getIUT(int projectId) throws SQLException    {return new JDBCReportListener( "jdbc:mock:getIUT",       "iut_user", "iut_pw", projectId );    }    public void testLongConstructor() throws Throwable {MockConnection conx = new MockPMDConx(1, 5);driver.setupConnect( conx );new JDBCReportListener("jdbc:mock:testLongConstructor", "tlc_user", "tlc_pw", 1);    }    public void testPropConstructor() throws Throwable {MockConnection conx = new MockPMDConx(2, 8);driver.setupConnect( conx );Properties props = new Properties();props.put( JDBCReportListener.JDBC_URL, "jdbc:mock:testPropConstructor" );props.put( JDBCReportListener.JDBC_USER, "tpc_user" );props.put( JDBCReportListener.JDBC_PASSWORD, "tpc_pw" );props.put( JDBCReportListener.JDBC_PROJECTID, "2");new JDBCReportListener(props);    }    public void testSingleViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );JDBCReportListener IUT = getIUT( 16 );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));    }    public void testMultiViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 16 );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1a" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileAa" );      // File NameviolInsert.addExpectedSetParameter( 4, 2561 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageBa" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classCa" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msga" );ctx = new RuleContext();ctx.setSourceCodeFilename( "fileAa" );ctx.setPackageName( "packageBa" );ctx.setClassName( "classCa" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1a", "Descriptiona", "msga" ),    2561, ctx ));    }    public void testSingleMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "single" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));JDBCReportListener IUT = getIUT( 18 );IUT.metricAdded( new Metric("single", 5, 30, 1.0, 6.0, 3.0, 1.5) );    }    public void testMultiMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 18 );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "first" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));IUT.metricAdded( new Metric("first", 5, 30, 1.0, 6.0, 3.0, 1.5) );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "second" );metInsert.addExpectedSetParameter( 3, new Double( 1.01 ));metInsert.addExpectedSetParameter( 4, new Double( 6.01 ));metInsert.addExpectedSetParameter( 5, new Double( 3.01 ));metInsert.addExpectedSetParameter( 6, new Double( 1.51 ));IUT.metricAdded( new Metric("second", 7, 32.5, 1.01, 6.01, 3.01, 1.51) );    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.util;import junit.framework.TestCase;import net.sourceforge.pmd.util.Applier;import net.sourceforge.pmd.util.UnaryFunction;import java.util.ArrayList;import java.util.List;public class ApplierTest extends TestCase {    private static class MyFunction implements UnaryFunction<Object> {        private boolean gotCallback;        public void applyTo(Object o) {            this.gotCallback = true;        }        public boolean gotCallback() {            return this.gotCallback;        }    }    public void testSimple() {        MyFunction f = new MyFunction();        List<Object> l = new ArrayList<Object>();        l.add(new Object());        Applier.apply(f, l.iterator());        assertTrue(f.gotCallback());    }}
 package test.net.sourceforge.pmd.jsp.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  /**  * Test the "DontNestJsfInJstlIteration" rule.  *  * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be  */ public class DontNestJsfInJstlIterationTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("jsf", "DontNestJsfInJstlIteration");     }      public void testViolation() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.jsp.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  /**  * Test the "NoScriptlets" rule.  *  * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be  */ public class NoScriptletsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("jsp", "NoScriptlets");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.jsp.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class NoInlineStyleInformationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("jsp", "NoInlineStyleInformation");    }    public void testAll() {        runTests(rule);    }}
package test.net.sourceforge.pmd.jsp.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class DuplicateJspImportTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("jsp", "DuplicateJspImports");    }    public void testAll() {        runTests(rule);    }}
package test.net.sourceforge.pmd.jsp.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class NoHtmlCommentsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("jsp", "NoHtmlComments");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.jsp.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  /**  * Test the "NoJspForward" rule.  *  * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be  */ public class NoJspForwardTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("jsp", "NoJspForward");     }      public void testViolation() {         runTests(rule);     } }
package test.net.sourceforge.pmd.jsp.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class IframeMissingSrcAttributeTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("jsp", "IframeMissingSrcAttribute");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.jsp.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class NoLongScriptsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("jsp", "NoLongScripts");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.jsp.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class NoClassAttributeTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("jsp", "NoClassAttribute");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.jsp.ast;import net.sourceforge.pmd.jsp.ast.ASTAttribute;import net.sourceforge.pmd.jsp.ast.ASTAttributeValue;import net.sourceforge.pmd.jsp.ast.ASTCData;import net.sourceforge.pmd.jsp.ast.ASTCommentTag;import net.sourceforge.pmd.jsp.ast.ASTDoctypeDeclaration;import net.sourceforge.pmd.jsp.ast.ASTDoctypeExternalId;import net.sourceforge.pmd.jsp.ast.ASTElement;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Set;/** * Test parsing of a JSP in document style, by checking the generated AST. *  * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be *  */public class JspDocStyleTest extends AbstractJspNodesTst {/** * Smoke test for JSP parser. *  * @throws Throwable */public void testSimplestJsp() throws Throwable {assertNumberOfNodes(ASTElement.class, TEST_SIMPLEST_HTML, 1);}/** * Test the information on a Element and Attribute. *  * @throws Throwable */public void testElementAttributeAndNamespace() throws Throwable {Set nodes = getNodes(null, TEST_ELEMENT_AND_NAMESPACE);Set<ASTElement> elementNodes = getNodesOfType(ASTElement.class, nodes);assertEquals("One element node expected!", 1, elementNodes.size());ASTElement element = elementNodes.iterator().next();assertEquals("Correct name expected!", "h:html", element.getName());assertEquals("Has namespace prefix!", true, element.isHasNamespacePrefix());assertEquals("Element is empty!", true, element.isEmpty());assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());assertEquals("Correct local name of element expected!", "html", element.getLocalName());Set attributeNodes = getNodesOfType(ASTAttribute.class, nodes);assertEquals("One attribute node expected!", 1, attributeNodes.size());ASTAttribute attribute = (ASTAttribute) attributeNodes.iterator().next();assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());assertEquals("Has namespace prefix!", true, attribute.isHasNamespacePrefix());assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix",attribute.getNamespacePrefix());assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());}/** * Test exposing a bug of parsing error when having a hash as last character * in an attribute value. * */public void testAttributeValueContainingHash() {Set nodes = getNodes(null, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);Set<ASTAttribute> attributes = getNodesOfType(ASTAttribute.class, nodes);assertEquals("Three attributes expected!", 3, attributes.size());List<ASTAttribute> attrsList = new ArrayList<ASTAttribute>(attributes);Collections.sort(attrsList, new Comparator<ASTAttribute>() {public int compare(ASTAttribute arg0, ASTAttribute arg1) {return arg0.getName().compareTo(arg1.getName());}});ASTAttribute attr = attrsList.get(0);assertEquals("Correct attribute name expected!", "foo", attr.getName());assertEquals("Correct attribute value expected!", "CREATE", attr.getFirstChildOfType(ASTAttributeValue.class).getImage());attr = attrsList.get(1);assertEquals("Correct attribute name expected!", "href", attr.getName());assertEquals("Correct attribute value expected!", "#", attr.getFirstChildOfType(ASTAttributeValue.class).getImage());attr = attrsList.get(2);assertEquals("Correct attribute name expected!", "something", attr.getName());assertEquals("Correct attribute value expected!", "#yes#", attr.getFirstChildOfType(ASTAttributeValue.class).getImage());}/** * Test correct parsing of CDATA. */public void testCData() {Set cdataNodes = getNodes(ASTCData.class, TEST_CDATA);assertEquals("One CDATA node expected!", 1, cdataNodes.size());ASTCData cdata = (ASTCData) cdataNodes.iterator().next();assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());}/** * Test parsing of Doctype declaration. */public void testDoctype() {Set nodes = getNodes(null, TEST_DOCTYPE);Set<ASTDoctypeDeclaration> docTypeDeclarations = getNodesOfType(ASTDoctypeDeclaration.class, nodes);assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());Set externalIds = getNodesOfType(ASTDoctypeExternalId.class, nodes);assertEquals("One doctype external id expected!", 1, externalIds.size());ASTDoctypeExternalId externalId = (ASTDoctypeExternalId) externalIds.iterator().next();assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",externalId.getUri());}/** * Test parsing of a XML comment. * */public void testComment() {Set comments = getNodes(ASTCommentTag.class, TEST_COMMENT);assertEquals("One comment expected!", 1, comments.size());ASTCommentTag comment = (ASTCommentTag) comments.iterator().next();assertEquals("Correct comment content expected!", "comment", comment.getImage());}private static final String TEST_SIMPLEST_HTML = "<html/>";private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"+ "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "+ "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n"+ "<greeting>Hello, world!</greeting>";private static final String TEST_COMMENT = "<html><!-- comment --></html>";private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";}
package test.net.sourceforge.pmd.jsp.ast;import net.sourceforge.pmd.jsp.ast.ASTElExpression;import net.sourceforge.pmd.jsp.ast.ASTJspComment;import net.sourceforge.pmd.jsp.ast.ASTJspDeclaration;import net.sourceforge.pmd.jsp.ast.ASTJspDirective;import net.sourceforge.pmd.jsp.ast.ASTJspDirectiveAttribute;import net.sourceforge.pmd.jsp.ast.ASTJspExpression;import net.sourceforge.pmd.jsp.ast.ASTJspExpressionInAttribute;import net.sourceforge.pmd.jsp.ast.ASTJspScriptlet;import net.sourceforge.pmd.jsp.ast.ASTValueBinding;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Set;public class JspPageStyleTest extends AbstractJspNodesTst {    /**     * Test parsing of a JSP comment.     */    public void testComment() {        Set comments = getNodes(ASTJspComment.class, JSP_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTJspComment comment = (ASTJspComment) comments.iterator().next();        assertEquals("Correct comment content expected!", "some comment", comment.getImage());    }    /**     * Test parsing a JSP directive.     */    public void testDirective() {        Set nodes = getNodes(null, JSP_DIRECTIVE);        Set<ASTJspDirective> directives = getNodesOfType(ASTJspDirective.class, nodes);        assertEquals("One directive expected!", 1, directives.size());        ASTJspDirective directive = directives.iterator().next();        assertEquals("Correct directive name expected!",                "page", directive.getName());        Set<ASTJspDirectiveAttribute> directiveAttrs = getNodesOfType(ASTJspDirectiveAttribute.class, nodes);        assertEquals("Two directive attributes expected!", 2, directiveAttrs.size());        List<ASTJspDirectiveAttribute> attrsList = new ArrayList<ASTJspDirectiveAttribute>(directiveAttrs);        Collections.sort(attrsList, new Comparator<ASTJspDirectiveAttribute>() {            public int compare(ASTJspDirectiveAttribute arg0, ASTJspDirectiveAttribute arg1) {                return arg0.getName().compareTo(arg1.getName());            }        });        ASTJspDirectiveAttribute attr = attrsList.get(0);        assertEquals("Correct directive attribute name expected!",                "language", attr.getName());        assertEquals("Correct directive attribute value expected!",                "java", attr.getValue());        attr = attrsList.get(1);        assertEquals("Correct directive attribute name expected!",                "session", attr.getName());        assertEquals("Correct directive attribute value expected!",                "true", attr.getValue());    }    /**     * Test parsing of a JSP declaration.     */    public void testDeclaration() {        Set declarations = getNodes(ASTJspDeclaration.class, JSP_DECLARATION);        assertEquals("One declaration expected!", 1, declarations.size());        ASTJspDeclaration declaration = (ASTJspDeclaration) declarations.iterator().next();        assertEquals("Correct declaration content expected!",                "String someString = \"s\";", declaration.getImage());    }    /**     * Test parsing of a JSP scriptlet.     */    public void testScriptlet() {        Set scriptlets = getNodes(ASTJspScriptlet.class, JSP_SCRIPTLET);        assertEquals("One scriptlet expected!", 1, scriptlets.size());        ASTJspScriptlet scriptlet = (ASTJspScriptlet) scriptlets.iterator().next();        assertEquals("Correct scriptlet content expected!",                "someString = someString + \"suffix\";", scriptlet.getImage());    }    /**     * Test parsing of a JSP expression.     */    public void testExpression() {        Set expressions = getNodes(ASTJspExpression.class, JSP_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpression expression = (ASTJspExpression) expressions.iterator().next();        assertEquals("Correct expression content expected!",                "someString", expression.getImage());    }    /**     * Test parsing of a JSP expression in an attribute.     */    public void testExpressionInAttribute() {        Set expressions = getNodes(ASTJspExpressionInAttribute.class,                JSP_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpressionInAttribute expression = (ASTJspExpressionInAttribute) expressions.iterator().next();        assertEquals("Correct expression content expected!",                "style.getClass()", expression.getImage());    }    /**     * Test parsing of a EL expression.     */    public void testElExpression() {        Set expressions = getNodes(ASTElExpression.class, JSP_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = (ASTElExpression) expressions.iterator().next();        assertEquals("Correct expression content expected!",                "myBean.get(\"${ World }\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    public void testElExpressionInAttribute() {        Set expressions = getNodes(ASTElExpression.class, JSP_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = (ASTElExpression) expressions.iterator().next();        assertEquals("Correct expression content expected!",                "myValidator.find(\"'jsp'\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    public void testJsfValueBinding() {        Set valueBindings = getNodes(ASTValueBinding.class, JSF_VALUE_BINDING);        assertEquals("One value binding expected!", 1, valueBindings.size());        ASTValueBinding valueBinding = (ASTValueBinding) valueBindings.iterator().next();        assertEquals("Correct expression content expected!",                "myValidator.find(\"'jsf'\")", valueBinding.getImage());    }    private static final String JSP_COMMENT            = "<html> <%-- some comment --%> </html>";    private static final String JSP_DIRECTIVE            = "<html> <%@ page language=\"java\" session='true'%> </html>";    private static final String JSP_DECLARATION            = "<html><%! String someString = \"s\"; %></html>";    private static final String JSP_SCRIPTLET            = "<html> <% someString = someString + \"suffix\"; %> </html>";    private static final String JSP_EXPRESSION            = "<html><head><title> <%= someString %> </title></head></html>";    private static final String JSP_EXPRESSION_IN_ATTRIBUTE            = "<html> <body> <p class='<%= style.getClass() %>'> Hello </p> </body> </html>";    private static final String JSP_EL_EXPRESSION            = "<html><title>Hello ${myBean.get(\"${ World }\") } .jsp</title></html>";    private static final String JSP_EL_EXPRESSION_IN_ATTRIBUTE            = "<html> <f:validator type=\"get('type').${myValidator.find(\"'jsp'\")}\" /> </html>";    private static final String JSF_VALUE_BINDING            = "<html> <body> <p class='#{myValidator.find(\"'jsf'\")}'> Hello </p> </body> </html>";}
package test.net.sourceforge.pmd.jsp.ast;import net.sourceforge.pmd.Language;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.SourceType;import net.sourceforge.pmd.rules.XPathRule;import test.net.sourceforge.pmd.testframework.RuleTst;import java.io.StringReader;public class XPathJspRuleTest extends RuleTst {    /**     * Test matching a XPath expression against a JSP source.     *     * @throws Throwable     */    public void testExpressionMatching() throws Throwable {        Rule rule = new XPathRule();        rule.addProperty("xpath", XPATH_EXPRESSION);        rule.setMessage("Test");        RuleSet rules = new RuleSet();        rules.addRule(rule);        rules.setLanguage(Language.JSP);        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        PMD p = new PMD();        p.processFile(new StringReader(MATCH), new RuleSets(rules), ctx, SourceType.JSP);        assertEquals("One violation expected!", 1, report.size());        RuleViolation rv = (RuleViolation) report.iterator().next();        assertEquals(1, rv.getBeginLine());    }    private static final String MATCH            = "<html><hr/></html>";    private static final String XPATH_EXPRESSION            = "//Element [@Name='hr']";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.testframework;import java.util.Properties;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.SourceType;/** * Stores the information required to run a complete test. */public class TestDescriptor {    private Rule rule;    private Properties properties;    private String description;    private int numberOfProblemsExpected;    private String code;    private SourceType sourceType;    private boolean reinitializeRule = false;   //default    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this(code, description, numberOfProblemsExpected, rule, RuleTst.DEFAULT_SOURCE_TYPE);    }        public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule, SourceType sourceType) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;        this.sourceType = sourceType;    }    public void setProperties(Properties properties) {        this.properties = properties;    }        public Properties getProperties() {        return properties;    }        public String getCode() {        return code;    }    public SourceType getSourceType() {        return sourceType;    }    public String getDescription() {        return description;    }    public int getNumberOfProblemsExpected() {        return numberOfProblemsExpected;    }    public Rule getRule() {        return rule;    }    public boolean getReinitializeRule() {        return reinitializeRule;    }    public void setReinitializeRule(boolean reinitializeRule) {        this.reinitializeRule = reinitializeRule;    }}
/** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.AssertionFailedError;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.ast.SimpleJavaNode;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.stat.DataPoint;import net.sourceforge.pmd.stat.Metric;import net.sourceforge.pmd.stat.StatisticalRule;import net.sourceforge.pmd.symboltable.SourceFileScope;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Random;/** * This class tests the Statistical Rules in PMD. * <p/> * The idea is, that we fill up 999 datapoints into * the Stat Rule, and then throw random parameters * at it. * <p/> * The three parameters which are checked are: * sigma - # Sigmas over the mean. * topscore - Only the top 5 or so items. * minimum - Only things of score 10 or better * <p/> * When more than one parameter is lumped together, then * we expect the one which would return the fewest to * determine what gets sent back. * <p/> * So, we throw each collection of parameters, where each * one is a different order into the system.  We check the * results off of what the smallest value should be. * <p/> * If you are going to work with StatisticalRule any, please * bump the "NUM_TESTS" number up to something like 128.  That * way you are more likely to identify problems.  It is set low * now to make building and running tests easier (when we aren't * touching the file.) * <p/> * Note also, that when verifying the Sigma, I wasn't quite able * to determine how many results it would return (it would vary * from -2 to 2 of what I expected.)  That is what the delta * parameter on the verify method takes.  If you can figure it * out exactly, (without stealing code from the StatRule) then * feel free to change it and tighten the deltas. */public class StatisticalRuleTest extends TestCase {    private static final int POINTS = 100;    private DataPoint points[] = new DataPoint[POINTS];    private MockStatisticalRule IUT = null;    private String testName = null;    private Random random = new Random();    public static final double MAX_MINIMUM = POINTS;    public static final double NO_MINIMUM = -1.0;    public static final double MAX_SIGMA = 5.0;    public static final double NO_SIGMA = -1.0;    public static final int MIN_TOPSCORE = 0;    public static final int NO_TOPSCORE = -1;    public static final double MEAN = 49.5;    public static final double SIGMA = 29.0115;    public static final int NUM_TESTS = 1;    public static final double DELTA = 0.005;    public StatisticalRuleTest(String name) {        super(name);        this.testName = name;    }    public void setUp() {        IUT = new MockStatisticalRule();        if (testName.endsWith("0")) {            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                SimpleNode s = new SimpleJavaNode(1);                s.setScope(new SourceFileScope("foo"));                s.testingOnly__setBeginLine(i);                s.testingOnly__setBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else if (testName.endsWith("1")) {            for (int i = POINTS - 1; i >= 0; i--) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                SimpleNode s = new SimpleJavaNode(1);                s.setScope(new SourceFileScope("foo"));                s.testingOnly__setBeginLine(i);                s.testingOnly__setBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else {            List<DataPoint> lPoints = new ArrayList<DataPoint>();            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                SimpleNode s = new SimpleJavaNode(1);                s.setScope(new SourceFileScope("foo"));                s.testingOnly__setBeginLine(i);                s.testingOnly__setBeginColumn(1);                s.testingOnly__setBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                lPoints.add(points[i]);            }            Collections.shuffle(lPoints);            for (int i = 0; i < POINTS; i++) {                IUT.addDataPoint(lPoints.get(i));            }        }    }    /**     * This test verifies that the Stat rule creates a Metric,     * with the proper values.     */    public void testMetrics() throws Throwable {        Report report = makeReport(IUT);        Iterator metrics = report.metrics();        assertTrue(metrics.hasNext());        Object o = metrics.next();        assertTrue(o instanceof Metric);        Metric m = (Metric) o;        assertEquals("test.net.sourceforge.pmd.stat.MockStatisticalRule", m.getMetricName());        assertEquals(0.0, m.getLowValue(), 0.05);        assertEquals(POINTS - 1.0, m.getHighValue(), 0.05);        assertEquals(MEAN, m.getAverage(), 0.05);        assertEquals(SIGMA, m.getStandardDeviation(), 0.05);    }    /**     * This returns a Random value for Sigma which will     * return some values.     */    public double randomSigma() {        return random.nextDouble() * 1.0;    }    /**     * This returns a Random value for Sigma which value     * is greater than the parameter.     */    public double randomSigma(int minimum) {        double minSigma = ((POINTS - 1 - minimum) - MEAN) / SIGMA;        if ((minSigma <= 0) || (minSigma > 2))            return randomSigma();        return minSigma + (random.nextDouble() * (2 - minSigma));    }    /**     * This returns the expected number of results when     * the Sigma rating is the smallest.     */    public int expectedSigma(double sigma) {        long expectedMin = Math.round(MEAN + (sigma * SIGMA));        if (((POINTS - 1) - expectedMin) < 0)            return 0;        return (POINTS - 1) - (int) expectedMin;    }    /**     * This generates a random minimum value for testing.     */    public double randomMinimum() {        return random.nextDouble() * (POINTS - 1);    }    /**     * This generates a random minimum value for which fewer     * results would be returned.     */    public double randomMinimum(int minimum) {        double diffTarget = 1.0 * (POINTS - 1 - minimum);        return (random.nextDouble() * minimum) + diffTarget;    }    /**     * This returns the expected number of reports.     * <p/>     * If the Minimum comes in at 521.569 then we expect     * 522, 523, ... 999 will pass.     */    public int expectedMinimum(double minimum) {        Double d = new Double(minimum);        return POINTS - 1 - d.intValue();    }    public void testExpectedMinimum() {        for (int i = 0; i < POINTS - 1; i++) {            assertEquals("Integer Min", POINTS - 1 - i, expectedMinimum(i * 1.0));            assertEquals("Double Min", POINTS - 1 - i, expectedMinimum((i * 1.0) + 0.5));        }    }    /**     * This returns a random value for Top Score.     */    public int randomTopScore() {        return random.nextInt(POINTS - 1);    }    /**     * This will return a random value for the Top Score     * which will return more than the minimum provided.     */    public int randomTopScore(double target) {        if (target < 0)            return 0;        return random.nextInt((new Double(target)).intValue());    }    /**     * This will return the expected number of results     * with the given Top Score.     */    public int expectedTopScore(int target) {        return target;    }    // Test Single Datapoint    public void testSingleDatapoint() {        StatisticalRule IUT = new MockStatisticalRule();        DataPoint point = new DataPoint();        point.setScore(POINTS + 1.0);        SimpleNode s = new SimpleJavaNode(1);        s.setScope(new SourceFileScope("foo"));        s.testingOnly__setBeginLine(POINTS + 1);        s.testingOnly__setBeginColumn(1);        point.setNode(s);        point.setMessage("SingleDataPoint");        IUT.addProperty("minimum", Integer.toString(POINTS));        IUT.addDataPoint(point);        Report report = makeReport(IUT);        assertEquals("Expecting only one result.", 1, report.size());    }    // Okay, we have three properties we need to    // test in Combination:    //  S = Sigma    //  T = Top Score    //  M = Minimum    //    // They are listed in decreasing order of what    // to expect.    //    // Thus testSM() should have the Sigma less than    // the minimum, so we expect the Minimum # of results.    //    public void testS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, NO_TOPSCORE, 0, 2);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            verifyResults(sigma, -1.0, -1, expectedSigma(sigma), 2);        }    }    public void testS1() throws Throwable {        testS();    }    public void testS2() throws Throwable {        testS();    }    public void testS3() throws Throwable {        testS();    }    public void testS4() throws Throwable {        testS();    }    public void testS5() throws Throwable {        testS();    }    public void testT() throws Throwable {        verifyResults(NO_SIGMA, NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            verifyResults(-1.0, -1.0, topScore, expectedTopScore(topScore), 0);        }    }    public void testT1() throws Throwable {        testT();    }    public void testT2() throws Throwable {        testT();    }    public void testT3() throws Throwable {        testT();    }    public void testT4() throws Throwable {        testT();    }    public void testT5() throws Throwable {        testT();    }    public void testM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            verifyResults(-1.0, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testM1() throws Throwable {        testM();    }    public void testM2() throws Throwable {        testM();    }    public void testM3() throws Throwable {        testM();    }    public void testM4() throws Throwable {        testM();    }    public void testM5() throws Throwable {        testM();    }    public void testST() throws Throwable {        verifyResults(randomSigma(), NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            verifyResults(sigma, NO_MINIMUM, topScore, expectedTopScore(topScore), 0);        }    }    public void testST1() throws Throwable {        testST();    }    public void testST2() throws Throwable {        testST();    }    public void testST3() throws Throwable {        testST();    }    public void testST4() throws Throwable {        testST();    }    public void testST5() throws Throwable {        testST();    }    public void testTS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            verifyResults(sigma, -1.0, topScore, expectedSigma(sigma), 2);        }    }    public void testTS1() throws Throwable {        testTS();    }    public void testTS2() throws Throwable {        testTS();    }    public void testTS3() throws Throwable {        testTS();    }    public void testTS4() throws Throwable {        testTS();    }    public void testTS5() throws Throwable {        testTS();    }    public void testSM() throws Throwable {        verifyResults(randomSigma(), MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testSM1() throws Throwable {        testSM();    }    public void testSM2() throws Throwable {        testSM();    }    public void testSM3() throws Throwable {        testSM();    }    public void testSM4() throws Throwable {        testSM();    }    public void testSM5() throws Throwable {        testSM();    }    public void testMS() throws Throwable {        verifyResults(MAX_SIGMA, randomMinimum(), NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, -1, expectedSigma(sigma), 2);        }    }    public void testMS1() throws Throwable {        testMS();    }    public void testMS2() throws Throwable {        testMS();    }    public void testMS3() throws Throwable {        testMS();    }    public void testMS4() throws Throwable {        testMS();    }    public void testMS5() throws Throwable {        testMS();    }    public void testTM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(NO_SIGMA, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTM1() throws Throwable {        testTM();    }    public void testTM2() throws Throwable {        testTM();    }    public void testTM3() throws Throwable {        testTM();    }    public void testTM4() throws Throwable {        testTM();    }    public void testTM5() throws Throwable {        testTM();    }    public void testMT() throws Throwable {        verifyResults(NO_SIGMA, randomMinimum(), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(NO_SIGMA, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testMT1() throws Throwable {        testMT();    }    public void testMT2() throws Throwable {        testMT();    }    public void testMT3() throws Throwable {        testMT();    }    public void testMT4() throws Throwable {        testMT();    }    public void testMT5() throws Throwable {        testMT();    }    public void testSTM() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, MAX_MINIMUM, randomTopScore(expectedSigma(sigma)), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testSTM1() throws Throwable {        testSTM();    }    public void testSTM2() throws Throwable {        testSTM();    }    public void testSTM3() throws Throwable {        testSTM();    }    public void testSTM4() throws Throwable {        testSTM();    }    public void testSTM5() throws Throwable {        testSTM();    }    public void testSMT() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, randomMinimum(expectedSigma(sigma)), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testSMT1() throws Throwable {        testSMT();    }    public void testSMT2() throws Throwable {        testSMT();    }    public void testSMT3() throws Throwable {        testSMT();    }    public void testSMT4() throws Throwable {        testSMT();    }    public void testSMT5() throws Throwable {        testSMT();    }    public void testTSM() throws Throwable {        int topScore = randomTopScore();        verifyResults(randomSigma(expectedTopScore(topScore)), MAX_MINIMUM, topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTSM1() throws Throwable {        testTSM();    }    public void testTSM2() throws Throwable {        testTSM();    }    public void testTSM3() throws Throwable {        testTSM();    }    public void testTSM4() throws Throwable {        testTSM();    }    public void testTSM5() throws Throwable {        testTSM();    }    public void testTMS() throws Throwable {        int topScore = randomTopScore();        verifyResults(MAX_SIGMA, randomMinimum(expectedTopScore(topScore)), topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedSigma(sigma), 2);        }    }    public void testTMS1() throws Throwable {        testTMS();    }    public void testTMS2() throws Throwable {        testTMS();    }    public void testTMS3() throws Throwable {        testTMS();    }    public void testTMS4() throws Throwable {        testTMS();    }    public void testTMS5() throws Throwable {        testTMS();    }    /**     * Verifies what happens when you pass these parameters     * into the thing.  DELTA is the amount of error allowed.     * Usually DELTA is only used for Sigma, as we really can't     * calculate it exactly.     */    public void verifyResults(double sigma, double minimum, int topScore, int expected, int delta) {        try {            setUp();            if (sigma >= 0) {                IUT.addProperty("sigma", Double.toString(sigma));            }            if (minimum >= 0) {                IUT.addProperty("minimum", Double.toString(minimum));            }            if (topScore >= 0) {                IUT.addProperty("topscore", Integer.toString(topScore));            }            Report report = makeReport(IUT);            if (delta == 0) {                assertEquals("Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore), expected, report.size());            } else {                String assertStr = "Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore) + " expected= " + Integer.toString(expected) + " +/- " + Integer.toString(delta) + " actual-result= " + report.size();                assertTrue(assertStr, report.size() >= (expected - delta));                assertTrue(assertStr, report.size() <= (expected + delta));            }        } catch (AssertionFailedError afe) {            System.err.println("******** " + testName + " ***********");            if (sigma != NO_SIGMA) {                System.err.println("SIGMA: " + Double.toString(sigma) + " EXPECT: " + Integer.toString(expectedSigma(sigma)));            }            if (minimum != NO_MINIMUM) {                System.err.println("MIN: " + Double.toString(minimum) + " EXPECT: " + Integer.toString(expectedMinimum(minimum)));            }            if (topScore != NO_TOPSCORE) {                System.err.println("TOP: " + Integer.toString(topScore) + " EXPECT: " + Integer.toString(expectedTopScore(topScore)));            }            throw afe;        }    }    public Report makeReport(Rule IUT) {        List list = new ArrayList();        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFilename(testName);        IUT.apply(list, ctx);        return report;    }}
/** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.TestCase;import net.sourceforge.pmd.stat.Metric;import java.util.Random;/** * @author David Dixon-Peugh */public class MetricTest extends TestCase {    private String testName = null;    private Random random = new Random();    /**     * Constructor for MetricTest.     *     * @param arg0     */    public MetricTest(String arg0) {        super(arg0);        this.testName = arg0;    }    public void testGetMetricName() {        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(testName, IUT.getMetricName());    }    public void testGetCount() {        int count = random.nextInt();        Metric IUT = new Metric(testName, count, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(count, IUT.getCount());    }    public void testGetTotal() {        double total = random.nextDouble();        Metric IUT = new Metric(testName, 0, total, 0.0, 0.0, 0.0, 0.0);        assertEquals(total, IUT.getTotal(), 0.05);    }    public void testGetLowValue() {        double low = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, low, 0.0, 0.0, 0.0);        assertEquals(low, IUT.getLowValue(), 0.05);    }    public void testGetHighValue() {        double high = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, high, 0.0, 0.0);        assertEquals(high, IUT.getHighValue(), 0.05);    }    public void testGetAverage() {        double mean = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, mean, 0.0);        assertEquals(mean, IUT.getAverage(), 0.05);    }    public void testGetStandardDeviation() {        double stdev = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, stdev);        assertEquals(stdev, IUT.getStandardDeviation(), 0.05);    }}
 package test.net.sourceforge.pmd.rules.finalize;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidCallingFinalizeTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("finalizers", "AvoidCallingFinalize");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.finalize;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class FinalizeDoesNotCallSuperFinalizeRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("finalizers", "FinalizeDoesNotCallSuperFinalize");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.finalize;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class FinalizeOnlyCallsSuperFinalizeRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("finalizers", "FinalizeOnlyCallsSuperFinalize");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.finalize;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class FinalizeOverloadedRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("finalizers", "FinalizeOverloaded");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.imports;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class DuplicateImportsRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("imports", "DuplicateImports");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.imports;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UnusedImportsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("imports", "UnusedImports");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.imports;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ImportFromSamePackageRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("imports", "ImportFromSamePackage");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.imports;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class DontImportJavaLangRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("imports", "DontImportJavaLang");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.javabeans;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MissingSerialVersionUIDTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() throws Exception {         rule = findRule("javabeans", "MissingSerialVersionUID");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.javabeans;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class BeanMembersShouldSerializeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("javabeans", "BeanMembersShouldSerialize");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseAssertNullInsteadOfAssertTrueTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("junit", "UseAssertNullInsteadOfAssertTrue");     }      public void testAll() throws Throwable {         runTests(rule);     } } 
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseAssertSameInsteadOfAssertTrueTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("junit", "UseAssertSameInsteadOfAssertTrue");     }      public void testAll() throws Throwable {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseAssertEqualsInsteadOfAssertTrueTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("junit", "UseAssertEqualsInsteadOfAssertTrue");     }      public void testAll() throws Throwable {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class TestClassWithoutTestCasesTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("junit", "TestClassWithoutTestCases");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class JUnitAssertionsShouldIncludeMessageTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("junit", "JUnitAssertionsShouldIncludeMessage");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class JUnitTestsShouldContainAssertsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("junit", "JUnitTestsShouldIncludeAssert");     }      public void testAll() throws Throwable {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class JUnitStaticSuiteRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("junit", "JUnitStaticSuite");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class JUnitSpellingRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("junit", "JUnitSpelling");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class SimplifyBooleanAssertionTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("junit", "SimplifyBooleanAssertion");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.junit;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryBooleanAssertionTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("junit", "UnnecessaryBooleanAssertion");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.j2ee;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UseProperClassLoaderTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("j2ee", "UseProperClassLoader");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class LongParameterListRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("codesize", "ExcessiveParameterList");         rule.addProperty("minimum", "9");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SwitchDensityTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "SwitchDensity");         rule.addProperty("minimum", "4");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst; import test.net.sourceforge.pmd.testframework.TestDescriptor;  public class ExcessiveMethodLengthTest extends SimpleAggregatorTst {     private Rule rule;     private TestDescriptor[] tests;      public void setUp() {         rule = findRule("codesize", "ExcessiveMethodLength");         tests = extractTestsFromXml(rule);     }      public void testAll() {         rule.addProperty("minimum", "10");         runTests(tests);     } /*     public void testOverrideMinimumWithTopScore() throws Throwable {         Rule r = findRule("codesize", "ExcessiveMethodLength");         r.addProperty("minimum", "1");         r.addProperty("topscore", "2");         Report rpt = new Report();         runTestFromString(tests[5].getCode(), r, rpt);         for (Iterator i = rpt.iterator(); i.hasNext();) {             RuleViolation rv = (RuleViolation)i.next();             assertTrue(rv.getLine() == 2 || rv.getLine() == 6);         }     } */  } 
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AssignmentToNonFinalStaticTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AssignmentToNonFinalStatic");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class ConfusingTernaryRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "ConfusingTernary");    }    public void testAll() {        runTests(rule);    }    /*public class BadTernaries {  public static void main(String[] args) {    int i = 0;    int j = 1;    int k = 2;    boolean x = true;    boolean y = false;    boolean z = true;    // flag all of these, lines 11 - 42:    if (i != 11) {a();} else {b();}    if (i != 12 && j != 0) {a();} else {b();}    if (i != 13 || j != 0) {a();} else {b();}    if (i != 14 && j != 0 && k != 0) {a();} else {b();}    if (i != 15 || j != 0 || k != 0) {a();} else {b();}    if (i != 16) {a();} else if (i != j) {b();} else{c();}    if (i != 17) {a();} else if (i == j) {b();} else{c();}    if (i == 18) {a();} else if (i != j) {b();} else{c();}    x = (!y ? x : y);    x = (!(x && y) ? y : z);    x = (!(x || y) ? y : z);    x = ((!x && !y) ? y : z);    x = ((!x || !y) ? y : z);    if (i != 24 && !x) {a();} else {b();}    if (i != 25 || !x) {a();} else {b();}    if (i != 26 && j != 0 && !y) {a();} else {b();}    if (i != 27 || j != 0 || !y) {a();} else {b();}    if (i != 28) {a();} else if (!x) {b();} else{c();}    if (i != 29) {a();} else if (x) {b();} else{c();}    if (i == 30) {a();} else if (!x) {b();} else{c();}    x = !(c() == y) ? y : !z;    if (!c()) {a();} else {b();}    if (c() != x) {a();} else {b();}    if (!c() != x) {a();} else {b();}    if (!c() != !x) {a();} else {b();}    if ((i != 36) || !(j == 0)) {a();} else {b();}    if ((i != 37) || !(x ? y : z)) {a();} else {b();}    if ((i != 38)) {a();} else {b();}    if (i != 39 || (j != 0 || k != 0)) {a();} else {b();}    if (i != 40 && (j != 0 && k != 0)) {a();} else {b();}    if (!x && (j != 41 && k != 0)) {a();} else {b();}    if (((x != y)) || !(x)) { a(); } else { b(); }    // don't flag these:    if (i != 0) {a();}    if (!x) {a();}    if (i == 0) {a();} else {b();}    if (i == 0 && j != 0) {a();} else {b();}    if (i == 0 || j != 0) {a();} else {b();}    if (i == 0 && !x) {a();} else {b();}    if (x) {a();} else {b();}    if (x ? y : !z) {a();} else {b();}    if (c() == !x) {a();} else {b();}    if (c() ? !x : !c()) {a();} else {b();}    if (!x && d() instanceof String) {a();} else {b();}    if (!x && (d() instanceof String)) {a();} else {b();}  }  private static void a() { }  private static void b() { }  private static boolean c() { return true; }  private static Object d() { return null; }}    */}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class NullAssignmentRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "NullAssignment");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.rules.design.PositionalIteratorRule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class PositionalIteratorRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = new PositionalIteratorRule();     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class LongClassRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("codesize", "ExcessiveClassLength");         rule.addProperty("minimum", "10");     }      public void testAll() {         runTests(rule);     } } 
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ImmutableFieldTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "ImmutableField");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class OnlyOneReturnRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "OnlyOneReturn");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class LooseCouplingTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("coupling", "LooseCoupling");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class PositionLiteralsFirstInComparisonsTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "PositionLiteralsFirstInComparisons");     }      public void testAll() {         runTests(rule);     }  }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Adding this test to validate current working code doesn't break I've been * trying to locate the article referenced. The below code stresses the NPath * rule, and according to its current style, runs 2 tests, one pass and one * fail. *  * @author Allan Caplan *  */public class NpathComplexityTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() {        rule = findRule("codesize", "NPathComplexity");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class PreserveStackTraceTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "PreserveStackTrace");    }        public void test() throws Throwable {        rule.setMessage("{0}");        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.IRuleViolation; import net.sourceforge.pmd.Report; import net.sourceforge.pmd.ReportListener; import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.stat.Metric; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst; import test.net.sourceforge.pmd.testframework.TestDescriptor;  public class UseSingletonTest extends SimpleAggregatorTst implements ReportListener {      private int callbacks;     private Rule rule;     private TestDescriptor[] tests;      public void setUp() {         rule = findRule("design", "UseSingleton");         tests = extractTestsFromXml(rule);     }      public void testAll() {         runTests(tests);     }      public void testResetState() throws Throwable {         callbacks = 0;         Report report = new Report();         report.addListener(this);         runTestFromString(tests[2].getCode(), rule, report);         runTestFromString(tests[3].getCode(), rule, report);         assertEquals(1, callbacks);     }      public void ruleViolationAdded(IRuleViolation ruleViolation) {         callbacks++;     }      public void metricAdded(Metric metric) {     } }
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class NonThreadSafeSingletonTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "NonThreadSafeSingleton");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class CompareObjectsWithEqualsTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "CompareObjectsWithEquals");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidInstanceofChecksInCatchClauseTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "AvoidInstanceofChecksInCatchClause");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidProtectedFieldInFinalClassRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AvoidProtectedFieldInFinalClass");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Adding this test to validate current working code doesn't break I've been * trying to locate the article referenced. The below code stresses the NPath * rule, and according to its current style, runs 2 tests, one pass and one * fail. *  * @author Allan Caplan */public class UseCollectionIsEmptyTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() {        rule = findRule("design", "UseCollectionIsEmpty");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UnsynchronizedStaticDateFormatterTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() {        rule = findRule("design", "UnsynchronizedStaticDateFormatter");    }    public void testAll() throws Exception{        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryLocalBeforeReturnRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "UnnecessaryLocalBeforeReturn");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class CollapsibleIfStatementsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "CollapsibleIfStatements");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class TooManyFieldsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("codesize", "TooManyFields");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyStatementNotInLoopRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptyStatementNotInLoop");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.design;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidConstantsInterfaceTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AvoidConstantsInterface");     }      public void testAll() {         runTests(rule);     }  }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.braces;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class IfElseStmtsMustUseBracesTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() throws Exception {         rule = findRule("braces", "IfElseStmtsMustUseBraces");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.braces;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class WhileLoopsMustUseBracesTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("braces", "WhileLoopsMustUseBraces");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.braces;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ForLoopsMustUseBracesTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("braces", "ForLoopsMustUseBraces");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.braces;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class IfStmtsMustUseBracesRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("braces", "IfStmtsMustUseBraces");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.migrating;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ReplaceVectorWithListTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("migrating", "ReplaceVectorWithList");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.migrating;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ReplaceEnumerationWithIteratorTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("migrating", "ReplaceEnumerationWithIterator");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.migrating;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class ByteInstantiationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("migrating", "ByteInstantiation");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.migrating;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ReplaceHashtableWithMapTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("migrating", "ReplaceHashtableWithMap");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.migrating;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidEnumAsIdentifierTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("migrating", "AvoidEnumAsIdentifier");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.migrating;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class ShortInstantiationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("migrating", "ShortInstantiation");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.migrating;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidAssertAsIdentifierTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("migrating", "AvoidAssertAsIdentifier");     }      public void testOne() throws Throwable {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.migrating;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class IntegerInstantiationTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("migrating", "IntegerInstantiation");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.migrating;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class LongInstantiationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("migrating", "LongInstantiation");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.logging.jakartacommons;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseCorrectExceptionLoggingTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("rulesets/logging-jakarta-commons.xml", "UseCorrectExceptionLogging");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.logging.jakartacommons;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ProperLoggerTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("rulesets/logging-jakarta-commons.xml", "ProperLogger");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.logging.java;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MoreThanOneLoggerTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("logging-java", "MoreThanOneLogger");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.logging.java;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SystemPrintlnTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("logging-java", "SystemPrintln");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.logging.java;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class LoggerIsNotStaticFinalTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("logging-java", "LoggerIsNotStaticFinal");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.logging.java;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidPrintStackTraceTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("logging-java", "AvoidPrintStackTrace");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.sunsecure;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class ArrayIsStoredDirectlyTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("sunsecure", "ArrayIsStoredDirectly");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.sunsecure;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class MethodReturnsInternalArrayTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("sunsecure", "MethodReturnsInternalArray");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.clone;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class CloneMethodMustImplementCloneableTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("clone", "CloneMethodMustImplementCloneable");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.clone;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class CloneThrowsCloneNotSupportedExceptionTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("clone", "CloneThrowsCloneNotSupportedException");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.clone;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ProperCloneImplementationTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("clone", "ProperCloneImplementation");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.codesize;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class NcssConstructorCountTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("codesize", "NcssConstructorCount");    }    public void testAll() {        rule.addProperty("minimum", "13");        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.codesize;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class NcssTypeCountTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("codesize", "NcssTypeCount");        rule.addProperty("minimum", "13");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.codesize;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class NcssMethodCountTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule  = findRule("codesize", "NcssMethodCount");    }    public void testAll() {        rule.addProperty("minimum", "13");        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidArrayLoopsTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "AvoidArrayLoops");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SimplifyStartsWithTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "SimplifyStartsWith");     }      public void testAll() {         runTests(rule);     } }
 /*  * Created on Jan 10, 2005   *  * $Id$  */ package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  /**  * Tests for the rule AvoidInstantiatingObjectsInLoops  *  * @author mgriffa  */ public class AvoidInstantiatingObjectsInLoopsTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "AvoidInstantiatingObjectsInLoops");     }      public void testAll() {         runTests(rule);         //FIXME see disabled rule in AvoidInstantiatingObjectsInLoops.xml     } }
 package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseArraysAsListTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "UseArraysAsList");     }      // FIXME should be able to catch case where Integer[] is passed     // as an argument... but may need to rewrite in Java for that.     public void testAll() {         runTests(rule);     } }
 /*  * Created on Jan 10, 2005   *  * $Id$  */ package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  /**  * Tests for the rule LocalVariableCouldBeFinal  *  * @author mgriffa  */ public class LocalVariableCouldBeFinalTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "LocalVariableCouldBeFinal");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class BooleanInversionTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "BooleanInversion");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryWrapperObjectCreationTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "UnnecessaryWrapperObjectCreation");     }      public void testAll() {         runTests(rule);     } }
 /*  * Created on Jan 10, 2005   *  * $Id$  */ package test.net.sourceforge.pmd.rules.optimization;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MethodArgumentCouldBeFinalTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("optimizations", "MethodArgumentCouldBeFinal");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules.optimization;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UseStringBufferForStringAppendsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("optimizations", "UseStringBufferForStringAppends");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.typeresolution.rules.imports;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UnusedImportsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("typeresolution", "UnusedImports");        rule.setMessage("{0}");        rule.setUsesTypeResolution();    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.typeresolution.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class CloneMethodMustImplementCloneableTest extends SimpleAggregatorTst {private Rule rule;public void setUp() {rule = findRule("typeresolution", "CloneMethodMustImplementCloneable");}public void testAll() {runTests(rule);}}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.typeresolution.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class LooseCouplingTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("typeresolution", "LooseCoupling");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidThrowingNullPointerExceptionTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strictexception", "AvoidThrowingNullPointerException");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ExceptionAsFlowControlTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() throws Exception {         rule = findRule("strictexception", "ExceptionAsFlowControl");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidCatchingThrowableRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strictexception", "AvoidCatchingThrowable");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  /**  * Tests the <code>AvoidRethrowingException</code> rule.  *  * @author George Thomas  */ public class AvoidRethrowingExceptionTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strictexception", "AvoidRethrowingException");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidThrowingRawExceptionTypesTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strictexception", "AvoidThrowingRawExceptionTypes");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ExceptionSignatureDeclarationRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strictexception", "SignatureDeclareThrowsException");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules.strictexception;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidCatchingNPETest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("strictexception", "AvoidCatchingNPE");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.strings;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AppendCharacterWithCharTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strings", "AppendCharacterWithChar");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class StringBufferInstantiationWithCharTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("strings", "StringBufferInstantiationWithChar");    }    public void testAll() {        runTests(new TestDescriptor[] {                new TestDescriptor(TEST1, "OK", 0, rule),                new TestDescriptor(TEST2, "failure case", 1, rule),       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        "  StringBuffer sb = new StringBuffer(\"c\");" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        "  StringBuffer sb = new StringBuffer('c');" + PMD.EOL +        "}";}
 package test.net.sourceforge.pmd.rules.strings;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryCaseChangeRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("rulesets/strings.xml", "UnnecessaryCaseChange");     }      public void testAll() {         runTests(rule);     }  /*    private static final String TEST5 =     "public class Foo {" + PMD.EOL +     " private boolean baz(String[] buz) {" + PMD.EOL +     "  return buz[2].toUpperCase().equalsIgnoreCase(\"foo\");" + PMD.EOL +     " }" + PMD.EOL +     "}"; */  }
 package test.net.sourceforge.pmd.rules.strings;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UselessStringValueOfTest extends SimpleAggregatorTst {  private Rule rule;  public void setUp() { rule = findRule("rulesets/strings.xml", "UselessStringValueOf"); }  public void testAll() { runTests(rule); } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class StringInstantiationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("strings", "StringInstantiation");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class ConsecutiveLiteralAppendsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("strings", "ConsecutiveLiteralAppends");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.strings;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class StringToStringRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strings", "StringToString");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */ package test.net.sourceforge.pmd.rules.strings;  import net.sourceforge.pmd.PMD; import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst; import test.net.sourceforge.pmd.testframework.TestDescriptor;  public class InefficientStringBufferingTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("strings", "InefficientStringBuffering");     }      public void testAll() {        runTests(new TestDescriptor[] {                new TestDescriptor(TEST1, "concatenating a literal to a method return value", 1, rule),                new TestDescriptor(TEST2, "same as TEST1, but in SB constructor", 1, rule),                new TestDescriptor(TEST3, "chained appends", 0, rule),                new TestDescriptor(TEST4, "concatenating two literals in SB constructor", 0, rule),                new TestDescriptor(TEST5, "concatenating two literals post-construction", 0, rule),                new TestDescriptor(TEST6, "case where concatenation is not a child of a BlockStatement, but instead is a child of an ExplicitConstructorInvocation", 0, rule),                new TestDescriptor(TEST7, "don't error out on array instantiation", 0, rule),                new TestDescriptor(TEST8, "usage of the StringBuffer constructor that takes an int", 0, rule),                new TestDescriptor(TEST9, "nested", 0, rule),                new TestDescriptor(TEST10, "looking up too high", 0, rule),                new TestDescriptor(TEST11, "looking too deep", 0, rule),                new TestDescriptor(TEST12, "concatenating two non-literals", 1, rule),                new TestDescriptor(TEST13, "concatenating method + int", 0, rule),                new TestDescriptor(TEST14, "JTextArea.append", 0, rule),                new TestDescriptor(TEST15, "don't get thrown off by a buried literal", 1, rule),                new TestDescriptor(TEST16, "sb.delete shouldn't trigger it", 0, rule),                new TestDescriptor(TEST17, "skip additions involving static finals, compiler will do constant folding for these", 0, rule),                new TestDescriptor(TEST18, "for statement without braces", 1, rule),                new TestDescriptor(TEST19, "if statement without braces", 1, rule),                new TestDescriptor(TEST20, "3 args version of StringBuffer.append", 0, rule),                new TestDescriptor(TEST21, "compile-time concats are ok", 0, rule),                new TestDescriptor(TEST22, "compile-time concats are ok, v2", 0, rule),        });     }     private static final String TEST1 =     "public class Foo {" + PMD.EOL +     " private void baz() {" + PMD.EOL +     "  StringBuffer sb = new StringBuffer();" + PMD.EOL +     "  sb.append(\"hello\"+ world()); "+     " }" + PMD.EOL +     "}";     private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " private void baz() {" + PMD.EOL +        "  StringBuffer sb = new StringBuffer(\"hello\"+ world());" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " private void baz() {" + PMD.EOL +        "  StringBuffer sb = new StringBuffer();" + PMD.EOL +        "  sb.append(\"hello\").append(world()); "+        " }" + PMD.EOL +        "}";     private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " private void baz() {" + PMD.EOL +        "  StringBuffer sb = new StringBuffer(\"hello\"+ \"world\");" + PMD.EOL +        " }" + PMD.EOL +        "}";        private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " private void baz() {" + PMD.EOL +        "  StringBuffer sb = new StringBuffer();" + PMD.EOL +        "  sb.append(\"hello\"+\"world\"); "+        " }" + PMD.EOL +        "}";     private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " public Foo() {" + PMD.EOL +        "  super(\"CauseMsg:\" + ex.getMessage(), ex); " + PMD.EOL +        " }" + PMD.EOL +        "}";      private static final String TEST7 =         "public class Foo {" + PMD.EOL +         " public void bar() {" + PMD.EOL +         "  int t[] = new int[x+y+1];" + PMD.EOL +         " }" + PMD.EOL +         "}";      private static final String TEST8 =        "public class Foo {" + PMD.EOL +        " public int foor() {return 2;}" + PMD.EOL +        " public void bar(int x) {" + PMD.EOL +        "  StringBuffer buf = new StringBuffer(1 + foo());" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST9 =        "public class Foo {" + PMD.EOL +        " public void bar(int x) {" + PMD.EOL +        "  StringBuffer buf = new StringBuffer(x);" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST10 =        "public class Foo {" + PMD.EOL +        " public void bar() {" + PMD.EOL +        "  if (foo) {" + PMD.EOL +        "   StringBuffer buf = new StringBuffer();" + PMD.EOL +        "   buf.append(\"hello\");" + PMD.EOL +        "   Object x = a(\"world\" + x, buf.toString());" + PMD.EOL +        "  }" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST11 =        "public class Foo {" + PMD.EOL +        " public void bar(int i) {" + PMD.EOL +        "  StringBuffer buf = new StringBuffer();" + PMD.EOL +        "  buf.append(getFoo(getBar(i + \"hi\")));" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST12 =        "public class Foo {" + PMD.EOL +        " public void bar(String a, String b) {" + PMD.EOL +        "  StringBuffer buf = new StringBuffer();" + PMD.EOL +        "  buf.append(a + b);" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST13 =        "public class Foo {" + PMD.EOL +        " public void bar(Date a) {" + PMD.EOL +        "  StringBuffer buf = new StringBuffer();" + PMD.EOL +        "  buf.append(a.getYear() + 1900);" + PMD.EOL +        " }" + PMD.EOL +        "}";     private static final String TEST14 =        "public class Foo {" + PMD.EOL +        " public void bar(JTextArea jta) {" + PMD.EOL +        "  jta.append(f + \"hi\");" + PMD.EOL +        " }" + PMD.EOL +        "}";      private static final String TEST15 =         "public class Foo {" + PMD.EOL +         " private void baz() {" + PMD.EOL +         "  StringBuffer sb = new StringBuffer(\"hello\"+ System.getProperty(\"blah\"));" + PMD.EOL +         " }" + PMD.EOL +         "}";      private static final String TEST16 =         "public class Foo {" + PMD.EOL +         " public void bar(StringBuffer sb) {" + PMD.EOL +         "  sb.delete(x, y+z);" + PMD.EOL +         " }" + PMD.EOL +         "}";      private static final String TEST17 =         "public class Foo {" + PMD.EOL +         " public static final String FOO = \"bar\";" + PMD.EOL +         " public void bar(StringBuffer sb) {" + PMD.EOL +         "  sb.append(\"foo\" + FOO);" + PMD.EOL +         " }" + PMD.EOL +         "}";         private static final String TEST18 =         "public class Foo {" + PMD.EOL +         " private void baz() {" + PMD.EOL +         "  StringBuffer sb = new StringBuffer();" + PMD.EOL +         "  for(int ix = 0; ix < 100; ix++) "+         "      sb.append(\"hello\"+ world()); "+         " }" + PMD.EOL +         "}";      private static final String TEST19 =         "public class Foo {" + PMD.EOL +         " private void baz() {" + PMD.EOL +         "  StringBuffer sb = new StringBuffer();" + PMD.EOL +         "  if(true) "+         "      sb.append(\"hello\"+ world()); "+         " }" + PMD.EOL +         "}";      private static final String TEST20 =         "public class Foo {" + PMD.EOL +         " private void baz(StringBuffer s, char[] chars, int start, int end) {" + PMD.EOL +         "  s.append(chars, start, start - end);" + PMD.EOL +         " }" + PMD.EOL +         "}";       private static final String TEST21 =             "public class Foo {" + PMD.EOL +             " private void baz() {" + PMD.EOL +             "StringBuffer buffer = new StringBuffer(" + PMD.EOL +             "\"a\" + \"b\" + \"c\");" + PMD.EOL +             "} }";      private static final String TEST22 =             "public class Foo {" + PMD.EOL +             "static final String BAR = \"foo\";" + PMD.EOL +             " private void baz() {" + PMD.EOL +             "StringBuffer buffer = new StringBuffer(" + PMD.EOL +             "\"a\" + BAR + \"b\" + BAR);" + PMD.EOL +             "} }"; }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class InefficientEmptyStringCheckTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("strings", "InefficientEmptyStringCheck");    }    public void testAll() {        runTests(rule);    }}
package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UseIndexOfCharTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() {        rule = findRule("rulesets/strings.xml", "UseIndexOfChar");    }    public void testAll() {       runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class InsufficientStringBufferDeclarationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("strings", "InsufficientStringBufferDeclaration");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules.strings;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseStringBufferLengthTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("rulesets/strings.xml", "UseStringBufferLength");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules.strings;  import java.util.Set;  import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.rules.strings.AvoidDuplicateLiteralsRule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidDuplicateLiteralsRuleTest extends SimpleAggregatorTst {     public void testAll() {         Rule rule = findRule("strings", "AvoidDuplicateLiterals");         rule.addProperty("threshold", "2");         runTests(rule);     }      public void testStringParserEmptyString() {         AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');         Set res = p.parse("");         assertTrue(res.isEmpty());     }      public void testStringParserSimple() {         AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');         Set res = p.parse("a,b,c");         assertEquals(3, res.size());         assertTrue(res.contains("a"));         assertTrue(res.contains("b"));         assertTrue(res.contains("c"));     }      public void testStringParserEscapedChar() {         AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');         Set res = p.parse("a,b,\\,");         assertEquals(3, res.size());         assertTrue(res.contains("a"));         assertTrue(res.contains("b"));         assertTrue(res.contains(","));     }      public void testStringParserEscapedEscapedChar() {         AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');         Set res = p.parse("a,b,\\\\");         assertEquals(3, res.size());         assertTrue(res.contains("a"));         assertTrue(res.contains("b"));         assertTrue(res.contains("\\"));     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class NoPackageTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("naming", "NoPackage");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AbstractClassWithoutAbstractMethodTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AbstractClassWithoutAbstractMethod");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ExcessiveImportsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("coupling", "ExcessiveImports");         rule.addProperty("minimum", "3");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SuspiciousConstantFieldNameTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "SuspiciousConstantFieldName");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyStaticInitializerRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptyStaticInitializer");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class OverrideBothEqualsAndHashcodeTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "OverrideBothEqualsAndHashcode");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class JumbledIncrementerRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("basic", "JumbledIncrementer");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class FinalizeShouldBeProtectedRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("finalizers", "FinalizeShouldBeProtected");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptySynchronizedBlockRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptySynchronizedBlock");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MethodWithSameNameAsEnclosingClassRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "MethodWithSameNameAsEnclosingClass");     }      public void testAll() {         runTests(rule);     } }
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.ExcessivePublicCount;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class ExcessivePublicCountTest extends SimpleAggregatorTst {    private Rule rule;        public void setUp() {        rule = new ExcessivePublicCount();    }        public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst; import test.net.sourceforge.pmd.testframework.TestDescriptor;  public class UncommentedEmptyConstructorRuleTest extends SimpleAggregatorTst {      private Rule rule;     private TestDescriptor[] tests;      public void setUp() {         rule = findRule("design", "UncommentedEmptyConstructor");         tests = extractTestsFromXml(rule);     }      public void testDefault() {         runTests(tests);     }      public void testIgnoredConstructorInvocation() {         rule.addProperty("ignoreExplicitConstructorInvocation", "true");         runTests(new TestDescriptor[]{             new TestDescriptor(tests[0].getCode(), "simple failure", 1, rule),             new TestDescriptor(tests[1].getCode(), "only 'this(...)' failure", 1, rule),             new TestDescriptor(tests[2].getCode(), "only 'super(...)' failure", 1, rule),             new TestDescriptor(tests[3].getCode(), "single-line comment is OK", 0, rule),             new TestDescriptor(tests[4].getCode(), "multiple-line comment is OK", 0, rule),             new TestDescriptor(tests[5].getCode(), "Javadoc comment is OK", 0, rule),             new TestDescriptor(tests[6].getCode(), "ok", 0, rule),             new TestDescriptor(tests[7].getCode(), "with 'this(...)' ok", 0, rule),             new TestDescriptor(tests[8].getCode(), "with 'super(...)' ok", 0, rule),             new TestDescriptor(tests[9].getCode(), "private is ok", 0, rule),         });     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class InstantiationToGetClassRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "InstantiationToGetClass");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryParenthesesTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() throws Exception {         rule = findRule("controversial", "UnnecessaryParentheses");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class BooleanInstantiationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "BooleanInstantiation");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MisplacedNullCheckTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "MisplacedNullCheck");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnusedPrivateFieldRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("unusedcode", "UnusedPrivateField");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class LongVariableRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("naming", "LongVariable");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class OptimizableToArrayCallTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "OptimizableToArrayCall");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseArrayListInsteadOfVectorTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("optimizations", "UseArrayListInsteadOfVector");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ClassNamingConventionsTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("naming", "ClassNamingConventions");     }          public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class DontImportSunTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "DontImportSun");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class VariableNamingConventionsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "VariableNamingConventions");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnusedLocalVariableTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("unusedcode", "UnusedLocalVariable");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AssignmentInOperandTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "AssignmentInOperand");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class BigIntegerInstantiationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "BigIntegerInstantiation");    }    public void testAll() {        runTests(rule);    }        }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ForLoopShouldBeWhileLoopRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "ForLoopShouldBeWhileLoop");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class BadComparisonTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "BadComparison");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnusedFormalParameterRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("unusedcode", "UnusedFormalParameter");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SimpleDateFormatNeedsLocaleRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "SimpleDateFormatNeedsLocale");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class DefaultPackageTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "DefaultPackage");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ShortMethodNameTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "ShortMethodName");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class FinalFieldCouldBeStaticRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "FinalFieldCouldBeStatic");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ShortVariableRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "ShortVariable");         rule.addProperty("pluginname", "true");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import java.io.StringReader;  import net.sourceforge.pmd.PMD; import net.sourceforge.pmd.Report; import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.RuleContext; import net.sourceforge.pmd.RuleSet; import net.sourceforge.pmd.RuleViolation; import net.sourceforge.pmd.rules.XPathRule; import test.net.sourceforge.pmd.testframework.RuleTst;  /**  * @author daniels  */ public class XPathRuleTest extends RuleTst {      XPathRule rule;      public void setUp() {         rule = new XPathRule();         rule.setMessage("XPath Rule Failed");     }      public void testPluginname() throws Throwable {         Rule rule = new XPathRule();         rule.addProperty("xpath", "//VariableDeclaratorId[string-length(@Image) < 3]");         rule.setMessage("{0}");         rule.addProperty("pluginname", "true");         PMD p = new PMD();         RuleContext ctx = new RuleContext();         Report report = new Report();         ctx.setReport(report);         ctx.setSourceCodeFilename("n/a");         RuleSet rules = new RuleSet();         rules.addRule(rule);         p.processFile(new StringReader(TEST1), rules, ctx);         RuleViolation rv = (RuleViolation) report.iterator().next();         assertEquals("a", rv.getDescription());     }      public void testVariables() throws Throwable {         Rule rule = new XPathRule();         rule.addProperty("xpath", "//VariableDeclaratorId[@Image=$var]");         rule.setMessage("Avoid vars");         rule.addProperty("var", "fiddle");         PMD p = new PMD();         RuleContext ctx = new RuleContext();         Report report = new Report();         ctx.setReport(report);         ctx.setSourceCodeFilename("n/a");         RuleSet rules = new RuleSet();         rules.addRule(rule);         p.processFile(new StringReader(TEST2), rules, ctx);         RuleViolation rv = (RuleViolation) report.iterator().next();         assertEquals(3, rv.getBeginLine());     }      private static final String TEST1 =             "public class Foo {" + PMD.EOL +             " int a;" + PMD.EOL +             "}";      private static final String TEST2 =             "public class Foo {" + PMD.EOL +             " int faddle;" + PMD.EOL +             " int fiddle;" + PMD.EOL +             "}"; }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EqualsNullRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "EqualsNull");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class CallSuperInConstructorTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "CallSuperInConstructor");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UselessOverridingMethodTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "UselessOverridingMethod");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SuspiciousEqualsMethodNameRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "SuspiciousEqualsMethodName");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidDollarSignsRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("naming", "AvoidDollarSigns");     }      public void testAll() {         runTests(rule);     }  }
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class BrokenNullCheckTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "BrokenNullCheck");    }       public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import java.util.Iterator;  import net.sourceforge.pmd.Report; import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.RuleViolation; import test.net.sourceforge.pmd.testframework.RuleTst; import test.net.sourceforge.pmd.testframework.TestDescriptor;  public class CyclomaticComplexityTest extends RuleTst {     private Rule rule;     private TestDescriptor[] tests;      public void setUp() {         rule = findRule("codesize", "CyclomaticComplexity");         tests = extractTestsFromXml(rule);     }      public void testOneMethod() throws Throwable {         rule.addProperty("reportLevel", "1");         Report report = new Report();         runTestFromString(tests[0].getCode(), rule, report);         Iterator i = report.iterator();         RuleViolation rv = (RuleViolation) i.next();         assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);     }      public void testNastyComplicatedMethod() throws Throwable {         rule.addProperty("reportLevel", "10");         Report report = new Report();         runTestFromString(tests[1].getCode(), rule, report);         Iterator i = report.iterator();         RuleViolation rv = (RuleViolation) i.next();         assertTrue(rv.getDescription().indexOf("Highest = 11") != -1);     }      public void testConstructor() throws Throwable {         rule.addProperty("reportLevel", "1");         Report report = new Report();         runTestFromString(tests[2].getCode(), rule, report);         Iterator i = report.iterator();         RuleViolation rv = (RuleViolation) i.next();         assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);     }      public void testLessComplicatedThanReportLevel() throws Throwable {         rule.addProperty("reportLevel", "10");         Report report = new Report();         runTestFromString(tests[0].getCode(), rule, report);         assertEquals(0, report.size());     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyTryBlockRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptyTryBlock");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ClassCastExceptionWithToArrayTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("basic", "ClassCastExceptionWithToArray");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ReturnFromFinallyBlockTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "ReturnFromFinallyBlock");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class CouplingBetweenObjectsTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("coupling", "CouplingBetweenObjects");         rule.addProperty("threshold", "2");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UncommentedEmptyMethodRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "UncommentedEmptyMethod");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class CloseResourceTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "CloseResource");        rule.addProperty("types", "Connection,Statement,ResultSet");  //Default    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnusedPrivateMethodRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("unusedcode", "UnusedPrivateMethod");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class DefaultLabelNotLastInSwitchStmtRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "DefaultLabelNotLastInSwitchStmt");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseLocaleWithCaseConversionsRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "UseLocaleWithCaseConversions");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SimplifyConditionalTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "SimplifyConditional");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class UnnecessaryReturnTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "UnnecessaryReturn");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SuspiciousHashcodeMethodNameRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "SuspiciousHashcodeMethodName");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidReassigningParametersTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AvoidReassigningParameters");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnusedModifierRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("controversial", "UnusedModifier");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MethodNamingConventionsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "MethodNamingConventions");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class EmptyCatchBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "EmptyCatchBlock");    }    public void testAll() {        runTests(rule);    }}
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class PackageCaseTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "PackageCase");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class NonStaticInitializerRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "NonStaticInitializer");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class IdempotentOperationsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "IdempotentOperations");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SwitchStmtsShouldHaveDefaultRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "SwitchStmtsShouldHaveDefault");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SimplifyBooleanReturnsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "SimplifyBooleanReturns");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AbstractNamingTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("naming", "AbstractNaming");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryFinalModifierTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "UnnecessaryFinalModifier");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UselessAssignmentRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         //rule = findRule("rulesets/scratchpad.xml", "UselessAssignment");     }      public void testAll() {         //FIXME: runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyWhileStmtRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptyWhileStmt");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnconditionalIfStatementRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "UnconditionalIfStatement");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyIfStmtRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptyIfStmt");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class MissingStaticMethodInNonInstantiatableClassTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "MissingStaticMethodInNonInstantiatableClass");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class AvoidNonConstructorMethodsWithClassNameTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("naming", "AvoidNonConstructorMethodsWithClassName");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class DoubleCheckedLockingTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "DoubleCheckedLocking");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MisleadingVariableNameTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("naming", "MisleadingVariableName");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidSynchronizedAtMethodLevelTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AvoidSynchronizedAtMethodLevel");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidDecimalLiteralsInBigDecimalConstructorTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("basic", "AvoidDecimalLiteralsInBigDecimalConstructor");     }      public void testAll() {         runTests(rule);     }  }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidFieldNameMatchingMethodNameTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("naming", "AvoidFieldNameMatchingMethodName");     }      public void testAll() {         runTests(rule);     } } 
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class AvoidThreadGroupTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "AvoidThreadGroup");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryTemporariesTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "UnnecessaryConversionTemporary");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class SimplifyBooleanExpressionsRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "SimplifyBooleanExpressions");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnusedNullCheckInEqualsTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "UnusedNullCheckInEquals");     }      public void testAll() {         runTests(rule);         //FIXME: new TestDescriptor(TESTN, "shouldn't this fail?", 1, rule),     }      /*private static final String TESTN =             "public class Foo {" + PMD.EOL +             " public void bar() {" + PMD.EOL +             "  if (x != null && y.equals(x)) {} " + PMD.EOL +             " }" + PMD.EOL +             "}";     */  }
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class SingularFieldRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("controversial", "SingularField");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyFinallyBlockRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptyFinallyBlock");     }      public void testAll() {         runTests(rule);     } }
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UseNotifyAllInsteadOfNotifyTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "UseNotifyAllInsteadOfNotify");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AvoidDeeplyNestedIfStmtsRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("design", "AvoidDeeplyNestedIfStmts");         rule.addProperty("problemDepth", "3");     }      public void testAll() {         runTests(rule);     } }
/* * Created on 11.12.2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** *  *  * @author Sven * @version $Revision$ *  * $Log$ * Revision 1.1  2006/12/11 17:24:58  holobender * added dataflowanomaly-analysis test * * */public class DataflowAnomalyAnalysisTest extends SimpleAggregatorTst {        private Rule rule;        /* (non-Javadoc)     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        rule = findRule("controversial", "DataflowAnomalyAnalysis");    }        public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptySwitchStmtRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("basic", "EmptySwitchStatements");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class AvoidUsingOctalValuesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "AvoidUsingOctalValues");    }    public void testAll() {        runTests(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class AvoidFieldNameMatchingTypeNameTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("naming", "AvoidFieldNameMatchingTypeName");    }    public void testAll() {        runTests(rule);    }}
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class AtLeastOneConstructorRuleTest extends SimpleAggregatorTst {      private Rule rule;      public void setUp() {         rule = findRule("controversial", "AtLeastOneConstructor");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.SourceType;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UselessOperationOnImmutableTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("basic", "UselessOperationOnImmutable");    }    // TODO - should use symbol table to catch all misuses of these types    public void testAll() {        runTests(new TestDescriptor[]{            new TestDescriptor(TEST1, "useless operation on BigDecimal", 1, rule),            new TestDescriptor(TEST2, "useless operation on BigInteger", 1, rule),            new TestDescriptor(TEST3, "using the result, so OK", 0, rule),            new TestDescriptor(TEST4, "using the result in a method call, so OK", 0, rule),            new TestDescriptor(TEST6, "BigInteger obtained from compound method call", 0, rule),        });        runTests(new TestDescriptor[]{                new TestDescriptor(TEST5, "Using generics on List, OK", 0, rule,SourceType.JAVA_15),            });    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            " public void foo() {" + PMD.EOL +            "  BigDecimal bd = new BigDecimal(5);" + PMD.EOL +            "  bd.add(new BigDecimal(5));" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST2 =            "public class Foo {" + PMD.EOL +            " public void foo() {" + PMD.EOL +            "  BigInteger bi = new BigInteger(5);" + PMD.EOL +            "  bi.add(new BigInteger(5));" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST3 =            "public class Foo {" + PMD.EOL +            " public void foo() {" + PMD.EOL +            "  BigInteger bi = new BigInteger(5);" + PMD.EOL +            "  bi = bi.add(new BigInteger(5));" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST4 =            "public class Foo {" + PMD.EOL +            " public void foo() {" + PMD.EOL +            "  BigInteger bi = new BigInteger(5);" + PMD.EOL +            "  bar(bi.add(new BigInteger(5)));" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        "    List<BigDecimal> getSolution() {" + PMD.EOL +        "        List<BigDecimal> result = new ArrayList<BigDecimal>();" + PMD.EOL +        "        for (int i = 0; i < size(); i++) {" + PMD.EOL +        "           result.add(entry(size(),i).negate());" + PMD.EOL +        "           result.add(this.equations[i].check(solution));" + PMD.EOL +        "        }" + PMD.EOL +        "    }" + PMD.EOL +        "}";    private static final String TEST6 =        "public class Foo {" + PMD.EOL +        "    public String toString() {" + PMD.EOL +        "    Bar _b;" + PMD.EOL +        "        java.math.BigInteger n = _b.getBigIntContainer().n;" + PMD.EOL +        "        return n.toString();" + PMD.EOL +        "    }" + PMD.EOL +        "}";}
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class EmptyFinalizerRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("finalizers", "EmptyFinalizer");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class UnnecessaryConstructorTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("controversial", "UnnecessaryConstructor");     }      public void testAll() {         runTests(rule);     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class AccessorClassGenerationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "AccessorClassGeneration");    }    public void testAll() {        runTests(rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousOctalEscapeTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("controversial", "SuspiciousOctalEscape");    }        public void testAll() {        runTests(new TestDescriptor[]{            new TestDescriptor(TEST1, "ok use of octal", 0, rule),            new TestDescriptor(TEST2, "should be flagged", 1, rule),            new TestDescriptor(TEST3, "should be flagged - different octal", 1, rule),            new TestDescriptor(TEST4, "should be flagged - different octal", 1, rule),        });    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x = \128;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST2 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  System.out.println(\"foo = \\128\");" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  System.out.println(\"foo = \\0008\");" + PMD.EOL +        " }" + PMD.EOL +        "}";        private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  System.out.println(\"foo = \\4008\");" + PMD.EOL +        " }" + PMD.EOL +        "}";    }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class MissingBreakInSwitchTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "MissingBreakInSwitch");     }      public void testAll() {         runTests(rule);     } }
 /**  * BSD-style license; for more info see http://pmd.sourceforge.net/license.html  */ package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class ConstructorCallsOverridableMethodTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "ConstructorCallsOverridableMethod");     }      public void testAll() {         runTests(rule);         //FIXME new TestDescriptor(BUG_985989, "bug report 985989, ", 1, rule),     }      /*private static final String BUG_985989 =             "public class Test {" + PMD.EOL +             "public static class SeniorClass {" + PMD.EOL +             "  public SeniorClass(){" + PMD.EOL +             "    toString(); //may throw NullPointerException if overridden" + PMD.EOL +             "  }" + PMD.EOL +             "  public String toString(){" + PMD.EOL +             "    return \"IAmSeniorClass\";" + PMD.EOL +             "  }" + PMD.EOL +             "}" + PMD.EOL +             "public static class JuniorClass extends SeniorClass {" + PMD.EOL +             "  private String name;" + PMD.EOL +             "  public JuniorClass(){" + PMD.EOL +             "    super(); //Automatic call leads to NullPointerException" + PMD.EOL +             "    name = \"JuniorClass\";" + PMD.EOL +             "  }" + PMD.EOL +             "  public String toString(){" + PMD.EOL +             "    return name.toUpperCase();" + PMD.EOL +             "  }" + PMD.EOL +             "}" + PMD.EOL +             "public static void main (String[] args) {" + PMD.EOL +             "  System.out.println(\": \"+new SeniorClass());" + PMD.EOL +             "  System.out.println(\": \"+new JuniorClass());" + PMD.EOL +             "}" + PMD.EOL +             "}";*/ }   
 package test.net.sourceforge.pmd.rules;  import net.sourceforge.pmd.Rule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class NonCaseLabelInSwitchStatementRuleTest extends SimpleAggregatorTst {     private Rule rule;      public void setUp() {         rule = findRule("design", "NonCaseLabelInSwitchStatement");     }      public void testAll() {         runTests(rule);     } }
package test.net.sourceforge.pmd.properties;import java.util.HashMap;import java.util.Map;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.TypeProperty;/** */public class TypePropertyTest extends AbstractPropertyDescriptorTester {public static final Class[] classes = new Class[] { String.class, Integer.class, int.class, HashMap.class, Map.class };public TypePropertyTest() {super();}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return randomChoice(classes);Object[] values = new Object[count];for (int i=0; i<values.length; i++) values[i] = createValue(1);return values;}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new TypeProperty("testType", "Test type property", Byte.class, 1.0f) :new TypeProperty("testType", "Test type property", classes, 1.0f);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.BooleanProperty;/** * @author Brian Remedios */public class BooleanPropertyTest extends AbstractPropertyDescriptorTester {public BooleanPropertyTest() {super();}/** * Method createValue. * @param valueCount int * @return Object */public Object createValue(int valueCount) {if (valueCount == 1) return System.currentTimeMillis() % 1 > 0 ?Boolean.TRUE : Boolean.FALSE;Boolean[] values = new Boolean[valueCount];for (int i=0; i<values.length; i++) values[i] = (Boolean)createValue(1);return values;}/** * Method createProperty. * @param maxValues int * @return PropertyDescriptor */public PropertyDescriptor createProperty(int maxValues) {return maxValues == 1 ?new BooleanProperty("testBoolean", "Test boolean property", false, 1.0f) :new BooleanProperty("testBoolean", "Test boolean property", new boolean[] {false}, 1.0f, maxValues);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.StringProperty;/** */public class StringPropertyTest extends AbstractPropertyDescriptorTester {private static final int maxStringLength = 52;private static final char delimiter = '|';private static final char[] charSet = filter(allChars.toCharArray(), delimiter);public StringPropertyTest() {super();}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return newString();String[] values = new String[count];for (int i=0; i<count; i++) values[i] = (String)createValue(1);return values;}/** * Method newString. * @return String */private String newString() {int strLength = randomInt(0, maxStringLength);char[] chars = new char[strLength];for (int i=0; i<chars.length; i++) chars[i] = randomCharIn(charSet);return new String(chars);}/** * Method randomCharIn. * @param chars char[] * @return char */private char randomCharIn(char[] chars) {return randomChar(chars);}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new StringProperty("testString", "Test string property", "brian", 1.0f) :new StringProperty("testString", "Test string property", new String[] {"hello", "world"}, 1.0f, delimiter);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.CharacterProperty;/** */public class CharacterPropertyTest extends AbstractPropertyDescriptorTester {private static final char delimiter = '|';private static final char[] charSet = filter(allChars.toCharArray(), delimiter);public CharacterPropertyTest() {super();}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return new Character(randomChar(charSet));Character[] values = new Character[count];for (int i=0; i<values.length; i++) values[i] = (Character)createValue(1);return values;}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new CharacterProperty("testCharacter", "Test character property", 'a', 1.0f) :new CharacterProperty("testCharacter", "Test character property", new char[] {'a', 'b', 'c'}, 1.0f, delimiter);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.IntegerProperty;/** */public class IntegerPropertyTest extends AbstractPropertyDescriptorTester {public IntegerPropertyTest() {super();// TODO Auto-generated constructor stub}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return new Integer((int)(System.currentTimeMillis() % 100));Integer[] values = new Integer[count];for (int i=0; i<values.length; i++) values[i] = (Integer)createValue(1);return values;}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new IntegerProperty("testInteger", "Test integer property", 9, 1.0f) :new IntegerProperty("testInteger", "Test integer property", new int[] {-1,0,1,2}, 1.0f, maxCount);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.FloatProperty;/** */public class FloatPropertyTest extends AbstractPropertyDescriptorTester {public FloatPropertyTest() {super();}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return new Float((int)(System.currentTimeMillis() % 100));Float[] values = new Float[count];for (int i=0; i<values.length; i++) values[i] = (Float)createValue(1);return values;}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new FloatProperty("testFloat", "Test float property", 9.0f, 1.0f) :new FloatProperty("testFloat", "Test float property", new float[] {-1,0,1,2}, 1.0f, maxCount);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.DoubleProperty;/** */public class DoublePropertyTest extends AbstractPropertyDescriptorTester {public DoublePropertyTest() {super();}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return new Double((int)(System.currentTimeMillis() % 100));Double[] values = new Double[count];for (int i=0; i<values.length; i++) values[i] = (Double)createValue(1);return values;}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new DoubleProperty("testDouble", "Test double property", 9.0, 1.0f) :new DoubleProperty("testDouble", "Test double property", new double[] {-1,0,1,2}, 1.0f, maxCount);}}
package test.net.sourceforge.pmd.properties;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.cpd.ReportException;import net.sourceforge.pmd.util.CollectionUtil;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;public class PropertyAccessorTest extends SimpleAggregatorTst {    private AbstractRule rule;    public void setUp() {        rule = new NonRuleWithAllPropertyTypes();    }    public static boolean areEqual(int[] a, int[] b) {    if (a.length != b.length) return false;    for (int i=0; i<a.length; i++) {    if (a[i] != b[i]) return false;    }    return true;    }       public static boolean areEqual(boolean[] a, boolean[] b) {    if (a.length != b.length) return false;    for (int i=0; i<a.length; i++) {    if (a[i] != b[i]) return false;    }    return true;    }        public void testIntegers() {    rule.setProperty(NonRuleWithAllPropertyTypes.singleInt, new Integer(0));        assertTrue(rule.getIntProperty(NonRuleWithAllPropertyTypes.singleInt) == 0);            rule.setProperties(NonRuleWithAllPropertyTypes.multiInt, new Object[] {new Integer(0), new Integer(1)});        assertTrue(areEqual(rule.getIntProperties(NonRuleWithAllPropertyTypes.multiInt), new int[]{0, 1}));                boolean exceptionOccurred = false;        try {        rule.setProperties(NonRuleWithAllPropertyTypes.singleInt, new Object[] {new Integer(0), new Integer(1)});        } catch (Exception ex) {        exceptionOccurred = true;        }        assertTrue(exceptionOccurred);                exceptionOccurred = false;        try {        rule.setProperty(NonRuleWithAllPropertyTypes.multiInt, new Integer(0));        } catch (Exception ex) {        exceptionOccurred = true;        }        assertTrue(exceptionOccurred);    }         public void testBooleans() {    rule.setProperty(NonRuleWithAllPropertyTypes.singleBool, Boolean.FALSE);        assertFalse(rule.getBooleanProperty(NonRuleWithAllPropertyTypes.singleBool));            rule.setProperties(NonRuleWithAllPropertyTypes.multiBool, new Boolean[] {Boolean.TRUE, Boolean.FALSE});        assertTrue(areEqual(rule.getBooleanProperties(NonRuleWithAllPropertyTypes.multiBool), new boolean[]{true, false}));                boolean exceptionOccurred = false;        try {        rule.setProperties(NonRuleWithAllPropertyTypes.singleBool, new Boolean[] {Boolean.TRUE, Boolean.FALSE});        } catch (Exception ex) {        exceptionOccurred = true;        }        assertTrue(exceptionOccurred);                exceptionOccurred = false;        try {        rule.setProperty(NonRuleWithAllPropertyTypes.multiBool, Boolean.TRUE);        } catch (Exception ex) {        exceptionOccurred = true;        }        assertTrue(exceptionOccurred);    }    //    public void testFloats() throws ReportException {////    rule.setProperty("singleFloat", new Float(0));//        assertTrue(rule.getFloatProperty("singleFloat") == 0f);//        //    rule.setProperties("multiBool", new Boolean[] {Boolean.TRUE, Boolean.FALSE});//        assertTrue(areEqual(rule.getBooleanProperties("multiBool"), new boolean[]{true, false}));//        //        boolean exceptionOccurred = false;//        try {//        rule.setProperties("singleBool", new Boolean[] {Boolean.TRUE, Boolean.FALSE});//        } catch (Exception ex) {//        exceptionOccurred = true;//        }//        assertTrue(exceptionOccurred);//        //        exceptionOccurred = false;//        try {//        rule.setProperty("multiBool", Boolean.TRUE);//        } catch (Exception ex) {//        exceptionOccurred = true;//        }//        assertTrue(exceptionOccurred);//    }        public void testStrings() {    rule.setProperty(NonRuleWithAllPropertyTypes.singleStr, "brian");        assertEquals(rule.getStringProperty(NonRuleWithAllPropertyTypes.singleStr), "brian");            rule.setProperties(NonRuleWithAllPropertyTypes.multiStr, new String[] {"hello", "world"});    assertTrue(CollectionUtil.arraysAreEqual(rule.getStringProperties(NonRuleWithAllPropertyTypes.multiStr),  new String[] {"hello", "world"}));                boolean exceptionOccurred = false;        try {        rule.setProperties(NonRuleWithAllPropertyTypes.singleStr, new String[] {"hello", "world"});        } catch (Exception ex) {        exceptionOccurred = true;        }        assertTrue(exceptionOccurred);                exceptionOccurred = false;        try {        rule.setProperty(NonRuleWithAllPropertyTypes.multiStr, "brian");        } catch (Exception ex) {        exceptionOccurred = true;        }        assertTrue(exceptionOccurred);    }}
package test.net.sourceforge.pmd.properties;import java.util.ArrayList;import java.util.HashMap;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.properties.EnumeratedProperty;/** */public class EnumeratedPropertyTest extends AbstractPropertyDescriptorTester {private static final String[] keys = new String[] {"map","emptyArray","list","string",};    private static final Object[] values = new Object[] {        new HashMap(),        new Object[0],        new ArrayList(),        "Hello World!",        };    public EnumeratedPropertyTest() {super();}/** * Method createValue. * @param count int * @return Object */protected Object createValue(int count) {if (count == 1) return randomChoice(values);Object[] values = new Object[count];for (int i=0; i<values.length; i++) values[i] = createValue(1);return values;}/** * Method createProperty. * @param maxCount int * @return PropertyDescriptor */protected PropertyDescriptor createProperty(int maxCount) {return maxCount == 1 ?new EnumeratedProperty<Object>("testEnumerations", "Test enumerations with complex types", keys, values, 1.0f) :new EnumeratedProperty<Object>("testEnumerations", "Test enumerations with complex types", keys, values, 1.0f, 3);}}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.CPPTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;public class CPPTokenizerTest extends TestCase {    public void testMultiLineMacros() throws Throwable {        CPPTokenizer tokenizer = new CPPTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(TEST1));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        assertEquals(7, tokens.size());    }    public void testDollarSignInIdentifier() {        parse(TEST2);    }    public void testDollarSignStartingIdentifier() {        parse(TEST3);    }    public void testWideCharacters() {        parse(TEST4);    }    private void parse(String snippet) {        CPPTokenizer tokenizer = new CPPTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(snippet));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);    }    private static final String TEST1 =            "#define FOO a +\\" + PMD.EOL +            "            b +\\" + PMD.EOL +            "            c +\\" + PMD.EOL +            "            d +\\" + PMD.EOL +            "            e +\\" + PMD.EOL +            "            f +\\" + PMD.EOL +            "            g" + PMD.EOL +            " void main() {}";    private static final String TEST2 =            " void main() { int x$y = 42; }";    private static final String TEST3 =            " void main() { int $x = 42; }";    private static final String TEST4 =            " void main() { char x = L'a'; }";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPPLanguage;import net.sourceforge.pmd.cpd.JavaLanguage;import net.sourceforge.pmd.cpd.LanguageFactory;import net.sourceforge.pmd.cpd.PHPLanguage;public class LanguageFactoryTest extends TestCase {    public void testSimple() {        LanguageFactory f = new LanguageFactory();        assertTrue(f.createLanguage(LanguageFactory.JAVA_KEY) instanceof JavaLanguage);        assertTrue(f.createLanguage(LanguageFactory.CPP_KEY) instanceof CPPLanguage);        assertTrue(f.createLanguage(LanguageFactory.C_KEY) instanceof CPPLanguage);        assertTrue(f.createLanguage(LanguageFactory.PHP_KEY) instanceof PHPLanguage);        try {            f.createLanguage("fiddlesticks");            throw new RuntimeException("Should have thrown an exception!");        } catch (RuntimeException e) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.TokenEntry;import java.util.Iterator;public class MatchTest extends TestCase {    public void testSimple() {        TokenEntry mark1 = new TokenEntry("public", "/var/Foo.java", 1);        TokenEntry mark2 = new TokenEntry("class", "/var/Foo.java", 1);        Match match = new Match(1, mark1, mark2);        match.setSourceCodeSlice("public class Foo {}");        assertEquals("public class Foo {}", match.getSourceCodeSlice());        match.setLineCount(10);        assertEquals(10, match.getLineCount());        assertEquals(1, match.getTokenCount());        Iterator i = match.iterator();        assertEquals(mark1, i.next());        assertEquals(mark2, i.next());        assertFalse(i.hasNext());    }    public void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1), new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;public class SourceCodeTest extends TestCase {    public void testSimple() throws Throwable {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(MatchAlgorithmTest.getSampleCode(), "Foo.java"));        assertEquals("Foo.java", sourceCode.getFileName());        tokenizer.tokenize(sourceCode, new Tokens());        assertEquals(MatchAlgorithmTest.LINE_1, sourceCode.getSlice(1, 1));        assertEquals(MatchAlgorithmTest.LINE_2, sourceCode.getSlice(2, 2));        assertEquals(MatchAlgorithmTest.LINE_1 + PMD.EOL + MatchAlgorithmTest.LINE_2, sourceCode.getSlice(1, 2));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;public class JavaTokensTokenizerTest extends TestCase {    public void test1() throws Throwable {        Tokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("public class Foo {}"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());        assertEquals("public class Foo {}", sourceCode.getSlice(1, 1));    }    public void test2() throws Throwable {        Tokenizer t = new JavaTokenizer();        String data = "public class Foo {" + PMD.EOL + "public void bar() {}" + PMD.EOL + "public void buz() {}" + PMD.EOL + "}";        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(data));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals("public class Foo {" + PMD.EOL + "public void bar() {}", sourceCode.getSlice(1, 2));    }    public void testDiscardSemicolons() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("public class Foo {private int x;}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(9, tokens.size());    }    public void testDiscardImports() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("import java.io.File;" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    public void testDiscardPkgStmts() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.FileReporter;import net.sourceforge.pmd.cpd.ReportException;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;/** * @author Philippe T'Seyen */public class FileReporterTest extends TestCase {    public void testCreation() {        try {            new FileReporter(null);            fail("expected NullPointerException");        } catch (NullPointerException npe) {        }    }    public void testEmptyReport() throws ReportException {        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");        assertTrue(reportFile.exists());        assertEquals(0, reportFile.length());        assertTrue(reportFile.delete());    }    public void testReport() throws ReportException, IOException {        String testString = "first line\nsecond line";        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report(testString);        assertEquals(testString, readFile(reportFile));        assertTrue(reportFile.delete());    }    public void testInvalidFile() {        File reportFile = new File("/invalid_folder/report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        try {            fileReporter.report("");            fail("expected ReportException");        } catch (ReportException re) {        }    }    private String readFile(File file) throws IOException {        BufferedReader reader = null;        try {            reader = new BufferedReader(new FileReader(file));            StringBuffer buffer = new StringBuffer();            String line = reader.readLine();            while (line != null) {                buffer.append(line);                line = reader.readLine();                if (line != null) {                    buffer.append('\n');                }            }            return buffer.toString();        } finally {            if (reader != null) reader.close();        }    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.AnyTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;public class AnyTokenizerTest extends TestCase {    public void testMultiLineMacros() throws Throwable {        AnyTokenizer tokenizer = new AnyTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(TEST1));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        assertEquals(30, tokens.size());    }    private static final String TEST1 =            "using System;" + PMD.EOL +            "namespace HelloNameSpace {" + PMD.EOL +            "" + PMD.EOL +            "    public class HelloWorld {" + PMD.EOL +            "        static void Main(string[] args) {" + PMD.EOL +            "            Console.WriteLine(\"Hello World!\");" + PMD.EOL +            "        }" + PMD.EOL +            "    }" + PMD.EOL +            "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.MatchAlgorithm;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokens;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class MatchAlgorithmTest extends TestCase {    public static final String LINE_1 = "public class Foo { ";    public static final String LINE_2 = " public void bar() {";    public static final String LINE_3 = "  System.out.println(\"hello\");";    public static final String LINE_4 = "  System.out.println(\"hello\");";    public static final String LINE_5 = "  int i = 5";    public static final String LINE_6 = "  System.out.print(\"hello\");";    public static final String LINE_7 = " }";    public static final String LINE_8 = "}";    public static String getSampleCode() {        return                LINE_1 + PMD.EOL +                LINE_2 + PMD.EOL +                LINE_3 + PMD.EOL +                LINE_4 + PMD.EOL +                LINE_5 + PMD.EOL +                LINE_6 + PMD.EOL +                LINE_7 + PMD.EOL +                LINE_8;    }    public void testSimple() throws Throwable {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(41, tokens.size());        Map<String, SourceCode> codeMap = new HashMap<String, SourceCode>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator matches = matchAlgorithm.matches();        Match match = (Match) matches.next();        assertFalse(matches.hasNext());        Iterator marks = match.iterator();        TokenEntry mark1 = (TokenEntry) marks.next();        TokenEntry mark2 = (TokenEntry) marks.next();        assertFalse(marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals(4, mark2.getBeginLine());        assertTrue("Foo.java" == mark1.getTokenSrcID() && "Foo.java" == mark2.getTokenSrcID());        assertEquals(LINE_3, match.getSourceCodeSlice());    }    public void testIgnore() throws Throwable {        JavaTokenizer tokenizer = new JavaTokenizer();        tokenizer.setIgnoreLiterals(true);        tokenizer.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        Map<String, SourceCode> codeMap = new HashMap<String, SourceCode>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator matches = matchAlgorithm.matches();        Match match = (Match) matches.next();        assertFalse(matches.hasNext());        Iterator marks = match.iterator();        marks.next();        marks.next();        marks.next();        assertFalse(marks.hasNext());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenEntry;public class TokenEntryTest extends TestCase {    public void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.Renderer;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.XMLRenderer;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.xml.parsers.DocumentBuilderFactory;import java.io.ByteArrayInputStream;import java.util.ArrayList;import java.util.List;/** * @author Philippe T'Seyen */public class XMLRendererTest extends TestCase {    public void test_no_dupes() {        Renderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<Match>();        String report = renderer.render(list.iterator());        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new ByteArrayInputStream(report.getBytes()));            NodeList nodes = doc.getChildNodes();            Node n = nodes.item(0);            assertEquals("pmd-cpd", n.getNodeName());            assertEquals(0, doc.getElementsByTagName("duplication").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    public void test_one_dupe() {        Renderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<Match>();        Match match = new Match(75, new TokenEntry("public", "/var/Foo.java", 48), new TokenEntry("stuff", "/var/Foo.java", 73));        match.setLineCount(6);        match.setSourceCodeSlice("code fragment");        list.add(match);        String report = renderer.render(list.iterator());        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new ByteArrayInputStream(report.getBytes()));            NodeList dupes = doc.getElementsByTagName("duplication");            assertEquals(1, dupes.getLength());            Node file = dupes.item(0).getFirstChild();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            assertEquals("48", file.getAttributes().getNamedItem("line").getNodeValue());            assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());            file = file.getNextSibling();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());            assertEquals(1, doc.getElementsByTagName("codefragment").getLength());            Node actualCode = doc.getElementsByTagName("codefragment").item(0).getFirstChild().getNextSibling();            assertEquals("\ncode fragment\n", actualCode.getNodeValue());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    public void testRender_MultipleMatch() {        Renderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<Match>();        Match match1 = new Match(75, new TokenEntry("public", "/var/Foo.java", 48), new TokenEntry("void", "/var/Foo.java", 73));        match1.setLineCount(6);        match1.setSourceCodeSlice("code fragment");        Match match2 = new Match(76, new TokenEntry("void", "/var/Foo2.java", 49), new TokenEntry("stuff", "/var/Foo2.java", 74));        match2.setLineCount(7);        match2.setSourceCodeSlice("code fragment 2");        list.add(match1);        list.add(match2);        String report = renderer.render(list.iterator());        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new ByteArrayInputStream(report.getBytes()));            assertEquals(2, doc.getElementsByTagName("duplication").getLength());            assertEquals(4, doc.getElementsByTagName("file").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }}
package test.net.sourceforge.pmd.dfa;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.dfa.Structure;public class StructureTest extends TestCase {    public void testAddResultsinDFANodeContainingAddedNode() {        Structure s = new Structure();        SimpleNode n = new ASTMethodDeclaration(1);        assertEquals(n, s.createNewNode(n).getSimpleNode());    }}
package test.net.sourceforge.pmd.dfa;import junit.framework.TestCase;import net.sourceforge.pmd.dfa.DataFlowNode;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.NodeType;import net.sourceforge.pmd.dfa.StartOrEndDataFlowNode;import java.util.LinkedList;public class DataFlowNodeTest extends TestCase {    public void testAddPathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        IDataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        parent.addPathToChild(child);        assertEquals(parent.getChildren().size(), 1);        assertTrue(child.getParents().contains(parent));        assertTrue(parent.getChildren().contains(child));    }    public void testRemovePathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        IDataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        parent.addPathToChild(child);        assertTrue(parent.removePathToChild(child));        assertFalse(child.getParents().contains(parent));        assertFalse(parent.getChildren().contains(child));    }    public void testRemovePathWithNonChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        IDataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        assertFalse(parent.removePathToChild(child));    }    public void testReverseParentPathsTo() {        DataFlowNode parent1 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode parent2 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        IDataFlowNode child1 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 13, false);        IDataFlowNode child2 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 13, false);        parent1.addPathToChild(child1);        parent2.addPathToChild(child1);        assertTrue(parent1.getChildren().contains(child1));        child1.reverseParentPathsTo(child2);        assertTrue(parent1.getChildren().contains(child2));        assertFalse(parent1.getChildren().contains(child1));        assertTrue(parent2.getChildren().contains(child2));        assertFalse(parent2.getChildren().contains(child1));        assertEquals(0, child1.getParents().size());        assertEquals(2, child2.getParents().size());    }    public void testSetType() {        DataFlowNode node = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        node.setType(NodeType.BREAK_STATEMENT);        assertTrue(node.isType(NodeType.BREAK_STATEMENT));        assertFalse(node.isType(NodeType.CASE_LAST_STATEMENT));    }}
package test.net.sourceforge.pmd.dfa;import junit.framework.TestCase;import net.sourceforge.pmd.dfa.variableaccess.VariableAccess;public class VariableAccessTest extends TestCase {    public void testGetVariableName() {        VariableAccess va = new VariableAccess(VariableAccess.DEFINITION, "foo.bar");        assertEquals("foo", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, ".foobar");        assertEquals("", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar.");        assertEquals("foobar", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar");        assertEquals("foobar", va.getVariableName());    }}
package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.pathfinder.CurrentPath;import net.sourceforge.pmd.dfa.pathfinder.DAAPathFinder;import net.sourceforge.pmd.dfa.pathfinder.Executable;import test.net.sourceforge.pmd.testframework.ParserTst;public class DAAPathFinderTest extends ParserTst implements Executable {    public void testTwoUpdateDefs() throws Throwable {        ASTMethodDeclarator meth = getOrderedNodes(ASTMethodDeclarator.class, TWO_UPDATE_DEFS).get(0);        DAAPathFinder a = new DAAPathFinder(meth.getDataFlowNode().getFlow().get(0), this);//        a.run();    }    public void execute(CurrentPath path) {    }    private static final String TWO_UPDATE_DEFS =            "class Foo {" + PMD.EOL +            " void bar(int x) {" + PMD.EOL +            "  for (int i=0; i<10; i++, j--) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.ast.ASTExpression;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTStatementExpression;import net.sourceforge.pmd.ast.ASTVariableDeclarator;import net.sourceforge.pmd.dfa.DataFlowNode;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.NodeType;import net.sourceforge.pmd.dfa.StatementAndBraceFinder;import test.net.sourceforge.pmd.testframework.ParserTst;public class StatementAndBraceFinderTest extends ParserTst {    public void testStatementExpressionParentChildLinks() throws Throwable {        ASTStatementExpression se = getOrderedNodes(ASTStatementExpression.class, TEST1).get(0);        ASTMethodDeclaration seParent = (ASTMethodDeclaration) ((DataFlowNode) se.getDataFlowNode().getParents().get(0)).getSimpleNode();        assertEquals(se, ((IDataFlowNode) seParent.getDataFlowNode().getChildren().get(0)).getSimpleNode());        assertEquals(seParent, ((IDataFlowNode) se.getDataFlowNode().getParents().get(0)).getSimpleNode());    }    public void testVariableDeclaratorParentChildLinks() throws Throwable {        ASTVariableDeclarator vd = getOrderedNodes(ASTVariableDeclarator.class, TEST2).get(0);        ASTMethodDeclaration vdParent = (ASTMethodDeclaration) ((DataFlowNode) vd.getDataFlowNode().getParents().get(0)).getSimpleNode();        assertEquals(vd, ((IDataFlowNode) vdParent.getDataFlowNode().getChildren().get(0)).getSimpleNode());        assertEquals(vdParent, ((IDataFlowNode) vd.getDataFlowNode().getParents().get(0)).getSimpleNode());    }    public void testIfStmtHasCorrectTypes() throws Throwable {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST3).get(0);        IDataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.IF_EXPR));        assertTrue(dfn.isType(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE));    }    public void testWhileStmtHasCorrectTypes() throws Throwable {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST4).get(0);        IDataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.WHILE_EXPR));        assertTrue(dfn.isType(NodeType.WHILE_LAST_STATEMENT));    }    public void testForStmtHasCorrectTypes() throws Throwable {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST5).get(0);        IDataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.FOR_INIT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.FOR_EXPR));        dfn = exp.getDataFlowNode().getFlow().get(4);        assertTrue(dfn.isType(NodeType.FOR_UPDATE));        assertTrue(dfn.isType(NodeType.FOR_BEFORE_FIRST_STATEMENT));        assertTrue(dfn.isType(NodeType.FOR_END));    }    public void testOnlyWorksForMethodsAndConstructors() {        StatementAndBraceFinder sbf = new StatementAndBraceFinder();        try {            sbf.buildDataFlowFor(new ASTCompilationUnit(1));            fail("Should have failed!");        } catch (RuntimeException e) {            // cool        }        sbf.buildDataFlowFor(new ASTMethodDeclaration(1));        sbf.buildDataFlowFor(new ASTConstructorDeclaration(1));    }    private static final String TEST1 =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  x = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST2 =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST3 =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  if (x) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST4 =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  while (x) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST5 =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  for (int i=0; i<10; i++) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.DataFlowNode;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.variableaccess.VariableAccess;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.List;public class GeneralFiddlingTest extends ParserTst {    public void test1() throws Throwable {        ASTCompilationUnit acu = buildDFA(TEST1);        ASTMethodDeclarator meth = acu.findChildrenOfType(ASTMethodDeclarator.class).get(0);        IDataFlowNode n = meth.getDataFlowNode();        List f = n.getFlow();        for (Iterator i = f.iterator(); i.hasNext();) {            DataFlowNode dfan = (DataFlowNode) i.next();            System.out.println(dfan);            List va = dfan.getVariableAccess();            for (Iterator j = va.iterator(); j.hasNext();) {                VariableAccess o = (VariableAccess) j.next();                System.out.println(o);            }        }    }    private static final String TEST1 =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x = 2;" + PMD.EOL +            "  foo(x);" + PMD.EOL +            "  x = 3;" + PMD.EOL +            " }" + PMD.EOL +            "}";}
/* * Created on 18.08.2004 */package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.IDataFlowNode;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.List;public class AcceptanceTest extends ParserTst {    public void testbook() throws Throwable {        getOrderedNodes(ASTMethodDeclarator.class, FOO);    }    private static final String FOO =            "class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public void testLabelledBreakLockup() throws Throwable {        getOrderedNodes(ASTMethodDeclarator.class, LABELLED_BREAK_LOCKUP);    }    private static final String LABELLED_BREAK_LOCKUP =            "class Foo {" + PMD.EOL +            " void bar(int x) {" + PMD.EOL +            "  here: if (x>2) {" + PMD.EOL +            "   break here;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            "}";    private boolean check(int[][] array, List methodNodes) {        for (int i = 0; i < methodNodes.size(); i++) {            ASTMethodDeclarator decl = (ASTMethodDeclarator) methodNodes.get(i);            IDataFlowNode inode = decl.getDataFlowNode();            for (int j = 0; j < inode.getChildren().size(); j++) {                IDataFlowNode child = inode.getChildren().get(j);                if (array[i][j] != child.getIndex() - 1) {                    return false;                }            }        }        return true;    }    public void test_1() throws Throwable {        assertTrue(check(TEST1_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST1)));    }    public void test_2() throws Throwable {        assertTrue(check(TEST2_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST2)));    }    public void test_3() throws Throwable {        assertTrue(check(TEST3_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST3)));    }    public void test_4() throws Throwable {        assertTrue(check(TEST4_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST4)));    }    public void test_6() throws Throwable {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST6)));    }    public void test_7() throws Throwable {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST7)));    }    public void test_8() throws Throwable {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST8)));    }    public void test_9() throws Throwable {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST9)));    }    public void test_10() throws Throwable {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST10)));    }    public void test_11() throws Throwable {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST11)));    }    public void test_12() throws Throwable {        assertTrue(check(TEST12_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST12)));    }    public void test_13() throws Throwable {        assertTrue(check(TEST13_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST13)));    }    public void test_14() throws Throwable {        assertTrue(check(TEST14_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST14)));    }    public void test_15() throws Throwable {        assertTrue(check(TEST15_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST15)));    }    public void test_16() throws Throwable {        assertTrue(check(TEST16_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST16)));    }    public void test_17() throws Throwable {        assertTrue(check(TEST17_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST17)));    }    public void test_18() throws Throwable {        assertTrue(check(TEST18_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST18)));    }    public void test_19() throws Throwable {        assertTrue(check(TEST19_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST19)));    }    public void test_20() throws Throwable {        assertTrue(check(TEST20_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST20)));    }    public void test_21() throws Throwable {        assertTrue(check(TEST21_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST21)));    }    public void test_22() throws Throwable {        assertTrue(check(TEST22_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST22)));    }    public void test_23() throws Throwable {        assertTrue(check(TEST23_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST23)));    }    public void test_24() throws Throwable {        assertTrue(check(TEST24_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST24)));    }    public void test_25() throws Throwable {        assertTrue(check(TEST25_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST25)));    }    public void test_26() throws Throwable {        assertTrue(check(TEST26_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST26)));    }    public void test_27() throws Throwable {        assertTrue(check(TEST27_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST27)));    }    public void test_28() throws Throwable {        assertTrue(check(TEST28_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST28)));    }    public void test_29() throws Throwable {        assertTrue(check(TEST29_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST29)));    }    public void test_30() throws Throwable {        assertTrue(check(TEST30_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST30)));    }    //  first dimension: the index of a node    //  second dimension: the indices of the children    private static final int[][] TEST1_NODES = {        {1},        {2},        {3},        {4, 6},        {5},        {6},        {}    };    private static final String TEST1 =            "class Foo {" + PMD.EOL +            " void test_1() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  if (x == 0) {" + PMD.EOL +            "   x++;" + PMD.EOL +            "   x = 0;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST2_NODES = {        {1},        {2},        {3},        {5, 7},        {3},        {6},        {4},        {}    };    private static final String TEST2 =            "class Foo {" + PMD.EOL +            " public void test_2() {" + PMD.EOL +            "  for (int i = 0; i < 1; i++) {" + PMD.EOL +            "   i++;" + PMD.EOL +            "   i = 8;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST3_NODES = {        {1},        {2},        {3},        {4, 5},        {3},        {}    };    private static final String TEST3 =            "public class Foo {" + PMD.EOL +            " public void test_3() {" + PMD.EOL +            "  for (int i = 0; i < 1; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST4_NODES = {        {1},        {2},        {3},        {}    };    private static final String TEST4 =            "public class Foo {" + PMD.EOL +            " public void test_4() {" + PMD.EOL +            "  for (; ;) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST5_NODES = {        {1},        {2},        {3},        {4},        {}    };    private static final String TEST6 =            "public class Foo {" + PMD.EOL +            " public void test_6() {" + PMD.EOL +            "  for (int i = 0; ;) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final String TEST7 =            "public class Foo {" + PMD.EOL +            " public void test_7() {" + PMD.EOL +            "  for (int i = 0; i < 0;) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST8_NODES = {        {1},        {2},        {3},        {4, 5},        {3},        {}    };    public static final String TEST8 =            "public class Foo {" + PMD.EOL +            " public void test_8() {" + PMD.EOL +            "  for (int i = 0; ; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    public static final String TEST9 =            "public class Foo {" + PMD.EOL +            " public void test_9() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  for (; i < 0;) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    public static final String TEST10 =            "public class Foo {" + PMD.EOL +            " public void test_10() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  for (; i < 0; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    public static final String TEST11 =            "public class Foo {" + PMD.EOL +            " public void test_11() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  for (; ; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST12_NODES = {        {1},        {2},        {3},        {4, 5},        {3},        {}    };    public static final String TEST12 =            "public class Foo {" + PMD.EOL +            " public void test_12() {" + PMD.EOL +            "  for (; ;) {" + PMD.EOL +            "   int i = 0;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST13_NODES = {        {1},        {2},        {3},        {5, 9},        {3},        {6},        {7, 8},        {8},        {4},        {}    };    public static final String TEST13 =            "public class Foo {" + PMD.EOL +            " public void test_13() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   i = 9;" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   }" + PMD.EOL +            "   i = 6;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST14_NODES = {        {1},        {2},        {3},        {5, 8},        {3},        {6},        {7, 4},        {4},        {}    };    public static final String TEST14 =            "public class Foo {" + PMD.EOL +            " public void test_14() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   i = 9;" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST15_NODES = {        {1},        {2},        {3},        {5, 7},        {3},        {6, 4},        {4},        {}    };    public static final String TEST15 =            "public class Foo {" + PMD.EOL +            " public void test_15() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST16_NODES = {        {1},        {2},        {3},        {5, 8},        {3},        {6, 7},        {4},        {4},        {}    };    public static final String TEST16 =            "public class Foo {" + PMD.EOL +            " public void test_16() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   } else {" + PMD.EOL +            "    i = 6;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST17_NODES = {        {1},        {2},        {3},        {5, 10},        {3},        {6, 7},        {4},        {8, 9},        {4},        {4},        {}    };    public static final String TEST17 =            "public class Foo {" + PMD.EOL +            " public void test_17() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   if (i < 6) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   } else if (i > 8) {" + PMD.EOL +            "    i = 9;" + PMD.EOL +            "   } else {" + PMD.EOL +            "    i = 10;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST18_NODES = {        {1},        {2},        {3},        {5, 9},        {3},        {6},        {8, 4},        {6},        {7},        {}    };    public static final String TEST18 =            "public class Foo {" + PMD.EOL +            " public void test_18() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   for (int j = 0; j < 0; j++) {" + PMD.EOL +            "    j++;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST19_NODES = {        {1},        {2},        {3},        {4, 5},        {10},        {6, 7},        {10},        {8, 9},        {10},        {10},        {}    };    public static final String TEST19 =            "public class Foo {" + PMD.EOL +            " public void test_19() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   i = 2;" + PMD.EOL +            "  } else if (i == 3) {" + PMD.EOL +            "   i = 4;" + PMD.EOL +            "  } else if (i == 5) {" + PMD.EOL +            "   i = 6;" + PMD.EOL +            "  } else {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST20_NODES = {        {1},        {2},        {3},        {4, 6},        {5, 7},        {7},        {7},        {}    };    public static final String TEST20 =            "public class Foo {" + PMD.EOL +            " public void test_20() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   if (i == 2) {" + PMD.EOL +            "    i = 3;" + PMD.EOL +            "   }" + PMD.EOL +            "  } else {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST21_NODES = {        {1},        {2},        {3},        {4, 9},        {5},        {7, 8},        {5},        {6},        {11},        {10, 11},        {11},        {}    };    public static final String TEST21 =            "public class Foo {" + PMD.EOL +            " public void test_21() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   for (i = 3; i < 4; i++) {" + PMD.EOL +            "    i = 5;" + PMD.EOL +            "   }" + PMD.EOL +            "   i++;" + PMD.EOL +            "  } else if (i < 6) {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST22_NODES = {        {1},        {2},        {3},        {4, 8},        {5},        {7, 9},        {5},        {6},        {9},        {}    };    public static final String TEST22 =            "public class Foo {" + PMD.EOL +            " public void test_22() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   for (i = 3; i < 4; i++) {" + PMD.EOL +            "    i = 5;" + PMD.EOL +            "   }" + PMD.EOL +            "  } else {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST23_NODES = {        {1},        {2},        {3},        {4, 8},        {5},        {7, 10},        {5},        {6},        {9, 10},        {10},        {}    };    public static final String TEST23 =            "public class Foo {" + PMD.EOL +            " public void test_23() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   for (i = 3; i < 4; i++) {" + PMD.EOL +            "    i = 5;" + PMD.EOL +            "   }" + PMD.EOL +            "  } else if (i < 6) {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST24_NODES = {        {1},        {2},        {3},        {4, 9},        {5},        {7, 11},        {5},        {8, 6},        {6},        {10, 11},        {11},        {}    };    public static final String TEST24 =            "public class Foo {" + PMD.EOL +            " public void test_24() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  if (x > 2) {" + PMD.EOL +            "   for (int i = 0; i < 1; i++) {" + PMD.EOL +            "    if (x > 3) {" + PMD.EOL +            "     x++;" + PMD.EOL +            "    }" + PMD.EOL +            "   }" + PMD.EOL +            "  } else if (x > 4) {" + PMD.EOL +            "   x++;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST25_NODES = {        {1},        {2},        {3},        {4, 5},        {5},        {}    };    public static final String TEST25 =            "public class Foo {" + PMD.EOL +            " public void test_25() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  switch (x) {" + PMD.EOL +            "   default:" + PMD.EOL +            "    x = 9;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST26_NODES = {        {1},        {2},        {3},        {4},        {5, 6},        {6},        {7},        {8, 3},        {9},        {}    };    public static final String TEST26 =            "public class Foo {" + PMD.EOL +            " public void test_26() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  do {" + PMD.EOL +            "   if (x > 0) {" + PMD.EOL +            "    x++;" + PMD.EOL +            "   }" + PMD.EOL +            "   x++;" + PMD.EOL +            "  } while (x < 9);" + PMD.EOL +            "  x++;" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST27_NODES = {        {1},        {2},        {3},        {5, 9},        {3},        {6},        {7},        {8},        {6, 4},        {}    };    public static final String TEST27 =            "public class Foo {" + PMD.EOL +            " public void test_27() {" + PMD.EOL +            "  for (int i = 0; i < 36; i++) {" + PMD.EOL +            "   int x = 0;" + PMD.EOL +            "   do {" + PMD.EOL +            "    x++;" + PMD.EOL +            "   } while (x < 9);" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST28_NODES = {        {1},        {2},        {3},        {5, 14},        {3},        {6},        {7},        {8, 12},        {9},        {10, 12},        {11},        {12},        {13},        {6, 4},        {}    };    public static final String TEST28 =            "public class Foo {" + PMD.EOL +            " private void test_28() {" + PMD.EOL +            "  for (int i = 0; i < 36; i++) {" + PMD.EOL +            "   int x = 0;" + PMD.EOL +            "   do {" + PMD.EOL +            "    if (x > 0) {" + PMD.EOL +            "     x++;" + PMD.EOL +            "     switch (i) {" + PMD.EOL +            "      case 0:" + PMD.EOL +            "       x = 0;" + PMD.EOL +            "       break;" + PMD.EOL +            "     }" + PMD.EOL +            "    }" + PMD.EOL +            "    x++;" + PMD.EOL +            "   } while (x < 9);" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST29_NODES = {        {1},        {2},        {3, 4, 5},        {6},        {6},        {6},        {}    };    public static final String TEST29 =            "public class Foo {" + PMD.EOL +            " private void test_29() {" + PMD.EOL +            "  switch(x) {" + PMD.EOL +            "   case 1:" + PMD.EOL +            "    break; " + PMD.EOL +            "   default: " + PMD.EOL +            "    break;" + PMD.EOL +            "   case 2:" + PMD.EOL +            "    break;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final int[][] TEST30_NODES = {        {1},        {2},        {3},        {4, 7},        {5, 6},        {4},        {3},        {}    };    public static final String TEST30 =            "public class Foo {" + PMD.EOL +            " private void test_30() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  while (true) {" + PMD.EOL +            "   while (x>0) {" + PMD.EOL +            "     x++;" + PMD.EOL +            "   }" + PMD.EOL +            "   continue;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.ant.PMDTask;import net.sourceforge.pmd.ant.RuleSetWrapper;import org.apache.tools.ant.BuildException;public class PMDTaskTest extends TestCase {    public void testNoFormattersValidation() {        PMDTask task = new PMDTask();        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no Formatters");        } catch (BuildException be) {            // cool        }    }    public void testFormatterWithNoToFileAttribute() {        PMDTask task = new PMDTask();        task.addFormatter(new Formatter());        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - a Formatter was missing a toFile attribute");        } catch (BuildException be) {            // cool        }    }    public void testNoRuleSets() {        PMDTask task = new PMDTask();        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no rulesets");        } catch (BuildException be) {            // cool        }    }    public void testNestedRuleset() {        PMDTask task = new PMDTask();        RuleSetWrapper r = new RuleSetWrapper();        r.addText("rulesets/basic.xml");        task.addRuleset(r);        r.addText("rulesets/design.xml");        task.addRuleset(r);        Formatter f = new Formatter();        task.addFormatter(f);                //TODO        try {            task.execute();        } catch (BuildException be) {            //fail(be.toString());        }    }    public void testInvalidJDK() {        PMDTask task = new PMDTask();        task.setTargetJDK("1.7");        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - JDK 1.7 targeted");        } catch (BuildException be) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import java.io.File;public class FormatterTest extends TestCase {    public void testType() {/*        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.getRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.getRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.getRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.getRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            f.getRenderer();            throw new RuntimeException("Should have failed!");        } catch (BuildException be) {            // cool        }*/    }    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isNoOutputSupplied());        f.setToFile(new File("foo"));        assertFalse("Formatter toFile should not be null!", f.isNoOutputSupplied());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.ast.SimpleJavaNode;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.jaxen.AttributeAxisIterator;public class AttributeAxisIteratorTest extends TestCase {    public void testRemove() {        SimpleNode n = new SimpleJavaNode(0);        n.testingOnly__setBeginColumn(1);        n.testingOnly__setBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        try {            iter.remove();            fail("Should have thrown an exception!");        } catch (UnsupportedOperationException e) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.jaxen.Attribute;import java.lang.reflect.Method;public class AttributeTest extends TestCase {    public void testConstructor() {        ASTPrimaryPrefix p = new ASTPrimaryPrefix(1);        p.testingOnly__setBeginLine(5);        Method[] methods = p.getClass().getMethods();        Method m = null;        for (int i = 0; i < methods.length; i++) {            if (methods[i].getName().equals("getBeginLine")) {                m = methods[i];                break;            }        }        Attribute a = new Attribute(p, "BeginLine", m);        assertEquals("BeginLine", a.getName());        assertEquals("5", a.getValue());        assertEquals(p, a.getParent());    }}
 package test.net.sourceforge.pmd.jaxen;  import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.rules.XPathRule; import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;  public class RegexpAcceptanceTest extends SimpleAggregatorTst {     public void testSimple() throws Throwable {         Rule r = new XPathRule();         r.addProperty("xpath", "//ClassOrInterfaceDeclaration[matches(@Image, 'F?o')]");         r.setMessage("");         runTests(r, "RegexpAcceptance");     } }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.jaxen;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTStatement;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.jaxen.DocumentNavigator;import org.jaxen.BaseXPath;import org.jaxen.JaxenException;import org.jaxen.UnsupportedAxisException;import test.net.sourceforge.pmd.testframework.RuleTst;import java.util.Iterator;import java.util.List;public class DocumentNavigatorTest extends RuleTst {    private TestRule rule;    private class TestRule extends AbstractRule {        private Node compilationUnit;        private Node importDeclaration;        private Node statement;        private Node primaryPrefix;        private Node primaryExpression;        /**         * @see net.sourceforge.pmd.ast.JavaParserVisitor#visit(ASTCompilationUnit, Object)         */        public Object visit(ASTCompilationUnit node, Object data) {            this.compilationUnit = node;            return super.visit(node, data);        }        public Object visit(ASTImportDeclaration node, Object data) {            this.importDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTStatement node, Object data) {            this.statement = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryPrefix node, Object data) {            this.primaryPrefix = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryExpression node, Object data) {            this.primaryExpression = node;            return super.visit(node, data);        }    }    public void setUp() throws Exception {        try {            rule = new TestRule();            runTestFromString(TEST, rule, new Report());        } catch (Throwable xx) {            xx.printStackTrace();            fail();        }    }    public void testChildAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getChildAxisIterator(rule.compilationUnit);        assertSame(rule.compilationUnit.jjtGetChild(0), iter.next());        assertSame(rule.compilationUnit.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testParentAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getParentAxisIterator(rule.importDeclaration);        assertSame(rule.importDeclaration.jjtGetParent(), iter.next());        assertFalse(iter.hasNext());    }    public void testParentAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getParentAxisIterator(rule.compilationUnit);        assertFalse(iter.hasNext());    }    public void testDescendantAxisIterator() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getDescendantAxisIterator(rule.statement);        Node statementExpression = rule.statement.jjtGetChild(0);        assertSame(statementExpression, iter.next());        Node primaryExpression = statementExpression.jjtGetChild(0);        assertSame(primaryExpression, iter.next());        Node primaryPrefix = primaryExpression.jjtGetChild(0);        assertSame(primaryPrefix, iter.next());        Node primarySuffix = primaryExpression.jjtGetChild(1);//        assertSame(primarySuffix, iter.next());        Node name = primaryPrefix.jjtGetChild(0);//        assertSame(name, iter.next());        Node arguments = primarySuffix.jjtGetChild(0);//        assertSame(arguments, iter.next());//        assertFalse(iter.hasNext());    }    public void testDescendantAxisIterator2() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getDescendantAxisIterator(rule.primaryPrefix);        Node name = rule.primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        assertFalse(iter.hasNext());    }    public void testFollowingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertSame(rule.primaryExpression.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testFollowingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertSame(rule.primaryExpression.jjtGetChild(0), iter.next());        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertFalse(iter.hasNext());    }    public void testXPath() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.statement);        assertEquals(6, matches.size());    }    public void testXPath2() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.importDeclaration);        assertEquals(1, matches.size());    }    public static final String TEST =            "import java.io.*;" + PMD.EOL +            "public class Foo {" + PMD.EOL +            " public Foo() {" + PMD.EOL +            "  try {" + PMD.EOL +            "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL +            "  } catch (Exception e) {}" + PMD.EOL +            "  try {" + PMD.EOL +            "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL +            "  } catch (Exception e) {" + PMD.EOL +            "   e.printStackTrace();" + PMD.EOL +            "   // this shouldn't show up on the report" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.ast.JavaParserVisitor;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.jaxen.Attribute;import net.sourceforge.pmd.jaxen.MatchesFunction;import org.jaxen.Context;import org.jaxen.FunctionCallException;import java.util.ArrayList;import java.util.List;public class MatchesFunctionTest extends TestCase implements Node {    public void jjtOpen() {    }    public void jjtClose() {    }    public void jjtSetParent(Node n) {    }    public Node jjtGetParent() {        return null;    }    public void jjtAddChild(Node n, int i) {    }    public Node jjtGetChild(int i) {        return null;    }    public int jjtGetNumChildren() {        return 0;    }    public Object jjtAccept(JavaParserVisitor visitor, Object data) {        return null;    }    private String className;    public String getValue() {        return className;    }    public void testMatch() throws FunctionCallException, NoSuchMethodException {        className = "Foo";        assertTrue(tryRegexp("Foo") instanceof List);    }    public void testNoMatch() throws FunctionCallException, NoSuchMethodException {        className = "bar";        assertTrue(tryRegexp("Foo") instanceof Boolean);        className = "FobboBar";        assertTrue(tryRegexp("Foo") instanceof Boolean);    }    private Object tryRegexp(String exp) throws FunctionCallException, NoSuchMethodException {        MatchesFunction function = new MatchesFunction();        List list = new ArrayList();        List<Attribute> attrs = new ArrayList<Attribute>();        attrs.add(new Attribute(this, "matches", getClass().getMethod("getValue", new Class[0])));        list.add(attrs);        list.add(exp);        Context c = new Context(null);        c.setNodeSet(new ArrayList());        return function.call(c, list);    }}    
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;public class HTMLRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new HTMLRenderer();    }    public String getExpected() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +        "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +        "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +        "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL + "<td width=\"*%\">n/a</td>" + PMD.EOL +        "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL +        "<td width=\"*\">msg</td>" + PMD.EOL +        "</tr>" + PMD.EOL +        "</table></body></html>";    }    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +        "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +        "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +        "</table></body></html>";    }    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +        "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +        "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +        "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL + "<td width=\"*%\">n/a</td>" + PMD.EOL +        "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL +        "<td width=\"*\">msg</td>" + PMD.EOL +        "</tr>" + PMD.EOL +        "<tr> " + PMD.EOL + "<td align=\"center\">2</td>" + PMD.EOL + "<td width=\"*%\">n/a</td>" + PMD.EOL +        "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL +        "<td width=\"*\">msg</td>" + PMD.EOL +        "</tr>" + PMD.EOL +        "</table></body></html>";    }        public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +            "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +            "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +            "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +            "<th>File</th><th>Problem</th></tr>" + PMD.EOL +            "<tr bgcolor=\"lightgrey\"> " + PMD.EOL +            "<td>file</td>" + PMD.EOL +            "<td>Error</td>" + PMD.EOL +            "</tr>" + PMD.EOL +            "</table></body></html>";            }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.IDEAJRenderer;public class IDEAJRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new IDEAJRenderer(new String[]{"","","","","Foo <init>","Foo.java"});    }    public String getExpected() {        return "msg" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }        public String getExpectedEmpty() {        return "";    }        public String getExpectedMultiple() {        return "msg" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL + "msg" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.TextPadRenderer;public class TextPadRendererTest extends AbstractRendererTst{    public AbstractRenderer getRenderer() {        return new TextPadRenderer();    }    public String getExpected() {        return PMD.EOL + "n/a(1,  Foo):  msg";    }    public String getExpectedEmpty() {        return "";    }        public String getExpectedMultiple() {        return PMD.EOL + "n/a(1,  Foo):  msg" + PMD.EOL + "n/a(1,  Foo):  msg";    }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.PapariTextRenderer;import java.io.File;import java.io.FileNotFoundException;import java.io.Reader;import java.io.StringReader;public class PapariTextRendererTest extends AbstractRendererTst {    private static String naString = "n/a";    static {        naString = naString.substring(naString.lastIndexOf(File.separator) + 1);    }        public AbstractRenderer getRenderer() {        return new PapariTextRenderer(){            protected Reader getReader(String sourceFile) throws FileNotFoundException {                return new StringReader("public class Foo {}");            }        };    }    public String getExpected() {        return "* file: n/a" + PMD.EOL + "    src:  " + naString + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL + "    msg:  msg" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + " : 1" + PMD.EOL + "* warnings: 1" + PMD.EOL;    }        public String getExpectedEmpty() {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 0" + PMD.EOL;    }        public String getExpectedMultiple() {        return "* file: n/a" + PMD.EOL + "    src:  " + naString + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL + "    msg:  msg" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + "    src:  " + naString + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL + "    msg:  msg" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + " : 2" + PMD.EOL + "* warnings: 2" + PMD.EOL;    }        public String getExpectedError(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "    err:  Error" + PMD.EOL + PMD.EOL + "* errors:   0" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.EmacsRenderer;public class EmacsRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new EmacsRenderer();    }    public String getExpected() {        return PMD.EOL + "n/a:1: msg";    }    public String getExpectedEmpty() {        return "";    }    public String getExpectedMultiple() {        return PMD.EOL + "n/a:1: msg" + PMD.EOL + "n/a:1: msg";    }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.VBHTMLRenderer;public class VBHTMLRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new VBHTMLRenderer();    }    public String getExpected() {        return  "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL +                 "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }" + PMD.EOL +                 ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }" + PMD.EOL +                 ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }" + PMD.EOL +                 "#TableHeader { background-color: #003366; }" + PMD.EOL +                 "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL +                 "#RowColor2 { background-color: white; }" + PMD.EOL +                 "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;n/a</font></tr>" + PMD.EOL +                 "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>msg</font></td></tr>" + PMD.EOL +                 "</table><br></center></body></html>";    }    public String getExpectedEmpty() {        // TODO Auto-generated method stub        return "";    }    public String getExpectedMultiple() {        return  "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL +                 "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }" + PMD.EOL +                 ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }" + PMD.EOL +                 ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }" + PMD.EOL +                 "#TableHeader { background-color: #003366; }" + PMD.EOL +                 "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL +                 "#RowColor2 { background-color: white; }" + PMD.EOL +                 "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;n/a</font></tr>" + PMD.EOL +                 "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>msg</font></td></tr>" + PMD.EOL +                 "<tr id=RowColor1><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>msg</font></td></tr>" + PMD.EOL +                "</table><br></center></body></html>";    }        public String getExpectedError(ProcessingError error) {        return  "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL +                 "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }" + PMD.EOL +                 ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }" + PMD.EOL +                 ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }" + PMD.EOL +                 "#TableHeader { background-color: #003366; }" + PMD.EOL +                 "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL +                 "#RowColor2 { background-color: white; }" + PMD.EOL +                 "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td><font class=title>&nbsp;Problems found</font></td></tr><tr id=RowColor2><td><font class=body>" + error +"\"</font></td></tr></table></center></body></html>";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.CSVRenderer;public class CSVRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new CSVRenderer();    }    public String getExpected() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL                + "\"1\",\"\",\"n/a\",\"5\",\"1\",\"msg\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    public String getExpectedEmpty() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL;    }    public String getExpectedMultiple() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL        + "\"1\",\"\",\"n/a\",\"5\",\"1\",\"msg\",\"RuleSet\",\"Foo\"" + PMD.EOL         + "\"2\",\"\",\"n/a\",\"5\",\"1\",\"msg\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    public String getExpectedError(ProcessingError error) {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL;    }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.TextRenderer;public class TextRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new TextRenderer();    }    public String getExpected() {        return PMD.EOL + "n/a:1\tmsg";    }    public String getExpectedEmpty() {        return "No problems found!";    }    public String getExpectedMultiple() {        return PMD.EOL + "n/a:1\tmsg" + PMD.EOL + "n/a:1\tmsg";    }    public String getExpectedError(ProcessingError error) {        return PMD.EOL + "file\t-\tError";    }    }
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.SourceType;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.renderers.XMLRenderer;import org.w3c.dom.Element;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import test.net.sourceforge.pmd.testframework.RuleTst;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.IOException;import java.io.StringReader;public class XMLRendererTest extends RuleTst {    private static class FooRule extends AbstractRule {        public Object visit(ASTClassOrInterfaceDeclaration c, Object ctx) {            if (c.getImage().equals("Foo")) addViolation(ctx, c);            return ctx;        }        public String getMessage() {            return "blah";        }        public String getName() {            return "Foo";        }        public String getRuleSetName() {            return "RuleSet";        }        public String getDescription() {            return "desc";        }    }    public void testEmptyReport() throws Throwable {        Element root = parseRootElement(new Report());        assertEquals("pmd", root.getNodeName());        assertNull(root.getFirstChild().getNextSibling()); // only one child, it's whitespace    }    public void testErrorReport() throws Throwable {        Report report = new Report();        report.addError(new Report.ProcessingError("test_msg", "test_filename"));        Element root = parseRootElement(report);        assertEquals("test_msg", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("msg").getNodeValue());    }    public void testSingleReport() throws Throwable {        Report report = new Report();        runTestFromString(TEST1, new FooRule(), report);        Element root = parseRootElement(report);        assertEquals("n/a", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());        assertEquals("Foo", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());        assertEquals("RuleSet", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("ruleset").getNodeValue());        assertEquals("1", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("line").getNodeValue());    }    private static final String TEST1 =            "public class Foo {}" + PMD.EOL;    private static final String TEST2 =            "public class Foo {" + PMD.EOL +            " public class Foo {}" + PMD.EOL +            "}" + PMD.EOL;    public void testDoubleReport() throws Throwable {        Report report = new Report();        runTestFromString(TEST2, new FooRule(), report);        runTestFromString(TEST2, new FooRule(), report);        Element root = parseRootElement(report);        assertEquals("Foo", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());        assertEquals("Foo", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getNextSibling().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());    }    public void testTwoFiles() throws Throwable {        Report report = new Report();        FooRule rule = new FooRule();        runTestFromString(TEST2, rule, report);        PMD p = new PMD();        p.setJavaVersion(SourceType.JAVA_14);        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFilename("bar");        RuleSet rules = new RuleSet();        rules.addRule(rule);        p.processFile(new StringReader(TEST2), rules, ctx);        Element root = parseRootElement(report);        assertEquals("bar", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());        assertEquals("n/a", root.getFirstChild().getNextSibling().getNextSibling().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());    }    private Element parseRootElement(Report rpt) throws SAXException, IOException, ParserConfigurationException {        return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(new StringReader(new XMLRenderer().render(rpt)))).getDocumentElement();    }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.YAHTMLRenderer;public class YAHTMLRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new YAHTMLRenderer();    }    public String getExpected() {        return "<h3 align=\"center\">The HTML files are created above the project directory.</h3>";    }    public String getExpectedEmpty() {        return "<h3 align=\"center\">The HTML files are created above the project directory.</h3>";    }        public String getExpectedMultiple() {        return "<h3 align=\"center\">The HTML files are created above the project directory.</h3>";    }        public String getExpectedError(ProcessingError error) {        return "<h3 align=\"center\">The HTML files are created above the project directory.</h3>";    }}
package test.net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.renderers.AbstractRenderer;import net.sourceforge.pmd.renderers.SummaryHTMLRenderer;public class SummaryHTMLRendererTest extends AbstractRendererTst {    public AbstractRenderer getRenderer() {        return new SummaryHTMLRenderer();    }    public String getExpected() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +                 "<h2><center>Summary</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><th>Rule name</th><th>Number of violations</th><tr><td>Foo</td><td align=center>1</td></tr></table><h2><center>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +                 "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +                 "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +                 "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +                 "<tr bgcolor=\"lightgrey\"> " + PMD.EOL +                 "<td align=\"center\">1</td>" + PMD.EOL +                 "<td width=\"*%\">n/a</td>" + PMD.EOL +                 "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL +                 "<td width=\"*\">msg</td>" + PMD.EOL +                 "</tr>" + PMD.EOL +                 "</table></table></body></html>";    }    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +         "<h2><center>Summary</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><th>Rule name</th><th>Number of violations</th></table><h2><center>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +         "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +         "</table></table></body></html>";    }        public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +         "<h2><center>Summary</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><th>Rule name</th><th>Number of violations</th><tr><td>Foo</td><td align=center>2</td></tr></table><h2><center>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +         "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +         "<tr bgcolor=\"lightgrey\"> " + PMD.EOL +         "<td align=\"center\">1</td>" + PMD.EOL +         "<td width=\"*%\">n/a</td>" + PMD.EOL +         "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL +         "<td width=\"*\">msg</td>" + PMD.EOL +         "</tr>" + PMD.EOL +         "<tr> " + PMD.EOL +         "<td align=\"center\">2</td>" + PMD.EOL +         "<td width=\"*%\">n/a</td>" + PMD.EOL +         "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL +         "<td width=\"*\">msg</td>" + PMD.EOL +         "</tr>" + PMD.EOL +         "</table></table></body></html>";    }    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL +         "<h2><center>Summary</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><th>Rule name</th><th>Number of violations</th></table><h2><center>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +         "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL +         "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>" + PMD.EOL +         "<th>File</th><th>Problem</th></tr>" + PMD.EOL +         "<tr bgcolor=\"lightgrey\"> " + PMD.EOL +         "<td>file</td>" + PMD.EOL +         "<td>Error</td>" + PMD.EOL +         "</tr>" + PMD.EOL +         "</table></table></body></html>";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.symboltable.TypeSet;import java.io.File;import java.util.HashSet;import java.util.Set;public class TypeSetTest extends TestCase {    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    public void testFindClassImplicitImport() throws Throwable {        TypeSet t = new TypeSet();        Class clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    public void testFindClassSamePackage() throws Throwable {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd.");        Class clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    public void testFindClassExplicitImport() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassImportOnDemand() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassPrimitive() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    public void testFindClassVoid() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    public void testFindFullyQualified() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    public void testPrimitiveTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    public void testVoidTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    public void testExplicitImportResolver() throws Throwable {        Set<String> imports = new HashSet<String>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(imports);        assertEquals(File.class, r.resolve("File"));    }    public void testImplicitImportResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        assertEquals(String.class, r.resolve("String"));    }    public void testImplicitImportResolverPassFail() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        try {            r.resolve("PMD");            fail("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }    }    public void testCurrentPackageResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver("net.sourceforge.pmd.");        assertEquals(PMD.class, r.resolve("PMD"));    }    public void testImportOnDemandResolverPass() throws Throwable {        Set<String> imports = new HashSet<String>();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    public void testImportOnDemandResolverFail() throws Throwable {        Set<String> imports = new HashSet<String>();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        try {            r.resolve("foo");            fail("Should have thrown a ClassNotFoundException");        } catch (ClassNotFoundException cnfe) {        }        try {            r.resolve("String");            fail("Should have thrown a ClassNotFoundException");        } catch (ClassNotFoundException cnfe) {        }    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleJavaNode;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import net.sourceforge.pmd.symboltable.VariableUsageFinderFunction;import net.sourceforge.pmd.util.Applier;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class VariableUsageFinderFunctionTest extends TestCase {    public void testLookingForUsed() {        ASTVariableDeclaratorId variableDeclarationIdNode = new ASTVariableDeclaratorId(1);        variableDeclarationIdNode.setImage("x");        VariableNameDeclaration nameDeclaration = new VariableNameDeclaration(variableDeclarationIdNode);        List<NameOccurrence> nameOccurrences = new ArrayList<NameOccurrence>();        nameOccurrences.add(new NameOccurrence(new SimpleJavaNode(2), "x"));        Map<VariableNameDeclaration, List<NameOccurrence>> declarations = new HashMap<VariableNameDeclaration, List<NameOccurrence>>();        declarations.put(nameDeclaration, nameOccurrences);        List<VariableNameDeclaration> vars = new ArrayList<VariableNameDeclaration>();        vars.add(nameDeclaration);        VariableUsageFinderFunction f = new VariableUsageFinderFunction(declarations);        Applier.apply(f, vars.iterator());        Map p = f.getUsed();        assertEquals(1, p.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.Scope;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;public class VariableNameDeclarationTest extends STBBaseTst {    public void testConstructor() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        Scope s = ((ASTVariableDeclaratorId) nodes.get(0)).getScope();        VariableNameDeclaration decl = s.getVariableDeclarations().keySet().iterator().next();        assertEquals("bar", decl.getImage());        assertEquals(3, decl.getNode().getBeginLine());    }    public void testExceptionBlkParam() {        ASTVariableDeclaratorId id = new ASTVariableDeclaratorId(3);        id.testingOnly__setBeginLine(10);        id.setImage("foo");        ASTFormalParameter param = new ASTFormalParameter(2);        id.jjtSetParent(param);        param.jjtSetParent(new ASTTryStatement(1));        VariableNameDeclaration decl = new VariableNameDeclaration(id);        assertTrue(decl.isExceptionBlockParameter());    }    public void testIsArray() {        parseCode(TEST3);        VariableNameDeclaration decl = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0).getScope().getVariableDeclarations().keySet().iterator().next();        assertTrue(decl.isArray());    }    public void testPrimitiveType() {        parseCode(TEST1);        VariableNameDeclaration decl = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0).getScope().getVariableDeclarations().keySet().iterator().next();        assertTrue(decl.isPrimitiveType());    }    public void testArrayIsReferenceType() {        parseCode(TEST3);        VariableNameDeclaration decl = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0).getScope().getVariableDeclarations().keySet().iterator().next();        assertTrue(decl.isReferenceType());    }    public void testPrimitiveTypeImage() {        parseCode(TEST3);        VariableNameDeclaration decl = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0).getScope().getVariableDeclarations().keySet().iterator().next();        assertEquals("int", decl.getTypeImage());    }    public void testRefTypeImage() {        parseCode(TEST4);        VariableNameDeclaration decl = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0).getScope().getVariableDeclarations().keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    public void testParamTypeImage() {        parseCode(TEST5);        VariableNameDeclaration decl = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0).getScope().getVariableDeclarations().keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    public static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  int bar = 42;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST2 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  try {} catch(Exception e) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST3 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  int[] x;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST4 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  String x;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST5 =            "public class Foo {" + PMD.EOL +            " void foo(String x) {}" + PMD.EOL +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTIfStatement;import net.sourceforge.pmd.symboltable.LocalScope;public class ScopeCreationVisitorTest extends STBBaseTst {    public void testScopesAreCreated() {        parseCode(TEST1);        ASTIfStatement n = acu.findChildrenOfType(ASTIfStatement.class).get(0);        assertTrue(n.getScope() instanceof LocalScope);    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  if (x>2) {}" + PMD.EOL +            " }" + PMD.EOL +            "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleJavaNode;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.MethodNameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.Iterator;import java.util.List;import java.util.Map;public class ClassScopeTest extends STBBaseTst {    public void testEnumsClassScope() {        parseCode15(ENUM_SCOPE);    }    // FIXME - these will break when this goes from Anonymous$1 to Foo$1    public void testAnonymousInnerClassName() {        ClassScope s = new ClassScope();        assertEquals("Anonymous$1", s.getClassName());        s = new ClassScope();        assertEquals("Anonymous$2", s.getClassName());    }    public void testContains() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testCantContainsSuperToString() {        ClassScope s = new ClassScope("Foo");        SimpleNode node = new SimpleJavaNode(1);        node.setImage("super.toString");        assertFalse(s.contains(new NameOccurrence(node, node.getImage())));    }    public void testContainsStaticVariablePrefixedWithClassName() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("X");        s.addDeclaration(new VariableNameDeclaration(node));        SimpleNode node2 = new SimpleJavaNode(2);        node2.setImage("Foo.X");        assertTrue(s.contains(new NameOccurrence(node2, node2.getImage())));    }    public void testClassName() {        parseCode(CLASS_NAME);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        assertEquals("Foo", n.getScope().getEnclosingClassScope().getClassName());    }    public void testMethodDeclarationRecorded() {        parseCode(METHOD_DECLARATIONS_RECORDED);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope s = (ClassScope) n.getScope();        Map m = s.getMethodDeclarations();        assertEquals(1, m.size());        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("bar", mnd.getImage());        ASTMethodDeclaration node = (ASTMethodDeclaration) mnd.getNode().jjtGetParent();        assertTrue(node.isPrivate());    }    public void testTwoMethodsSameNameDiffArgs() {        // TODO this won't work with String and java.lang.String        parseCode(METHODS_WITH_DIFF_ARG);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        assertEquals(2, m.size());        Iterator i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration) i.next();        assertEquals("bar", mnd.getImage());        assertEquals("bar", ((MethodNameDeclaration) i.next()).getImage());    }    public final void testOneParams() throws Throwable {        parseCode(ONE_PARAM);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String)", mnd.getParameterDisplaySignature());    }    public final void testTwoParams() throws Throwable {        parseCode(TWO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,int)", mnd.getParameterDisplaySignature());    }    public final void testNoParams() throws Throwable {        parseCode(NO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("()", mnd.getParameterDisplaySignature());    }    public final void testNestedClassDeclFound() throws Throwable {        parseCode(NESTED_CLASS_FOUND);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope c = (ClassScope) n.getScope();        Map m = c.getClassDeclarations();        ClassNameDeclaration cnd = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals("Buz", cnd.getImage());    }    public final void testbuz() throws Throwable {        parseCode(METH);        //SymbolTableViewer st = new SymbolTableViewer();        //acu.jjtAccept(st, null);    }    public void testMethodUsageSeen() {        parseCode(METHOD_USAGE_SEEN);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        Iterator i = m.entrySet().iterator();        Map.Entry entry = (Map.Entry) i.next();                MethodNameDeclaration mnd = (MethodNameDeclaration) entry.getKey();        if (!mnd.getImage().equals("bar")) {            mnd = (MethodNameDeclaration) i.next();        }        List usages = (List) entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((NameOccurrence) usages.get(0)).getImage());    }    public void testMethodUsageSeenWithThis() {        parseCode(METHOD_USAGE_SEEN_WITH_THIS);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        Iterator i = m.entrySet().iterator();        Map.Entry entry = (Map.Entry) i.next();        MethodNameDeclaration mnd = (MethodNameDeclaration) entry.getKey();        if (!mnd.getImage().equals("bar")) {            mnd = (MethodNameDeclaration) i.next();        }        List usages = (List) entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((NameOccurrence) usages.get(0)).getImage());    }    public void testMethodUsageSeen2() {        parseCode(METHOD_USAGE_SEEN2);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope) n.getScope()).getMethodDeclarations();        Iterator i = m.entrySet().iterator();        Map.Entry entry = (Map.Entry) i.next();        MethodNameDeclaration mnd = (MethodNameDeclaration) entry.getKey();        if (mnd.getNode().getBeginLine() == 2) {            List usages = (List) entry.getValue();            System.out.println(usages.size());            System.out.println(mnd);            mnd = (MethodNameDeclaration) i.next();        }    }    private static final String METHOD_USAGE_SEEN2 =            "public class Foo {" + PMD.EOL +            " public void baz() {" + PMD.EOL +            "  baz(x, y);" + PMD.EOL +            " }" + PMD.EOL +            " private void baz(int x, int y) {}" + PMD.EOL +            "}";    private static final String METHOD_USAGE_SEEN =            "public class Foo {" + PMD.EOL +            " private void bar() {}" + PMD.EOL +            " public void buz() {" + PMD.EOL +            "  bar();" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String METHOD_USAGE_SEEN_WITH_THIS =            "public class Foo {" + PMD.EOL +            " private void bar() {}" + PMD.EOL +            " public void buz() {" + PMD.EOL +            "  this.bar();" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String METH =            "public class Test {" + PMD.EOL +            "  static { " + PMD.EOL +            "   int y; " + PMD.EOL +            "  } " + PMD.EOL +            "  void bar(int x) {} " + PMD.EOL +            "  void baz(int x) {} " + PMD.EOL +            "}";    private static final String NESTED_CLASS_FOUND =            "public class Test {" + PMD.EOL +            "  private class Buz {} " + PMD.EOL +            "}";    private static final String ONE_PARAM =            "public class Test {" + PMD.EOL +            "  void bar(String x) {" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String TWO_PARAMS =            "public class Test {" + PMD.EOL +            "  void bar(String x, int y) {" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String NO_PARAMS =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String CLASS_NAME =            "public class Foo {}";    private static final String METHOD_DECLARATIONS_RECORDED =            "public class Foo {" + PMD.EOL +            " private void bar() {}" + PMD.EOL +            "}";    private static final String METHODS_WITH_DIFF_ARG =            "public class Foo {" + PMD.EOL +            " private void bar(String x) {}" + PMD.EOL +            " private void bar() {}" + PMD.EOL +            "}";    private static final String ENUM_SCOPE =            "public enum Foo {" + PMD.EOL +            " HEAP(\"foo\");" + PMD.EOL +            " private final String fuz;" + PMD.EOL +            " public String getFuz() {" + PMD.EOL +            "  return fuz;" + PMD.EOL +            " }" + PMD.EOL +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.MethodScope;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;import java.util.Map;public class LocalScopeTest extends STBBaseTst {    public void testNameWithThisOrSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertFalse(scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testNameWithSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertFalse(scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testLocalVariableDeclarationFound() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId) nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        assertEquals(1, vars.size());        NameDeclaration decl = (NameDeclaration) vars.keySet().iterator().next();        assertEquals("b", decl.getImage());    }    public void testQualifiedNameOccurrence() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId) nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        NameDeclaration decl = (NameDeclaration) vars.keySet().iterator().next();        NameOccurrence occ = (NameOccurrence) ((List) vars.get(decl)).get(0);        assertEquals("b", occ.getImage());    }    public void testPostfixUsageIsRecorded() {        parseCode(TEST3);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId) nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        NameDeclaration decl = (NameDeclaration) vars.keySet().iterator().next();        List usages = (List) vars.get(decl);        NameOccurrence occ = (NameOccurrence) usages.get(0);        assertEquals(4, occ.getLocation().getBeginLine());    }    public void testLocalVariableTypesAreRecorded() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        Map vars = ((ASTVariableDeclaratorId) nodes.get(0)).getScope().getVariableDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("Bar", decl.getTypeImage());    }    public void testMethodArgumentTypesAreRecorded() {        parseCode(TEST5);        List nodes = acu.findChildrenOfType(ASTFormalParameter.class);        Map vars = ((ASTFormalParameter) nodes.get(0)).getScope().getVariableDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    public void testgetEnclosingMethodScope() {        parseCode(TEST4);        ASTLocalVariableDeclaration node = acu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        LocalScope scope = (LocalScope) node.getScope();        MethodScope ms = scope.getEnclosingMethodScope();        assertEquals(2, ms.getVariableDeclarations().size());    }    public static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  Bar b = new Bar();" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST2 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  Bar b = new Bar();" + PMD.EOL +            "  b.buz = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST3 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  int x = 2;" + PMD.EOL +            "  x++;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST4 =            "public class Foo {" + PMD.EOL +            " void foo(String x, String z) { int y; }" + PMD.EOL +            "}";    public static final String TEST5 =            "public class Foo {" + PMD.EOL +            " void foo(String x);" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.symboltable.MethodScope;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;import java.util.Map;public class MethodScopeTest extends STBBaseTst {    public void testMethodParameterOccurrenceRecorded() {        parseCode(TEST1);        Map m = acu.findChildrenOfType(ASTMethodDeclaration.class).get(0).getScope().getVariableDeclarations();        VariableNameDeclaration vnd = (VariableNameDeclaration) m.keySet().iterator().next();        assertEquals("bar", vnd.getImage());        List occs = (List) m.get(vnd);        NameOccurrence occ = (NameOccurrence) occs.get(0);        assertEquals(3, occ.getLocation().getBeginLine());    }    public void testMethodName() {        parseCode(TEST1);        ASTMethodDeclaration meth = acu.findChildrenOfType(ASTMethodDeclaration.class).get(0);        MethodScope ms = (MethodScope) meth.getScope();        assertEquals(ms.getName(), "foo");    }    public static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void foo(int bar) {" + PMD.EOL +            "  bar = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.symboltable.NameFinder;import net.sourceforge.pmd.symboltable.NameOccurrence;import java.util.List;public class NameOccurrencesTest extends STBBaseTst {    public void testSuper() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression) nodes.get(0));        assertEquals("super", occs.getNames().get(0).getImage());    }    public void testThis() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression) nodes.get(0));        assertEquals("this", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    public void testNameLinkage() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression) nodes.get(0));        NameOccurrence thisNameOccurrence = occs.getNames().get(0);        assertEquals(thisNameOccurrence.getNameForWhichThisIsAQualifier(), occs.getNames().get(1));    }    public void testSimpleVariableOccurrence() {        parseCode(TEST3);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression) nodes.get(0));        assertEquals("x", occs.getNames().get(0).getImage());        assertFalse(occs.getNames().get(0).isThisOrSuper());        assertFalse(occs.getNames().get(0).isMethodOrConstructorInvocation());        assertTrue(occs.getNames().get(0).isOnLeftHandSide());    }    public void testQualifiedOccurrence() {        parseCode(TEST4);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression) nodes.get(0));        assertEquals("b", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }        public void testIsSelfAssignment(){        parseCode(TEST5);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression) nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());        parseCode(TEST6);        nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        occs = new NameFinder((ASTPrimaryExpression) nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());    }    public static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  super.x = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST2 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  this.x = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST3 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  x = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST4 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  b.x = 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    public static final String TEST5 =        "public class Foo{" + PMD.EOL +        "    private int counter;" + PMD.EOL +        "    private Foo(){" + PMD.EOL +        "        counter = 0;" + PMD.EOL +        "    }" + PMD.EOL +        "    private int foo(){" + PMD.EOL +        "        if (++counter < 3) {" + PMD.EOL +        "            return 0;" + PMD.EOL +        "        }" + PMD.EOL +        "        return 1;" + PMD.EOL +        "    }" + PMD.EOL +        "}";        public static final String TEST6 =        "public class Foo{" + PMD.EOL +        "    private int counter;" + PMD.EOL +        "    private Foo(){" + PMD.EOL +        "        counter = 0;" + PMD.EOL +        "    }" + PMD.EOL +        "    private int foo(){" + PMD.EOL +        "        if (++this.counter < 3) {" + PMD.EOL +        "            return 0;" + PMD.EOL +        "        }" + PMD.EOL +        "        return 1;" + PMD.EOL +        "    }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import net.sourceforge.pmd.symboltable.Scope;import java.util.Map;public class GlobalScopeTest extends STBBaseTst {    public void testClassDeclAppears() {        parseCode(TEST1);        ASTCompilationUnit decl = acu.findChildrenOfType(ASTCompilationUnit.class).get(0);        Scope scope = decl.getScope();        Map m = scope.getClassDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    public void testEnums() {        parseCode15(TEST2);    }    private static final String TEST1 =            "public class Foo {}" + PMD.EOL;    private static final String TEST2 =            "public enum Bar {" + PMD.EOL +            "  FOO1 {          " + PMD.EOL +            "    private static final String FIELD_NAME = \"\";" + PMD.EOL +            "  }," + PMD.EOL +            "  FOO2 {          " + PMD.EOL +            "    private static final String FIELD_NAME = \"\";" + PMD.EOL +            "  }" + PMD.EOL +            "}" + PMD.EOL;}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.MethodNameDeclaration;import java.util.Iterator;import java.util.List;import java.util.Map;public class MethodNameDeclarationTest extends STBBaseTst {    public void testEquality() {        parseCode(SIMILAR);        ASTClassOrInterfaceDeclaration n = acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<MethodNameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getMethodDeclarations();        Iterator<MethodNameDeclaration> i = m.keySet().iterator();        MethodNameDeclaration mnd1 = i.next();        MethodNameDeclaration mnd2 = i.next();    }    private static final String SIMILAR =            "public class Foo {" + PMD.EOL +            " public void bar() {" + PMD.EOL +            "  bar(x, y);" + PMD.EOL +            " }" + PMD.EOL +            " private void bar(int x, int y) {}" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import java.util.Iterator;import java.util.Map;public class SourceFileScopeTest extends STBBaseTst {    public void testClassDeclAppears() {        parseCode(TEST1);        Map m = acu.getScope().getClassDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    public void testPackageIsEmptyString() {        parseCode(TEST1);        ASTCompilationUnit decl = acu.findChildrenOfType(ASTCompilationUnit.class).get(0);        assertEquals(decl.getScope().getEnclosingSourceFileScope().getPackageName(), "");    }    public void testPackageNameFound() {        parseCode(TEST2);        ASTCompilationUnit decl = acu.findChildrenOfType(ASTCompilationUnit.class).get(0);        assertEquals(decl.getScope().getEnclosingSourceFileScope().getPackageName(), "foo.bar");    }    public void testNestedClasses() {        parseCode(TEST3);        Map m = acu.getScope().getClassDeclarations();        Iterator iterator = m.keySet().iterator();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) iterator.next();        assertEquals(classNameDeclaration.getImage(), "Foo");        assertFalse(iterator.hasNext());    }    private static final String TEST1 =            "public class Foo {}" + PMD.EOL;    private static final String TEST2 =            "package foo.bar;" + PMD.EOL +            "public class Foo {" + PMD.EOL +            "}" + PMD.EOL;    private static final String TEST3 =            "public class Foo {" + PMD.EOL +            " public class Bar {" + PMD.EOL +            " }" + PMD.EOL +            "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.NameOccurrence;public class AcceptanceTest extends STBBaseTst {/*    public void testClashingSymbols() {        parseCode(TEST1);    }    public void testInitializer() {        parseCode(TEST_INITIALIZERS);        ASTInitializer a = (ASTInitializer)(acu.findChildrenOfType(ASTInitializer.class)).get(0);        assertFalse(a.isStatic());        a = (ASTInitializer)(acu.findChildrenOfType(ASTInitializer.class)).get(1);        assertTrue(a.isStatic());    }    public void testCatchBlocks() {        parseCode(TEST_CATCH_BLOCKS);        ASTCatchStatement c = (ASTCatchStatement)(acu.findChildrenOfType(ASTCatchStatement.class)).get(0);        ASTBlock a = (ASTBlock)(c.findChildrenOfType(ASTBlock.class)).get(0);        Scope s = a.getScope();        Map vars = s.getParent().getVariableDeclarations();        assertEquals(1, vars.size());        VariableNameDeclaration v = (VariableNameDeclaration)vars.keySet().iterator().next();        assertEquals("e", v.getImage());        assertEquals(1, ((List)vars.get(v)).size());    }    public void testEq() {        parseCode(TEST_EQ);        ASTEqualityExpression e = (ASTEqualityExpression)(acu.findChildrenOfType(ASTEqualityExpression.class)).get(0);        ASTMethodDeclaration method = (ASTMethodDeclaration)e.getFirstParentOfType(ASTMethodDeclaration.class);        Scope s = method.getScope();        Map m = s.getVariableDeclarations();        for (Iterator i = m.keySet().iterator(); i.hasNext();) {            VariableNameDeclaration vnd = (VariableNameDeclaration)i.next();            SimpleNode node = vnd.getNode();            //System.out.println();        }        //System.out.println(m.size());    }*/    public void testFieldFinder() {        System.out.println(TEST_FIELD);        parseCode(TEST_FIELD);        ASTVariableDeclaratorId declaration = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0);        NameOccurrence no = declaration.getUsages().iterator().next();        SimpleNode location = no.getLocation();        System.out.println("variable " + declaration.getImage() + " is used here: " + location.getImage());    }/*    public void testDemo() {        parseCode(TEST_DEMO);        System.out.println(TEST_DEMO);        ASTMethodDeclaration node = (ASTMethodDeclaration) acu.findChildrenOfType(ASTMethodDeclaration.class).get(0);        Scope s = node.getScope();        Map m = s.getVariableDeclarations();        for (Iterator i = m.keySet().iterator(); i.hasNext();) {            VariableNameDeclaration d = (VariableNameDeclaration) i.next();            System.out.println("Variable: " + d.getImage());            System.out.println("Type: " + d.getTypeImage());        }    }*//*            List u = (List)m.get(d);            System.out.println("Usages: " + u.size());            NameOccurrence o = (NameOccurrence)u.get(0);            int beginLine = o.getLocation().getBeginLine();            System.out.println("Used in line " + beginLine);*/    private static final String TEST_DEMO =            "public class Foo  {" + PMD.EOL +            " void bar(ArrayList buz) { " + PMD.EOL +            " } " + PMD.EOL +            "}" + PMD.EOL;    private static final String TEST_EQ =            "public class Foo  {" + PMD.EOL +            " boolean foo(String a, String b) { " + PMD.EOL +            "  return a == b; " + PMD.EOL +            " } " + PMD.EOL +            "}" + PMD.EOL;    private static final String TEST1 =            "import java.io.*;" + PMD.EOL +            "public class Foo  {" + PMD.EOL +            " void buz( ) {" + PMD.EOL +            "  Object o = new Serializable() { int x; };" + PMD.EOL +            "  Object o1 = new Serializable() { int x; };" + PMD.EOL +            " }" + PMD.EOL +            "}" + PMD.EOL;    private static final String TEST_INITIALIZERS =            "public class Foo  {" + PMD.EOL +            " {} " + PMD.EOL +            " static {} " + PMD.EOL +            "}" + PMD.EOL;    private static final String TEST_CATCH_BLOCKS =            "public class Foo  {" + PMD.EOL +            " void foo() { " + PMD.EOL +            "  try { " + PMD.EOL +            "  } catch (Exception e) { " + PMD.EOL +            "   e.printStackTrace(); " + PMD.EOL +            "  } " + PMD.EOL +            " } " + PMD.EOL +            "}" + PMD.EOL;    private static final String TEST_FIELD =    "public class MyClass {" + PMD.EOL +    " private int a; " + PMD.EOL +    " boolean b = MyClass.ASCENDING; " + PMD.EOL +    "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.ImageFinderFunction;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.ArrayList;import java.util.List;public class ImageFinderFunctionTest extends TestCase {    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    public void testSeveralImages() {        List<String> imgs = new ArrayList<String>();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }}
package test.net.sourceforge.pmd.typeresolution;import net.sourceforge.pmd.typeresolution.PMDASMClassLoader;import java.util.Map;import junit.framework.TestCase;public class PMDASMClassLoaderTest extends TestCase {    private PMDASMClassLoader cl;    protected void setUp() throws Exception {        cl = new PMDASMClassLoader();        super.setUp();    }    public void testLoadClassWithImportOnDemand() throws Exception {        String className = "test.net.sourceforge.pmd.typeresolution.ClassWithImportOnDemand";        Class clazz = cl.loadClass(className);        assertNotNull(clazz);        Map imports = cl.getImportedClasses(className);        assertNotNull(imports);        assertEquals(4, imports.size());        assertEquals("java.util.List", imports.get("List"));        assertEquals("java.util.ArrayList", imports.get("ArrayList"));        assertEquals("java.lang.Object", imports.get("Object"));        assertEquals("test.net.sourceforge.pmd.typeresolution.ClassWithImportOnDemand", imports.get("ClassWithImportOnDemand"));    }        public void testClassWithImportInnerOnDemand() throws Exception {        String className = "test.net.sourceforge.pmd.typeresolution.ClassWithImportInnerOnDemand";        Class clazz = cl.loadClass(className);        assertNotNull(clazz);        Map imports = cl.getImportedClasses(className);        assertNotNull(imports);        System.err.println(imports);        assertEquals(8, imports.size());        assertEquals("java.util.Iterator", imports.get("Iterator"));        assertEquals("java.util.Map", imports.get("Map"));        assertEquals("java.util.Set", imports.get("Set"));        assertEquals("java.util.Map$Entry", imports.get("Entry"));        assertEquals("java.util.Map$Entry", imports.get("Map$Entry"));        assertEquals("java.util.Map$Entry", imports.get("Map$Entry"));        assertEquals("java.lang.Object", imports.get("Object"));        assertEquals("test.net.sourceforge.pmd.typeresolution.ClassWithImportInnerOnDemand", imports.get("ClassWithImportInnerOnDemand"));    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTPrimarySuffix;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTPrimarySuffixTest extends ParserTst {    public void testArrayDereference() throws Throwable {        Set ops = getNodes(ASTPrimarySuffix.class, TEST1);        assertTrue(((ASTPrimarySuffix) (ops.iterator().next())).isArrayDereference());    }    public void testArguments() throws Throwable {        Set ops = getNodes(ASTPrimarySuffix.class, TEST2);        assertTrue(((ASTPrimarySuffix) (ops.iterator().next())).isArguments());    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            "  {x[0] = 2;}" + PMD.EOL +            "}";    private static final String TEST2 =            "public class Foo {" + PMD.EOL +            "  {foo(a);}" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTLiteral;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTLiteralTest extends ParserTst {    public void testIsStringLiteral() throws Throwable {        Set literals = getNodes(ASTLiteral.class, TEST1);        assertTrue(((ASTLiteral)(literals.iterator().next())).isStringLiteral());    }    public void testIsNotStringLiteral() throws Throwable {        Set literals = getNodes(ASTLiteral.class, TEST2);        assertTrue(!((ASTLiteral)(literals.iterator().next())).isStringLiteral());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "  String x = \"foo\";" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "  int x = 42;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.Set;public class ClassDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, false, false);    }    public void testAbstract() throws Throwable {        String access[] = {"abstract"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, true, false, false);    }    public void testFinal() throws Throwable {        String access[] = {"final"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, true, false);    }    public void testStrict() throws Throwable {        String access[] = {"strictfp"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, false, true);    }    public void testPublicFinal() throws Throwable {        String access[] = {"public", "final"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, true, false);    }    public void verifyFlags(ASTClassOrInterfaceDeclaration acd, boolean bPublic, boolean bAbstract, boolean bFinal, boolean bStrict) {        assertEquals("Public: ", bPublic, acd.isPublic());        assertEquals("Abstract: ", bAbstract, acd.isAbstract());        assertEquals("Final: ", bFinal, acd.isFinal());        assertEquals("Strict: ", bStrict, acd.isStrictfp());    }    public ASTClassOrInterfaceDeclaration getClassDecl(String access[]) throws Throwable {        String javaCode = "";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " class Test { } ";        Set classes = getNodes(ASTClassOrInterfaceDeclaration.class, javaCode);        assertEquals("Wrong number of classes", 1, classes.size());        Iterator i = classes.iterator();        return (ASTClassOrInterfaceDeclaration) i.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.Set;public class FieldDeclTest extends ParserTst {    public String makeAccessJavaCode(String access[]) {        String result = "public class Test { ";        for (int i = 0; i < access.length; i++) {            result += access[i] + " ";        }        return result + " int j;  }";    }    public ASTFieldDeclaration getFieldDecl(String access[]) throws Throwable {        Set fields = getNodes(ASTFieldDeclaration.class, makeAccessJavaCode(access));        assertEquals("Wrong number of fields", 1, fields.size());        Iterator i = fields.iterator();        return (ASTFieldDeclaration) i.next();    }    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be protected.", afd.isProtected());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testStatic() throws Throwable {        String access[] = {"private", "static"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be static.", afd.isStatic());        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be final.", afd.isFinal());        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testTransient() throws Throwable {        String access[] = {"private", "transient"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());        assertTrue("Expecting field to be transient.", afd.isTransient());    }    public void testVolatile() throws Throwable {        String access[] = {"private", "volatile"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be volatile.", afd.isVolatile());        assertTrue("Expecting field to be private.", afd.isPrivate());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTAllocationExpression;import net.sourceforge.pmd.ast.ASTAssertStatement;import net.sourceforge.pmd.ast.ASTBlockStatement;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTBlockStatementTest extends ParserTst {    public void testIsAllocation() {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAllocationExpression(1), 0);        assertTrue(bs.isAllocation());    }    public void testIsAllocation2() {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAssertStatement(1), 0);        assertFalse(bs.isAllocation());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.Set;public class MethodDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be protected.", amd.isProtected());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be final.", amd.isFinal());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testSynchronized() throws Throwable {        String access[] = {"public", "synchronized"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be synchronized.", amd.isSynchronized());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testAbstract() throws Throwable {        String access[] = {"public", "abstract"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be abstract.", amd.isAbstract());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testNative() throws Throwable {        String access[] = {"private", "native"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be native.", amd.isNative());        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testStrict() throws Throwable {        String access[] = {"public", "strictfp"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be strict.", amd.isStrictfp());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public ASTMethodDeclaration getMethodDecl(String access[]) throws Throwable {        String javaCode = "public class Test { ";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " void stuff() { } }";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        assertEquals("Wrong number of methods", 1, methods.size());        Iterator i = methods.iterator();        return (ASTMethodDeclaration) i.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ParseException;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTImportDeclarationTest extends ParserTst {    public void testImportOnDemand() throws Throwable {        Set ops = getNodes(ASTImportDeclaration.class, TEST1);        assertTrue(((ASTImportDeclaration) (ops.iterator().next())).isImportOnDemand());    }    public void testGetImportedNameNode() throws Throwable {        ASTImportDeclaration i = getNodes(ASTImportDeclaration.class, TEST2).iterator().next();        assertEquals("foo.bar.Baz", i.getImportedName());    }    public void testStaticImport() throws Throwable {        Set ops = getNodes(new TargetJDK1_5(), ASTImportDeclaration.class, TEST3);        ASTImportDeclaration i = (ASTImportDeclaration) (ops.iterator().next());        assertTrue(i.isStatic());    }    public void testStaticImportFailsWithJDK14() throws Throwable {        try {            getNodes(ASTImportDeclaration.class, TEST3);            fail("Should have failed to parse a static import in JDK 1.4 mode");        } catch (ParseException pe) {            // cool        }    }    private static final String TEST1 =            "import foo.bar.*;" + PMD.EOL +            "public class Foo {}";    private static final String TEST2 =            "import foo.bar.Baz;" + PMD.EOL +            "public class Foo {}";    private static final String TEST3 =            "import static foo.bar.Baz;" + PMD.EOL +            "public class Foo {}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.ast.ASTAnnotation;import net.sourceforge.pmd.ast.ParseException;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTAnnotationTest extends ParserTst {    public void testAnnotationFailsWithJDK14() throws Throwable {        try {            getNodes(ASTAnnotation.class, TEST1);            // FIXME fail("Should have failed to parse an annotation in JDK 1.4 mode");        } catch (ParseException pe) {            // cool        }    }    public void testAnnotationSucceedsWithJDK15() throws Throwable {        try {            getNodes(new TargetJDK1_5(), ASTAnnotation.class, TEST1);        } catch (ParseException pe) {            pe.printStackTrace();            fail("Should have been able to parse an annotation in JDK 1.5 mode");        }    }    private static final String TEST1 =            "public class Foo extends Buz {" + PMD.EOL +            " @Override" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  // overrides a superclass method" + PMD.EOL +            " }" + PMD.EOL +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTClassOrInterfaceType;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTVariableDeclaratorIdTest extends ParserTst {    public void testIsExceptionBlockParameter() {        ASTTryStatement tryNode = new ASTTryStatement(1);        ASTBlock block = new ASTBlock(2);        ASTVariableDeclaratorId v = new ASTVariableDeclaratorId(3);        v.jjtSetParent(block);        block.jjtSetParent(tryNode);        assertTrue(v.isExceptionBlockParameter());    }    public void testTypeNameNode() throws Throwable {        ASTCompilationUnit acu = super.getNodes(ASTCompilationUnit.class, TYPE_NAME_NODE).iterator().next();        ASTVariableDeclaratorId id = acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode().jjtGetChild(0);        assertEquals("String", name.getImage());    }    private static final String TYPE_NAME_NODE =            "public class Test {" + PMD.EOL +            "  private String bar;" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import test.net.sourceforge.pmd.testframework.ParserTst;import java.io.StringReader;public class ParserCornersTest extends ParserTst {    public final void testGetFirstASTNameImageNull() throws Throwable {        new TargetJDK1_4().createParser(new StringReader(ABSTRACT_METHOD_LEVEL_CLASS_DECL)).CompilationUnit();    }    private static final String ABSTRACT_METHOD_LEVEL_CLASS_DECL =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   abstract class X { public abstract void f(); }" + PMD.EOL +            "   class Y extends X { public void f() {" + PMD.EOL +            "    new Y().f();" + PMD.EOL +            "   }}" + PMD.EOL +            "  }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.ast.JavaParser;import test.net.sourceforge.pmd.testframework.ParserTst;import java.io.StringReader;public class ASTLocalVariableDeclarationTest extends ParserTst {    public void testSingleDimArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST1));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTLocalVariableDeclaration node = cu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(1, node.getArrayDepth());    }    public void testMultDimArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST2));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTLocalVariableDeclaration node = cu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(2, node.getArrayDepth());    }    public void testMultDimArraySplitBraces() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST3));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTLocalVariableDeclaration node = cu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    private static final String TEST1 =            "class Foo {" + PMD.EOL +            " void bar() {int x[] = null;}" + PMD.EOL +            "}";    private static final String TEST2 =            "class Foo {" + PMD.EOL +            " void bar() {int x[][] = null;}" + PMD.EOL +            "}";    private static final String TEST3 =            "class Foo {" + PMD.EOL +            " void bar() {int[] x[][] = null;}" + PMD.EOL +            "}";}
/* * Created on Jan 19, 2005  * * $Id$ */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTThrowStatement;import test.net.sourceforge.pmd.testframework.ParserTst;/** * @author mgriffa */public class ASTThrowStatementTest extends ParserTst {    public final void testGetFirstASTNameImageNull() throws Throwable {        ASTThrowStatement t = getNodes(ASTThrowStatement.class, NULL_NAME).iterator().next();        assertNull(t.getFirstClassOrInterfaceTypeImage());    }    public final void testGetFirstASTNameImageNew() throws Throwable {        ASTThrowStatement t = getNodes(ASTThrowStatement.class, OK_NAME).iterator().next();        assertEquals("FooException", t.getFirstClassOrInterfaceTypeImage());    }    private static final String NULL_NAME =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   throw e;" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String OK_NAME =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   throw new FooException();" + PMD.EOL +            "  }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import net.sourceforge.pmd.ast.ASTType;import net.sourceforge.pmd.ast.ASTVariableDeclarator;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.Dimensionable;import net.sourceforge.pmd.ast.JavaParser;import test.net.sourceforge.pmd.testframework.ParserTst;import java.io.StringReader;public class ASTFieldDeclarationTest extends ParserTst {    public void testIsArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST1));        ASTCompilationUnit cu = parser.CompilationUnit();        Dimensionable node = cu.findChildrenOfType(ASTFieldDeclaration.class).get(0);        assertTrue(node.isArray());        assertEquals(1, node.getArrayDepth());    }    public void testMultiDimensionalArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST2));        ASTCompilationUnit cu = parser.CompilationUnit();        Dimensionable node = cu.findChildrenOfType(ASTFieldDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    public void testIsSyntacticallyPublic() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST3));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTFieldDeclaration node = cu.findChildrenOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isSyntacticallyPublic());        assertFalse(node.isPackagePrivate());        assertFalse(node.isPrivate());        assertFalse(node.isProtected());        assertTrue(node.isFinal());        assertTrue(node.isStatic());        assertTrue(node.isPublic());    }    public void testWithEnum() {        JavaParser parser = (new TargetJDK1_5()).createParser(new StringReader(TEST4));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTFieldDeclaration node = cu.findChildrenOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isInterfaceMember());    }    private static final String TEST1 =            "class Foo {" + PMD.EOL +            " String[] foo;" + PMD.EOL +            "}";    private static final String TEST2 =            "class Foo {" + PMD.EOL +            " String[][][] foo;" + PMD.EOL +            "}";    private static final String TEST3 =            "interface Foo {" + PMD.EOL +            " int BAR = 6;" + PMD.EOL +            "}";    private static final String TEST4 =            "public enum Foo {" + PMD.EOL +            " FOO(1);" + PMD.EOL +            " private int x;" + PMD.EOL +            "}";    public void testGetVariableName() {        int id = 0;        ASTFieldDeclaration n = new ASTFieldDeclaration(id++);        ASTType t = new ASTType(id++);        ASTVariableDeclarator decl = new ASTVariableDeclarator(id++);        ASTVariableDeclaratorId declid = new ASTVariableDeclaratorId(id++);        n.jjtAddChild(t, 0);        t.jjtAddChild(decl, 0);        decl.jjtAddChild(declid, 0);        declid.setImage("foo");        assertEquals("foo", n.getVariableName());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTInitializer;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTInitializerTest extends ParserTst {    public void testDontCrashOnBlockStatement() throws Throwable {        try {            getNodes(ASTInitializer.class, TEST1);        } catch (Exception e) {            // FIXME            // e.printStackTrace();            //fail("Couldn't parse:\n" + TEST1);        }    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            " {" + PMD.EOL +            "   x = 5;" + PMD.EOL +            " }" + PMD.EOL +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.AccessNode;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class AccessNodeTest extends ParserTst {    public void testModifiersOnClassDecl() throws Throwable {        Set ops = getNodes(ASTClassOrInterfaceDeclaration.class, TEST1);        assertTrue(((ASTClassOrInterfaceDeclaration) (ops.iterator().next())).isPublic());    }    private static final String TEST1 =            "public class Foo {}";    public void testStatic() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not static.", node.isStatic());        node.setStatic();        assertTrue("Node set to static, not static.", node.isStatic());    }    public void testPublic() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not public.", node.isPublic());        node.setPublic();        assertTrue("Node set to public, not public.", node.isPublic());    }    public void testProtected() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not protected.", node.isProtected());        node.setProtected();        assertTrue("Node set to protected, not protected.", node.isProtected());    }    public void testPrivate() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not private.", node.isPrivate());        node.setPrivate();        assertTrue("Node set to private, not private.", node.isPrivate());    }    public void testFinal() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not final.", node.isFinal());        node.setFinal();        assertTrue("Node set to final, not final.", node.isFinal());    }    public void testSynchronized() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not synchronized.", node.isSynchronized());        node.setSynchronized();        assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());    }    public void testVolatile() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not volatile.", node.isVolatile());        node.setVolatile();        assertTrue("Node set to volatile, not volatile.", node.isVolatile());    }    public void testTransient() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not transient.", node.isTransient());        node.setTransient();        assertTrue("Node set to transient, not transient.", node.isTransient());    }    public void testNative() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not native.", node.isNative());        node.setNative();        assertTrue("Node set to native, not native.", node.isNative());    }    public void testAbstract() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not abstract.", node.isAbstract());        node.setAbstract();        assertTrue("Node set to abstract, not abstract.", node.isAbstract());    }    public void testStrict() {        AccessNode node = new AccessNode(1);        assertFalse("Node should default to not strict.", node.isStrictfp());        node.setStrictfp();        assertTrue("Node set to strict, not strict.", node.isStrictfp());    }    public void testPackagePrivate() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to package private.", node.isPackagePrivate());        node.setPrivate();        assertFalse("Node set to private, still package private.", node.isPackagePrivate());        node = new AccessNode(1);        node.setPublic();        assertFalse("Node set to public, still package private.", node.isPackagePrivate());        node = new AccessNode(1);        node.setProtected();        assertFalse("Node set to protected, still package private.", node.isPackagePrivate());    }}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import java.io.ByteArrayInputStream;import java.io.InputStreamReader;public class EncodingTest extends TestCase {    public void testDecodingOfUTF8() throws Throwable {        //String platformEncoding = System.getProperty("file.encoding");        //String encoding = "ISO-8859-1";        String encoding = "UTF-8";        String code = new String(TEST_UTF8.getBytes(), encoding);        InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(code.getBytes()));        //FIXME/*        ASTCompilationUnit acu = new TargetJDK1_4().createParser(isr).CompilationUnit();        String methodName = ((ASTMethodDeclarator)acu.findChildrenOfType(ASTMethodDeclarator.class).get(0)).getImage();        assertEquals(new String("".getBytes(), encoding), methodName);*/    }    private static final String TEST_UTF8 =            "class Foo {" + PMD.EOL +            " void () {}" + PMD.EOL +            " void fiddle() {}" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTBooleanLiteral;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTBooleanLiteralTest extends ParserTst {    public void testTrue() throws Throwable {        Set ops = getNodes(ASTBooleanLiteral.class, TEST1);        ASTBooleanLiteral b = (ASTBooleanLiteral) ops.iterator().next();        assertTrue(b.isTrue());    }    public void testFalse() throws Throwable {        Set ops = getNodes(ASTBooleanLiteral.class, TEST2);        ASTBooleanLiteral b = (ASTBooleanLiteral) ops.iterator().next();        assertTrue(!b.isTrue());    }    private static final String TEST1 =            "class Foo { " + PMD.EOL +            " boolean bar = true; " + PMD.EOL +            "} ";    private static final String TEST2 =            "class Foo { " + PMD.EOL +            " boolean bar = false; " + PMD.EOL +            "} ";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTSwitchLabel;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTSwitchLabelTest extends ParserTst {    public void testDefaultOff() throws Throwable {        Set ops = getNodes(ASTSwitchLabel.class, TEST1);        assertFalse(((ASTSwitchLabel) (ops.iterator().next())).isDefault());    }    public void testDefaultSet() throws Throwable {        Set ops = getNodes(ASTSwitchLabel.class, TEST2);        assertTrue(((ASTSwitchLabel) (ops.iterator().next())).isDefault());    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  switch (x) {" + PMD.EOL +            "   case 1: y = 2;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST2 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  switch (x) {" + PMD.EOL +            "   default: y = 2;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclarator;public class ASTMethodDeclarationTest extends TestCase {    public void testGetVariableName() {        int id = 0;        ASTMethodDeclaration md = new ASTMethodDeclaration(id++);        ASTMethodDeclarator de = new ASTMethodDeclarator(id++);        de.setImage("foo");        md.jjtAddChild(de, 0);        assertEquals("foo", md.getMethodName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTAssignmentOperator;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTBlockStatement;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTExpression;import net.sourceforge.pmd.ast.ASTExtendsList;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import net.sourceforge.pmd.ast.ASTImplementsList;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTReturnStatement;import net.sourceforge.pmd.ast.ASTStatement;import net.sourceforge.pmd.ast.ASTVariableInitializer;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.ast.SimpleNode;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set;public class SimpleNodeTest extends ParserTst {    public void testMethodDiffLines() throws Throwable {        Set methods = getNodes(ASTMethodDeclaration.class, METHOD_DIFF_LINES);        Iterator iter = methods.iterator();        verifyNode((SimpleNode) iter.next(), 2, 9, 4, 2);    }    public void testMethodSameLine() throws Throwable {        Set methods = getNodes(ASTMethodDeclaration.class, METHOD_SAME_LINE);        verifyNode((SimpleNode) methods.iterator().next(), 2, 9, 2, 21);    }    public void testNoLookahead() throws Throwable {        String code = NO_LOOKAHEAD; // 1, 8 -> 1, 20        Set uCD = getNodes(ASTClassOrInterfaceDeclaration.class, code);        verifyNode((SimpleNode) uCD.iterator().next(), 1, 8, 1, 20);    }    public void testHasExplicitExtends() throws Throwable {        String code = HAS_EXPLICIT_EXTENDS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertTrue(ucd.jjtGetChild(0) instanceof ASTExtendsList);    }    public void testNoExplicitExtends() throws Throwable {        String code = NO_EXPLICIT_EXTENDS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertFalse(ucd.jjtGetChild(0) instanceof ASTExtendsList);    }    public void testHasExplicitImplements() throws Throwable {        String code = HAS_EXPLICIT_IMPLEMENTS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertTrue(ucd.jjtGetChild(0) instanceof ASTImplementsList);    }    public void testNoExplicitImplements() throws Throwable {        String code = NO_EXPLICIT_IMPLEMENTS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertFalse(ucd.jjtGetChild(0) instanceof ASTImplementsList);    }    public void testColumnsOnQualifiedName() throws Throwable {        Set name = getNodes(ASTName.class, QUALIFIED_NAME);        Iterator i = name.iterator();        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 1, 19);            }        }    }    public void testLineNumbersForNameSplitOverTwoLines() throws Throwable {        Set name = getNodes(ASTName.class, BROKEN_LINE_IN_NAME);        Iterator i = name.iterator();        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 2, 4);            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 18);            }        }    }    public void testLineNumbersAreSetOnAllSiblings() throws Throwable {        Set blocks = getNodes(ASTBlock.class, LINE_NUMBERS_ON_SIBLINGS);        Iterator i = blocks.iterator();        while (i.hasNext()) {            ASTBlock b = (ASTBlock) i.next();            assertTrue(b.getBeginLine() > 0);        }        blocks = getNodes(ASTVariableInitializer.class, LINE_NUMBERS_ON_SIBLINGS);        i = blocks.iterator();        while (i.hasNext()) {            ASTVariableInitializer b = (ASTVariableInitializer) i.next();            assertTrue(b.getBeginLine() > 0);        }        blocks = getNodes(ASTExpression.class, LINE_NUMBERS_ON_SIBLINGS);        i = blocks.iterator();        while (i.hasNext()) {            ASTExpression b = (ASTExpression) i.next();            assertTrue(b.getBeginLine() > 0);        }    }    public void testFindChildrenOfType() {        ASTBlock block = new ASTBlock(2);        block.jjtAddChild(new ASTReturnStatement(1), 0);        assertEquals(1, block.findChildrenOfType(ASTReturnStatement.class).size());    }    public void testFindChildrenOfTypeMultiple() {        ASTBlock block = new ASTBlock(1);        block.jjtAddChild(new ASTBlockStatement(2), 0);        block.jjtAddChild(new ASTBlockStatement(3), 1);        List<ASTBlockStatement> nodes = new ArrayList<ASTBlockStatement>();        block.findChildrenOfType(ASTBlockStatement.class, nodes);        assertEquals(2, nodes.size());    }    public void testFindChildrenOfTypeRecurse() {        ASTBlock block = new ASTBlock(1);        ASTBlock childBlock = new ASTBlock(2);        block.jjtAddChild(childBlock, 0);        childBlock.jjtAddChild(new ASTMethodDeclaration(3), 0);        List<ASTMethodDeclaration> nodes = new ArrayList<ASTMethodDeclaration>();        block.findChildrenOfType(ASTMethodDeclaration.class, nodes);        assertEquals(1, nodes.size());    }    public void testGetFirstChild() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstChildOfType(ASTStatement.class);        assertNotNull(n);        assertTrue(n instanceof ASTStatement);        assertEquals(x, n);    }    public void testGetFirstChildNested() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        x.jjtAddChild(x1, 1);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstChildOfType(ASTAssignmentOperator.class);        assertNotNull(n);        assertTrue(n instanceof ASTAssignmentOperator);        assertEquals(x1, n);    }    public void testGetFirstChildNestedDeeper() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        ASTName x2 = new ASTName(5);        x.jjtAddChild(x1, 1);        x1.jjtAddChild(x2, 0);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstChildOfType(ASTName.class);        assertNotNull(n);        assertTrue(n instanceof ASTName);        assertEquals(x2, n);    }/*    public void testContainsNoInner() throws Throwable {        ASTCompilationUnit c = (ASTCompilationUnit) getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER).iterator().next();        List res = new ArrayList();        c.findChildrenOfType(ASTFieldDeclaration.class, res, false);        assertTrue(res.isEmpty());        String expectedXml = "<CompilationUnit BeginColumn=\"1\" BeginLine=\"5\" EndColumn=\"1\" EndLine=\"5\">" +                "<TypeDeclaration BeginColumn=\"1\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">" +                "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"8\" BeginLine=\"1\" EndColumn=\"1\" " +                "EndLine=\"5\" Final=\"false\" Image=\"Test\" Interface=\"false\" Native=\"false\" Nested=\"false\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">" +                "<ClassOrInterfaceBody BeginColumn=\"19\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">" +                "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"3\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">" +                "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"10\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\" Final=\"false\" " +                "Image=\"Inner\" Interface=\"false\" Native=\"false\" Nested=\"true\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" " +                "Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">" +                "<ClassOrInterfaceBody BeginColumn=\"22\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">" +                "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\">" +                "<FieldDeclaration Abstract=\"false\" Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\" Final=\"false\" Native=\"false\" PackagePrivate=\"true\" Private=\"false\" Protected=\"false\" Public=\"false\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" VariableName=\"foo\" Volatile=\"false\"><Type Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"6\" EndLine=\"3\">" +                "<PrimitiveType Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" Boolean=\"false\" EndColumn=\"6\" EndLine=\"3\" Image=\"int\"/>" +                "</Type>" +                "<VariableDeclarator BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\">" +                "<VariableDeclaratorId Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\" ExceptionBlockParameter=\"false\" Image=\"foo\"/>" +                "</VariableDeclarator></FieldDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody>" +                "</ClassOrInterfaceDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody></ClassOrInterfaceDeclaration>" +                "</TypeDeclaration></CompilationUnit>";        assertEquals( expectedXml, getXmlString( c ) );    }*/    public void testContainsNoInnerWithAnonInner() throws Throwable {        ASTCompilationUnit c = getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER_WITH_ANON_INNER).iterator().next();        List<ASTFieldDeclaration> res = new ArrayList<ASTFieldDeclaration>();        c.findChildrenOfType(ASTFieldDeclaration.class, res, false);        assertTrue(res.isEmpty());    }    public void testContainsChildOfType() throws Throwable {        ASTClassOrInterfaceDeclaration c = getNodes(ASTClassOrInterfaceDeclaration.class, CONTAINS_CHILDREN_OF_TYPE).iterator().next();        assertTrue(c.containsChildOfType(ASTFieldDeclaration.class));    }    public void testXPathNodeSelect() throws Throwable {        ASTClassOrInterfaceDeclaration c = getNodes(ASTClassOrInterfaceDeclaration.class, TEST_XPATH).iterator().next();        List nodes = c.findChildNodesWithXPath("//FieldDeclaration");        assertEquals(2, nodes.size());        assertTrue(nodes.get(0) instanceof ASTFieldDeclaration);    }    private void verifyNode(SimpleNode node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Unexpected beginning line: ", beginLine, node.getBeginLine());        assertEquals("Unexpected beginning column: ", beginCol, node.getBeginColumn());        assertEquals("Unexpected ending line:", endLine, node.getEndLine());        assertEquals("Unexpected ending column:", endCol, node.getEndColumn());    }    private static final String HAS_EXPLICIT_EXTENDS =            "public class Test extends Foo {}";    private static final String NO_EXPLICIT_EXTENDS =            "public class Test {}";    private static final String HAS_EXPLICIT_IMPLEMENTS =            "public class Test implements Foo {}";    private static final String NO_EXPLICIT_IMPLEMENTS =            "public class Test {}";    private static final String METHOD_SAME_LINE =            "public class Test {" + PMD.EOL +            " public void foo() {}" + PMD.EOL +            "}";    private static final String QUALIFIED_NAME =            "import java.io.File;" + PMD.EOL +            "public class Foo{}";    private static final String BROKEN_LINE_IN_NAME =            "import java.io." + PMD.EOL +            "File;" + PMD.EOL +            "public class Foo{}";    private static final String LINE_NUMBERS_ON_SIBLINGS =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  try {" + PMD.EOL +            "  } catch (Exception1 e) {" + PMD.EOL +            "   int x =2;" + PMD.EOL +            "  }" + PMD.EOL +            " if (x != null) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String NO_LOOKAHEAD = "public class Foo { }";    private static final String METHOD_DIFF_LINES =            "public class Test {" + PMD.EOL +            " public void foo() {" + PMD.EOL +            "  int x;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String CONTAINS_CHILDREN_OF_TYPE =            "public class Test {" + PMD.EOL +            "  int x;" + PMD.EOL +            "}";    private static final String CONTAINS_NO_INNER =            "public class Test {" + PMD.EOL +            "  public class Inner {" + PMD.EOL +            "   int foo;" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String CONTAINS_NO_INNER_WITH_ANON_INNER =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   foo(new Fuz() { int x = 2;});" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String TEST_XPATH =            "public class Test {" + PMD.EOL +            "  int x = 2;" + PMD.EOL +            "  int y = 42;" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_3;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.TargetJDKVersion;import net.sourceforge.pmd.ast.JavaParser;import net.sourceforge.pmd.ast.ParseException;import java.io.StringReader;public class JDKVersionTest extends TestCase {    // enum keyword/identifier    public void testEnumAsKeywordShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_ENUM));            p.CompilationUnit();            throw new Error("JDK 1.4 parser should have failed to parse enum used as keyword");        } catch (ParseException e) {        }    // cool    }    public void testEnumAsIdentifierShouldPassWith14() throws Throwable {        JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK14_ENUM));        p.CompilationUnit();    }    public void testEnumAsKeywordShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_ENUM));        p.CompilationUnit();    }    public void testEnumAsIdentifierShouldFailWith15() throws Throwable {        try {            TargetJDKVersion jdk = new TargetJDK1_5();            JavaParser p = jdk.createParser(new StringReader(JDK14_ENUM));            p.CompilationUnit();            throw new Error("JDK 1.5 parser should have failed to parse enum used as identifier");        } catch (ParseException e) {        }    // cool    }    // enum keyword/identifier    // assert keyword/identifier    public void testAssertAsKeywordVariantsSucceedWith1_4() {        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST1)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST2)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST3)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST4)).CompilationUnit();    }    public void testAssertAsVariableDeclIdentifierFailsWith1_4() {        try {            (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST5)).CompilationUnit();            throw new RuntimeException("Usage of assert as identifier should have failed with 1.4");        } catch (ParseException pe) {            // cool        }    }    public void testAssertAsMethodNameIdentifierFailsWith1_4() {        try {            (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST7)).CompilationUnit();            throw new RuntimeException("Usage of assert as identifier should have failed with 1.4");        } catch (ParseException pe) {            // cool        }    }    public void testAssertAsIdentifierSucceedsWith1_3() {        JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST5));        jp.CompilationUnit();    }    public void testAssertAsKeywordFailsWith1_3() {        try {            JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST6));            jp.CompilationUnit();            throw new RuntimeException("Usage of assert as keyword should have failed with 1.3");        } catch (ParseException pe) {            // cool        }    }    // assert keyword/identifier    public void testVarargsShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_VARARGS));        p.CompilationUnit();    }    public void testVarargsShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_VARARGS));            p.CompilationUnit();            fail("Should have throw ParseException!");        } catch (ParseException pe) {            // cool        }    }    public void testJDK15ForLoopSyntaxShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_FORLOOP));        p.CompilationUnit();    }    public void testJDK15ForLoopSyntaxWithModifiers() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_FORLOOP_WITH_MODIFIER));        p.CompilationUnit();    }    public void testJDK15ForLoopShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_FORLOOP));            p.CompilationUnit();            fail("Should have throw ParseException!");        } catch (ParseException pe) {            // cool        }    }    public void testJDK15GenericsSyntaxShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_GENERICS));        p.CompilationUnit();    }    public void testVariousParserBugs() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(FIELDS_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(GT_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(ANNOTATIONS_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(GENERIC_IN_FIELD));        p.CompilationUnit();    }    public void testNestedClassInMethodBug() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(INNER_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(INNER_BUG2));        p.CompilationUnit();    }    public void testGenericsInMethodCall() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(GENERIC_IN_METHOD_CALL));        p.CompilationUnit();    }    public void testGenericINAnnotation() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(GENERIC_IN_ANNOTATION));        p.CompilationUnit();    }    public void testGenericReturnType() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(GENERIC_RETURN_TYPE));        p.CompilationUnit();    }    public void testMultipleGenerics() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(FUNKY_GENERICS));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(MULTIPLE_GENERICS));        p.CompilationUnit();    }    public void testAnnotatedParams() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(ANNOTATED_PARAMS));        p.CompilationUnit();    }    public void testAnnotatedLocals() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(ANNOTATED_LOCALS));        p.CompilationUnit();    }    public void testAssertAsIdentifierSucceedsWith1_3_test2() {        JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST5_a));        jp.CompilationUnit();    }    private static final String ANNOTATED_LOCALS =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  @SuppressWarnings(\"foo\") int y = 5;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String ANNOTATED_PARAMS =            "public class Foo {" + PMD.EOL +            " void bar(@SuppressWarnings(\"foo\") int x) {}" + PMD.EOL +            "}";    private static final String ASSERT_TEST1 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  assert x == 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String ASSERT_TEST2 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  assert (x == 2);" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String ASSERT_TEST3 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  assert (x==2) : \"hi!\";" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String ASSERT_TEST4 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  assert (x==2) : \"hi!\";" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String ASSERT_TEST5 =            "public class Foo {" + PMD.EOL +            "  int assert = 2;" + PMD.EOL +            "}";    private static final String ASSERT_TEST5_a =            "public class Foo {" + PMD.EOL +            "  void bar() { assert(); }" + PMD.EOL +            "}";    private static final String ASSERT_TEST6 =            "public class Foo {" + PMD.EOL +            " void foo() {" + PMD.EOL +            "  assert (x == 2) : \"hi!\";" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String ASSERT_TEST7 =            "public class Foo {" + PMD.EOL +            " void assert() {}" + PMD.EOL +            "}";    private static final String JDK15_ENUM =            "public class Test {" + PMD.EOL +            " enum Season { winter, spring, summer, fall };" + PMD.EOL +            "}";    private static final String JDK14_ENUM =            "public class Test {" + PMD.EOL +            " int enum;" + PMD.EOL +            "}";    private static final String JDK15_VARARGS =            "public class Test {" + PMD.EOL +            " void bar(Object ... args) {}" + PMD.EOL +            "}";    private static final String JDK15_FORLOOP =            "public class Test {" + PMD.EOL +            " void foo(List list) {" + PMD.EOL +            "  for (Integer i : list) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String JDK15_FORLOOP_WITH_MODIFIER =            "public class Test {" + PMD.EOL +            " void foo(List list) {" + PMD.EOL +            "  for (final Integer i : list) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String JDK15_GENERICS =            "public class Test {" + PMD.EOL +            "  ArrayList<Integer> list =  new ArrayList<Integer>();" + PMD.EOL +            "}";    private static final String FIELDS_BUG =            "public class Test {" + PMD.EOL +            "  private Foo bar;" + PMD.EOL +            "}";    private static final String GT_BUG =            "public class Test {" + PMD.EOL +            "  int y = x > 32;" + PMD.EOL +            "}";    private static final String ANNOTATIONS_BUG =            "@Target(ElementType.METHOD)" + PMD.EOL +            "public @interface Foo {" + PMD.EOL +            "}";    private static final String GENERIC_IN_FIELD =            "public class Foo {" + PMD.EOL +            " Class<Double> foo = (Class<Double>)clazz;" + PMD.EOL +            "}";    private static final String GENERIC_IN_ANNOTATION =            "public class Foo {" + PMD.EOL +            " public <A extends Annotation> A foo(Class<A> c) {" + PMD.EOL +            "  return null;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String INNER_BUG =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   final class Inner {};" + PMD.EOL +            "   Inner i = new Inner();" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String INNER_BUG2 =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   class Inner {};" + PMD.EOL +            "   Inner i = new Inner();" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String GENERIC_IN_METHOD_CALL =            "public class Test {" + PMD.EOL +            "  List<String> test() {" + PMD.EOL +            "   return Collections.<String>emptyList();" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String GENERIC_RETURN_TYPE =            "public class Test {" + PMD.EOL +            "  public static <String> String test(String x) {" + PMD.EOL +            "   return x;" + PMD.EOL +            "  }" + PMD.EOL +            "}";    // See java/lang/concurrent/ConcurrentHashMap    private static final String MULTIPLE_GENERICS =            "public class Foo<K,V> {" + PMD.EOL +            "  public <A extends K, B extends V> Foo(Bar<A,B> t) {}" + PMD.EOL +            "}";    // See java/lang/concurrent/CopyOnWriteArraySet    private static final String FUNKY_GENERICS =            "public class Foo {" + PMD.EOL +            "  public <T extends E> Foo() {}" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTAssignmentOperator;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTAssignmentOperatorTest extends ParserTst {    public void testSimpleAssignmentRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST1);        assertTrue(!((ASTAssignmentOperator) (ops.iterator().next())).isCompound());    }    public void testCompoundAssignmentPlusRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST2);        assertTrue(((ASTAssignmentOperator) (ops.iterator().next())).isCompound());    }    public void testCompoundAssignmentMultRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST3);        assertTrue(((ASTAssignmentOperator) (ops.iterator().next())).isCompound());    }    private static final String TEST1 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x;" + PMD.EOL +            "  x=2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST2 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x;" + PMD.EOL +            "  x += 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String TEST3 =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  int x;" + PMD.EOL +            "  x *= 2;" + PMD.EOL +            " }" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import java.util.Iterator;import java.util.Set;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTFormalParameterTest extends ParserTst {    public void testVarargs() throws Throwable {        int nrOfVarArgs   = 0;        int nrOfNoVarArgs = 0;                Set ops = getNodes(new TargetJDK1_5(), ASTFormalParameter.class, TEST1);        for (Iterator iter = ops.iterator(); iter.hasNext();) {            ASTFormalParameter b = (ASTFormalParameter) iter.next();            ASTVariableDeclaratorId variableDeclId = b.getFirstChildOfType(ASTVariableDeclaratorId.class);            if (!"x".equals(variableDeclId.getImage())) {                assertTrue(b.isVarargs());                nrOfVarArgs++;            } else {                assertFalse(b.isVarargs());                nrOfNoVarArgs++;            }        }                //Ensure that both possibilities are tested        assertEquals(1, nrOfVarArgs);        assertEquals(1, nrOfNoVarArgs);    }    private static final String TEST1 =            "class Foo {" + PMD.EOL +            " void bar(int x, int... others) {}" + PMD.EOL +            "}";}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.ExternalRuleID;public class ExternalRuleIDTest extends TestCase {    public void testSimpleRef() {        String xrefString = "rulesets/basic.xml/EmptyCatchBlock";        ExternalRuleID xref = new ExternalRuleID(xrefString);        assertEquals("Filename mismatch!", "rulesets/basic.xml", xref.getFilename());        assertEquals("Rule name mismatch!", "EmptyCatchBlock", xref.getRuleName());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.SourceType;import net.sourceforge.pmd.SourceTypeDiscoverer;import java.io.File;public class SourceTypeDiscovererTest extends TestCase {    /**     * Test on JSP file.     */    public void testJspFile() {        SourceTypeDiscoverer discoverer = new SourceTypeDiscoverer();        File jspFile = new File("/path/to/MyPage.jsp");        SourceType type = discoverer.getSourceTypeOfFile(jspFile);        assertEquals("SourceType must be JSP!", SourceType.JSP, type);    }    /**     * Test on Java file with default options.     */    public void testJavaFileUsingDefaults() {        SourceTypeDiscoverer discoverer = new SourceTypeDiscoverer();        File javaFile = new File("/path/to/MyClass.java");        SourceType type = discoverer.getSourceTypeOfFile(javaFile);        assertEquals("SourceType must be Java 1.4!", SourceType.JAVA_14, type);    }    /**     * Test on Java file with Java version set to 1.5.     */    public void testJavaFileUsing15() {        SourceTypeDiscoverer discoverer = new SourceTypeDiscoverer();        discoverer.setSourceTypeOfJavaFiles(SourceType.JAVA_15);        File javaFile = new File("/path/to/MyClass.java");        SourceType type = discoverer.getSourceTypeOfFile(javaFile);        assertEquals("SourceType must be Java 1.5!", SourceType.JAVA_15, type);    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.SourceFileSelector;import java.io.File;/** * Tests on FileSelector. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be */public class FileSelectorTest extends TestCase {    /**     * Test default selection of .java files.     */    public void testSelectJavaFile() {        SourceFileSelector fileSelector = new SourceFileSelector();        File javaFile = new File("/path/to/MyClass.java");        boolean selected = fileSelector.isWantedFile(javaFile);        assertEquals("Java file must be selected!", true, selected);    }    /**     * Test wanted selection of .jsp files.     */    public void testSelectJspFile() {        SourceFileSelector fileSelector = new SourceFileSelector();        fileSelector.setSelectJspFiles(true);        File javaFile = new File("/path/to/MyPage.jsp");        boolean selected = fileSelector.isWantedFile(javaFile);        assertEquals("Jsp file must be selected!", true, selected);    }    /**     * Test unwanted selection of a non source file.     */    public void testUnwantedFile() {        SourceFileSelector fileSelector = new SourceFileSelector();        File javaFile = new File("/path/to/myFile.txt");        boolean selected = fileSelector.isWantedFile(javaFile);        assertEquals("Not-source file must not be selected!", false, selected);    }    /**     * Test unwanted selection of a java file.     */    public void testUnwantedJavaFile() {        SourceFileSelector fileSelector = new SourceFileSelector();        fileSelector.setSelectJavaFiles(false);        File javaFile = new File("/path/to/MyClass.java");        boolean selected = fileSelector.isWantedFile(javaFile);        assertEquals("Unwanted java file must not be selected!", false, selected);    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.CommandLineOptions;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.EmacsRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.IDEAJRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.VBHTMLRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;import java.io.InputStreamReader;public class CommandLineOptionsTest extends TestCase {    public void testTargetJDKVersion() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic"});        assertEquals("1.4", opt.getTargetJDK());        opt = new CommandLineOptions(new String[]{"file", "format", "ruleset", "-targetjdk", "1.3"});        assertEquals("1.3", opt.getTargetJDK());        opt = new CommandLineOptions(new String[]{"file", "format", "ruleset", "-targetjdk", "1.5"});        assertEquals("1.5", opt.getTargetJDK());        opt = new CommandLineOptions(new String[]{"file", "format", "ruleset", "-targetjdk", "1.6"});        assertEquals("1.6", opt.getTargetJDK());        opt = new CommandLineOptions(new String[]{"-targetjdk", "1.6", "file", "format", "ruleset"});        assertEquals("1.6", opt.getTargetJDK());    }    public void testDebug() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic", "-debug"});        assertTrue(opt.debugEnabled());        opt = new CommandLineOptions(new String[]{"-debug", "file", "format", "basic"});        assertTrue(opt.debugEnabled());    }    public void testExcludeMarker() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic", "-excludemarker", "FOOBAR"});        assertEquals("FOOBAR", opt.getExcludeMarker());        opt = new CommandLineOptions(new String[]{"-excludemarker", "FOOBAR", "file", "format", "basic"});        assertEquals("FOOBAR", opt.getExcludeMarker());    }    public void testShortNames() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic", "-shortnames"});        assertTrue(opt.shortNamesEnabled());        opt = new CommandLineOptions(new String[]{"-shortnames", "file", "format", "basic"});        assertTrue(opt.shortNamesEnabled());    }    public void testEncoding() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic"});        assertTrue(opt.getEncoding().equals((new InputStreamReader(System.in)).getEncoding()));        opt = new CommandLineOptions(new String[]{"file", "format", "ruleset", "-encoding", "UTF-8"});        assertTrue(opt.getEncoding().equals("UTF-8"));        opt = new CommandLineOptions(new String[]{"-encoding", "UTF-8", "file", "format", "ruleset"});        assertTrue(opt.getEncoding().equals("UTF-8"));    }    public void testInputFileName() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic"});        assertEquals("file", opt.getInputPath());    }    public void testReportFormat() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic"});        assertEquals("format", opt.getReportFormat());    }    public void testRulesets() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic"});        assertEquals("rulesets/basic.xml", opt.getRulesets());    }    public void testCommaSeparatedFiles() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file1,file2,file3", "format", "basic"});        assertTrue(opt.containsCommaSeparatedFileList());    }    public void testNotEnoughArgs() {        try {            new CommandLineOptions(new String[]{"file1", "format"});            fail("Should have thrown an exception when only array contained < 3 args");        } catch (RuntimeException re) {            // cool        }    }    public void testNullArgs() {        try {            new CommandLineOptions(null);            fail("Should have thrown an exception when null passed to constructor");        } catch (RuntimeException re) {            // cool        }    }        public void testReportFile(){            CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "format", "basic", "-reportfile", "foo.txt"});        assertSame("foo.txt", opt.getReportFile());        opt = new CommandLineOptions(new String[]{"-reportfile", "foo.txt", "file", "format", "basic"});        assertSame("foo.txt", opt.getReportFile());    }    public void testCpus() {CommandLineOptions opt = new CommandLineOptions(new String[] { "file", "format", "basic", "-cpus", "2" });assertEquals(2, opt.getCpus());opt = new CommandLineOptions(new String[] { "-cpus", "2", "file", "format", "basic" });assertEquals(2, opt.getCpus());}    public void testRenderer() {        CommandLineOptions opt = new CommandLineOptions(new String[]{"file", "xml", "basic"});        assertTrue(opt.createRenderer() instanceof XMLRenderer);        opt = new CommandLineOptions(new String[]{"file", "html", "basic"});        assertTrue(opt.createRenderer() instanceof HTMLRenderer);        opt = new CommandLineOptions(new String[]{"file", "text", "basic"});        assertTrue(opt.createRenderer() instanceof TextRenderer);        opt = new CommandLineOptions(new String[]{"file", "emacs", "basic"});        assertTrue(opt.createRenderer() instanceof EmacsRenderer);        opt = new CommandLineOptions(new String[]{"file", "csv", "basic"});        assertTrue(opt.createRenderer() instanceof CSVRenderer);        opt = new CommandLineOptions(new String[]{"file", "vbhtml", "basic"});        assertTrue(opt.createRenderer() instanceof VBHTMLRenderer);        opt = new CommandLineOptions(new String[]{"file", "ideaj", "basic"});        assertTrue(opt.createRenderer() instanceof IDEAJRenderer);        try {            opt = new CommandLineOptions(new String[]{"file", "fiddlefaddle", "basic"});            opt.createRenderer();        } catch (IllegalArgumentException iae) {            // cool        }        try {            opt = new CommandLineOptions(new String[]{"file", "", "basic"});            opt.createRenderer();        } catch (IllegalArgumentException iae) {            // cool        }    }        public void testOptionsFirst(){CommandLineOptions opt = new CommandLineOptions(new String[] { "-cpus", "2", "-debug", "file", "format", "basic" });assertEquals(2, opt.getCpus());        assertEquals("file", opt.getInputPath());        assertEquals("format", opt.getReportFormat());        assertEquals("rulesets/basic.xml", opt.getRulesets());        assertTrue(opt.debugEnabled());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;public class ReadableDurationTest extends TestCase {    public void testMillisSeconds() {        assertEquals("0s", new Report.ReadableDuration(35).getTime());    }    public void testSeconds() {        assertEquals("25s", new Report.ReadableDuration(25 * 1000).getTime());    }    public void testWholeMinutes() {        assertEquals("5m 0s", new Report.ReadableDuration(60 * 1000 * 5).getTime());    }    public void testMinutesAndSeconds() {        assertEquals("5m 10s", new Report.ReadableDuration((60 * 1000 * 5) + (1000 * 10)).getTime());    }    public void testHours() {        assertEquals("2h 0m 0s", new Report.ReadableDuration(60 * 1000 * 120).getTime());    }}
package test.net.sourceforge.pmd;import net.sourceforge.pmd.SourceType;import junit.framework.TestCase;public class SourceTypeTest extends TestCase {    public void testGetSourceTypeForId(){        assertEquals(SourceType.getSourceTypeForId("java 1.3"), SourceType.JAVA_13);        assertEquals(SourceType.getSourceTypeForId("java 1.4"), SourceType.JAVA_14);        assertEquals(SourceType.getSourceTypeForId("java 1.5"), SourceType.JAVA_15);        assertEquals(SourceType.getSourceTypeForId("java 1.6"), SourceType.JAVA_16);    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.SimpleRuleSetNameMapper;public class SimpleRuleSetNameMapperTest extends TestCase {    public void testMultipleSimple() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("unusedcode,basic");        assertEquals("rulesets/unusedcode.xml,rulesets/basic.xml", s.getRuleSets());    }    public void testOneSimple() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("basic");        assertEquals("rulesets/basic.xml", s.getRuleSets());    }    public void testMultipleRegular() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("rulesets/unusedcode.xml,rulesets/basic.xml");        assertEquals("rulesets/unusedcode.xml,rulesets/basic.xml", s.getRuleSets());    }    public void testOneRegular() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("rulesets/unusedcode.xml");        assertEquals("rulesets/unusedcode.xml", s.getRuleSets());    }    public void testMix() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("rulesets/unusedcode.xml,basic");        assertEquals("rulesets/unusedcode.xml,rulesets/basic.xml", s.getRuleSets());    }    public void testUnknown() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("favorites.xml");        assertEquals("favorites.xml", s.getRuleSets());    }    public void testUnknownAndSimple() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("basic,favorites.xml");        assertEquals("rulesets/basic.xml,favorites.xml", s.getRuleSets());    }}
 package test.net.sourceforge.pmd;  import net.sourceforge.pmd.AbstractRule; import net.sourceforge.pmd.PMD; import net.sourceforge.pmd.Report; import net.sourceforge.pmd.SourceType; import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration; import net.sourceforge.pmd.ast.ASTVariableDeclaratorId; import test.net.sourceforge.pmd.testframework.RuleTst;  public class SuppressWarningsTest extends RuleTst {      private static class FooRule extends AbstractRule {         public Object visit(ASTClassOrInterfaceDeclaration c, Object ctx) {             if (c.getImage().equalsIgnoreCase("Foo")) addViolation(ctx, c);             return super.visit(c, ctx);         }          public Object visit(ASTVariableDeclaratorId c, Object ctx) {             if (c.getImage().equalsIgnoreCase("Foo")) addViolation(ctx, c);             return super.visit(c, ctx);         }         public String getName() {             return "NoFoo";         }     }      public void testClassLevelSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST1, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(0, rpt.size());         runTestFromString(TEST2, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(0, rpt.size());     }      public void testInheritedSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST3, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(0, rpt.size());     }      public void testMethodLevelSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST4, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(1, rpt.size());     }      public void testConstructorLevelSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST5, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(0, rpt.size());     }      public void testFieldLevelSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST6, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(1, rpt.size());     }      public void testParameterLevelSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST7, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(1, rpt.size());     }      public void testLocalVariableLevelSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST8, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(1, rpt.size());     }      public void testSpecificSuppression() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST9, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(1, rpt.size());     }          public void testNoSuppressionBlank() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST10, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(2, rpt.size());     }          public void testNoSuppressionSomethingElseS() throws Throwable {         Report rpt = new Report();         runTestFromString(TEST11, new FooRule(), rpt, SourceType.JAVA_15);         assertEquals(2, rpt.size());     }     private static final String TEST1 =             "@SuppressWarnings(\"PMD\")" + PMD.EOL +             "public class Foo {}";      private static final String TEST2 =             "@SuppressWarnings(\"PMD\")" + PMD.EOL +             "public class Foo {" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";      private static final String TEST3 =             "public class Baz {" + PMD.EOL +             " @SuppressWarnings(\"PMD\")" + PMD.EOL +             " public class Bar {" + PMD.EOL +             "  void bar() {" + PMD.EOL +             "   int foo;" + PMD.EOL +             "  }" + PMD.EOL +             " }" + PMD.EOL +             "}";      private static final String TEST4 =             "public class Foo {" + PMD.EOL +             " @SuppressWarnings(\"PMD\")" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";      private static final String TEST5 =             "public class Bar {" + PMD.EOL +             " @SuppressWarnings(\"PMD\")" + PMD.EOL +             " public Bar() {" + PMD.EOL +             "  int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";      private static final String TEST6 =             "public class Bar {" + PMD.EOL +             " @SuppressWarnings(\"PMD\")" + PMD.EOL +             " int foo;" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";      private static final String TEST7 =             "public class Bar {" + PMD.EOL +             " int foo;" + PMD.EOL +             " void bar(@SuppressWarnings(\"PMD\") int foo) {}" + PMD.EOL +             "}";      private static final String TEST8 =             "public class Bar {" + PMD.EOL +             " int foo;" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  @SuppressWarnings(\"PMD\") int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";      private static final String TEST9 =             "public class Bar {" + PMD.EOL +             " int foo;" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  @SuppressWarnings(\"PMD.NoFoo\") int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";     private static final String TEST10 =             "public class Bar {" + PMD.EOL +             " int foo;" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  @SuppressWarnings(\"\") int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}";     private static final String TEST11 =             "public class Bar {" + PMD.EOL +             " int foo;" + PMD.EOL +             " void bar() {" + PMD.EOL +             "  @SuppressWarnings(\"SomethingElse\") int foo;" + PMD.EOL +             " }" + PMD.EOL +             "}"; }    
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.PropertyDescriptor;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.ast.SimpleJavaNode;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.properties.StringProperty;import net.sourceforge.pmd.symboltable.SourceFileScope;import java.util.HashMap;import java.util.Map;public class AbstractRuleTest extends TestCase {    private static class MyRule extends AbstractRule {    private static final PropertyDescriptor pd = new StringProperty("foo", "foo property", "x", 1.0f);    private static final PropertyDescriptor xpath = new StringProperty("xpath", "xpath property", "", 2.0f);        private static final Map<String, PropertyDescriptor> propertyDescriptorsByName = asFixedMap(new PropertyDescriptor[] { pd, xpath });        protected Map<String, PropertyDescriptor> propertiesByName() {        return propertyDescriptorsByName;        }        public MyRule() {            setName("MyRule");            setMessage("my rule msg");            setPriority(3);            setProperty(pd, "value");        }    }    private static class MyOtherRule extends AbstractRule {    private static final PropertyDescriptor pd = new StringProperty("foo", "foo property", "x", 1.0f);private static final Map<String, PropertyDescriptor> propertyDescriptorsByName = asFixedMap(new PropertyDescriptor[] { pd });        protected Map<String, PropertyDescriptor> propertiesByName() {        return propertyDescriptorsByName;        }public MyOtherRule() {            setName("MyOtherRule");            setMessage("my other rule");            setPriority(3);            setProperty(pd, "value");        }    }    public AbstractRuleTest(String name) {        super(name);    }    public void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginColumn(5);        s.testingOnly__setBeginLine(5);        s.setScope(new SourceFileScope("foo"));        RuleViolation rv = new RuleViolation(r, ctx, s);        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule msg mismatch!", "my rule msg", rv.getDescription());        assertEquals("RuleSet name mismatch!", "foo", rv.getRule().getRuleSetName());    }    public void testCreateRV2() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginColumn(5);        s.testingOnly__setBeginLine(5);        s.setScope(new SourceFileScope("foo"));        RuleViolation rv = new RuleViolation(r, ctx, s, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }    public void testRuleExclusion() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        Map<Integer, String> m = new HashMap<Integer, String>();        m.put(new Integer(5), "");        ctx.setReport(new Report());        ctx.excludeLines(m);        ctx.setSourceCodeFilename("filename");        SimpleNode n = new SimpleJavaNode(1);        n.testingOnly__setBeginColumn(5);        n.testingOnly__setBeginLine(5);        n.setScope(new SourceFileScope("foo"));        RuleViolation rv = new RuleViolation(r, ctx, n, "specificdescription");        ctx.getReport().addRuleViolation(rv);        assertTrue(ctx.getReport().isEmpty());    }    public void testEquals1() {        MyRule r = new MyRule();        assertFalse("A rule is never equals to null!", r.equals(null));    }    public void testEquals2() {        MyRule r = new MyRule();        assertEquals("A rule must be equals to itself", r, r);    }    public void testEquals3() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        assertEquals("Two instances of the same rule are equal", r1, r2);        assertEquals("Hashcode for two instances of the same rule must be equal", r1.hashCode(), r2.hashCode());    }    public void testEquals4() {        MyRule myRule = new MyRule();        assertFalse("A rule cannot be equal to an object of another class", myRule.equals("MyRule"));    }    public void testEquals5() {        MyRule myRule = new MyRule();        MyOtherRule myOtherRule = new MyOtherRule();        assertFalse("Two rules from different classes cannot be equal", myRule.equals(myOtherRule));    }    public void testEquals6() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setName("MyRule2");        assertFalse("Rules with different names cannot be equal", r1.equals(r2));    }    public void testEquals7() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setPriority(1);        assertFalse("Rules with different priority levels cannot be equal", r1.equals(r2));    }    public void testEquals8() {        MyRule r1 = new MyRule();        r1.setProperty(MyRule.xpath, "something");        MyRule r2 = new MyRule();        r2.setProperty(MyRule.xpath, "something else");        assertFalse("Rules with different properties values cannot be equal", r1.equals(r2));    }    public void testEquals9() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setProperty(MyRule.xpath, "something else");        assertFalse("Rules with different properties cannot be equal", r1.equals(r2));    }    public void testEquals10() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setMessage("another message");        assertTrue("Rules with different messages are still equal", r1.equals(r2));        assertTrue("Rules that are equal must have the same hashcode", r1.hashCode() == r2.hashCode());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.JavaParser;import net.sourceforge.pmd.ast.ASTCompilationUnit;import test.net.sourceforge.pmd.testframework.MockRule;import java.io.StringReader;import java.util.ArrayList;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;public class RuleSetTest extends TestCase {    private String javaCode = "public class Test { }";    public void testNoDFA() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertFalse(rs.usesDFA());    }    public void testIncludesRuleWithDFA() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        mock.setUsesDFA();        rs.addRule(mock);        assertTrue(rs.usesDFA());    }    public void testAccessors() {        RuleSet rs = new RuleSet();        rs.setName("foo");        assertEquals("name mismatch", "foo", rs.getName());        rs.setDescription("bar");        assertEquals("description mismatch", "bar", rs.getDescription());    }    public void testGetRuleByName() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    public void testGetRuleByName2() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertNull("the rule FooRule must not be found!", rs.getRuleByName("FooRule"));    }    public void testRuleList() {        RuleSet IUT = new RuleSet();        assertEquals("Size of RuleSet isn't zero.", 0, IUT.size());        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        IUT.addRule(rule);        assertEquals("Size of RuleSet isn't one.", 1, IUT.size());        Collection rules = IUT.getRules();        Iterator i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    public void testAddRuleSet() {        RuleSet set1 = new RuleSet();        set1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet set2 = new RuleSet();        set2.addRule(new MockRule("name2", "desc", "msg", "rulesetname"));        set1.addRuleSet(set2);        assertEquals("ruleset size wrong", 2, set1.size());    }    public void testApply0Rules() throws Throwable {        RuleSet IUT = new RuleSet();        verifyRuleSet(IUT, 0, new HashSet());    }    public void testEquals1() {        RuleSet s = new RuleSet();        assertFalse("A ruleset cannot be equals to null", s.equals(null));    }    public void testEquals2() {        RuleSet s = new RuleSet();        assertTrue("A rulset must be equals to itself", s.equals(s));    }    public void testEquals3() {        RuleSet s = new RuleSet();        s.setName("basic rules");        assertFalse("A ruleset cannot be equals to another kind of object", s.equals("basic rules"));    }    public void testEquals4() {        RuleSet s1 = new RuleSet();        s1.setName("my ruleset");        s1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet s2 = new RuleSet();        s2.setName("my ruleset");        s2.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        assertEquals("2 rulesets with same name and rules must be equals", s1, s2);        assertEquals("Equals rulesets must have the same hashcode", s1.hashCode(), s2.hashCode());    }    public void testEquals5() {        RuleSet s1 = new RuleSet();        s1.setName("my ruleset");        s1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet s2 = new RuleSet();        s2.setName("my other ruleset");        s2.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        assertFalse("2 rulesets with different name but same rules must not be equals", s1.equals(s2));    }    public void testEquals6() {        RuleSet s1 = new RuleSet();        s1.setName("my ruleset");        s1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet s2 = new RuleSet();        s2.setName("my ruleset");        s2.addRule(new MockRule("other rule", "desc", "msg", "rulesetname"));        assertFalse("2 rulesets with same name but different rules must not be equals", s1.equals(s2));    }    protected void verifyRuleSet(RuleSet IUT, int size, Set values) throws Throwable {        RuleContext context = new RuleContext();        Set<RuleViolation> reportedValues = new HashSet<RuleViolation>();        context.setReport(new Report());        IUT.apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().size());        Iterator violations = context.getReport().iterator();        while (violations.hasNext()) {            RuleViolation violation = (RuleViolation) violations.next();            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        Iterator expected = values.iterator();        while (expected.hasNext()) {            RuleViolation violation = (RuleViolation) expected.next();            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    protected List makeCompilationUnits() throws Throwable {        List<ASTCompilationUnit> RC = new ArrayList<ASTCompilationUnit>();        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(javaCode));        RC.add(parser.CompilationUnit());        return RC;    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import java.util.Iterator;import java.util.Map;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.IRuleViolation;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.SourceType;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.SimpleJavaNode;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;import net.sourceforge.pmd.stat.Metric;import net.sourceforge.pmd.symboltable.SourceFileScope;import test.net.sourceforge.pmd.testframework.MockRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class ReportTest extends RuleTst implements ReportListener {    private static class FooRule extends AbstractRule {        public Object visit(ASTClassOrInterfaceDeclaration c, Object ctx) {            if ("Foo".equals(c.getImage())) addViolation(ctx, c);            return ctx;        }        public String getMessage() {            return "blah";        }        public String getName() {            return "Foo";        }        public String getRuleSetName() {            return "RuleSet";        }        public String getDescription() {            return "desc";        }    }    private boolean violationSemaphore;    private boolean metricSemaphore;    public void ruleViolationAdded(IRuleViolation ruleViolation) {        violationSemaphore = true;    }    public void metricAdded(Metric metric) {        metricSemaphore = true;    }    public void testBasic() throws Throwable {        Report r = new Report();        runTestFromString(TEST1, new FooRule(), r);        assertTrue(!r.isEmpty());    }    public void testMetric0() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());    }    public void testMetric1() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());        r.addMetric(new Metric("m1", 0, 0.0, 1.0, 2.0, 3.0, 4.0));        assertTrue("Expected metrics weren't there", r.hasMetrics());        Iterator ms = r.metrics();        assertTrue("Should have some metrics in there now", ms.hasNext());        Object o = ms.next();        assertTrue("Expected Metric, got " + o.getClass(), o instanceof Metric);        Metric m = (Metric) o;        assertEquals("metric name mismatch", "m1", m.getMetricName());        assertEquals("wrong low value", 1.0, m.getLowValue(), 0.05);        assertEquals("wrong high value", 2.0, m.getHighValue(), 0.05);        assertEquals("wrong avg value", 3.0, m.getAverage(), 0.05);        assertEquals("wrong std dev value", 4.0, m.getStandardDeviation(), 0.05);    }    public void testExclusionsInReportWithAnnotations() throws Throwable {        Report rpt = new Report();        runTestFromString(TEST2, new FooRule(), rpt, SourceType.JAVA_15);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    public void testExclusionsInReportWithNOPMD() throws Throwable {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    private static final String TEST1 =            "public class Foo {}" + PMD.EOL;    private static final String TEST2 =            "@SuppressWarnings(\"PMD\")" + PMD.EOL +            "public class Foo {}";    private static final String TEST3 =            "public class Foo {} // NOPMD";    // Files are grouped together now.    public void testSortedReport_File() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        SimpleNode s = getNode(10, 5, ctx.getSourceCodeFilename());        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), ctx, s));        ctx.setSourceCodeFilename("bar");        SimpleNode s1 = getNode(10, 5, ctx.getSourceCodeFilename());        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), ctx, s1));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    public void testSortedReport_Line() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        SimpleNode s = getNode(10, 5, ctx.getSourceCodeFilename());        r.addRuleViolation(new RuleViolation(new MockRule("rule2", "rule2", "msg", "rulesetname"), ctx, s));        ctx.setSourceCodeFilename("foo2");        SimpleNode s1 = getNode(20, 5, ctx.getSourceCodeFilename());        r.addRuleViolation(new RuleViolation(new MockRule("rule1", "rule1", "msg", "rulesetname"), ctx, s1));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    public void testListener() {        Report rpt = new Report();        rpt.addListener(this);        violationSemaphore = false;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("file");        SimpleNode s = getNode(5, 5, ctx.getSourceCodeFilename());        rpt.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), ctx, s));        assertTrue(violationSemaphore);        metricSemaphore = false;        rpt.addMetric(new Metric("test", 0, 0.0, 0.0, 0.0, 0.0, 0.0));        assertTrue("no metric", metricSemaphore);    }    public void testSummary() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        SimpleNode s = getNode(5, 5, ctx.getSourceCodeFilename());        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new RuleViolation(rule, ctx, s));        ctx.setSourceCodeFilename("foo2");        Rule mr = new MockRule("rule1", "rule1", "msg", "rulesetname");        SimpleNode s1 = getNode(20, 5, ctx.getSourceCodeFilename());        SimpleNode s2 = getNode(30, 5, ctx.getSourceCodeFilename());        r.addRuleViolation(new RuleViolation(mr, ctx, s1));        r.addRuleViolation(new RuleViolation(mr, ctx, s2));        Map summary = r.getSummary();        assertEquals(summary.keySet().size(), 2);        assertTrue(summary.values().contains(new Integer(1)));        assertTrue(summary.values().contains(new Integer(2)));    }        private SimpleNode getNode(int line, int column, String scopeName){        SimpleNode s = new SimpleJavaNode(2);        SimpleNode parent = new SimpleJavaNode(1);        parent.testingOnly__setBeginLine(line);        parent.testingOnly__setBeginColumn(column);        s.jjtSetParent(parent);        s.setScope(new SourceFileScope(scopeName));        s.testingOnly__setBeginLine(10);        s.testingOnly__setBeginColumn(5);        return s;    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.util.ResourceLoader;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class RuleSetFactoryTest extends TestCase {    public void testRefs() throws Throwable {        InputStream in = ResourceLoader.loadResourceAsStream("rulesets/favorites.xml", this.getClass().getClassLoader());        if (in == null) {            throw new RuleSetNotFoundException("Can't find resource   Make sure the resource is a valid file or URL or is on the CLASSPATH.  Here's the current classpath: " + System.getProperty("java.class.path"));        }        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createSingleRuleSet("rulesets/favorites.xml");        assertNotNull(rs.getRuleByName("WhileLoopsMustUseBraces"));    }    public void testRuleSetNotFound() {        RuleSetFactory rsf = new RuleSetFactory();        try {            rsf.createSingleRuleSet("fooooo");            fail("Should have thrown a RuleSetNotFoundException");        } catch (RuleSetNotFoundException rsnfe) {            // cool        }    }    public void testCreateEmptyRuleSet() {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    public void testSingleRule() {        RuleSet rs = loadRuleSet(SINGLE_RULE);        assertEquals(1, rs.size());        Rule r = rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("avoid the mock rule", r.getMessage());    }    public void testMultipleRules() {        RuleSet rs = loadRuleSet(MULTIPLE_RULES);        assertEquals(2, rs.size());        Set<String> expected = new HashSet<String>();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Iterator i = rs.getRules().iterator(); i.hasNext();) {            assertTrue(expected.contains(((Rule) i.next()).getName()));        }    }    public void testSingleRuleWithPriority() {        assertEquals(3, loadFirstRule(PRIORITY).getPriority());    }    public void testProps() {        Rule r = loadFirstRule(PROPERTIES);        assertTrue(r.hasProperty("foo"));        assertEquals("bar", r.getStringProperty("foo"));        assertEquals(2, r.getIntProperty("fooint"));        assertTrue(r.hasProperty("fooBoolean"));        assertTrue(r.getBooleanProperty("fooBoolean"));        assertTrue(r.hasProperty("fooDouble"));        assertEquals(1.0, r.getDoubleProperty("fooDouble"), 0.05);        assertTrue(!r.hasProperty("BuggleFish"));        assertTrue(r.getDescription().indexOf("testdesc2") != -1);    }    public void testXPathPluginnameProperty() {        Rule r = loadFirstRule(XPATH_PLUGINNAME);        assertTrue(r.hasProperty("pluginname"));    }    public void testXPath() {        Rule r = loadFirstRule(XPATH);        assertTrue(r.hasProperty("xpath"));        assertTrue(r.getStringProperty("xpath").indexOf(" //Block ") != -1);    }    public void testFacadesOffByDefault() {        Rule r = loadFirstRule(XPATH);        assertFalse(r.usesDFA());    }    public void testDFAFlag() {        assertTrue(loadFirstRule(DFA).usesDFA());    }    public void testExternalReferenceOverride() {        Rule r = loadFirstRule(REF_OVERRIDE);        assertEquals("TestNameOverride", r.getName());        assertEquals("Test message override", r.getMessage());        assertEquals("Test description override", r.getDescription());        assertEquals("Test example override", r.getExample());        assertEquals(3, r.getPriority());        assertTrue(r.hasProperty("test2"));        assertEquals("override2", r.getStringProperty("test2"));        assertTrue(r.hasProperty("test3"));        assertEquals("override3", r.getStringProperty("test3"));        assertTrue(r.hasProperty("test4"));        assertEquals("new property", r.getStringProperty("test4"));    }    public void testOverrideMessage() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);        assertEquals("TestMessageOverride", r.getMessage());    }    public void testOverrideMessageOneElem() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);        assertEquals("TestMessageOverride", r.getMessage());    }    public void testExternalRef() {        try {            loadFirstRule(REF_MISPELLED_XREF);            fail("Whoa, should have gotten an IllegalArgumentException");        } catch (IllegalArgumentException iae) {            // cool        }    }    public void testSetPriority() {        RuleSetFactory rsf = new RuleSetFactory();        rsf.setMinimumPriority(2);        assertEquals(0, rsf.createRuleSet(new ByteArrayInputStream(SINGLE_RULE.getBytes())).size());        rsf.setMinimumPriority(4);        assertEquals(1, rsf.createRuleSet(new ByteArrayInputStream(SINGLE_RULE.getBytes())).size());    }    private static final String REF_OVERRIDE_ORIGINAL_NAME =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule " + PMD.EOL +            "  ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\" message=\"TestMessageOverride\"> " + PMD.EOL +            " </rule>" + PMD.EOL +            "</ruleset>";    private static final String REF_MISPELLED_XREF =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule " + PMD.EOL +            "  ref=\"rulesets/unusedcode.xml/FooUnusedLocalVariable\"> " + PMD.EOL +            " </rule>" + PMD.EOL +            "</ruleset>";    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\" message=\"TestMessageOverride\"/> " + PMD.EOL +            "</ruleset>";    private static final String REF_OVERRIDE =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule " + PMD.EOL +            "  ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\" " + PMD.EOL +            "  name=\"TestNameOverride\" " + PMD.EOL +            "  message=\"Test message override\"> " + PMD.EOL +            "  <description>Test description override</description>" + PMD.EOL +            "  <example>Test example override</example>" + PMD.EOL +            "  <priority>3</priority>" + PMD.EOL +            "  <properties>" + PMD.EOL +            "   <property name=\"test2\" value=\"override2\"/>" + PMD.EOL +            "   <property name=\"test3\"><value>override3</value></property>" + PMD.EOL +            "   <property name=\"test4\" value=\"new property\"/>" + PMD.EOL +            "  </properties>" + PMD.EOL +            " </rule>" + PMD.EOL +            "</ruleset>";    private static final String EMPTY_RULESET =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "</ruleset>";    private static final String SINGLE_RULE =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "<priority>3</priority>" + PMD.EOL +            "</rule></ruleset>";    private static final String MULTIPLE_RULES =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule name=\"MockRuleName1\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "</rule>" + PMD.EOL +            "<rule name=\"MockRuleName2\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "</rule></ruleset>";    private static final String PROPERTIES =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"fooBoolean\" value=\"true\"/>" + PMD.EOL +            "<property name=\"fooDouble\" value=\"1.0\" />" + PMD.EOL +            "<property name=\"foo\" value=\"bar\"/>" + PMD.EOL +            "<property name=\"fooint\" value=\"2\"/>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String XPATH =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<priority>3</priority>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"xpath\">" + PMD.EOL +            "<value>" + PMD.EOL +            "<![CDATA[ //Block ]]>" + PMD.EOL +            "</value>" + PMD.EOL +            "</property>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String XPATH_PLUGINNAME =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<priority>3</priority>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"xpath\" pluginname=\"true\">" + PMD.EOL +            "<value>" + PMD.EOL +            "<![CDATA[ //Block ]]>" + PMD.EOL +            "</value>" + PMD.EOL +            "</property>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String PRIORITY =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "<priority>3</priority>" + PMD.EOL +            "</rule></ruleset>";    private static final String DFA =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "dfa=\"true\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "<priority>3</priority>" + PMD.EOL +            "</rule></ruleset>";    private Rule loadFirstRule(String ruleSetName) {        RuleSet rs = loadRuleSet(ruleSetName);        return rs.getRules().iterator().next();    }    private RuleSet loadRuleSet(String ruleSetName) {        RuleSetFactory rsf = new RuleSetFactory();        return rsf.createRuleSet(new ByteArrayInputStream(ruleSetName.getBytes()));    }/*    public void testExternalReferences() {        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);        assertEquals(1, rs.size());        assertEquals(UnusedLocalVariableRule.class, rs.getRuleByName("UnusedLocalVariable").getClass());    }        private static final String EXTERNAL_REFERENCE_RULE_SET =                "<?xml version=\"1.0\"?>" + PMD.EOL +                "<ruleset name=\"test\">" + PMD.EOL +                "<description>testdesc</description>" + PMD.EOL +                "<rule ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\"/>" + PMD.EOL +                "</ruleset>";*/}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;public class RuleContextTest extends TestCase {    public void testReport() {        RuleContext ctx = new RuleContext();        assertEquals(0, ctx.getReport().size());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    public void testFilename() {        RuleContext ctx = new RuleContext();        assertNull("filename should be null", ctx.getSourceCodeFilename());        ctx.setSourceCodeFilename("foo");        assertEquals("filename mismatch", "foo", ctx.getSourceCodeFilename());    }}
 package test.net.sourceforge.pmd;  import java.io.StringReader;  import net.sourceforge.pmd.PMD; import net.sourceforge.pmd.Report; import net.sourceforge.pmd.Rule; import net.sourceforge.pmd.RuleContext; import net.sourceforge.pmd.RuleSet; import net.sourceforge.pmd.RuleSets; import net.sourceforge.pmd.SourceTypeToRuleLanguageMapper; import test.net.sourceforge.pmd.testframework.RuleTst; import test.net.sourceforge.pmd.testframework.TestDescriptor;  public class ExcludeLinesTest extends RuleTst {     private Rule rule;      public void setUp() {         rule = findRule("unusedcode", "UnusedLocalVariable");     }      public void testAcceptance() {         runTest(new TestDescriptor(TEST1, "NOPMD should work", 0, rule));         runTest(new TestDescriptor(TEST2, "Should fail without exclude marker", 1, rule));     }      public void testAlternateMarker() throws Throwable {         PMD p = new PMD();         p.setExcludeMarker("FOOBAR");         RuleContext ctx = new RuleContext();         Report r = new Report();         ctx.setReport(r);         ctx.setSourceCodeFilename("n/a");         RuleSet rules = new RuleSet();         rules.addRule(rule);         rules.setLanguage(SourceTypeToRuleLanguageMapper.getMappedLanguage(DEFAULT_SOURCE_TYPE));         p.processFile(new StringReader(TEST3), new RuleSets(rules), ctx, DEFAULT_SOURCE_TYPE);         assertTrue(r.isEmpty());         assertEquals(r.getSuppressedRuleViolations().size(), 1);     }      private static final String TEST1 =             "public class Foo {" + PMD.EOL +             " void foo() {" + PMD.EOL +             "  int x; //NOPMD " + PMD.EOL +             " } " + PMD.EOL +             "}";      private static final String TEST2 =             "public class Foo {" + PMD.EOL +             " void foo() {" + PMD.EOL +             "  int x;" + PMD.EOL +             " } " + PMD.EOL +             "}";      private static final String TEST3 =             "public class Foo {" + PMD.EOL +             " void foo() {" + PMD.EOL +             "  int x; // FOOBAR" + PMD.EOL +             " } " + PMD.EOL +             "}";  }
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;public class RuleViolationTest extends TestCase {    public void testConstructor1() {/*        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginLine(2);        RuleViolation r = new RuleViolation(rule, ctx, s);        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());*/    }/*    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginLine(2);        RuleViolation r = new RuleViolation(rule, ctx, s, "description");        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename1");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginLine(10);        RuleViolation r1 = new RuleViolation(rule, ctx, s, "description");        ctx.setSourceCodeFilename("filename2");        SimpleNode s1 = new SimpleJavaNode(1);        s1.testingOnly__setBeginLine(10);        RuleViolation r2 = new RuleViolation(rule, ctx, s1, "description");        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginLine(10);        SimpleNode s1 = new SimpleJavaNode(1);        s1.testingOnly__setBeginLine(20);        RuleViolation r1 = new RuleViolation(rule, ctx, s, "description");        RuleViolation r2 = new RuleViolation(rule, ctx, s1, "description");        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleJavaNode(1);        s.testingOnly__setBeginLine(10);        SimpleNode s1 = new SimpleJavaNode(1);        s1.testingOnly__setBeginLine(10);        RuleViolation r1 = new RuleViolation(rule, ctx, s, "description");        RuleViolation r2 = new RuleViolation(rule, ctx, s1, "description");        assertEquals(1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }*/}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import java.util.Iterator;import java.util.List;public class TestClassWithoutTestCases extends AbstractRule {    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {        if (node.isAbstract() || node.isInterface() || node.isNested()) {            return data;        }        String className = node.getImage();        if (className.endsWith("Test")) {            List<ASTMethodDeclarator> m = node.findChildrenOfType(ASTMethodDeclarator.class);            boolean testsFound = false;            if (m != null) {                for (Iterator<ASTMethodDeclarator> it = m.iterator(); it.hasNext() && !testsFound;) {                    ASTMethodDeclarator md = it.next();                    if (!isInInnerClassOrInterface(md)                            && md.getImage().startsWith("test")) {                        testsFound = true;                    }                }            }            if (!testsFound) {                addViolation(data, node);            }        }        return data;    }    private boolean isInInnerClassOrInterface(ASTMethodDeclarator md) {        ASTClassOrInterfaceDeclaration p = md.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);        return p != null && p.isNested();    }}
/* *  Copyright (c) 2002-2003, the pmd-netbeans team *  All rights reserved. * *  Redistribution and use in source and binary forms, with or without modification, *  are permitted provided that the following conditions are met: * *  - Redistributions of source code must retain the above copyright notice, *  this list of conditions and the following disclaimer. * *  - Redistributions in binary form must reproduce the above copyright *  notice, this list of conditions and the following disclaimer in the *  documentation and/or other materials provided with the distribution. * *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE *  ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH *  DAMAGE. */package pmd;import java.io.PrintStream;import java.util.logging.LogRecord;import junit.framework.*;import java.util.Collections;import java.util.List;import java.util.logging.Handler;import java.util.logging.Level;import java.util.logging.Logger;import org.netbeans.api.java.classpath.ClassPath;import org.netbeans.junit.NbTestCase;import org.netbeans.spi.java.classpath.ClassPathProvider;import org.netbeans.spi.java.classpath.support.ClassPathSupport;import org.netbeans.spi.java.queries.SourceLevelQueryImplementation;import org.openide.filesystems.FileLock;import org.openide.filesystems.FileObject;import org.openide.filesystems.FileUtil;import org.openide.loaders.DataObject;/** * @author radim */public class SourceLevelTest extends NbTestCase {        /*    static {        System.setProperty("org.openide.util.Lookup", Lkp.class.getName());    }        public static final class Lkp extends org.openide.util.lookup.AbstractLookup {        public Lkp() {            this(new org.openide.util.lookup.InstanceContent());        }                private Lkp(org.openide.util.lookup.InstanceContent ic) {            super(ic);            ic.add(new TestSourceLevelQueryImpl());        }    }     */        public SourceLevelTest(String testName) {        super(testName);    }    protected void setUp() throws Exception {        super.setUp();        // uncomment MockService registration and delete META-INF/services file when dropping 5.5 support//        MockServices.setServices(TestSourceLevelQueryImpl.class);    }    protected void tearDown() throws Exception {    }    public static Test suite() {        TestSuite suite = new TestSuite(SourceLevelTest.class);                return suite;    }    /**     * Test of checkCookies method, of class pmd.RunPMDAction.     */    public void testSourceLevels() throws Exception {        clearWorkDir();        CountingHandler counter = new CountingHandler();        Logger.getLogger("pmd").addHandler(counter);        Logger.getLogger("pmd").setLevel(Level.FINE);                List result;                FileObject dir = FileUtil.toFileObject(getWorkDir());        ClassPath cp = ClassPathSupport.createClassPath(new FileObject[] { dir });        TestClassPathProvider.testCP = cp;        assertNotNull("Cannot find FileObject for work dir", dir);        FileObject f1;        DataObject d1;                TestSourceLevelQueryImpl.level = "1.4";        f1 = dir.createData("PMDSample.java");        assertNotNull("Cannot create file in work dir", f1);        FileLock l = null;        try {            l = f1.lock();            PrintStream ps = new PrintStream (f1.getOutputStream(l));            ps.print("public class PMDSample { PMDSample () {} }");            ps.close();        }        finally {            if (l != null) {                l.releaseLock();            }        }        d1 = DataObject.find(f1);        assertNotNull("Cannot find a data object", d1);        result = pmd.RunPMDAction.performScan(Collections.singletonList(d1));        assertEquals("There should be no error for PMDSample.java file", 0, result.size());                TestSourceLevelQueryImpl.level = "1.5";        try {            l = f1.lock();            PrintStream ps = new PrintStream (f1.getOutputStream(l));            ps.print("public class PMDSample { PMDSample () { " +                    "   new java.util.ArrayList<Boolean>();" +                    "  }" +                    "}");            ps.close();        }        finally {            if (l != null) {                l.releaseLock();            }        }        result = pmd.RunPMDAction.performScan(Collections.singletonList(d1));        assertEquals("There should be no error for PMDSample.java file", 0, result.size());        assertEquals("No error logged during scanning", 0, counter.count);        TestSourceLevelQueryImpl.level = "1.6";        result = pmd.RunPMDAction.performScan(Collections.singletonList(d1));        assertEquals("There should be no error for PMDSample.java file", 0, result.size());        assertEquals("No error logged during scanning", 0, counter.count);    }    public static class TestSourceLevelQueryImpl implements SourceLevelQueryImplementation {                static String level;                public TestSourceLevelQueryImpl () {                    }            public String getSourceLevel(FileObject arg0) {//            System.out.println("TestSourceLevelQueryImpl "+arg0.toString()+", "+level);            return level;        }    }        public static class TestClassPathProvider implements ClassPathProvider {                static ClassPath testCP;                public TestClassPathProvider () {        }            public ClassPath findClassPath(FileObject file, String type) {            if (testCP == null || !ClassPath.SOURCE.equals(type))                return null;                        if (FileUtil.isParentOf(testCP.getRoots()[0], file)) {                return testCP;            }            return null;        }}        public static class CountingHandler extends Handler {        int count;            public void publish(LogRecord arg0) {            System.out.println("Log "+arg0);            count++;        }        public void flush() {        }        public void close() throws SecurityException {        }}}
/* *  Copyright (c) 2002-2003, the pmd-netbeans team *  All rights reserved. * *  Redistribution and use in source and binary forms, with or without modification, *  are permitted provided that the following conditions are met: * *  - Redistributions of source code must retain the above copyright notice, *  this list of conditions and the following disclaimer. * *  - Redistributions in binary form must reproduce the above copyright *  notice, this list of conditions and the following disclaimer in the *  documentation and/or other materials provided with the distribution. * *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE *  ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR *  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY *  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH *  DAMAGE. */package pmd;import java.io.PrintStream;import junit.framework.*;import java.util.Collections;import java.util.List;import org.netbeans.junit.NbTestCase;import org.openide.filesystems.FileLock;import org.openide.filesystems.FileObject;import org.openide.filesystems.FileSystem;import org.openide.filesystems.FileUtil;import org.openide.filesystems.XMLFileSystem;import org.openide.loaders.DataObject;/** * @author radim */public class RunPMDActionTest extends NbTestCase {        public RunPMDActionTest(String testName) {        super(testName);    }    protected void setUp() throws Exception {    }    protected void tearDown() throws Exception {    }    public static Test suite() {        TestSuite suite = new TestSuite(RunPMDActionTest.class);                return suite;    }    /**     * Test of getHelpCtx method, of class pmd.RunPMDAction.     */    public void testGetHelpCtx() {        pmd.RunPMDAction instance = (RunPMDAction)RunPMDAction.get(RunPMDAction.class);        assertNotNull("There is no help context associated to RunPMDAction", instance.getHelpCtx());    }    /**     * Test of checkCookies method, of class pmd.RunPMDAction.     */    public void testCheckCookies() throws Exception {        clearWorkDir();        //        List dataobjects = null;//        List expResult = null;        List result;                // try on empty list                result = pmd.RunPMDAction.performScan(Collections.<DataObject>emptyList());//        assertEquals(expResult, result);                FileObject dir = FileUtil.toFileObject(getWorkDir());        assertNotNull("Cannot find FileObject for work dir", dir);        FileObject f1;        f1 = dir.createData("MANIFEST.MF");        assertNotNull("Cannot create file in work dir", f1);        DataObject d1 = DataObject.find(f1);        assertNotNull("Cannot find a data object", d1);        result = pmd.RunPMDAction.performScan(Collections.singletonList(d1));        assertEquals("There should be no error for MANIFEST.MF file", 0, result.size());                f1 = dir.createData("PMDSample.java");        assertNotNull("Cannot create file in work dir", f1);        FileLock l = null;        try {            l = f1.lock();            PrintStream ps = new PrintStream (f1.getOutputStream(l));            ps.print("public class PMDSample { PMDSample () {} }");            ps.close();        }        finally {            if (l != null) {                l.releaseLock();            }        }        d1 = DataObject.find(f1);        assertNotNull("Cannot find a data object", d1);        result = pmd.RunPMDAction.performScan(Collections.singletonList(d1));        assertEquals("There should be no error for PMDSample.java file", 0, result.size());            }        public void testShouldCheck() throws Exception {        clearWorkDir();                FileObject dir = FileUtil.toFileObject(getWorkDir());        assertNotNull("Cannot find FileObject for work dir", dir);        FileObject f1;        f1 = dir.createData("MANIFEST.MF");        assertNotNull("Cannot create file in work dir", f1);        DataObject d1 = DataObject.find(f1);        assertNotNull("Cannot find a data object", d1);        assertFalse("MANIFEST.MF file should not be checked", RunPMDAction.shouldCheck(d1));                f1 = dir.createData("PMDSample.java");        assertNotNull("Cannot create file in work dir", f1);        FileLock l = null;        try {            l = f1.lock();            PrintStream ps = new PrintStream (f1.getOutputStream(l));            ps.print("public class PMDSample { PMDSample () {} }");            ps.close();        }        finally {            if (l != null) {                l.releaseLock();            }        }        d1 = DataObject.find(f1);        assertTrue("Java file should be checked", RunPMDAction.shouldCheck(d1));        FileSystem fs = new XMLFileSystem(RunPMDActionTest.class.getResource("testfs.xml"));        f1 = fs.findResource("pkg/Sample.java");        assertFalse("expecting R/O file on XMLFileSystem", f1.canWrite());        d1 = DataObject.find(f1);        assertTrue("read only Java file "+d1+" should be checked too", RunPMDAction.shouldCheck(d1));    }    /**     * Test of asynchronous method, of class pmd.RunPMDAction.     */    public void testAsynchronous() {        pmd.RunPMDAction instance = (RunPMDAction)RunPMDAction.get(RunPMDAction.class);        assertTrue("RunPMDAction should be asynchronous", instance.asynchronous());    }    }
package test.net.sourceforge.pmd.rx.rules;import java.util.Set;import java.util.Iterator;import net.sourceforge.pmd.rx.facts.*;import net.sourceforge.pmd.rx.rules.*;import test.net.sourceforge.pmd.rx.*;public class DuplicateImportTest    extends DroolsRuleTst{    private String testName = null;    private String JAVA_NO_DUPE ="import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_DEMAND ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_NO_DEMAND ="import java.util.List;" +"import java.util.List;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_NO_DEMAND ="import java.util.*;" +"import java.util.List;" +"public class HelloWorld { }";    public DuplicateImportTest(String name) {super( name );this.testName = name;    }    public void testNoDupes() throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_NO_DUPE );Iterator rvs = results.iterator();while (rvs.hasNext()) {    RuleViolationFact rvFact = (RuleViolationFact) rvs.next();    ImportFact impFact = (ImportFact) rvFact.getFact();    System.err.println("DuplicateImport: " + impFact.getACU() + "/" +       impFact.getImportPackage() + "/" +       Integer.toString( impFact.getLineNumber() ));}assertEquals("Expecting no violations",     0, results.size() );    }    public void testDupeOnDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeOnNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }}
package test.net.sourceforge.pmd.rx;import java.util.Set;import java.util.HashSet;import java.util.Iterator;import java.io.StringReader;import org.drools.*;import org.drools.spi.*;import org.drools.semantic.java.*;import net.sourceforge.pmd.*;import net.sourceforge.pmd.rx.*;import net.sourceforge.pmd.ast.*;import net.sourceforge.pmd.rx.facts.*;import junit.framework.TestCase;public class DroolsVisitorTest    extends TestCase{    private String testName = null;    private static String JAVA_TEST_PACKAGE ="package test;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_1 ="import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_2 ="import java.util.*;" +"import java.lang.ref.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_SINGLE ="import java.util.Map;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_DUP ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_CLASS ="class TestClass { }";    private static String JAVA_TEST_CLASS_PUBLIC ="public class TestClass { }";    private static String JAVA_TEST_CLASS_ABSTRACT ="abstract class TestClass { }";    private static String JAVA_TEST_CLASS_INNER ="class Outer { class Inner { } }";    private static String JAVA_TEST_CLASS_ANON ="class Named { " +"  void foo() { Named.bar( new Runnable() { } ); } " +        "}";    private ASTCompilationUnit current = null;    public DroolsVisitorTest(String name) {super( name );this.testName = name;    }    public void testPackage() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.PackageFact.class,  JAVA_TEST_PACKAGE );assertEq("Expected one result.", 1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT( "Expected PackageFact.", fact instanceof PackageFact );PackageFact pkgFact = (PackageFact) fact;assertEq("Expecting package name of 'test'", "test", pkgFact.getPackageName() );    }    public void testImport1() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_1 );assertEq("Expected one result.", 1, results.size() );Iterator imports = results.iterator();Object fact = imports.next();assertT("Expected type of ImportFact",fact instanceof ImportFact);ImportFact impFact = (ImportFact) fact;assertEq("Expecting 'java.util' in Imports.", "java.util", impFact.getImportPackage() );    }    public void testImport2() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_2 );assertEq("Expected two results.", 2, results.size() );boolean sawUtil = false;boolean sawRef = false;ACUFact acu = null;Iterator imports = results.iterator();while (imports.hasNext()) {    Object fact = imports.next();    assertT("Expected type of ImportFact",    fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );    sawUtil = sawUtil |impFact.getImportPackage().equals("java.util");    sawRef = sawRef |impFact.getImportPackage().equals("java.lang.ref");}assertT("Expecting one import of 'java.util'", sawUtil);assertT("Expecting one import of 'java.lang.ref'", sawRef);    }    public void testImportDup() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_DUP );assertEq("Expected two results.", 2, results.size() );ACUFact acu = null;Iterator dups = results.iterator();while (dups.hasNext()) {    Object fact = dups.next();        assertT( "Expected fact to be of ImportFact type.",     fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );        assertT( "Should be On Demand.",     impFact.isOnDemand() );    assertEq("Expected java.util.Map to be imported.",     "java.util", impFact.getImportPackage() );}    }    public void testImportSingle() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_SINGLE );assertEq("Expected one result.", 1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ImportFact type.", fact instanceof ImportFact );ImportFact impFact = (ImportFact) fact;assertT( "Should not be listed as On Demand.", !impFact.isOnDemand() );assertEq("Expected java.util.Map to be imported.", "java.util.Map", impFact.getImportPackage() );    }    public void testClass() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS );assertEq( "Expected one result.",  1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT("Expected fact to be of ClassFact type.",fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass", classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, false, false, false );    }    public void testClassPublic() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_PUBLIC );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, true, false, false, false );    }    public void testClassAbstract() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_ABSTRACT );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, true, false, false );    }        public void testClassInner() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_INNER );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact outer = null;  ClassFact inner = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;          if (classFact.getClassName().equals("Outer")) {  outer = classFact;      }          if (classFact.getClassName().equals("Inner")) {  inner = classFact;      }}    }    public void testClassAnon() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_ANON );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact named = null;  ClassFact anon = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;      if (classFact.getOuterClass() == null) {  named = classFact;      } else {  anon = classFact;      }  }  assertNotNull( "Expected to find Named class.", named );  assertNotNull( "Expected to find Anon class.", anon );  assertEq( "Expected both classes to have same ACU.",    named.getACU(), anon.getACU() );  assertEq( "Expected Outer Class of Anon to be Named.",    named, anon.getOuterClass() );    }        public void assertEq( String message,  Object expected,  Object result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }        public void assertEq( String message,  boolean expected,  boolean result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertEq( String message,  int expected,  int result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertT( String message, boolean cond ) throws Throwable    {try {    assertTrue( message, cond );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public Set collectFacts( Class clazz,     String javaCode )throws Throwable    {RuleBase rules = new RuleBase();FactCollector collector = new FactCollector( clazz );rules.addRule( collector );JavaParser parser =    new JavaParser( new StringReader( javaCode ));ASTCompilationUnit acu =    parser.CompilationUnit();current = acu;WorkingMemory memory = rules.createWorkingMemory();DroolsVisitor IUT = new DroolsVisitor( memory );IUT.visit( acu, null );return collector.getFacts();    }    public void verifyClassFlags( ClassFact classFact,  boolean bPublic,  boolean bAbstract,  boolean bFinal,  boolean bStrict ) throws Throwable    {assertEq("Public: ", bPublic, classFact.isPublic() );assertEq("Abstract: ", bAbstract, classFact.isAbstract() );assertEq("Final: ", bFinal, classFact.isFinal() );assertEq("Strict: ", bStrict, classFact.isStrict() );    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 12:06:26 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.cpd.Tile;import net.sourceforge.pmd.dcpd.*;import java.util.ArrayList;import java.util.List;import java.util.Iterator;public class TileHarvesterTest extends TestCase {    public TileHarvesterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        // do the expansion from 1 to 2 tokens and write those expansions        // back to the mock space so TileHarvester can read them        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    TileExpanderTest.marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        space.setTileWrappers(space.getWrittenEntries());        // now the test        TileHarvester tileGatherer = new TileHarvester(space, job);        Occurrences newOcc = tileGatherer.harvest(occ.size());        assertEquals(2, newOcc.size());*/    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 11:04:26 AM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.jini.space.JavaSpace;import net.jini.core.lease.Lease;import net.sourceforge.pmd.dcpd.*;import net.sourceforge.pmd.cpd.*;import java.io.StringReader;import java.util.Iterator;import java.util.List;import java.util.ArrayList;import java.util.Stack;public class TileExpanderTest extends TestCase {    public TileExpanderTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        List writtenEntries = space.getWrittenEntries();        assertEquals(7, writtenEntries.size());*/    }   public static List marshal(Iterator i) {        List list = new ArrayList();        while (i.hasNext()) {            list.add(i.next());        }        return list;    }    public static TokenSets createTokenSets() throws Throwable {        TokenSets tokenSets = new TokenSets();        TokenList tokenList1 = new TokenList("list1");        JavaTokensTokenizer tokenizer = new JavaTokensTokenizer();        tokenizer.tokenize(tokenList1, new StringReader("public class Foo {}"));        tokenSets.add(tokenList1);        TokenList tokenList2 = new TokenList("list2");        tokenizer.tokenize(tokenList2, new StringReader("public class Bar {}"));        tokenSets.add(tokenList2);        return tokenSets;    }}
/* * User: tom * Date: Sep 6, 2002 * Time: 4:15:46 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.dcpd.Job;import net.sourceforge.pmd.dcpd.TilePlanter;public class TilePlanterTest extends TestCase {    public TilePlanterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        TilePlanter scatterer = new TilePlanter(space, job);        scatterer.plant(occ);        assertEquals(6, space.getWrittenEntries().size());*/    }}
/* * Created on 22 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.impl;import java.io.ByteArrayOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;import junit.framework.TestCase;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.core.PMDCoreException;import net.sourceforge.pmd.core.rulesets.IRuleSetsManager;import net.sourceforge.pmd.core.rulesets.vo.RuleSet;import net.sourceforge.pmd.core.rulesets.vo.RuleSets;/** * RuleSetsManager unit tests *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2006/10/06 16:42:04  phherlin * Continue refactoring of rullesets management * * Revision 1.1  2006/06/21 23:06:54  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * *  */public class RuleSetsManagerImplTest extends TestCase {    /**     * Test the valueOf method in its expected usage.     *      * @throws RuleSetNotFoundException     */    public void testValueOf1() throws PMDCoreException, RuleSetNotFoundException {        IRuleSetsManager rsm = new RuleSetsManagerImpl();        RuleSet ruleSet = rsm.valueOf(new String[] { "rulesets/basic.xml" });        Collection pmdRules = ruleSet.getPmdRuleSet().getRules();        Collection basicRules = new RuleSetFactory().createSingleRuleSet("rulesets/basic.xml").getRules();        // dump("PMD Rules", pmdRules);        // dump("Basic Rules", basicRules);        assertTrue("All the basic rules have not been loaded !", pmdRules.containsAll(basicRules));        assertTrue("All the loaded rules are not in the basic rules!", basicRules.containsAll(pmdRules));    }    /**     * Passing a null array to valueOf is not allowed     *      * @throws RuleSetNotFoundException     *      */    public void testValueOf2() throws PMDCoreException {        try {            IRuleSetsManager rsm = new RuleSetsManagerImpl();            RuleSet ruleSet = rsm.valueOf(null);            fail("Getting a rule set from a null array is not allowed");        } catch (IllegalArgumentException e) {            // Sucess        }    }    /**     * Passing an empty array to valueOf is not allowed     *      * @throws RuleSetNotFoundException     *      */    public void testValueOf3() throws PMDCoreException {        try {            IRuleSetsManager rsm = new RuleSetsManagerImpl();            RuleSet ruleSet = rsm.valueOf(new String[] {});            fail("Getting a rule set from an empty array is not allowed");        } catch (IllegalArgumentException e) {            // Sucess        }    }        /**     * Basically test the writeToXml operation.     *     */    public void testWriteToXml() throws PMDCoreException, UnsupportedEncodingException, IOException {        ByteArrayOutputStream out = null;        InputStream in = new FileInputStream("./test/testRuleSetsManager.rulesets");        if (in == null) {            throw new IllegalStateException("The test file testRuleSetsManager.rulesets cannot be found. The test cannot be performed.");        }                byte[] bytes = new byte[in.available()];        in.read(bytes);                String reference = new String(bytes, "UTF-8");        in.close();                System.out.println("--reference");        System.out.println(reference);                try {            IRuleSetsManager rsm = new RuleSetsManagerImpl();            RuleSet ruleSet = rsm.valueOf(new String[] { "rulesets/basic.xml" });            ruleSet.setName("basic");            ruleSet.setLanguage(RuleSet.LANGUAGE_JAVA);                        List ruleSetsList = new ArrayList();            ruleSetsList.add(ruleSet);                        RuleSets ruleSets = new RuleSets();            ruleSets.setRuleSets(ruleSetsList);            ruleSets.setDefaultRuleSet(ruleSet);            out = new ByteArrayOutputStream();            rsm.writeToXml(ruleSets, out);                        String result = new String(out.toByteArray(), "UTF-8");                        System.out.println("--result");            System.out.println(result);                        assertEquals("The outpout rulesets is not the expected one", reference, result);        } finally {            if (out != null) {                out.close();            }        }    }    /**     * Dump a collection of rules     *      * @param message     * @param rules     */    private void dump(String message, Collection rules) {        System.out.println("Dump " + message);        for (Iterator i = rules.iterator(); i.hasNext();) {            Rule rule = (Rule) i.next();            System.out.println(rule.getName());        }        System.out.println();    }}
/* * Created on 18 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import java.util.HashSet;import java.util.Set;import junit.framework.TestCase;/** * Unit tests for Properties object *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * * */public class PropertiesTest extends TestCase {        /**     * A new properties object must have its set of properties not null and empty     *     */    public void testDefaults() {        Properties p = new Properties();        assertNotNull("Properties set cannot be null", p.getProperties());        assertEquals("Properties set should be empty", 0, p.getProperties().size());    }    /**     * Setting any set as properties is allowed for now !     *     */    public void testSetProperties1() {        try {            Properties p = new Properties();            Set set = new HashSet();            set.add("foo");            p.setProperties(set);        } catch (IllegalArgumentException e) {            fail("Setting any set as properties is allowed for now!");        }    }        /**     * Setting a null set as properties is illegal     *     */    public void testSetProperties2() {        try {            Properties p = new Properties();            p.setProperties(null);            fail("Setting a null set as properties is illegal");        } catch (IllegalArgumentException e) {            // success!        }    }        /**     * Obviously an instance is equals to itself     *     */    public void testEquals1() {        Properties p = new Properties();        assertEquals("An instance should be equals to itself", p, p);    }        /**     * 2 different properties instances are equals if their set are the same      */    public void testEquals2() {        Properties p1 = new Properties();        Set set = new HashSet();        set.add("foo");        p1.setProperties(set);        Properties p2 = new Properties();        p2.setProperties(set);                assertEquals("2 different properties instances are equals if their set are the same", p1, p2);    }    /**     * 2 different properties instances are equals if their set are the same.     * same as previous one but with a legal properties set.     */    public void testEquals3() {        Property prop = new Property();        prop.setName("p1");        prop.setValue("value1");        Set set = new HashSet();        set.add(prop);        Properties p1 = new Properties();        p1.setProperties(set);        Properties p2 = new Properties();        p2.setProperties(set);                assertEquals("2 different properties instances are equals if their set are the same", p1, p2);    }    /**     * 2 different properties instances are equals if their set are the same.     * same as previous one but with 2 differents sets     */    public void testEquals4() {        Property prop = new Property();        prop.setName("p1");        prop.setValue("value1");        Set set1 = new HashSet();        set1.add(prop);        Set set2 = new HashSet();        set2.add(prop);        Properties p1 = new Properties();        p1.setProperties(set1);        Properties p2 = new Properties();        p2.setProperties(set2);                assertEquals("2 different properties instances are equals if their set are the same", p1, p2);    }    /**     * 2 different properties instances are equals if their set are the same.     * same as previous one but with 2 differents instances of property objets.     */    public void testEquals5() {        Property prop1 = new Property();        prop1.setName("p1");        prop1.setValue("value1");        Property prop2 = new Property();        prop2.setName("p1");        prop2.setValue("value1");        Set set1 = new HashSet();        set1.add(prop1);        Set set2 = new HashSet();        set2.add(prop2);        Properties p1 = new Properties();        p1.setProperties(set1);        Properties p2 = new Properties();        p2.setProperties(set2);                assertEquals("2 different properties instances are equals if their set are the same", p1, p2);    }    /**     * 2 different properties instances are different if their set are the different     */    public void testEquals6() {        Property prop1 = new Property();        prop1.setName("p1");        prop1.setValue("value1");        Property prop2 = new Property();        prop2.setName("p2");        prop2.setValue("value2");        Set set1 = new HashSet();        set1.add(prop1);        Set set2 = new HashSet();        set1.add(prop2);        Properties p1 = new Properties();        p1.setProperties(set1);        Properties p2 = new Properties();        p2.setProperties(set2);                assertFalse("2 different properties instances are different if their set are the different", p1.equals(p2));    }        /**     * A properties Object cannot be equals to null     *     */    public void testEquals7() {        Property prop1 = new Property();        prop1.setName("p1");        prop1.setValue("value1");        Set set1 = new HashSet();        set1.add(prop1);        Properties p1 = new Properties();        p1.setProperties(set1);                assertFalse("A properties object cannot be equals to null", p1.equals(null));    }        /**     * A properties Object cannot be equals to any other objects     *     */    public void testEquals8() {        Property prop1 = new Property();        prop1.setName("p1");        prop1.setValue("value1");        Set set1 = new HashSet();        set1.add(prop1);        Properties p1 = new Properties();        p1.setProperties(set1);                assertFalse("A properties Object cannot be equals to any other objects", p1.equals(prop1));        assertFalse("A properties Object cannot be equals to any other objects", p1.equals(set1));    }    /**     * 2 equal properties must have the same hashCode     *     */    public void testHashCode1() {        Property prop1 = new Property();        prop1.setName("p1");        prop1.setValue("value1");        Property prop2 = new Property();        prop2.setName("p1");        prop2.setValue("value1");        Set set1 = new HashSet();        set1.add(prop1);        Set set2 = new HashSet();        set2.add(prop2);        Properties p1 = new Properties();        p1.setProperties(set1);        Properties p2 = new Properties();        p2.setProperties(set2);                assertEquals("2 equal properties must have the same hashCode", p1.hashCode(), p2.hashCode());    }    /**     * 2 different properties must have the different hashCode     *     */    public void testHashCode2() {        Property prop1 = new Property();        prop1.setName("p1");        prop1.setValue("value1");        Property prop2 = new Property();        prop2.setName("p2");        prop2.setValue("value2");        Set set1 = new HashSet();        set1.add(prop1);        Set set2 = new HashSet();        set2.add(prop2);        Properties p1 = new Properties();        p1.setProperties(set1);        Properties p2 = new Properties();        p2.setProperties(set2);                assertFalse("2 different properties must have the different hashCode", p1.hashCode() == p2.hashCode());    }}
/* * Created on 17 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import junit.framework.TestCase;/** * Unit tests of class Property *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * * Revision 1.1  2006/06/18 22:29:50  phherlin * Begin refactoring the unit tests for the plugin * *  */public class PropertyTest extends TestCase {    /**     * A new property objet has its name and value not null and assigned to an     * empty string.     *      */    public void testDefaults() {        Property p = new Property();        assertNotNull("Name must not be null", p.getName());        assertTrue("Name must be an empty string", p.getName().length() == 0);        assertNotNull("Value must not be null", p.getValue());        assertTrue("Value must be an empty string", p.getValue().length() == 0);    }    /**     * Assigning any string to name is legal.     *      */    public void testSetName1() {        Property p = new Property();        p.setName("any string");        assertEquals("Name can be assigned any string", "any string", p.getName());    }    /**     * Assigning null to name is illegal.     *      */    public void testSetName2() {        try {            Property p = new Property();            p.setName(null);            fail("Assigning null to name is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Assigning any string to value is legal.     *      */    public void testSetValue1() {        Property p = new Property();        p.setValue("any string");        assertEquals("Value can be assigned any string", "any string", p.getValue());    }    /**     * Assigning null to Value is illegal.     *      */    public void testSetValue2() {        try {            Property p = new Property();            p.setValue(null);            fail("Assigning null to value is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * 2 properties are equals if their names and value are equal     *      */    public void testEquals1() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                assertEquals("2 properties must be equals if their names and values are equals", p1, p2);    }    /**     * 2 properties are diffrent if their names are different.     *      */    public void testEquals2() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p2");        p2.setValue("value1");                assertFalse("2 properties must be different if their names are different", p1.equals(p2));    }    /**     * 2 properties are diffrent if their value are different.     *      */    public void testEquals3() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p1");        p2.setValue("value2");                assertFalse("2 properties must be different if their values are different", p1.equals(p2));    }        /**     * A property is always different than null     *     */    public void testEquals4() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        assertFalse("A property cannot be equals to null", p1.equals(null));    }        /**     * Any property objet is always different that any other objets     *     */    public void testEquals5() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        assertFalse("Property object must be different that any other object", p1.equals("p1"));    }        /**     * Obviously a property object is equals to itself     *     */    public void testEquals6() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        assertEquals("A property object is equals to itself", p1, p1);    }        /**     * 2 equal properties must have the same hashCode     *     */    public void testHashCode1() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                assertTrue("2 equal properties must have the same hashCode", p1.hashCode() == p2.hashCode());    }    /**     * 2 different properties must have the different hashCodes.     *     */    public void testHashCode2() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p2");        p2.setValue("value1");                assertFalse("2 different properties should have different hashCodes", p1.hashCode() == p2.hashCode());    }    /**     * 2 different properties must have the different hashCodes.     *     */    public void testHashCode3() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p1");        p2.setValue("value2");                assertFalse("2 different properties should have different hashCodes", p1.hashCode() == p2.hashCode());    }    /**     * 2 different properties must have the different hashCodes.     *     */    public void testHashCode4() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");        Property p2 = new Property();        p2.setName("p2");        p2.setValue("value2");                assertFalse("2 different properties should have different hashCodes", p1.hashCode() == p2.hashCode());    }}
/* * Created on 22 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import java.util.Iterator;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;/** *  *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * * */public class TestManager {    private static RuleSet basicRuleSet;    private static Rule[] rules;        public static Rule getRule(int i) throws RuleSetNotFoundException {        if (rules == null) {            getRuleSet();        }                return rules[i];    }        public static RuleSet getRuleSet() throws RuleSetNotFoundException {        if (basicRuleSet == null) {            basicRuleSet = new RuleSetFactory().createSingleRuleSet("rulesets/basic.xml");            Iterator i = getRuleSet().getRules().iterator();            rules = new Rule[4];            for (int j = 0; j < 4; j++) {                rules[j] = (Rule) i.next();            }        }                return basicRuleSet;    }}
/* * Created on 17 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import junit.framework.TestCase;/** * Unit tests of Priority object. *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2006/10/06 16:42:03  phherlin * Continue refactoring of rullesets management * * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * * Revision 1.1  2006/06/18 22:29:50  phherlin * Begin refactoring the unit tests for the plugin * * */public class PriorityTest extends TestCase {        /**     * A default constructed priority is set to level 3     *     */    public void testDefaultPriority() {        assertEquals("Default priority is not set to 3", Priority.LEVEL3, new Priority());    }    /**     * It is legal to construct a priority object and to assign a value.     * This test implicitluy test the basic equality also.     * All in one test case!     */    public void testSetPriority() {        Priority p = new Priority();        p.setPriorityValue(Priority.LEVEL1_LITTERAL);        assertEquals("Constructing a priority level 1 has failed!", Priority.LEVEL1, p);        p.setPriorityValue(Priority.LEVEL2_LITTERAL);        assertEquals("Constructing a priority level 2 has failed!", Priority.LEVEL2, p);        p.setPriorityValue(Priority.LEVEL3_LITTERAL);        assertEquals("Constructing a priority level 3 has failed!", Priority.LEVEL3, p);        p.setPriorityValue(Priority.LEVEL4_LITTERAL);        assertEquals("Constructing a priority level 4 has failed!", Priority.LEVEL4, p);        p.setPriorityValue(Priority.LEVEL5_LITTERAL);        assertEquals("Constructing a priority level 5 has failed!", Priority.LEVEL5, p);    }        /**     * Test an illegal value that is 0     *     */    public void testSetPriorityIllegal1() {        try {            Priority p = new Priority();            p.setPriorityValue(0);            fail("Setting a priority level to 0 should raise an IllegalArgumentException");        } catch (IllegalArgumentException e) {            // this is correct        }    }        /**     * Test an illegal value that is negative     *     */    public void testSetPriorityIllegal2() {        try {            Priority p = new Priority();            p.setPriorityValue(-15);            fail("Setting a priority level to a negative number should raise an IllegalArgumentException");        } catch (IllegalArgumentException e) {            // this is correct        }    }        /**     * Test an illegal value that is too high     *     */    public void testSetPriorityIllegal3() {        try {            Priority p = new Priority();            p.setPriorityValue(6);            fail("Setting a priority level to a high value should raise an IllegalArgumentException");        } catch (IllegalArgumentException e) {            // this is correct        }    }        /**     * 2 different instances assigned different levels are not equals     *     */    public void testEquals1() {        Priority p = new Priority();        p.setPriorityValue(1);                assertFalse("2 priorities with different levels (1:2) are not equals", Priority.LEVEL2.equals(p));        assertFalse("2 priorities with different levels (1:3) are not equals", Priority.LEVEL3.equals(p));        assertFalse("2 priorities with different levels (1:4) are not equals", Priority.LEVEL4.equals(p));        assertFalse("2 priorities with different levels (1:5) are not equals", Priority.LEVEL5.equals(p));    }        /**     * Any priority object is always not equal to null     *     */    public void testEquals2() {        assertFalse("Priority object (1) is not equal to null", Priority.LEVEL1.equals(null));        assertFalse("Priority object (2) is not equal to null", Priority.LEVEL2.equals(null));        assertFalse("Priority object (3) is not equal to null", Priority.LEVEL3.equals(null));        assertFalse("Priority object (4) is not equal to null", Priority.LEVEL4.equals(null));        assertFalse("Priority object (5) is not equal to null", Priority.LEVEL5.equals(null));    }        /**     * Any priority objet is always different that any other objets     *     */    public void testEquals3() {        assertFalse("Priority object must be different that any other object", Priority.LEVEL1.equals(new Integer(1)));    }        public void testEquals4() {        Priority p1 = new Priority();        assertEquals("A priority objetc must be equals to itself", p1, p1);    }        /**     * 2 equals objets have the same hashcode     *     */    public void testHashCode1() {        Priority p = new Priority();        assertTrue("2 equal priority objects must have the same hashcode value", Priority.LEVEL3.hashCode() == p.hashCode());    }        /**     * 2 different priority objects must have different hashcode values     *     */    public void testHashCode2() {        assertFalse("2 different priority objects must have different hashcode values", Priority.LEVEL1.hashCode() == Priority.LEVEL2.hashCode());    }}
/* * Created on 18 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import junit.framework.TestCase;import net.sourceforge.pmd.RuleSetNotFoundException;/** * Unit tests for the RuleSet class *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * Revision 1.1 2006/06/18 22:29:50 phherlin Begin refactoring the unit * tests for the plugin *  *  */public class RuleSetTest extends TestCase {    /**     * Test the default attributes of a rule set     *      */    public void testDefaults() {        RuleSet rs = new RuleSet();        assertNotNull("Name should not be null", rs.getName());        assertNotNull("Description should not be null", rs.getDescription());        assertNotNull("Rules should not be null", rs.getRules());        assertNotNull("Language should not be null", rs.getLanguage());        assertEquals("Name should be empty", 0, rs.getName().length());        assertEquals("Description should be empty", 0, rs.getDescription().length());        assertEquals("Rules collecction should be empty", 0, rs.getRules().size());        assertEquals("Default language should be set to Java", RuleSet.LANGUAGE_JAVA, rs.getLanguage());    }    /**     * Setting any name is legal     *      */    public void testSetName1() {        try {            RuleSet rs = new RuleSet();            rs.setName("any name");        } catch (IllegalArgumentException e) {            fail("setting name to any name is legal");        }    }    /**     * Setting name to null is illegal     *      */    public void testSetName2() {        try {            RuleSet rs = new RuleSet();            rs.setName(null);            fail("setting name to null is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting name to empty string is illegal     *      */    public void testSetName3() {        try {            RuleSet rs = new RuleSet();            rs.setName("");            fail("setting name to empty string is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting name to empty string is illegal     *      */    public void testSetName4() {        try {            RuleSet rs = new RuleSet();            rs.setName(" \t\n");            fail("setting name to empty string is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting any description is legal     *      */    public void testSetDescription1() {        try {            RuleSet rs = new RuleSet();            rs.setDescription("any description");        } catch (IllegalArgumentException e) {            fail("setting description to any string is legal");        }    }    /**     * Setting description to null is illegal     *      */    public void testSetDescription2() {        try {            RuleSet rs = new RuleSet();            rs.setDescription(null);            fail("setting description to null is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting Description to empty string is legal     *      */    public void testSetDescription3() {        try {            RuleSet rs = new RuleSet();            rs.setDescription("");        } catch (IllegalArgumentException e) {            fail("setting description to empty string is legal");        }    }    /**     * Setting Description to empty string is legal     *      */    public void testSetDescription4() {        try {            RuleSet rs = new RuleSet();            rs.setDescription(" \t\n");            assertEquals("The string should not be modified", " \t\n", rs.getDescription());        } catch (IllegalArgumentException e) {            fail("setting description to empty string is legal");        }    }    /**     * Language could be assigned the JAVA value     *      */    public void testSetLanguage1() {        try {            RuleSet rs = new RuleSet();            rs.setLanguage("JAVA");        } catch (IllegalArgumentException e) {            fail("setting language to JAVA is legal");        }    }    /**     * Language could be assigned the JSP value     *      */    public void testSetLanguage2() {        try {            RuleSet rs = new RuleSet();            rs.setLanguage("JSP");        } catch (IllegalArgumentException e) {            fail("setting language to JSP is legal");        }    }    /**     * Setting language to null is illegal     *      */    public void testSetLanguage3() {        try {            RuleSet rs = new RuleSet();            rs.setLanguage(null);            fail("setting language to null is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting language to empty string is illegal     *      */    public void testSetLanguage4() {        try {            RuleSet rs = new RuleSet();            rs.setLanguage("");            fail("setting language to empty string is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting language to empty string is illegal     *      */    public void testSetLanguage5() {        try {            RuleSet rs = new RuleSet();            rs.setLanguage(" \t\n");            fail("setting language to empty string is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Setting language to any string is illegal     *      */    public void testSetLanguage6() {        try {            RuleSet rs = new RuleSet();            rs.setLanguage("any string");            fail("setting language to any string is illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Adding a rule.     *      * @throws RuleSetNotFoundException     *      */    public void testAddRule1() throws RuleSetNotFoundException {        try {            RuleSet rs = new RuleSet();            Rule rule = new Rule();            rule.setPmdRule(TestManager.getRule(0));            rs.addRule(rule);        } catch (IllegalArgumentException e) {            fail("adding any rule object is legal !");        }    }    /**     * Adding a null rule is illegal.     *      */    public void testAddRule2() {        try {            RuleSet rs = new RuleSet();            rs.addRule(null);            fail("Adding a null rule is illegal !");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * An instance of a rule set is equals to itself     *      */    public void testEquals1() {        RuleSet rs = new RuleSet();        rs.setName("default");        assertEquals("A ruleset is equal to itself", rs, rs);    }    /**     * A rule set is never equal to null     *      */    public void testEquals2() {        RuleSet rs = new RuleSet();        rs.setName("default");        assertFalse("A ruleset is never equal to null", rs.equals(null));    }    /**     * RuleSets are equal if they have the same name, language and rules     * collection whatever the description.     *      * @throws RuleSetNotFoundException     *      */    public void testEquals3() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("default");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertEquals("These rule sets should be equals", rs1, rs2);    }    /**     * Rule sets with different names are different     *      * @throws RuleSetNotFoundException     *      */    public void testEquals4() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("custom");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertFalse("Rule sets with different names are different", rs1.equals(rs2));    }    /**     * Rule sets with different languages are different     *      * @throws RuleSetNotFoundException     *      */    public void testEquals5() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("default");        rs2.setLanguage(RuleSet.LANGUAGE_JAVA);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertFalse("Rule sets with different languages are different", rs1.equals(rs2));    }    /**     * Rule sets with different rules collection are different     *      * @throws RuleSetNotFoundException     *      */    public void testEquals7() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to yet another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("default");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertFalse("Rule sets with different rules collections are different", rs1.equals(rs2));    }    /**     * Equal rule sets must have the same hash code     *      * @throws RuleSetNotFoundException     *      */    public void testHashCode1() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("default");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertEquals("Equal rule sets must have the same hash code", rs1.hashCode(), rs2.hashCode());    }    /**     * Different rule sets should have different hash codes     *      * @throws RuleSetNotFoundException     *      */    public void testHashCode2() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("custom");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertFalse("Different rule sets should have different hash codes", rs1.hashCode() == rs2.hashCode());    }    /**     * Different rule sets should have different hash codes     *      * @throws RuleSetNotFoundException     *      */    public void testHashCode3() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("default");        rs2.setLanguage(RuleSet.LANGUAGE_JAVA);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertFalse("Different rule sets should have different hash codes", rs1.hashCode() == rs2.hashCode());    }    /**     * Different rule sets should have different hash codes     *      * @throws RuleSetNotFoundException     *      */    public void testHashCode4() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to yet another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("default");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        assertFalse("Different rule sets should have different hash codes", rs1.hashCode() == rs2.hashCode());    }    /**     * The PMD Rule Set should contain the we have added     *      * @throws RuleSetNotFoundException     *      */    public void testGetPmdRuleSet() throws RuleSetNotFoundException {        Rule rule = new Rule();        rule.setPmdRule(TestManager.getRule(0));        RuleSet ruleSet = new RuleSet();        ruleSet.addRule(rule);        assertNotNull("The PMD Rule Set should not be null", ruleSet.getPmdRuleSet());        assertTrue("The added rule set should be present in the PMD rule set", ruleSet.getPmdRuleSet().getRules().contains(                TestManager.getRule(0)));    }}
/* * Created on 20 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import java.util.ArrayList;import java.util.List;import net.sourceforge.pmd.RuleSetNotFoundException;import junit.framework.TestCase;/** * Unit tests for RuleSets class *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2006/10/06 16:42:03  phherlin * Continue refactoring of rullesets management * * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * * Revision 1.1  2006/06/20 22:04:18  phherlin * Implement the last object of the rulesets structure * *  */public class RuleSetsTest extends TestCase {    /**     * Test the defaults of a RuleSets object     *      */    public void testDefaults() {        RuleSets rs = new RuleSets();        assertNull("the default rule set should be null", rs.getDefaultRuleSet());        assertNotNull("the rule sets list should not be null", rs.getRuleSets());        assertEquals("The rule sets list should be empty", 0, rs.getRuleSets().size());    }        /**     * Setting a null rule sets list is not allowed     *     */    public void testSetRuleSets1() {        try {            RuleSets rs = new RuleSets();            rs.setRuleSets(null);            fail("Setting a null rule sets is illegal");        } catch (IllegalArgumentException e) {            // success        }    }        /**     * Setting an empty rule sets list is not allowed     *     */    public void testSetRuleSets2() {        try {            RuleSets rs = new RuleSets();            rs.setRuleSets(new ArrayList());            fail("Setting an empty rule sets is illegal");        } catch (IllegalArgumentException e) {            // success        }    }        /**     * Setting any non empty list is OK.     * We do not validate the element type for now.     *     */    public void testSetRuleSets3() {        List l = new ArrayList();        l.add("a ruleset");        RuleSets rs = new RuleSets();        rs.setRuleSets(l);                assertSame("The rule set list has not been set", l, rs.getRuleSets());    }    /**     * Setting a null default rule set is illegal     *      */    public void testSetDefaultRuleSet1() {        try {            RuleSets rs = new RuleSets();            rs.setDefaultRuleSet(null);            fail("setting a default rule set to null should be illegal");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * A default rule set should belong to the rule sets list.     * @throws RuleSetNotFoundException      *      */    public void testSetDefaultRuleSet2() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("custom");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        try {            RuleSets rs = new RuleSets();            rs.getRuleSets().add(rs1);            rs.setDefaultRuleSet(rs2);            fail("The default rule set should belong to the rulesets list");        } catch (IllegalArgumentException e) {            // success        }    }    /**     * Test the definition of a default rule set.     * @throws RuleSetNotFoundException      *      */    public void testSetDefaultRuleSet3() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        Rule r3 = new Rule();        r3.setRef("ref to a rule");        r3.setPmdRule(TestManager.getRule(2));        Rule r4 = new Rule();        r4.setRef("ref to another rule");        r4.setPmdRule(TestManager.getRule(3));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);        RuleSet rs2 = new RuleSet();        rs2.setName("custom");        rs2.setLanguage(RuleSet.LANGUAGE_JSP);        rs2.addRule(r3);        rs2.addRule(r4);        rs2.setDescription("Description does not make the difference");        RuleSets rs = new RuleSets();        rs.getRuleSets().add(rs1);        rs.getRuleSets().add(rs2);        rs.setDefaultRuleSet(rs2);                assertSame("The default rule set has not been defined!", rs2, rs.getDefaultRuleSet());    }        /**     * 2 rule sets are equals if they are the same instance     *     */    public void testEquals1() {        RuleSets rs1 = new RuleSets();        RuleSets rs2 = rs1;                assertEquals("Rule sets should be equal", rs1, rs2);    }        /**     * 2 rule sets are different if they are different instance     *     */    public void testEquals2() {        RuleSets rs1 = new RuleSets();        RuleSets rs2 = new RuleSets();                assertFalse("Rule sets should not be equal", rs1.equals(rs2));    }        /**     * A rule sets should not be equals to null     *     */    public void testEquals3() {        RuleSets rs1 = new RuleSets();                assertFalse("Rule sets should not be equal to null", rs1.equals(null));    }        /**     * 2 equals rule sets should have the same hash code     *     */    public void testHashCode1() {        RuleSets rs1 = new RuleSets();        RuleSets rs2 = rs1;                assertEquals("Equal Rule sets should have the same hash code", rs1.hashCode(), rs2.hashCode());    }        /**     * 2 different rule sets should have different hash code     *     */    public void testHashCode2() {        RuleSets rs1 = new RuleSets();        RuleSets rs2 = new RuleSets();                assertFalse("Different rule sets should have different hash code", rs1.hashCode() == rs2.hashCode());    }        /**     * Test the basic usage of the default ruleset setter     *     */    public void testSetDefaultRuleSetName() throws RuleSetNotFoundException {        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setPmdRule(TestManager.getRule(0));        Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setPmdRule(TestManager.getRule(1));        RuleSet rs1 = new RuleSet();        rs1.setName("default");        rs1.setLanguage(RuleSet.LANGUAGE_JSP);        rs1.addRule(r1);        rs1.addRule(r2);                List ruleSetsList = new ArrayList();        ruleSetsList.add(rs1);                RuleSets ruleSets = new RuleSets();        ruleSets.setRuleSets(ruleSetsList);                ruleSets.setDefaultRuleSetName("default");                assertSame("The default ruleset has not been set correctly", rs1, ruleSets.getDefaultRuleSet());    }        /**     * Test setting a default ruleset name to null     *     */    public void testSetDefaultRuleSetNameNull() {        try {            RuleSets ruleSets = new RuleSets();            ruleSets.setDefaultRuleSetName(null);            fail("Setting a default ruleset name to null is illegal");        } catch (IllegalArgumentException e) {            // success        }    }}
/* * Created on 18 juin 2006 * * Copyright (c) 2006, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.rulesets.vo;import junit.framework.TestCase;import net.sourceforge.pmd.RuleSetNotFoundException;/** * Unit tests for class Rule *  * @author Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/21 23:06:52  phherlin * Move the new rule sets management to the core plugin instead of the runtime. * Continue the development. * * Revision 1.1  2006/06/18 22:29:50  phherlin * Begin refactoring the unit tests for the plugin * * */public class RuleTest extends TestCase {    /**     * Asserts the defaults of a new rule object     *     */    public void testDefaults() {        Rule r = new Rule();        assertNotNull("The ref attribute must not be null", r.getRef());        assertEquals("The ref attribute should be empty", 0, r.getRef().trim().length());        assertNull("The message attribute should be null", r.getMessage());        assertNull("The priority attribute should be null", r.getPriority());        assertNull("The properties attribute should be null", r.getProperties());        assertNull("The pmd rule attribute should be null", r.getPmdRule());    }        /**     * Setting a null ref attribute is illegal     *     */    public void testSetRef1() {        try {            Rule r = new Rule();            r.setRef(null);            fail("Setting a null ref attribute is illegal");        } catch (IllegalArgumentException e) {            // success        }    }        /**     * Setting an empty ref attribute is illegal     *     */    public void testSetRef2() {        try {            Rule r = new Rule();            r.setRef("");            fail("Setting an empty string for the ref attribute is illegal");        } catch (IllegalArgumentException e) {            // success        }    }        /**     * Setting an empty ref attribute is illegal.     * Test with blank characters.     *     */    public void testSetRef3() {        try {            Rule r = new Rule();            r.setRef(" \r\n");            fail("Setting an empty string for the ref attribute is illegal");        } catch (IllegalArgumentException e) {            // success        }    }        /**     * To be sure, a ref attribute should be assigned any string     *     */    public void testSetRef4() {        try {            Rule r = new Rule();            r.setRef("any string");        } catch (IllegalArgumentException e) {            fail("It should be legal to set any string to ref attribute");        }    }        /**     * Setting a null PMD Rule is illegal     *     */    public void testSetPmdRule1() {        try {            Rule r = new Rule();            r.setPmdRule(null);            fail("Setting a null PMD Rule is illegal");        } catch (IllegalArgumentException e) {            // success        }    }        /**     * Setting a any PMD Rule is legal even if the reference is     * not the same (no check for now).     *      * @throws RuleSetNotFoundException      *     */    public void testSetPmdRule2() throws RuleSetNotFoundException {        try {            Rule r = new Rule();            r.setPmdRule(TestManager.getRule(0));        } catch (IllegalArgumentException e) {            fail("Setting any PMD Rule is legal");        }    }        /**     * an instance of a Rule object is equal to itself     */    public void testEquals1() {        Rule r = new Rule();        r.setRef("A reference");        assertEquals("A instance of Rule is equals to itself", r, r);    }        /**     * a rule cannot be equals to null     */    public void testEquals2() {        Rule r = new Rule();        r.setRef("A reference");        assertFalse("A rule cannot be equal to null", r.equals(null));    }        /**     * To be equals, rules must share the same ref, priority and properties.     *     */    public void testEquals3() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to a rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL3);        r2.setMessage("Message doesn't make the difference");        assertEquals("These 2 rules must be equal", r1, r2);            }        /**     * Rules with a different ref attribute are not equals     *     */    public void testEquals4() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL3);        r2.setMessage("Message doesn't make the difference");        assertFalse("Rules with different ref attribute are different", r1.equals(r2));            }        /**     * Rules with a different priority are not equals     *     */    public void testEquals5() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to a rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL1);        r2.setMessage("Message doesn't make the difference");        assertFalse("Rules with different priority are different", r1.equals(r2));            }        /**     * Rules with different properties are not equals     *     */    public void testEquals6() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value2");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to a rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL3);        r2.setMessage("Message doesn't make the difference");        assertFalse("Rules with different properties are different", r1.equals(r2));            }        /**     * Equal rules have the same hash code     *     */    public void testHashCode1() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to a rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL3);        r2.setMessage("Message doesn't make the difference");        assertEquals("Equal rules have the same hashcode", r1.hashCode(), r2.hashCode());            }        /**     * Different rules should have different hashCode     *     */    public void testHashCode2() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to another rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL3);        r2.setMessage("Message doesn't make the difference");        assertFalse("Different rules should have different hash code", r1.hashCode() == r2.hashCode());            }        /**     * Different rules should have different hash code     *     */    public void testHashCode3() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value1");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to a rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL1);        r2.setMessage("Message doesn't make the difference");        assertFalse("Different rules should have different hash code", r1.hashCode() == r2.hashCode());            }        /**     * Different rules should have different hash code     *     */    public void testHashCode4() {        Property p1 = new Property();        p1.setName("p1");        p1.setValue("value1");                Properties s1 = new Properties();        s1.getProperties().add(p1);                Property p2 = new Property();        p2.setName("p1");        p2.setValue("value2");                Properties s2 = new Properties();        s2.getProperties().add(p2);        Rule r1 = new Rule();        r1.setRef("ref to a rule");        r1.setProperties(s1);        r1.setPriority(Priority.LEVEL3);                Rule r2 = new Rule();        r2.setRef("ref to a rule");        r2.setProperties(s2);        r2.setPriority(Priority.LEVEL3);        r2.setMessage("Message doesn't make the difference");        assertFalse("Different rules should have different hash code", r1.hashCode() == r2.hashCode());            }}
/* * Created on 2 juillet 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core.ext;import java.util.Iterator;import java.util.Set;import junit.framework.TestCase;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.core.PMDCorePlugin;/** * Test the ruleset extension *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/18 22:29:52  phherlin * Begin refactoring the unit tests for the plugin * Revision 1.1 2005/07/02 14:32:02 phherlin Implement the RuleSets * extension points new tests *  *  */public class RuleSetsExtensionProcessorTest extends TestCase {    /**     * Tests the additional rulesets has been registered. For this test to work,     * the test plugin fragment must be installed.     *      */    public void testAdditionalRuleSetsRegistered() throws RuleSetNotFoundException {        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();        assertFalse("No registered rulesets!", registeredRuleSets.isEmpty());        RuleSetFactory factory = new RuleSetFactory();        RuleSet ruleSet = factory.createSingleRuleSet("rulesets/extra1.xml");        assertTrue("RuleSet \"rulesets/extra1.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));        ruleSet = factory.createSingleRuleSet("rulesets/extra2.xml");        assertTrue("RuleSet \"rulesets/extra2.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));    }    /**     * Tests the additional default rulesets has been registered. For this test     * to work, the test plugin fragment must be installed.     *      */    public void testAdditionalDefaultRuleSetsRegistered() throws RuleSetNotFoundException {        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getDefaultRuleSets();        assertFalse("No registered default rulesets!", registeredRuleSets.isEmpty());        RuleSetFactory factory = new RuleSetFactory();        RuleSet ruleSet = factory.createSingleRuleSet("rulesets/extra1.xml");        assertTrue("RuleSet \"rulesets/extra1.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));        ruleSet = factory.createSingleRuleSet("rulesets/extra2.xml");        assertTrue("RuleSet \"rulesets/extra2.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));    }    /**     * test if a ruleset is registered     *      * @param ruleSet     * @param set     * @return true if ok     */    private boolean ruleSetRegistered(RuleSet ruleSet, Set set) {        boolean registered = false;        Iterator i = set.iterator();        while (i.hasNext() && !registered) {            RuleSet registeredRuleSet = (RuleSet) i.next();            registered = registeredRuleSet.getName().equals(ruleSet.getName());        }        return registered;    }}
/* * Created on 7 juin 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.core.IRuleSetManager;import net.sourceforge.pmd.core.impl.RuleSetManagerImpl;import junit.framework.TestCase;/** * Test the ruleset manager. *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * * Revision 1.2  2005/07/02 14:32:01  phherlin * Implement the RuleSets extension points new tests * * Revision 1.1  2005/06/15 21:14:56  phherlin * Create the project for the Eclipse plugin unit tests * * */public class RuleSetManagerTest extends TestCase {    private IRuleSetManager ruleSetManager;    /**     * Default constructor     * @param name     */    public RuleSetManagerTest(String name) {        super(name);    }        /**     * Test the register ruleset     *     */    public void testRegisterRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        assertEquals("RuleSet not registrered!", 1, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Test the registration of a null ruleset     *     */    public void testRegisterNullRuleSet() {        try {            this.ruleSetManager.registerRuleSet(null);            fail("Should return an IllegalArgumentException");        } catch (IllegalArgumentException e) {            ; // cool        }    }        /**     * Registering twice the same rule set results in no addition     *     */    public void testDuplicateRegister() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        this.ruleSetManager.registerRuleSet(ruleSet);        assertEquals("Only one rule set should have been registered", 1, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Test unregistration     *     */    public void testUnregisterRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        assertEquals("RuleSet not registered!", 1, this.ruleSetManager.getRegisteredRuleSets().size());        this.ruleSetManager.unregisterRuleSet(ruleSet);        assertEquals("RuleSet not unregistered", 0, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Unregistering a null ruleset is illegal     *     */    public void testUnregisterNullRuleSet() {        try {            this.ruleSetManager.unregisterRuleSet(null);            fail("An IllegalArgumentException should be returned");        } catch (RuntimeException e) {            ; // cool        }    }        /**     * Unregistering twice the same rule set has no effect     *     */    public void testDuplicateUnregister() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        this.ruleSetManager.unregisterRuleSet(ruleSet);        this.ruleSetManager.unregisterRuleSet(ruleSet);        assertEquals("RuleSet not unregistered", 0, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Test the register default ruleset     *     */    public void testRegisterDefaultRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not registrered!", 1, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * Test the registration of a null ruleset     *     */    public void testRegisterNullDefaultRuleSet() {        try {            this.ruleSetManager.registerDefaultRuleSet(null);            fail("Should return an IllegalArgumentException");        } catch (IllegalArgumentException e) {            ; // cool        }    }        /**     * Registering twice the same default rule set results in no addition     *     */    public void testDuplicateRegisterDefault() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        assertEquals("Only one rule set should have been registered", 1, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * Test unregistration default     *     */    public void testUnregisterDefaultRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not registered!", 1, this.ruleSetManager.getDefaultRuleSets().size());        this.ruleSetManager.unregisterDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not unregistered", 0, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * Unregistering a null default ruleset is illegal     *     */    public void testUnregisterNullDefaultRuleSet() {        try {            this.ruleSetManager.unregisterDefaultRuleSet(null);            fail("An IllegalArgumentException should be returned");        } catch (RuntimeException e) {            ; // cool        }    }        /**     * Unregistering twice the same Default rule set has no effect     *     */    public void testDuplicateUnregisterDefault() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        this.ruleSetManager.unregisterDefaultRuleSet(ruleSet);        this.ruleSetManager.unregisterDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not unregistered", 0, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        this.ruleSetManager = new RuleSetManagerImpl();    }}
/* * Created on 7 juin 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.core;import java.util.Iterator;import java.util.Set;import junit.framework.TestCase;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.core.PMDCorePlugin;import net.sourceforge.pmd.core.PluginConstants;/** * Test the PMD Core plugin *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/18 22:29:52  phherlin * Begin refactoring the unit tests for the plugin * Revision 1.2 2005/07/02 14:32:01 phherlin * Implement the RuleSets extension points new tests *  * Revision 1.1 2005/06/15 21:14:56 phherlin Create the project for the Eclipse * plugin unit tests *  *  */public class PMDCorePluginTest extends TestCase {    /**     * Constructor for PMDCorePluginTest.     *      * @param name     */    public PMDCorePluginTest(String name) {        super(name);    }    /**     * Test that the core plugin has been instantiated     *      */    public void testPMDCorePluginNotNull() {        assertNotNull("The Core Plugin has not been instantiated", PMDCorePlugin.getDefault());    }    /**     * Test that we can get a ruleset manager     *      */    public void testRuleSetManagerNotNull() {        assertNotNull("Cannot get a ruleset manager", PMDCorePlugin.getDefault().getRuleSetManager());    }    /**     * Test all the known PMD rulesets has been registered For this test to     * work, no fragement or only the test plugin fragment should be installed.     *      */    public void testStandardPMDRuleSetsRegistered() throws RuleSetNotFoundException {        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();        assertFalse("No registered rulesets!", registeredRuleSets.isEmpty());        RuleSetFactory factory = new RuleSetFactory();        for (int i = 0; i < PluginConstants.PMD_RULESETS.length; i++) {            RuleSet ruleSet = factory.createSingleRuleSet(PluginConstants.PMD_RULESETS[i]);            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", ruleSetRegistered(ruleSet,                    registeredRuleSets));        }    }    /**     * Test the default rulesets has been registered For this test to work, no     * fragement or only the test plugin fragment should be installed.     *      */    public void testDefaultPMDRuleSetsRegistered() throws RuleSetNotFoundException {        Set defaultRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();        assertFalse("No registered default rulesets!", defaultRuleSets.isEmpty());        RuleSetFactory factory = new RuleSetFactory();        for (int i = 0; i < PluginConstants.PMD_RULESETS.length; i++) {            RuleSet ruleSet = factory.createSingleRuleSet(PluginConstants.PMD_RULESETS[i]);            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", ruleSetRegistered(ruleSet,                    defaultRuleSets));        }    }    /**     * test if a ruleset is registered     *      * @param ruleSet     * @param set     * @return true if ok     */    private boolean ruleSetRegistered(RuleSet ruleSet, Set set) {        boolean registered = false;        Iterator i = set.iterator();        while (i.hasNext() && !registered) {            RuleSet registeredRuleSet = (RuleSet) i.next();            registered = registeredRuleSet.getName().equals(ruleSet.getName());        }        return registered;    }}
/* * Created on 14 avr. 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.runtime.cmd;import java.io.InputStream;import junit.framework.TestCase;import name.herlin.command.CommandException;import name.herlin.command.UnsetInputPropertiesException;import net.sourceforge.pmd.eclipse.EclipseUtils;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.runtime.PMDRuntimeConstants;import net.sourceforge.pmd.runtime.cmd.RenderReportCmd;import net.sourceforge.pmd.runtime.cmd.ReviewCodeCmd;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IFolder;import org.eclipse.core.resources.IProject;import org.eclipse.core.resources.IResource;import org.eclipse.core.runtime.CoreException;/** * Test the report rendering *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * Revision 1.2 2005/12/30 16:29:15 phherlin * Implement a new preferences model and review some tests *  * Revision 1.1 2005/06/15 21:14:57 phherlin Create the project for the Eclipse * plugin unit tests *  *  */public class RenderReportCmdTest extends TestCase {    private IProject testProject;    /**     * Default constructor     *      * @param name     */    public RenderReportCmdTest(String name) {        super(name);    }    /**     * Test the basic usage of the report rendering command     *      */    public void testRenderReportCmdBasic() throws CommandException, CoreException {        ReviewCodeCmd reviewCmd = new ReviewCodeCmd();        reviewCmd.addResource(this.testProject);        reviewCmd.performExecute();        RenderReportCmd cmd = new RenderReportCmd();        cmd.setProject(this.testProject);        cmd.setRenderer(new HTMLRenderer());        cmd.setReportName(PMDRuntimeConstants.HTML_REPORT_NAME);        cmd.performExecute();        cmd.join();        IFolder reportFolder = this.testProject.getFolder(PMDRuntimeConstants.REPORT_FOLDER);        assertTrue(reportFolder.exists());        IFile reportFile = reportFolder.getFile(PMDRuntimeConstants.HTML_REPORT_NAME);        assertTrue(reportFile.exists());        this.testProject.deleteMarkers(PMDRuntimeConstants.PMD_MARKER, true, IResource.DEPTH_INFINITE);        if (reportFile.exists()) {            reportFile.delete(true, false, null);        }        if (reportFolder.exists()) {            reportFolder.delete(true, false, null);        }    }    /**     * Test robustness #1     *      * @throws CommandException     */    public void testRenderReportCmdNullArg1() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(new HTMLRenderer());            cmd.setReportName(PMDRuntimeConstants.HTML_REPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #2     *      * @throws CommandException     */    public void testRenderReportCmdNullArg2() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(PMDRuntimeConstants.HTML_REPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #3     *      * @throws CommandException     */    public void testRenderReportCmdNullArg3() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(new HTMLRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #4     *      * @throws CommandException     */    public void testRenderReportCmdNullArg4() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(PMDRuntimeConstants.HTML_REPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #5     *      * @throws CommandException     */    public void testRenderReportCmdNullArg5() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(new HTMLRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #6     *      * @throws CommandException     */    public void testRenderReportCmdNullArg6() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #7     *      * @throws CommandException     */    public void testRenderReportCmdNullArg7() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Create a test source file inside that project        EclipseUtils.createTestSourceFile(this.testProject);        InputStream is = EclipseUtils.getResourceStream(this.testProject, "/Test.java");        assertNotNull("Cannot find the test source file", is);        is.close();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                EclipseUtils.removePMDNature(this.testProject);                // this.testProject.refreshLocal(IResource.DEPTH_INFINITE,                // null);                // Thread.sleep(500);                // this.testProject.delete(true, true, null);                // this.testProject = null;            }        }        super.tearDown();    }}
/* * Created on 14 avr. 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.runtime.cmd;import java.io.InputStream;import junit.framework.TestCase;import name.herlin.command.CommandException;import name.herlin.command.UnsetInputPropertiesException;import net.sourceforge.pmd.cpd.SimpleRenderer;import net.sourceforge.pmd.eclipse.EclipseUtils;import net.sourceforge.pmd.runtime.PMDRuntimeConstants;import net.sourceforge.pmd.runtime.cmd.DetectCutAndPasteCmd;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IFolder;import org.eclipse.core.resources.IProject;import org.eclipse.core.runtime.CoreException;/** * Test the CPD command *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2006/11/16 17:14:34  holobender * Some major changes: * - new CPD View * - changed and refactored ViolationOverview * - some minor changes to dataflowview to work with PMD * * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * Revision 1.1 2005/06/15 21:14:57 * phherlin Create the project for the Eclipse plugin unit tests *  *  */public class DetectCutAndPasteCmdTest extends TestCase {    private IProject testProject;    /**     * Default constructor     *      * @param name     */    public DetectCutAndPasteCmdTest(String name) {        super(name);    }    /**     * Test the basic usage of the cpd command     *      */    public void testDetectCutAndPasteCmdBasic1() throws CommandException, CoreException {        int i;        DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();        cmd.setProject(this.testProject);        cmd.setRenderer(new SimpleRenderer());        cmd.setReportName(PMDRuntimeConstants.SIMPLE_CPDREPORT_NAME);        cmd.setCreateReport(true);        cmd.setLanguage("java");        cmd.setMinTileSize(10);        cmd.performExecute();        cmd.join();        IFolder reportFolder = this.testProject.getFolder(PMDRuntimeConstants.REPORT_FOLDER);        assertTrue(reportFolder.exists());        IFile reportFile = reportFolder.getFile(PMDRuntimeConstants.SIMPLE_CPDREPORT_NAME);        assertTrue(reportFile.exists());        if (reportFile.exists()) {            reportFile.delete(true, false, null);        }        if (reportFolder.exists()) {            reportFolder.delete(true, false, null);        }    }        /**     * Test the basic usage of the cpd command     *      */    public void testDetectCutAndPasteCmdBasic2() throws CommandException, CoreException {        DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();        cmd.setProject(this.testProject);        cmd.setCreateReport(false);        cmd.setLanguage("java");        cmd.setMinTileSize(10);        cmd.performExecute();        cmd.join();        IFolder reportFolder = this.testProject.getFolder(PMDRuntimeConstants.REPORT_FOLDER);        assertFalse(reportFolder.exists());        IFile reportFile = reportFolder.getFile(PMDRuntimeConstants.SIMPLE_CPDREPORT_NAME);        assertFalse(reportFile.exists());    }        /**     * Test robustness #1     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg1() throws CommandException {                try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(new SimpleRenderer());            cmd.setReportName(PMDRuntimeConstants.SIMPLE_CPDREPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #2     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg2() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(PMDRuntimeConstants.SIMPLE_CPDREPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #3     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg3() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(new SimpleRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #4     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg4() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(PMDRuntimeConstants.SIMPLE_CPDREPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #5     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg5() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(new SimpleRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #6     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg6() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #7     *      * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg7() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Create a test source file inside that project        EclipseUtils.createTestSourceFile(this.testProject);        InputStream is = EclipseUtils.getResourceStream(this.testProject, "/Test.java");        assertNotNull("Cannot find the test source file", is);        is.close();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                EclipseUtils.removePMDNature(this.testProject);                // this.testProject.refreshLocal(IResource.DEPTH_INFINITE,                // null);                // Thread.sleep(500);                // this.testProject.delete(true, true, null);                // this.testProject = null;            }        }        super.tearDown();    }}
/* * Created on 12 avr. 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.runtime.cmd;import java.io.InputStream;import java.util.Map;import junit.framework.TestCase;import name.herlin.command.CommandException;import name.herlin.command.UnsetInputPropertiesException;import net.sourceforge.pmd.eclipse.EclipseUtils;import net.sourceforge.pmd.runtime.cmd.ReviewCodeCmd;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IProject;import org.eclipse.core.runtime.CoreException;/** * This tests the PMD Processor command *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * * Revision 1.3  2006/01/17 21:26:24  phherlin * Ignore exceptions occuring inside the teardown operation * * Revision 1.2  2005/12/30 16:29:15  phherlin * Implement a new preferences model and review some tests * * Revision 1.1  2005/06/15 21:14:57  phherlin * Create the project for the Eclipse plugin unit tests * *   */public class ReviewCmdTest extends TestCase {    private IProject testProject;    /**     * Test case constructor     *      * @param name     *            of the test case     */    public ReviewCmdTest(String name) {        super(name);    }    /**     * Test the basic usage of the processor command     *       */    public void testReviewCmdBasic() throws CommandException, CoreException {        ReviewCodeCmd cmd = new ReviewCodeCmd();        cmd.addResource(this.testProject);        cmd.performExecute();        cmd.join();        Map markers = cmd.getMarkers();                // We do not test PMD, only a non-empty report is enough        assertNotNull(markers);        assertTrue("Report size = " + markers.size(), markers.size() > 0);    }    /**     * The ReviewCodeCmd must also work on a ResourceDelta      * @throws CommandException     */    public void testReviewCmdDelta() throws CommandException {        // Don't know how to test that yet        // How to instantiate a ResourceDelta ?        // Let's comment for now    }        /**     * Normally a null resource and a null resource delta is not acceptable.     * @throws CommandException     */    public void testReviewCmdNullResource() throws CommandException {        try {            ReviewCodeCmd cmd = new ReviewCodeCmd();            cmd.addResource(null);            cmd.setResourceDelta(null);            cmd.performExecute();            fail("An Exception must be thrown");        } catch (UnsetInputPropertiesException e) {            fail("An IllegalArgumentException must have been thrown before");        } catch (IllegalArgumentException e) {            ; // cool, success        }    }        /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Create a test source file inside that project        IFile testFile = EclipseUtils.createTestSourceFile(this.testProject);        InputStream is = EclipseUtils.getResourceStream(this.testProject, "/Test.java");        assertNotNull("Cannot find the test source file", is);        is.close();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        try {            if (this.testProject != null) {                if (this.testProject.exists() && this.testProject.isAccessible()) {                    EclipseUtils.removePMDNature(this.testProject);//                this.testProject.refreshLocal(IResource.DEPTH_INFINITE, null);//                Thread.sleep(500);//                this.testProject.delete(true, true, null);//                this.testProject = null;                }            }            super.tearDown();        } catch (Exception e) {            System.out.println("Exception " + e.getClass().getName() + " when tearing down. Ignored.");        }    }}
/* * Created on 6 fevr. 2005 * * Copyright (c) 2004, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.runtime.properties;import java.util.Iterator;import java.util.Set;import junit.framework.TestCase;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.core.PMDCorePlugin;import net.sourceforge.pmd.eclipse.EclipseUtils;import net.sourceforge.pmd.runtime.PMDRuntimePlugin;import net.sourceforge.pmd.runtime.builder.PMDNature;import net.sourceforge.pmd.runtime.preferences.IPreferencesManager;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IProject;import org.eclipse.core.runtime.CoreException;import org.eclipse.ui.IWorkingSet;/** * Test the project properties model. *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.3  2006/10/08 22:19:16  phherlin * Fix last Java warnings * * Revision 1.2  2006/10/06 16:42:03  phherlin * Continue refactoring of rullesets management * * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * Revision 1.4 2005/12/30 16:29:16 * phherlin Implement a new preferences model and review some tests *  * Revision 1.3 2005/07/02 14:31:11 phherlin Fixing equals assertion to test on * rules collection instead *  * Revision 1.2 2005/07/01 00:06:38 phherlin Refactoring and writing more tests *  * Revision 1.1 2005/06/15 21:14:56 phherlin Create the project for the Eclipse * plugin unit tests *  *  */public class ProjectPropertiesModelTest extends TestCase {    private IProject testProject;    private RuleSet initialPluginRuleSet;    /**     * Test case constructor     *      * @param name of the test case     */    public ProjectPropertiesModelTest(String name) {        super(name);    }    /**     * A property should be used to know if PMD is enabled for a project. Set to     * TRUE     *      */    public void testPmdEnabledTRUE() throws CoreException, PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        model.setPmdEnabled(true);        model.sync();        assertTrue("Cannot activate PMD for that project", this.testProject.hasNature(PMDNature.PMD_NATURE));        assertTrue("PMD Property not set!", model.isPmdEnabled());    }    /**     * A property should be used to know id PMD is enabled for a project. Set to     * FALSE.     *      */    public void testPmdEnabledFALSE() throws PropertiesException, CoreException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        model.setPmdEnabled(true);        model.sync();        assertTrue("Cannot activate PMD for that project", this.testProject.hasNature(PMDNature.PMD_NATURE));        model.setPmdEnabled(false);        model.sync();        assertFalse("Cannot desactivate PMD for that project", this.testProject.hasNature(PMDNature.PMD_NATURE));        assertFalse("PMD Property not reset!", model.isPmdEnabled());    }    /**     * A brand new project should be affected the Plugin ruleset in the global     * ruleset.     *      */    public void testProjectRuleSet() throws PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        IPreferencesManager pmgr = PMDRuntimePlugin.getDefault().getPreferencesManager();        assertSame("A new project is not set the plugin ruleset", model.getProjectRuleSet(), pmgr.getRuleSet());    }    /**     * Set another ruleset.     */    public void testProjectRuleSet1() throws PropertiesException, RuleSetNotFoundException, CoreException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSetFactory factory = new RuleSetFactory();        // use the basic ruleset because it should be included in the plugin        // ruleset.        RuleSet basicRuleSet = factory.createSingleRuleSet("rulesets/basic.xml");        // First set the project ruleset        model.setProjectRuleSet(basicRuleSet);        model.sync();        // Test the ruleset we set is equal to the ruleset we queried        RuleSet projectRuleSet = model.getProjectRuleSet();        assertNotNull("Project ruleset has not been set", projectRuleSet);        assertTrue("The project ruleset is not the basic ruleset", EclipseUtils.assertRuleSetEquals(basicRuleSet.getRules(),                projectRuleSet.getRules()));    }    /**     * When rules are removed from the plugin preferences, these rules should     * also be removed from the project     * euh... ben en fait non. annul.     */    public void testProjectRuleSet2() throws PropertiesException, RuleSetNotFoundException, CoreException {/*        // First ensure that the plugin initial ruleset is equal to the project        // ruleset        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", this.initialPluginRuleSet.getRules(), projectRuleSet                .getRules());        // use the basic ruleset and set it at the only plugin ruleset        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createSingleRuleSet("rulesets/basic.xml");        IPreferencesManager pmgr = PMDRuntimePlugin.getDefault().getPreferencesManager();        pmgr.setRuleSet(basicRuleSet);        projectRuleSet = model.getProjectRuleSet();        dumpRuleSet(basicRuleSet);        dumpRuleSet(projectRuleSet);        assertEquals("The project ruleset is not equal to the plugin ruleset", basicRuleSet.getRules(), projectRuleSet.getRules());*/        }    /**     * When rules are added to the plugin preferences, these rules should also     * be added to the project     */    public void testProjectRuleSet3() throws PropertiesException, RuleSetNotFoundException, CoreException {        // First ensure that the plugin initial ruleset is equal to the project        // ruleset        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", this.initialPluginRuleSet.getRules(), projectRuleSet.getRules());        // 2. add a rule to the plugin rule set        Rule myRule = new AbstractRule() {            public String getName() {                return "MyRule";            }        };        RuleSet newRuleSet = new RuleSet();        newRuleSet.setName("foo");        newRuleSet.addRuleSet(this.initialPluginRuleSet);        newRuleSet.addRule(myRule);        PMDRuntimePlugin.getDefault().getPreferencesManager().setRuleSet(newRuleSet);        // Test that the project rule set should still be the same as the plugin        // rule set        model = mgr.loadProjectProperties(this.testProject);        projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", PMDRuntimePlugin.getDefault()                .getPreferencesManager().getRuleSet().getRules(), projectRuleSet.getRules());    }    /**     * Bug: when a user deselect a project rule it is not saved     */    public void testBug() throws PropertiesException, RuleSetNotFoundException, CoreException {        RuleSetFactory factory = new RuleSetFactory();        // First ensure that the plugin initial ruleset is equal to the project        // ruleset        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", this.initialPluginRuleSet.getRules(), projectRuleSet.getRules());        // 2. remove the first rule (keep its name for assertion)        RuleSet newRuleSet = new RuleSet();        newRuleSet.addRuleSet(projectRuleSet);        Iterator i = newRuleSet.getRules().iterator();        Rule removedRule = (Rule) i.next();        i.remove();        model.setProjectRuleSet(newRuleSet);        model.sync();        // 3. test the rule has correctly been removed        projectRuleSet = model.getProjectRuleSet();        assertNull("The rule has not been removed!", projectRuleSet.getRuleByName(removedRule.getName()));    }    /**     * It should not be possible to set to null a project ruleset     *      */    public void testProjectRuleSetNull() throws PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        try {            model.setProjectRuleSet(null);            fail("A ModelException must be raised when setting a project ruleset to null");        } catch (PropertiesException e) {            // OK that's correct        }    }    /**     * A project may have its ruleset stored in the project own directory. Test     * set to TRUE.     */    public void testRuleSetStoredInProjectTRUE() throws PropertiesException, RuleSetNotFoundException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createSingleRuleSet("rulesets/basic.xml");        model.setPmdEnabled(true);        model.setRuleSetStoredInProject(false);        model.setProjectWorkingSet(null);        model.setProjectRuleSet(basicRuleSet);        model.sync();        model.createDefaultRuleSetFile();        model.setRuleSetStoredInProject(true);        model.sync();        boolean b = model.isRuleSetStoredInProject();        IFile file = this.testProject.getFile(".ruleset");        RuleSet projectRuleSet = factory.createSingleRuleSet(file.getLocation().toOSString());        assertTrue("the ruleset should be stored in the project", b);        assertEquals("The project ruleset must be equals to the one found in the project", model.getProjectRuleSet(),                projectRuleSet);    }    /**     * A project may have its ruleset stored in the project own directory. Test     * set to FALSE.     *      */    public void testRuleSetStoredInProjectFALSE() throws PropertiesException, RuleSetNotFoundException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createSingleRuleSet("rulesets/basic.xml");        model.setPmdEnabled(true);        model.setRuleSetStoredInProject(false);        model.setProjectWorkingSet(null);        model.setProjectRuleSet(basicRuleSet);        model.sync();        model.createDefaultRuleSetFile();        model.setRuleSetStoredInProject(true);        model.sync();        model.setRuleSetStoredInProject(false);        model.sync();        boolean b = model.isRuleSetStoredInProject();        assertFalse("the ruleset should'nt be stored in the project", b);    }    /**     * A project may work only on a subset of files defined by a working set     *      */    public void testProjectWorkingSetNull() throws PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        model.setProjectWorkingSet(null);        IWorkingSet w = model.getProjectWorkingSet();        assertNull("The project should not have a working set defined", w);    }    /**     * A project may know if it should be rebuilt or not     *      */    public void testRebuild1() throws PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        model.setPmdEnabled(false);        model.setProjectWorkingSet(null);        model.setRuleSetStoredInProject(false);        model.setNeedRebuild(false);        assertFalse(model.isNeedRebuild());    }    /**     * A project may know if it should be rebuilt or not     *      */    public void testRebuild2() throws PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        model.setPmdEnabled(true);        assertTrue(model.isNeedRebuild());    }    /**     * A project may know if it should be rebuilt or not     *      */    public void testRebuild3() throws PropertiesException {        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        model.setPmdEnabled(true);        RuleSet pmdRuleSet = PMDRuntimePlugin.getDefault().getPreferencesManager().getRuleSet();        RuleSet fooRuleSet = new RuleSet();        Rule rule1 = pmdRuleSet.getRuleByName("EmptyCatchBlock");        fooRuleSet.addRule(rule1);        model.setProjectRuleSet(fooRuleSet);        assertTrue(model.isNeedRebuild());    }    /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Keep the plugin ruleset        this.initialPluginRuleSet = PMDRuntimePlugin.getDefault().getPreferencesManager().getRuleSet();        this.initialPluginRuleSet.getRules().clear();        Set defaultRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getDefaultRuleSets();        for (Iterator i = defaultRuleSets.iterator(); i.hasNext();) {            this.initialPluginRuleSet.addRuleSet((RuleSet) i.next());        }    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        // 1. Delete the test project        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                this.testProject.delete(true, true, null);                this.testProject = null;            }        }        // 2. Restore the plugin initial rule set        PMDRuntimePlugin.getDefault().getPreferencesManager().setRuleSet(this.initialPluginRuleSet);        super.tearDown();    }    private void dumpRuleSet(RuleSet ruleSet) {        System.out.println("Dumping rule set:" + ruleSet.getName());        Iterator i = ruleSet.getRules().iterator();        while (i.hasNext()) {            Rule rule = (Rule) i.next();            System.out.println(rule.getName());        }        System.out.println();    }    }
package net.sourceforge.pmd.ui.properties;import java.util.Iterator;import junit.framework.TestCase;import name.herlin.command.CommandException;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.eclipse.EclipseUtils;import net.sourceforge.pmd.runtime.PMDRuntimePlugin;import net.sourceforge.pmd.runtime.properties.IProjectProperties;import net.sourceforge.pmd.runtime.properties.IProjectPropertiesManager;import net.sourceforge.pmd.runtime.properties.PropertiesException;import net.sourceforge.pmd.ui.properties.UpdateProjectPropertiesCmd;import org.eclipse.core.resources.IProject;public class UpdateProjectPropertiesCmdTest extends TestCase {    private IProject testProject;    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());    }    protected void tearDown() throws Exception {        try {            // 1. Delete the test project            if (this.testProject != null) {                if (this.testProject.exists() && this.testProject.isAccessible()) {                    this.testProject.delete(true, true, null);                    this.testProject = null;                }            }            super.tearDown();        } catch (Exception e) {            System.out.println("Exception " + e.getClass().getName() + " when tearing down. Ignored.");        }    }    /**     * Bug: when a user deselect a project rule it is not saved     */    public void testBug() throws CommandException, PropertiesException {        RuleSetFactory factory = new RuleSetFactory();        // First ensure that the plugin initial ruleset is equal to the project        // ruleset        IProjectPropertiesManager mgr = PMDRuntimePlugin.getDefault().getPropertiesManager();        IProjectProperties model = mgr.loadProjectProperties(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", PMDRuntimePlugin.getDefault()                .getPreferencesManager().getRuleSet().getRules(), projectRuleSet.getRules());        // 2. remove the first rule (keep its name for assertion)        RuleSet newRuleSet = new RuleSet();        newRuleSet.addRuleSet(projectRuleSet);        Iterator i = newRuleSet.getRules().iterator();        Rule removedRule = (Rule) i.next();        i.remove();        UpdateProjectPropertiesCmd cmd = new UpdateProjectPropertiesCmd();        cmd.setPmdEnabled(true);        cmd.setProject(this.testProject);        cmd.setProjectRuleSet(newRuleSet);        cmd.setProjectWorkingSet(null);        cmd.setRuleSetStoredInProject(false);        cmd.execute();        // 3. test the rule has correctly been removed        projectRuleSet = model.getProjectRuleSet();        assertNull("The rule has not been removed!", projectRuleSet.getRuleByName(removedRule.getName()));    }}
/* * Created on 6 fvr. 2005 * * Copyright (c) 2004, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package net.sourceforge.pmd.eclipse;import java.io.Reader;import java.io.StringReader;import java.util.Iterator;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.SourceType;import net.sourceforge.pmd.core.PluginConstants;/** * Test if PMD can be run correctly *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2006/06/18 22:29:51  phherlin * Begin refactoring the unit tests for the plugin * Revision 1.2 2005/07/01 00:06:38 phherlin * Refactoring and writing more tests *  * Revision 1.1 2005/06/15 21:14:57 phherlin Create the project for the Eclipse * plugin unit tests *  *  */public class BasicPMDTest extends TestCase {    /**     * Test case constructor     *      * @param name of the test case     */    public BasicPMDTest(String name) {        super(name);    }    /**     * One first thing the plugin must be able to do is to run PMD     *      */    public void testRunPmdJdk13() {        try {            PMD pmd = new PMD();            pmd.setJavaVersion(SourceType.JAVA_13);            String sourceCode = "public class Foo {\n public void foo() {\nreturn;\n}}";            Reader input = new StringReader(sourceCode);            RuleContext context = new RuleContext();            context.setSourceCodeFilename("foo.java");            context.setReport(new Report());            RuleSet basicRuleSet = new RuleSetFactory().createSingleRuleSet("rulesets/basic.xml");            pmd.processFile(input, basicRuleSet, context);            Iterator iter = context.getReport().iterator();            assertTrue("There should be at least one violation", iter.hasNext());            RuleViolation violation = (RuleViolation) iter.next();            assertEquals(violation.getRule().getName(), "UnnecessaryReturn");            assertEquals(3, violation.getBeginLine());        } catch (RuleSetNotFoundException e) {            e.printStackTrace();            fail();        } catch (PMDException e) {            e.printStackTrace();            fail();        }    }    /**     * Let see with Java 1.4     *      */    public void testRunPmdJdk14() {        try {            PMD pmd = new PMD();            pmd.setJavaVersion(SourceType.JAVA_14);            String sourceCode = "public class Foo {\n public void foo() {\nreturn;\n}}";            Reader input = new StringReader(sourceCode);            RuleContext context = new RuleContext();            context.setSourceCodeFilename("foo.java");            context.setReport(new Report());            RuleSet basicRuleSet = new RuleSetFactory().createSingleRuleSet("rulesets/basic.xml");            pmd.processFile(input, basicRuleSet, context);            Iterator iter = context.getReport().iterator();            assertTrue("There should be at least one violation", iter.hasNext());            RuleViolation violation = (RuleViolation) iter.next();            assertEquals(violation.getRule().getName(), "UnnecessaryReturn");            assertEquals(3, violation.getBeginLine());        } catch (RuleSetNotFoundException e) {            e.printStackTrace();            fail();        } catch (PMDException e) {            e.printStackTrace();            fail();        }    }    /**     * Let see with Java 1.5     *      */    public void testRunPmdJdk15() {        try {            PMD pmd = new PMD();            pmd.setJavaVersion(SourceType.JAVA_15);            String sourceCode = "public class Foo {\n public void foo() {\nreturn;\n}}";            Reader input = new StringReader(sourceCode);            RuleContext context = new RuleContext();            context.setSourceCodeFilename("foo.java");            context.setReport(new Report());            RuleSet basicRuleSet = new RuleSetFactory().createSingleRuleSet("rulesets/basic.xml");            pmd.processFile(input, basicRuleSet, context);            Iterator iter = context.getReport().iterator();            assertTrue("There should be at least one violation", iter.hasNext());            RuleViolation violation = (RuleViolation) iter.next();            assertEquals(violation.getRule().getName(), "UnnecessaryReturn");            assertEquals(3, violation.getBeginLine());        } catch (RuleSetNotFoundException e) {            e.printStackTrace();            fail();        } catch (PMDException e) {            e.printStackTrace();            fail();        }    }    /**     * Try to load all the plugin known rulesets     *      */    public void testDefaulltRuleSets() {        RuleSetFactory factory = new RuleSetFactory();        String allRuleSets[] = PluginConstants.PMD_RULESETS;        for (int i = 0; i < allRuleSets.length; i++) {            try {                RuleSet ruleSet = factory.createSingleRuleSet(allRuleSets[i]);            } catch (RuleSetNotFoundException e) {                e.printStackTrace();                fail("unable to load ruleset " + allRuleSets[i]);            }        }    }}