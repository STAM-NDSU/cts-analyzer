/* *  */package test.net.sourceforge.pmd.jdbc;import com.mockobjects.sql.MockConnection;import com.mockobjects.sql.MockDriver;import com.mockobjects.sql.MockPreparedStatement;import com.mockobjects.sql.MockSingleRowResultSet;import junit.framework.TestCase;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.jdbc.JDBCReportListener;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.MockRule;import java.sql.Date;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JDBCReportListenerTest extends TestCase {    private MockDriver driver = null;    private MockPreparedStatement violInsert = null;    private MockPreparedStatement metInsert = null;    public void setUp() {driver = new MockDriver();try {    DriverManager.registerDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    public void tearDown() {try {    DriverManager.deregisterDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    private class MockInsertPMDRunsextends MockPreparedStatement    {private int runId = 0;public MockInsertPMDRuns( int projectId, int runId ) {    //    setExpectedQueryString("INSERT INTO PMD_RUNS (PROJECT_ID, RUN_DATE) VALUES (?, ?)");    addExpectedSetParameter( 1, projectId );    this.runId = runId;}public void setDate( int position, Date dateTime ) {    assertEquals("Date in wrong position.", 2, position);    assertTrue( "Didn't add the current date.",dateTime.getTime() > System.currentTimeMillis() - 5000);    assertTrue( "Set a future date.",dateTime.getTime() < System.currentTimeMillis() + 5000);}public ResultSet getGeneratedKeys() {    MockSingleRowResultSet RC = new MockSingleRowResultSet();    RC.addExpectedIndexedValues( new Object[] { new Integer(runId) });    return RC;}    }    private class MockPMDConxextends MockConnection    {public MockPMDConx( int projectId, int runId ) {    super();    setupAddPreparedStatement( new MockInsertPMDRuns( projectId, runId ) );    violInsert = new MockPreparedStatement();    setupAddPreparedStatement( violInsert );        metInsert = new MockPreparedStatement();    setupAddPreparedStatement( metInsert );}public PreparedStatement prepareStatement( String sql, int returnKeys )    throws SQLException{    assertEquals( "Not set to return generated keys.",   returnKeys, Statement.RETURN_GENERATED_KEYS );    return prepareStatement( sql );}    }    public JDBCReportListener getIUT(int projectId) throws SQLException    {return new JDBCReportListener( "jdbc:mock:getIUT",       "iut_user", "iut_pw", projectId );    }    public void testLongConstructor() throws Throwable {MockConnection conx = new MockPMDConx(1, 5);driver.setupConnect( conx );new JDBCReportListener("jdbc:mock:testLongConstructor", "tlc_user", "tlc_pw", 1);    }    public void testPropConstructor() throws Throwable {MockConnection conx = new MockPMDConx(2, 8);driver.setupConnect( conx );Properties props = new Properties();props.put( JDBCReportListener.JDBC_URL, "jdbc:mock:testPropConstructor" );props.put( JDBCReportListener.JDBC_USER, "tpc_user" );props.put( JDBCReportListener.JDBC_PASSWORD, "tpc_pw" );props.put( JDBCReportListener.JDBC_PROJECTID, "2");new JDBCReportListener(props);    }    public void testSingleViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );JDBCReportListener IUT = getIUT( 16 );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));    }    public void testMultiViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 16 );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1a" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileAa" );      // File NameviolInsert.addExpectedSetParameter( 4, 2561 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageBa" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classCa" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msga" );ctx = new RuleContext();ctx.setSourceCodeFilename( "fileAa" );ctx.setPackageName( "packageBa" );ctx.setClassName( "classCa" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1a", "Descriptiona", "msga" ),    2561, ctx ));    }    public void testSingleMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "single" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));JDBCReportListener IUT = getIUT( 18 );IUT.metricAdded( new Metric("single", 5, 30, 1.0, 6.0, 3.0, 1.5) );    }    public void testMultiMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 18 );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "first" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));IUT.metricAdded( new Metric("first", 5, 30, 1.0, 6.0, 3.0, 1.5) );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "second" );metInsert.addExpectedSetParameter( 3, new Double( 1.01 ));metInsert.addExpectedSetParameter( 4, new Double( 6.01 ));metInsert.addExpectedSetParameter( 5, new Double( 3.01 ));metInsert.addExpectedSetParameter( 6, new Double( 1.51 ));IUT.metricAdded( new Metric("second", 7, 32.5, 1.01, 6.01, 3.01, 1.51) );    }}
package net.sourceforge.pmd.gel;public class Test { private int y;}
package test.net.sourceforge.pmd.util;import junit.framework.TestCase;import net.sourceforge.pmd.util.Applier;import net.sourceforge.pmd.util.UnaryFunction;import java.util.ArrayList;import java.util.List;public class ApplierTest extends TestCase {    private static class MyFunction implements UnaryFunction {        private boolean gotCallback;        public void applyTo(Object o) {            this.gotCallback = true;        }        public boolean gotCallback() {            return this.gotCallback;        }    }    public void testSimple() {        MyFunction f = new MyFunction();        List l = new ArrayList();        l.add(new Object());        Applier.apply(f, l.iterator());        assertTrue(f.gotCallback());    }}
package test.net.sourceforge.pmd.util;import junit.framework.TestCase;import net.sourceforge.pmd.util.StringUtil;public class StringUtilTest extends TestCase {    public void testReplaceWithOneChar() {        assertEquals("faa", StringUtil.replaceString("foo", 'o', "a"));    }    public void testReplaceWithMultipleChars() {        assertEquals("faaaa", StringUtil.replaceString("foo", 'o', "aa"));    }}
package test.net.sourceforge.pmd.stat;import junit.framework.AssertionFailedError;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.stat.DataPoint;import net.sourceforge.pmd.stat.Metric;import net.sourceforge.pmd.stat.StatisticalRule;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Random;/** * This class tests the Statistical Rules in PMD. * * The idea is, that we fill up 999 datapoints into * the Stat Rule, and then throw random parameters * at it. * * The three parameters which are checked are: * sigma - # Sigmas over the mean. * topscore - Only the top 5 or so items. * minimum - Only things of score 10 or better * * When more than one parameter is lumped together, then * we expect the one which would return the fewest to * determine what gets sent back. * * So, we throw each collection of parameters, where each * one is a different order into the system.  We check the * results off of what the smallest value should be. * * If you are going to work with StatisticalRule any, please * bump the "NUM_TESTS" number up to something like 128.  That * way you are more likely to identify problems.  It is set low * now to make building and running tests easier (when we aren't * touching the file.) * * Note also, that when verifying the Sigma, I wasn't quite able * to determine how many results it would return (it would vary * from -2 to 2 of what I expected.)  That is what the delta * parameter on the verify method takes.  If you can figure it * out exactly, (without stealing code from the StatRule) then * feel free to change it and tighten the deltas. */public class StatisticalRuleTest extends TestCase {    private static final int POINTS = 100;    private DataPoint points[] = new DataPoint[POINTS];    private MockStatisticalRule IUT = null;    private String testName = null;    private Random random = new Random();    public static final double MAX_MINIMUM = POINTS;    public static final double NO_MINIMUM = -1.0;    public static final double MAX_SIGMA = 5.0;    public static final double NO_SIGMA = -1.0;    public static final int MIN_TOPSCORE = 0;    public static final int NO_TOPSCORE = -1;    public static final double MEAN = 49.5;    public static final double SIGMA = 28.86750;    public static final int NUM_TESTS = 1;    public static final double DELTA = 0.005;    public StatisticalRuleTest(String name) {        super(name);        this.testName = name;    }    public void setUp() {        IUT = new MockStatisticalRule();        if (testName.endsWith("0")) {            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                points[i].setLineNumber(i);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else if (testName.endsWith("1")) {            for (int i = POINTS-1; i >= 0; i--) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                points[i].setLineNumber(i);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else {            List lPoints = new ArrayList();            for (int i = 0; i < POINTS; i++) {                DataPoint point = new DataPoint();                point.setScore(1.0 * i);                point.setLineNumber(i);                point.setMessage("DataPoint[" + Integer.toString(i) + "]");                lPoints.add(point);            }            Collections.shuffle(lPoints);            for (int i = 0; i < POINTS; i++) {                IUT.addDataPoint((DataPoint) lPoints.get(i));            }        }    }    /**     * This test verifies that the Stat rule creates a Metric,     * with the proper values.     */    public void testMetrics() throws Throwable {        Report report = makeReport(IUT);        Iterator metrics = report.metrics();        assertTrue(metrics.hasNext());        Object o = metrics.next();        assertTrue(o instanceof Metric);        Metric m = (Metric) o;        assertEquals("test.net.sourceforge.pmd.stat.MockStatisticalRule", m.getMetricName());        assertEquals(0.0, m.getLowValue(), 0.05);        assertEquals(POINTS -1.0, m.getHighValue(), 0.05);        assertEquals(MEAN, m.getAverage(), 0.05);        assertEquals(SIGMA, m.getStandardDeviation(), 0.05);    }    /**     * This returns a Random value for Sigma which will     * return some values.     */    public double randomSigma() {        return random.nextDouble() * 1.0;    }    /**     * This returns a Random value for Sigma which value     * is greater than the parameter.     */    public double randomSigma(int minimum) {        double minSigma = ((POINTS -1 - minimum) - MEAN) / SIGMA;        if ((minSigma <= 0) || (minSigma > 2))            return randomSigma();        return minSigma + (random.nextDouble() * (2 - minSigma));    }    /**     * This returns the expected number of results when     * the Sigma rating is the smallest.     */    public int expectedSigma(double sigma) {        long expectedMin = Math.round(MEAN + (sigma * SIGMA));        if (((POINTS -1) - expectedMin) < 0)            return 0;        return (POINTS -1) - (int) expectedMin;    }    /**     * This generates a random minimum value for testing.     */    public double randomMinimum() {        return random.nextDouble() * (POINTS -1);    }    /**     * This generates a random minimum value for which fewer     * results would be returned.     */    public double randomMinimum(int minimum) {        double diffTarget = 1.0 * (POINTS -1 - minimum);        return (random.nextDouble() * minimum) + diffTarget;    }    /**     * This returns the expected number of reports.     *     * If the Minimum comes in at 521.569 then we expect     * 522, 523, ... 999 will pass.     */    public int expectedMinimum(double minimum) {        Double d = new Double(minimum);        return POINTS -1 - d.intValue();    }    public void testExpectedMinimum() {        for (int i = 0; i < POINTS -1; i++) {            assertEquals("Integer Min", POINTS -1 - i, expectedMinimum(i * 1.0));            assertEquals("Double Min", POINTS -1 - i, expectedMinimum((i * 1.0) + 0.5));        }    }    /**     * This returns a random value for Top Score.     */    public int randomTopScore() {        return random.nextInt(POINTS -1);    }    /**     * This will return a random value for the Top Score     * which will return more than the minimum provided.     */    public int randomTopScore(double target) {        if (target < 0)            return 0;        return random.nextInt((new Double(target)).intValue());    }    /**     * This will return the expected number of results     * with the given Top Score.     */    public int expectedTopScore(int target) {        return target;    }    // Test Single Datapoint    public void testSingleDatapoint() {        StatisticalRule IUT = new MockStatisticalRule();        DataPoint point = new DataPoint();        point.setScore(POINTS + 1.0);        point.setLineNumber(POINTS + 1);        point.setMessage("SingleDataPoint");        IUT.addProperty("minimum", Integer.toString(POINTS));        IUT.addDataPoint(point);        Report report = makeReport(IUT);        assertEquals("Expecting only one result.", 1, report.size());    }    // Okay, we have three properties we need to    // test in Combination:    //  S = Sigma    //  T = Top Score    //  M = Minimum    //    // They are listed in decreasing order of what    // to expect.    //    // Thus testSM() should have the Sigma less than    // the minimum, so we expect the Minimum # of results.    //    public void testS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, NO_TOPSCORE, 0, 2);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            verifyResults(sigma, -1.0, -1, expectedSigma(sigma), 2);        }    }    public void testS1() throws Throwable {        testS();    }    public void testS2() throws Throwable {        testS();    }    public void testS3() throws Throwable {        testS();    }    public void testS4() throws Throwable {        testS();    }    public void testS5() throws Throwable {        testS();    }    public void testT() throws Throwable {        verifyResults(NO_SIGMA, NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            verifyResults(-1.0, -1.0, topScore, expectedTopScore(topScore), 0);        }    }    public void testT1() throws Throwable {        testT();    }    public void testT2() throws Throwable {        testT();    }    public void testT3() throws Throwable {        testT();    }    public void testT4() throws Throwable {        testT();    }    public void testT5() throws Throwable {        testT();    }    public void testM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            verifyResults(-1.0, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testM1() throws Throwable {        testM();    }    public void testM2() throws Throwable {        testM();    }    public void testM3() throws Throwable {        testM();    }    public void testM4() throws Throwable {        testM();    }    public void testM5() throws Throwable {        testM();    }    public void testST() throws Throwable {        verifyResults(randomSigma(), NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            verifyResults(sigma, NO_MINIMUM, topScore, expectedTopScore(topScore), 0);        }    }    public void testST1() throws Throwable {        testST();    }    public void testST2() throws Throwable {        testST();    }    public void testST3() throws Throwable {        testST();    }    public void testST4() throws Throwable {        testST();    }    public void testST5() throws Throwable {        testST();    }    public void testTS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            verifyResults(sigma, -1.0, topScore, expectedSigma(sigma), 2);        }    }    public void testTS1() throws Throwable {        testTS();    }    public void testTS2() throws Throwable {        testTS();    }    public void testTS3() throws Throwable {        testTS();    }    public void testTS4() throws Throwable {        testTS();    }    public void testTS5() throws Throwable {        testTS();    }    public void testSM() throws Throwable {        verifyResults(randomSigma(), MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testSM1() throws Throwable {        testSM();    }    public void testSM2() throws Throwable {        testSM();    }    public void testSM3() throws Throwable {        testSM();    }    public void testSM4() throws Throwable {        testSM();    }    public void testSM5() throws Throwable {        testSM();    }    public void testMS() throws Throwable {        verifyResults(MAX_SIGMA, randomMinimum(), NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, -1, expectedSigma(sigma), 2);        }    }    public void testMS1() throws Throwable {        testMS();    }    public void testMS2() throws Throwable {        testMS();    }    public void testMS3() throws Throwable {        testMS();    }    public void testMS4() throws Throwable {        testMS();    }    public void testMS5() throws Throwable {        testMS();    }    public void testTM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(NO_SIGMA, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTM1() throws Throwable {        testTM();    }    public void testTM2() throws Throwable {        testTM();    }    public void testTM3() throws Throwable {        testTM();    }    public void testTM4() throws Throwable {        testTM();    }    public void testTM5() throws Throwable {        testTM();    }    public void testMT() throws Throwable {        verifyResults(NO_SIGMA, randomMinimum(), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(NO_SIGMA, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testMT1() throws Throwable {        testMT();    }    public void testMT2() throws Throwable {        testMT();    }    public void testMT3() throws Throwable {        testMT();    }    public void testMT4() throws Throwable {        testMT();    }    public void testMT5() throws Throwable {        testMT();    }    public void testSTM() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, MAX_MINIMUM, randomTopScore(expectedSigma(sigma)), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testSTM1() throws Throwable {        testSTM();    }    public void testSTM2() throws Throwable {        testSTM();    }    public void testSTM3() throws Throwable {        testSTM();    }    public void testSTM4() throws Throwable {        testSTM();    }    public void testSTM5() throws Throwable {        testSTM();    }    public void testSMT() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, randomMinimum(expectedSigma(sigma)), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testSMT1() throws Throwable {        testSMT();    }    public void testSMT2() throws Throwable {        testSMT();    }    public void testSMT3() throws Throwable {        testSMT();    }    public void testSMT4() throws Throwable {        testSMT();    }    public void testSMT5() throws Throwable {        testSMT();    }    public void testTSM() throws Throwable {        int topScore = randomTopScore();        verifyResults(randomSigma(expectedTopScore(topScore)), MAX_MINIMUM, topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTSM1() throws Throwable {        testTSM();    }    public void testTSM2() throws Throwable {        testTSM();    }    public void testTSM3() throws Throwable {        testTSM();    }    public void testTSM4() throws Throwable {        testTSM();    }    public void testTSM5() throws Throwable {        testTSM();    }    public void testTMS() throws Throwable {        int topScore = randomTopScore();        verifyResults(MAX_SIGMA, randomMinimum(expectedTopScore(topScore)), topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedSigma(sigma), 2);        }    }    public void testTMS1() throws Throwable {        testTMS();    }    public void testTMS2() throws Throwable {        testTMS();    }    public void testTMS3() throws Throwable {        testTMS();    }    public void testTMS4() throws Throwable {        testTMS();    }    public void testTMS5() throws Throwable {        testTMS();    }    /**     * Verifies what happens when you pass these parameters     * into the thing.  DELTA is the amount of error allowed.     * Usually DELTA is only used for Sigma, as we really can't     * calculate it exactly.     */    public void verifyResults(double sigma, double minimum, int topScore, int expected, int delta) {        try {            setUp();            if (sigma >= 0) {                IUT.addProperty("sigma", Double.toString(sigma));            }            if (minimum >= 0) {                IUT.addProperty("minimum", Double.toString(minimum));            }            if (topScore >= 0) {                IUT.addProperty("topscore", Integer.toString(topScore));            }            Report report = makeReport(IUT);            if (delta == 0) {                assertEquals("Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore), expected, report.size());            } else {                String assertStr = "Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore) + " expected= " + Integer.toString(expected) + " +/- " + Integer.toString(delta) + " actual-result= " + report.size();                assertTrue(assertStr, report.size() >= (expected - delta));                assertTrue(assertStr, report.size() <= (expected + delta));            }        } catch (AssertionFailedError afe) {            System.err.println("******** " + testName + " ***********");            if (sigma != NO_SIGMA) {                System.err.println("SIGMA: " + Double.toString(sigma) + " EXPECT: " + Integer.toString(expectedSigma(sigma)));            }            if (minimum != NO_MINIMUM) {                System.err.println("MIN: " + Double.toString(minimum) + " EXPECT: " + Integer.toString(expectedMinimum(minimum)));            }            if (topScore != NO_TOPSCORE) {                System.err.println("TOP: " + Integer.toString(topScore) + " EXPECT: " + Integer.toString(expectedTopScore(topScore)));            }            throw afe;        }    }    public Report makeReport(Rule IUT) {        List list = new ArrayList();        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFilename(testName);        IUT.apply(list, ctx);        return report;    }}
/** * Created on Aug 28, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.TestCase;import net.sourceforge.pmd.stat.Metric;import java.util.Random;/** * @author David Dixon-Peugh */public class MetricTest extends TestCase {    private String testName = null;    private Random random = new Random();    /**     * Constructor for MetricTest.     * @param arg0     */    public MetricTest(String arg0) {        super(arg0);        this.testName = arg0;    }    public void testGetMetricName() {        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(testName, IUT.getMetricName());    }    public void testGetCount() {        int count = random.nextInt();        Metric IUT = new Metric(testName, count, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(count, IUT.getCount());    }    public void testGetTotal() {        double total = random.nextDouble();        Metric IUT = new Metric(testName, 0, total, 0.0, 0.0, 0.0, 0.0);        assertEquals(total, IUT.getTotal(), 0.05);    }    public void testGetLowValue() {        double low = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, low, 0.0, 0.0, 0.0);        assertEquals(low, IUT.getLowValue(), 0.05);    }    public void testGetHighValue() {        double high = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, high, 0.0, 0.0);        assertEquals(high, IUT.getHighValue(), 0.05);    }    public void testGetAverage() {        double mean = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, mean, 0.0);        assertEquals(mean, IUT.getAverage(), 0.05);    }    public void testGetStandardDeviation() {        double stdev = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, stdev);        assertEquals(stdev, IUT.getStandardDeviation(), 0.05);    }}
package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.rules.junit.JUnitAssertionsShouldIncludeMessageRule;import net.sourceforge.pmd.cpd.CPD;import test.net.sourceforge.pmd.rules.RuleTst;public class JUnitAssertionsShouldIncludeMessageRuleTest extends RuleTst {    public void testAssertEqualsOK() throws Throwable {        runTestFromString(TEST1, 0, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertEqualsBad() throws Throwable {        runTestFromString(TEST2, 1, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertTrueOK() throws Throwable {        runTestFromString(TEST3, 0, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertTrueBad() throws Throwable {        runTestFromString(TEST4, 1, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertNullOK() throws Throwable {        runTestFromString(TEST5, 0, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertNullBad() throws Throwable {        runTestFromString(TEST6, 1, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertSameOK() throws Throwable {        runTestFromString(TEST7, 0, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertSameBad() throws Throwable {        runTestFromString(TEST8, 1, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertNotNullOK() throws Throwable {        runTestFromString(TEST9, 0, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testAssertNotNullBad() throws Throwable {        runTestFromString(TEST10, 1, new JUnitAssertionsShouldIncludeMessageRule());    }    public void testFindBug() throws Throwable {        runTestFromString(TEST11, 0, new JUnitAssertionsShouldIncludeMessageRule());    }    private static final String TEST1 =    "public class JUnitAssertionsShouldIncludeMessageRule1 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertEquals(\"1 == 1\", 1, 1);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class JUnitAssertionsShouldIncludeMessageRule2 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertEquals(1, 1);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class JUnitAssertionsShouldIncludeMessageRule3 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertTrue(\"foo\", \"foo\".equals(\"foo\"));" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class JUnitAssertionsShouldIncludeMessageRule4 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertTrue(\"foo\".equals(\"foo\"));" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class JUnitAssertionsShouldIncludeMessageRule5 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertNull(\"it's not null\", null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public class JUnitAssertionsShouldIncludeMessageRule6 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertNull(null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST7 =    "public class JUnitAssertionsShouldIncludeMessageRule7 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertSame(\"not same!\", null, null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST8 =    "public class JUnitAssertionsShouldIncludeMessageRule8 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertSame(null, null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST9 =    "public class JUnitAssertionsShouldIncludeMessageRule9 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertNotNull(\"foo\", null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST10 =    "public class JUnitAssertionsShouldIncludeMessageRule10 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  assertNotNull(null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST11 =    "public class JUnitAssertionsShouldIncludeMessageRule11 {" + CPD.EOL +    " public void test1() {" + CPD.EOL +    "  this.test1(\"foo\");" + CPD.EOL +    " }" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;import test.net.sourceforge.pmd.rules.RuleTst;public class JUnitStaticSuiteRuleTest extends RuleTst {    private static final String TEST1 =    "public class JUnitStaticSuite1 {" + CPD.EOL +    " public TestSuite suite() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class JUnitStaticSuite2 {" + CPD.EOL +    " public static TestSuite suite() {}" + CPD.EOL +    "}";    private static final String TEST3 =    "public class JUnitStaticSuite3 {" + CPD.EOL +    " private static TestSuite suite() {}" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//MethodDeclaration[not(@Static='true') or not(@Public='true')][MethodDeclarator/@Image='suite']");    }    public void testNonstatic() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testGoodOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testPrivateSuite() throws Throwable {        runTestFromString(TEST3, 1, rule);    }}
package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;import test.net.sourceforge.pmd.rules.RuleTst;public class JUnitSpellingRuleTest extends RuleTst {    private static final String TEST1 =    "public class JUnitSpelling1 {" + CPD.EOL +    " // these should be 'setUp'" + CPD.EOL +    " public void setup() {}" + CPD.EOL +    " public void SetUp() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class JUnitSpelling2 {" + CPD.EOL +    " // these should be 'tearDown'" + CPD.EOL +    " public void TearDown() {}" + CPD.EOL +    " public void teardown() {}" + CPD.EOL +    "}";    private static final String TEST3 =    "public class JUnitSpelling3 {" + CPD.EOL +    " // these are OK" + CPD.EOL +    " public void setUp() {}" + CPD.EOL +    " public void tearDown() {}" + CPD.EOL +    "}";    private static final String TEST4 =    "public class JUnitSpelling4 {" + CPD.EOL +    " // these are OK" + CPD.EOL +    " public void utility() {}" + CPD.EOL +    " public void foobr() {}" + CPD.EOL +    "}";    private static final String TEST5 =    "public class JUnitSpelling5 {" + CPD.EOL +    " public void setup(String x) {}" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//MethodDeclarator[(not(@Image = 'setUp') and translate(@Image, 'SETuP', 'setUp') = 'setUp') or (not(@Image = 'tearDown') and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')][FormalParameters[count(*) = 0]]");    }    public void testSetupMisspellings1() throws Throwable {        runTestFromString(TEST1, 2, rule);    }    public void testTeardownMisspellings() throws Throwable {        runTestFromString(TEST2, 2, rule);    }    public void testMethodsSpelledOK() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void testUnrelatedMethods() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void testMethodWithParams() throws Throwable {        runTestFromString(TEST5, 0, rule);    }}
/* $Id$ */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.design.LongParameterListRule;import test.net.sourceforge.pmd.rules.RuleTst;public class LongParameterListRuleTest extends RuleTst {    private static final String TEST1 =    "public class LongParameterList0 {" + CPD.EOL +    "    public void foo() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class LongParameterList1 {" + CPD.EOL +    "    public void foo(int p01, int p02, int p03, int p04, int p05," + CPD.EOL +    "                   int p06, int p07, int p08, int p09, int p10 ) { }" + CPD.EOL +    "    public void bar(int p01, int p02, int p03, int p04, int p05 ) { }" + CPD.EOL +    "}";    public LongParameterListRule getIUT() {        LongParameterListRule IUT = new LongParameterListRule();        IUT.addProperty("minimum", "9");        return IUT;    }    public void testShortMethod() throws Throwable {        runTestFromString(TEST1, 0, getIUT());    }    public void testOneLongMethod() throws Throwable {        runTestFromString(TEST2, 1, getIUT());    }}
/** * Created on Sep 4, 2002 */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.design.SwitchDensityRule;import test.net.sourceforge.pmd.rules.RuleTst;/** * @author dpeugh * * This tests the new SwitchDensity rule to see if it really * does work. */public class SwitchDensityTest extends RuleTst {    private static final String TEST1 =    "// Switch Density = 5.0" + CPD.EOL +    "public class SwitchDensity1 {" + CPD.EOL +    "       public void foo(int i) {" + CPD.EOL +    "               switch (i) {" + CPD.EOL +    "                       case 0:" + CPD.EOL +    "                       {" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                       }" + CPD.EOL +    "               }                               " + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST2 =    "// Switch Density = 1.0" + CPD.EOL +    "public class SwitchDensity2 {" + CPD.EOL +    "       public void foo(int i) {" + CPD.EOL +    "               switch (i) {" + CPD.EOL +    "                       case 0:" + CPD.EOL +    "                       {" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                       }" + CPD.EOL +    "               }                               " + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST3 =    "// Switch Density = 1.0" + CPD.EOL +    "public class SwitchDensity3 {" + CPD.EOL +    "       public void foo(int i) {" + CPD.EOL +    "               switch (i) {" + CPD.EOL +    "                       case 0:" + CPD.EOL +    "                       case 1:" + CPD.EOL +    "                       case 2:" + CPD.EOL +    "                       case 3:" + CPD.EOL +    "                       case 4:" + CPD.EOL +    "                       {" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                               System.err.println(\"I am a fish.\");" + CPD.EOL +    "                       }" + CPD.EOL +    "               }                               " + CPD.EOL +    "       }" + CPD.EOL +    "}";    public SwitchDensityTest() {        super();    }    public SwitchDensityRule getIUT() {        SwitchDensityRule RC = new SwitchDensityRule();        RC.addProperty("minimum", "4");        return RC;    }    public void testSD1() throws Throwable {        runTestFromString(TEST1, 1, getIUT());    }    public void testSD2() throws Throwable {        runTestFromString(TEST2, 0, getIUT());    }    public void testSD3() throws Throwable {        runTestFromString(TEST3, 0, getIUT());    }}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.design.UseSingletonRule;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.rules.RuleTst;public class UseSingletonRuleTest extends RuleTst implements ReportListener {    private static final String TEST1 =    "public class UseSingleton1 {" + CPD.EOL +    " // Should trigger UseSingleton rule?" + CPD.EOL +    " public UseSingleton1() { }" + CPD.EOL +    " " + CPD.EOL +    " public static void doSomething() {" + CPD.EOL +    "  // Blah, blah, blah." + CPD.EOL +    " }" + CPD.EOL +    "" + CPD.EOL +    " public static void main(String args[]) {" + CPD.EOL +    "  doSomething();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class UseSingleton2" + CPD.EOL +    "{" + CPD.EOL +    "    // Should not trigger UseSingleton rule." + CPD.EOL +    "    public UseSingleton2() { }" + CPD.EOL +    "" + CPD.EOL +    "    public void doSomething() { }" + CPD.EOL +    "    " + CPD.EOL +    "    public static void main(String args[]) { }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class UseSingleton3" + CPD.EOL +    "{" + CPD.EOL +    "    // Should trigger it." + CPD.EOL +    "    public static void doSomething1() { }" + CPD.EOL +    "    public static void doSomething2() { }" + CPD.EOL +    "    public static void doSomething3() { }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class UseSingleton4" + CPD.EOL +    "{" + CPD.EOL +    "    public UseSingleton4() { }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class UseSingleton5 {" + CPD.EOL +    " private UseSingleton5() {}" + CPD.EOL +    " public static UseSingleton5 get() {" + CPD.EOL +    "  return null;" + CPD.EOL +    " }     " + CPD.EOL +    "}";    public void testAllStaticsPublicConstructor() throws Throwable {        runTestFromString(TEST1, 1, new UseSingletonRule());    }    public void testOKDueToNonStaticMethod() throws Throwable {        runTestFromString(TEST2, 0, new UseSingletonRule());    }    public void testNoConstructorCoupleOfStatics() throws Throwable {        runTestFromString(TEST3, 1, new UseSingletonRule());    }    public void testNoConstructorOneStatic() throws Throwable {        runTestFromString(TEST4, 0, new UseSingletonRule());    }    public void testClassicSingleton() throws Throwable {        runTestFromString(TEST5, 0, new UseSingletonRule());    }    public void testResetState() throws Throwable {        callbacks = 0;        Rule rule = new UseSingletonRule();        Report report = new Report();        report.addListener(this);        runTestFromString(TEST3, rule, report);        runTestFromString(TEST4, rule, report);        assertEquals(1, callbacks);    }    private int callbacks;    public void ruleViolationAdded(RuleViolation ruleViolation) {        callbacks++;    }    public void metricAdded(Metric metric) {    }}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.rules.design.NullAssignmentRule;import net.sourceforge.pmd.cpd.CPD;import test.net.sourceforge.pmd.rules.RuleTst;public class NullAssignmentRuleTest extends RuleTst {    private static final String TEST1 =    "public class NullAssignment1 {" + CPD.EOL +    "       public Object foo() {" + CPD.EOL +    "               Object x = null; // OK" + CPD.EOL +    "               return x;" + CPD.EOL +    "       }       " + CPD.EOL +    "}";    private static final String TEST2 =    "public class NullAssignment2 {" + CPD.EOL +    "       public void foo() {" + CPD.EOL +    "               Object x;" + CPD.EOL +    "               x = new Object();" + CPD.EOL +    "               for (int y = 0; y < 10; y++) {" + CPD.EOL +    "                       System.err.println(y);  " + CPD.EOL +    "               }" + CPD.EOL +    "               x = null; // This is bad" + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class NullAssignment3 {" + CPD.EOL +    "       public void foo() {" + CPD.EOL +    "               Object x;" + CPD.EOL +    "               if (x == null) { // This is OK" + CPD.EOL +    "                       return;" + CPD.EOL +    "               }" + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class NullAssignment4 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  String x = null;" + CPD.EOL +    "  x = new String(null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    public void testInitAssignment() throws Throwable {        runTestFromString(TEST1, 0, new NullAssignmentRule());    }    public void testBadAssignment() throws Throwable {        runTestFromString(TEST2, 1, new NullAssignmentRule());    }    public void testCheckTest() throws Throwable {        runTestFromString(TEST3, 0, new NullAssignmentRule());    }    public void testNullParamOnRHS() throws Throwable {        runTestFromString(TEST4, 0, new NullAssignmentRule());    }}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.rules.design.PositionalIteratorRule;import net.sourceforge.pmd.cpd.CPD;import test.net.sourceforge.pmd.rules.RuleTst;public class PositionalIteratorRuleTest extends RuleTst {    private static final String TEST1 =    "public class PositionalIterator1 {" + CPD.EOL +    " public void foo(Iterator i) {" + CPD.EOL +    "  while(i.hasNext()) {" + CPD.EOL +    "   Object one = i.next();" + CPD.EOL +    "   " + CPD.EOL +    "   // 2 calls to next() inside the loop == bad!" + CPD.EOL +    "   Object two = i.next(); " + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class PositionalIterator2 {" + CPD.EOL +    " public void foo(Iterator i) {" + CPD.EOL +    "  while(i.hasNext()) {" + CPD.EOL +    "   Object one = i.next();" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class PositionalIterator3 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  Iterator i = (new List()).iterator();" + CPD.EOL +    "  while(i.hasNext()) {" + CPD.EOL +    "   Object one = i.next();" + CPD.EOL +    "   Iterator j = (new List()).iterator();" + CPD.EOL +    "   while (j.hasNext()) {" + CPD.EOL +    "    j.next();" + CPD.EOL +    "   }" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    public void test1() throws Throwable {        runTestFromString(TEST1, 1, new PositionalIteratorRule());    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, new PositionalIteratorRule());    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, new PositionalIteratorRule());    }}
/* $Id$ */package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.design.LongMethodRule;import test.net.sourceforge.pmd.rules.RuleTst;public class LongMethodRuleTest extends RuleTst {    private LongMethodRule getIUT() {        LongMethodRule IUT = new LongMethodRule();        IUT.addProperty("minimum", "10");        return IUT;    }    public void testShortMethod() throws Throwable {        runTestFromString(TEST1, 0, getIUT());    }    public void testReallyLongMethod() throws Throwable {        runTestFromString(TEST2, 1, getIUT());    }    public void testReallyLongMethodWithLongerRange() throws Throwable {        LongMethodRule IUT = getIUT();        IUT.addProperty("minimum", "20");        runTestFromString(TEST2, 0, IUT);    }    public void testNotQuiteLongMethod() throws Throwable {        runTestFromString(TEST3, 0, getIUT());    }    public void testLongMethod() throws Throwable {        runTestFromString(TEST4, 1, getIUT());    }    private static final String TEST1 =    "public class LongMethod1 {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "System.err.println(\"This is short.\");" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class LongMethod2 {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "System.err.println(\"This is long.\");" + CPD.EOL +    "    } // 11 lines - violation" + CPD.EOL +    "}";    private static final String TEST3 =    "public class LongMethod2 {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "System.err.println(\"This is long, but not a violation\");" + CPD.EOL +    "    } // 9 lines - Not a violation" + CPD.EOL +    "}";    private static final String TEST4 =    "public class LongMethod2 {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "System.err.println(\"This is long, and is a violation\");" + CPD.EOL +    "    } // > 10 lines - Not a violation" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.design.LongClassRule;import test.net.sourceforge.pmd.rules.RuleTst;public class LongClassRuleTest extends RuleTst {    public LongClassRule getIUT() {        LongClassRule IUT = new LongClassRule();        IUT.addProperty("minimum", "10");        return IUT;    }    public void testShortClass() throws Throwable {        runTestFromString(TEST0, 0, getIUT());    }    public void testLongClass() throws Throwable {        runTestFromString(TEST1, 1, getIUT());    }    public void testLongClassWithLongerTest() throws Throwable {        LongClassRule IUT = getIUT();        IUT.addProperty("minimum", "2000");        runTestFromString(TEST1, 0, IUT);    }    private static final String TEST0 =    "public class LongMethod1 {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "System.err.println(\"This is short.\");" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST1 =    "public class LongClass1" + CPD.EOL +    "{" + CPD.EOL +    "    public void method0() {" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "System.err.println(\"This is a long class.\");" + CPD.EOL +    "    }" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.rules.design.OnlyOneReturnRule;import net.sourceforge.pmd.cpd.CPD;import test.net.sourceforge.pmd.rules.RuleTst;public class OnlyOneReturnRuleTest extends RuleTst {    private static final String TEST1 =    "public class OnlyOneReturn1 {" + CPD.EOL +    " public String foo(int x) {    " + CPD.EOL +    "  if (x > 0) {" + CPD.EOL +    "   return \"hey\";" + CPD.EOL +    "  }" + CPD.EOL +    "  return \"hi\";" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class OnlyOneReturn2 {" + CPD.EOL +    " public String foo(int x) {    " + CPD.EOL +    "  return \"hi\";" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class OnlyOneReturn3 {" + CPD.EOL +    " public void foo(int x) {      " + CPD.EOL +    "  int y =2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class OnlyOneReturn4 {" + CPD.EOL +    " public void foo(int x) {      " + CPD.EOL +    "  if (x>2) {" + CPD.EOL +    "    return;" + CPD.EOL +    "  }" + CPD.EOL +    "  int y =2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class OnlyOneReturn5 {" + CPD.EOL +    " public int foo(int x) {" + CPD.EOL +    "  try {" + CPD.EOL +    "   x += 2;" + CPD.EOL +    "   return x;" + CPD.EOL +    "  } finally {" + CPD.EOL +    "   System.err.println(\"WunderBuggy!\");" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public class OnlyOneReturn6 {" + CPD.EOL +    " public int foo() {" + CPD.EOL +    "  FileFilter f = new FileFilter() {" + CPD.EOL +    "   public boolean accept(File file) {" + CPD.EOL +    "    return false;" + CPD.EOL +    "   }" + CPD.EOL +    "  };" + CPD.EOL +    "  return 2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    public void testTwoReturns() throws Throwable {        runTestFromString(TEST1, 1, new OnlyOneReturnRule());    }    public void testOneReturn() throws Throwable {        runTestFromString(TEST2, 0, new OnlyOneReturnRule());    }    public void testNoReturns() throws Throwable {        runTestFromString(TEST3, 0, new OnlyOneReturnRule());    }    public void testVoidRtn() throws Throwable {        runTestFromString(TEST4, 0, new OnlyOneReturnRule());    }    public void testFinally() throws Throwable {        runTestFromString(TEST5, 0, new OnlyOneReturnRule());    }    public void testReturnInsideAnonymousInnerClass() throws Throwable {        runTestFromString(TEST6, 0, new OnlyOneReturnRule());    }}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.rules.design.LooseCouplingRule;import net.sourceforge.pmd.cpd.CPD;import test.net.sourceforge.pmd.rules.RuleTst;public class LooseCouplingRuleTest extends RuleTst {    private static final String TEST1 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling1 {" + CPD.EOL +    " public HashSet getFoo() {" + CPD.EOL +    "  return new HashSet();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling2 {" + CPD.EOL +    " public Map getFoo() {" + CPD.EOL +    "  return new HashMap();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class LooseCoupling3 {" + CPD.EOL +    " public void foo() {}" + CPD.EOL +    "}";    private static final String TEST4 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling1 {" + CPD.EOL +    " private Set fooSet = new HashSet(); // OK" + CPD.EOL +    "" + CPD.EOL +    " public Set getFoo() {" + CPD.EOL +    "  return fooSet;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling5 {" + CPD.EOL +    " private HashSet fooSet = new HashSet(); // NOT OK" + CPD.EOL +    "" + CPD.EOL +    " public Set getFoo() {" + CPD.EOL +    "  return fooSet;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling1 {" + CPD.EOL +    " private HashSet fooSet = new HashSet(); // NOT OK" + CPD.EOL +    "" + CPD.EOL +    " public HashSet getFoo() { // NOT OK" + CPD.EOL +    "  return fooSet;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST7 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling7 {" + CPD.EOL +    " private HashSet fooSet = new HashSet();" + CPD.EOL +    " private HashMap fooMap = new HashMap();" + CPD.EOL +    "}";    private static final String TEST8 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling8 {" + CPD.EOL +    " public void foo(HashMap bar) {}" + CPD.EOL +    "}";    private static final String TEST9 =    "import java.util.*;" + CPD.EOL +    "public class LooseCoupling9 {" + CPD.EOL +    " public void foo(Vector bar) {}" + CPD.EOL +    "}";    private LooseCouplingRule rule;    public void setUp() {        rule = new LooseCouplingRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void test4() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void test5() throws Throwable {        runTestFromString(TEST5, 1, rule);    }    public void test6() throws Throwable {        runTestFromString(TEST6, 2, rule);    }    public void test7() throws Throwable {        runTestFromString(TEST7, 2, rule);    }    public void test8() throws Throwable {        runTestFromString(TEST8, 1, rule);    }    public void testVector() throws Throwable {        runTestFromString(TEST9, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class JumbledIncrementerRuleTest extends RuleTst {    private static final String TEST1 =    "public class JumbledIncrementerRule1 {" + CPD.EOL +    " public void foo() { " + CPD.EOL +    "  for (int i = 0; i < 10; i++) { " + CPD.EOL +    "   for (int k = 0; k < 20; i++) { " + CPD.EOL +    "    System.out.println(\"Hello\"); " + CPD.EOL +    "   } " + CPD.EOL +    "  } " + CPD.EOL +    " } " + CPD.EOL +    "}";    private static final String TEST2 =    "public class JumbledIncrementerRule2 {" + CPD.EOL +    " public void foo() { " + CPD.EOL +    "  for (int i = 0; i < 10; i++) { " + CPD.EOL +    "   for (int k = 0; k < 20; k++) { " + CPD.EOL +    "    System.out.println(\"Hello\"); " + CPD.EOL +    "   } " + CPD.EOL +    "  } " + CPD.EOL +    " } " + CPD.EOL +    "}";    private static final String TEST3 =    "public class JumbledIncrementerRule3 {" + CPD.EOL +    " public void foo() { " + CPD.EOL +    "  for (int i=0; i<5; ) {" + CPD.EOL +    "   i++;" + CPD.EOL +    "  }" + CPD.EOL +    "  for (int i=0;;) {" + CPD.EOL +    "   if (i<5) {" + CPD.EOL +    "    break;" + CPD.EOL +    "   }" + CPD.EOL +    "   i++;" + CPD.EOL +    "  }" + CPD.EOL +    "  for (;;) {" + CPD.EOL +    "   int x =5;" + CPD.EOL +    "  }" + CPD.EOL +    "  for (int i=0; i<5;i++) ;" + CPD.EOL +    "  for (int i=0; i<5;i++) " + CPD.EOL +    "   foo();" + CPD.EOL +    " } " + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty(            "xpath",            "//ForStatement[ForUpdate//Name/@Image = ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image]");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.UnusedPrivateFieldRule;public class UnusedPrivateFieldRuleTest extends SimpleAggregatorTst {    private UnusedPrivateFieldRule rule;    public void setUp() {        rule = new UnusedPrivateFieldRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple unused private field", 1, rule),           new TestDescriptor(TEST2, "private field referenced in another field's initializer", 0, rule),           new TestDescriptor(TEST3, "private field with field of same name in anonymous inner class", 1, rule),           new TestDescriptor(TEST4, "field is used semantically before it's declared syntactically", 0, rule),           new TestDescriptor(TEST5, "private field referenced via 'this' modifier", 0, rule),           new TestDescriptor(TEST6, "private referenced by anonymous inner class", 0, rule),           new TestDescriptor(TEST7, "interface sanity test", 0, rule),           new TestDescriptor(TEST8, "unused private field in static inner class", 1, rule),           new TestDescriptor(TEST9, "private field referenced in nonstatic inner class", 0, rule),           new TestDescriptor(TEST10, "unused private static field", 1, rule),           new TestDescriptor(TEST11, "private static final referenced with qualifier", 0, rule),           new TestDescriptor(TEST12, "unused private field after class decl", 1, rule),           new TestDescriptor(TEST13, "two unused private fields in separate inner classes", 2, rule),           new TestDescriptor(TEST14, "method param shadows unused private field", 1, rule),           new TestDescriptor(TEST15, "private field referenced via 'this' not shadowed by param of same name", 0, rule),           new TestDescriptor(TEST16, "don't catch public fields", 0, rule),           new TestDescriptor(TEST17, "instantiate self and reference private field on other object", 0, rule),           new TestDescriptor(TEST18, "don't count Serialization fields as being unused", 0, rule),       });    }    private static final String TEST1 =    "public class UnusedPrivateField1 {" + CPD.EOL +    "private String foo;" + CPD.EOL +    "}";    private static final String TEST2 =    "public class UnusedPrivateField2 {" + CPD.EOL +    " " + CPD.EOL +    " private String foo;" + CPD.EOL +    " private String bar = foo;" + CPD.EOL +    " " + CPD.EOL +    " public void buz() {" + CPD.EOL +    "  bar = null;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class UnusedPrivateField3 {" + CPD.EOL +    "" + CPD.EOL +    " private String foo;" + CPD.EOL +    "" + CPD.EOL +    " public void baz() {" + CPD.EOL +    "  Runnable r = new Runnable() {" + CPD.EOL +    "   public void run() {" + CPD.EOL +    "    String foo = \"buz\";" + CPD.EOL +    "   }" + CPD.EOL +    "  };   " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class UnusedPrivateField4 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  foo[0] = 0;" + CPD.EOL +    " }" + CPD.EOL +    " private int[] foo;" + CPD.EOL +    "}";    private static final String TEST5 =    "public class UnusedPrivateField5 {" + CPD.EOL +    " private String foo;" + CPD.EOL +    " public void bar() {   " + CPD.EOL +    "  this.foo = null;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public class UnusedPrivateField6 {" + CPD.EOL +    " private static final String FOO = \"foo\";" + CPD.EOL +    "  public Runnable bar() {      " + CPD.EOL +    "   return new Runnable() {" + CPD.EOL +    "    public void run() {" + CPD.EOL +    "     FOO.toString();" + CPD.EOL +    "    }" + CPD.EOL +    "   };" + CPD.EOL +    "  }" + CPD.EOL +    "}";    private static final String TEST7 =    "public interface UnusedPrivateField7 {" + CPD.EOL +    " public static final String FOO = \"FOO\"; " + CPD.EOL +    " public boolean equals(Object another);" + CPD.EOL +    " public int hashCode();" + CPD.EOL +    " public String toString();" + CPD.EOL +    "}";    private static final String TEST8 =    "public class UnusedPrivateField8 {" + CPD.EOL +    " public static class Services {" + CPD.EOL +    "  private String x;    " + CPD.EOL +    " }" + CPD.EOL +    "}" + CPD.EOL +    "";    private static final String TEST9 =    "public class UnusedPrivateField9 {" + CPD.EOL +    " private int x;" + CPD.EOL +    " private class Bar {" + CPD.EOL +    "  public void baz() {" + CPD.EOL +    "   x = 2;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST10 =    "public class UnusedPrivateField10 {" + CPD.EOL +    " private static String foo;" + CPD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + CPD.EOL +    " private static final int BAR = 2;" + CPD.EOL +    " int x = Foo.BAR;" + CPD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + CPD.EOL +    " public class Foo {}" + CPD.EOL +    " private int x;" + CPD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + CPD.EOL +    " public class Foo {private int x;}" + CPD.EOL +    " public class Bar {private int x;}" + CPD.EOL +    "}";    private static final String TEST14 =    "public class Foo {" + CPD.EOL +    " private int value;" + CPD.EOL +    " public int doSomething(int value) { " + CPD.EOL +    "  return value + 1; " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST15 =    "public class Foo {" + CPD.EOL +    " private int x; " + CPD.EOL +    " public UnusedPrivateField17(int x) {" + CPD.EOL +    "  this.x=x;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + CPD.EOL +    " public static final String FOO = \"foo\";" + CPD.EOL +    "}";    private static final String TEST17 =    "public class Foo {" + CPD.EOL +    " private int x;" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  Foo foo = new Foo();  " + CPD.EOL +    "  foo.x = 2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST18 =    "public class Foo {" + CPD.EOL +    " private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"foo\", String.class)};" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class LongVariableRuleTest extends RuleTst {    private static final String TEST1 =    "public class LongVariableParam {" + CPD.EOL +    "    public static void main(String argsWithExtraMustard[]) { " + CPD.EOL +    "       // a should trigger it." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class LongVariableNone {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "       int bugleDeWump = -1;" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class LongVariableLocal {" + CPD.EOL +    "" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "       int abcdefghijklmnopqrstuvwxyz = -1; " + CPD.EOL +    "       // Should trigger ShortVariable rule." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class LongVariableFor {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "       for (int interestingIntIterator = 0; " + CPD.EOL +    "            interestingIntIterator < 10; " + CPD.EOL +    "            interestingIntIterator++) { } // Should trigger." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class LongVariableField {" + CPD.EOL +    "    private int abcdefghijklmnopqrstuvwxyz; // Should cause a problem." + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//VariableDeclaratorId[string-length(@Image) > 12]");    }    public void testLongVariableParam() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testLongVariableNone() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testLongVariableLocal() throws Throwable {        runTestFromString(TEST3, 1, rule);    }    public void testLongVariableField() throws Throwable {        runTestFromString(TEST4, 1, rule);    }    public void testLongVariableFor() throws Throwable {        runTestFromString(TEST5, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class AssignmentInOperandRuleTest extends RuleTst {    private static final String TEST1 =    "public class AssignmentInOperand1 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  if ((x = getX()) == 3) {" + CPD.EOL +    "   System.out.println(\"3!\");" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    " private int getX() {" + CPD.EOL +    "  return 3;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class AssignmentInOperand2 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  if (false) {}" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class AssignmentInOperand3 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  if (false) {" + CPD.EOL +    "   int x =2;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class AssignmentInOperand4 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  while ( (x = getX()) != 0 ) {}" + CPD.EOL +    " }" + CPD.EOL +    " private int getX() {return 2;}" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//*[name()='WhileStatement' or name()='IfStatement'][Expression//AssignmentOperator]");    }    public void testSimple() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testAssignmentInIfBody() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void testAssignmentInWhileLoop() throws Throwable {        runTestFromString(TEST4, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.SimplifyBooleanReturnsRule;public class SimplifyBooleanReturnsRuleTest extends RuleTst {    private static final String TEST1 =    "public class SimplifyBooleanReturns1 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  if (true) {" + CPD.EOL +    "   return true;" + CPD.EOL +    "  } else {" + CPD.EOL +    "  return false;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class SimplifyBooleanReturns2 {" + CPD.EOL +    " public boolean foo() {        " + CPD.EOL +    "  if (true) " + CPD.EOL +    "   return true;" + CPD.EOL +    "   else " + CPD.EOL +    "  return false;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class SimplifyBooleanReturns3 {" + CPD.EOL +    " public Object foo() { " + CPD.EOL +    "  if (!true) {" + CPD.EOL +    "   return null;" + CPD.EOL +    "  } else  {}" + CPD.EOL +    "  return null;" + CPD.EOL +    " }" + CPD.EOL +    "}";    public void test1() throws Throwable {        runTestFromString(TEST1, 1, new SimplifyBooleanReturnsRule());    }    public void test2() throws Throwable {        runTestFromString(TEST2, 1, new SimplifyBooleanReturnsRule());    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, new SimplifyBooleanReturnsRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class IfElseStmtsMustUseBracesRuleTest extends RuleTst {    private static final String TEST1 =    "public class IfElseStmtsNeedBraces1 {" + CPD.EOL +    "       public void foo() {     " + CPD.EOL +    "               int x =0;" + CPD.EOL +    "               if (true == true) " + CPD.EOL +    "                       x=2;" + CPD.EOL +    "                else " + CPD.EOL +    "                       x=4;" + CPD.EOL +    "               " + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class IfElseStmtsNeedBraces2 {" + CPD.EOL +    "       public void foo() {     " + CPD.EOL +    "               int x =0;" + CPD.EOL +    "               if (true == true) {" + CPD.EOL +    "                       x=2;" + CPD.EOL +    "               } else {" + CPD.EOL +    "                       x=4;" + CPD.EOL +    "               }" + CPD.EOL +    "       }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//IfStatement[count(*) > 2][not(Statement/Block)]");    }    public void testIfElseStmtsMustUseBraces1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testIfElseStmtsMustUseBraces2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.ExcessivePublicCountRule;import net.sourceforge.pmd.cpd.CPD;public class ExcessivePublicCountRuleTest extends RuleTst {    private static final String TEST1 =    "public class ExcessivePublicCountRule1 {" + CPD.EOL +    " public int foo;" + CPD.EOL +    "}";    private static final String TEST2 =    "public class ExcessivePublicCountRule2 {" + CPD.EOL +    " public int foo;" + CPD.EOL +    " public int bif;" + CPD.EOL +    " public int baz;" + CPD.EOL +    " public int bof;" + CPD.EOL +    "}";    private ExcessivePublicCountRule rule;    public void setUp() {        rule = new ExcessivePublicCountRule();    }    public void testSimpleOK() throws Throwable {        rule.addProperty("minimum", "50");        runTestFromString(TEST1, 0, rule);    }    public void testSimpleBad() throws Throwable {        rule.addProperty("minimum", "2");        runTestFromString(TEST2, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.UnusedLocalVariableRule;public class UnusedLocalVariableTest extends RuleTst {    private static final String TEST1 =    "import java.io.*;" + CPD.EOL +    "public class UnusedLocal1 {" + CPD.EOL +    " public foo() {" + CPD.EOL +    "  try {" + CPD.EOL +    "   FileReader fr = new FileReader(\"/dev/null\");" + CPD.EOL +    "   } catch (Exception e) {}" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class UnusedLocal2 {" + CPD.EOL +    " public void method() {" + CPD.EOL +    "  int x;" + CPD.EOL +    " }" + CPD.EOL +    "}" + CPD.EOL +    "";    private static final String TEST3 =    "import java.util.*;" + CPD.EOL +    "public class UnusedLocal3 {" + CPD.EOL +    "    public UnusedLocal3() {" + CPD.EOL +    "       List a = new ArrayList();" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "";    private static final String TEST4 =    "import java.util.*;" + CPD.EOL +    "public class UnusedLocal4 {" + CPD.EOL +    "    public UnusedLocal4() {" + CPD.EOL +    "       List a = new ArrayList();" + CPD.EOL +    "       if (true == true) {" + CPD.EOL +    "               a.size();" + CPD.EOL +    "       }" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "";    private static final String TEST5 =    "import java.util.*;" + CPD.EOL +    "public class UnusedLocal5 {" + CPD.EOL +    "static {" + CPD.EOL +    "       String x;" + CPD.EOL +    "}" + CPD.EOL +    "}" + CPD.EOL +    "";    private static final String TEST6 =    "public class UnusedLocal6 {" + CPD.EOL +    " public int x;" + CPD.EOL +    "}";    private static final String TEST7 =    "public class UnusedLocal7 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  for (int i=0;i<10; i++);" + CPD.EOL +    "  for (int i=0;i<10; i++);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST8 =    "public class UnusedLocal8 {" + CPD.EOL +    "  String foo = System.getProperty(\"line.separator\", \"\\n\");" + CPD.EOL +    "}";    private static final String TEST9 =    "public class UnusedLocal9 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  final String x = \"baf\";" + CPD.EOL +    "   new Runnable() {" + CPD.EOL +    "    public void run() {" + CPD.EOL +    "     System.out.println(x);" + CPD.EOL +    "    }" + CPD.EOL +    "   };  " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST10 =    "public interface UnusedLocal10 {" + CPD.EOL +    " public void foo();" + CPD.EOL +    " public String bar();" + CPD.EOL +    "}";    private static final String TEST11 =    "public class UnusedLocal11 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  String x = \"hi\";" + CPD.EOL +    "  class Bar {" + CPD.EOL +    "   public void buz() {" + CPD.EOL +    "    String x = \"howdy\";" + CPD.EOL +    "   }" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST12 =    "public class UnusedLocal12 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  for (int x = 0; ; ) { // USED" + CPD.EOL +    "   x++;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST13 =    "public class UnusedLocal13 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  final String x = \"hi\";" + CPD.EOL +    "   new Runnable() {" + CPD.EOL +    "    public void run() {" + CPD.EOL +    "     x.toString();" + CPD.EOL +    "    }" + CPD.EOL +    "   };" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST14 =    "public class UnusedLocal14 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  int x,y=0;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST15 =    "public class UnusedLocal15 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  try {" + CPD.EOL +    "   //int x =2;" + CPD.EOL +    "  } catch (RuntimeException e) {" + CPD.EOL +    "  } catch (Exception e) {" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private UnusedLocalVariableRule rule;    public void setUp() {        rule = new UnusedLocalVariableRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 1, rule);    }    public void test4() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void test5() throws Throwable {        runTestFromString(TEST5, 1, rule);    }    public void test6() throws Throwable {        runTestFromString(TEST6, 0, rule);    }    public void test7() throws Throwable {        runTestFromString(TEST7, 0, rule);    }    public void test8() throws Throwable {        runTestFromString(TEST8, 0, rule);    }    public void test9() throws Throwable {        runTestFromString(TEST9, 0, rule);    }    public void test10() throws Throwable {        runTestFromString(TEST10, 0, rule);    }    public void test11() throws Throwable {        runTestFromString(TEST11, 2, rule);    }    public void test12() throws Throwable {        runTestFromString(TEST12, 0, rule);    }    public void test13() throws Throwable {        runTestFromString(TEST13, 0, rule);    }    public void test14() throws Throwable {        runTestFromString(TEST14, 2, rule);    }    public void test15() throws Throwable {        runTestFromString(TEST15, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.DoubleCheckedLockingRule;import net.sourceforge.pmd.cpd.CPD;public class DoubleCheckedLockingRuleTest extends RuleTst {    private static final String TEST1 =    "public class DoubleCheckedLockingRule1 {" + CPD.EOL +    " public void foo() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class DoubleCheckedLockingRule2 {" + CPD.EOL +    "      Object baz;" + CPD.EOL +    "      Object bar() {" + CPD.EOL +    "        if(baz == null) { //baz may be non-null yet not fully created" + CPD.EOL +    "          synchronized(this){" + CPD.EOL +    "            if(baz == null){" + CPD.EOL +    "              baz = new Object();" + CPD.EOL +    "            }" + CPD.EOL +    "          }" + CPD.EOL +    "        }" + CPD.EOL +    "        return baz;" + CPD.EOL +    "      }" + CPD.EOL +    "}";    private static final String TEST3 =    "public interface DoubleCheckedLockingRule3 {" + CPD.EOL +    " void foo();" + CPD.EOL +    "}";    public void testSimpleOK() throws Throwable {        runTestFromString(TEST1, 0, new DoubleCheckedLockingRule());    }    public void testSimpleBad() throws Throwable {        runTestFromString(TEST2, 1, new DoubleCheckedLockingRule());    }    public void testSkipInterfaces() throws Throwable {        runTestFromString(TEST3, 0, new DoubleCheckedLockingRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class ForLoopShouldBeWhileLoopRuleTest extends RuleTst {    private static final String TEST1 =    "public class ForLoopShouldBeWhileLoop1 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  for (;x<5;) { " + CPD.EOL +    "   x++;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class ForLoopShouldBeWhileLoop2 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  for (int x=2;x<5;) { " + CPD.EOL +    "   x++;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class ForLoopShouldBeWhileLoop3 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  for (;;) {}" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty(            "xpath",            "//ForStatement[count(*) > 1][not(ForInit)][not(ForUpdate)]");    }    public void testSimple() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testForSemicolonSemicolon() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.UnusedFormalParameterRule;public class UnusedFormalParameterRuleTest extends RuleTst {    private static final String TEST1 =    "class UnusedFormalParam1 {" + CPD.EOL +    "    private void testMethod(String param1) {" + CPD.EOL +    "        //System.out.println(param1);" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "class UnusedFormalParam2 {" + CPD.EOL +    "    private void foo (String s) " + CPD.EOL +    "    {String str = s.toString();}" + CPD.EOL +    "}";    private static final String TEST3 =    "class UnusedFormalParam3 {" + CPD.EOL +    "    private void t1(String s) {" + CPD.EOL +    "        s.toString();" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST4 =    "public interface UnusedFormalParam4 {" + CPD.EOL +    " public void foo(String bar);" + CPD.EOL +    "}";    private UnusedFormalParameterRule rule;    public void setUp() {        rule = new UnusedFormalParameterRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testOneParam() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testFullyQualified() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testOneParamWithMethodCall() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void testInterface() throws Throwable {        runTestFromString(TEST4, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class OverrideBothEqualsAndHashcodeRuleTest extends RuleTst {    private static final String TEST1 =    "public class OverrideBothEqualsAndHashcode1 {" + CPD.EOL +    " public int hashCode() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class OverrideBothEqualsAndHashcode2 {" + CPD.EOL +    " public boolean equals(Object other) {}" + CPD.EOL +    "}";    private static final String TEST3 =    "public class OverrideBothEqualsAndHashcode3 {" + CPD.EOL +    " public boolean equals(Object other) {}" + CPD.EOL +    " public int hashCode() {}" + CPD.EOL +    "}";    private static final String TEST4 =    "public class OverrideBothEqualsAndHashcode4 {" + CPD.EOL +    "}";    private static final String TEST5 =    "public class OverrideBothEqualsAndHashcode5 {" + CPD.EOL +    " public boolean equals(String o) {" + CPD.EOL +    "  return true;" + CPD.EOL +    " }" + CPD.EOL +    " public int hashCode() {" + CPD.EOL +    "  return 0;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public interface OverrideBothEqualsAndHashcode6 {" + CPD.EOL +    " public boolean equals(Object o);" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//ClassDeclaration//MethodDeclarator" +        "[" +        "(" +        "@Image = 'equals'" +        " and count(FormalParameters/*) = 1" +        " and not(//MethodDeclarator[count(FormalParameters/*) = 0][@Image = 'hashCode'])" +        ") or (" +        "@Image='hashCode'" +        " and count(FormalParameters/*) = 0" +        " and not(//MethodDeclarator[count(FormalParameters//Type/Name[@Image = 'Object']) = 1][@Image = 'equals'])" +        ")]");    }    public void testHashCodeOnly() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testEqualsOnly() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void testCorrectImpl() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void testNeither() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void testEqualsSignatureUsesStringNotObject() throws Throwable {        runTestFromString(TEST5, 1, rule);    }    public void testInterface() throws Throwable {        runTestFromString(TEST6, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class ForLoopsMustUseBracesRuleTest extends RuleTst {    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//ForStatement[not(Statement/Block)]");    }    public void test1() throws Throwable {        runTestFromString(TEST1,1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2,0, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3,1, rule);    }    public void test4() throws Throwable {        runTestFromString(TEST4,1, rule);    }    public void test5() throws Throwable {        runTestFromString(TEST5,1, rule);    }    private static final String TEST1 =    "public class ForLoopsNeedBraces1 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  for (int i=0; i<42;i++)" + CPD.EOL +    "       foo();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class ForLoopsNeedBraces2 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  for (int i=0; i<42;i++) {" + CPD.EOL +    "       foo();" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class ForLoopsNeedBraces3 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  for (int i=0; i<42;) " + CPD.EOL +    "       foo();" + CPD.EOL +    "  " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class ForLoopsNeedBraces4 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  for (int i=0;;) " + CPD.EOL +    "       foo();" + CPD.EOL +    "  " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class ForLoopsNeedBraces5 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  for (;;) " + CPD.EOL +    "       foo();" + CPD.EOL +    "  " + CPD.EOL +    " }" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class ShortVariableRuleTest extends SimpleAggregatorTst {    private static final String TEST1 =    "public class ShortVariableParam {" + CPD.EOL +    "    public static void main(String a[]) { // a should trigger it." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class ShortVariableNone {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "       int bugleDeWump = -1;" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class ShortVariableLocal {" + CPD.EOL +    "" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "       int ab = -1; " + CPD.EOL +    "       // Should trigger ShortVariable rule." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class ShortVariableFor {" + CPD.EOL +    "    public static void main(String args[]) {" + CPD.EOL +    "       for (int i = 0; i < 10; i++) { } // Should NOT!! trigger." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class ShortVariableField {" + CPD.EOL +    "    private int qx; // Should cause a problem." + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//VariableDeclaratorId[string-length(@Image) < 3][not(ancestor::ForInit)]");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "param", 1, rule),           new TestDescriptor(TEST2, "none", 0, rule),           new TestDescriptor(TEST3, "local", 1, rule),           new TestDescriptor(TEST4, "for", 0, rule),           new TestDescriptor(TEST5, "field", 1, rule),       });    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.XPathRule;/** * @author daniels * * Cannot Implement: * <LI> Cyclomatic Complexity Rule - don't understand it * <LI> Import From Same Package Rule - cannot check for sub packages * <LI> StringToString - may be possible, but a better grammar would help. * <LI> UnnecessaryConversionTemporaryRule - don't understand it * <LI> UnusedFormalParameter - may be possible, but a better grammar would help.  * <LI> UnusedImportsRule - may be possible, but a better grammar would help. * <LI> UnusedLocalVariableFieldRule - may be possible, but a better grammar would help. * <LI> UnusedPrivateFieldRule - may be possible, but a better grammar would help. * <LI> UnusedPrivateMethodRule - may be possible, but a better grammar would help. * <HR>  * * Partial Implementation * <LI> DuplicateImportsRuleTest - cannot detect specific vs. general imports   *  * <HR> *   * Differing Implementation * <LI> AvoidDuplicateLiteralsRule - marks all duplicate nodes * */public class XPathRuleTest extends RuleTst {    XPathRule rule;    public void setUp() {        rule = new XPathRule();        rule.setMessage("XPath Rule Failed");    }    //    public void testUnusedFormalParameterRule() throws Throwable {//        rule.addProperty("xpath", "//MethodDeclaration[@Private='true'][@Native='false']//FormalParameters//VariableDeclaratorId");//        runTestFromFile("UnusedFormalParam1.java", 1, rule);//        runTestFromFile("UnusedFormalParam2.java", 0, rule);//        runTestFromFile("UnusedFormalParam3.java", 0, rule);//        runTestFromFile("UnusedFormalParam4.java", 0, rule);//    }    //public void testUnnecessaryConversionTemporaryRule() throws Throwable{//        runTestFromFile("UnnecessaryTemporary.java", 6, rule);//}//    public void testStringToString() throws Throwable {//        runTestFromFile("StringToString1.java", 1, rule);//        runTestFromFile("StringToString2.java", 1, rule);//        runTestFromFile("StringToString3.java", 1, rule);//        runTestFromFile("StringToString4.java", 0, rule);//        runTestFromFile("StringToString5.java", 0, rule);//        runTestFromFile("StringToString6.java", 1, rule);//        //    }    public void testDeeplyNestedIfStmtsRule() throws Throwable {        rule.addProperty(            "xpath",            "//IfStatement[count(ancestor::IfStatement[not(Statement[2])]) > {0}]");        rule.addProperty("subst", "1");        runTestFromString(AvoidDeeplyNestedIfStmtsRuleTest.TEST1, 1, rule);        runTestFromString(AvoidDeeplyNestedIfStmtsRuleTest.TEST2, 0, rule);    }    /**     * This differs from the original in that ALL duplicates are marked.      * @throws Throwable     */    public void testAvoidDuplicateLiteralsRule() throws Throwable {        //fail("I wouldn't even know where to begin");        rule.addProperty(            "xpath",            "//Literal[@Image = preceding::Literal/@Image or @Image = following::Literal/@Image]");        runTestFromString(AvoidDuplicateLiteralsRuleTest.TEST1, 4, rule);        runTestFromString(AvoidDuplicateLiteralsRuleTest.TEST2, 0, rule);        runTestFromString(AvoidDuplicateLiteralsRuleTest.TEST3, 0, rule);    }    /**     * @todo Figure it out.     */    public void testAvoidReassigningParameters() throws Throwable {        //        fail("I wouldn't even know where to begin");        rule.addProperty(            "xpath",            "//PrimaryExpression[following-sibling::AssignmentOperator][PrimaryPrefix/Name/@Image = ancestor::MethodDeclaration/MethodDeclarator/FormalParameters/FormalParameter/VariableDeclaratorId/@Image]");        runTestFromString(AvoidReassigningParametersRuleTest.TEST1, 1, rule);        runTestFromString(AvoidReassigningParametersRuleTest.TEST2, 0, rule);        runTestFromString(AvoidReassigningParametersRuleTest.TEST3, 1, rule);        runTestFromString(AvoidReassigningParametersRuleTest.TEST4, 0, rule);        runTestFromString(AvoidReassigningParametersRuleTest.TEST5, 0, rule);        runTestFromString(AvoidReassigningParametersRuleTest.TEST6, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethodRule;import net.sourceforge.pmd.cpd.CPD;public class ConstructorCallsOverridableMethodRuleTest extends RuleTst {    private static final String TEST1 =    "public class ConstructorCallsOverridableMethodRule1 {" + CPD.EOL +    " public ConstructorCallsOverridableMethodRule1() {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    " public void foo() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class ConstructorCallsOverridableMethodRule2 {" + CPD.EOL +    " public ConstructorCallsOverridableMethodRule2() {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    " protected void foo() {}" + CPD.EOL +    "}";    private static final String TEST3 =    "public class ConstructorCallsOverridableMethodRule3 {" + CPD.EOL +    " public ConstructorCallsOverridableMethodRule3() {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    " void foo() {}" + CPD.EOL +    "}";    private static final String TEST4 =    "public class ConstructorCallsOverridableMethodRule4 {" + CPD.EOL +    " public ConstructorCallsOverridableMethodRule4() {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    " private void foo() {}" + CPD.EOL +    "}";    private static final String TEST5 =    "public class ConstructorCallsOverridableMethodRule5 {" + CPD.EOL +    " public ConstructorCallsOverridableMethodRule5() {" + CPD.EOL +    "  this(\"Bar\");" + CPD.EOL +    " }" + CPD.EOL +    " private ConstructorCallsOverridableMethodRule5(String bar) {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    " public void foo() {}" + CPD.EOL +    "}";    public void testCallsPublic() throws Throwable {        runTestFromString(TEST1, 1, new ConstructorCallsOverridableMethodRule());    }    public void testCallsProtected() throws Throwable {        runTestFromString(TEST2, 1, new ConstructorCallsOverridableMethodRule());    }    public void testCallsPackage() throws Throwable {        runTestFromString(TEST3, 1, new ConstructorCallsOverridableMethodRule());    }    public void testCallsPrivateMethodOK() throws Throwable {        runTestFromString(TEST4, 0, new ConstructorCallsOverridableMethodRule());    }    public void testCallsPrivateConstructor() throws Throwable {        runTestFromString(TEST5, 1, new ConstructorCallsOverridableMethodRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.DuplicateImportsRule;import net.sourceforge.pmd.cpd.CPD;public class DuplicateImportsRuleTest extends RuleTst {    private static final String TEST1 =    "import java.io.File;" + CPD.EOL +    "import java.util.*;" + CPD.EOL +    "import java.io.File;" + CPD.EOL +    "" + CPD.EOL +    "public class DuplicateImports {}";    private static final String TEST2 =    "import java.io.*;" + CPD.EOL +    "import java.io.*;" + CPD.EOL +    "" + CPD.EOL +    "public class DuplicateImports2 {}";    private static final String TEST3 =    "import java.util.*;" + CPD.EOL +    "import java.net.*;" + CPD.EOL +    "import java.io.*;" + CPD.EOL +    "import java.io.File;" + CPD.EOL +    "" + CPD.EOL +    "public class DuplicateImports3 {}";    private static final String TEST4 =    "import javax.servlet.*;" + CPD.EOL +    "import javax.servlet.http.*;" + CPD.EOL +    "" + CPD.EOL +    "public class DuplicateImports4 {}";    private DuplicateImportsRule rule;    public void setUp() {        rule = new DuplicateImportsRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 1, rule);    }    public void test4() throws Throwable {        runTestFromString(TEST4, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class EmptyTryBlockRuleTest extends RuleTst {    private static final String TEST1 =    "public class EmptyTryBlock1 {" + CPD.EOL +    "       public void foo() {" + CPD.EOL +    "               try {" + CPD.EOL +    "               } catch (Exception e) {" + CPD.EOL +    "                       e.printStackTrace();" + CPD.EOL +    "               }" + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class EmptyTryBlock2 {" + CPD.EOL +    "       public void foo() {" + CPD.EOL +    "               try {" + CPD.EOL +    "               } finally {" + CPD.EOL +    "                       int x = 5;" + CPD.EOL +    "               }" + CPD.EOL +    "       }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class EmptyTryBlock3 {" + CPD.EOL +    "       public void foo() {" + CPD.EOL +    "               try {" + CPD.EOL +    "                       int f =2;" + CPD.EOL +    "               } finally {" + CPD.EOL +    "                       int x = 5;" + CPD.EOL +    "               }" + CPD.EOL +    "       }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//TryStatement/Block[1][count(*) = 0]");    }    public void testEmptyTryBlock1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testEmptyTryBlock2() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void testEmptyTryBlock3() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.UnnecessaryConversionTemporaryRule;public class UnnecessaryTemporariesRuleTest extends RuleTst {    private static final String TEST1 =    " public class UnnecessaryTemporary1 {" + CPD.EOL +    "     void method (int x) {" + CPD.EOL +    "        new Integer(x).toString(); " + CPD.EOL +    "        new Long(x).toString(); " + CPD.EOL +    "        new Float(x).toString(); " + CPD.EOL +    "        new Byte((byte)x).toString(); " + CPD.EOL +    "        new Double(x).toString(); " + CPD.EOL +    "        new Short((short)x).toString(); " + CPD.EOL +    "     }" + CPD.EOL +    " }";    public void testSimple() throws Throwable {        runTestFromString(TEST1, 6, new UnnecessaryConversionTemporaryRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class ReturnFromFinallyBlockTest extends RuleTst {    private static final String TEST1 =    "public class ReturnFromFinallyBlock1 {" + CPD.EOL +    " public String bugga() {" + CPD.EOL +    "  try {" + CPD.EOL +    "   throw new Exception( \"My Exception\" );" + CPD.EOL +    "  } catch (Exception e) {" + CPD.EOL +    "   throw e;" + CPD.EOL +    "  } finally {" + CPD.EOL +    "   return \"A. O. K.\"; // Very bad." + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}" + CPD.EOL +    "";    private static final String TEST2 =    "public class ReturnFromFinallyBlock2 {" + CPD.EOL +    " public String getBar() {" + CPD.EOL +    "  try {" + CPD.EOL +    "   return \"buz\";" + CPD.EOL +    "  } catch (Exception e) {" + CPD.EOL +    "   return \"biz\";" + CPD.EOL +    "  } finally {" + CPD.EOL +    "   return \"fiddle!\"; // bad!" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "} ";    private static final String TEST3 =    "public class ReturnFromFinallyBlock3 {" + CPD.EOL +    " public String getBar() {" + CPD.EOL +    "  try {" + CPD.EOL +    "   return \"buz\";" + CPD.EOL +    "  } finally {" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "} ";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//TryStatement[@Finally='true']/Block[position() = last()]//ReturnStatement");    }    public void testThrowExceptionButReturnFromFinally() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testLotsOfReturns() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void testOK() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class StringInstantiationRuleTest extends RuleTst {    private static final String TEST1 =    "public class StringInstantiation1 {" + CPD.EOL +    " private String bar = new String(\"bar\");" + CPD.EOL +    " private String baz = new String();" + CPD.EOL +    "}";    private static final String TEST2 =    "public class StringInstantiation2 {" + CPD.EOL +    " private String[] bar = new String[5];" + CPD.EOL +    "}";    private static final String TEST3 =    "public class StringInstantiation3 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  byte[] bytes = new byte[50];" + CPD.EOL +    "  String bar = new String(bytes, 0, bytes.length);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class StringInstantiation4 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  byte[] bytes = new byte[50];" + CPD.EOL +    "  String bar = new String(bytes, 0, bytes.length, \"some-encoding\");" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//AllocationExpression[Name/@Image='String'][count(.//Expression) < 2][not(ArrayDimsAndInits)]");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 2, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void test4() throws Throwable {        runTestFromString(TEST4, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.StringToStringRule;public class StringToStringRuleTest extends RuleTst {    private static final String TEST1 =    "public class StringToString1 {" + CPD.EOL +    " private String baz() {" + CPD.EOL +    "  String bar = \"howdy\";" + CPD.EOL +    "  return bar.toString();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class StringToString2 {" + CPD.EOL +    " private String baz(String bar) {" + CPD.EOL +    "  return bar.toString();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class StringToString3 {" + CPD.EOL +    " private String baz;" + CPD.EOL +    " private int getBaz() {" + CPD.EOL +    "  return baz.toString();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class StringToString4 {" + CPD.EOL +    " private int baz;" + CPD.EOL +    " private int getBaz() {" + CPD.EOL +    "  return baz;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class StringToString5 {" + CPD.EOL +    " private String getBaz(String foo, StringBuffer buffer) {" + CPD.EOL +    "  return buffer.toString();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public class StringToString6 {" + CPD.EOL +    " private String getBaz() {" + CPD.EOL +    "  String[] foo = {\"hi\"};" + CPD.EOL +    "  return foo[0].toString();" + CPD.EOL +    " }" + CPD.EOL +    "}";    public void testLocalVar() throws Throwable {        runTestFromString(TEST1, 1, new StringToStringRule());    }    public void testParam() throws Throwable {        runTestFromString(TEST2, 1, new StringToStringRule());    }    public void testInstanceVar() throws Throwable {        runTestFromString(TEST3, 1, new StringToStringRule());    }    public void testPrimitiveType() throws Throwable {        runTestFromString(TEST4, 0, new StringToStringRule());    }    public void testMultipleSimilarParams() throws Throwable {        runTestFromString(TEST5, 0, new StringToStringRule());    }    public void testStringArray() throws Throwable {        runTestFromString(TEST6, 1, new StringToStringRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.UnusedPrivateMethodRule;public class UnusedPrivateMethodRuleTest extends SimpleAggregatorTst {    private UnusedPrivateMethodRule rule;    public void setUp() {        rule = new UnusedPrivateMethodRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "private method called by public method", 0, rule),           new TestDescriptor(TEST2, "simple unused private method", 1, rule),           new TestDescriptor(TEST3, "anonymous inner class calls private method", 0, rule),           new TestDescriptor(TEST4, "two private methods with same name but different parameters", 1, rule),           new TestDescriptor(TEST5, "calling private method after instantiating new copy of myself", 0, rule),           new TestDescriptor(TEST6, "calling private method using 'this' modifier", 0, rule),       });    }    private static final String TEST1 =    "public class UnusedPrivateMethod1 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    " private void foo() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class UnusedPrivateMethod2 {" + CPD.EOL +    " private void foo() {}" + CPD.EOL +    "}";    private static final String TEST3 =    "public class UnusedPrivateMethod3 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  new Runnable() {" + CPD.EOL +    "   public void run() {" + CPD.EOL +    "    foo();" + CPD.EOL +    "   }" + CPD.EOL +    "  };" + CPD.EOL +    " }" + CPD.EOL +    "" + CPD.EOL +    " private void foo() {}" + CPD.EOL +    "}";    private static final String TEST4 =    "public class UnusedPrivateMethod4 {" + CPD.EOL +    " private void foo() {}" + CPD.EOL +    " private void foo(String baz) {}" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  foo();" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class UnusedPrivateMethod5 {" + CPD.EOL +    " private void foo(String[] args) {}" + CPD.EOL +    " public static void main(String[] args) {" + CPD.EOL +    "  UnusedPrivateMethod5 u = new UnusedPrivateMethod5();" + CPD.EOL +    "  u.foo(args); " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public class UnusedPrivateMethod6 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  this.foo();" + CPD.EOL +    " }" + CPD.EOL +    " private void foo() {}" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.AvoidReassigningParametersRule;import net.sourceforge.pmd.cpd.CPD;public class AvoidReassigningParametersRuleTest extends RuleTst {    public static final String TEST1 =    "public class AvoidReassigningParameters1 {" + CPD.EOL +    " private void foo(String bar) {" + CPD.EOL +    "  bar = \"something else\";" + CPD.EOL +    " }" + CPD.EOL +    "}";    public static final String TEST2 =    "public class AvoidReassigningParameters2 {" + CPD.EOL +    " private void foo(String bar) {}" + CPD.EOL +    "}";    public static final String TEST3 =    "public class AvoidReassigningParameters3 {" + CPD.EOL +    " private int bar;" + CPD.EOL +    " private void foo(String bar) {" + CPD.EOL +    "  bar = \"hi\";" + CPD.EOL +    " }" + CPD.EOL +    "}";    public static final String TEST4 =    "public class AvoidReassigningParameters4 {" + CPD.EOL +    " private int bar;" + CPD.EOL +    " private void foo(String bar) {" + CPD.EOL +    "  this.bar = \"hi\";" + CPD.EOL +    " }" + CPD.EOL +    "}";    public static final String TEST5 =    "public class AvoidReassigningParameters5 {" + CPD.EOL +    "" + CPD.EOL +    " private class Foo {" + CPD.EOL +    "  public String bar;" + CPD.EOL +    " }" + CPD.EOL +    "" + CPD.EOL +    " private void foo(String bar) {" + CPD.EOL +    "  Foo f = new Foo();" + CPD.EOL +    "  f.bar = bar;" + CPD.EOL +    " }" + CPD.EOL +    "}";    public static final String TEST6 =    "import java.awt.*;" + CPD.EOL +    "" + CPD.EOL +    "public class AvoidReassigningParameters6 {" + CPD.EOL +    " private void foo(GridBagConstraints gbc) {" + CPD.EOL +    "  gbc.gridx = 2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private AvoidReassigningParametersRule rule;    public void setUp() {        rule = new AvoidReassigningParametersRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testSimple() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testNoUsage() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testInstanceVarSameNameAsParam() throws Throwable {        runTestFromString(TEST3, 1, rule);    }    public void testQualifiedNameInstanceVarSameAsParam() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void testQualifiedNameSameAsParam() throws Throwable {        runTestFromString(TEST5, 0, rule);    }    public void testAssignmentToParametersField() throws Throwable {        runTestFromString(TEST6, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class IfStmtsMustUseBracesRuleTest extends RuleTst {    private static final String TEST1 =    "public class IfStmtsMustUseBraces1 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  int x = 0;   " + CPD.EOL +    "  if (true) x=2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class IfStmtsMustUseBraces2 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  if (true) {" + CPD.EOL +    "   int x=2;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class IfStmtsMustUseBraces3 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  if (true) {" + CPD.EOL +    "   if (true) bar();" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//IfStatement[count(*) < 3][not(Statement/Block)]");    }    public void testSimpleBad() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testSimpleOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testNexted() throws Throwable {        runTestFromString(TEST3, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.CouplingBetweenObjectsRule;public class CouplingBetweenObjectsRuleTest extends RuleTst {    private static final String TEST1 =    "import java.util.*;" + CPD.EOL +    "" + CPD.EOL +    "public class CouplingBetweenObjects1 {" + CPD.EOL +    " public List foo() {return null;}" + CPD.EOL +    " public ArrayList foo() {return null;}" + CPD.EOL +    " public Vector foo() {return null;}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class CouplingBetweenObjects2 {" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new CouplingBetweenObjectsRule();        rule.addProperty("threshold", "2");    }    public void testSimpleBad() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testSimpleOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class ShortMethodNameRuleTest extends RuleTst {    private static final String TEST1 =    "public class ShortMethodName0 {" + CPD.EOL +    "    public int abcd( int i ) {" + CPD.EOL +    "       // Should not violate." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class ShortMethodName1 {" + CPD.EOL +    "    public int a( int i ) {" + CPD.EOL +    "       // Should violate." + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class ShortMethodName2 {" + CPD.EOL +    "    public int a( int i ) {" + CPD.EOL +    "       // Should violate" + CPD.EOL +    "    }" + CPD.EOL +    "" + CPD.EOL +    "    public int b( int i ) {" + CPD.EOL +    "       // Should violate" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class ShortMethodName3 {" + CPD.EOL +    "    public int a( int i ) {" + CPD.EOL +    "       // Should violate" + CPD.EOL +    "    }" + CPD.EOL +    "" + CPD.EOL +    "    public int bcde( int i ) {" + CPD.EOL +    "       // Should not violate" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//MethodDeclarator[string-length(@Image) < 3]");    }    public void testShortMethodName0() throws Throwable {        runTestFromString(TEST1, 0, rule);    }    public void testShortMethodName1() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void testShortMethodName2() throws Throwable {        runTestFromString(TEST3, 2, rule);    }    public void testShortMethodName3() throws Throwable {        runTestFromString(TEST4, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class UnusedModifierRuleTest extends RuleTst {    private static final String TEST1 =    "public interface UnusedModifier1 {" + CPD.EOL +    " public void bar();" + CPD.EOL +    "}";    private static final String TEST2 =    "public abstract class UnusedModifier2 {" + CPD.EOL +    " public abstract void bar();" + CPD.EOL +    "}";    private static final String TEST3 =    "public interface UnusedModifier3 {" + CPD.EOL +    " abstract void bar();" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//InterfaceDeclaration//MethodDeclaration[@Public='true' or @Abstract = 'true']");    }    public void testAbstract() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testAbstractClass() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testPublicAndAbstract() throws Throwable {        runTestFromString(TEST3, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class EmptyCatchBlockRuleTest extends RuleTst {    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty(            "xpath",            "//TryStatement[@Catch='true']"                + "/Block"                + "[position() > 1]"                + "[count(*) = 0]"                + "[../@Finally='false' or following-sibling::Block]");    }    public void testSimple() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testNotEmpty() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testNoCatchWithNestedCatchInFinally() throws Throwable {        runTestFromString(TEST3, 1, rule);    }    public void testMultipleCatchBlocks() throws Throwable {        runTestFromString(TEST4, 2, rule);    }    public void testEmptyTryAndFinally() throws Throwable {        runTestFromString(TEST5, 0, rule);    }    public static final String TEST1 =    "import java.io.*;" + CPD.EOL +    "public class EmptyCatchBlock {" + CPD.EOL +    "    public EmptyCatchBlock() {" + CPD.EOL +    "       try {" + CPD.EOL +    "               FileReader fr = new FileReader(\"/dev/null\");" + CPD.EOL +    "               // howdy" + CPD.EOL +    "       } catch (Exception e) {" + CPD.EOL +    "       }" + CPD.EOL +    "       try {" + CPD.EOL +    "               FileReader fr = new FileReader(\"/dev/null\");" + CPD.EOL +    "       } catch (Exception e) {" + CPD.EOL +    "               e.printStackTrace();" + CPD.EOL +    "               // this shouldn't show up on the report" + CPD.EOL +    "       }" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class EmptyCatchBlock2 {" + CPD.EOL +    "    public EmptyCatchBlock2() {" + CPD.EOL +    "       try {" + CPD.EOL +    "       } catch (RuntimeException e) {e.getMessage();}" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class EmptyCatchBlock3 {" + CPD.EOL +    " private void foo() {" + CPD.EOL +    "  try {" + CPD.EOL +    "  } finally {" + CPD.EOL +    "   try {" + CPD.EOL +    "    int x =2;" + CPD.EOL +    "   } catch (Exception e) {}" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class EmptyCatchBlock4 {" + CPD.EOL +    " private void foo() {" + CPD.EOL +    "  try {" + CPD.EOL +    "  } catch (Exception e) {" + CPD.EOL +    "  } catch (Throwable t) {" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class EmptyCatchBlock5 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  try {" + CPD.EOL +    "  } catch (Exception e) {" + CPD.EOL +    "   blah.blah();" + CPD.EOL +    "  } finally {}" + CPD.EOL +    " }" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.ExcessiveImportsRule;public class ExcessiveImportsRuleTest extends RuleTst {    private static final String TEST1 =    "import java.util.Vector;" + CPD.EOL +    "import java.util.Vector;" + CPD.EOL +    "import java.util.Vector;" + CPD.EOL +    "import java.util.Vector;" + CPD.EOL +    "import java.util.Vector;" + CPD.EOL +    "import java.util.Vector;" + CPD.EOL +    "" + CPD.EOL +    "public class ExcessiveImports1{}";    private static final String TEST2 =    "import java.util.Vector;" + CPD.EOL +    "" + CPD.EOL +    "public class ExcessiveImports2{}";    private Rule rule;    public void setUp() {        rule = new ExcessiveImportsRule();        rule.addProperty("minimum", "5");    }    public void testSimpleBad() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testSimpleOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class SwitchStmtsShouldHaveDefaultRuleTest extends RuleTst {    private static final String TEST1 =    "public class SwitchStmtsShouldHaveDefault1 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  switch (x) {" + CPD.EOL +    "   case 2: int y=8;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class SwitchStmtsShouldHaveDefault2 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  switch (x) {" + CPD.EOL +    "   case 2: int y=8;" + CPD.EOL +    "   default: int j=8;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//SwitchStatement[not(SwitchLabel[count(*) = 0])]");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class UnnecessaryConstructorRuleTest extends RuleTst {    private static final String TEST1 =    "public class UnnecessaryConstructor1 {" + CPD.EOL +    " public UnnecessaryConstructor1() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class UnnecessaryConstructor2 {" + CPD.EOL +    " private UnnecessaryConstructor2() {}" + CPD.EOL +    "}";    private static final String TEST3 =    "public class UnnecessaryConstructor3 {" + CPD.EOL +    " public UnnecessaryConstructor3(int x) {}" + CPD.EOL +    "}";    private static final String TEST4 =    "public class UnnecessaryConstructor4 {" + CPD.EOL +    " public UnnecessaryConstructor4() {  " + CPD.EOL +    "  int x = 2;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST5 =    "public class UnnecessaryConstructor5 {" + CPD.EOL +    " public UnnecessaryConstructor5() throws IOException {  " + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST6 =    "public class UnnecessaryConstructor6 {" + CPD.EOL +    " public UnnecessaryConstructor6() {" + CPD.EOL +    " }" + CPD.EOL +    " public UnnecessaryConstructor6(String foo) {}" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//ConstructorDeclaration[1][count(//ConstructorDeclaration)=1][@Public='true'][not(FormalParameters/*)][not(BlockStatement)][not(NameList)]");    }    public void testSimpleFailureCase() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testPrivate() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testHasArgs() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void testHasBody() throws Throwable {        runTestFromString(TEST4, 0, rule);    }    public void testHasExceptions() throws Throwable {        runTestFromString(TEST5, 0, rule);    }    public void testMultipleConstructors() throws Throwable {        runTestFromString(TEST6, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class EmptyWhileStmtRuleTest extends RuleTst {    private static final String TEST1 =    "public class EmptyWhileStmtRule {" + CPD.EOL +    "    public EmptyWhileStmtRule() {" + CPD.EOL +    "       while (true == true) {" + CPD.EOL +    "       }" + CPD.EOL +    "       while (true == true) {" + CPD.EOL +    "               String x = \"\";" + CPD.EOL +    "       }" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//WhileStatement/Statement/Block[count(*) = 0]");    }    public void testEmptyWhileStmtRule() throws Throwable {        runTestFromString(TEST1, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class EmptyIfStmtRuleTest extends RuleTst {    private static final String TEST1 =    "public class EmptyIfStmtRule {" + CPD.EOL +    "    public EmptyIfStmtRule() {" + CPD.EOL +    "       if (null == null) {" + CPD.EOL +    "       }" + CPD.EOL +    "       if (null != null) {" + CPD.EOL +    "               this.toString();" + CPD.EOL +    "       }" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//IfStatement/Statement/Block[count(*) = 0]");    }    public void testOneEmptyOneNotEmpty() throws Throwable {        runTestFromString(TEST1, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class WhileLoopsMustUseBracesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//WhileStatement[not(Statement/Block)]");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "no braces", 1, rule),           new TestDescriptor(TEST2, "with braces", 0, rule),       });    }    private static final String TEST1 =    "public class WhileLoopsNeedBraces1 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  int x =0;" + CPD.EOL +    "  while (true)" + CPD.EOL +    "   x++;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class WhileLoopsNeedBraces2 {" + CPD.EOL +    " public void foo() {   " + CPD.EOL +    "  int x =0;" + CPD.EOL +    "  while (true) {" + CPD.EOL +    "   x++;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.UnusedImportsRule;public class UnusedImportsRuleTest extends RuleTst {    private static final String TEST1 =    "import java.io.File;" + CPD.EOL +    "public class UnusedImports1 {}";    private static final String TEST2 =    "import java.io.File;" + CPD.EOL +    "public class UnusedImports2 {" + CPD.EOL +    " private File file;" + CPD.EOL +    "}";    private static final String TEST3 =    "import java.io.File;" + CPD.EOL +    "import java.util.List;" + CPD.EOL +    "public class UnusedImports3 {" + CPD.EOL +    "}";    private static final String TEST4 =    "import java.security.AccessController;" + CPD.EOL +    "public class UnusedImports4 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  AccessController.doPrivileged(null);" + CPD.EOL +    " }" + CPD.EOL +    "}";    private UnusedImportsRule rule;    public void setUp() {        rule = new UnusedImportsRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 2, rule);    }    public void test4() throws Throwable {        runTestFromString(TEST4, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;public class TestDescriptor {    public String code;    public String description;    public int numberOfProblemsExpected;    public Rule rule;    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class SimplifyBooleanExpressionsRuleTest extends RuleTst {    private static final String TEST1 =    "public class SimplifyBooleanExpressions1 {" + CPD.EOL +    " private boolean foo = (isFoo() == true);" + CPD.EOL +    " public boolean isFoo() {return foo;}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class SimplifyBooleanExpressions2 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  boolean bar = (new String().length() >2) == false;" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class SimplifyBooleanExpressions3 {" + CPD.EOL +    " boolean bar = true;" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//Expression/ConditionalAndExpression/InstanceOfExpression[position()>1]/PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral");    }    public void testInFieldAssignment() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testInMethodBody() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void testOK() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class EmptyFinallyBlockRuleTest extends RuleTst {    private static final String TEST1 =    "public class EmptyFinallyBlock1 {" + CPD.EOL +    "    public void foo() {" + CPD.EOL +    "       try {" + CPD.EOL +    "       } catch (Exception e) {} finally {}" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class EmptyFinallyBlock2 {" + CPD.EOL +    "    public void foo() {" + CPD.EOL +    "       try {" + CPD.EOL +    "       } finally {}" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class EmptyFinallyBlock3 {" + CPD.EOL +    "    public void foo() {" + CPD.EOL +    "       try {" + CPD.EOL +    "       } finally {int x =2;}" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST4 =    "public class EmptyFinallyBlock4 {" + CPD.EOL +    " public void foo() {" + CPD.EOL +    "  try {" + CPD.EOL +    "  } catch (IOException e ){" + CPD.EOL +    "  } catch (Exception e ) {" + CPD.EOL +    "  } catch (Throwable t ) {" + CPD.EOL +    "  } finally{" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty(            "xpath",            "//TryStatement[@Finally='true']/Block[position() = last()][count(*) = 0]");    }    public void testEmptyFinallyBlock1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testEmptyFinallyBlock2() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void testEmptyFinallyBlock3() throws Throwable {        runTestFromString(TEST3, 0, rule);    }    public void testMultipleCatchBlocksWithFinally() throws Throwable {        runTestFromString(TEST4, 1, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule;public class AvoidDeeplyNestedIfStmtsRuleTest extends RuleTst {    public static final String TEST1 =    "public class AvoidDeeplyNestedIfStmtsRule1 {" + CPD.EOL +    " public void bar() { " + CPD.EOL +    "  int x=2; " + CPD.EOL +    "  int y=3; " + CPD.EOL +    "  int z=4; " + CPD.EOL +    "  if (x>y) { " + CPD.EOL +    "   if (y>z) { " + CPD.EOL +    "    if (z==x) { " + CPD.EOL +    "     // this is officially out of control now " + CPD.EOL +    "    } " + CPD.EOL +    "   } " + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    public static final String TEST2 =    "public class AvoidDeeplyNestedIfStmtsRule2 {" + CPD.EOL +    " public void bar() { " + CPD.EOL +    "  if (true) {" + CPD.EOL +    "  } else if (true) {" + CPD.EOL +    "  } else if (true) {" + CPD.EOL +    "  } else {" + CPD.EOL +    "    // this ain't good code, but it shouldn't trigger this rule" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new AvoidDeeplyNestedIfStmtsRule();        rule.addProperty("problemDepth", "3");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class EmptySwitchStmtRuleTest extends RuleTst {    private static final String TEST1 =    "public class EmptySwitchStmt1 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  switch (x) {}" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class EmptySwitchStmt2 {" + CPD.EOL +    " public void bar() {" + CPD.EOL +    "  int x = 2;" + CPD.EOL +    "  switch (x) {" + CPD.EOL +    "   case 2: int y=4;" + CPD.EOL +    "  }" + CPD.EOL +    " }" + CPD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//SwitchStatement[count(*) = 1]");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.ImportFromSamePackageRule;import net.sourceforge.pmd.cpd.CPD;public class ImportFromSamePackageRuleTest extends RuleTst {    private static final String TEST1 =    "package foo;" + CPD.EOL +    "import foo.Bar;" + CPD.EOL +    "public class ImportFromSamePackage1{}";    private static final String TEST2 =    "package foo;" + CPD.EOL +    "import foo.buz.Bar;" + CPD.EOL +    "public class ImportFromSamePackage2{}";    private static final String TEST3 =    "import java.util.*;" + CPD.EOL +    "public class ImportFromSamePackage3{}";    private static final String TEST4 =    "package bar;" + CPD.EOL +    "import Foo;" + CPD.EOL +    "public class ImportFromSamePackage4{}";    private static final String TEST5 =    "import Foo;" + CPD.EOL +    "public class ImportFromSamePackage5{}";    private static final String TEST6 =    "package foo.bar;" + CPD.EOL +    "import foo.bar.baz.*;" + CPD.EOL +    "public class ImportFromSamePackage6{}";    public void testSimple() throws Throwable {        runTestFromString(TEST1, 1, new ImportFromSamePackageRule());    }    public void testDefaultPackageImportingFromSubPackage() throws Throwable {        runTestFromString(TEST2, 0, new ImportFromSamePackageRule());    }    public void testClassInDefaultPackageImportingFromOtherPackage() throws Throwable {        runTestFromString(TEST3, 0, new ImportFromSamePackageRule());    }    public void testClassNotInDefaultPackageImportingFromDefaultPackage() throws Throwable {        runTestFromString(TEST4, 0, new ImportFromSamePackageRule());    }    public void testClassInDefaultPackageImportingFromDefaultPackage() throws Throwable {        runTestFromString(TEST5, 1, new ImportFromSamePackageRule());    }    public void testImportingFromSubPackage() throws Throwable {        runTestFromString(TEST6, 0, new ImportFromSamePackageRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.XPathRule;public class DontImportJavaLangRuleTest extends RuleTst {    private static final String TEST1 =    "import java.lang.String;" + CPD.EOL +    "" + CPD.EOL +    "public class DontImportJavaLang1 {}";    private static final String TEST2 =    "import java.lang.*;" + CPD.EOL +    "" + CPD.EOL +    "public class DontImportJavaLang2 {}";    private static final String TEST3 =    "import java.lang.ref.*;" + CPD.EOL +    "import java.lang.reflect.*;" + CPD.EOL +    "" + CPD.EOL +    "public class DontImportJavaLang3 {}";    private Rule rule;    public void setUp() {        rule = new XPathRule();        rule.addProperty("xpath", "//ImportDeclaration"                + "[starts-with(Name/@Image, 'java.lang')]"                + "[not(starts-with(Name/@Image, 'java.lang.ref'))]"                + "[not(starts-with(Name/@Image, 'java.lang.reflect'))]");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 1, rule);    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.rules.CyclomaticComplexityRule;import java.util.Iterator;public class CyclomaticComplexityRuleTest extends RuleTst {    private CyclomaticComplexityRule rule = new CyclomaticComplexityRule();    public void setUp() {        rule.setMessage("The {0} ''{1}'' has a Cyclomatic Complexity of {2}.");    }    public void testOneMethod() throws Throwable {        rule.addProperty("reportLevel", "1");        Report report = new Report();        runTestFromString(TEST1, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);    }    public void testNastyComplicatedMethod() throws Throwable {        rule.addProperty("reportLevel", "10");        Report report = new Report();        runTestFromString(TEST2, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 12") != -1);    }    public void testConstructor() throws Throwable {        rule.addProperty("reportLevel", "1");        Report report = new Report();        runTestFromString(TEST3, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);    }    public void testLessComplicatedThanReportLevel() throws Throwable {        rule.addProperty("reportLevel", "10");        Report report = new Report();        runTestFromString(TEST1, rule, report);        assertEquals(0, report.size());    }    private static final String TEST1 =    "public class CyclomaticComplexity1 {" + CPD.EOL +    " public void foo() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class CyclomaticComplexity2 {" + CPD.EOL +    " public void example() {" + CPD.EOL +    "  int x = 0;" + CPD.EOL +    "  int a = 0;" + CPD.EOL +    "  int b = 0;" + CPD.EOL +    "  int c = 0;" + CPD.EOL +    "  int d = 0;" + CPD.EOL +    "  int a1 = 0;" + CPD.EOL +    "  int a2 = 0;" + CPD.EOL +    "  int b1 = 0;" + CPD.EOL +    "  int b2 = 0;" + CPD.EOL +    "  int z = 0;" + CPD.EOL +    "  int h = 0;" + CPD.EOL +    "  int e = 0;" + CPD.EOL +    "  int f = 0;" + CPD.EOL +    "" + CPD.EOL +    "  if (a == b) {" + CPD.EOL +    "   if (a1 == b1) {" + CPD.EOL +    "     x=2;" + CPD.EOL +    "   } else if (a2 == b2) {" + CPD.EOL +    "     x=2;" + CPD.EOL +    "   }" + CPD.EOL +    "            else" + CPD.EOL +    "            {" + CPD.EOL +    "                x=2;" + CPD.EOL +    "            }" + CPD.EOL +    "        }" + CPD.EOL +    "       else if (c == d)" + CPD.EOL +    "        {" + CPD.EOL +    "           while (c == d)" + CPD.EOL +    "            {" + CPD.EOL +    "                x=2;" + CPD.EOL +    "            }" + CPD.EOL +    "        }" + CPD.EOL +    "       else if (e == f)" + CPD.EOL +    "        {" + CPD.EOL +    "           for (int n = 0; n < h; n++)" + CPD.EOL +    "            {" + CPD.EOL +    "                x=2;" + CPD.EOL +    "            }" + CPD.EOL +    "        }" + CPD.EOL +    "        else" + CPD.EOL +    "        {" + CPD.EOL +    "            switch (z)" + CPD.EOL +    "            {" + CPD.EOL +    "               case 1:" + CPD.EOL +    "                x=2;" + CPD.EOL +    "                    break;" + CPD.EOL +    "" + CPD.EOL +    "              case 2:" + CPD.EOL +    "                x=2;" + CPD.EOL +    "                    break;" + CPD.EOL +    "" + CPD.EOL +    "              case 3:" + CPD.EOL +    "                x=2;" + CPD.EOL +    "                    break;" + CPD.EOL +    "" + CPD.EOL +    "              default:" + CPD.EOL +    "                x=2;" + CPD.EOL +    "                    break;" + CPD.EOL +    "            }" + CPD.EOL +    "        }" + CPD.EOL +    "    }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class CyclomaticComplexity3 {" + CPD.EOL +    " public CyclomaticComplexity3() {}" + CPD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.AtLeastOneConstructorRule;import net.sourceforge.pmd.cpd.CPD;public class AtLeastOneConstructorRuleTest extends RuleTst {    private static final String TEST1 =    "public class AtLeastOneConstructorRule1 {" + CPD.EOL +    " public AtLeastOneConstructorRule1() {}" + CPD.EOL +    "}";    private static final String TEST2 =    "public class AtLeastOneConstructorRule2 {" + CPD.EOL +    "}";    private static final String TEST3 =    "public class AtLeastOneConstructorRule3 {" + CPD.EOL +    " public class Foo {}" + CPD.EOL +    " public AtLeastOneConstructorRule3() {}" + CPD.EOL +    "}";    private static final String TEST4 =    "public class AtLeastOneConstructorRule4 {" + CPD.EOL +    " public class Foo { " + CPD.EOL +    "  public Foo() {}" + CPD.EOL +    " }" + CPD.EOL +    "}";    public void testSimpleOK() throws Throwable {        runTestFromString(TEST1, 0, new AtLeastOneConstructorRule());    }    public void testSimpleBad() throws Throwable {        runTestFromString(TEST2, 1, new AtLeastOneConstructorRule());    }    public void testNestedClassWithout() throws Throwable {        runTestFromString(TEST3, 1, new AtLeastOneConstructorRule());    }    public void testNestedClassWithOuterWithout() throws Throwable {        runTestFromString(TEST4, 1, new AtLeastOneConstructorRule());    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.AvoidDuplicateLiteralsRule;import net.sourceforge.pmd.cpd.CPD;public class AvoidDuplicateLiteralsRuleTest extends RuleTst {    public static final String TEST1 =    "public class AvoidDuplicateLiterals1 {" + CPD.EOL +    " private void bar() {" + CPD.EOL +    "    buz(\"Howdy\");" + CPD.EOL +    "    buz(\"Howdy\");" + CPD.EOL +    "    buz(\"Howdy\");" + CPD.EOL +    "    buz(\"Howdy\");" + CPD.EOL +    " }" + CPD.EOL +    " private void buz(String x) {}" + CPD.EOL +    "}";    public static final String TEST2 =    "public class AvoidDuplicateLiterals2 {" + CPD.EOL +    " private void bar() {" + CPD.EOL +    "    buz(2);" + CPD.EOL +    " }" + CPD.EOL +    " private void buz(int x) {}" + CPD.EOL +    "}";    public static final String TEST3 =    "public class AvoidDuplicateLiterals3 {" + CPD.EOL +    " private static final String FOO = \"foo\";" + CPD.EOL +    "}";    private AvoidDuplicateLiteralsRule rule;    public void setUp() {        rule = new AvoidDuplicateLiteralsRule();        rule.setMessage("avoid ''{0}'' and ''{1}''");        rule.addProperty("threshold", "2");    }    public void testTwoLiteralStringArgs() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testLiteralIntArg() throws Throwable {        runTestFromString(TEST2, 0, rule);    }    public void testLiteralFieldDecl() throws Throwable {        runTestFromString(TEST3, 0, rule);    }}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.AccessorClassGenerationRule;import net.sourceforge.pmd.cpd.CPD;public class AccessorClassGenerationRuleTest extends RuleTst {    private static final String TEST1 =    "public class Foo1 {" + CPD.EOL +    " public class InnerClass {" + CPD.EOL +    "   private InnerClass(){" + CPD.EOL +    "   }" + CPD.EOL +    " }" + CPD.EOL +    " void method(){" + CPD.EOL +    "   new InnerClass();//Causes generation of accessor" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST2 =    "public class Foo2 {" + CPD.EOL +    " public class InnerClass {" + CPD.EOL +    "   public InnerClass(){" + CPD.EOL +    "   }" + CPD.EOL +    " }" + CPD.EOL +    " void method(){" + CPD.EOL +    "   new InnerClass(); //OK, due to public constructor" + CPD.EOL +    " }" + CPD.EOL +    "}";    private static final String TEST3 =    "public class Foo3 {" + CPD.EOL +    "    public class InnerClass {" + CPD.EOL +    "      void method(){" + CPD.EOL +    "        new Foo3();//Causes generation of accessor" + CPD.EOL +    "      }" + CPD.EOL +    "    }" + CPD.EOL +    "    private Foo3(){" + CPD.EOL +    "    }" + CPD.EOL +    "}";    public void testInnerClassHasPrivateConstructor() throws Throwable {        runTestFromString(TEST1, 1, new AccessorClassGenerationRule());    }    public void testInnerClassHasPublicConstructor() throws Throwable {        runTestFromString(TEST2, 0, new AccessorClassGenerationRule());    }    public void testOuterClassHasPrivateConstructor() throws Throwable {        runTestFromString(TEST3, 1, new AccessorClassGenerationRule());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPPLanguage;import net.sourceforge.pmd.cpd.JavaLanguage;import net.sourceforge.pmd.cpd.LanguageFactory;public class LanguageFactoryTest extends TestCase {    public void testSimple() {        LanguageFactory f = new LanguageFactory();        assertTrue(f.createLanguage(LanguageFactory.JAVA_KEY) instanceof JavaLanguage);        assertTrue(f.createLanguage(LanguageFactory.CPP_KEY) instanceof CPPLanguage);        try {            f.createLanguage("fiddlesticks");            throw new RuntimeException("Should have thrown an exception!");        } catch (RuntimeException e) {            // cool        }    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.Mark;import net.sourceforge.pmd.cpd.Match;import java.util.Iterator;public class MatchTest extends TestCase  {    public void testSimple() {        Mark mark1 = new Mark(1, "/var/Foo.java", 1, 1);        Mark mark2 = new Mark(2, "/var/Foo.java", 2, 1);        Match match = new Match(1, mark1, mark2);        match.setSourceCodeSlice("public class Foo {}");        assertEquals("public class Foo {}", match.getSourceCodeSlice());        match.setLineCount(10);        assertEquals(10, match.getLineCount());        assertEquals(1, match.getTokenCount());        Iterator i = match.iterator();        assertEquals(mark1, i.next());        assertEquals(mark2, i.next());        assertFalse(i.hasNext());    }    public void testCompareTo() {        Match m1 = new Match(1, new Mark(1, "/var/Foo.java", 1, 1), new Mark(2, "/var/Foo.java", 2, 1));        Match m2 = new Match(2, new Mark(4, "/var/Foo.java", 4, 1), new Mark(5, "/var/Foo.java", 5, 1));        assertTrue(m2.compareTo(m1) < 0);    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;import java.io.StringReader;public class SourceCodeTest extends TestCase {    public void testSimple() throws Throwable {        String code = MatchAlgorithmTest.getSampleCode();        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("Foo.java");        assertEquals("Foo.java", sourceCode.getFileName());        tokenizer.tokenize(sourceCode, new Tokens(), new StringReader(code));        assertEquals(MatchAlgorithmTest.LINE_1, sourceCode.getSlice(0,0));        assertEquals(MatchAlgorithmTest.LINE_2, sourceCode.getSlice(1,1));        assertEquals(MatchAlgorithmTest.LINE_1 + CPD.EOL + MatchAlgorithmTest.LINE_2, sourceCode.getSlice(0,1));    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPDListener;import net.sourceforge.pmd.cpd.CPDNullListener;import net.sourceforge.pmd.cpd.Mark;import net.sourceforge.pmd.cpd.MarkComparator;import net.sourceforge.pmd.cpd.TokenEntry;import java.io.File;import java.util.ArrayList;import java.util.List;public class MarkComparatorTest extends TestCase {    private class MyListener implements CPDListener {        public void addedFile(int fileCount, File file) {        }        public void comparisonCountUpdate(long comparisons) {            gotCallback = true;        }    }    private boolean gotCallback;    public void testEqualMarksAreEqual() {        List code = getCode();        MarkComparator comp = new MarkComparator(new CPDNullListener(), code);        Mark mark1 = new Mark(code.size(), "/var/Foo.java", 0, 1);        Mark mark6 = new Mark(code.size(), "/var/Foo.java", 5, 1);        assertEquals(0, comp.compare(mark1, mark6));    }    public void testSameMarkIsEqual() {        List code = getCode();        MarkComparator comp = new MarkComparator(new CPDNullListener(), code);        Mark mark1 = new Mark(code.size(), "/var/Foo.java", 0, 1);        assertEquals(0, comp.compare(mark1, mark1));    }    public void testUnuequalMarksAreUnequal() {        List code = getCode();        MarkComparator comp = new MarkComparator(new CPDNullListener(), code);        Mark mark1 = new Mark(0, "/var/Foo.java", 0, 1);        Mark mark5 = new Mark(4, "/var/Foo.java", 4, 1);        assertFalse(0 == comp.compare(mark1, mark5));    }    public void testcomparisonCountCallback() {        gotCallback = false;        List code = getCode();        MarkComparator comp = new MarkComparator(new MyListener(), code, 3);        Mark mark1 = new Mark(code.size(), "/var/Foo.java", 0, 1);        Mark mark2 = new Mark(code.size(), "/var/Foo.java", 1, 1);        comp.compare(mark1, mark2);        comp.compare(mark1, mark2);        comp.compare(mark1, mark2);        assertTrue(gotCallback);    }    public void test1() {}    private List getCode() {        List code = new ArrayList();        TokenEntry te1 = new TokenEntry("System", 0, "/var/Foo.java", 1);        TokenEntry te2 = new TokenEntry(".", 1, "/var/Foo.java", 1);        TokenEntry te3 = new TokenEntry("out", 2, "/var/Foo.java", 1);        TokenEntry te4 = new TokenEntry(".", 3, "/var/Foo.java", 1);        TokenEntry te5 = new TokenEntry("println", 4, "/var/Foo.java", 1);        TokenEntry te6 = new TokenEntry("System", 5, "/var/Foo.java", 1);        code.add(te1);        code.add(te2);        code.add(te3);        code.add(te4);        code.add(te5);        code.add(te6);        return code;    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;import java.io.StringReader;public class JavaTokensTokenizerTest extends TestCase {    private static final String EOL = System.getProperty("line.separator", "\n");    public void test1() throws Throwable {        Tokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "public class Foo {}";        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens, new StringReader(data));        assertEquals(6, tokens.size());        assertEquals("public class Foo {}", sourceCode.getSlice(0, 0));    }    public void test2() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "public class Foo {" + EOL + "public void bar() {}" + EOL + "public void buz() {}" + EOL + "}";        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens, new StringReader(data));        assertEquals("public class Foo {" + EOL + "public void bar() {}", sourceCode.getSlice(0, 1));    }    public void testDiscardSemicolons() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "public class Foo {private int x;}";        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens, new StringReader(data));        assertEquals(9, tokens.size());    }    public void testDiscardImports() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "import java.io.File;" + EOL + "public class Foo {}";        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens, new StringReader(data));        assertEquals(6, tokens.size());    }    public void testDiscardPkgStmts() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "package foo.bar.baz;" + EOL + "public class Foo {}";        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens, new StringReader(data));        assertEquals(6, tokens.size());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.FileReporter;import net.sourceforge.pmd.cpd.ReportException;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;/** * @author  Philippe T'Seyen */public class FileReporterTest extends TestCase{  public void testCreation() {    try {      FileReporter fileReporter = new FileReporter(null);      fail("expected NullPointerException");    } catch (NullPointerException npe) {    }  }  public void testEmptyReport() throws ReportException {    File reportFile = new File("report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    fileReporter.report("");    assertTrue(reportFile.exists());    assertEquals(0, reportFile.length());    assertTrue(reportFile.delete());  }  public void testReport() throws ReportException, IOException {    String testString = "first line\nsecond line";    File reportFile = new File("report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    fileReporter.report(testString);    assertEquals(testString, readFile(reportFile));    assertTrue(reportFile.delete());  }  public void testInvalidFile() {    File reportFile = new File("/invalid_folder/report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    try {      fileReporter.report("");      fail("expected ReportException");    } catch (ReportException re) {    }  }  private String readFile(File file) throws IOException {    BufferedReader reader = null;    try {      reader = new BufferedReader(new FileReader(file));      StringBuffer buffer = new StringBuffer();      String line = reader.readLine();      while (line != null) {        buffer.append(line);        line = reader.readLine();        if (line != null) {          buffer.append("\n");        }      }      return buffer.toString();    } finally {      if (reader != null) reader.close();    }  }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.Mark;public class MarkTest extends TestCase {    public void testSimple() {        Mark mark = new Mark(0, "/var/Foo.java", 10, 1);        assertEquals(mark.getIndexIntoFile(), 10);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndexIntoTokenArray());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.Mark;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.MatchAlgorithm;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;import java.io.StringReader;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class MatchAlgorithmTest extends TestCase {    public static final String LINE_1 = "public class Foo { ";    public static final String LINE_2 = " public void bar() {";    public static final String LINE_3 = "  System.out.println(\"hello\");";    public static final String LINE_4 = " System.out.println(\"hello\");";    public static final String LINE_5 = " }";    public static final String LINE_6 = "}";    public static String getSampleCode() {        return            LINE_1 + CPD.EOL +            LINE_2 + CPD.EOL +            LINE_3 + CPD.EOL +            LINE_4 + CPD.EOL +            LINE_5 + CPD.EOL +            LINE_6;    }    public void testSimple() throws Throwable {        String code = getSampleCode();        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("Foo.java");        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens, new StringReader(code));        assertEquals(29, tokens.size());        Map codeMap = new HashMap();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens);        matchAlgorithm.findMatches(5);        Iterator matches = matchAlgorithm.matches();        Match match = (Match)matches.next();        assertFalse(matches.hasNext());        Iterator marks = match.iterator();        Mark mark1 = (Mark)marks.next();        Mark mark2 = (Mark)marks.next();        assertTrue(!marks.hasNext());        assertEquals(2, mark2.getBeginLine());        assertEquals(3, mark1.getBeginLine());        assertTrue("Foo.java" == mark1.getTokenSrcID() && "Foo.java" == mark2.getTokenSrcID());        assertEquals(LINE_3, match.getSourceCodeSlice());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.*;import java.util.ArrayList;import java.util.List;/** * @author  Philippe T'Seyen */public class XMLRendererTest extends TestCase{  public void testRender_NoMatches()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd></pmd-cpd>", report);  }  public void testRender_Match()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    Match match = new Match(75, new Mark(1, "/var/Foo.java", 1, 48), new Mark(2, "/var/Foo.java", 2, 73));    match.setLineCount(6);    match.setSourceCodeSlice("code fragment");    list.add(match);    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd><duplication lines=\"6\" tokens=\"75\"><file line=\"48\" path=\"/var/Foo.java\"/><file line=\"73\" path=\"/var/Foo.java\"/><codefragment><![CDATA[" + CPD.EOL + "code fragment" + CPD.EOL + "]]></codefragment></duplication></pmd-cpd>", report);  }  public void testRender_MultipleMatch()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    Match match1 = new Match(75, new Mark(1, "/var/Foo.java", 1, 48), new Mark(2, "/var/Foo.java", 2, 73));    match1.setLineCount(6);    match1.setSourceCodeSlice("code fragment");    Match match2 = new Match(76, new Mark(2, "/var/Foo2.java", 2, 49), new Mark(3, "/var/Foo2.java", 3, 74));    match2.setLineCount(7);    match2.setSourceCodeSlice("code fragment 2");    list.add(match1);    list.add(match2);    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd><duplication lines=\"6\" tokens=\"75\"><file line=\"48\" path=\"/var/Foo.java\"/><file line=\"73\" path=\"/var/Foo.java\"/><codefragment><![CDATA[" + CPD.EOL + "code fragment" + CPD.EOL + "]]></codefragment></duplication><duplication lines=\"7\" tokens=\"76\"><file line=\"49\" path=\"/var/Foo2.java\"/><file line=\"74\" path=\"/var/Foo2.java\"/><codefragment><![CDATA[" + CPD.EOL + "code fragment 2" + CPD.EOL + "]]></codefragment></duplication></pmd-cpd>", report);  }}
package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.PathChecker;public class PathCheckerTest extends TestCase {    public void testPathCheckerRelativeWin() {        PathChecker pc = new PathChecker("Windows XP");        assertTrue(!pc.isAbsolute("foo\\bar.html"));    }    public void testPathCheckerAbsoluteWin() {        PathChecker pc = new PathChecker("Windows XP");        assertTrue(pc.isAbsolute("c:\\foo\\bar.html"));    }    public void testPathCheckerRelativeNix() {        PathChecker pc = new PathChecker("Linux");        assertTrue(!pc.isAbsolute("foo/bar.html"));    }    public void testPathCheckerAbsoluteNix() {        PathChecker pc = new PathChecker("Linux");        assertTrue(pc.isAbsolute("/var/www/html/report.html"));    }}
package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.ant.PMDTask;import org.apache.tools.ant.BuildException;public class PMDTaskTest extends TestCase {    public void testNoFormattersValidation() {        PMDTask task = new PMDTask();        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no Formatters");        } catch (BuildException be) {            // cool        }    }    public void testFormatterWithNoToFileAttribute() {        PMDTask task = new PMDTask();        task.addFormatter(new Formatter());        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - a Formatter was missing a toFile attribute");        } catch (BuildException be) {            // cool        }    }    public void testNoRuleSets() {        PMDTask task = new PMDTask();        task.setPrintToConsole(true);        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no rulesets");        } catch (BuildException be) {            // cool        }    }    public void testBogusRuleSet() {        PMDTask task = new PMDTask();        task.setPrintToConsole(true);        task.setRuleSetFiles("fiddlesticks");        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - bogus rulesets");        } catch (BuildException be) {            // cool        }    }}
package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;import org.apache.tools.ant.BuildException;public class FormatterTest extends TestCase {    public void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.getRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.getRenderer() instanceof TextRenderer);        f.setType("html");        assertTrue(f.getRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            throw new RuntimeException("Should have failed!");        } catch (BuildException be) {            // cool        }    }    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isToFileNull());        f.setToFile("foo");        assertFalse("Formatter toFile should not be null!", f.isToFileNull());    }}
package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.jaxen.Attribute;import net.sourceforge.pmd.jaxen.AttributeAxisIterator;public class AttributeAxisIteratorTest extends TestCase {    public void testRemove() {        SimpleNode n = new SimpleNode(0);        n.testingOnly__setBeginColumn(1);        n.testingOnly__setBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        try {            iter.remove();            fail("Should have thrown an exception!");        } catch (UnsupportedOperationException e) {            // cool        }    }    public void testNext() {        SimpleNode n = new SimpleNode(0);        n.testingOnly__setBeginLine(1);        n.testingOnly__setBeginColumn(2);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        Attribute a = (Attribute)iter.next();        assertEquals("BeginLine", a.getName());        assertEquals("1", a.getValue());        a = (Attribute)iter.next();        assertEquals("BeginColumn", a.getName());        assertEquals("2", a.getValue());        a = (Attribute)iter.next();        assertEquals("EndLine", a.getName());        assertEquals("0", a.getValue());        a = (Attribute)iter.next();        assertEquals("EndColumn", a.getName());        assertFalse(iter.hasNext());    }}
package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.jaxen.Attribute;public class AttributeTest extends TestCase {    public void testConstructor() {        Attribute a = new Attribute(null, "name", "value");        assertEquals("name", a.getName());        assertEquals("value", a.getValue());        assertNull(a.getParent());    }    public void testAccessors() {        Attribute a = new Attribute(null, null, null);        a.setName("name");        a.setValue("value");        a.setParent(null);        assertEquals("name", a.getName());        assertEquals("value", a.getValue());        assertNull(a.getParent());    }}
/* * Created on 15/03/2003 * * To change this generated comment go to  * Window>Preferences>Java>Code Generation>Code Template */package test.net.sourceforge.pmd.jaxen;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTStatement;import net.sourceforge.pmd.ast.ASTTypeDeclaration;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.jaxen.DocumentNavigator;import org.jaxen.BaseXPath;import org.jaxen.JaxenException;import org.jaxen.UnsupportedAxisException;import test.net.sourceforge.pmd.rules.RuleTst;import test.net.sourceforge.pmd.rules.EmptyCatchBlockRuleTest;import java.util.Iterator;import java.util.List;/** * @author daniels * * To change this generated comment go to  * Window>Preferences>Java>Code Generation>Code Template */public class DocumentNavigatorTest extends RuleTst {       private TestRule rule;    private class TestRule extends AbstractRule {        private Node compilationUnit;        private Node importDeclaration;        private Node typeDeclaration;        private Node statement;        private Node primaryPrefix;        private Node primaryExpression;        private Node methodDeclaration;        /**         * @see net.sourceforge.pmd.ast.JavaParserVisitor#visit(ASTCompilationUnit, Object)         */        public Object visit(ASTCompilationUnit node, Object data) {            this.compilationUnit = node;            return super.visit(node, data);        }        public Object visit(ASTImportDeclaration node, Object data) {            this.importDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTTypeDeclaration node, Object data) {            this.typeDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTStatement node, Object data) {            this.statement = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryPrefix node, Object data) {            this.primaryPrefix = node;            return super.visit(node, data);        }        public Object visit(ASTMethodDeclaration node, Object data) {            this.methodDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryExpression node, Object data) {            this.primaryExpression = node;            return super.visit(node, data);        }    }    public void setUp() throws Exception {        try{            rule = new TestRule();            runTestFromString(EmptyCatchBlockRuleTest.TEST1, rule, new Report());        } catch (Throwable xx) {            fail();        }    }        public void testChildAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getChildAxisIterator(rule.compilationUnit);        assertSame(rule.compilationUnit.jjtGetChild(0), iter.next());        assertSame(rule.compilationUnit.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testParentAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getParentAxisIterator(rule.importDeclaration);        assertSame(rule.importDeclaration.jjtGetParent(), iter.next());        assertFalse(iter.hasNext());    }        public void testParentAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getParentAxisIterator(rule.compilationUnit);        assertFalse(iter.hasNext());    }    public void testDescendantAxisIterator() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();Iterator iter = nav.getDescendantAxisIterator(rule.statement);Node statementExpression = rule.statement.jjtGetChild(0);assertSame(statementExpression, iter.next());Node primaryExpression = statementExpression.jjtGetChild(0);        assertSame(primaryExpression, iter.next());        Node primaryPrefix = primaryExpression.jjtGetChild(0);        assertSame(primaryPrefix, iter.next());        Node primarySuffix = primaryExpression.jjtGetChild(1);        assertSame(primarySuffix, iter.next());        Node name = primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        Node arguments = primarySuffix.jjtGetChild(0);        assertSame(arguments, iter.next());        assertFalse(iter.hasNext());    }        public void testDescendantAxisIterator2() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getDescendantAxisIterator(rule.primaryPrefix);        Node name = rule.primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        assertFalse(iter.hasNext());    }        public void testFollowingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertSame(rule.primaryExpression.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testFollowingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertSame(rule.primaryExpression.jjtGetChild(0), iter.next());        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertFalse(iter.hasNext());    }    /*    public void testAttributeAxisIterator() {        //TODO: This is fragile - attribute order is not guaranteed        DocumentNavigator nav = new DocumentNavigator();        Attribute attr;        Iterator iter = nav.getAttributeAxisIterator(rule.primaryPrefix);        attr = (Attribute) iter.next();        assertEquals("BeginLine", attr.getName());        assertEquals("12", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("BeginColumn", attr.getName());        assertEquals("17", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("EndLine", attr.getName());        assertEquals("12", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("EndColumn", attr.getName());        assertEquals("33", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("ThisModifier", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("SuperModifier", attr.getName());        assertEquals("false", attr.getValue());        assertFalse(iter.hasNext());    }*//*    public void testTest() throws Throwable {        runTestFromFile("UnusedModifier1.java", rule);        DocumentNavigator nav = new DocumentNavigator();XPath xpath1 = new BaseXPath(".[@Public = 'true']", nav);assertTrue(xpath1.booleanValueOf(rule.methodDeclaration));assertSame(rule.methodDeclaration, xpath1.selectSingleNode(rule.methodDeclaration));               XPath xpath2 = new BaseXPath("//ASTMethodDeclaration[@Public='true']", nav);        System.out.println(xpath2);        assertTrue(xpath2.booleanValueOf(rule.compilationUnit));        assertSame(rule.methodDeclaration, xpath2.selectSingleNode(rule.compilationUnit));           }*//*    public void testAttributeAxisIterator2() throws Throwable {        //TODO: This is fragile - attribute order is not guaranteed        runTestFromFile("UnusedModifier1.java", rule);        DocumentNavigator nav = new DocumentNavigator();        Attribute attr;        assertNotNull(rule.methodDeclaration);        Iterator iter = nav.getAttributeAxisIterator(rule.methodDeclaration);        attr = (Attribute) iter.next();        assertEquals("BeginLine", attr.getName());        assertEquals("2", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("BeginColumn", attr.getName());        assertEquals("2", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("EndLine", attr.getName());        assertEquals("2", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("EndColumn", attr.getName());        assertEquals("19", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Interface", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Private", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Transient", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Static", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Public", attr.getName());        assertEquals("true", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Protected", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Final", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Synchronized", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Volatile", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Native", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Abstract", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Strict", attr.getName());        assertEquals("false", attr.getValue());        attr = (Attribute) iter.next();        assertEquals("Super", attr.getName());        assertEquals("false", attr.getValue());        assertFalse(iter.hasNext());    }*/    public void testXPath() throws JaxenException {BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());List matches = xPath.selectNodes(rule.statement);assertEquals(6, matches.size());            }    public void testXPath2() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.importDeclaration);        assertEquals(1, matches.size());            }    public void testXPath3() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.typeDeclaration);        assertEquals(76, matches.size());    }        public void testXPath4() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.compilationUnit);        assertEquals(79, matches.size());    }    }
package test.net.sourceforge.pmd.renderers;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.XMLRenderer;import test.net.sourceforge.pmd.MockRule;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class XMLRendererTest extends TestCase {    private XMLRenderer IUT = null;    private MockRule RULE1 = new MockRule("RULE1", "RULE1", "msg");    private MockRule RULE2 = new MockRule("RULE2", "RULE2", "msg");    private RuleContext ctx = new RuleContext();    public XMLRendererTest(String name) {        super(name);    }    public void setUp() {        IUT = new XMLRenderer();    }    public void testEmptyReport() throws Throwable {        String rendered = IUT.render(new Report());        assertTrue("Expected empty PMD tag.", rendered.indexOf("violation") < 0);    }    public void testSingleReport() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testSingleReport");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        String rendered = IUT.render(report);        // <?xml version="1.0"?>        // <pmd>        //   <file name="testSingleReport">        //     <violation line="1" rule="RULE1">        // Rule1        //     </violation>        //   </file>        // </pmd>        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testSingleReport\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        verifyPositions(rendered, expectedStrings);    }    public void testDoubleReport() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testDoubleReport");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        report.addRuleViolation(new RuleViolation(RULE2, 2, "Rule2", ctx));        String rendered = IUT.render(report);        // <?xml version="1.0"?>        // <pmd>        //   <file name="testSingleReport">        //     <violation line="1" rule="RULE1">        // Rule1        //     </violation>        //     <violation line="2" rule="RULE2">        // Rule2        //     </violation>        //   </file>        // </pmd>        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testDoubleReport\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("<violation line=\"2\" rule=\"RULE2\">");        expectedStrings.add("Rule2");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        verifyPositions(rendered, expectedStrings);    }    public void testTwoFiles() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_1");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        String rendered = IUT.render(report);        // <?xml version="1.0"?>        // <pmd>        //   <file name="testTwoFiles_0">        //     <violation line="1" rule="RULE1">        // Rule1        //     </violation>        //   </file>        //   <file name="testTwoFiles_1">        //     <violation line="1" rule="RULE1">        // Rule1        //     </violation>        //   </file>        // </pmd>        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testTwoFiles_0\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("<file name=\"testTwoFiles_1\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        verifyPositions(rendered, expectedStrings);    }    public void testUnorderedFiles() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_1");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE2, 2, "Rule2", ctx));        String rendered = IUT.render(report);        // <?xml version="1.0"?>        // <pmd>        //   <file name="testTwoFiles_0">        //     <violation line="1" rule="RULE1">        // Rule1        //     </violation>        //   </file>        //   <file name="testTwoFiles_1">        //     <violation line="1" rule="RULE1">        // Rule1        //     </violation>        //   </file>        // </pmd>        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testTwoFiles_0\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("<violation line=\"2\" rule=\"RULE2\">");        expectedStrings.add("Rule2");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("<file name=\"testTwoFiles_1\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        verifyPositions(rendered, expectedStrings);    }    public void verifyPositions(String rendered, List strings) {        Iterator i = strings.iterator();        int currPos = 0;        String lastString = "<?xml version=\"1.0\"?>";        while (i.hasNext()) {            String str = (String) i.next();            int strPos = rendered.indexOf(str, currPos);            assertTrue("Expecting: " + str + " after " + lastString, strPos > currPos);            currPos = strPos;            lastString = str;        }    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.symboltable.TypeSet;import java.io.File;import java.util.HashSet;import java.util.Set;public class TypeSetTest extends TestCase {    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    public void testFindClassImplicitImport() throws Throwable {        TypeSet t = new TypeSet();        Class clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    public void testFindClassSamePackage() throws Throwable {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd.");        Class clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    public void testFindClassExplicitImport() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassImportOnDemand() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassPrimitive() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    public void testFindClassVoid() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    public void testFindFullyQualified() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    public void testPrimitiveTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    public void testVoidTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    public void testExplicitImportResolver() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(imports);        assertEquals(File.class, r.resolve("File"));    }    public void testImplicitImportResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        assertEquals(String.class, r.resolve("String"));    }    public void testImplicitImportResolverPassFail() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        try {            r.resolve("PMD");            throw new RuntimeException("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }    }    public void testCurrentPackageResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver("net.sourceforge.pmd.");        assertEquals(PMD.class, r.resolve("PMD"));    }    public void testImportOnDemandResolverPass() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    public void testImportOnDemandResolverFail() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        try {            r.resolve("foo");            throw new RuntimeException("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }        try {            r.resolve("String");            throw new RuntimeException("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.AbstractScope;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.Scope;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.Iterator;public class AbstractScopeTest extends TestCase {    // A helper class to stub out AbstractScope's abstract stuff    private class MyScope extends AbstractScope {        protected NameDeclaration findVariableHere(NameOccurrence occ) {            for (Iterator i = variableNames.keySet().iterator(); i.hasNext();) {                NameDeclaration decl = (NameDeclaration) i.next();                if (decl.getImage().equals(occ.getImage())) {                    return decl;                }            }            return null;        }    }    // Another helper class to test the search for a class scope behavior    private class IsEnclosingClassScope extends AbstractScope {        protected NameDeclaration findVariableHere(NameOccurrence occ) {            return null;        }        public Scope getEnclosingClassScope() {            return this;        }    }    public void testAccessors() {        Scope scope = new MyScope();        MyScope parent = new MyScope();        scope.setParent(parent);        assertEquals(parent, scope.getParent());        assertTrue(!scope.getVariableDeclarations(false).keySet().iterator().hasNext());        assertTrue(scope.getVariableDeclarations(true).isEmpty());    }    public void testEnclClassScopeGetsDelegatedRight() {        Scope scope = new MyScope();        Scope isEncl = new IsEnclosingClassScope();        scope.setParent(isEncl);        assertEquals(isEncl, scope.getEnclosingClassScope());    }    public void testAdd() {        Scope scope = new MyScope();        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        VariableNameDeclaration decl = new VariableNameDeclaration(node);        scope.addDeclaration(decl);        assertTrue(scope.contains(new NameOccurrence(new SimpleNode(1), "foo")));    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;public class VariableNameDeclarationTest extends TestCase {    public void testConstructor() {        ASTVariableDeclaratorId exp = createNode("foo", 10);        LocalScope scope = new LocalScope();        exp.setScope(scope);        VariableNameDeclaration decl = new VariableNameDeclaration(exp);        assertEquals("foo", decl.getImage());        assertEquals(10, decl.getLine());    }    public void testExceptionBlkParam() {        ASTVariableDeclaratorId id = new ASTVariableDeclaratorId(3);        id.testingOnly__setBeginLine(10);        id.setImage("foo");        ASTFormalParameter param = new ASTFormalParameter(2);        id.jjtSetParent(param);        ASTTryStatement tryStmt = new ASTTryStatement(1);        param.jjtSetParent(tryStmt);        VariableNameDeclaration decl = new VariableNameDeclaration(id);        assertTrue(decl.isExceptionBlockParameter());    }    private static ASTVariableDeclaratorId createNode(String image, int line) {        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage(image);        node.testingOnly__setBeginLine(line);        return node;    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTClassBody;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.ast.ASTForStatement;import net.sourceforge.pmd.ast.ASTIfStatement;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTUnmodifiedClassDeclaration;import net.sourceforge.pmd.ast.ASTUnmodifiedInterfaceDeclaration;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.GlobalScope;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.MethodScope;import net.sourceforge.pmd.symboltable.ScopeFactory;public class ScopeFactoryTest extends TestCase {    public void testGlobalScope() {        ScopeFactory sf = new ScopeFactory();        assertTrue(sf.createScope(new ASTCompilationUnit(1)) instanceof GlobalScope);    }    public void testClassScope() {        ScopeFactory sf = new ScopeFactory();        assertTrue(sf.createScope(new ASTUnmodifiedClassDeclaration(1)) instanceof ClassScope);        assertTrue(sf.createScope(new ASTUnmodifiedInterfaceDeclaration(1)) instanceof ClassScope);    }    public void testfunctionScope() {        ScopeFactory sf = new ScopeFactory();        assertTrue(sf.createScope(new ASTMethodDeclaration(1)) instanceof MethodScope);        assertTrue(sf.createScope(new ASTConstructorDeclaration(1)) instanceof MethodScope);    }    public void testLocalScope() {        ScopeFactory sf = new ScopeFactory();        assertTrue(sf.createScope(new ASTBlock(1)) instanceof LocalScope);        assertTrue(sf.createScope(new ASTTryStatement(1)) instanceof LocalScope);        assertTrue(sf.createScope(new ASTForStatement(1)) instanceof LocalScope);        assertTrue(sf.createScope(new ASTIfStatement(1)) instanceof LocalScope);    }    public void testUnknownScope_ThisShouldNeverHappen() throws Throwable {        ScopeFactory sf = new ScopeFactory();        try {            sf.createScope(new ASTClassBody(1));            throw new Throwable("Should have failed!");        } catch (RuntimeException re) {            // cool        }    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTIfStatement;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.symboltable.GlobalScope;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.ScopeCreator;public class ScopeCreatorTest extends TestCase {    public void testScopesAreCreated() {        ScopeCreator sc = new ScopeCreator();        ASTCompilationUnit acu = new ASTCompilationUnit(1);        acu.setScope(new GlobalScope());        ASTTryStatement tryNode = new ASTTryStatement(2);        tryNode.setScope(new LocalScope());        tryNode.jjtSetParent(acu);        ASTIfStatement ifNode = new ASTIfStatement(3);        ifNode.jjtSetParent(tryNode);        sc.visit(acu, null);        assertTrue(ifNode.getScope() instanceof LocalScope);    }    /*       public void testPush() {            SymbolTable s = new SymbolTable();            s.push(new GlobalScope());            assertEquals(1,s.depth());        }        public void testPop() {            SymbolTable s = new SymbolTable();            s.push(new GlobalScope());            s.pop();            assertEquals(0,s.depth());        }        public void testPeek() {            SymbolTable s = new SymbolTable();            Scope scope = new GlobalScope();            s.push(scope);            assertEquals(scope, s.peek());        }        public void testParentLinkage() {            SymbolTable s = new SymbolTable();            Scope scope = new GlobalScope();            s.push(scope);            Scope scope2 = new LocalScope();            s.push(scope2);            Scope scope3 = new LocalScope();            s.push(scope3);            assertEquals(scope2.getParent(), scope);            assertEquals(scope3.getParent(), scope2);            s.pop();            assertEquals(scope2.getParent(), scope);            assertEquals(scope3.getParent(), scope2);        }    */}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;public class ClassScopeTest extends TestCase {    public void testContains() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getVariableDeclarations(false).keySet().iterator().hasNext());    }    public void testCantContainsSuperToString() {        ClassScope s = new ClassScope("foo");        SimpleNode node = new SimpleNode(1);        node.setImage("super.toString");        assertTrue(!s.contains(new NameOccurrence(node, node.getImage())));    }    public void testContainsStaticVariablePrefixedWithClassName() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("X");        s.addDeclaration(new VariableNameDeclaration(node));        SimpleNode node2 = new SimpleNode(2);        node2.setImage("Foo.X");        assertTrue(s.contains(new NameOccurrence(node2, node2.getImage())));    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;public class LocalScopeTest extends TestCase {    private class MyASTVariableDeclaratorId extends ASTVariableDeclaratorId {        public MyASTVariableDeclaratorId(int x) {            super(x);        }        public boolean isExceptionBlockParameter() {            return true;        }    }    public void testNameWithThisOrSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertTrue(!scope.getVariableDeclarations(false).keySet().iterator().hasNext());    }    public void testNameWithSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertTrue(!scope.getVariableDeclarations(false).keySet().iterator().hasNext());    }    public void testExceptionParamNameIsDiscarded() {        ASTVariableDeclaratorId node = new MyASTVariableDeclaratorId(1);        VariableNameDeclaration decl = new VariableNameDeclaration(node);        LocalScope scope = new LocalScope();        scope.addDeclaration(decl);        assertTrue(!scope.getVariableDeclarations(false).keySet().iterator().hasNext());    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTPrimarySuffix;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.NameOccurrences;public class NameOccurrencesTest extends TestCase {    public void testNameLinkage() {        ASTPrimaryExpression primary = new ASTPrimaryExpression(1);        primary.testingOnly__setBeginLine(10);        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        prefix.testingOnly__setBeginLine(10);        primary.jjtAddChild(prefix, 0);        ASTPrimarySuffix suffix = new ASTPrimarySuffix(3);        suffix.setImage("x");        suffix.testingOnly__setBeginLine(10);        primary.jjtAddChild(suffix, 1);        NameOccurrences occs = new NameOccurrences(primary);        NameOccurrence thisOcc = (NameOccurrence) occs.iterator().next();        NameOccurrence xOcc = (NameOccurrence) occs.getNames().get(1);        assertEquals(thisOcc.getNameForWhichThisIsAQualifier(), xOcc);    }    // super    public void testSuper() {        ASTPrimaryExpression primary = new ASTPrimaryExpression(1);        primary.testingOnly__setBeginLine(10);        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        prefix.testingOnly__setBeginLine(10);        primary.jjtAddChild(prefix, 0);        NameOccurrences occs = new NameOccurrences(primary);        assertEquals("super", ((NameOccurrence) occs.getNames().get(0)).getImage());    }    // this    public void testThis() {        ASTPrimaryExpression primary = new ASTPrimaryExpression(1);        primary.testingOnly__setBeginLine(10);        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        prefix.testingOnly__setBeginLine(10);        primary.jjtAddChild(prefix, 0);        NameOccurrences occs = new NameOccurrences(primary);        assertEquals("this", ((NameOccurrence) occs.getNames().get(0)).getImage());    }    // this.x    public void testFieldWithThis() {        ASTPrimaryExpression primary = new ASTPrimaryExpression(1);        primary.testingOnly__setBeginLine(10);        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        prefix.testingOnly__setBeginLine(10);        primary.jjtAddChild(prefix, 0);        ASTPrimarySuffix suffix = new ASTPrimarySuffix(3);        suffix.setImage("x");        suffix.testingOnly__setBeginLine(10);        primary.jjtAddChild(suffix, 1);        NameOccurrences occs = new NameOccurrences(primary);        assertEquals("this", ((NameOccurrence) occs.getNames().get(0)).getImage());        assertEquals("x", ((NameOccurrence) occs.getNames().get(1)).getImage());    }    // x    public void testField() {        ASTPrimaryExpression primary = new ASTPrimaryExpression(1);        primary.testingOnly__setBeginLine(10);        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.testingOnly__setBeginLine(10);        primary.jjtAddChild(prefix, 0);        ASTName name = new ASTName(3);        name.setImage("x");        prefix.jjtAddChild(name, 0);        NameOccurrences occs = new NameOccurrences(primary);        assertEquals("x", ((NameOccurrence) occs.getNames().get(0)).getImage());    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.NameOccurrence;public class NameOccurrenceTest extends TestCase {    public void testConstructor() {        SimpleNode node = new ASTPrimaryExpression(1);        node.testingOnly__setBeginLine(10);        LocalScope lclScope = new LocalScope();        node.setScope(lclScope);        NameOccurrence occ = new NameOccurrence(node, "foo");        assertEquals("foo", occ.getImage());        assertTrue(!occ.isThisOrSuper());        assertEquals(new NameOccurrence(null, "foo"), occ);        assertEquals(10, occ.getBeginLine());    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.ast.ASTVariableDeclarator;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.DeclarationFinder;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.NameOccurrence;public class DeclarationFinderTest extends TestCase {    public void testDeclarationsAreFound() {        DeclarationFinder df = new DeclarationFinder();        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        ASTVariableDeclarator parent = new ASTVariableDeclarator(2);        node.jjtSetParent(parent);        ASTLocalVariableDeclaration gparent = new ASTLocalVariableDeclaration(3);        parent.jjtSetParent(gparent);        LocalScope scope = new LocalScope();        node.setScope(scope);        df.visit(node, null);        assertTrue(scope.contains(new NameOccurrence(new SimpleNode(4), "foo")));    }    public void test1() {    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.ImageFinderFunction;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.ArrayList;import java.util.List;public class ImageFinderFunctionTest extends TestCase {    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    public void testSeveralImages() {        List imgs = new ArrayList();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTClassDeclaration;import java.util.Iterator;import java.util.Set;public class ClassDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, false, false);    }    public void testAbstract() throws Throwable {        String access[] = {"abstract"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, true, false, false);    }    public void testFinal() throws Throwable {        String access[] = {"final"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, true, false);    }    public void testStrict() throws Throwable {        String access[] = {"strictfp"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, false, true);    }    public void testPublicFinal() throws Throwable {        String access[] = {"public", "final"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, true, false);    }    public void verifyFlags(ASTClassDeclaration acd, boolean bPublic, boolean bAbstract, boolean bFinal, boolean bStrict) {        assertEquals("Public: ", bPublic, acd.isPublic());        assertEquals("Abstract: ", bAbstract, acd.isAbstract());        assertEquals("Final: ", bFinal, acd.isFinal());        assertEquals("Strict: ", bStrict, acd.isStrict());    }    public ASTClassDeclaration getClassDecl(String access[]) throws Throwable {        String javaCode = "";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " class Test { } ";        Set classes = getNodes(ASTClassDeclaration.class, javaCode);        assertEquals("Wrong number of classes", 1, classes.size());        Iterator i = classes.iterator();        return (ASTClassDeclaration) i.next();    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import java.util.Iterator;import java.util.Set;public class FieldDeclTest extends ParserTst {    public String makeAccessJavaCode(String access[]) {        String RC = "public class Test { ";        for (int i = 0; i < access.length; i++) {            RC += access[i] + " ";        }        RC += " int j;  }";        return RC;    }    public ASTFieldDeclaration getFieldDecl(String access[]) throws Throwable {        Set fields = getNodes(ASTFieldDeclaration.class, makeAccessJavaCode(access));        assertEquals("Wrong number of fields", 1, fields.size());        Iterator i = fields.iterator();        return (ASTFieldDeclaration) i.next();    }    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be protected.", afd.isProtected());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testStatic() throws Throwable {        String access[] = {"private", "static"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be static.", afd.isStatic());        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be final.", afd.isFinal());        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testTransient() throws Throwable {        String access[] = {"private", "transient"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());        assertTrue("Expecting field to be transient.", afd.isTransient());    }    public void testVolatile() throws Throwable {        String access[] = {"private", "volatile"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be volatile.", afd.isVolatile());        assertTrue("Expecting field to be private.", afd.isPrivate());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import java.util.Iterator;import java.util.Set;public class MethodDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be protected.", amd.isProtected());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be final.", amd.isFinal());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testSynchronized() throws Throwable {        String access[] = {"public", "synchronized"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be synchronized.", amd.isSynchronized());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testAbstract() throws Throwable {        String access[] = {"public", "abstract"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be abstract.", amd.isAbstract());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testNative() throws Throwable {        String access[] = {"private", "native"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be native.", amd.isNative());        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testStrict() throws Throwable {        String access[] = {"public", "strictfp"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be strict.", amd.isStrict());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public ASTMethodDeclaration getMethodDecl(String access[]) throws Throwable {        String javaCode = "public class Test { ";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " void stuff() { } }";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        assertEquals("Wrong number of methods", 1, methods.size());        Iterator i = methods.iterator();        return (ASTMethodDeclaration) i.next();    }}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ASTName;public class ASTImportDeclarationTest extends TestCase {    public void testBasic() {        ASTImportDeclaration i = new ASTImportDeclaration(1);        assertTrue(!i.isImportOnDemand());        i.setImportOnDemand();        assertTrue(i.isImportOnDemand());    }    public void testGetImportedNameNode() {        ASTImportDeclaration i = new ASTImportDeclaration(1);        ASTName name = new ASTName(2);        i.jjtAddChild(name, 0);        assertEquals(name, i.getImportedNameNode());    }}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;public class ASTVariableDeclaratorIdTest extends TestCase {    public void testIsExceptionBlockParameter() {        ASTTryStatement tryNode = new ASTTryStatement(1);        ASTBlock block = new ASTBlock(2);        ASTVariableDeclaratorId v = new ASTVariableDeclaratorId(3);        v.jjtSetParent(block);        block.jjtSetParent(tryNode);        assertTrue(v.isExceptionBlockParameter());    }}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.AccessNode;public class AccessNodeTest extends TestCase {    public void testStatic() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not static.", !node.isStatic());        node.setStatic();        assertTrue("Node set to static, not static.", node.isStatic());    }    public void testPublic() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not public.", !node.isPublic());        node.setPublic();        assertTrue("Node set to public, not public.", node.isPublic());    }    public void testProtected() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not protected.", !node.isProtected());        node.setProtected();        assertTrue("Node set to protected, not protected.", node.isProtected());    }    public void testPrivate() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not private.", !node.isPrivate());        node.setPrivate();        assertTrue("Node set to private, not private.", node.isPrivate());    }    public void testFinal() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not final.", !node.isFinal());        node.setFinal();        assertTrue("Node set to final, not final.", node.isFinal());    }    public void testSynchronized() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not synchronized.", !node.isSynchronized());        node.setSynchronized();        assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());    }    public void testVolatile() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not volatile.", !node.isVolatile());        node.setVolatile();        assertTrue("Node set to volatile, not volatile.", node.isVolatile());    }    public void testTransient() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not transient.", !node.isTransient());        node.setTransient();        assertTrue("Node set to transient, not transient.", node.isTransient());    }    public void testNative() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not native.", !node.isNative());        node.setNative();        assertTrue("Node set to native, not native.", node.isNative());    }    public void testInterface() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not interface.", !node.isInterface());        node.setInterface();        assertTrue("Node set to interface, not interface.", node.isInterface());    }    public void testAbstract() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not abstract.", !node.isAbstract());        node.setAbstract();        assertTrue("Node set to abstract, not abstract.", node.isAbstract());    }    public void testStrict() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not strict.", !node.isStrict());        node.setStrict();        assertTrue("Node set to strict, not strict.", node.isStrict());    }    public void testSuper() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not super.", !node.isSuper());        node.setSuper();        assertTrue("Node set to super, not super.", node.isSuper());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTBlockStatement;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTReturnStatement;import net.sourceforge.pmd.ast.ASTUnmodifiedClassDeclaration;import net.sourceforge.pmd.ast.SimpleNode;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set;public class SimpleNodeTest extends ParserTst {    public void testMethodDiffLines() throws Throwable {        String javaCode = "public class Test {\n";        javaCode += "  public void helloWorld() \n"; // Line 2, Col 3        javaCode += "  { System.err.println(\"Hello World\"); \n";        javaCode += " } \n"; // Line 4, Col 2        javaCode += "}";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        Iterator iter = methods.iterator();        assertTrue(iter.hasNext());        verifyNode((SimpleNode) iter.next(), 2, 3, 4, 2);    }    public void testMethodSameColumn() throws Throwable {        String javaCode = "public class Test {\n";        javaCode += "public void helloWorld() {\n"; // Line 2, Col 1        javaCode += "} \n"; // Line 3, Col 1        javaCode += "}\n";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        Iterator iter = methods.iterator();        assertTrue(iter.hasNext());        verifyNode((SimpleNode) iter.next(), 2, 1, 3, 1);    }    public void testMethodSameLine() throws Throwable {        String javaCode = "public class Test {\n";        javaCode += "  public void helloWorld() {}\n"; // 2, 3 -> 2, 29        javaCode += "}\n";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        Iterator iter = methods.iterator();        assertTrue(iter.hasNext());        verifyNode((SimpleNode) iter.next(), 2, 3, 2, 29);    }    public void testNoLookahead() throws Throwable {        String javaCode = "public class Foo { }\n"; // 1, 8 -> 1, 20        Set uCD = getNodes(ASTUnmodifiedClassDeclaration.class, javaCode);        Iterator iter = uCD.iterator();        assertTrue(iter.hasNext());        verifyNode((SimpleNode) iter.next(), 1, 8, 1, 20);    }    public void testNames() throws Throwable {        String code = "import java.io.File; \n public class Foo{}";        Set name = getNodes(ASTName.class, code);        Iterator i = name.iterator();        assertTrue(i.hasNext());        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 16, 1, 19);            }        }    }    public void testNames2() throws Throwable {        String code = "import java.io.\nFile; \n public class Foo{}";        Set name = getNodes(ASTName.class, code);        Iterator i = name.iterator();        assertTrue(i.hasNext());        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 2, 1, 2, 4);                // This is a BUG!  Should start on line 1.            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 18);            }        }    }    public void verifyNode(SimpleNode node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Wrong Line Number provided for Start: ", beginLine, node.getBeginLine());        assertEquals("Wrong Column provided for Begin: ", beginCol, node.getBeginColumn());        assertEquals("Wrong Line Number provided for End: ", endLine, node.getEndLine());        assertEquals("Wrong Column provide for End: ", endCol, node.getEndColumn());    }    public void testFindChildrenOfType() {        ASTBlock block = new ASTBlock(2);        block.jjtAddChild(new ASTReturnStatement(1), 0);        assertEquals(1, block.findChildrenOfType(ASTReturnStatement.class).size());    }    public void testFindChildrenOfTypeMultiple() {        ASTBlock block = new ASTBlock(1);        block.jjtAddChild(new ASTBlockStatement(2), 0);        block.jjtAddChild(new ASTBlockStatement(3), 1);        List nodes = new ArrayList();        block.findChildrenOfType(ASTBlockStatement.class, nodes);        assertEquals(2, nodes.size());    }    public void testFindChildrenOfTypeRecurse() {        ASTBlock block = new ASTBlock(1);        ASTBlock childBlock = new ASTBlock(2);        block.jjtAddChild(childBlock, 0);        childBlock.jjtAddChild(new ASTMethodDeclaration(3), 0);        List nodes = new ArrayList();        block.findChildrenOfType(ASTMethodDeclaration.class, nodes);        assertEquals(1, nodes.size());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.ExternalRuleID;public class ExternalRuleIDTest extends TestCase {    public ExternalRuleIDTest(String name) {        super(name);    }    public void testParse() {        String xrefString = "rulesets/basic.xml/EmptyCatchBlock";        ExternalRuleID xref = new ExternalRuleID(xrefString);        assertEquals("Filename mismatch!", "rulesets/basic.xml", xref.getFilename());        assertEquals("Rule name mismatch!", "EmptyCatchBlock", xref.getRuleName());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;public class AbstractRuleTest extends TestCase {    private static class MyRule extends AbstractRule {        public String getMessage() {            return "myrule";        }    }    public AbstractRuleTest(String name) {        super(name);    }    public void testCreateRV() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation rv = r.createRuleViolation(ctx, 5);        assertEquals("Line number mismatch!", 5, rv.getLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "myrule", rv.getDescription());    }    public void testCreateRV2() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation rv = r.createRuleViolation(ctx, 5, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.ast.JavaParser;import java.io.StringReader;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.Set;public class RuleSetTest extends TestCase {    private String javaCode = "public class Test { }";    public void testConstructor() {        new RuleSet();    }    public void testAccessors() {        RuleSet rs = new RuleSet();        rs.setName("foo");        assertEquals("name mismatch", "foo", rs.getName());        rs.setDescription("bar");        assertEquals("description mismatch", "bar", rs.getDescription());    }    public void testGetRuleByName() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg");        rs.addRule(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    public void testRuleList() {        RuleSet IUT = new RuleSet();        assertEquals("Size of RuleSet isn't zero.", 0, IUT.size());        MockRule rule = new MockRule("name", "desc", "msg");        IUT.addRule(rule);        assertEquals("Size of RuleSet isn't one.", 1, IUT.size());        Set rules = IUT.getRules();        Iterator i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    public void testAddRuleSet() {        RuleSet set1 = new RuleSet();        set1.addRule(new MockRule("name", "desc", "msg"));        RuleSet set2 = new RuleSet();        set2.addRule(new MockRule("name", "desc", "msg"));        set1.addRuleSet(set2);        assertEquals("ruleset size wrong", 2, set1.size());    }    public void testApply0Rules() throws Throwable {        RuleSet IUT = new RuleSet();        verifyRuleSet(IUT, 0, new HashSet());    }    public void testApply1Rule() throws Throwable {        RuleSet IUT = new RuleSet();        MockRule rule = new MockRule("name", "desc", "msg");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation violation = new RuleViolation(rule, 1, ctx);        rule.addViolation(violation);        IUT.addRule(rule);        verifyRuleSet(IUT, 1, Collections.singleton(violation));    }    public void testApplyNRule() throws Throwable {        RuleSet IUT = new RuleSet();        Random rand = new Random();        int numRules = rand.nextInt(10) + 1;        Set ruleViolations = new HashSet();        for (int i = 0; i < numRules; i++) {            MockRule rule = new MockRule("name", "desc", "msg");            RuleContext ctx = new RuleContext();            ctx.setSourceCodeFilename("filename");            RuleViolation violation = new RuleViolation(rule, i, ctx);            ruleViolations.add(violation);            rule.addViolation(violation);            IUT.addRule(rule);        }        verifyRuleSet(IUT, numRules, ruleViolations);    }    protected void verifyRuleSet(RuleSet IUT, int size, Set values) throws Throwable {        RuleContext context = new RuleContext();        Set reportedValues = new HashSet();        context.setReport(new Report());        IUT.apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().size());        Iterator violations = context.getReport().iterator();        while (violations.hasNext()) {            RuleViolation violation = (RuleViolation) violations.next();            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        Iterator expected = values.iterator();        while (expected.hasNext()) {            RuleViolation violation = (RuleViolation) expected.next();            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    protected List makeCompilationUnits() throws Throwable {        List RC = new ArrayList();        JavaParser parser = new JavaParser(new StringReader(javaCode));        RC.add(parser.CompilationUnit());        return RC;    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;import net.sourceforge.pmd.stat.Metric;import java.util.Iterator;public class ReportTest extends TestCase implements ReportListener {    private boolean violationSemaphore;    private boolean metricSemaphore;    public void testBasic() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg"), 5, ctx));        assertTrue(!r.isEmpty());    }    public void testMetric0() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());    }    public void testMetric1() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());        r.addMetric(new Metric("m1", 0, 0.0, 1.0, 2.0, 3.0, 4.0));        assertTrue("Expected metrics weren't there", r.hasMetrics());        Iterator ms = r.metrics();        assertTrue("Should have some metrics in there now", ms.hasNext());        Object o = ms.next();        assertTrue("Expected Metric, got " + o.getClass(), o instanceof Metric);        Metric m = (Metric) o;        assertEquals("metric name mismatch", "m1", m.getMetricName());        assertEquals("wrong low value", 1.0, m.getLowValue(), 0.05);        assertEquals("wrong high value", 2.0, m.getHighValue(), 0.05);        assertEquals("wrong avg value", 3.0, m.getAverage(), 0.05);        assertEquals("wrong std dev value", 4.0, m.getStandardDeviation(), 0.05);    }    // Files are grouped together now.    public void testSortedReport_File() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg"), 10, ctx));        ctx.setSourceCodeFilename("bar");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg"), 20, ctx));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    public void testSortedReport_Line() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        r.addRuleViolation(new RuleViolation(new MockRule("rule2", "rule2", "msg"), 10, ctx));        ctx.setSourceCodeFilename("foo2");        r.addRuleViolation(new RuleViolation(new MockRule("rule1", "rule1", "msg"), 20, ctx));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    public void testListener() {        Report rpt = new Report();        rpt.addListener(this);        violationSemaphore = false;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("file");        rpt.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg"), 5, ctx));        assertTrue(violationSemaphore);        metricSemaphore = false;        rpt.addMetric(new Metric("test", 0, 0.0, 0.0, 0.0, 0.0, 0.0));        assertTrue("no metric", metricSemaphore);    }    public void ruleViolationAdded(RuleViolation ruleViolation) {        violationSemaphore = true;    }    public void metricAdded(Metric metric) {        metricSemaphore = true;    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleProperties;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.RuleSetReader;import net.sourceforge.pmd.RuleSetWriter;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.util.ResourceLoader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.InputStreamReader;import java.io.StringReader;import java.io.StringBufferInputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/** * A test for reading and writing a rule set file.  The registered rule sets * * @author Donald A. Leckie * @since August 30, 2002 * @version $Revision$, $Date$ */public class RuleSetReadWriteTest extends TestCase {    private InputStream m_inputStream;    private RuleSet m_ruleSetIn;    private RuleSet m_ruleSetOut;    /**     ********************************************************************************     *     */    public RuleSetReadWriteTest() {        super("Rule Set Read/Write Test");    }    /**     ********************************************************************************     *     */    public void testReadWrite() {/*        try {            loadTestFile();            m_ruleSetIn = (new RuleSetReader()).read(m_inputStream, "foo");            write();            m_ruleSetOut = (new RuleSetReader()).read(m_inputStream, "foo");            compare();        } catch (PMDException pmdException) {            pmdException.printStackTrace();        }*/    }    /**     ********************************************************************************     *     */    private void loadTestFile() {        m_inputStream = new StringBufferInputStream(TEST1);    }    /**     ********************************************************************************     *     */    private void write() {        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();        (new RuleSetWriter(outputStream)).write(m_ruleSetIn);        m_inputStream = new ByteArrayInputStream(outputStream.toByteArray());    }    /**     ********************************************************************************     *     */    private void compare() {        assertEquals("Rule set names are equal.", m_ruleSetIn.getName(), m_ruleSetOut.getName());        //assertEquals("Rule set descriptions are equal.", m_ruleSetIn.getDescription(), m_ruleSetOut.getDescription());        Set rulesIn = m_ruleSetIn.getRules();        Set rulesOut = m_ruleSetOut.getRules();        int rulesInCount = rulesIn.size();        int rulesOutCount = rulesOut.size();        assertEquals("Rule counts are equal.", rulesInCount, rulesOutCount);        Rule[] rulesOutArray = new Rule[rulesOutCount];        rulesOut.toArray(rulesOutArray);        Map rulesOutMap = new HashMap((int) (rulesInCount / 0.75));        for (int n = 0; n < rulesOutCount; n++) {            String key = rulesOutArray[n].getName();            rulesOutMap.put(key, rulesOutArray[n]);        }        Iterator iterator = rulesIn.iterator();        while (iterator.hasNext()) {            Rule ruleIn = (Rule) iterator.next();            String key = ruleIn.getName();            Rule ruleOut = (Rule) rulesOutMap.get(key);            assertNotNull("\"" + key + "\" exists in output rules.", ruleOut);            if (ruleOut != null) {                assertEquals("Rule messages are equal.", ruleIn.getMessage(), ruleOut.getMessage());                assertEquals("Rule class are equal.", ruleIn.getClass().getName(), ruleOut.getClass().getName());                assertEquals("Rule includes are equal.", ruleIn.include(), ruleOut.include());                //      assertEquals("Rule descriptions are equal.", ruleIn.getDescription(), ruleOut.getDescription());                assertEquals("Rule examples are equal.", ruleIn.getExample(), ruleOut.getExample());                RuleProperties propertiesIn = ruleIn.getProperties();                RuleProperties propertiesOut = ruleOut.getProperties();                assertEquals("Properties counts are equal.", propertiesIn.size(), propertiesOut.size());                Enumeration property = propertiesIn.keys();                while (property.hasMoreElements()) {                    String propertyName = (String) property.nextElement();                    String propertyInValue = propertiesIn.getValue(propertyName);                    String propertyOutValue = propertiesOut.getValue(propertyName);                    assertNotNull("\"" + propertyName + "\" exists in output rule properties.", propertyOutValue);                    String msg = "Rule property \"" + propertyName + "\" values are equal.";                    assertEquals(msg, propertyInValue, propertyOutValue);                    String propertyInValueType = propertiesIn.getValueType(propertyName);                    String propertyOutValueType = propertiesOut.getValueType(propertyName);                    assertNotNull("\"" + propertyName + "\" exists in output rule properties.", propertyOutValueType);                    msg = "Rule property \"" + propertyName + "\" value types are equal.";                    assertEquals(msg, propertyInValueType, propertyOutValueType);                }            }        }    }    /**     ********************************************************************************     *     * @param args     */    public static void main(String[] args) {        (new RuleSetReadWriteTest()).testReadWrite();    }    private static final String TEST1 =    "<?xml version=\"1.0\"?>" + CPD.EOL +    "<ruleset name=\"Basic Rules\">" + CPD.EOL +    "  <description>" + CPD.EOL +    "The Basic Ruleset contains a collection of good practice rules which everyone should follow." + CPD.EOL +    "  </description>" + CPD.EOL +    "  <rule name=\"EmptyCatchBlock\"" + CPD.EOL +    "        message=\"Avoid empty catch blocks\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.EmptyCatchBlockRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "Empty Catch Block finds instances where an exception is caught," + CPD.EOL +    "but nothing is done.  In most circumstances, this swallows an exception" + CPD.EOL +    "which should either be acted on or reported." + CPD.EOL +    "    </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "  public void doSomething() {" + CPD.EOL +    "    try {" + CPD.EOL +    "      FileInputStream fis = new FileInputStream(\"/tmp/bugger\");" + CPD.EOL +    "    } catch (IOException ioe) {" + CPD.EOL +    "        // not good" + CPD.EOL +    "    }" + CPD.EOL +    "  }" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"EmptyIfStmt\"" + CPD.EOL +    "        message=\"Avoid empty 'if' statements\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.EmptyIfStmtRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "Empty If Statement finds instances where a condition is checked but nothing is done about it." + CPD.EOL +    "  </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "  if (absValue < 1) {" + CPD.EOL +    "     // not good" + CPD.EOL +    "  }" + CPD.EOL +    "]]>" + CPD.EOL +    "     </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"EmptyWhileStmt\"" + CPD.EOL +    "        message=\"Avoid empty 'while' statements\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.EmptyWhileStmtRule\">" + CPD.EOL +    "     <description>" + CPD.EOL +    "Empty While Statement finds all instances where a while statement" + CPD.EOL +    "does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if" + CPD.EOL +    "it's a while loop that does a lot in the exit expression, rewrite it to make it clearer." + CPD.EOL +    "     </description>" + CPD.EOL +    "     <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "while (a == b) {" + CPD.EOL +    "  // not good" + CPD.EOL +    "}" + CPD.EOL +    "]]>" + CPD.EOL +    "     </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"IfElseStmtsMustUseBracesRule\"" + CPD.EOL +    "        message=\"Avoid using 'if...else' statements without curly braces\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.IfElseStmtsMustUseBracesRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "    Avoid using if..else statements without using curly braces" + CPD.EOL +    "    </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "  public void doSomething() {" + CPD.EOL +    "    // this is OK" + CPD.EOL +    "    if (foo) x++;" + CPD.EOL +    "" + CPD.EOL +    "    // but this is not" + CPD.EOL +    "    if (foo)" + CPD.EOL +    "        x=x+1;" + CPD.EOL +    "    else" + CPD.EOL +    "        x=x-1;" + CPD.EOL +    "  }" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"UnnecessaryConversionTemporaryRule\"" + CPD.EOL +    "        message=\"Avoid unnecessary temporaries when converting primitives to Strings\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.UnnecessaryConversionTemporaryRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "    Avoid unnecessary temporaries when converting primitives to Strings" + CPD.EOL +    "    </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "  public String convert(int x) {" + CPD.EOL +    "    // this wastes an object" + CPD.EOL +    "    String foo = new Integer(x).toString();" + CPD.EOL +    "    // this is better" + CPD.EOL +    "    return Integer.toString(x);" + CPD.EOL +    "  }" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"OverrideBothEqualsAndHashcodeRule\"" + CPD.EOL +    "        message=\"Ensure you override both equals() and hashCode()\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.OverrideBothEqualsAndHashcodeRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "Override both public boolean Object.equals(Object other), and public int Object.hashCode(), or override neither.  Even if you are inheriting a hashCode() from a parent class, consider implementing hashCode and explicitly delegating to your superclass." + CPD.EOL +    "    </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "// this is bad" + CPD.EOL +    "public class Bar {" + CPD.EOL +    "    public boolean equals(Object o) {" + CPD.EOL +    "        // do some comparison" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "// and so is this" + CPD.EOL +    "public class Baz {" + CPD.EOL +    "    public int hashCode() {" + CPD.EOL +    "        // return some hash value" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "// this is OK" + CPD.EOL +    "public class Foo {" + CPD.EOL +    "    public boolean equals(Object other) {" + CPD.EOL +    "        // do some comparison" + CPD.EOL +    "    }" + CPD.EOL +    "    public int hashCode() {" + CPD.EOL +    "        // return some hash value" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"EmptyTryBlock\"" + CPD.EOL +    "        message=\"Avoid empty try blocks\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.EmptyTryBlockRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "Avoid empty try blocks - what's the point?" + CPD.EOL +    "    </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "// this is bad" + CPD.EOL +    "public void bar() {" + CPD.EOL +    "    try {" + CPD.EOL +    "    } catch (Exception e) {" + CPD.EOL +    "        e.printStackTrace();" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"EmptyFinallyBlock\"" + CPD.EOL +    "        message=\"Avoid empty finally blocks\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.EmptyFinallyBlockRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "Avoid empty finally blocks - these can be deleted." + CPD.EOL +    "    </description>" + CPD.EOL +    "" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "// this is bad" + CPD.EOL +    "public void bar() {" + CPD.EOL +    "    try {" + CPD.EOL +    "        int x=2;" + CPD.EOL +    "    } finally {" + CPD.EOL +    "    }" + CPD.EOL +    "}" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"WhileLoopsMustUseBracesRule\"" + CPD.EOL +    "        message=\"Avoid using 'while' statements without curly braces\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.WhileLoopsMustUseBracesRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "    Avoid using 'while' statements without using curly braces" + CPD.EOL +    "    </description>" + CPD.EOL +    "" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "  public void doSomething() {" + CPD.EOL +    "    while (true)" + CPD.EOL +    "        x++;" + CPD.EOL +    "  }" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  <rule name=\"ForLoopsMustUseBracesRule\"" + CPD.EOL +    "        message=\"Avoid using 'for' statements without curly braces\"" + CPD.EOL +    "        class=\"net.sourceforge.pmd.rules.ForLoopsMustUseBracesRule\">" + CPD.EOL +    "    <description>" + CPD.EOL +    "    Avoid using 'for' statements without using curly braces" + CPD.EOL +    "    </description>" + CPD.EOL +    "    <example>" + CPD.EOL +    "<![CDATA[" + CPD.EOL +    "  public void foo() {" + CPD.EOL +    "    for (int i=0; i<42;i++)" + CPD.EOL +    "        foo();" + CPD.EOL +    "  }" + CPD.EOL +    "]]>" + CPD.EOL +    "    </example>" + CPD.EOL +    "  </rule>" + CPD.EOL +    "  </ruleset>" + CPD.EOL +    "";}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import java.io.ByteArrayInputStream;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class RuleSetFactoryTest extends TestCase {    private static final String EOL = System.getProperty("line.separator", "\n");    private static final String EMPTY_RULE_SET =            "<?xml version=\"1.0\"?>" + EOL +            "<ruleset name=\"test\">" + EOL +            "<description>testdesc</description>" + EOL +            "</ruleset>";    private static final String SINGLE_RULE_SET =            "<?xml version=\"1.0\"?>" + EOL +            "<ruleset name=\"test\">" + EOL +            "<description>" + EOL +            "testdesc" + EOL +            "</description>" + EOL +            "<rule " + EOL +            "name=\"MockRuleName\" " + EOL +            "message=\"avoid the mock rule\" " + EOL +            "class=\"test.net.sourceforge.pmd.MockRule\">" +            "</rule></ruleset>";    private static final String MULTIPLE_RULE_SET =            "<?xml version=\"1.0\"?>" + EOL +            "<ruleset name=\"test\">" + EOL +            "<description>" + EOL +            "testdesc" + EOL + "</description>" + EOL +            "<rule name=\"MockRuleName1\" " + EOL +            "message=\"avoid the mock rule\" " + EOL +            "class=\"test.net.sourceforge.pmd.MockRule\">" + EOL +            "</rule>" + EOL +            "<rule name=\"MockRuleName2\" " + EOL +            "message=\"avoid the mock rule\" " + EOL +            "class=\"test.net.sourceforge.pmd.MockRule\">" + EOL +            "</rule></ruleset>";    private static final String RULE_WITH_PROPERTIES =            "<?xml version=\"1.0\"?>" + EOL +            "<ruleset name=\"test\">" + EOL +            "<description>" + EOL +            "testdesc" + EOL +            "</description>" + EOL +            "<rule name=\"MockRuleName\" " + EOL +            "message=\"avoid the mock rule\" " + EOL +            "class=\"test.net.sourceforge.pmd.MockRule\">" + EOL +            "<description>" + EOL + "testdesc2" + EOL +            "</description>" + EOL +            "<properties>" + EOL +            "<property name=\"fooBoolean\" value=\"true\"/>" + EOL +            "<property name=\"fooDouble\" value=\"1.0\" />" + EOL +            "<property name=\"foo\" value=\"bar\"/>" + EOL +            "<property name=\"fooint\" value=\"2\"/>" + EOL +            "</properties>" + EOL +            "</rule></ruleset>";    private static final String RULE_WITH_XPATH =            "<?xml version=\"1.0\"?>" + EOL +            "<ruleset name=\"test\">" + EOL +            "<description>" + EOL +            "testdesc" + EOL +            "</description>" + EOL +            "<priority>3</priority>" + EOL +            "<rule name=\"MockRuleName\" " + EOL +            "message=\"avoid the mock rule\" " + EOL +            "class=\"test.net.sourceforge.pmd.MockRule\">" + EOL +            "<description>" + EOL +            "testdesc2" + EOL +            "</description>" + EOL +            "<properties>" + EOL +            "<property name=\"xpath\">" + EOL +            "<value>" + EOL +            "<![CDATA[ //Block ]]>" + EOL +            "</value>" + EOL +            "</property>" + EOL +            "</properties>" + EOL +            "</rule></ruleset>";    private static final String SINGLE_RULE_SET_WITH_PRIORITY =            "<?xml version=\"1.0\"?>" + EOL +            "<ruleset name=\"test\">" + EOL +            "<description>" + EOL +            "testdesc" + EOL +            "</description>" + EOL +            "<rule " + EOL +            "name=\"MockRuleName\" " + EOL +            "message=\"avoid the mock rule\" " + EOL +            "class=\"test.net.sourceforge.pmd.MockRule\">" +            "<priority>3</priority>" + EOL +            "</rule></ruleset>";    public void testSingleRuleWithPriority() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(SINGLE_RULE_SET_WITH_PRIORITY.getBytes()));        Rule r = (Rule)rs.getRules().iterator().next();        assertEquals(3, r.getPriority());    }    public void testRuleSetNotFound() {        RuleSetFactory rsf = new RuleSetFactory();        try {            rsf.createRuleSet("fooooo");            throw new RuntimeException("Should have thrown a RuleSetNotFoundException");        } catch (RuleSetNotFoundException rsnfe) {            // cool        }    }    public void testCreateEmptyRuleSet() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(EMPTY_RULE_SET.getBytes()));        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    public void testSingleRule() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(SINGLE_RULE_SET.getBytes()));        assertEquals(1, rs.size());        Rule r = (Rule)rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("avoid the mock rule", r.getMessage());    }    public void testMultipleRules() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(MULTIPLE_RULE_SET.getBytes()));        assertEquals(2, rs.size());        Set expected = new HashSet();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Iterator i = rs.getRules().iterator(); i.hasNext();) {            assertTrue(expected.contains(((Rule) i.next()).getName()));        }    }    public void testProps() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(RULE_WITH_PROPERTIES.getBytes()));        Rule r = (Rule) rs.getRules().iterator().next();        assertTrue(r.hasProperty("foo"));        assertEquals("bar", r.getStringProperty("foo"));        assertEquals(2, r.getIntProperty("fooint"));        assertTrue(r.hasProperty("fooBoolean"));        assertTrue(r.getBooleanProperty("fooBoolean"));        assertTrue(r.hasProperty("fooDouble"));        assertEquals(1.0, r.getDoubleProperty("fooDouble"), 0.05);        assertTrue(!r.hasProperty("BuggleFish"));        assertTrue(r.getDescription().indexOf("testdesc2") != -1);    }    public void testXPath() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(RULE_WITH_XPATH.getBytes()));        Rule r = (Rule) rs.getRules().iterator().next();        assertTrue(r.hasProperty("xpath"));        assertEquals(" //Block ", r.getStringProperty("xpath"));    }    /*        public void testExternalReferences() {            RuleSetFactory rsf = new RuleSetFactory();            RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(EXTERNAL_REFERENCE_RULE_SET.getBytes()));            assertEquals(1, rs.size());        }        private static final String EXTERNAL_REFERENCE_RULE_SET = "<?xml version=\"1.0\"?>" +                             "<ruleset name=\"test\">\r\n<description>testdesc</description><rule ref=\"rulesets/basic.xml/EmptyCatchBlock\"/></ruleset>";        private static final String SINGLE_RULE_NO_PROPS = "<?xml version=\"1.0\"?>" +                             "<ruleset name=\"test\">\r\n<description>testdesc</description>" +                             "<rule name=\"MockRuleName\" message=\"avoid the mock rule\" class=\"test.net.sourceforge.pmd.MockRule\">" +                             "<properties></properties>" +                             "</rule></ruleset>";    */}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;public class RuleContextTest extends TestCase {    public void testReport() {        RuleContext ctx = new RuleContext();        assertNull("Report should be null", ctx.getReport());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    public void testFilename() {        RuleContext ctx = new RuleContext();        assertNull("filename should be null", ctx.getSourceCodeFilename());        ctx.setSourceCodeFilename("foo");        assertEquals("filename mismatch", "foo", ctx.getSourceCodeFilename());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;public class RuleViolationTest extends TestCase {    public void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r = new RuleViolation(rule, 2, ctx);        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getLine());        assertEquals("filename is wrong", "filename", r.getFilename());    }    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r = new RuleViolation(rule, 2, "description", ctx);        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename1");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        ctx.setSourceCodeFilename("filename2");        RuleViolation r2 = new RuleViolation(rule, 20, "description", ctx);        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        RuleViolation r2 = new RuleViolation(rule, 20, "description", ctx);        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        RuleViolation r2 = new RuleViolation(rule, 10, "description", ctx);        assertEquals(0, comp.compare(r1, r2));        assertEquals(0, comp.compare(r2, r1));    }}
package test.net.sourceforge.pmd.rx.rules;import java.util.Set;import java.util.Iterator;import net.sourceforge.pmd.rx.facts.*;import net.sourceforge.pmd.rx.rules.*;import test.net.sourceforge.pmd.rx.*;public class DuplicateImportTest    extends DroolsRuleTst{    private String testName = null;    private String JAVA_NO_DUPE ="import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_DEMAND ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_NO_DEMAND ="import java.util.List;" +"import java.util.List;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_NO_DEMAND ="import java.util.*;" +"import java.util.List;" +"public class HelloWorld { }";    public DuplicateImportTest(String name) {super( name );this.testName = name;    }    public void testNoDupes() throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_NO_DUPE );Iterator rvs = results.iterator();while (rvs.hasNext()) {    RuleViolationFact rvFact = (RuleViolationFact) rvs.next();    ImportFact impFact = (ImportFact) rvFact.getFact();    System.err.println("DuplicateImport: " + impFact.getACU() + "/" +       impFact.getImportPackage() + "/" +       Integer.toString( impFact.getLineNumber() ));}assertEquals("Expecting no violations",     0, results.size() );    }    public void testDupeOnDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeOnNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }}
package test.net.sourceforge.pmd.rx;import java.util.Set;import java.util.HashSet;import java.util.Iterator;import java.io.StringReader;import org.drools.*;import org.drools.spi.*;import org.drools.semantic.java.*;import net.sourceforge.pmd.*;import net.sourceforge.pmd.rx.*;import net.sourceforge.pmd.ast.*;import net.sourceforge.pmd.rx.facts.*;import junit.framework.TestCase;public class DroolsVisitorTest    extends TestCase{    private String testName = null;    private static String JAVA_TEST_PACKAGE ="package test;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_1 ="import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_2 ="import java.util.*;" +"import java.lang.ref.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_SINGLE ="import java.util.Map;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_DUP ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_CLASS ="class TestClass { }";    private static String JAVA_TEST_CLASS_PUBLIC ="public class TestClass { }";    private static String JAVA_TEST_CLASS_ABSTRACT ="abstract class TestClass { }";    private static String JAVA_TEST_CLASS_INNER ="class Outer { class Inner { } }";    private static String JAVA_TEST_CLASS_ANON ="class Named { " +"  void foo() { Named.bar( new Runnable() { } ); } " +        "}";    private ASTCompilationUnit current = null;    public DroolsVisitorTest(String name) {super( name );this.testName = name;    }    public void testPackage() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.PackageFact.class,  JAVA_TEST_PACKAGE );assertEq("Expected one result.", 1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT( "Expected PackageFact.", fact instanceof PackageFact );PackageFact pkgFact = (PackageFact) fact;assertEq("Expecting package name of 'test'", "test", pkgFact.getPackageName() );    }    public void testImport1() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_1 );assertEq("Expected one result.", 1, results.size() );Iterator imports = results.iterator();Object fact = imports.next();assertT("Expected type of ImportFact",fact instanceof ImportFact);ImportFact impFact = (ImportFact) fact;assertEq("Expecting 'java.util' in Imports.", "java.util", impFact.getImportPackage() );    }    public void testImport2() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_2 );assertEq("Expected two results.", 2, results.size() );boolean sawUtil = false;boolean sawRef = false;ACUFact acu = null;Iterator imports = results.iterator();while (imports.hasNext()) {    Object fact = imports.next();    assertT("Expected type of ImportFact",    fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );    sawUtil = sawUtil |impFact.getImportPackage().equals("java.util");    sawRef = sawRef |impFact.getImportPackage().equals("java.lang.ref");}assertT("Expecting one import of 'java.util'", sawUtil);assertT("Expecting one import of 'java.lang.ref'", sawRef);    }    public void testImportDup() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_DUP );assertEq("Expected two results.", 2, results.size() );ACUFact acu = null;Iterator dups = results.iterator();while (dups.hasNext()) {    Object fact = dups.next();        assertT( "Expected fact to be of ImportFact type.",     fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );        assertT( "Should be On Demand.",     impFact.isOnDemand() );    assertEq("Expected java.util.Map to be imported.",     "java.util", impFact.getImportPackage() );}    }    public void testImportSingle() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_SINGLE );assertEq("Expected one result.", 1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ImportFact type.", fact instanceof ImportFact );ImportFact impFact = (ImportFact) fact;assertT( "Should not be listed as On Demand.", !impFact.isOnDemand() );assertEq("Expected java.util.Map to be imported.", "java.util.Map", impFact.getImportPackage() );    }    public void testClass() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS );assertEq( "Expected one result.",  1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT("Expected fact to be of ClassFact type.",fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass", classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, false, false, false );    }    public void testClassPublic() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_PUBLIC );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, true, false, false, false );    }    public void testClassAbstract() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_ABSTRACT );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, true, false, false );    }        public void testClassInner() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_INNER );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact outer = null;  ClassFact inner = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;          if (classFact.getClassName().equals("Outer")) {  outer = classFact;      }          if (classFact.getClassName().equals("Inner")) {  inner = classFact;      }}    }    public void testClassAnon() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_ANON );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact named = null;  ClassFact anon = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;      if (classFact.getOuterClass() == null) {  named = classFact;      } else {  anon = classFact;      }  }  assertNotNull( "Expected to find Named class.", named );  assertNotNull( "Expected to find Anon class.", anon );  assertEq( "Expected both classes to have same ACU.",    named.getACU(), anon.getACU() );  assertEq( "Expected Outer Class of Anon to be Named.",    named, anon.getOuterClass() );    }        public void assertEq( String message,  Object expected,  Object result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }        public void assertEq( String message,  boolean expected,  boolean result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertEq( String message,  int expected,  int result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertT( String message, boolean cond ) throws Throwable    {try {    assertTrue( message, cond );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public Set collectFacts( Class clazz,     String javaCode )throws Throwable    {RuleBase rules = new RuleBase();FactCollector collector = new FactCollector( clazz );rules.addRule( collector );JavaParser parser =    new JavaParser( new StringReader( javaCode ));ASTCompilationUnit acu =    parser.CompilationUnit();current = acu;WorkingMemory memory = rules.createWorkingMemory();DroolsVisitor IUT = new DroolsVisitor( memory );IUT.visit( acu, null );return collector.getFacts();    }    public void verifyClassFlags( ClassFact classFact,  boolean bPublic,  boolean bAbstract,  boolean bFinal,  boolean bStrict ) throws Throwable    {assertEq("Public: ", bPublic, classFact.isPublic() );assertEq("Abstract: ", bAbstract, classFact.isAbstract() );assertEq("Final: ", bFinal, classFact.isFinal() );assertEq("Strict: ", bStrict, classFact.isStrict() );    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 12:06:26 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.cpd.Tile;import net.sourceforge.pmd.dcpd.*;import java.util.ArrayList;import java.util.List;import java.util.Iterator;public class TileHarvesterTest extends TestCase {    public TileHarvesterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        // do the expansion from 1 to 2 tokens and write those expansions        // back to the mock space so TileHarvester can read them        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    TileExpanderTest.marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        space.setTileWrappers(space.getWrittenEntries());        // now the test        TileHarvester tileGatherer = new TileHarvester(space, job);        Occurrences newOcc = tileGatherer.harvest(occ.size());        assertEquals(2, newOcc.size());*/    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 11:04:26 AM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.jini.space.JavaSpace;import net.jini.core.lease.Lease;import net.sourceforge.pmd.dcpd.*;import net.sourceforge.pmd.cpd.*;import java.io.StringReader;import java.util.Iterator;import java.util.List;import java.util.ArrayList;import java.util.Stack;public class TileExpanderTest extends TestCase {    public TileExpanderTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        List writtenEntries = space.getWrittenEntries();        assertEquals(7, writtenEntries.size());*/    }   public static List marshal(Iterator i) {        List list = new ArrayList();        while (i.hasNext()) {            list.add(i.next());        }        return list;    }    public static TokenSets createTokenSets() throws Throwable {        TokenSets tokenSets = new TokenSets();        TokenList tokenList1 = new TokenList("list1");        JavaTokensTokenizer tokenizer = new JavaTokensTokenizer();        tokenizer.tokenize(tokenList1, new StringReader("public class Foo {}"));        tokenSets.add(tokenList1);        TokenList tokenList2 = new TokenList("list2");        tokenizer.tokenize(tokenList2, new StringReader("public class Bar {}"));        tokenSets.add(tokenList2);        return tokenSets;    }}
/* * User: tom * Date: Sep 6, 2002 * Time: 4:15:46 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.dcpd.Job;import net.sourceforge.pmd.dcpd.TilePlanter;public class TilePlanterTest extends TestCase {    public TilePlanterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        TilePlanter scatterer = new TilePlanter(space, job);        scatterer.plant(occ);        assertEquals(6, space.getWrittenEntries().size());*/    }}