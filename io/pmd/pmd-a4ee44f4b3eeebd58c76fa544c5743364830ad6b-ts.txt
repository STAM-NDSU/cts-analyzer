/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class GroovyTokenizerTest extends CpdTextComparisonTest {    public GroovyTokenizerTest() {        super(".groovy");    }    @Override    protected String getResourcePrefix() {        return "../lang/groovy/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new GroovyTokenizer();    }    @Test    public void testSample() {        doTest("sample");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyForeachStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveTemplateLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineJavaScriptTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineStylesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedMacroParameterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm;import java.io.StringReader;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for VM parsing. * */public class VmParserTest {    private static final String VM_SRC = "<HTML><BODY>Hello $customer.Name <table> "            + "#foreach($mud in $mudsOnSpecial)" + "  #if ( $customer.hasPurchased($mud) )" + "     <tr>" + "      <td>"            + "       $flogger.getPromo( $mud )" + "    </td>" + "  </tr>" + " #elseif ($customer.broke) do stuff #end"            + "\n " + "#end " + "</table>";    private static final String SRC2 = "#macro(tablerows $color $values ) " + "#foreach( $value in $values ) "            + "<tr><td bgcolor=$color>$value</td></tr> " + "#end " + "#end "            + "#set( $greatlakes = [\"Superior\",\"Michigan\",\"Huron\",\"Erie\",\"Ontario\"] ) "            + "#set( $color = \"blue\" ) " + "<table> " + " #tablerows( $color $greatlakes ) " + "</table>";    private static final String SRC3 = "#if ( $c1 ) #if ( $c2)#end #end";    // private static final String VM_SRC = "#if( $mud == 1 ) blah #if ($dirt ==    // 2) stuff #end #end";    @Test    public void testParser() {        final Node node = parse(VM_SRC);        Assert.assertNotNull(node);    }    @Test    public void testParser2() {        final Node node = parse(SRC2);        Assert.assertNotNull(node);    }    @Test    public void testParser3() {        final Node node = parse(SRC3);        Assert.assertNotNull(node);    }    private Node parse(final String code) {        final LanguageVersionHandler vmLang = LanguageRegistry.getLanguage(VmLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler();        final Parser parser = vmLang.getParser(vmLang.getDefaultParserOptions());        final Node node = parser.parse(null, new StringReader(code));        return node;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vm.VmLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VmLanguageModule.NAME, VmLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(VmLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test velocity's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.perl.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.PerlLanguage;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * */public class PerlTokenizerTest extends CpdTextComparisonTest {    public PerlTokenizerTest() {        super(".pl");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PerlLanguage().getTokenizer();    }    @Test    public void testSample() {        doTest("sample");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.dfa;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.ast.AbstractNode;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.dfa.NodeType;import net.sourceforge.pmd.lang.dfa.StartOrEndDataFlowNode;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;import net.sourceforge.pmd.lang.plsql.PlsqlParsingHelper;import net.sourceforge.pmd.lang.plsql.ast.ASTExpression;import net.sourceforge.pmd.lang.plsql.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.plsql.ast.ASTProgramUnit;import net.sourceforge.pmd.lang.plsql.ast.ASTVariableOrConstantDeclarator;import net.sourceforge.pmd.lang.plsql.ast.PLSQLNode;public class StatementAndBraceFinderTest extends AbstractPLSQLParserTst {    private final PlsqlParsingHelper plsql = PlsqlParsingHelper.WITH_PROCESSING.withResourceContext(StatementAndBraceFinderTest.class);    private ASTExpression getExpr(String test1) {        return plsql.parse(test1).getFirstDescendantOfType(ASTExpression.class);    }    /**     * Java ASTStatementExpression equivalent is inferred as an Expression()     * which has an UnlabelledStatement as a parent.     */    @Test    public void testExpressionParentChildLinks() {        ASTExpression ex = getExpr(TEST1);        DataFlowNode dfn = ex.getDataFlowNode();        assertEquals(3, dfn.getLine());        assertTrue(dfn.getNode() instanceof ASTExpression);        List<DataFlowNode> dfns = dfn.getParents();        assertEquals(1, dfns.size());        DataFlowNode parentDfn = dfns.get(0);        assertEquals(2, parentDfn.getLine());        assertTrue(parentDfn.getNode() instanceof ASTProgramUnit);        ASTProgramUnit exParent = (ASTProgramUnit) parentDfn.getNode();        // Validate the two-way link between Program Unit and Statement        assertEquals(ex, exParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(exParent, ex.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testVariableOrConstantDeclaratorParentChildLinks() {        ASTVariableOrConstantDeclarator vd = plsql.getNodes(ASTVariableOrConstantDeclarator.class, TEST2).get(0);        // ASTMethodDeclaration vdParent = (ASTMethodDeclaration)        // ((DataFlowNode) vd.getDataFlowNode().getParents().get(0)).getNode();        ASTProgramUnit vdParent = (ASTProgramUnit) vd.getDataFlowNode().getParents().get(0).getNode();        // Validate the two-way link between Program Unit and Variable        assertEquals(vd, vdParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(vdParent, vd.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testIfStmtHasCorrectTypes() {        ASTExpression exp = getExpr(TEST3);        assertEquals(5, exp.getDataFlowNode().getFlow().size());        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.IF_EXPR));        assertEquals(3, dfn.getLine());        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE));        assertEquals(3, dfn.getLine());    }    @Test    public void testWhileStmtHasCorrectTypes() {        ASTExpression exp = getExpr(TEST4);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.WHILE_EXPR));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.WHILE_LAST_STATEMENT));    }    @Test    public void testForStmtHasCorrectTypes() {        ASTExpression exp = getExpr(TEST5);        DataFlowNode dfn = null;        dfn = exp.getDataFlowNode().getFlow().get(0);        assertTrue(dfn instanceof StartOrEndDataFlowNode);        dfn = exp.getDataFlowNode().getFlow().get(1);        assertTrue(dfn.getNode() instanceof ASTProgramUnit);        assertEquals(2, dfn.getLine());        dfn = exp.getDataFlowNode().getFlow().get(2);        assertEquals(3, dfn.getLine());        assertTrue(dfn.isType(NodeType.FOR_EXPR));        assertTrue(dfn.isType(NodeType.FOR_BEFORE_FIRST_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertEquals(3, dfn.getLine());        assertTrue(dfn.isType(NodeType.FOR_END));    }    @Test    public void testSimpleCaseStmtHasCorrectTypes() {        ASTExpression exp = getExpr(TEST6);        DataFlowNode dfn = null;        dfn = exp.getDataFlowNode().getFlow().get(0);        assertTrue(dfn instanceof StartOrEndDataFlowNode);        dfn = exp.getDataFlowNode().getFlow().get(1);        assertEquals(2, dfn.getLine());        assertTrue(dfn.getNode() instanceof ASTProgramUnit);        dfn = exp.getDataFlowNode().getFlow().get(2);        assertEquals(4, dfn.getLine());        assertTrue(dfn.isType(NodeType.SWITCH_START));        assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertEquals(5, dfn.getLine());        assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT));        assertTrue(dfn.isType(NodeType.BREAK_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(4);        assertEquals(6, dfn.getLine());        assertTrue(dfn.isType(NodeType.SWITCH_LAST_DEFAULT_STATEMENT));        assertTrue(dfn.isType(NodeType.BREAK_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(5);        assertEquals(7, dfn.getLine());        assertTrue(dfn.isType(NodeType.SWITCH_END));    }    /*     * @Test public void testSearchedCaseStmtHasCorrectTypes()     * { List<ASTStatement> statements = getOrderedNodes(ASTStatement.class,     * TEST7); List<ASTExpression> expressions =     * getOrderedNodes(ASTExpression.class, TEST7);     *     * ASTStatement st = statements.get(0); ASTStatement st1 =     * statements.get(1); ASTStatement st2 = statements.get(2); ASTStatement st3     * = statements.get(3);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-st(0)="+st.     * getBeginLine());     *     * ASTExpression ex = expressions.get(0); ASTExpression ex1 =     * expressions.get(1); ASTExpression ex2 = expressions.get(2); ASTExpression     * ex3 = expressions.get(3); ASTExpression ex4 = expressions.get(4);     * System.err.println("ASTExpression="+ex );     *     * DataFlowNode dfn = null; //dfn = ex.getDataFlowNode().getFlow().get(0);     * //dfn = st.getDataFlowNode().getFlow().get(0); dfn = (DataFlowNode)     * st.getDataFlowNode(); System.err.println("DataFlowNode(st-0)="+dfn ) ;     * System.err.println("DataFlowNode(st-1)="+st1.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(st-2)="+st2.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(st-3)="+st3.getDataFlowNode() ) ;     *     * System.err.println("DataFlowNode(ex-0)="+ex.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-1)="+ex1.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-2)="+ex2.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-3)="+ex3.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-4)="+ex4.getDataFlowNode() ) ;     * List<DataFlowNode> dfns = dfn.getFlow();     * System.err.println("DataFlowNodes List size="+dfns.size()) ; DataFlowNode     * firstDfn = dfns.get(0); System.err.println("firstDataFlowNode="+firstDfn     * ) ;     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(0)="+dfn);     * dfn = st.getDataFlowNode().getFlow().get(1);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(1)="+dfn);     * dfn = st.getDataFlowNode().getFlow().get(2);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(2)="+dfn);     * assertTrue(dfn.isType(NodeType.SWITCH_START)); dfn =     * st.getDataFlowNode().getFlow().get(3);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(3)="+dfn);     * assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT)); //dfn =     * st.getDataFlowNode().getFlow().get(4);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(5)="+dfn);     * assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT)); dfn =     * st.getDataFlowNode().getFlow().get(5);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(7)="+dfn);     * assertTrue(dfn.isType(NodeType.SWITCH_LAST_DEFAULT_STATEMENT)); dfn =     * st.getDataFlowNode().getFlow().get(6);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(8)="+dfn);     * assertTrue(dfn.isType(NodeType.SWITCH_END)); }     */    @Test    public void testLabelledStmtHasCorrectTypes() {        ASTExpression exp = getExpr(TEST8);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertEquals(3, dfn.getLine());        assertTrue(dfn.isType(NodeType.LABEL_STATEMENT));    }    @Test    public void testOnlyWorksForMethodsAndConstructors() {        StatementAndBraceFinder sbf = new StatementAndBraceFinder(plsql.getDefaultHandler().getDataFlowHandler());        PLSQLNode node = new ASTMethodDeclaration(1);        ((AbstractNode) node).testingOnlySetBeginColumn(1);        sbf.buildDataFlowFor(node);        // sbf.buildDataFlowFor(new ASTConstructorDeclaration(1));        node = new ASTProgramUnit(1);        ((AbstractNode) node).testingOnlySetBeginColumn(1);        sbf.buildDataFlowFor(node);    }    private static final String TEST1 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  x := 2;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST2 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS "            + PMD.EOL + "  int x; " + PMD.EOL + "  BEGIN NULL ;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST3 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  if (x) THEN NULL; END IF; " + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST4 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  while (x) LOOP NULL; END LOOP;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST5 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  for i in 0..9 LOOP NULL; END LOOP;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST6 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS "            + PMD.EOL + " BEGIN" + PMD.EOL + " CASE 1 " + PMD.EOL + " WHEN 0 THEN NULL; " + PMD.EOL            + " WHEN 1 THEN NULL; " + PMD.EOL + " ELSE NULL;" + PMD.EOL + " END CASE; " + PMD.EOL + " END bar; "            + PMD.EOL + "END foo;";    private static final String TEST7 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS "            + PMD.EOL + " BEGIN" + PMD.EOL + " CASE " + PMD.EOL + " WHEN 0=1 THEN NULL; " + PMD.EOL            + " WHEN 1=1 THEN NULL; " + PMD.EOL + " ELSE NULL;" + PMD.EOL + " END CASE;" + PMD.EOL + " END bar;"            + PMD.EOL + "END foo;";    private static final String TEST8 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + " <<label>> NULL;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToDateToCharTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATE_TO_CHAR");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToDateWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATEWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToTimestampWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_TIMESTAMPWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssObjectCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePackageSpecificationLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveTypeLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePackageBodyLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NPathComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveObjectLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CodeFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LineLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidTabCharacterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MisplacedPragmaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TomKytesDespairTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class InsertIntoClauseTest extends AbstractPLSQLParserTst {    @Test    public void parseInsertInto() {        plsql.parseResource("InsertIntoClause.pls");    }    @Test    public void parseInsertIntoReturning() {        plsql.parseResource("InsertIntoClauseReturning.pls");    }    @Test    public void parseInsertIntoWithRecord() {        plsql.parseResource("InsertIntoClauseRecord.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class XMLElementTest extends AbstractPLSQLParserTst {    @Test    public void testParseXMLElement() {        ASTInput input = plsql.parseResource("XMLElement.pls");        List<ASTXMLElement> xmlelements = input.findDescendantsOfType(ASTXMLElement.class);        Assert.assertEquals(10, xmlelements.size());        Assert.assertEquals("\"Emp\"", xmlelements.get(0).getFirstChildOfType(ASTID.class).getImage());        Assert.assertTrue(xmlelements.get(3).getChild(1) instanceof ASTXMLAttributesClause);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorForLoopTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorForLoopSimple() {        ASTInput input = plsql.parseResource("CursorForLoopSimple.pls");        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        Assert.assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        Assert.assertNotNull(forindex);        Assert.assertEquals("someone", forindex.getImage());    }    @Test    public void parseCursorForLoopNested() {        ASTInput input = plsql.parseResource("CursorForLoopNested.pls");        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        Assert.assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        Assert.assertNotNull(forindex);        Assert.assertEquals("c_cmp", forindex.getImage());        ASTCursorForLoopStatement forloop2 = forloop.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex2 = forloop2.getFirstChildOfType(ASTForIndex.class);        Assert.assertEquals("c_con", forindex2.getImage());        ASTCursorForLoopStatement forloop3 = forloop2.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex3 = forloop3.getFirstChildOfType(ASTForIndex.class);        Assert.assertEquals("c_pa", forindex3.getImage());    }    @Test    public void parseCursorForLoop1047a() {        ASTInput input = plsql.parseResource("CursorForLoop1047a.pls");        Assert.assertNotNull(input);    }    @Test    public void parseCursorForLoop1047b() {        ASTInput input = plsql.parseResource("CursorForLoop1047b.pls");        Assert.assertNotNull(input);    }    @Test    public void parseCursorForLoop681() {        ASTInput input = plsql.parseResource("CursorForLoop681.pls");        Assert.assertNotNull(input);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class MultipleDDLStatementsTest extends AbstractPLSQLParserTst {    @Test    public void parseDDLCommands() throws Exception {        ASTInput input = plsql.parseResource("DDLCommands.sql");        List<ASTDDLCommand> ddlcommands = input.findDescendantsOfType(ASTDDLCommand.class);        Assert.assertEquals(6, ddlcommands.size());        List<ASTComment> comments = input.findDescendantsOfType(ASTComment.class);        Assert.assertEquals(5, comments.size());        Assert.assertEquals("'abbreviated job title'", comments.get(0).getFirstChildOfType(ASTStringLiteral.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class JoinClauseTest extends AbstractPLSQLParserTst {    @Test    public void testInnerCrossJoin() {        ASTInput input = plsql.parseResource("InnerCrossJoin.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(1, joins.size());        Assert.assertTrue(joins.get(0).isCross());        Assert.assertFalse(joins.get(0).isNatural());    }    @Test    public void testInnerNaturalJoin() {        ASTInput input = plsql.parseResource("InnerNaturalJoin.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(2, joins.size());        Assert.assertFalse(joins.get(0).isCross());        Assert.assertTrue(joins.get(0).isNatural());    }    @Test    public void testInnerJoinUsing() {        ASTInput input = plsql.parseResource("InnerJoinUsing.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(3, joins.size());        Assert.assertFalse(joins.get(0).isCross());        Assert.assertFalse(joins.get(0).isNatural());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        Assert.assertEquals(1, columns.size());        Assert.assertEquals("department_id", columns.get(0).getImage());    }    @Test    public void testOuterJoinUsing() {        ASTInput input = plsql.parseResource("OuterJoinUsing.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.FULL, type.getType());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        Assert.assertEquals(1, columns.size());        Assert.assertEquals("department_id", columns.get(0).getImage());    }    @Test    public void testRightOuterJoin() {        ASTInput input = plsql.parseResource("RightOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());    }    @Test    public void testLeftOuterJoin() {        ASTInput input = plsql.parseResource("LeftOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.LEFT, type.getType());        List<ASTSelectStatement> selects = input.findDescendantsOfType(ASTSelectStatement.class);        Assert.assertEquals(2, selects.size());        Assert.assertTrue(selects.get(0).getFromClause().getChild(0) instanceof ASTJoinClause);        Assert.assertTrue(selects.get(1).getFromClause().getChild(0) instanceof ASTJoinClause);    }    @Test    public void testNaturalRightOuterJoin() {        ASTInput input = plsql.parseResource("NaturalRightOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        Assert.assertTrue(joins.get(0).isNatural());    }    @Test    public void testOuterJoinPartitioned() {        ASTInput input = plsql.parseResource("OuterJoinPartitioned.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        Assert.assertNotNull(joins.get(0).getFirstChildOfType(ASTQueryPartitionClause.class));    }    @Test    public void testFullOuterJoin() {        plsql.parseResource("FullOuterJoin.pls");    }    @Test    public void testInnerJoinSubquery() {        plsql.parseResource("InnerJoinSubquery.pls");    }    @Test    public void testJoinOperator() {        ASTInput input = plsql.parseResource("JoinOperator.pls");        List<ASTOuterJoinExpression> expressions = input.findDescendantsOfType(ASTOuterJoinExpression.class);        Assert.assertEquals(4, expressions.size());        Assert.assertEquals("h.opp_id", expressions.get(3).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorAttributesTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorWithAttribute() {        ASTInput input = plsql.parseResource("CursorAttributes.pls");        ASTExpression exp = input.getFirstDescendantOfType(ASTIfStatement.class).getFirstChildOfType(ASTExpression.class);        Assert.assertEquals("TestSearch%notfound", exp.getImage());    }    @Test    public void parseImplicitCursorAttributeBulkExceptions() {        plsql.parseResource("CursorAttributesBulkExceptions.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTFetchStatementTest extends AbstractPLSQLParserTst {    @Test    public void testBulkCollectLimit() {        ASTInput input = plsql.parseResource("FetchStatementBulkCollectLimit.pls");        List<ASTFetchStatement> fetchStatements = input.findDescendantsOfType(ASTFetchStatement.class);        Assert.assertEquals(1, fetchStatements.size());        ASTFetchStatement fetch = fetchStatements.get(0);        Assert.assertTrue(fetch.isBulkCollect());        Assert.assertTrue(fetch.isLimit());    }    @Test    public void testFetch() {        ASTInput input = plsql.parseResource("FetchStatement.pls");        List<ASTFetchStatement> fetchStatements = input.findDescendantsOfType(ASTFetchStatement.class);        Assert.assertEquals(1, fetchStatements.size());        ASTFetchStatement fetch = fetchStatements.get(0);        Assert.assertFalse(fetch.isBulkCollect());        Assert.assertFalse(fetch.isLimit());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class DeleteStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseDeleteStatementExample() {        ASTInput input = plsql.parseResource("DeleteStatementExample.pls");        List<ASTDeleteStatement> deleteStatements = input.findDescendantsOfType(ASTDeleteStatement.class);        Assert.assertEquals(3, deleteStatements.size());        Assert.assertEquals("product_descriptions", deleteStatements.get(0).getChild(0)                                                                    .getFirstChildOfType(ASTTableName.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectUnionTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectUnion() {        plsql.parseResource("SelectUnion.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectIntoWithGroupByTest extends AbstractPLSQLParserTst {    @Test    public void testExample1() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy1.pls");        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        Assert.assertNotNull(groupByClause);    }    @Test    public void testExample2() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy2.pls");        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        Assert.assertNotNull(groupByClause);    }    @Test    public void testExample3WithCube() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy3.pls");        ASTRollupCubeClause cubeClause = input.getFirstDescendantOfType(ASTRollupCubeClause.class);        Assert.assertNotNull(cubeClause);        Assert.assertEquals("CUBE", cubeClause.getImage());    }    @Test    public void testExample4WithGroupingSets() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy4.pls");        ASTGroupingSetsClause groupingSetsClause = input.getFirstDescendantOfType(ASTGroupingSetsClause.class);        Assert.assertNotNull(groupingSetsClause);        List<ASTFromClause> fromClauses = input.findDescendantsOfType(ASTFromClause.class);        Assert.assertEquals(1, fromClauses.size());        Assert.assertEquals(5, fromClauses.get(0).getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectForUpdateTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectForUpdateWait() {        ASTInput input = plsql.parseResource("SelectForUpdateWait.pls");        Assert.assertNotNull(input);        Assert.assertEquals(5, input.findDescendantsOfType(ASTForUpdateClause.class).size());    }    @Test    public void parseSelectForUpdate() {        ASTInput input = plsql.parseResource("SelectForUpdate.pls");        Assert.assertNotNull(input);        List<ASTForUpdateClause> forUpdateClauses = input.findDescendantsOfType(ASTForUpdateClause.class);        Assert.assertEquals(2, forUpdateClauses.size());        Assert.assertEquals(2, forUpdateClauses.get(1).getNumChildren());        Assert.assertEquals("e", forUpdateClauses.get(1).getChild(0).getImage());        Assert.assertEquals("salary", forUpdateClauses.get(1).getChild(1).getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class PLSQLParserTest extends AbstractPLSQLParserTst {    @Test    public void testExceptions() {        plsql.parse("CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                       + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                       + "        doSomethingElse;" + "END;");    }    /**     * See https://sourceforge.net/p/pmd/bugs/1167/     */    @Test    public void testBOM() {        plsql.parse("\ufeff" + "CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                       + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                       + "        doSomethingElse;" + "END;");    }    @Test(timeout = 5000)    public void testBug1531() {        plsql.parse("create or replace force view oxa.o_xa_function_role_types as\n"                       + "select \"CFT_ID\",\"CFR_ID\",\"CFT_NAME\",\"TCN\",\"LOG_MODULE\",\"LOG_USER\",\"LOG_DATE\",\"LOG_TIME\" from crm_function_role_types\n"                       + "/");    }    @Test    public void testBug1527() {        plsql.parseResource("InlinePragmaProcError.pls");    }    @Test    public void testBug1520IsOfType() {        plsql.parseResource("IsOfType.pls");    }    @Test    public void testBug1520Using() {        plsql.parseResource("Using.pls");    }    @Test    public void testSingleLineSelect() {        plsql.parseResource("SingleLineSelect.pls");    }    @Test    public void testMultiLineSelect() {        plsql.parseResource("MultiLineSelect.pls");    }    @Test    public void testIsNull() {        plsql.parseResource("IsNull.pls");    }    @Test    public void testCodingStyleExample() {        plsql.parseResource("CodingStyleExample.pls");    }    @Test    public void testCaseIssue1454() {        plsql.parseResource("CaseIssue1454.pls");    }    @Test    public void testExecuteImmediateIssue3106() {        plsql.parseResource("ExecuteImmediateIssue3106.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class InOutNoCopyTest extends AbstractPLSQLParserTst {    @Test    public void parseInOutNoCopy() {        ASTInput input = plsql.parseResource("InOutNoCopy.pls");        Assert.assertNotNull(input);        List<ASTFormalParameter> params = input.findDescendantsOfType(ASTFormalParameter.class);        Assert.assertEquals(18, params.size());        //detailed check of first 6 test cases        Assert.assertFalse(params.get(0).isIn());        Assert.assertFalse(params.get(0).isOut());        Assert.assertFalse(params.get(0).isNoCopy());        Assert.assertTrue(params.get(1).isIn());        Assert.assertFalse(params.get(1).isOut());        Assert.assertFalse(params.get(1).isNoCopy());        Assert.assertFalse(params.get(2).isIn());        Assert.assertTrue(params.get(2).isOut());        Assert.assertFalse(params.get(2).isNoCopy());        Assert.assertTrue(params.get(3).isIn());        Assert.assertTrue(params.get(3).isOut());        Assert.assertFalse(params.get(3).isNoCopy());        Assert.assertTrue(params.get(4).isIn());        Assert.assertTrue(params.get(4).isOut());        Assert.assertTrue(params.get(4).isNoCopy());        Assert.assertFalse(params.get(5).isIn());        Assert.assertTrue(params.get(5).isOut());        Assert.assertTrue(params.get(5).isNoCopy());        //piecemeal test of other test cases        Assert.assertFalse(params.get(11).isIn());        Assert.assertTrue(params.get(11).isOut());        Assert.assertTrue(params.get(11).isNoCopy());        Assert.assertTrue(params.get(16).isIn());        Assert.assertTrue(params.get(16).isOut());        Assert.assertTrue(params.get(16).isNoCopy());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectExpressionsTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectExpression() {        plsql.parseResource("SelectExpressions.pls");    }    @Test    public void parseSelectSimpleExpression() {        ASTInput input = plsql.parseResource("SelectSimpleExpression.pls");        Assert.assertNotNull(input);        List<ASTSimpleExpression> simpleExpressions = input.findDescendantsOfType(ASTSimpleExpression.class);        Assert.assertEquals(1, simpleExpressions.size());        ASTSimpleExpression exp = simpleExpressions.get(0);        Assert.assertEquals("e.first_name", exp.getImage());        Assert.assertEquals(2, exp.getNumChildren());        Assert.assertEquals(ASTTableName.class, exp.getChild(0).getClass());        Assert.assertEquals(ASTColumn.class, exp.getChild(1).getClass());    }    @Test    public void parseSelectCount() {        plsql.parseResource("SelectCount.pls");    }    @Test    public void parseSelectSubqueryExpression() {        plsql.parseResource("SelectSubqueryExpressions.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CreateTableTest extends AbstractPLSQLParserTst {    @Test    public void parseCreateTable() {        ASTInput input = plsql.parseResource("CreateTable.pls");        // 5th column of first table statement has a inline constraint of type check        ASTTableColumn columnStatus = input.findChildrenOfType(ASTTable.class).get(0).findChildrenOfType(ASTTableColumn.class).get(4);        Assert.assertEquals("status", columnStatus.getFirstChildOfType(ASTID.class).getImage());        Assert.assertEquals(ConstraintType.CHECK, columnStatus.getFirstChildOfType(ASTInlineConstraint.class).getType());    }    @Test    public void parseCreateOrganizedTable() {        plsql.parseResource("CreateOrganizedTable.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TrimWithRecordTypeTest extends AbstractPLSQLParserTst {    @Test    public void parseTrimWithRecordType() {        plsql.parseResource("TrimWithRecordType.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class WhereClauseTest extends AbstractPLSQLParserTst {    @Test    public void testFunctionCall() {        ASTInput input = plsql.parseResource("WhereClauseFunctionCall.pls");        List<ASTSelectIntoStatement> selectStatements = input.findDescendantsOfType(ASTSelectIntoStatement.class);        Assert.assertEquals(4, selectStatements.size());        ASTFunctionCall functionCall = selectStatements.get(0).getFirstDescendantOfType(ASTFunctionCall.class);        Assert.assertEquals("UPPER", functionCall.getImage());        ASTFunctionCall functionCall2 = selectStatements.get(2).getFirstDescendantOfType(ASTFunctionCall.class);        Assert.assertEquals("utils.get_colname", functionCall2.getImage());    }    @Test    public void testLikeCondition() {        plsql.parseResource("WhereClauseLike.pls");    }    @Test    public void testNullCondition() {        plsql.parseResource("WhereClauseIsNull.pls");    }    @Test    public void testBetweenCondition() {        plsql.parseResource("WhereClauseBetween.pls");    }    @Test    public void testInCondition() {        plsql.parseResource("WhereClauseIn.pls");    }    @Test    public void testIsOfTypeCondition() {        plsql.parseResource("WhereClauseIsOfType.pls");    }    @Test    public void testConcatenationOperator() {        plsql.parseResource("WhereClauseConcatenation.pls");    }    @Test    public void testExistsCondition() {        plsql.parseResource("WhereClauseExists.pls");    }    @Test    public void testMultisetCondition() {        plsql.parseResource("WhereClauseMultiset.pls");    }    @Test    public void testRegexpLikeCondition() {        ASTInput input = plsql.parseResource("WhereClauseRegexpLike.pls");        List<ASTRegexpLikeCondition> regexps = input.findDescendantsOfType(ASTRegexpLikeCondition.class);        Assert.assertEquals(3, regexps.size());        Assert.assertEquals("last_name", regexps.get(1).getSourceChar().getImage());        Assert.assertEquals("'([aeiou])\\1'", regexps.get(1).getPattern().getImage());        Assert.assertEquals("'i'", regexps.get(1).getMatchParam());    }    @Test    public void testSubqueries() {        plsql.parseResource("WhereClauseSubqueries.pls");    }    @Test    public void testParentheses() {        plsql.parseResource("WhereClauseParens.pls");    }    @Test    public void testCurrentOf() {        plsql.parseResource("WhereCurrentOf.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class AnonymousBlockTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorInsideProcAnonymousBlock() {        plsql.parseResource("AnonymousBlock1.sql");    }    @Test    public void parseCursorInsideAnonymousBlock() {        plsql.parseResource("AnonymousBlock2.sql");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TriggerTest extends AbstractPLSQLParserTst {    /**     * Parsing a trigger should not result in a NPE.     *     * @see <a href="https://github.com/pmd/pmd/issues/2325">#2325 [plsql] NullPointerException while running parsing test for CREATE TRIGGER</a>     */    @Test    public void parseCreateTrigger() {        ASTInput input = plsql.parseResource("TriggerUnit.pls");        PLSQLNode trigger = input.getChild(0);        Assert.assertEquals(ASTTriggerUnit.class, trigger.getClass());        Assert.assertNotNull(trigger.getScope());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorWithWithTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorWithWith() {        ASTInput input = plsql.parseResource("CursorWithWith.pls");        ASTCursorUnit cursor = input.getFirstDescendantOfType(ASTCursorUnit.class);        ASTSelectStatement select = (ASTSelectStatement) cursor.getChild(1);        ASTWithClause with = (ASTWithClause) select.getChild(0);        ASTName queryName = (ASTName) with.getChild(0);        Assert.assertEquals("risk_set", queryName.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SlashAsDivisionTest extends AbstractPLSQLParserTst {    @Test    public void parseSlashAsDivision() {        plsql.parseResource("SlashAsDivision.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectHierarchicalTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectHierarchicalQueries() {        plsql.parseResource("SelectHierarchical.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.plsql.PlsqlParsingHelper;public class PlsqlTreeDumpTest extends BaseTreeDumpTest {    public PlsqlTreeDumpTest() {        super(new RelevantAttributePrinter(), ".pls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return PlsqlParsingHelper.WITH_PROCESSING.withResourceContext(getClass());    }    @Test    public void sqlPlusLexicalVariables() {        doTest("SqlPlusLexicalVariablesIssue195");    }    @Test    public void parseParsingExclusion() {        doTest("ParsingExclusion");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class XMLTableTest extends AbstractPLSQLParserTst {    @Test    public void testParseXMLTable() {        ASTInput node = plsql.parseResource("XMLTable.pls");        List<ASTFunctionCall> functions = node.findDescendantsOfType(ASTFunctionCall.class);        ASTFunctionCall xmlforest = functions.get(functions.size() - 1);        Assert.assertEquals("XMLFOREST", xmlforest.getImage());        Assert.assertEquals("e.employee_id", xmlforest.getChild(1).getImage());        Assert.assertEquals("foo", xmlforest.getChild(2).getImage());        Assert.assertTrue(xmlforest.getChild(2) instanceof ASTID);        Assert.assertEquals("e.last_name", xmlforest.getChild(3).getImage());        Assert.assertEquals("last_name", xmlforest.getChild(4).getImage());        Assert.assertTrue(xmlforest.getChild(4) instanceof ASTID);        Assert.assertEquals("e.salary", xmlforest.getChild(5).getImage());        Assert.assertEquals(6, xmlforest.getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ViewTest extends AbstractPLSQLParserTst {    @Test    public void parseCreateViewIssue981() {        plsql.parseResource("ViewIssue981.pls");    }    @Test    public void parseCreateView() {        plsql.parseResource("CreateViewWithSubquery.pls");    }    @Test    public void parseCreateViewWithoutSemicolon() {        plsql.parseResource("QueryWithoutSemicolon.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class RecordTypeTest extends AbstractPLSQLParserTst {    @Test    public void parseRecordType() {        plsql.parseResource("RecordType.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class FunctionsTest extends AbstractPLSQLParserTst {    @Test    public void parseTrimCall() {        plsql.parseResource("TrimFunction.pls");    }    @Test    public void parseSelectExtractExpression() {        plsql.parseResource("ExtractExpressions.pls");    }    @Test    public void parseXMLExpression() {        plsql.parseResource("XMLFunctions.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectIntoStatementTest extends AbstractPLSQLParserTst {    @Test    public void testParsingComplex() {        plsql.parseResource("SelectIntoStatement.pls");    }    @Test    public void testParsingExample1() {        plsql.parseResource("SelectIntoStatementExample1.pls");    }    @Test    public void testParsingExample2() {        plsql.parseResource("SelectIntoStatementExample2.pls");    }    @Test    public void testParsingExample3() {        plsql.parseResource("SelectIntoStatementExample3.pls");    }    @Test    public void testParsingExample4() {        plsql.parseResource("SelectIntoStatementExample4.pls");    }    @Test    public void testParsingExample5() {        plsql.parseResource("SelectIntoStatementExample5.pls");    }    @Test(expected = ParseException.class)    public void testParsingExample6Invalid() {        plsql.parseResource("SelectIntoStatementExample6Invalid.pls");    }    @Test    public void testParsingWithFunctionCall() {        plsql.parseResource("SelectIntoStatementFunctionCall.pls");    }    @Test    public void testParsingIntoRecordField() {        plsql.parseResource("SelectIntoStatementRecordField.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class IfStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseIfWithElseIf() throws Exception {        String code = "BEGIN\nIF 1 = 1 THEN null;\nELSIF (2 = 2) THEN null;\nELSE null;\nEND IF;\nEND;\n/\n";        ASTInput input = plsql.parse(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ExecuteImmediateTest extends AbstractPLSQLParserTst {    @Test    public void parseExecuteImmediate1047a() {        plsql.parseResource("ExecuteImmediate1047a.pls");    }    @Test    public void parseExecuteImmediate1047b() {        plsql.parseResource("ExecuteImmediate1047b.pls");    }    @Test    public void parseExecuteImmediateString() {        plsql.parseResource("ExecuteImmediateString.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTSqlStatementTest extends AbstractPLSQLParserTst {    @Test    public void testCommit() {        ASTInput input = plsql.parseResource("CommitStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(1, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.COMMIT);    }    @Test    public void testRollback() {        ASTInput input = plsql.parseResource("RollbackStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(1, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.ROLLBACK);    }    @Test    public void testSavepoint() {        ASTInput input = plsql.parseResource("SavepointStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(2, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.SAVEPOINT);        assertType(sqlStatements, 1, ASTSqlStatement.Type.ROLLBACK);    }    @Test    public void testSetTransaction() {        ASTInput input = plsql.parseResource("SetTransactionStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(3, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.COMMIT);        assertType(sqlStatements, 1, ASTSqlStatement.Type.SET_TRANSACTION);        assertType(sqlStatements, 2, ASTSqlStatement.Type.COMMIT);    }    private void assertType(List<ASTSqlStatement> sqlStatements, int index, ASTSqlStatement.Type expectedType) {        Assert.assertEquals(expectedType, sqlStatements.get(index).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class UpdateStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseUpdateStatementExample() {        ASTInput input = plsql.parseResource("UpdateStatementExample.pls");        List<ASTUpdateStatement> updateStatements = input.findDescendantsOfType(ASTUpdateStatement.class);        Assert.assertEquals(2, updateStatements.size());        Assert.assertEquals(2, updateStatements.get(1).getFirstChildOfType(ASTUpdateSetClause.class)                .findChildrenOfType(ASTColumn.class).size());    }    @Test    public void parseUpdateStatementExample2() {        ASTInput input = plsql.parseResource("UpdateStatementExample2.pls");        Assert.assertNotNull(input);    }    @Test    public void parseUpdateStatementRef() {        ASTInput input = plsql.parseResource("UpdateStatementRef.pls");        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTCompoundConditionTest extends AbstractPLSQLParserTst {    @Test    public void testParseType() {        ASTInput input = plsql.parse("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1 AnD user_id = 2; END;");        List<ASTCompoundCondition> compoundConditions = input.findDescendantsOfType(ASTCompoundCondition.class);        Assert.assertFalse(compoundConditions.isEmpty());        Assert.assertEquals("AND", compoundConditions.get(0).getType());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTExtractExpressionTest extends AbstractPLSQLParserTst {    @Test    public void testXml() {        ASTInput unit = plsql.parse("SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks', "                + "'xmlns:a=\"http://warehouse/1\" xmlns:b=\"http://warehouse/2\"') \"Number of Docks\" "                + " FROM warehouses WHERE warehouse_spec IS NOT NULL;");        ASTExtractExpression extract = unit.getFirstDescendantOfType(ASTExtractExpression.class);        Assert.assertTrue(extract.isXml());        Assert.assertEquals("/Warehouse/Docks", extract.getXPath());        Assert.assertEquals("xmlns:a=\"http://warehouse/1\" xmlns:b=\"http://warehouse/2\"", extract.getNamespace());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class OrderByExpressionsTest extends AbstractPLSQLParserTst {    @Test    public void parseOrderByExpression() {        plsql.parseResource("OrderByExpression.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTComparisonConditionTest extends AbstractPLSQLParserTst {    @Test    public void testOperator() {        ASTInput input = plsql.parse("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1; END;");        List<ASTComparisonCondition> conditions = input.findDescendantsOfType(ASTComparisonCondition.class);        Assert.assertEquals(1, conditions.size());        Assert.assertEquals("=", conditions.get(0).getOperator());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class LexicalParametersTest extends AbstractPLSQLParserTst {    @Test    public void parseLexicalParameters() {        plsql.parseResource("LexicalParameters.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TableCollectionExpressionTest extends AbstractPLSQLParserTst {    @Test    public void testExamples() {        plsql.parseResource("TableCollectionExpressionExamples.pls");    }    @Test    public void testIssue1526() {        plsql.parseResource("TableCollectionExpressionIssue1526.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class StringLiteralsTest extends AbstractPLSQLParserTst {    @Test    public void parseStringLiterals() throws Exception {        ASTInput input = plsql.parseResource("StringLiterals.pls");        List<ASTStringLiteral> strings = input.findDescendantsOfType(ASTStringLiteral.class);        Assert.assertEquals(20, strings.size());        assertString("'Hello'", "Hello", 0, strings);        assertString("N'nchar literal'", "nchar literal", 4, strings);        assertString("nQ'[ab']cd]'", "ab']cd", 11, strings);        assertString("Q'{SELECT * FROM employees WHERE last_name = 'Smith';}'",                "SELECT * FROM employees WHERE last_name = 'Smith';", 13, strings);        assertString("q'{\n" + "    also multiple\n" + "    lines\n" + "  }'",                "\n" + "    also multiple\n" + "    lines\n" + "  ", 15, strings);    }    @Test    public void parseMultilineVarchar() throws Exception {        ASTInput input = plsql.parseResource("MultilineVarchar.pls");        List<ASTStringLiteral> strings = input.findDescendantsOfType(ASTStringLiteral.class);        Assert.assertEquals(1, strings.size());        Assert.assertTrue(normalizeEol(strings.get(0).getString()).startsWith("\ncreate or replace and"));    }    private static void assertString(String quoted, String plain, int index, List<ASTStringLiteral> strings) {        Assert.assertEquals(quoted, normalizeEol(strings.get(index).getImage()));        Assert.assertEquals(plain, normalizeEol(strings.get(index).getString()));    }    private static String normalizeEol(String s) {        return s.replaceAll("\r\n|\n\r|\n|\r", "\n");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql;import static java.util.Collections.singletonList;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.plsql.ast.ASTInput;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;/** * Tests to use XPath rules with PLSQL. */public class PLSQLXPathRuleTest extends AbstractPLSQLParserTst {    private final ASTInput node = plsql.parse(        "create or replace\n" + "package pkg_xpath_problem\n" + "AS\n" + "    PROCEDURE pkg_minimal\n" + "    IS\n"            + "        a_variable VARCHAR2(1);\n" + "    BEGIN \n" + "        --PRAGMA INLINE(output,'YES');\n"            + "        a_variable := 'Y' ;\n" + "    END ;\n" + "end pkg_xpath_problem;\n" + "/\n" + "");    public PLSQLXPathRuleTest() {    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule1() {        testOnVersion(XPathVersion.XPATH_1_0);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule1Compatibility() {        testOnVersion(XPathVersion.XPATH_1_0_COMPATIBILITY);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule2() {        testOnVersion(XPathVersion.XPATH_2_0);    }    private void testOnVersion(XPathVersion xpath10) {        XPathRule rule = new XPathRule(xpath10, "//PrimaryPrefix");        rule.setLanguage(LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME));        rule.setMessage("Test Violation");        RuleContext ctx = new RuleContext();        ctx.setLanguageVersion(plsql.getDefaultVersion());        rule.apply(singletonList(node), ctx);        Assert.assertEquals(2, ctx.getReport().size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class PLSQLTokenizerTest extends CpdTextComparisonTest {    public PLSQLTokenizerTest() {        super(".sql");    }    @Override    protected String getResourcePrefix() {        return "../lang/plsql/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PLSQLTokenizer();    }        @Test    public void testSimple() {        doTest("sample-plsql");    }    @Test    public void testSpecialComments() {        doTest("specialComments");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on PLSQL file with default version     */    @Test    public void testPlsql() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File plsqlFile = new File("/path/to/MY_PACKAGE.sql");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(plsqlFile);        assertEquals("LanguageVersion must be PLSQL!",                LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { PLSQLLanguageModule.NAME, PLSQLLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test plsql's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class SwiftTokenizerTest extends CpdTextComparisonTest {    public SwiftTokenizerTest() {        super(".swift");    }    @Override    protected String getResourcePrefix() {        return "../lang/swift/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new SwiftTokenizer();    }    @Test    public void testSwift42() {        doTest("Swift4.2");    }    @Test    public void testSwift50() {        doTest("Swift5.0");    }    @Test    public void testSwift51() {        doTest("Swift5.1");    }    @Test    public void testSwift52() {        doTest("Swift5.2");    }    @Test    public void testStackoverflowOnLongLiteral() {        doTest("Issue628");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class ObjectiveCTokenizerTest extends CpdTextComparisonTest {    public ObjectiveCTokenizerTest() {        super(".m");    }    @Override    protected String getResourcePrefix() {        return "../lang/objc/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new ObjectiveCTokenizer();    }    @Test    public void testLongSample() {        doTest("big_sample");    }    @Test    public void testUnicodeEscape() {        doTest("unicodeEscapeInString");    }    @Test    public void testUnicodeCharInIdent() {        doTest("unicodeCharInIdent");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.bugs;import java.io.InputStream;import java.io.InputStreamReader;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.typeresolution.testdata.UsesJavaStreams;@Ignorepublic class InterfaceMethodTest {    @Test    public void shouldNotFail() {        ASTCompilationUnit acu = parseAndTypeResolveForClass(UsesJavaStreams.class);    }    // Note: If you're using Eclipse or some other IDE to run this test, you    // _must_ have the regress folder in    // the classpath. Normally the IDE doesn't put source directories themselves    // directly in the classpath, only    // the output directories are in the classpath.    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz) {        String sourceFile = clazz.getName().replace('.', '/') + ".java";        InputStream is = InterfaceMethodTest.class.getClassLoader().getResourceAsStream(sourceFile);        if (is == null) {            throw new IllegalArgumentException("Unable to find source file " + sourceFile + " for " + clazz);        }        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                .getVersion("1.8").getLanguageVersionHandler();        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler                .getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));        languageVersionHandler.getSymbolFacade().start(acu);        languageVersionHandler.getTypeResolutionFacade(InterfaceMethodTest.class.getClassLoader()).start(acu);        return acu;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static org.junit.Assert.assertEquals;import java.io.InputStream;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.List;import org.jaxen.JaxenException;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode;import net.sourceforge.pmd.typeresolution.testdata.SuperClass;import net.sourceforge.pmd.typeresolution.testdata.SuperExpression;import net.sourceforge.pmd.typeresolution.testdata.ThisExpression;import net.sourceforge.pmd.typeresolution.testdata.UsesJavaStreams;import net.sourceforge.pmd.typeresolution.testdata.UsesRepeatableAnnotations;public class ClassTypeResolverJava8Test {    @Test    public void interfaceMethodShouldBeParseable() {        ASTCompilationUnit acu = parseAndTypeResolveForClass18(UsesJavaStreams.class);    }    @Test    public void repeatableAnnotationsMethodShouldBeParseable() {        ASTCompilationUnit acu = parseAndTypeResolveForClass18(UsesRepeatableAnnotations.class);    }    @Test    public void testThisExpression() throws JaxenException {        ASTCompilationUnit acu = parseAndTypeResolveForClass18(ThisExpression.class);        List<ASTPrimaryExpression> expressions = convertList(                acu.findChildNodesWithXPath("//VariableInitializer/Expression/PrimaryExpression"),                ASTPrimaryExpression.class);        List<ASTPrimaryPrefix> prefixes = convertList(                acu.findChildNodesWithXPath("//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix"),                ASTPrimaryPrefix.class);        int index = 0;        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.PrimaryThisInterface.class, expressions.get(index).getType());        assertEquals(ThisExpression.PrimaryThisInterface.class, prefixes.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());        assertEquals("All expressions not tested", index, prefixes.size());    }    @Test    public void testSuperExpression() throws JaxenException {        ASTCompilationUnit acu = parseAndTypeResolveForClass18(SuperExpression.class);        List<AbstractJavaTypeNode> expressions = convertList(                acu.findChildNodesWithXPath("//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix"),                AbstractJavaTypeNode.class);        int index = 0;        assertEquals(SuperClass.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    private static <T> List<T> convertList(List<Node> nodes, Class<T> target) {        List<T> converted = new ArrayList<>();        for (Node n : nodes) {            converted.add(target.cast(n));        }        return converted;    }    private ASTCompilationUnit parseAndTypeResolveForClass18(Class<?> clazz) {        return parseAndTypeResolveForClass(clazz, "1.8");    }    // Note: If you're using Eclipse or some other IDE to run this test, you    // _must_ have the regress folder in    // the classpath. Normally the IDE doesn't put source directories themselves    // directly in the classpath, only    // the output directories are in the classpath.    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {        String sourceFile = clazz.getName().replace('.', '/') + ".java";        InputStream is = ClassTypeResolverJava8Test.class.getClassLoader().getResourceAsStream(sourceFile);        if (is == null) {            throw new IllegalArgumentException("Unable to find source file " + sourceFile + " for " + clazz);        }        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                .getVersion(version).getLanguageVersionHandler();        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler                .getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new InputStreamReader(is));        languageVersionHandler.getSymbolFacade().start(acu);        languageVersionHandler.getQualifiedNameResolutionFacade(ClassTypeResolverJava8Test.class.getClassLoader()).start(acu);        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverJava8Test.class.getClassLoader()).start(acu);        return acu;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;import net.sourceforge.pmd.lang.scala.ast.BaseScalaTest;public class XPathRuleTest extends BaseScalaTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    public void testPrintHelloWorld() {        Report report = evaluate(SCALA_TEST, "//TermApply/TermName[@Image=\"println\"]");        RuleViolation rv = report.iterator().next();        assertEquals(2, rv.getBeginLine());    }    private Report evaluate(String testSource, String xpath) {        XPathRule rule = new XPathRule(XPathVersion.XPATH_2_0, xpath);        rule.setLanguage(LanguageRegistry.getLanguage(ScalaLanguageModule.NAME));        rule.setMessage("XPath Rule Failed");        return scala.getReportForResource(rule, testSource);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import java.util.Collections;import java.util.concurrent.atomic.AtomicInteger;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.internal.util.IteratorUtil;import net.sourceforge.pmd.lang.scala.ast.ASTSource;import net.sourceforge.pmd.lang.scala.ast.ASTTermApply;import net.sourceforge.pmd.lang.scala.ast.ASTTermName;import net.sourceforge.pmd.lang.scala.ast.BaseScalaTest;import net.sourceforge.pmd.lang.scala.ast.ScalaNode;public class ScalaRuleTest extends BaseScalaTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    public void testRuleVisits() {        final AtomicInteger visited = new AtomicInteger();        ScalaRule rule = new ScalaRule() {            @Override            public RuleContext visit(ScalaNode<?> node, RuleContext data) {                visited.incrementAndGet();                return super.visit(node, data);            }        };        ASTSource root = scala.parseResource(SCALA_TEST);        rule.apply(Collections.singletonList(root), null);        Assert.assertEquals(12, visited.get());    }    @Test    public void testDummyRule() {        ScalaRule rule = new ScalaRule() {            @Override            public RuleContext visit(ASTTermApply node, RuleContext data) {                ASTTermName child = node.getFirstChildOfType(ASTTermName.class);                if (child != null && child.hasImageEqualTo("println")) {                    addViolation(data, node);                }                return data;            }        };        Report report = scala.getReportForResource(rule, SCALA_TEST);        Assert.assertEquals(1, IteratorUtil.count(report.iterator()));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.ast;/** * @author Clément Fournier */public abstract class BaseScalaTest {    protected final ScalaParsingHelper scala = ScalaParsingHelper.DEFAULT.withResourceContext(getClass());}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.ast.TokenMgrError;public class ScalaTokenizerTest extends CpdTextComparisonTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    public ScalaTokenizerTest() {        super(".scala");    }    @Override    protected String getResourcePrefix() {        return "../lang/scala/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new ScalaTokenizer();    }    @Test    public void testSample() {        doTest("sample-LiftActor");    }    @Test    public void testSuppressionComments() {        doTest("special_comments");    }    @Test    public void tokenizeFailTest() {        ex.expect(TokenMgrError.class);        doTest("unlexable_sample");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.13",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.13"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.12",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.12"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.11",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.11"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.10",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.10"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test scala rulesets */public class RulesetFactoryTest extends AbstractRuleSetFactoryTest {    // no rulesets yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidTrailingCommaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InnaccurateNumericLiteralTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EqualComparisonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryParenthesesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoElseReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnreachableCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ScopeForInVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsistentReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GlobalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidWithStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseBaseWithParseIntTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTForInLoopTest extends EcmascriptParserTestBase {    /**     * Note: for each loops are deprecated.     *     * @see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in">for each...in</a>     */    @Test    public void testForEachLoop() {        ASTAstRoot node = js.parse("for each (var item in items) {}");        ASTForInLoop loop = (ASTForInLoop) node.getChild(0);        Assert.assertFalse(loop.isForOf());        Assert.assertTrue(loop.isForEach());    }    @Test    public void testForOfLoop() {        ASTAstRoot node = js.parse("for (var item of items) {}");        ASTForInLoop loop = (ASTForInLoop) node.getChild(0);        Assert.assertTrue(loop.isForOf());        Assert.assertFalse(loop.isForEach());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import org.mozilla.javascript.ast.AstRoot;/** * See the following bugs: #1141 ECMAScript: getFinallyBlock() is buggy. #1142 * ECMAScript: getCatchClause() is buggy */public class ASTTryStatementTest extends EcmascriptParserTestBase {    private ASTTryStatement getTryStmt(String js) {        EcmascriptNode<AstRoot> node = this.js.parse(js);        List<ASTTryStatement> trys = node.findDescendantsOfType(ASTTryStatement.class);        Assert.assertEquals(1, trys.size());        ASTTryStatement tryStmt = trys.get(0);        return tryStmt;    }    @Test    public void testFinallyBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } finally { } }");        Assert.assertNull(tryStmt.getCatchClause(0));        Assert.assertFalse(tryStmt.hasCatch());        Assert.assertEquals(0, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }    @Test    public void testCatchBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(1, tryStmt.getNumCatchClause());        Assert.assertNull(tryStmt.getFinallyBlock());        Assert.assertFalse(tryStmt.hasFinally());    }    @Test    public void testCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } finally { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(1, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }    @Test    public void testMultipleCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt(                "function() { " + "try { } " + "catch (error if error instanceof BadError) { } "                        + "catch (error2 if error2 instanceof OtherError) { } " + "finally { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertNotNull(tryStmt.getCatchClause(1));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(2, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import java.util.Locale;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;public class TrailingCommaTest extends EcmascriptParserTestBase {    @Rule    public DefaultLocale defaultLocale = new DefaultLocale();    @Test    public void testTrailingCommaDefaultLocale() {        testTrailingComma();    }    @Test    public void testTrailingCommaFrFr() {        defaultLocale.set(Locale.FRANCE);        testTrailingComma();    }    @Test    public void testTrailingCommaRootLocale() {        defaultLocale.set(Locale.ROOT);        testTrailingComma();    }    public void testTrailingComma() {        ASTAstRoot node = js.parse("x = {a : 1, };\n");        ASTObjectLiteral fn = node.getFirstDescendantOfType(ASTObjectLiteral.class);        Assert.assertTrue(fn.isTrailingComma());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.io.Reader;import java.io.StringReader;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.Test;import org.mozilla.javascript.ast.AstRoot;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ecmascript.Ecmascript3Parser;import net.sourceforge.pmd.lang.ecmascript.EcmascriptParserOptions;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;public class EcmascriptParserTest extends EcmascriptParserTestBase {    /**     * https://sourceforge.net/p/pmd/bugs/1043/     */    @Test    public void testLineNumbers() {        final String SOURCE_CODE = "function a() {" + PMD.EOL + "  alert('hello');" + PMD.EOL + "}" + PMD.EOL;        EcmascriptNode<AstRoot> node = js.parse(SOURCE_CODE);        assertEquals(1, node.getBeginLine());        assertEquals(1, node.getBeginColumn());        assertEquals(3, node.getEndLine());        assertEquals(1, node.getEndColumn());        Node child = node.getFirstChildOfType(ASTFunctionNode.class);        assertEquals(1, child.getBeginLine());        assertEquals(1, child.getBeginColumn());        assertEquals(3, child.getEndLine());        assertEquals(1, child.getEndColumn());        child = node.getFirstDescendantOfType(ASTFunctionCall.class);        assertEquals(2, child.getBeginLine());        assertEquals(3, child.getBeginColumn());        assertEquals(2, child.getEndLine());        assertEquals(16, child.getEndColumn());    }    /**     * https://sourceforge.net/p/pmd/bugs/1149/     */    @Test    public void testLineNumbersWithinEcmascriptRules() {        String source = "function f(x){\n" + "   if (x) {\n" + "       return 1;\n" + "   } else {\n"                + "       return 0;\n" + "   }\n" + "}";        final List<String> output = new ArrayList<>();        class MyEcmascriptRule extends AbstractEcmascriptRule {            public Object visit(ASTScope node, Object data) {                output.add("Scope from " + node.getBeginLine() + " to " + node.getEndLine());                return super.visit(node, data);            }        }        MyEcmascriptRule rule = new MyEcmascriptRule();        RuleContext ctx = new RuleContext();        rule.apply(Arrays.asList(js.parse(source)), ctx);        assertEquals("Scope from 2 to 4", output.get(0));        assertEquals("Scope from 4 to 6", output.get(1));    }    /**     * Test bug https://sourceforge.net/p/pmd/bugs/1118/     */    @Test    public void testArrayAccess() {        EcmascriptNode<AstRoot> node = js.parse("function a() { b['a'] = 1; c[1] = 2; }");        List<ASTElementGet> arrays = node.findDescendantsOfType(ASTElementGet.class);        assertEquals("b", arrays.get(0).getTarget().getImage());        assertEquals("a", arrays.get(0).getElement().getImage());        assertEquals("c", arrays.get(1).getTarget().getImage());        assertEquals("1", arrays.get(1).getElement().getImage());    }    /**     * Test for bug #1136 ECAMScript: NullPointerException in getLeft() and     * getRight()     */    @Test    public void testArrayMethod() {        EcmascriptNode<AstRoot> rootNode = js.parse(            "function test(){\n" + "  a();      // OK\n" + "  b.c();    // OK\n" + "  d[0]();   // OK\n"                + "  e[0].f(); // OK\n" + "  y.z[0](); // FAIL ==> java.lang.NullPointerException\n" + "}");        List<ASTFunctionCall> calls = rootNode.findDescendantsOfType(ASTFunctionCall.class);        List<String> results = new ArrayList<>();        for (ASTFunctionCall f : calls) {            Node node = f.getTarget();            results.add(getName(node));        }        assertEquals("[a, b.c, d[], e[].f, y.z[]]", results.toString());    }    private String getName(Node node) {        if (node instanceof ASTName) {            return ((ASTName) node).getIdentifier();        }        if (node instanceof ASTPropertyGet) {            final ASTPropertyGet pgNode = (ASTPropertyGet) node;            final String leftName = getName(pgNode.getLeft());            final String rightName = getName(pgNode.getRight());            return leftName + "." + rightName;        }        if (node instanceof ASTElementGet) {            return getName(((ASTElementGet) node).getTarget()) + "[]";        }        return "????";    }    /**     * https://sourceforge.net/p/pmd/bugs/1150/ #1150 "EmptyExpression" for     * valid statements!     */    @Test    public void testCaseAsIdentifier() {        ASTAstRoot rootNode = js.parse("function f(a){\n" + "    a.case.flag = 1;\n" + "    return;\n" + "}");        ASTBlock block = rootNode.getFirstDescendantOfType(ASTBlock.class);        assertFalse(block.getChild(0) instanceof ASTEmptyExpression);        assertTrue(block.getChild(0) instanceof ASTExpressionStatement);        assertTrue(block.getChild(0).getChild(0) instanceof ASTAssignment);    }    /**     * https://sourceforge.net/p/pmd/bugs/1045/ #1045 //NOPMD not working (or     * not implemented) with ECMAscript     */    @Test    public void testSuppresionComment() {        Ecmascript3Parser parser = new Ecmascript3Parser(new EcmascriptParserOptions());        Reader sourceCode = new StringReader("function(x) {\n" + "x = x; //NOPMD I know what I'm doing\n" + "}\n");        parser.parse("foo", sourceCode);        assertEquals(" I know what I'm doing", parser.getSuppressMap().get(2));        assertEquals(1, parser.getSuppressMap().size());        EcmascriptParserOptions parserOptions = new EcmascriptParserOptions();        parserOptions.setSuppressMarker("FOOOO");        parser = new Ecmascript3Parser(parserOptions);        sourceCode = new StringReader(                "function(x) {\n" + "y = y; //NOPMD xyz\n" + "x = x; //FOOOO I know what I'm doing\n" + "}\n");        parser.parse("foo", sourceCode);        assertEquals(" I know what I'm doing", parser.getSuppressMap().get(3));        assertEquals(1, parser.getSuppressMap().size());    }    /**     * #1191 Ecmascript fails to parse "void(0)"     */    @Test    public void testVoidKeyword() {        ASTAstRoot rootNode = js.parse("function f(matchFn, fieldval, n){\n"                                           + "    return (matchFn)?(matcharray = eval(matchFn+\"('\"+fieldval+\"','\"+n.id+\"')\")):void(0);\n"                                           + "}\n");        ASTUnaryExpression unary = rootNode.getFirstDescendantOfType(ASTUnaryExpression.class);        assertEquals("void", unary.getImage());    }    /**     * #1192 Ecmascript fails to parse this operator " ^= "     */    @Test    public void testXorAssignment() {        ASTAstRoot rootNode = js.parse("function f() { var x = 2; x ^= 2; x &= 2; x |= 2; "                                           + "x &&= true; x ||= false; x *= 2; x /= 2; x %= 2; x += 2; x -= 2; "                                           + "x <<= 2; x >>= 2; x >>>= 2; }");        ASTAssignment infix = rootNode.getFirstDescendantOfType(ASTAssignment.class);        assertEquals("^=", infix.getImage());    }    /**     * [javascript] Failing with OutOfMemoryError parsing a Javascript file #2081     */    @Test(timeout = 5000L)    public void shouldNotFailWithOutOfMemory() {        ASTAstRoot rootNode = js.parse("(``\n);");        assertNotNull(rootNode);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTVariableDeclarationTest extends EcmascriptParserTestBase {    @Test    public void testLet() {        ASTAstRoot node = js.parse("let x = 1;");        ASTVariableDeclaration varDecl = (ASTVariableDeclaration) node.getChild(0);        Assert.assertTrue(varDecl.isLet());        ASTVariableInitializer varInit = (ASTVariableInitializer) varDecl.getChild(0);        ASTName name = (ASTName) varInit.getChild(0);        Assert.assertEquals("x", name.getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.NodePrintersKt;public class JsTreeDumpTest extends BaseTreeDumpTest {    public JsTreeDumpTest() {        super(NodePrintersKt.getSimpleNodePrinter(), ".js");    }    @Override    public BaseParsingHelper<JsParsingHelper, ASTAstRoot> getParser() {        return JsParsingHelper.DEFAULT.withResourceContext(JsTreeDumpTest.class, "testdata");    }    @Test    public void simpleJavascriptFile() {        doTest("SimpleJavascriptFile");    }    @Test    public void jquerySelector() {        doTest("jquery-selector");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTFunctionNodeTest extends EcmascriptParserTestBase {    @Test    public void testGetBody() {        ASTAstRoot node = js.parse("function foo() { var a = 'a'; }");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        Assert.assertFalse(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        Assert.assertTrue(body instanceof ASTBlock);    }    @Test    public void testGetBodyFunctionClosureExpression() {        ASTAstRoot node = js18.parse("(function(x) x*x)");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        Assert.assertTrue(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        Assert.assertTrue(body instanceof ASTBlock);        Assert.assertTrue(body.getChild(0) instanceof ASTReturnStatement);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript;import static net.sourceforge.pmd.lang.ParserOptionsTestUtils.verifyOptionsEqualsHashcode;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ecmascript.EcmascriptParserOptions.Version;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;import net.sourceforge.pmd.properties.BooleanProperty;public class EcmascriptParserOptionsTest {    @Test    public void testDefaults() throws Exception {        EcmascriptParserOptions parserOptions = new EcmascriptParserOptions();        assertTrue(parserOptions.isRecordingComments());        assertTrue(parserOptions.isRecordingLocalJsDocComments());        assertEquals(EcmascriptParserOptions.Version.VERSION_ES6, parserOptions.getRhinoLanguageVersion());        MyRule rule = new MyRule();        parserOptions = (EcmascriptParserOptions) rule.getParserOptions();        assertTrue(parserOptions.isRecordingComments());        assertTrue(parserOptions.isRecordingLocalJsDocComments());        assertEquals(EcmascriptParserOptions.Version.VERSION_ES6, parserOptions.getRhinoLanguageVersion());    }    @Test    public void testConstructor() throws Exception {        MyRule rule = new MyRule();        rule.setProperty(EcmascriptParserOptions.RECORDING_COMMENTS_DESCRIPTOR, true);        assertTrue(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingComments());        rule.setProperty(EcmascriptParserOptions.RECORDING_COMMENTS_DESCRIPTOR, false);        assertFalse(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingComments());        rule.setProperty(EcmascriptParserOptions.RECORDING_LOCAL_JSDOC_COMMENTS_DESCRIPTOR, true);        assertTrue(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingLocalJsDocComments());        rule.setProperty(EcmascriptParserOptions.RECORDING_LOCAL_JSDOC_COMMENTS_DESCRIPTOR, false);        assertFalse(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingLocalJsDocComments());        rule.setProperty(EcmascriptParserOptions.RHINO_LANGUAGE_VERSION, Version.VERSION_DEFAULT);        assertEquals(EcmascriptParserOptions.Version.VERSION_DEFAULT,                ((EcmascriptParserOptions) rule.getParserOptions()).getRhinoLanguageVersion());        rule.setProperty(EcmascriptParserOptions.RHINO_LANGUAGE_VERSION, Version.VERSION_1_8);        assertEquals(EcmascriptParserOptions.Version.VERSION_1_8,                ((EcmascriptParserOptions) rule.getParserOptions()).getRhinoLanguageVersion());    }    @Test    public void testSetters() {        EcmascriptParserOptions options = new EcmascriptParserOptions();        options.setSuppressMarker("foo");        assertEquals("foo", options.getSuppressMarker());        options.setSuppressMarker(null);        assertNull(options.getSuppressMarker());    }    @Test    public void testEqualsHashcode() throws Exception {        BooleanProperty[] properties = {EcmascriptParserOptions.RECORDING_COMMENTS_DESCRIPTOR,                                        EcmascriptParserOptions.RECORDING_LOCAL_JSDOC_COMMENTS_DESCRIPTOR, };        for (int i = 0; i < properties.length; i++) {            BooleanProperty property = properties[i];            MyRule rule = new MyRule();            rule.setProperty(property, true);            ParserOptions options1 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options2 = rule.getParserOptions();            rule.setProperty(property, true);            ParserOptions options3 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options4 = rule.getParserOptions();            verifyOptionsEqualsHashcode(options1, options2, options3, options4);        }        EcmascriptParserOptions options1 = new EcmascriptParserOptions();        options1.setSuppressMarker("foo");        EcmascriptParserOptions options2 = new EcmascriptParserOptions();        options2.setSuppressMarker("bar");        EcmascriptParserOptions options3 = new EcmascriptParserOptions();        options3.setSuppressMarker("foo");        EcmascriptParserOptions options4 = new EcmascriptParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);        options1 = new EcmascriptParserOptions();        options1.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_DEFAULT);        options2 = new EcmascriptParserOptions();        options2.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_1_8);        options3 = new EcmascriptParserOptions();        options3.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_DEFAULT);        options4 = new EcmascriptParserOptions();        options4.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_1_8);        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    private static final class MyRule extends AbstractEcmascriptRule {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.emptyString;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    @Test    public void shouldFindDuplicatesWithDifferentFileExtensions() {        runCPD("--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File1.ts",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File2.ts");        assertThat(getOutput(), containsString("Found a 9 line (32 tokens) duplication in the following files"));    }    @Test    public void shouldFindNoDuplicatesWithDifferentFileExtensions() {        runCPD("--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/");        assertThat(getOutput().trim(), emptyString());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class EcmascriptTokenizerTest extends CpdTextComparisonTest {    public EcmascriptTokenizerTest() {        super(".js");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new EcmascriptTokenizer();    }    @Override    protected String getResourcePrefix() {        return "../lang/ecmascript/cpd/testdata";    }    @Test    public void testSimple() {        doTest("simple");    }    @Test    public void testSimplewithSemis() {        doTest("simpleWithSemis");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1239/     */    @Test    public void parseStringNotAsMultiline() {        doTest("lineContinuations");    }    @Test    public void testIgnoreSingleLineComments() {        doTest("singleLineCommentIgnore");    }    @Test    public void testIgnoreMultiLineComments() {        doTest("multilineCommentIgnore");    }    @Test    public void testTemplateStrings() {        doTest("templateStrings");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * */public class AnyTokenizerForTypescriptTest extends CpdTextComparisonTest {    public AnyTokenizerForTypescriptTest() {        super(".ts");    }    @Override    protected String getResourcePrefix() {        return "testdata/ts";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new AnyTokenizer();    }    @Test    public void testFile1() {        doTest("SampleTypeScript");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testEcmascript() {        executeTarget("testEcmascript");        assertOutputContaining("A 'return', 'break', 'continue', or 'throw' statement should be the last in a block.");        assertOutputContaining("Avoid using global variables");        assertOutputContaining("Use ===/!== to compare with true/false or Numbers");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.util.FileUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CLITest extends BaseCLITest {    @Test    public void useEcmaScript() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "xml", "-R", "ecmascript-basic", "-version", "3", "-l",            "ecmascript", "-debug", };        String resultFilename = runTest(args, "useEcmaScript");        assertTrue("Invalid JavaScript version",                FileUtil.findPatternInFile(new File(resultFilename), "Using Ecmascript version: Ecmascript 3"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ecmascript.EcmascriptLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { EcmascriptLanguageModule.NAME, EcmascriptLanguageModule.TERSE_NAME, "3",            LanguageRegistry.getLanguage(EcmascriptLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ecmascript.EcmascriptLanguageModule;import net.sourceforge.pmd.lang.ecmascript.ast.ASTFunctionNode;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;import net.sourceforge.pmd.lang.ecmascript.rule.EcmascriptRuleViolationFactory;import net.sourceforge.pmd.testframework.RuleTst;public class ReportTest extends RuleTst {    @Test    public void testExclusionsInReportWithNOPMDEcmascript() throws Exception {        Report rpt = new Report();        Rule rule = new AbstractEcmascriptRule() {            @Override            public Object visit(ASTFunctionNode node, Object data) {                EcmascriptRuleViolationFactory.INSTANCE.addViolation((RuleContext) data, this, node, "Test", null);                return super.visit(node, data);            }        };        String code = "function(x) // NOPMD test suppress\n" + "{ x = 1; }";        runTestFromString(code, rule, rpt,                LanguageRegistry.getLanguage(EcmascriptLanguageModule.NAME).getDefaultVersion());        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test javascript's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.VfTokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class VfTokenizerTest extends CpdTextComparisonTest {    public VfTokenizerTest() {        super(".page");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        VfTokenizer tokenizer = new VfTokenizer();        return tokenizer;    }    @Test    public void testTokenize() {        doTest("SampleUnescapeElWithTab");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfHtmlStyleTagXssTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.nio.file.Path;import java.nio.file.Paths;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.RulesetsFactoryUtils;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfLanguageModule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfUnescapeElTest extends PmdRuleTst {    public static final String EXPECTED_RULE_MESSAGE = "Avoid unescaped user controlled content in EL";    /**     * Verify that CustomFields stored in sfdx project format are correctly parsed     */    @Test    public void testSfdxCustomFields() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("StandardAccount.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals("Number of violations", 20, ruleViolations.size());        int firstLineWithErrors = 14;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            int expectedLineNumber = firstLineWithErrors + i;            if ((ruleViolations.size() + firstLineWithErrors - 1) == expectedLineNumber) {                // The last line has two errors on the same page                expectedLineNumber = expectedLineNumber - 1;            }            assertEquals("Line Number", expectedLineNumber, ruleViolation.getBeginLine());        }    }    /**     * Verify that CustomFields stored in mdapi format are correctly parsed     */    @Test    public void testMdapiCustomFields() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Vf).resolve("StandardAccount.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals("Number of violations", 6, ruleViolations.size());        int firstLineWithErrors = 8;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals("Line Number", firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Tests a page with a single Apex controller     */    @Test    public void testApexController() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("ApexController.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals("Number of violations", 2, ruleViolations.size());        int firstLineWithErrors = 9;        for (int i = 0; i < ruleViolations.size(); i++) {            // There should start at line 9            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals("Line Number", firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Tests a page with a standard controller and two Apex extensions     */    @Test    public void testExtensions() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve(Paths.get("StandardAccountWithExtensions.page"));        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals(8, ruleViolations.size());        int firstLineWithErrors = 9;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals(firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Runs a rule against a Visualforce page on the file system. This code is based on     * {@link net.sourceforge.pmd.testframework.RuleTst#runTestFromString(String, Rule, Report, LanguageVersion, boolean)}     */    private Report runRule(Path vfPagePath) throws FileNotFoundException, PMDException {        LanguageVersion languageVersion = LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = languageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = languageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse(vfPagePath.toString(), new FileReader(vfPagePath.toFile()));        assertNotNull(node);        // BEGIN Based on RuleTst class        PMD p = new PMD();        p.getConfiguration().setDefaultLanguageVersion(languageVersion);        p.getConfiguration().setIgnoreIncrementalAnalysis(true);        // simple class loader, that doesn't delegate to parent.        // this allows us in the tests to simulate PMD run without        // auxclasspath, not even the classes from the test dependencies        // will be found.        p.getConfiguration().setClassLoader(new ClassLoader() {            @Override            protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {                if (name.startsWith("java.") || name.startsWith("javax.")) {                    return super.loadClass(name, resolve);                }                throw new ClassNotFoundException(name);            }        });        Rule rule = findRule("category/vf/security.xml", "VfUnescapeEl");        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFile(vfPagePath.toFile());        ctx.setLanguageVersion(languageVersion);        ctx.setIgnoreExceptions(false);        RuleSet rules = RulesetsFactoryUtils.defaultFactory().createSingleRuleRuleSet(rule);        p.getSourceCodeProcessor().processSourceCode(new FileReader(vfPagePath.toFile()), new RuleSets(rules), ctx);        // END Based on RuleTst class        return report;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfCsrfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;/*** * Unit tests to focus on regex pattern used to identify URL methods within style tags */public class VfHtmlXssStyleTagUrlPatternMatchingTest {    @Test    public void testUrlMethodPatternMatchForPositive() {        final String sampleString = "div {  background: url(blah";        assertTrue("Sample should be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }    @Test    public void testUrlMethodPatternMatchForCaseInsensitive() {        final String sampleString = "div {  background: uRl(";        assertTrue("Sample should be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }    @Test    public void testUrlMethodPatternMatchForWhitespaceAfterUrl() {        final String sampleString = "div {  background: url (";        assertTrue("Sample should be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }    @Test    public void testUrlMethodPatternMatchForClosedUrl() {        final String sampleString = "div {  background: url('myUrl')";        assertFalse("Sample should not be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }    @Test    public void testUrlMethodPatternMatchForClosedUrlWithNoContent() {        final String sampleString = "div {  background: url() ";        assertFalse("Sample should not be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }    @Test    public void testUrlMethodPatternMatchForUrlNoBracket() {        final String sampleString = "div {  background: url";        assertFalse("Sample should not be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }    @Test    public void testUrlMethodPatternMatchForNoUrl() {        final String sampleString = "div {  background: myStyle('";        assertFalse("Sample should not be considered as starting a URL method: " + sampleString, VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.IOException;import java.io.StringReader;import java.util.List;import java.util.Map;import java.util.stream.Collectors;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.SimpleCharStream;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer;public class ASTExpressionTest {    /**     * Slightly different scenarios which cause different AST, but should return the same results.     */    private static final String[] SNIPPET_TEMPLATES = new String[] {        "{!%s}",        "<apex:outputText value=\"{!%s}\" escape=\"false\"/>",        "<script>function someFunc() {var foo = \"{!%s}\";}</script>" };    @Test    public void testExpressionWithApexGetter() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyValue"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertTrue(template, map.containsKey("MyValue"));            assertTrue(template, map.get("MyValue") instanceof ASTIdentifier);        }    }    @Test    public void testExpressionWithStandardController() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c.Text__c"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertTrue(template, map.containsKey("MyObject__c.Text__c"));            assertTrue(template, map.get("MyObject__c.Text__c") instanceof ASTIdentifier);        }    }    @Test    public void testSelectOptions() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "userOptions.0"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertTrue(template, map.containsKey("userOptions.0"));            assertTrue(template, map.get("userOptions.0") instanceof ASTLiteral);        }    }    @Test    public void testMultipleIdentifiers() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c.Text__c + ' this is a string' + MyObject__c.Text2__c"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 2, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertEquals(template, 2, map.size());            assertTrue(template, map.containsKey("MyObject__c.Text__c"));            assertTrue(template, map.get("MyObject__c.Text__c") instanceof ASTIdentifier);            assertTrue(template, map.containsKey("MyObject__c.Text2__c"));            assertTrue(template, map.get("MyObject__c.Text2__c") instanceof ASTIdentifier);        }    }    @Test    public void testIdentifierWithRelation() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c.MyObject2__r.Text__c"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertEquals(template, 1, map.size());            assertTrue(template, map.containsKey("MyObject1__c.MyObject2__r.Text__c"));            assertTrue(template, map.get("MyObject1__c.MyObject2__r.Text__c") instanceof ASTIdentifier);        }    }    @Test    public void testMultipleIdentifiersWithRelation() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c.MyObject2__r.Text__c + ' this is a string' + MyObject1__c.MyObject2__r.Text2__c"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 2, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertEquals(template, 2, map.size());            assertTrue(template, map.containsKey("MyObject1__c.MyObject2__r.Text__c"));            assertTrue(template, map.get("MyObject1__c.MyObject2__r.Text__c") instanceof ASTIdentifier);            assertTrue(template, map.containsKey("MyObject1__c.MyObject2__r.Text2__c"));            assertTrue(template, map.get("MyObject1__c.MyObject2__r.Text2__c") instanceof ASTIdentifier);        }    }    /**     * The current implementation does not support expressing statements using array notation. This notation introduces     * complexities that may be addressed in a future release.     */    @Test    public void testExpressionWithArrayIndexingNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c['Name']"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 2, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    @Test    public void testIdentifierWithRelationIndexedAsArrayNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c['MyObject2__r'].Text__c"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 2, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    @Test    public void testIdentifierWithComplexIndexedArrayNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "theLineItems[item.Id].UnitPrice"));            List<Node> nodes = VFTestUtils.findNodes(compilationUnit, "//Expression");            assertEquals(template, 2, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    /**     * Invert the map to make it easier to unit test.     */    private Map<String, Node> invertMap(Map<VfTypedNode, String> map) {        Map<String, Node> result = map.entrySet().stream()                .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));        // Ensure no values have been lost        assertEquals(map.size(), result.size());        return result;    }    private ASTCompilationUnit compile(String snippet) {        return compile(snippet, false);    }    private ASTCompilationUnit compile(String snippet, boolean renderAST) {        ASTCompilationUnit node = new net.sourceforge.pmd.lang.vf.ast.VfParser(                new SimpleCharStream(new StringReader("<apex:page>"                        + snippet                        + "</apex:page>"))).CompilationUnit();        if (renderAST) {            try {                new XmlTreeRenderer().renderSubtree(node, System.out);            } catch (IOException e) {                throw new RuntimeException(e);            }        }        return node;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;/** * @author sergey.gorbaty */public class VfParserTest extends AbstractVfNodesTest {    @Test    public void testSingleDoubleQuoteAndEL() {        vf.parse("<span escape='false' attrib=\"{!call}\">${!'yes'}</span>");    }    @Test    public void testSingleDoubleQuoteAndELFunction() {        vf.parse("<span escape='false' attrib=\"{!call}\">${!method}</span>");    }    @Test    public void testSingleDoubleQuote() {        vf.parse("<span escape='false' attrib=\"{!call}\">${\"yes\"}</span>");    }    @Test    public void testAttributeNameWithDot() {        vf.parse("<table-row keep-together.within-page=\"always\" >");    }    @Test    public void testAttributeNameWithUnderscore() {        vf.parse("<table-row test_attribute=\"always\" >");    }    @Test    public void testAttributeNameWithColon() {        vf.parse("<table-row test:attribute=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidSymbol() {        vf.parse("<table-row test&attribute=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidDot() {        vf.parse("<table-row .class=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidDotV2() {        vf.parse("<table-row test..attribute=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidDotV3() {        vf.parse("<table-row test.attribute.=\"always\" >");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;public abstract class AbstractVfNodesTest {    protected final VfParsingHelper vf = VfParsingHelper.DEFAULT.withResourceContext(getClass());}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import java.util.List;import org.junit.Test;public class VfPageStyleTest extends AbstractVfNodesTest {    /**     * Test parsing of a EL expression.     */    @Test    public void testElExpression() {        List<ASTElExpression> expressions = vf.getNodes(ASTElExpression.class, VF_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "myBean", id.getImage());        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "get", dotid.getImage());        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("Correct expression content expected!", "\"{! World }\"", literal.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testElExpressionInAttribute() {        List<ASTElExpression> expressions = vf.getNodes(ASTElExpression.class, VF_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "myValidator", id.getImage());        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "find", dotid.getImage());        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("Correct expression content expected!", "\"'vf'\"", literal.getImage());    }    private static final String VF_EL_EXPRESSION = "<html><title>Hello {!myBean.get(\"{! World }\") } .vf</title></html>";    private static final String VF_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').{!myValidator.find(\"'vf'\")}\" /> </html>";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VfPageStyleTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import org.junit.Test;/** * Test parsing of a VF in document style, by checking the generated AST. * Original @author pieter_van_raemdonck - Application Engineers NV/SA - * www.ae.be * * @author sergey.gorbaty - VF adaptation * */public class VfDocStyleTest extends AbstractVfNodesTest {    /**     * Smoke test for VF parser.     */    @Test    public void testSimplestVf() {        List<ASTElement> nodes = vf.getNodes(ASTElement.class, TEST_SIMPLEST_HTML);        assertEquals("Exactly " + 1 + " element(s) expected", 1, nodes.size());    }    /**     * Test the information on a Element and Attribute.     */    @Test    public void testElementAttributeAndNamespace() {        ASTCompilationUnit root = vf.parse(TEST_ELEMENT_AND_NAMESPACE);        List<ASTElement> elementNodes = root.findDescendantsOfType(ASTElement.class);        assertEquals("One element node expected!", 1, elementNodes.size());        ASTElement element = elementNodes.iterator().next();        assertEquals("Correct name expected!", "h:html", element.getName());        assertTrue("Has namespace prefix!", element.isHasNamespacePrefix());        assertTrue("Element is empty!", element.isEmpty());        assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "html", element.getLocalName());        List<ASTAttribute> attributeNodes = root.findDescendantsOfType(ASTAttribute.class);        assertEquals("One attribute node expected!", 1, attributeNodes.size());        ASTAttribute attribute = attributeNodes.iterator().next();        assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());        assertTrue("Has namespace prefix!", attribute.isHasNamespacePrefix());        assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix", attribute.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    public void testAttributeValueContainingHash() {        List<ASTAttribute> attributes = vf.getNodes(ASTAttribute.class, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        assertEquals("Three attributes expected!", 3, attributes.size());        ASTAttribute attr = attributes.get(0);        assertEquals("Correct attribute name expected!", "something", attr.getName());        assertEquals("Correct attribute value expected!", "#yes#",                     attr.getFirstDescendantOfType(ASTText.class).getImage());        attr = attributes.get(1);        assertEquals("Correct attribute name expected!", "foo", attr.getName());        assertEquals("Correct attribute value expected!", "CREATE",                attr.getFirstDescendantOfType(ASTText.class).getImage());        attr = attributes.get(2);        assertEquals("Correct attribute name expected!", "href", attr.getName());        assertEquals("Correct attribute value expected!", "#", attr.getFirstDescendantOfType(ASTText.class).getImage());    }    /**     * Test correct parsing of CDATA.     */    @Test    public void testCData() {        List<ASTCData> cdataNodes = vf.getNodes(ASTCData.class, TEST_CDATA);        assertEquals("One CDATA node expected!", 1, cdataNodes.size());        ASTCData cdata = cdataNodes.iterator().next();        assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());    }    /**     * Test parsing of Doctype declaration.     */    @Test    public void testDoctype() {        ASTCompilationUnit root = vf.parse(TEST_DOCTYPE);        List<ASTDoctypeDeclaration> docTypeDeclarations = root.findDescendantsOfType(ASTDoctypeDeclaration.class);        assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());        List<ASTDoctypeExternalId> externalIds = root.findDescendantsOfType(ASTDoctypeExternalId.class);        assertEquals("One doctype external id expected!", 1, externalIds.size());        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());        assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",                externalId.getUri());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "Script!", text.getImage());    }    /**     * Test parsing of EL in attribute of an element.     */    @Test    public void testELInTagValue() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE);        assertEquals("One element expected!", 1, elements.size());        ASTElement element = elements.iterator().next();        ASTAttributeValue attribute = element.getFirstDescendantOfType(ASTAttributeValue.class);        ASTIdentifier id = attribute.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "foo", id.getImage());    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    public void testELInTagValueWithCommentDQ() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT);        assertEquals("One element expected!", 1, elements.size());        ASTElement element = elements.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "init", id.getImage());    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    public void testELInTagValueWithCommentSQ() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ);        assertEquals("One element expected!", 1, elements.size());        ASTElement element = elements.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "init", id.getImage());    }    /**     * Test parsing of EL in HTML &lt;script&gt; element.     */    @Test    public void testELInHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext=", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of inline comment in EL.     */    @Test    public void testInlineCommentInEL() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext=", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of quoted EL in HTML &lt;script&gt; element.     */    @Test    public void testQuotedELInHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_QUOTED_EL_IN_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext='textHere", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be     * valid html but it is likely to appear in .page files.     */    @Test    public void testImportHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttribute> attr = script.findDescendantsOfType(ASTAttribute.class);        assertEquals("One script expected!", 1, attr.size());        ASTAttribute att = attr.iterator().next();        ASTAttributeValue val = att.getFirstChildOfType(ASTAttributeValue.class);        ASTText text = val.getFirstChildOfType(ASTText.class);        assertEquals("filename.js", text.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScriptWithAttribute() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "Script!", text.getImage());        List<ASTText> attrs = script.findDescendantsOfType(ASTText.class);        assertEquals("text/javascript", attrs.get(0).getImage());    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    public void testComplexHtmlScript() {        List<ASTHtmlScript> script = vf.getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals("One script expected!", 1, script.size());        ASTHtmlScript next = script.iterator().next();        ASTText text = next.getFirstChildOfType(ASTText.class);        assertTrue(text.getImage().contains("<!--"));    }    /**     * Test parsing of HTML &lt;style&gt; element.     */    @Test    public void testInlineCss() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals("Two elements expected!", 3, elements.size());    }    /**     * Test parsing of HTML text within element.     */    @Test    public void testTextInTag() {        List<ASTText> scripts = vf.getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals("One text chunk expected!", 1, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    public void noSpacesBetweenTags() {        List<ASTElement> scripts = vf.getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals("Two tags expected!", 2, scripts.size());        Iterator<ASTElement> iterator = scripts.iterator();        ASTElement script = iterator.next();        assertEquals("Correct content expected!", "a", script.getName());        script = iterator.next();        assertEquals("Correct content expected!", "b", script.getName());    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    public void unclosedTagsWithDollar() {        List<ASTText> scripts = vf.getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " $ ", script.getImage());    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    public void unclosedTagsWithELWithin() {        List<ASTElement> element = vf.getNodes(ASTElement.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals("One element expected!", 1, element.size());        for (ASTElement elem : element) {            ASTContent content = elem.getFirstChildOfType(ASTContent.class);            List<ASTElExpression> els = content.findChildrenOfType(ASTElExpression.class);            assertEquals("Two EL expressions expected!", 2, els.size());            ASTElExpression node = (ASTElExpression) content.getChild(0);            ASTIdentifier id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("Correct content expected!", "expr1", id.getImage());            node = (ASTElExpression) content.getChild(1);            id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("Correct content expected!", "expr2", id.getImage());        }    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void textAfterOpenAndClosedTag() {        List<ASTElement> nodes = vf.getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two elements expected!", 2, nodes.size());        assertEquals("First element should be a", "a", nodes.get(0).getName());        assertFalse("first element should be closed", nodes.get(0).isUnclosed());        assertEquals("Second element should be b", "b", nodes.get(1).getName());        assertTrue("Second element should not be closed", nodes.get(1).isUnclosed());        List<ASTText> text = vf.getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two text chunks expected!", 2, text.size());    }    @Test    public void quoteEL() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        List<ASTElExpression> els = attr.findChildrenOfType(ASTElExpression.class);        assertEquals("Must be 1!", 1, els.size());        ASTExpression expr = els.get(0).getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = expr.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Expected to detect proper value for attribute!", "something", id.getImage());    }    /**     * smoke test for a non-quoted attribute value     */    @Test    public void quoteAttrValue() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("Expected to detect proper value for attribute!", "yes|", text.getImage());    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    public void noQuoteAttrEmpty() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_EMPTY_ATTR);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertNull("Expected to detect proper value for attribute!", attr.getImage());    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    public void singleQuoteAttrTab() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_TAB_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("Expected to detect proper value for attribute!", "\t", text.getImage());    }    @Test    public void unclosedTag() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("Second element should be tag:someTag", "tag:someTag", elements.get(0).getName());        assertEquals("First element should be sorted tag:if", "tag:if", elements.get(1).getName());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());    }    @Test    public void unclosedTagAndNoQuotesForAttribute() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_ATTR);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("Second element should be tag:someTag", "tag:someTag", elements.get(0).getName());        assertEquals("First element should be sorted tag:if", "tag:if", elements.get(1).getName());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());    }    @Test    public void unclosedTagMultipleLevels() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("3 tags expected", 3, elements.size());        assertEquals("First element should be sorted tag:someTag", "tag:someTag", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertEquals("Third element should be tag:x", "tag:x", sortedElmnts.get(2).getName());        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        assertFalse(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    public void nestedEmptyTags() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Third element should be html", "html", sortedElmnts.get(3).getName());        // a1        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2        assertTrue(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());        // html        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt;     * &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    public void nestedMultipleTags() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 6, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be a3", "a3", sortedElmnts.get(2).getName());        assertEquals("Forth element should be a4", "a4", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be b", "b", sortedElmnts.get(4).getName());        assertEquals("Sixth element should be html", "html", sortedElmnts.get(5).getName());        // a1 not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2 not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // a3 empty and not closed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // a4 empty but closed        assertTrue(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());        // b empty but closed        assertTrue(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());        // html not empty and closed        assertFalse(sortedElmnts.get(5).isEmpty());        assertFalse(sortedElmnts.get(5).isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt;     * &lt;/x&gt; . Here x is the first tag to be closed thus rendering the next     * close of a (&lt;/a&gt;) to be disregarded.     */    @Test    public void unclosedParentTagClosedBeforeChild() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This should     * be disregarded and structure of children and parents should not be     * influenced. in other words &lt;/a&gt; should close the first &lt;a&gt;     * tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    public void unmatchedTagDoesNotInfluenceStructure() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a is not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt; An unmatched closing of 'z' appears randomly in the document.     * This should be disregarded and structure of children and parents should     * not be influenced. Also un unclosed &lt;a&gt; tag appears at the start of     * the document     */    @Test    public void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("5 tags expected", 5, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be a", "a", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be b", "b", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be x", "x", sortedElmnts.get(4).getName());        // first a is empty and unclosed        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // second a not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(3).isEmpty());        assertTrue(sortedElmnts.get(3).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());    }    /**     * will sort the AST element in list in alphabetical order and if tag name     * is the same it will sort against o1.getBeginColumn() +""+     * o1.getBeginLine(). so first criteria is the name, then the second is the     * column +""+line string.     *     * @param elements     * @return     */    private List<ASTElement> sortNodesByName(List<ASTElement> elements) {        Collections.sort(elements, new Comparator<ASTElement>() {            @Override            public int compare(ASTElement o1, ASTElement o2) {                if (o1.getName() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getName() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getName().equals(o2.getName())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getName().compareTo(o2.getName());            }        });        return elements;    }    @Test    public void noQuoteAttrWithJspEL() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTIdentifier id = attr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Expected to detect proper value for EL in attribute!", "something", id.getImage());    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE = "<apex:page action=\"{!foo}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT = "<apex:page action=\"{!/*comment here*/init}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ = "<apex:page action='{!/*comment here*/init}'>text</apex:page>";    private static final String TEST_EL_IN_HTML_SCRIPT = "<html><head><script>var text={!elInScript};</script></head></html>";    private static final String TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT = "<html><head><script>var text={!/*junk1*/elInScript/*junk2*/};</script></head></html>";    private static final String TEST_QUOTED_EL_IN_HTML_SCRIPT = "<html><head><script>var text='textHere{!elInScript}';</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" /></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>{!expr1}{!expr2}</a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"{!something}\" > </tag:if>";    private static final String TEST_ATTR = "<tag:if something=\"yes|\" > </tag:if>";    private static final String TEST_EMPTY_ATTR = "<tag:if something= >  <a href=\"http://someHost:/some_URL\" >foo</a> </tag:if>";    private static final String TEST_TAB_ATTR = "<tag:if something='\t' >   </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if something=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag something=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_ATTR = "<tag:someTag> <tag:if something='x' > </tag:someTag>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<apex:someTag something={!something} > foo </apex:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @Before    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *     */    @Test    public void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt;     */    @Test    public void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertNull;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;public class ObjectFieldTypesTest {    private static final Map<String, DataType> EXPECTED_SFDX_DATA_TYPES;    private static final Map<String, DataType> EXPECTED_MDAPI_DATA_TYPES;    static {        EXPECTED_SFDX_DATA_TYPES = new HashMap<>();        EXPECTED_SFDX_DATA_TYPES.put("Account.Checkbox__c", DataType.Checkbox);        EXPECTED_SFDX_DATA_TYPES.put("Account.DateTime__c", DataType.DateTime);        EXPECTED_SFDX_DATA_TYPES.put("Account.LongTextArea__c", DataType.LongTextArea);        EXPECTED_SFDX_DATA_TYPES.put("Account.Picklist__c", DataType.Picklist);        EXPECTED_SFDX_DATA_TYPES.put("Account.Text__c", DataType.Text);        EXPECTED_SFDX_DATA_TYPES.put("Account.TextArea__c", DataType.TextArea);        // Edge Cases        // Invalid property should return null        EXPECTED_SFDX_DATA_TYPES.put("Account.DoesNotExist__c", null);        EXPECTED_MDAPI_DATA_TYPES = new HashMap<>();        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDCheckbox__c", DataType.Checkbox);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDDateTime__c", DataType.DateTime);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDLongTextArea__c", DataType.LongTextArea);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDPicklist__c", DataType.Picklist);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDText__c", DataType.Text);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDTextArea__c", DataType.TextArea);        // Edge Cases        // Invalid property should return null        EXPECTED_MDAPI_DATA_TYPES.put("Account.DoesNotExist__c", null);    }    /**     * Verify that CustomFields stored in sfdx project format are correctly parsed     */    @Test    public void testSfdxAccountIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue());    }    /**     * Verify that CustomFields stored in mdapi format are correctly parsed     */    @Test    public void testMdapiAccountIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        validateMDAPIAccount(objectFieldTypes, vfPagePath, VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue());    }    /**     * Verify that fields are found across multiple directories     */    @Test    public void testFieldsAreFoundInMultipleDirectories() {        ObjectFieldTypes objectFieldTypes;        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)            .resolve("SomePage.page");        List<String> paths = Arrays.asList(VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue().get(0),                VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Objects).toString());        objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, paths);        validateMDAPIAccount(objectFieldTypes, vfPagePath, paths);        Collections.reverse(paths);        objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, paths);        validateMDAPIAccount(objectFieldTypes, vfPagePath, paths);    }    @Test    public void testInvalidDirectoryDoesNotCauseAnException() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        String vfFileName = vfPagePath.toString();        List<String> paths = Arrays.asList(Paths.get("..", "objects-does-not-exist").toString());        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        assertNull(objectFieldTypes.getDataType("Account.DoesNotExist__c", vfFileName, paths));    }    /**     * Validate the expected results when the Account Fields are stored in decomposed sfdx format     */    private void validateSfdxAccount(ObjectFieldTypes objectFieldTypes, Path vfPagePath, List<String> paths) {        VFTestUtils.validateDataTypes(EXPECTED_SFDX_DATA_TYPES, objectFieldTypes, vfPagePath, paths);    }    /**     * Validate the expected results when the Account Fields are stored in a single file MDAPI format     */    private void validateMDAPIAccount(ObjectFieldTypes objectFieldTypes, Path vfPagePath, List<String> paths) {        VFTestUtils.validateDataTypes(EXPECTED_MDAPI_DATA_TYPES, objectFieldTypes, vfPagePath, paths);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.jupiter.api.Assertions.assertNull;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.nio.file.Path;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;import net.sourceforge.pmd.lang.vf.ast.ASTLiteral;import net.sourceforge.pmd.lang.vf.ast.VfTypedNode;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer;public class VfExpressionTypeVisitorTest {    private static final Map<String, DataType> EXPECTED_CUSTOM_FIELD_DATA_TYPES;    private static final Map<String, DataType> EXPECTED_APEX_DATA_TYPES;    static {        EXPECTED_CUSTOM_FIELD_DATA_TYPES = new HashMap<>();        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("CreatedDate", DataType.DateTime);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("DateTime__c", DataType.DateTime);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Checkbox__c", DataType.Checkbox);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Name", DataType.Text);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Text__c", DataType.Text);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("TextArea__c", DataType.TextArea);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("LongTextArea__c", DataType.LongTextArea);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Picklist__c", DataType.Picklist);        EXPECTED_APEX_DATA_TYPES = new HashMap<>();        EXPECTED_APEX_DATA_TYPES.put("AccountIdProp", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("AccountId", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountId", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountIdProp", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("AccountName", DataType.Text);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountName", DataType.Text);        EXPECTED_APEX_DATA_TYPES.put("ConflictingProp", DataType.Unknown);    }    /**     * Strings that use dot notation(Account.CreatedDate) result in ASTIdentifier nodes     */    @Test    public void testXpathQueryForCustomFieldIdentifiers() throws FileNotFoundException {        Node rootNode = compile("StandardAccount.page");        for (Map.Entry<String, DataType> entry : EXPECTED_CUSTOM_FIELD_DATA_TYPES.entrySet()) {            String xpath = String.format("//Identifier[@Image='%s' and @DataType='%s']", entry.getKey(), entry.getValue().name());            List<Node> nodes = VFTestUtils.findNodes(rootNode, xpath);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(entry.getKey(), 2, nodes.size());            for (Node node : nodes) {                assertEquals(entry.getKey(), node.getImage());                assertTrue(node.getClass().getSimpleName(), node instanceof ASTIdentifier);                ASTIdentifier identifier = (ASTIdentifier) node;                assertEquals(entry.getKey(), entry.getValue(), identifier.getDataType());            }        }    }    /**     * Strings that use array notation, Account['CreatedDate') don't have a DataType added. This type of notation     * creates ambiguous situations with Apex methods that return Maps. This may be addressed in a future release.     */    @Test    public void testXpathQueryForCustomFieldLiteralsHaveNullDataType() throws FileNotFoundException {        Node rootNode = compile("StandardAccount.page");        for (Map.Entry<String, DataType> entry : EXPECTED_CUSTOM_FIELD_DATA_TYPES.entrySet()) {            // Literals are surrounded by apostrophes            String xpath = String.format("//Literal[@Image=\"'%s'\" and @DataType='']", entry.getKey());            List<Node> nodes = VFTestUtils.findNodes(rootNode, xpath);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(entry.getKey(), 2, nodes.size());            for (Node node : nodes) {                assertEquals(String.format("'%s'", entry.getKey()), node.getImage());                assertTrue(node.getClass().getSimpleName(), node instanceof ASTLiteral);                ASTLiteral literal = (ASTLiteral) node;                assertEquals(entry.getKey(), null, literal.getDataType());            }        }    }    /**     * Nodes where the DataType can't be determined should have a null DataType     */    @Test    public void testDataTypeForCustomFieldsNotFound() throws FileNotFoundException {        Node rootNode = compile("StandardAccount.page");        for (String xpath : new String[] { "//Identifier[@Image='NotFoundField__c']", "//Literal[@Image=\"'NotFoundField__c'\"]" }) {            List<Node> nodes = VFTestUtils.findNodes(rootNode, xpath);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(2, nodes.size());            for (Node node : nodes) {                assertTrue(node.getClass().getSimpleName(), node instanceof VfTypedNode);                VfTypedNode dataNode = (VfTypedNode) node;                assertNull(dataNode.getDataType());            }        }    }    /**     * Apex properties result in ASTIdentifier nodes     */    @Test    public void testXpathQueryForProperties() throws FileNotFoundException {        Node rootNode = compile("ApexController.page");        for (Map.Entry<String, DataType> entry : EXPECTED_APEX_DATA_TYPES.entrySet()) {            String xpath = String.format("//Identifier[@Image='%s' and @DataType='%s']", entry.getKey(), entry.getValue().name());            List<Node> nodes = VFTestUtils.findNodes(rootNode, xpath);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(entry.getKey(), 2, nodes.size());            for (Node node : nodes) {                assertEquals(entry.getKey(), node.getImage());                assertTrue(node.getClass().getSimpleName(), node instanceof ASTIdentifier);                ASTIdentifier identifier = (ASTIdentifier) node;                assertEquals(entry.getKey(), entry.getValue(), identifier.getDataType());            }        }    }    /**     * Nodes where the DataType can't be determined should have a null DataType     */    @Test    public void testDataTypeForApexPropertiesNotFound() throws FileNotFoundException {        Node rootNode = compile("ApexController.page");        String xpath = "//Identifier[@Image='NotFoundProp']";        List<Node> nodes = VFTestUtils.findNodes(rootNode, xpath);        // Each string appears twice, it is set on a "value" attribute and inline        assertEquals(2, nodes.size());        for (Node node : nodes) {            assertTrue(node.getClass().getSimpleName(), node instanceof VfTypedNode);            VfTypedNode dataNode = (VfTypedNode) node;            assertNull(dataNode.getDataType());        }    }    private Node compile(String pageName) throws FileNotFoundException {        return compile(pageName, false);    }    private Node compile(String pageName, boolean renderAST) throws FileNotFoundException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve(pageName);        return compile(vfPagePath, renderAST);    }    private Node compile(Path vfPagePath, boolean renderAST) throws FileNotFoundException {        LanguageVersion languageVersion = LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = languageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = languageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse(vfPagePath.toString(), new FileReader(vfPagePath.toFile()));        assertNotNull(node);        if (renderAST) {            try {                new XmlTreeRenderer().renderSubtree(node, System.out);            } catch (IOException e) {                throw new RuntimeException(e);            }        }        return node;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertNull;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;public class ApexClassPropertyTypesTest {    private static final Map<String, DataType> EXPECTED_DATA_TYPES;    static {        // Intentionally use the wrong case for property names to ensure that they can be found. The Apex class name        // must have the correct case since it is used to lookup the file. The Apex class name is guaranteed to be correct        // in the Visualforce page, but the property names are not        EXPECTED_DATA_TYPES = new HashMap<>();        EXPECTED_DATA_TYPES.put("ApexController.accOuntIdProp", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.AcCountId", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.AcCountname", DataType.Text);        // InnerController        // The class should be parsed to Unknown. It's not a valid expression on its own.        EXPECTED_DATA_TYPES.put("ApexController.innErController", DataType.Unknown);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountIdProp", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountid", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountnAme", DataType.Text);        // Edge cases        // Invalid class should return null        EXPECTED_DATA_TYPES.put("unknownclass.invalidProperty", null);        // Invalid class property should return null        EXPECTED_DATA_TYPES.put("ApexController.invalidProperty", null);        /*         * It is possible to have a property and method with different types that resolve to the same Visualforce         * expression. An example is an Apex class with a property "public String Foo {get; set;}" and a method of         * "Integer getFoo() { return 1; }". These properties should map to {@link DataType#Unknown}.         */        EXPECTED_DATA_TYPES.put("ApexController.ConflictingProp", DataType.Unknown);    }    @Test    public void testApexClassIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("SomePage.page");        ApexClassPropertyTypes apexClassPropertyTypes = new ApexClassPropertyTypes();        VFTestUtils.validateDataTypes(EXPECTED_DATA_TYPES, apexClassPropertyTypes, vfPagePath,                VfParserOptions.APEX_DIRECTORIES_DESCRIPTOR.defaultValue());    }    @Test    public void testInvalidDirectoryDoesNotCauseAnException() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("SomePage.page");        String vfFileName = vfPagePath.toString();        List<String> paths = Arrays.asList(Paths.get("..", "classes-does-not-exist").toString());        ApexClassPropertyTypes apexClassPropertyTypes = new ApexClassPropertyTypes();        assertNull(apexClassPropertyTypes.getDataType("ApexController.accOuntIdProp", vfFileName, paths));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertEquals;import org.junit.Test;public class VfParserOptionsTest {    @Test    public void testDefaultPropertyDescriptors() {        VfParserOptions vfParserOptions = new VfParserOptions();        assertEquals(VfParserOptions.DEFAULT_APEX_DIRECTORIES,                     vfParserOptions.getProperty(VfParserOptions.APEX_DIRECTORIES_DESCRIPTOR));        assertEquals(VfParserOptions.DEFAULT_OBJECT_DIRECTORIES,                     vfParserOptions.getProperty(VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    public RuleSetFactoryTest() {        super(ApexLanguageModule.TERSE_NAME);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.io.BufferedReader;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Hashtable;import java.util.List;import java.util.Map;import org.apache.commons.lang3.tuple.Pair;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.symbol.type.BasicType;public class ApexClassPropertyTypesVisitorTest {    @Test    public void testApexClassIsProperlyParsed() throws IOException {        LanguageVersion languageVersion = LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = languageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = languageVersion.getLanguageVersionHandler().getParser(parserOptions);        Path apexPath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Apex)                .resolve("ApexController.cls").toAbsolutePath();        ApexClassPropertyTypesVisitor visitor = new ApexClassPropertyTypesVisitor();        try (BufferedReader reader = Files.newBufferedReader(apexPath, StandardCharsets.UTF_8)) {            Node node = parser.parse(apexPath.toString(), reader);            assertNotNull(node);            visitor.visit((ApexNode<?>) node, null);        }        List<Pair<String, BasicType>> variables = visitor.getVariables();        assertEquals(7, variables.size());        Map<String, BasicType> variableNameToVariableType = new Hashtable<>();        for (Pair<String, BasicType> variable : variables) {            // Map the values and ensure there were no duplicates            BasicType previous = variableNameToVariableType.put(variable.getKey(), variable.getValue());            assertNull(variable.getKey(), previous);        }        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.AccountIdProp"));        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.AccountId"));        assertEquals(BasicType.STRING, variableNameToVariableType.get("ApexController.AccountName"));        assertEquals(BasicType.APEX_OBJECT, variableNameToVariableType.get("ApexController.InnerController"));        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.InnerController.InnerAccountIdProp"));        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.InnerController.InnerAccountId"));        assertEquals(BasicType.STRING, variableNameToVariableType.get("ApexController.InnerController.InnerAccountName"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;import apex.jorje.semantic.symbol.type.BasicType;public class DataTypeTest {    @Test    public void testFromString() {        assertEquals(DataType.AutoNumber, DataType.fromString("AutoNumber"));        assertEquals(DataType.AutoNumber, DataType.fromString("autonumber"));        assertEquals(DataType.Unknown, DataType.fromString(""));        assertEquals(DataType.Unknown, DataType.fromString(null));    }    @Test    public void testFromBasicType() {        assertEquals(DataType.Checkbox, DataType.fromBasicType(BasicType.BOOLEAN));        assertEquals(DataType.Number, DataType.fromBasicType(BasicType.DECIMAL));        assertEquals(DataType.Number, DataType.fromBasicType(BasicType.DOUBLE));        assertEquals(DataType.Unknown, DataType.fromBasicType(BasicType.APEX_OBJECT));        assertEquals(DataType.Unknown, DataType.fromBasicType(null));    }    @Test    public void testRequiresEncoding() {        assertFalse(DataType.AutoNumber.requiresEscaping);        assertTrue(DataType.Text.requiresEscaping);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.vf.VfLanguageModule;/** * @author sergey.gorbaty * */public class LanguageVersionDiscovererTest {    /**     * Test on VF file.     */    @Test    public void testVFFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File vfFile = new File("/path/to/MyPage.page");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals("LanguageVersion must be VF!",                LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), languageVersion);    }    @Test    public void testComponentFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File vfFile = new File("/path/to/MyPage.component");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals("LanguageVersion must be VF!",                LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vf.VfLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VfLanguageModule.NAME, VfLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), }, });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class DartTokenizerTest extends CpdTextComparisonTest {    public DartTokenizerTest() {        super(".dart");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new DartTokenizer();    }    @Test    public void testComment() {        doTest("comment");    }    @Test    public void testEscapeSequences() {        doTest("escape_sequences");    }    @Test    public void testEscapedBackslash() {        doTest("escaped_backslash");    }    @Test    public void testEscapedString() {        doTest("escaped_string");    }    @Test    public void testIncrement() {        doTest("increment");    }    @Test    public void testImports() {        doTest("imports");    }    @Test    public void testStringInterpolation() {        doTest("string_interpolation");    }    @Test    public void testEscapedDollar() {        doTest("escaped_dollar");    }    @Test    public void testRegex() {        doTest("regex");    }    @Test    public void testRegex2() {        doTest("regex2");    }    @Test    public void testRegex3() {        doTest("regex3");    }    @Test    public void testStringWithBackslashes() {        doTest("string_with_backslashes");    }    @Test    public void testMultiline() {        doTest("string_multiline");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class PythonTokenizerTest extends CpdTextComparisonTest {    public PythonTokenizerTest() {        super(".py");    }    @Override    protected String getResourcePrefix() {        return "../lang/python/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PythonTokenizer();    }            @Test    public void sampleTest() {        doTest("sample_python");    }    @Test    public void specialComments() {        doTest("special_comments");    }    @Test    public void testBackticks() {        doTest("backticks");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.xml.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class XmlCPDTokenizerTest extends CpdTextComparisonTest {    public XmlCPDTokenizerTest() {        super(".xml");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new XmlTokenizer();    }    @Test    public void tokenizeTest() {        doTest("simple");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MistypedCDATASectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.StringReader;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import org.w3c.dom.Attr;import org.w3c.dom.CharacterData;import org.w3c.dom.Comment;import org.w3c.dom.Document;import org.w3c.dom.DocumentType;import org.w3c.dom.Element;import org.w3c.dom.Entity;import org.w3c.dom.EntityReference;import org.w3c.dom.Notation;import org.w3c.dom.ProcessingInstruction;import org.w3c.dom.Text;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractDomXmlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><?mypi?><!DOCTYPE testDoc [<!ENTITY entity \"e\">]><!--Comment--><foo abc=\"abc\"><bar>TEXT</bar><![CDATA[cdata!]]>&gt;&entity;&lt;</foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setExpandEntityReferences(false);        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        MyRule rule = new MyRule();        rule.apply(nodes, null);        List<org.w3c.dom.Node> visited = rule.visitedNodes.get("Attr");        assertEquals(1, visited.size());        assertEquals("abc", visited.get(0).getLocalName());        visited = rule.visitedNodes.get("CharacterData");        assertEquals(1, visited.size());        assertEquals("cdata!", ((CharacterData) visited.get(0)).getData());        visited = rule.visitedNodes.get("Comment");        assertEquals("Comment", ((Comment) visited.get(0)).getData());        visited = rule.visitedNodes.get("Document");        assertEquals(1, visited.size());        visited = rule.visitedNodes.get("DocumentType");        assertEquals("testDoc", ((DocumentType) visited.get(0)).getName());        visited = rule.visitedNodes.get("Element");        assertEquals(2, visited.size());        assertEquals("foo", visited.get(0).getLocalName());        assertEquals("bar", visited.get(1).getLocalName());        // TODO Figure out how to trigger this.        // visited = rule.visitedNodes.get("Entity");        // assertEquals(0, visited.size());        visited = rule.visitedNodes.get("EntityReference");        assertEquals(1, visited.size());        assertEquals("entity", ((EntityReference) visited.get(0)).getNodeName());        // TODO Figure out how to trigger this.        // visited = rule.visitedNodes.get("Notation");        // assertEquals(0, visited.size());        visited = rule.visitedNodes.get("ProcessingInstruction");        assertEquals(1, visited.size());        assertEquals("mypi", ((ProcessingInstruction) visited.get(0)).getTarget());        visited = rule.visitedNodes.get("Text");        assertEquals(3, visited.size());        assertEquals("TEXT", ((Text) visited.get(0)).getData());        assertEquals(">", ((Text) visited.get(1)).getData());        String text = ((Text) visited.get(2)).getData();        if ("<".equals(text)) {            // java13 and later don't expand entities if setExpandEntityReferences==false            assertEquals("<", ((Text) visited.get(2)).getData());        } else {            assertEquals("e<", ((Text) visited.get(2)).getData());        }    }    @Test    public void dtdIsNotLookedUp() {        String source = "<!DOCTYPE struts-config PUBLIC "                + " \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN \" "                + " \"http://jakarta.inexistinghost.org/struts/dtds/struts-config_1_1.dtd\" >" + "<struts-config/>";        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setLookupDescriptorDoc(false);        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        // no exception should be thrown        MyRule rule = new MyRule();        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        rule.apply(nodes, null);        // first element is still parsed        assertNotNull(rule.visitedNodes.get("Element"));    }    @Test    public void xsdIsNotLookedUp() {        String source = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> "                + "<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" "                + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "                + "xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.inexisting.com/xml/ns/javaee/web-app_2_5.xsd\" "                + "version=\"2.5\">" + "</web-app>";        XmlParserOptions parserOptions = new XmlParserOptions();        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        // no exception should be thrown        // first element is still parsed        MyRule rule = new MyRule();        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        rule.apply(nodes, null);        assertNotNull(rule.visitedNodes.get("Element"));    }    private static class MyRule extends AbstractDomXmlRule {        final Map<String, List<org.w3c.dom.Node>> visitedNodes = new HashMap<>();        MyRule() {        }        private void visit(String key, org.w3c.dom.Node node) {            List<org.w3c.dom.Node> nodes = visitedNodes.get(key);            if (nodes == null) {                nodes = new ArrayList<>();                visitedNodes.put(key, nodes);            }            nodes.add(node);        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            super.apply(nodes, ctx);        }        @Override        protected void visit(XmlNode node, Attr attr, RuleContext ctx) {            visit("Attr", attr);            super.visit(node, attr, ctx);        }        @Override        protected void visit(XmlNode node, CharacterData characterData, RuleContext ctx) {            visit("CharacterData", characterData);            super.visit(node, characterData, ctx);        }        @Override        protected void visit(XmlNode node, Comment comment, RuleContext ctx) {            visit("Comment", comment);            super.visit(node, comment, ctx);        }        @Override        protected void visit(XmlNode node, Document document, RuleContext ctx) {            visit("Document", document);            super.visit(node, document, ctx);        }        @Override        protected void visit(XmlNode node, DocumentType documentType, RuleContext ctx) {            visit("DocumentType", documentType);            super.visit(node, documentType, ctx);        }        @Override        protected void visit(XmlNode node, Element element, RuleContext ctx) {            visit("Element", element);            super.visit(node, element, ctx);        }        @Override        protected void visit(XmlNode node, Entity entity, RuleContext ctx) {            visit("Entity", entity);            super.visit(node, entity, ctx);        }        @Override        protected void visit(XmlNode node, EntityReference entityReference, RuleContext ctx) {            visit("EntityReference", entityReference);            super.visit(node, entityReference, ctx);        }        @Override        protected void visit(XmlNode node, Notation notation, RuleContext ctx) {            visit("Notation", notation);            super.visit(node, notation, ctx);        }        @Override        protected void visit(XmlNode node, ProcessingInstruction processingInstruction, RuleContext ctx) {            visit("ProcessingInstruction", processingInstruction);            super.visit(node, processingInstruction, ctx);        }        @Override        protected void visit(XmlNode node, Text text, RuleContext ctx) {            visit("Text", text);            super.visit(node, text, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractXmlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><foo abc=\"abc\"><bar/></foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        MyRule rule = new MyRule();        rule.apply(nodes, null);        assertEquals(3, rule.visitedNodes.size());        assertEquals("document", rule.visitedNodes.get(0).toString());        assertEquals("foo", rule.visitedNodes.get(1).toString());        assertEquals("bar", rule.visitedNodes.get(2).toString());    }    private static class MyRule extends AbstractXmlRule {        final List<XmlNode> visitedNodes = new ArrayList<>();        MyRule() {        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            visitedNodes.clear();            super.apply(nodes, ctx);        }        @Override        protected void visit(XmlNode node, RuleContext ctx) {            visitedNodes.add(node);            super.visit(node, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static net.sourceforge.pmd.lang.ParserOptionsTestUtils.verifyOptionsEqualsHashcode;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.xml.rule.AbstractXmlRule;import net.sourceforge.pmd.properties.BooleanProperty;public class XmlParserOptionsTest {    @Test    public void testDefaults() {        XmlParserOptions options = new XmlParserOptions();        assertFalse(options.isCoalescing());        assertTrue(options.isExpandEntityReferences());        assertFalse(options.isIgnoringComments());        assertFalse(options.isIgnoringElementContentWhitespace());        assertTrue(options.isNamespaceAware());        assertFalse(options.isValidating());        assertFalse(options.isXincludeAware());        MyRule rule = new MyRule();        options = (XmlParserOptions) rule.getParserOptions();        assertFalse(options.isCoalescing());        assertTrue(options.isExpandEntityReferences());        assertFalse(options.isIgnoringComments());        assertFalse(options.isIgnoringElementContentWhitespace());        assertTrue(options.isNamespaceAware());        assertFalse(options.isValidating());        assertFalse(options.isXincludeAware());    }    @Test    public void testConstructor() {        MyRule rule = new MyRule();        rule.setProperty(XmlParserOptions.COALESCING_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isCoalescing());        rule.setProperty(XmlParserOptions.COALESCING_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isCoalescing());        rule.setProperty(XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isExpandEntityReferences());        rule.setProperty(XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isExpandEntityReferences());        rule.setProperty(XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isIgnoringComments());        rule.setProperty(XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isIgnoringComments());        rule.setProperty(XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isIgnoringElementContentWhitespace());        rule.setProperty(XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isIgnoringElementContentWhitespace());        rule.setProperty(XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isNamespaceAware());        rule.setProperty(XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isNamespaceAware());        rule.setProperty(XmlParserOptions.VALIDATING_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isValidating());        rule.setProperty(XmlParserOptions.VALIDATING_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isValidating());        rule.setProperty(XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isXincludeAware());        rule.setProperty(XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isXincludeAware());    }    @Test    public void testSetters() {        XmlParserOptions options = new XmlParserOptions();        options.setSuppressMarker("foo");        assertEquals("foo", options.getSuppressMarker());        options.setSuppressMarker(null);        assertNull(options.getSuppressMarker());        options.setCoalescing(true);        assertTrue(options.isCoalescing());        options.setCoalescing(false);        assertFalse(options.isCoalescing());        options.setExpandEntityReferences(true);        assertTrue(options.isExpandEntityReferences());        options.setExpandEntityReferences(false);        assertFalse(options.isExpandEntityReferences());        options.setIgnoringComments(true);        assertTrue(options.isIgnoringComments());        options.setIgnoringComments(false);        assertFalse(options.isIgnoringComments());        options.setIgnoringElementContentWhitespace(true);        assertTrue(options.isIgnoringElementContentWhitespace());        options.setIgnoringElementContentWhitespace(false);        assertFalse(options.isIgnoringElementContentWhitespace());        options.setNamespaceAware(true);        assertTrue(options.isNamespaceAware());        options.setNamespaceAware(false);        assertFalse(options.isNamespaceAware());        options.setValidating(true);        assertTrue(options.isValidating());        options.setValidating(false);        assertFalse(options.isValidating());        options.setXincludeAware(true);        assertTrue(options.isXincludeAware());        options.setXincludeAware(false);        assertFalse(options.isXincludeAware());    }    @Test    public void testEqualsHashcode() throws Exception {        BooleanProperty[] properties = new BooleanProperty[] { XmlParserOptions.COALESCING_DESCRIPTOR,            XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR,            XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR,            XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, XmlParserOptions.VALIDATING_DESCRIPTOR,            XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, };        for (int i = 0; i < properties.length; i++) {            BooleanProperty property = properties[i];            MyRule rule = new MyRule();            rule.setProperty(property, true);            ParserOptions options1 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options2 = rule.getParserOptions();            rule.setProperty(property, true);            ParserOptions options3 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options4 = rule.getParserOptions();            verifyOptionsEqualsHashcode(options1, options2, options3, options4);        }        XmlParserOptions options1 = new XmlParserOptions();        options1.setSuppressMarker("foo");        XmlParserOptions options2 = new XmlParserOptions();        options2.setSuppressMarker("bar");        XmlParserOptions options3 = new XmlParserOptions();        options3.setSuppressMarker("foo");        XmlParserOptions options4 = new XmlParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    private static final class MyRule extends AbstractXmlRule {    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(XmlParserOptionsTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static net.sourceforge.pmd.lang.xml.XmlParsingHelper.XML;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.StringReader;import java.io.UnsupportedEncodingException;import java.util.Iterator;import java.util.Locale;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.lang.xml.ast.XmlNode;import net.sourceforge.pmd.lang.xml.ast.XmlParser;import net.sourceforge.pmd.util.StringUtil;/** * Unit test for the {@link XmlParser}. */public class XmlParserTest {    private static final String XML_TEST = "<?xml version=\"1.0\"?>\n" + "<!DOCTYPE rootElement\n" + "[\n"            + "<!ELEMENT rootElement (child1,child2)>\n" + "<!ELEMENT child1 (#PCDATA)>\n"            + "<!ATTLIST child1 test CDATA #REQUIRED>\n" + "<!ELEMENT child2 (#PCDATA)>\n" + "\n"            + "<!ENTITY pmd \"Copyright: PMD\">\n" + "]\n" + ">\n" + "<rootElement>\n"            + "    <!-- that's a comment -->\n" + "    <child1 test=\"1\">entity: &pmd;\n" + "    </child1>\n"            + "    <child2>\n" + "      <![CDATA[ cdata section ]]>\n" + "    </child2>\n" + "</rootElement>";    private static final String XML_NAMESPACE_TEST = "<?xml version=\"1.0\"?>\n"            + "<pmd:rootElement xmlns:pmd=\"http://pmd.sf.net\">\n" + "    <!-- that's a comment -->\n"            + "    <pmd:child1 test=\"1\">entity: &amp;\n" + "    </pmd:child1>\n" + "    <pmd:child2>\n"            + "      <![CDATA[ cdata section ]]>\n" + "    </pmd:child2>\n" + "</pmd:rootElement>";    private static final String XML_INVALID_WITH_DTD = "<?xml version=\"1.0\"?>\n" + "<!DOCTYPE rootElement\n" + "[\n"            + "<!ELEMENT rootElement (child)>\n" + "<!ELEMENT child (#PCDATA)>\n" + "]\n" + ">\n" + "<rootElement>\n"            + "  <invalidChild></invalidChild>\n" + "</rootElement>";    /**     * See bug #1054: XML Rules ever report a line -1 and not the line/column     * where the error occurs     *     */    @Test    public void testLineNumbers() {        Node document = XML.parse(XML_TEST);        assertNode(document, "document", 2);        assertLineNumbers(document, 1, 1, 19, 14);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        assertLineNumbers(dtdElement, 2, 1, 11, 1);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertLineNumbers(rootElement, 12, 1, 19, 14);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertLineNumbers(rootElement.getChild(0), 12, 14, 13, 4);        assertNode(rootElement.getChild(1), "comment", 0);        assertLineNumbers(rootElement.getChild(1), 13, 5, 13, 29);        assertTextNode(rootElement.getChild(2), "\\n    ");        assertLineNumbers(rootElement.getChild(2), 13, 30, 14, 4);        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertLineNumbers(child1, 14, 5, 15, 13);        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertLineNumbers(child1.getChild(0), 14, 22, 15, 4);        assertTextNode(rootElement.getChild(4), "\\n    ");        assertLineNumbers(rootElement.getChild(4), 15, 14, 16, 4);        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 3);        assertLineNumbers(child2, 16, 5, 18, 13);        assertTextNode(child2.getChild(0), "\\n      ");        assertLineNumbers(child2.getChild(0), 16, 13, 17, 6);        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertLineNumbers(child2.getChild(1), 17, 7, 17, 33);        assertTextNode(child2.getChild(2), "\\n    ");        assertLineNumbers(child2.getChild(2), 17, 34, 18, 4);        assertTextNode(rootElement.getChild(6), "\\n");        assertLineNumbers(rootElement.getChild(6), 18, 14, 18, 14);    }    /**     * Verifies the default parsing behavior of the XML parser.     */    @Test    public void testDefaultParsing() {        Node document = XML.parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser with coalescing enabled.     */    @Test    public void testParsingCoalescingEnabled() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setCoalescing(true);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 1);        assertTextNode(child2.getChild(0), "\\n       cdata section \\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if entities are not     * expanded.     */    @Test    public void testParsingDoNotExpandEntities() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setExpandEntityReferences(false);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 3, "test", "1");        assertTextNode(child1.getChild(0), "entity: ");        assertNode(child1.getChild(1), "pmd", 0);        // with java13, expandEntityReferences=false works correctly, and the        // entity &pmd; is not expanded        String text = child1.getChild(2).getImage();        if ("\n    ".equals(text)) {            // java13 and later            assertTextNode(child1.getChild(2), "\\n    ");        } else {            assertTextNode(child1.getChild(2), "Copyright: PMD\\n    ");        }        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if ignoring comments.     */    @Test    public void testParsingIgnoreComments() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setIgnoringComments(true);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 5);        assertTextNode(rootElement.getChild(0), "\\n    \\n    ");        Node child1 = rootElement.getChild(1);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child2 = rootElement.getChild(3);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(4), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if ignoring whitespaces     * in elements.     */    @Test    public void testParsingIgnoreElementContentWhitespace() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setIgnoringElementContentWhitespace(true);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 3);        assertNode(rootElement.getChild(0), "comment", 0);        Node child1 = rootElement.getChild(1);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        Node child2 = rootElement.getChild(2);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");    }    /**     * Verifies the default parsing behavior of the XML parser with namespaces.     */    @Test    public void testDefaultParsingNamespaces() {        Node document = XML.parse(XML_NAMESPACE_TEST);        assertNode(document, "document", 1);        Node rootElement = document.getChild(0);        assertNode(rootElement, "pmd:rootElement", 7, "xmlns:pmd", "http://pmd.sf.net");        Assert.assertEquals("http://pmd.sf.net", ((XmlNode) rootElement).getNode().getNamespaceURI());        Assert.assertEquals("pmd", ((XmlNode) rootElement).getNode().getPrefix());        Assert.assertEquals("rootElement", ((XmlNode) rootElement).getNode().getLocalName());        Assert.assertEquals("pmd:rootElement", ((XmlNode) rootElement).getNode().getNodeName());        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "pmd:child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: &\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "pmd:child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the default parsing behavior of the XML parser with namespaces     * but not namespace aware.     */    @Test    public void testParsingNotNamespaceAware() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setNamespaceAware(false);        Node document = XML.withParserOptions(parserOptions).parse(XML_NAMESPACE_TEST);        assertNode(document, "document", 1);        Node rootElement = document.getChild(0);        assertNode(rootElement, "pmd:rootElement", 7, "xmlns:pmd", "http://pmd.sf.net");        Assert.assertNull(((XmlNode) rootElement).getNode().getNamespaceURI());        Assert.assertNull(((XmlNode) rootElement).getNode().getPrefix());        Assert.assertNull(((XmlNode) rootElement).getNode().getLocalName());        Assert.assertEquals("pmd:rootElement", ((XmlNode) rootElement).getNode().getNodeName());        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "pmd:child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: &\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "pmd:child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser with validation on.     *     * @throws UnsupportedEncodingException     *             error     */    @Test    public void testParsingWithValidation() throws UnsupportedEncodingException {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setValidating(true);        PrintStream oldErr = System.err;        Locale oldLocale = Locale.getDefault();        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            System.setErr(new PrintStream(bos));            Locale.setDefault(Locale.ENGLISH);            Node document = XML.withParserOptions(parserOptions).parse(XML_INVALID_WITH_DTD);            Assert.assertNotNull(document);            String output = bos.toString("UTF-8");            Assert.assertTrue(output.contains("Element type \"invalidChild\" must be declared."));            Assert.assertTrue(output.contains("The content of element type \"rootElement\" must match \"(child)\"."));            Assert.assertEquals(2, document.getNumChildren());            Assert.assertEquals("invalidChild", String.valueOf(document.getChild(1).getChild(1)));        } finally {            System.setErr(oldErr);            Locale.setDefault(oldLocale);        }    }    @Test    public void testWithProcessingInstructions() {        String xml = "<?xml version=\"1.0\"?><?mypi?><!DOCTYPE testDoc [<!ENTITY myentity \"e\">]><!--Comment--><foo abc=\"abc\"><bar>TEXT</bar><![CDATA[cdata!]]>&gt;&myentity;&lt;</foo>";        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions options = (XmlParserOptions) xmlVersionHandler.getDefaultParserOptions();        options.setExpandEntityReferences(false);        Parser parser = xmlVersionHandler.getParser(options);        Node document = parser.parse(null, new StringReader(xml));        Assert.assertNotNull(document);        assertNode(document.getChild(0), "mypi", 0);        assertLineNumbers(document.getChild(0), 1, 22, 1, 29);    }    @Test    public void testBug1518() throws Exception {        XML.parseResource("parsertests/bug1518.xml");    }    @Test    public void testAutoclosingElementLength() {        final String xml = "<elementName att1='foo' att2='bar' att3='other' />";        assertLineNumbers(XML.parse(xml), 1, 1, 1, xml.length());    }    /**     * Asserts a single node inclusive attributes.     *     * @param node     *            the node     * @param toString     *            the to String representation to expect     * @param childs     *            number of childs     * @param atts     *            attributes - each object pair forms one attribute: first name,     *            then value.     */    private void assertNode(Node node, String toString, int childs, Object... atts) {        Assert.assertEquals(toString, String.valueOf(node));        Assert.assertEquals(childs, node.getNumChildren());        Iterator<Attribute> attributeIterator = ((XmlNode) node).getAttributeIterator();        if (atts != null) {            for (int i = 0; i < atts.length; i += 2) {                Assert.assertTrue(attributeIterator.hasNext());                String name = String.valueOf(atts[i]);                Object value = atts[i + 1];                Attribute attribute = attributeIterator.next();                Assert.assertEquals(name, attribute.getName());                Assert.assertEquals(value, attribute.getValue());            }        }        Assert.assertFalse(attributeIterator.hasNext());    }    /**     * Assert a single text node.     *     * @param node     *            the node to check     * @param text     *            the text to expect     */    private void assertTextNode(Node node, String text) {        assertTextNode(node, text, "text");    }    /**     * Assert a single text node.     *     * @param node     *            the node to check     * @param text     *            the text to expect     * @param toString     *            the to string representation     */    private void assertTextNode(Node node, String text, String toString) {        Assert.assertEquals(toString, String.valueOf(node));        Assert.assertEquals(0, node.getNumChildren());        Assert.assertEquals(text, StringUtil.escapeWhitespace(node.getImage()));        Iterator<Attribute> attributeIterator = ((XmlNode) node).getAttributeIterator();        Assert.assertTrue(attributeIterator.hasNext());        Attribute attribute = attributeIterator.next();        Assert.assertEquals("Image", attribute.getName());        Assert.assertEquals(text, StringUtil.escapeWhitespace(attribute.getValue()));        Assert.assertFalse(attributeIterator.hasNext());    }    /**     * Assert the line numbers of a node.     *     * @param node     *            the node     * @param beginLine     *            the begin line     * @param beginColumn     *            the begin column     * @param endLine     *            the end line     * @param endColumn     *            the end column     */    private void assertLineNumbers(Node node, int beginLine, int beginColumn, int endLine, int endColumn) {        Assert.assertEquals("begin line wrong", beginLine, node.getBeginLine());        Assert.assertEquals("begin column wrong", beginColumn, node.getBeginColumn());        Assert.assertEquals("end line wrong", endLine, node.getEndLine());        Assert.assertEquals("end column wrong", endColumn, node.getEndColumn());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProjectVersionAsDependencyVersionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InvalidDependencyTypesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.wsdl.rule;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.wsdl.WsdlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractWsdlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><foo abc=\"abc\"><bar/></foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        Parser parser = LanguageRegistry.getLanguage(WsdlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        MyRule rule = new MyRule();        rule.apply(nodes, null);        assertEquals(3, rule.visitedNodes.size());        assertEquals("document", rule.visitedNodes.get(0).toString());        assertEquals("foo", rule.visitedNodes.get(1).toString());        assertEquals("bar", rule.visitedNodes.get(2).toString());    }    private static class MyRule extends AbstractWsdlRule {        final List<XmlNode> visitedNodes = new ArrayList<>();        MyRule() {        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            visitedNodes.clear();            super.apply(nodes, ctx);        }        @Override        protected void visit(XmlNode node, RuleContext ctx) {            visitedNodes.add(node);            super.visit(node, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidAxisNavigationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseConcatOnceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testXML() {        executeTarget("testXML");        assertOutputContaining("Potentially mistyped CDATA section with extra [ at beginning or ] at the end.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.pom.PomLanguageModule;import net.sourceforge.pmd.lang.wsdl.WsdlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xsl.XslLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { XmlLanguageModule.NAME, XmlLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion(), },            { XslLanguageModule.NAME, XslLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(XslLanguageModule.NAME).getDefaultVersion(), },            { WsdlLanguageModule.NAME, WsdlLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(WsdlLanguageModule.NAME).getDefaultVersion(), },            { PomLanguageModule.NAME, PomLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(PomLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test xml's and xslt's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class GoTokenizerTest extends CpdTextComparisonTest {    public GoTokenizerTest() {        super(".go");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new GoTokenizer();    }    @Override    protected String getResourcePrefix() {        return "../lang/go/cpd/testdata";    }    @Test    public void simpleTest() {        doTest("hello");    }    @Test    public void bigFileTest() {        doTest("btrfs");    }    @Test    public void testIssue1751() {        doTest("issue-1751");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.go.GoLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { GoLanguageModule.NAME, GoLanguageModule.TERSE_NAME, "1",            LanguageRegistry.getLanguage(GoLanguageModule.NAME).getDefaultVersion(), }, });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.ast.TokenMgrError;public class CsTokenizerTest extends CpdTextComparisonTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    public CsTokenizerTest() {        super(".cs");    }    @Override    protected String getResourcePrefix() {        return "../lang/cs/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        CsTokenizer tok = new CsTokenizer();        tok.setProperties(properties);        return tok;    }    @Test    public void testSimpleClass() {        doTest("simpleClass");    }    @Test    public void testSimpleClassMethodMultipleLines() {        doTest("simpleClassMethodMultipleLines");    }    @Test    public void testStrings() {        doTest("strings");    }    @Test    public void testOpenString() {        ex.expect(TokenMgrError.class);        doTest("unlexable_string");    }    @Test    public void testCommentsIgnored1() {        doTest("comments");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testOperators() {        doTest("operatorsAndStuff");    }    @Test    public void testLineNumberAfterMultilineString() {        doTest("strings");    }    @Test    public void testDoNotIgnoreUsingDirectives() {        doTest("usingDirectives");    }    @Test    public void testIgnoreUsingDirectives() {        doTest("usingDirectives", "_ignored", ignoreUsings());    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    @Test    public void testLongListsOfNumbersAreNotIgnored() {        doTest("listOfNumbers");    }    @Test    public void testLongListsOfNumbersAreIgnored() {        doTest("listOfNumbers", "_ignored", skipLiteralSequences());    }    @Test    public void testCSharp7And8Additions() {        doTest("csharp7And8Additions");    }    private Properties ignoreUsings() {        return properties(true, false);    }    private Properties skipLiteralSequences() {        return properties(false, true);    }    private Properties properties(boolean ignoreUsings, boolean ignoreLiteralSequences) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.IGNORE_USINGS, Boolean.toString(ignoreUsings));        properties.setProperty(Tokenizer.OPTION_IGNORE_LITERAL_SEQUENCES, Boolean.toString(ignoreLiteralSequences));        return properties;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import java.util.ArrayList;import java.util.List;import java.util.Properties;import org.junit.Ignore;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageVersion;/** * Stores the information required to run a complete test. */@Ignore("this is not a unit test")public class TestDescriptor {    private Rule rule;    private Properties properties;    private String description;    private int numberOfProblemsExpected;    private List<String> expectedMessages = new ArrayList<>();    private List<Integer> expectedLineNumbers = new ArrayList<>();    private String code;    private LanguageVersion languageVersion;    // default, avoids unintentional mixing of state between test cases    private boolean reinitializeRule = true;    private boolean isRegressionTest = true;    private boolean useAuxClasspath = true;    private int numberInDocument = -1;    public TestDescriptor() {        // Empty default descriptor added to please mvn surefire plugin    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this(code, description, numberOfProblemsExpected, rule, rule.getLanguage().getDefaultVersion());    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule,            LanguageVersion languageVersion) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;        this.languageVersion = languageVersion;    }    public int getNumberInDocument() {        return numberInDocument;    }    public void setNumberInDocument(int numberInDocument) {        this.numberInDocument = numberInDocument;    }    public void setExpectedMessages(List<String> messages) {        expectedMessages.clear();        expectedMessages.addAll(messages);    }    public List<String> getExpectedMessages() {        return expectedMessages;    }    public void setExpectedLineNumbers(List<Integer> expectedLineNumbers) {        this.expectedLineNumbers.clear();        this.expectedLineNumbers.addAll(expectedLineNumbers);    }    public List<Integer> getExpectedLineNumbers() {        return expectedLineNumbers;    }    public void setProperties(Properties properties) {        this.properties = properties;    }    public Properties getProperties() {        return properties;    }    public String getCode() {        return code;    }    public LanguageVersion getLanguageVersion() {        return languageVersion;    }    public String getDescription() {        return description;    }    public int getNumberOfProblemsExpected() {        return numberOfProblemsExpected;    }    public Rule getRule() {        return rule;    }    public boolean getReinitializeRule() {        return reinitializeRule;    }    public void setReinitializeRule(boolean reinitializeRule) {        this.reinitializeRule = reinitializeRule;    }    /**     * Checks whether we are testing for regression problems only. Return value     * is based on the system property "pmd.regress".     *     * @return <code>false</code> if system property "pmd.regress" is set to     *         <code>false</code>, <code>true</code> otherwise     */    public static boolean inRegressionTestMode() {        boolean inRegressionMode = true; // default        try {            // get the "pmd.regress" System property            String property = System.getProperty("pmd.regress");            if (property != null) {                inRegressionMode = Boolean.parseBoolean(property);            }        } catch (IllegalArgumentException e) {            throw new RuntimeException("Invalid system property 'pmd.regress'", e);        }        return inRegressionMode;    }    public boolean isRegressionTest() {        return isRegressionTest;    }    public void setRegressionTest(boolean isRegressionTest) {        this.isRegressionTest = isRegressionTest;    }    public void setUseAuxClasspath(boolean useAuxClasspath) {        this.useAuxClasspath = useAuxClasspath;    }    public boolean isUseAuxClasspath() {        return useAuxClasspath;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.util.List;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;/** * @author Romain PELISSE, belaran@gmail.com * * @deprecated Use CpdTextComparisonTest in module pmd-lang-test */@Deprecatedpublic abstract class AbstractTokenizerTest {    protected int expectedTokenCount;    protected Tokenizer tokenizer;    protected SourceCode sourceCode;    public abstract void buildTokenizer() throws IOException;    public abstract String getSampleCode() throws IOException;    protected void tokenizeTest() throws IOException {        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        List<TokenEntry> entries = tokens.getTokens();        assertEquals(expectedTokenCount, entries.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;/** * Unit tests for {@link ParserOptions}. * @deprecated for removal in PMD 7.0. Use {@link ParserOptionsTestUtils}. */@Deprecatedpublic class ParserOptionsTest {    /**     * SuppressMarker should be initially null and changeable.     */    @Test    public void testSuppressMarker() {        ParserOptions parserOptions = new ParserOptions();        Assert.assertNull(parserOptions.getSuppressMarker());        parserOptions.setSuppressMarker("foo");        Assert.assertEquals("foo", parserOptions.getSuppressMarker());    }    /**     * Verify that the equals and hashCode methods work as expected.     */    @Test    public void testEqualsHashcode() {        ParserOptions options1 = new ParserOptions();        options1.setSuppressMarker("foo");        ParserOptions options2 = new ParserOptions();        options2.setSuppressMarker("bar");        ParserOptions options3 = new ParserOptions();        options3.setSuppressMarker("foo");        ParserOptions options4 = new ParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    /**     * Verify equals and hashCode for 4 {@link ParserOptions} instances. The     * given options should be as follows: 1 and 3 are equals, as are 2 and 4.     *     * @param options1     *            first option instance - equals third     * @param options2     *            second option instance - equals fourth     * @param options3     *            third option instance - equals first     * @param options4     *            fourth option instance - equals second     */    public static void verifyOptionsEqualsHashcode(ParserOptions options1, ParserOptions options2,                                                   ParserOptions options3, ParserOptions options4) {        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.nio.file.Files;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.BeforeClass;import net.sourceforge.pmd.PMD;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public abstract class BaseCLITest {    protected static final String TEST_OUPUT_DIRECTORY = "target/cli-tests/";    // Points toward a folder with not many source files, to avoid actually PMD    // and slowing down tests    protected static final String SOURCE_FOLDER = "src/test/resources/net/sourceforge/pmd/cli";    protected PrintStream originalOut;    protected PrintStream originalErr;    /**     * @throws java.lang.Exception     */    @BeforeClass    public static void setUp() throws Exception {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        File testOuputDir = new File(TEST_OUPUT_DIRECTORY);        if (!testOuputDir.exists()) {            assertTrue("failed to create output directory for test:" + testOuputDir.getAbsolutePath(),                    testOuputDir.mkdirs());        }    }    @Before    public void setup() {        originalOut = System.out;        originalErr = System.err;    }    @After    public void tearDown() {        IOUtils.closeQuietly(System.out);        System.setOut(originalOut);        System.setErr(originalErr);    }    protected void createTestOutputFile(String filename) {        try {            @SuppressWarnings("PMD.CloseResource")            PrintStream out = new PrintStream(Files.newOutputStream(new File(filename).toPath()));            System.setOut(out);            System.setErr(out);        } catch (IOException e) {            fail("Can't create file " + filename + " for test.");        }    }    protected String runTest(String[] args, String testname) {        return runTest(args, testname, 0);    }    protected String runTest(String[] args, String testname, int expectedExitCode) {        String filename = TEST_OUPUT_DIRECTORY + testname + ".txt";        long start = System.currentTimeMillis();        createTestOutputFile(filename);        System.out.println("Start running test " + testname);        runPMDWith(args);        checkStatusCode(expectedExitCode);        System.out.println("Test finished successfully after " + (System.currentTimeMillis() - start) + "ms.");        return filename;    }    protected void runPMDWith(String[] args) {        PMD.main(args);    }    protected void checkStatusCode(int expectedExitCode) {        int statusCode = getStatusCode();        if (statusCode != expectedExitCode) {            fail("PMD failed with status code:" + statusCode);        }    }    protected int getStatusCode() {        return Integer.parseInt(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.UnsupportedEncodingException;import org.junit.After;import org.junit.Before;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.cpd.CPDCommandLineInterface;public abstract class BaseCPDCLITest {    private ByteArrayOutputStream bufferStdout;    private PrintStream originalStdout;    private PrintStream originalStderr;    @Before    public void setup() throws UnsupportedEncodingException {        originalStdout = System.out;        originalStderr = System.err;        bufferStdout = new ByteArrayOutputStream();        System.setOut(new PrintStream(bufferStdout, false, "UTF-8"));        System.setErr(System.out);    }    @After    public void teardown() {        System.setOut(originalStdout);        System.setErr(originalStderr);    }    public final String getOutput() {        try {            return bufferStdout.toString("UTF-8");        } catch (UnsupportedEncodingException e) {            throw new RuntimeException(e);        }    }    protected void runCPD(String... args) {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPD.main(args);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Properties;import java.util.Set;import java.util.StringTokenizer;import java.util.regex.Pattern;import javax.xml.parsers.ParserConfigurationException;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.apache.commons.io.FilenameUtils;import org.junit.BeforeClass;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import org.xml.sax.helpers.DefaultHandler;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.ResourceLoader;/** * Base test class to verify the language's rulesets. This class should be * subclassed for each language. */public abstract class AbstractRuleSetFactoryTest {    @org.junit.Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    private static SAXParserFactory saxParserFactory;    private static ValidateDefaultHandler validateDefaultHandler;    private static SAXParser saxParser;    protected Set<String> validXPathClassNames = new HashSet<>();    private final Set<String> languagesToSkip = new HashSet<>();    public AbstractRuleSetFactoryTest() {        this(new String[0]);    }    /**     * Constructor used when a module that depends on another module wants to filter out the dependee's rulesets.     *     * @param languagesToSkip {@link Language}s terse names that appear in the classpath via a dependency, but should be     * skipped because they aren't the primary language which the concrete instance of this class is testing.     */    public AbstractRuleSetFactoryTest(String... languagesToSkip) {        this.languagesToSkip.addAll(Arrays.asList(languagesToSkip));        validXPathClassNames.add(XPathRule.class.getName());    }    /**     * Setups the XML parser with validation.     *     * @throws Exception     *             any error     */    @BeforeClass    public static void init() throws Exception {        saxParserFactory = SAXParserFactory.newInstance();        saxParserFactory.setValidating(true);        saxParserFactory.setNamespaceAware(true);        // Hope we're using Xerces, or this may not work!        // Note: Features are listed here        // http://xerces.apache.org/xerces2-j/features.html        saxParserFactory.setFeature("http://xml.org/sax/features/validation", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema-full-checking", true);        validateDefaultHandler = new ValidateDefaultHandler();        saxParser = saxParserFactory.newSAXParser();    }    /**     * Checks all rulesets of all languages on the classpath and verifies that     * all required attributes for all rules are specified.     *     * @throws Exception     *             any error     */    @Test    public void testAllPMDBuiltInRulesMeetConventions() throws Exception {        int invalidSinceAttributes = 0;        int invalidExternalInfoURL = 0;        int invalidClassName = 0;        int invalidRegexSuppress = 0;        int invalidXPathSuppress = 0;        StringBuilder messages = new StringBuilder();        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            RuleSet ruleSet = loadRuleSetByFileName(fileName);            for (Rule rule : ruleSet.getRules()) {                // Skip references                if (rule instanceof RuleReference) {                    continue;                }                Language language = rule.getLanguage();                String group = fileName.substring(fileName.lastIndexOf('/') + 1);                group = group.substring(0, group.indexOf(".xml"));                if (group.indexOf('-') >= 0) {                    group = group.substring(0, group.indexOf('-'));                }                // Is since missing ?                if (rule.getSince() == null) {                    invalidSinceAttributes++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" is missing 'since' attribute")                            .append(PMD.EOL);                }                // Is URL valid ?                if (rule.getExternalInfoUrl() == null || "".equalsIgnoreCase(rule.getExternalInfoUrl())) {                    invalidExternalInfoURL++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" is missing 'externalInfoURL' attribute")                            .append(PMD.EOL);                } else {                    String expectedExternalInfoURL = "https?://pmd.(sourceforge.net|github.io)/.+/pmd_rules_"                            + language.getTerseName() + "_"                            + FilenameUtils.getBaseName(fileName)                            + ".html#"                            + rule.getName().toLowerCase(Locale.ROOT);                    if (rule.getExternalInfoUrl() == null                            || !rule.getExternalInfoUrl().matches(expectedExternalInfoURL)) {                        invalidExternalInfoURL++;                        messages.append("Rule ")                                .append(fileName)                                .append("/")                                .append(rule.getName())                                .append(" seems to have an invalid 'externalInfoURL' value (")                                .append(rule.getExternalInfoUrl())                                .append("), it should be:")                                .append(expectedExternalInfoURL)                                .append(PMD.EOL);                    }                }                // Proper class name/packaging?                String expectedClassName = "net.sourceforge.pmd.lang." + language.getTerseName() + ".rule." + group                        + "." + rule.getName() + "Rule";                if (!rule.getRuleClass().equals(expectedClassName)                        && !validXPathClassNames.contains(rule.getRuleClass())) {                    invalidClassName++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" seems to have an invalid 'class' value (")                            .append(rule.getRuleClass())                            .append("), it should be:")                            .append(expectedClassName)                            .append(PMD.EOL);                }                // Should not have violation suppress regex property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR) != null) {                    invalidRegexSuppress++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" should not have '")                            .append(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name())                            .append("', this is intended for end user customization only.")                            .append(PMD.EOL);                }                // Should not have violation suppress xpath property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) != null) {                    invalidXPathSuppress++;                    messages.append("Rule ").append(fileName).append("/").append(rule.getName()).append(" should not have '").append(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name()).append("', this is intended for end user customization only.").append(PMD.EOL);                }            }        }        // We do this at the end to ensure we test ALL the rules before failing        // the test        if (invalidSinceAttributes > 0 || invalidExternalInfoURL > 0 || invalidClassName > 0 || invalidRegexSuppress > 0                || invalidXPathSuppress > 0) {            fail("All built-in PMD rules need 'since' attribute (" + invalidSinceAttributes                    + " are missing), a proper ExternalURLInfo (" + invalidExternalInfoURL                    + " are invalid), a class name meeting conventions (" + invalidClassName + " are invalid), no '"                    + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name() + "' property (" + invalidRegexSuppress                    + " are invalid), and no '" + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name() + "' property ("                    + invalidXPathSuppress + " are invalid)" + PMD.EOL + messages);        }    }    /**     * Verifies that all rulesets are valid XML according to the xsd schema.     *     * @throws Exception     *             any error     */    @Test    public void testXmlSchema() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstSchema(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Verifies that all rulesets are valid XML according to the DTD.     *     * @throws Exception     *             any error     */    @Test    public void testDtd() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstDtd(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Reads and writes the rulesets to make sure, that no data is lost if the     * rulests are processed.     *     * @throws Exception     *             any error     */    @Test    public void testReadWriteRoundTrip() throws Exception {        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            testRuleSet(fileName);        }    }    // Gets all test PMD Ruleset XML files    private List<String> getRuleSetFileNames() throws IOException, RuleSetNotFoundException {        List<String> result = new ArrayList<>();        for (Language language : LanguageRegistry.getLanguages()) {            if (this.languagesToSkip.contains(language.getTerseName())) {                continue;            }            result.addAll(getRuleSetFileNames(language.getTerseName()));        }        return result;    }    private List<String> getRuleSetFileNames(String language) throws IOException, RuleSetNotFoundException {        List<String> ruleSetFileNames = new ArrayList<>();        try {            Properties properties = new Properties();            try (InputStream is = new ResourceLoader().loadClassPathResourceAsStreamOrThrow("rulesets/" + language + "/rulesets.properties")) {                properties.load(is);            }            String fileNames = properties.getProperty("rulesets.filenames");            StringTokenizer st = new StringTokenizer(fileNames, ",");            while (st.hasMoreTokens()) {                ruleSetFileNames.add(st.nextToken());            }        } catch (RuleSetNotFoundException e) {            // this might happen if a language is only support by CPD, but not            // by PMD            System.err.println("No ruleset found for language " + language);        }        return ruleSetFileNames;    }    private RuleSet loadRuleSetByFileName(String ruleSetFileName) throws RuleSetNotFoundException {        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        return rsf.createRuleSet(ruleSetFileName);    }    private boolean validateAgainstSchema(String fileName)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstSchema(inputStream);            if (!valid) {                System.err.println("Validation against XML Schema failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstSchema(InputStream inputStream)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        saxParser.parse(inputStream, validateDefaultHandler.resetValid());        inputStream.close();        return validateDefaultHandler.isValid();    }    private boolean validateAgainstDtd(String fileName)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstDtd(inputStream);            if (!valid) {                System.err.println("Validation against DTD failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstDtd(InputStream inputStream)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        // Read file into memory        String file = readFullyToString(inputStream);        inputStream.close();        String rulesetNamespace = RuleSetWriter.RULESET_2_0_0_NS_URI;        // Remove XML Schema stuff, replace with DTD        file = file.replaceAll("<\\?xml [ a-zA-Z0-9=\".-]*\\?>", "");        file = file.replaceAll("xmlns=\"" + rulesetNamespace + "\"", "");        file = file.replaceAll("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "");        file = file.replaceAll("xsi:schemaLocation=\"" + rulesetNamespace                + " https://pmd.sourceforge.io/ruleset_\\d_0_0.xsd\"", "");        if (rulesetNamespace.equals(RuleSetWriter.RULESET_2_0_0_NS_URI)) {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset SYSTEM "                    + "\"https://pmd.sourceforge.io/ruleset_2_0_0.dtd\">" + PMD.EOL + file;        } else {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset>" + PMD.EOL + file;        }        try (InputStream modifiedStream = new ByteArrayInputStream(file.getBytes())) {            saxParser.parse(modifiedStream, validateDefaultHandler.resetValid());        }        return validateDefaultHandler.isValid();    }    private String readFullyToString(InputStream inputStream) throws IOException {        StringBuilder buf = new StringBuilder(64 * 1024);        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {            String line;            while ((line = reader.readLine()) != null) {                buf.append(line);                buf.append(PMD.EOL);            }            return buf.toString();        }    }    private static InputStream loadResourceAsStream(String resource) throws RuleSetNotFoundException {        return new ResourceLoader().loadClassPathResourceAsStreamOrThrow(resource);    }    private void testRuleSet(String fileName)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        // Load original XML        // String xml1 =        // readFullyToString(ResourceLoader.loadResourceAsStream(fileName));        // System.out.println("xml1: " + xml1);        // Load the original RuleSet        RuleSet ruleSet1 = loadRuleSetByFileName(fileName);        // Write to XML, first time        ByteArrayOutputStream outputStream1 = new ByteArrayOutputStream();        RuleSetWriter writer1 = new RuleSetWriter(outputStream1);        writer1.write(ruleSet1);        writer1.close();        String xml2 = new String(outputStream1.toByteArray());        // System.out.println("xml2: " + xml2);        // Read RuleSet from XML, first time        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleSet2 = ruleSetFactory.createRuleSet(createRuleSetReferenceId(xml2));        // Do write/read a 2nd time, just to be sure        // Write to XML, second time        ByteArrayOutputStream outputStream2 = new ByteArrayOutputStream();        RuleSetWriter writer2 = new RuleSetWriter(outputStream2);        writer2.write(ruleSet2);        writer2.close();        String xml3 = new String(outputStream2.toByteArray());        // System.out.println("xml3: " + xml3);        // Read RuleSet from XML, second time        RuleSet ruleSet3 = ruleSetFactory.createRuleSet(createRuleSetReferenceId(xml3));        // The 2 written XMLs should all be valid w.r.t Schema/DTD        assertTrue("1st roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml3.getBytes())));        assertTrue("1st roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml3.getBytes())));        // All 3 versions of the RuleSet should be the same        assertEqualsRuleSet("Original RuleSet and 1st roundtrip Ruleset not the same (filename: " + fileName + ")",                ruleSet1, ruleSet2);        assertEqualsRuleSet("1st roundtrip Ruleset and 2nd roundtrip RuleSet not the same (filename: " + fileName + ")",                ruleSet2, ruleSet3);        // It's hard to compare the XML DOMs. At least the roundtrip ones should        // textually be the same.        assertEquals("1st roundtrip RuleSet XML and 2nd roundtrip RuleSet XML (filename: " + fileName + ")", xml2,                xml3);    }    private void assertEqualsRuleSet(String message, RuleSet ruleSet1, RuleSet ruleSet2) {        assertEquals(message + ", RuleSet name", ruleSet1.getName(), ruleSet2.getName());        assertEquals(message + ", RuleSet description", ruleSet1.getDescription(), ruleSet2.getDescription());        assertEquals(message + ", RuleSet exclude patterns", ruleSet1.getExcludePatterns(),                ruleSet2.getExcludePatterns());        assertEquals(message + ", RuleSet include patterns", ruleSet1.getIncludePatterns(),                ruleSet2.getIncludePatterns());        assertEquals(message + ", RuleSet rule count", ruleSet1.getRules().size(), ruleSet2.getRules().size());        for (int i = 0; i < ruleSet1.getRules().size(); i++) {            Rule rule1 = ((List<Rule>) ruleSet1.getRules()).get(i);            Rule rule2 = ((List<Rule>) ruleSet2.getRules()).get(i);            assertFalse(message + ", Different RuleReference",                        rule1 instanceof RuleReference != rule2 instanceof RuleReference);            if (rule1 instanceof RuleReference) {                RuleReference ruleReference1 = (RuleReference) rule1;                RuleReference ruleReference2 = (RuleReference) rule2;                assertEquals(message + ", RuleReference overridden language", ruleReference1.getOverriddenLanguage(),                        ruleReference2.getOverriddenLanguage());                assertEquals(message + ", RuleReference overridden minimum language version",                        ruleReference1.getOverriddenMinimumLanguageVersion(),                        ruleReference2.getOverriddenMinimumLanguageVersion());                assertEquals(message + ", RuleReference overridden maximum language version",                        ruleReference1.getOverriddenMaximumLanguageVersion(),                        ruleReference2.getOverriddenMaximumLanguageVersion());                assertEquals(message + ", RuleReference overridden deprecated", ruleReference1.isOverriddenDeprecated(),                        ruleReference2.isOverriddenDeprecated());                assertEquals(message + ", RuleReference overridden name", ruleReference1.getOverriddenName(),                        ruleReference2.getOverriddenName());                assertEquals(message + ", RuleReference overridden description",                        ruleReference1.getOverriddenDescription(), ruleReference2.getOverriddenDescription());                assertEquals(message + ", RuleReference overridden message", ruleReference1.getOverriddenMessage(),                        ruleReference2.getOverriddenMessage());                assertEquals(message + ", RuleReference overridden external info url",                        ruleReference1.getOverriddenExternalInfoUrl(), ruleReference2.getOverriddenExternalInfoUrl());                assertEquals(message + ", RuleReference overridden priority", ruleReference1.getOverriddenPriority(),                        ruleReference2.getOverriddenPriority());                assertEquals(message + ", RuleReference overridden examples", ruleReference1.getOverriddenExamples(),                        ruleReference2.getOverriddenExamples());            }            assertEquals(message + ", Rule name", rule1.getName(), rule2.getName());            assertEquals(message + ", Rule class", rule1.getRuleClass(), rule2.getRuleClass());            assertEquals(message + ", Rule description " + rule1.getName(), rule1.getDescription(),                    rule2.getDescription());            assertEquals(message + ", Rule message", rule1.getMessage(), rule2.getMessage());            assertEquals(message + ", Rule external info url", rule1.getExternalInfoUrl(), rule2.getExternalInfoUrl());            assertEquals(message + ", Rule priority", rule1.getPriority(), rule2.getPriority());            assertEquals(message + ", Rule examples", rule1.getExamples(), rule2.getExamples());            List<PropertyDescriptor<?>> propertyDescriptors1 = rule1.getPropertyDescriptors();            List<PropertyDescriptor<?>> propertyDescriptors2 = rule2.getPropertyDescriptors();            assertEquals(message + ", Rule property descriptor ", propertyDescriptors1, propertyDescriptors2);            for (int j = 0; j < propertyDescriptors1.size(); j++) {                Object value1 = rule1.getProperty(propertyDescriptors1.get(j));                Object value2 = rule2.getProperty(propertyDescriptors2.get(j));                // special case for Pattern, there is no equals method                if (propertyDescriptors1.get(j).type() == Pattern.class) {                    value1 = ((Pattern) value1).pattern();                    value2 = ((Pattern) value2).pattern();                }                assertEquals(message + ", Rule property value " + j, value1, value2);            }            assertEquals(message + ", Rule property descriptor count", propertyDescriptors1.size(),                    propertyDescriptors2.size());        }    }    /**     * Create a {@link RuleSetReferenceId} by the given XML string.     *     * @param ruleSetXml     *            the ruleset file content as string     * @return the {@link RuleSetReferenceId}     */    protected static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {        return new RuleSetReferenceId(null) {            @Override            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {                return new ByteArrayInputStream(ruleSetXml.getBytes(StandardCharsets.UTF_8));            }        };    }    /**     * Validator for the SAX parser     */    private static class ValidateDefaultHandler extends DefaultHandler {        private boolean valid = true;        private final Map<String, String> schemaMapping;        ValidateDefaultHandler() {            schemaMapping = new HashMap<>();            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.xsd", "ruleset_2_0_0.xsd");            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.dtd", "ruleset_2_0_0.dtd");        }        public ValidateDefaultHandler resetValid() {            valid = true;            return this;        }        public boolean isValid() {            return valid;        }        @Override        public void error(SAXParseException e) throws SAXException {            log("Error", e);        }        @Override        public void fatalError(SAXParseException e) throws SAXException {            log("FatalError", e);        }        @Override        public void warning(SAXParseException e) throws SAXException {            log("Warning", e);        }        private void log(String prefix, SAXParseException e) {            String message = prefix + " at (" + e.getLineNumber() + ", " + e.getColumnNumber() + "): " + e.getMessage();            System.err.println(message);            valid = false;        }        @Override        public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {            String resource = schemaMapping.get(systemId);            if (resource != null) {                try {                    InputStream inputStream = loadResourceAsStream(resource);                    return new InputSource(inputStream);                } catch (RuleSetNotFoundException e) {                    System.err.println(e.getMessage());                    throw new IOException(e.getMessage());                }            }            throw new IllegalArgumentException(                    "No clue how to handle: publicId=" + publicId + ", systemId=" + systemId);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.ant.SourceLanguage;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.util.ResourceLoader;/** * Base test class for {@link LanguageVersion} implementations. <br> * Each language implementation should subclass this and provide a data method. * * <pre> * &#64;Parameters *     public static Collection&lt;Object[]&gt; data() { *       return Arrays.asList(new Object[][] { *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.1", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.1") }, *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.2", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.2") }, * *            // doesn't exist *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.3", *              null } *       }); * </pre> * * <p>For the parameters, see the constructor * {@link #AbstractLanguageVersionTest(String, String, String, LanguageVersion)}.</p> */@RunWith(Parameterized.class)public class AbstractLanguageVersionTest {    private String name;    private String version;    private String simpleTerseName;    private String terseName;    private LanguageVersion expected;    /**     * Creates a new {@link AbstractLanguageVersionTest}     *     * @param name     *            the name under which the language module is registered     * @param terseName     *            the terse name under which the language module is registered     * @param version     *            the specific version of the language version     * @param expected     *            the expected {@link LanguageVersion} instance     */    public AbstractLanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        this.name = name;        this.version = version;        this.simpleTerseName = terseName;        this.terseName = terseName;        if (version != null && !version.isEmpty()) {            this.terseName += " " + version;        }        this.expected = expected;    }    /**     * Checks that the expected {@link LanguageVersion} can be found by the     * combination of {@link #terseName} and {@link #version}.     */    @Test    public void testGetLanguageVersionForTerseName() {        assertEquals(expected, LanguageRegistry.findLanguageVersionByTerseName(terseName));    }    /**     * Checks that the expected {@link LanguageVersion} can be found via     * {@link #name} and {@link #version}.     */    @Test    public void testFindVersionsForLanguageNameAndVersion() {        SourceLanguage sourceLanguage = new SourceLanguage();        sourceLanguage.setName(name);        sourceLanguage.setVersion(version);        Language language = LanguageRegistry.getLanguage(sourceLanguage.getName());        LanguageVersion languageVersion = null;        if (language != null) {            languageVersion = language.getVersion(sourceLanguage.getVersion());        }        assertEquals(expected, languageVersion);    }    private boolean supportsRules() {        if (expected == null || expected.getLanguage().getRuleChainVisitorClass() == null                || expected.getLanguageVersionHandler() == null) {            return false;        }        LanguageVersionHandler languageVersionHandler = expected.getLanguageVersionHandler();        ParserOptions defaultParserOptions = languageVersionHandler.getDefaultParserOptions();        Parser parser = languageVersionHandler.getParser(defaultParserOptions);        return parser.canParse();    }    /**     * Makes sure, that for each language a "categories.properties" file exists.     *     * @throws Exception     *             any error     */    @Test    public void testRegisteredRulesets() throws Exception {        // only check for languages, that support rules        if (!supportsRules()) {            return;        }        ResourceLoader rl = new ResourceLoader();        Properties props = new Properties();        String rulesetsProperties = "category/" + simpleTerseName + "/categories.properties";        try (InputStream inputStream = rl.loadClassPathResourceAsStreamOrThrow(rulesetsProperties)) {            props.load(inputStream);        }        assertRulesetsAndCategoriesProperties(rl, props);    }    /**     * If a rulesets.properties file still exists, test it as well.     *     * @throws Exception     *             any error     */    @Test    public void testOldRegisteredRulesets() throws Exception {        // only check for languages, that support rules        if (expected == null || expected.getLanguage().getRuleChainVisitorClass() == null) {            return;        }        ResourceLoader rl = new ResourceLoader();        Properties props = new Properties();        String rulesetsProperties = "rulesets/" + simpleTerseName + "/rulesets.properties";        InputStream inputStream = rl.loadClassPathResourceAsStream(rulesetsProperties);        if (inputStream != null) {            // rulesets.properties file exists            try (InputStream in = inputStream) {                props.load(in);            }            assertRulesetsAndCategoriesProperties(rl, props);        }    }    @Test    public void testVersionsAreDistinct() {        if (expected == null) {            return;        }        Language lang = expected.getLanguage();        int count = 0;        for (LanguageVersion lv : lang.getVersions()) {            if (lv.equals(expected)) {                count++;            }        }        assertEquals("Expected exactly one occurrence of " + expected                         + " in the language versions of its language", 1, count);    }    private void assertRulesetsAndCategoriesProperties(ResourceLoader rl, Properties props)            throws IOException, RuleSetNotFoundException {        String rulesetFilenames = props.getProperty("rulesets.filenames");        assertNotNull(rulesetFilenames);        RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();        if (rulesetFilenames.trim().isEmpty()) {            return;        }        String[] rulesets = rulesetFilenames.split(",");        for (String r : rulesets) {            try (InputStream stream = rl.loadClassPathResourceAsStream(r)) {                assertNotNull(stream);            }            RuleSet ruleset = factory.createRuleSet(r);            assertNotNull(ruleset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.verifyNoMoreInteractions;import static org.mockito.Mockito.when;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import org.mockito.ArgumentMatchers;import org.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.test.lang.ast.DummyNode;public class RuleTstTest {    private LanguageVersion dummyLanguage = LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion();    private Rule rule = mock(Rule.class);    private RuleTst ruleTester = new RuleTst() {    };    @Test    public void shouldCallStartAndEnd() {        Report report = new Report();        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        ruleTester.runTestFromString("the code", rule, report, dummyLanguage, false);        verify(rule).start(any(RuleContext.class));        verify(rule).end(any(RuleContext.class));        verify(rule, times(5)).getLanguage();        verify(rule).isDfa();        verify(rule).isTypeResolution();        verify(rule).isMultifile();        verify(rule, times(2)).isRuleChain();        verify(rule).getMinimumLanguageVersion();        verify(rule).getMaximumLanguageVersion();        verify(rule).apply(ArgumentMatchers.<Node>anyList(), any(RuleContext.class));        verify(rule, times(4)).getName();        verify(rule).getPropertiesByPropertyDescriptor();        verifyNoMoreInteractions(rule);    }    @Test    public void shouldAssertLinenumbersSorted() {        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        Mockito.doAnswer(new Answer<Void>() {            private RuleViolation createViolation(RuleContext context, int beginLine, String message) {                DummyNode node = new DummyNode(1);                node.testingOnlySetBeginLine(beginLine);                node.testingOnlySetBeginColumn(1);                ParametricRuleViolation<Node> violation = new ParametricRuleViolation<Node>(rule, context, node, message);                return violation;            }            @Override            public Void answer(InvocationOnMock invocation) throws Throwable {                RuleContext context = invocation.getArgument(1, RuleContext.class);                // the violations are reported out of order                context.getReport().addRuleViolation(createViolation(context, 15, "first reported violation"));                context.getReport().addRuleViolation(createViolation(context, 5, "second reported violation"));                return null;            }        }).when(rule).apply(ArgumentMatchers.<Node>anyList(), Mockito.any(RuleContext.class));        TestDescriptor testDescriptor = new TestDescriptor("the code", "sample test", 2, rule, dummyLanguage);        testDescriptor.setReinitializeRule(false);        testDescriptor.setExpectedLineNumbers(Arrays.asList(5, 15));        try {            ruleTester.runTest(testDescriptor);            // there should be no assertion failures            // expected line numbers and actual line numbers match        } catch (AssertionError assertionError) {            Assert.fail(assertionError.toString());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.Arrays;import java.util.Collections;import java.util.List;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sourceforge.pmd.test.lang.DummyLanguageModule;/** * Unit tests for {@link ParserOptions}. * This class is located in the pmd-test project instead of pmd-core so that it can invoke * {@link ParserOptionsTestUtils#verifyOptionsEqualsHashcode} * * TODO: 7.0.0: Rename to ParserOptionsTest when {@link ParserOptionsTest} is removed. */public class ParserOptionsUnitTest {    private static final List<String> DEFAULT_LIST = Arrays.asList("value1", "value2");    private static final String DEFAULT_STRING = "value3";    private static final List<String> OVERRIDDEN_LIST = Arrays.asList("override1", "override2");    private static final String OVERRIDDEN_STRING = "override3";    private static class TestParserOptions extends ParserOptions {        private static final PropertyDescriptor<List<String>> LIST_DESCRIPTOR =                PropertyFactory.stringListProperty("listOfStringValues")                        .desc("A list of values for testing.")                        .defaultValue(DEFAULT_LIST)                        .delim(',')                        .build();        private static final PropertyDescriptor<String> STRING_DESCRIPTOR =                PropertyFactory.stringProperty("stringValue")                        .desc("A single value for testing.")                        .defaultValue(DEFAULT_STRING)                        .build();        private TestParserOptions() {            super(DummyLanguageModule.TERSE_NAME);            defineProperty(LIST_DESCRIPTOR);            defineProperty(STRING_DESCRIPTOR);            overridePropertiesFromEnv();        }    }    /**     * SuppressMarker should be initially null and changeable.     */    @Test    public void testSuppressMarker() {        ParserOptions parserOptions = new ParserOptions();        Assert.assertNull(parserOptions.getSuppressMarker());        parserOptions.setSuppressMarker("foo");        Assert.assertEquals("foo", parserOptions.getSuppressMarker());    }    @Test    public void testDefaultPropertyDescriptors() {        TestParserOptions parserOptions = new TestParserOptions();        assertEquals(DEFAULT_LIST, parserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals(DEFAULT_STRING, parserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    @Test    public void testOverriddenPropertyDescriptors() {        TestParserOptions parserOptions = new TestParserOptions();        parserOptions.setProperty(TestParserOptions.LIST_DESCRIPTOR, OVERRIDDEN_LIST);        parserOptions.setProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        assertEquals(OVERRIDDEN_LIST, parserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals(OVERRIDDEN_STRING, parserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    @Test    public void testEnvOverriddenPropertyDescriptors() {        TestParserOptions parserOptions = new TestParserOptions() {            @Override            protected String getEnvValue(PropertyDescriptor<?> propertyDescriptor) {                if (propertyDescriptor.equals(TestParserOptions.LIST_DESCRIPTOR)) {                    return StringUtils.join(OVERRIDDEN_LIST, ",");                } else if (propertyDescriptor.equals(TestParserOptions.STRING_DESCRIPTOR)) {                    return OVERRIDDEN_STRING;                } else {                    throw new RuntimeException("Should not happen");                }            }        };        assertEquals(OVERRIDDEN_LIST, parserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals(OVERRIDDEN_STRING, parserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    @Test    public void testEmptyPropertyDescriptors() {        TestParserOptions vfParserOptions = new TestParserOptions() {            @Override            protected String getEnvValue(PropertyDescriptor<?> propertyDescriptor) {                if (propertyDescriptor.equals(TestParserOptions.LIST_DESCRIPTOR)                        || propertyDescriptor.equals(TestParserOptions.STRING_DESCRIPTOR)) {                    return "";                } else {                    throw new RuntimeException("Should not happen");                }            }        };        assertEquals(Collections.emptyList(), vfParserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals("", vfParserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    /**     * Verify that the equals and hashCode methods work as expected.     * TODO: Consider using Guava's EqualsTester     */    @Test    public void testSuppressMarkerEqualsHashCode() {        ParserOptions options1;        ParserOptions options2;        ParserOptions options3;        ParserOptions options4;        // SuppressMarker        options1 = new ParserOptions();        options2 = new ParserOptions();        options3 = new ParserOptions();        options4 = new ParserOptions();        options1.setSuppressMarker("foo");        options2.setSuppressMarker("bar");        options3.setSuppressMarker("foo");        options4.setSuppressMarker("bar");        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // PropertyDescriptor        options1 = new ParserOptions();        options2 = new ParserOptions();        options3 = new ParserOptions();        options4 = new ParserOptions();        options1.defineProperty(TestParserOptions.LIST_DESCRIPTOR);        options2.defineProperty(TestParserOptions.STRING_DESCRIPTOR);        options3.defineProperty(TestParserOptions.LIST_DESCRIPTOR);        options4.defineProperty(TestParserOptions.STRING_DESCRIPTOR);        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // PropertyValue        options1 = new ParserOptions();        options2 = new ParserOptions();        options3 = new ParserOptions();        options4 = new ParserOptions();        options1.defineProperty(TestParserOptions.STRING_DESCRIPTOR, DEFAULT_STRING);        options2.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        options3.defineProperty(TestParserOptions.STRING_DESCRIPTOR, DEFAULT_STRING);        options4.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // Language        options1 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options2 = new ParserOptions();        options3 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options4 = new ParserOptions();        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // SuppressMarker, PropertyDescriptor, PropertyValue, Language        options1 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options2 = new ParserOptions();        options3 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options4 = new ParserOptions();        options1.setSuppressMarker("foo");        options2.setSuppressMarker("bar");        options3.setSuppressMarker("foo");        options4.setSuppressMarker("bar");        options1.defineProperty(TestParserOptions.LIST_DESCRIPTOR, DEFAULT_LIST);        options2.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        options3.defineProperty(TestParserOptions.LIST_DESCRIPTOR, DEFAULT_LIST);        options4.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        assertFalse(options1.equals(null));    }    @Test    public void testGetEnvironmentVariableName() {        ParserOptions parserOptions = new TestParserOptions();        assertEquals("PMD_DUMMY_LISTOFSTRINGVALUES",                parserOptions.getEnvironmentVariableName(TestParserOptions.LIST_DESCRIPTOR));        assertEquals("PMD_DUMMY_STRINGVALUE",                parserOptions.getEnvironmentVariableName(TestParserOptions.STRING_DESCRIPTOR));    }    @Test(expected = IllegalStateException.class)    public void testGetEnvironmentVariableNameThrowsExceptionIfLanguageIsNull() {        ParserOptions parserOptions = new ParserOptions();        parserOptions.getEnvironmentVariableName(TestParserOptions.LIST_DESCRIPTOR);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class KotlinTokenizerTest extends CpdTextComparisonTest {    public KotlinTokenizerTest() {        super(".kt");    }    @Override    protected String getResourcePrefix() {        return "../lang/kotlin/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new KotlinTokenizer();    }    @Test    public void testComments() {        doTest("comment");    }    @Test    public void testIncrement() {        doTest("increment");    }    @Test    public void testImportsIgnored() {        doTest("imports");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import java.util.List;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.rule.AbstractJUnitRule;public class TestClassWithoutTestCasesRule extends AbstractJUnitRule {    @Override    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {        if (node.isAbstract() || node.isInterface() || node.isNested()) {            return data;        }        List<ASTMethodDeclaration> m = node.findDescendantsOfType(ASTMethodDeclaration.class);        boolean testsFound = false;        if (m != null) {            for (ASTMethodDeclaration md : m) {                if (isJUnitMethod(md, data)) {                    testsFound = true;                    break;                }            }        }        if (!testsFound) {            addViolation(data, node);        }        return data;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.coverage;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.fail;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.StringUtils;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardErrorStreamLog;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.PMD;public class PMDCoverageTest {    @Rule    public StandardOutputStreamLog output = new StandardOutputStreamLog();    @Rule    public StandardErrorStreamLog errorStream = new StandardErrorStreamLog();    @Rule    public TemporaryFolder folder = new TemporaryFolder();    /**     * Test some of the PMD command line options     */    @Test    public void testPmdOptions() {        runPmd("-d src/main/java/net/sourceforge/pmd/lang/java/rule/design -f text -R rulesets/internal/all-java.xml -language java -stress -benchmark");    }    /**     * Run the PMD command line tool, i.e. call PMD.main().     *     * @param commandLine     */    private void runPmd(String commandLine) {        String[] args = commandLine.split("\\s");        try {            File f = folder.newFile();            args = ArrayUtils.addAll(                args,                "-reportfile",                f.getAbsolutePath(),                "-threads",                String.valueOf(Runtime.getRuntime().availableProcessors())            );            PMD.runPmd(args);            assertEquals("Nothing should be output to stdout", 0, output.getLog().length());            assertEquals("No exceptions expected", 0, StringUtils.countMatches(errorStream.getLog(), "Exception applying rule"));            assertFalse("Wrong configuration? Ruleset not found", errorStream.getLog().contains("Ruleset not found"));            assertEquals("No usage of deprecated XPath attributes expected", 0, StringUtils.countMatches(errorStream.getLog(), "Use of deprecated attribute"));            String report = FileUtils.readFileToString(f, StandardCharsets.UTF_8);            assertEquals("No processing errors expected", 0, StringUtils.countMatches(report, "Error while processing"));            // we might have explicit examples of parsing errors, so these are maybe false positives            assertEquals("No parsing error expected", 0, StringUtils.countMatches(report, "Error while parsing"));        } catch (IOException ioe) {            fail("Problem creating temporary file: " + ioe.getLocalizedMessage());        }    }    @Test    public void runAllJavaPmdOnSourceTree() {        runPmd("-d src/main/java -f text -R rulesets/internal/all-java.xml -language java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics.impl;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clément Fournier */public class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/java/metrics_test.xml";    @Override    public void setUp() {        addRule(RULESET, "CognitiveComplexityTest");        addRule(RULESET, "CycloTest");        addRule(RULESET, "NcssTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "LocTest");        addRule(RULESET, "NPathTest");        addRule(RULESET, "NopaTest");        addRule(RULESET, "NoamTest");        addRule(RULESET, "WocTest");        addRule(RULESET, "TccTest");        addRule(RULESET, "AtfdTest");        addRule(RULESET, "CfoTest");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics.xpath;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.StringReader;import java.util.Iterator;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.xpath.MetricFunction;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;/** * @author Clément Fournier * @since 6.0.0 */public class XPathMetricFunctionTest {    // TODO 7.0 when removing jaxen these tests need to be updated to use pmd-java:metric    private static final String VIOLATION_MESSAGE = "violation";    @org.junit.Rule    public ExpectedException expected = ExpectedException.none();    private Rule makeXpathRuleFromXPath(String xpath) {        XPathRule rule = new XPathRule(XPathVersion.XPATH_1_0, xpath);        rule.setMessage(VIOLATION_MESSAGE);        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        return rule;    }    private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFile(new File("n/a"));        ctx.setIgnoreExceptions(false); // for test, we want immediate exceptions thrown and not collect them        RuleSet rules = RuleSet.forSingleRule(rule);        p.getSourceCodeProcessor().processSourceCode(new StringReader(code), new RuleSets(rules), ctx);        return report.iterator();    }    @Test    public void testWellFormedClassMetricRule() throws PMDException {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[metric('NCSS') > 0]");        final String code = "class Foo { Foo() {} void bar() {}}";        Iterator<RuleViolation> violations = getViolations(rule, code);        assertTrue(violations.hasNext());    }    @Test    public void testWellFormedOperationMetricRule() throws PMDException {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[metric('CYCLO') > 1]");        final String code = "class Goo { Goo() {if(true){}} }";        Iterator<RuleViolation> violations = getViolations(rule, code);        assertTrue(violations.hasNext());    }    @Test    public void testBadCase() throws PMDException {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[metric('cYclo') > 1]");        final String code = "class Hoo { Hoo() {if(true){}} }";        Iterator<RuleViolation> violations = getViolations(rule, code);        assertTrue(violations.hasNext());    }    @Test    public void testNonexistentMetric() throws Exception {        testWithExpectedException("//ConstructorDeclaration[metric('FOOBAR') > 1]",                                  "class Joo { Joo() {if(true){}} }",                                  IllegalArgumentException.class,                                  MetricFunction.badOperationMetricKeyMessage());    }    @Test    public void testWrongNodeTypeGeneric() throws Exception {        testWithExpectedException("//IfStatement[metric('NCSS') > 1]",                                  "class Koo { Koo() {if(true){}} }",                                  IllegalStateException.class,                                  MetricFunction.genericBadNodeMessage());    }    @Test    public void testWrongMetricKeyForTypeDeclaration() throws Exception {        testWithExpectedException("//EnumDeclaration[metric('CYCLO') > 1]",                                  "enum Loo { FOO; }",                                  IllegalArgumentException.class,                                  MetricFunction.badClassMetricKeyMessage());    }    @Test    public void testWrongMetricKeyForOperationDeclaration() throws Exception {        testWithExpectedException("//MethodDeclaration[metric('WMC') > 1]",                                  "class Moo { void foo() {if(true){}} }",                                  IllegalArgumentException.class,                                  MetricFunction.badOperationMetricKeyMessage());    }    private void testWithExpectedException(String xpath, String code,                                           Class<? extends Exception> expectedThrowable,                                           String expectedMessage) throws Exception {        Rule rule = makeXpathRuleFromXPath(xpath);        expected.expect(expectedThrowable);        expected.expectMessage(expectedMessage);        try {            getViolations(rule, code);        } catch (PMDException pmdE) {            throw (Exception) pmdE.getCause();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.metrics.api.JavaClassMetricKey;import net.sourceforge.pmd.lang.java.metrics.api.JavaOperationMetricKey;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricKeyUtil;import net.sourceforge.pmd.lang.metrics.MetricOption;import net.sourceforge.pmd.lang.metrics.MetricOptions;import net.sourceforge.pmd.lang.metrics.ParameterizedMetricKey;/** * @author Clément Fournier */public class ParameterizedMetricKeyTest {    private static final MetricOptions DUMMY_VERSION_1 = MetricOptions.ofOptions(Options.DUMMY1, Options.DUMMY2);    private static final MetricOptions DUMMY_VERSION_2 = MetricOptions.ofOptions(Options.DUMMY2);    @Test    public void testIdentity() {        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            assertEquals(key1, key2);            assertTrue(key1 == key2);        }        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            assertEquals(key1, key2);            assertTrue(key1 == key2);        }    }    @Test    public void testVersioning() {        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_2);            assertNotEquals(key1, key2);            assertFalse(key1 == key2);        }        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_2);            assertNotEquals(key1, key2);            assertFalse(key1 == key2);        }    }    @Test    public void testToString() {        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            assertTrue(key1.toString().contains(key1.key.name()));            assertTrue(key1.toString().contains(key1.options.toString()));        }    }    @Test    public void testAdHocMetricKey() {        MetricKey<ASTAnyTypeDeclaration> adHocKey = MetricKeyUtil.of("metric", null);        ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        assertNotNull(key1);        assertNotNull(key2);        assertTrue(key1 == key2);        assertEquals(key1, key2);        assertTrue(key1.toString().contains(key1.key.name()));        assertTrue(key1.toString().contains(key1.options.toString()));    }    private enum Options implements MetricOption {        DUMMY1,        DUMMY2;        @Override        public String valueName() {            return null;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorReducedAdapter;import net.sourceforge.pmd.lang.java.ast.MethodLikeNode;import net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaClassMetric;import net.sourceforge.pmd.lang.java.metrics.impl.AbstractJavaOperationMetric;import net.sourceforge.pmd.lang.java.metrics.testdata.MetricsVisitorTestData;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricKeyUtil;import net.sourceforge.pmd.lang.metrics.MetricOptions;import net.sourceforge.pmd.lang.metrics.MetricsUtil;/** * @author Clément Fournier */public class ProjectMemoizerTest extends BaseNonParserTest {    private MetricKey<ASTAnyTypeDeclaration> classMetricKey = MetricKeyUtil.of(null, new RandomClassMetric());    private MetricKey<MethodLikeNode> opMetricKey = MetricKeyUtil.of(null, new RandomOperationMetric());    @Test    public void memoizationTest() {        ASTCompilationUnit acu = java.parseClass(MetricsVisitorTestData.class);        List<Integer> expected = visitWith(acu, true);        List<Integer> real = visitWith(acu, false);        assertEquals(expected, real);    }    @Test    public void forceMemoizationTest() {        ASTCompilationUnit acu = java.parseClass(MetricsVisitorTestData.class);        List<Integer> reference = visitWith(acu, true);        List<Integer> real = visitWith(acu, true);        assertEquals(reference.size(), real.size());        // we force recomputation so each result should be different        for (int i = 0; i < reference.size(); i++) {            assertNotEquals(reference.get(i), real.get(i));        }    }    private List<Integer> visitWith(ASTCompilationUnit acu, final boolean force) {        final List<Integer> result = new ArrayList<>();        acu.jjtAccept(new JavaParserVisitorReducedAdapter() {            @Override            public Object visit(ASTMethodOrConstructorDeclaration node, Object data) {                if (opMetricKey.supports(node)) {                    result.add((int) MetricsUtil.computeMetric(opMetricKey, node, MetricOptions.emptyOptions(), force));                }                return super.visit(node, data);            }            @Override            public Object visit(ASTAnyTypeDeclaration node, Object data) {                if (classMetricKey.supports(node)) {                    result.add((int) MetricsUtil.computeMetric(classMetricKey, node, MetricOptions.emptyOptions(), force));                }                return super.visit(node, data);            }        }, null);        return result;    }    private class RandomOperationMetric extends AbstractJavaOperationMetric {        private Random random = new Random();        @Override        public double computeFor(MethodLikeNode node, MetricOptions options) {            return random.nextInt();        }    }    private class RandomClassMetric extends AbstractJavaClassMetric {        private Random random = new Random();        @Override        public double computeFor(ASTAnyTypeDeclaration node, MetricOptions options) {            return random.nextInt();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.metrics.SigMask;/** * @author Clément Fournier */public class SigMaskTest extends BaseNonParserTest {    private static final String TEST_FIELDS = "class Bzaz{"        + "public String x;"        + "private int y;"        + "protected String z;"        + "int s;"        + "public final int t;"        + "private final int a;"        + "protected final double u;"        + "final long v;"        + "static int aa;"        + "static final int ab;"        + "private static int ac;"        + "protected static final int ad;"        + "public static int ag;"        + "}";    private static final String TEST_OPERATIONS = "abstract class Bzaz{ "        + "int x;"        + "int y;"        + "int z;"        // constructors        + "public Bzaz() {}"        + "private Bzaz(int x){}"        + "protected Bzaz(int x, String y){}"        // static        + "public static void main(String[] args){}"        + "protected static void makeFoo(){}"        + "private static void makeBar(){}"        // getters and setters        + "public int getX(){return 2;}"        + "int getY(){return 0;}"        + "protected void setY(int y){}"        + "private void setX(int x){}"        // methods        + "public void foo(){} "        + "void bar(){} "        + "protected void foo(int x){} "        + "private void rand(){}"        // abstract        + "protected abstract int getZ();"        + "abstract int abs2();"        + "public static abstract String abstr();"        + "abstract void setZ(int x);"        + "}";    /**     * Ensure any non-abstract method is covered by a newly created mask.     */    @Test    public void testEmptyOperationMask() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        SigMask<JavaOperationSignature> mask = new JavaOperationSigMask();        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isAbstract()) {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }    /**     * Ensure any field is covered by a newly created mask.     */    @Test    public void testEmptyFieldMask() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        SigMask<JavaFieldSignature> mask = new JavaFieldSigMask();        for (ASTFieldDeclaration node : nodes) {            assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));        }    }    @Test    public void testFinalFields() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.forbidFinal();        for (ASTFieldDeclaration node : nodes) {            if (node.isFinal()) {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testStaticFields() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.forbidStatic();        for (ASTFieldDeclaration node : nodes) {            if (node.isStatic()) {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testFieldvisibility() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.restrictVisibilitiesTo(Visibility.PUBLIC);        for (ASTFieldDeclaration node : nodes) {            if (node.isPublic()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PRIVATE);        for (ASTFieldDeclaration node : nodes) {            if (node.isPrivate()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PACKAGE);        for (ASTFieldDeclaration node : nodes) {            if (node.isPackagePrivate()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PROTECTED);        for (ASTFieldDeclaration node : nodes) {            if (node.isProtected()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testOperationVisibility() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        JavaOperationSigMask mask = new JavaOperationSigMask();        mask.coverAbstract();        mask.restrictVisibilitiesTo(Visibility.PUBLIC);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPublic()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PRIVATE);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPrivate()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PACKAGE);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPackagePrivate()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PROTECTED);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isProtected()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }    @Test    public void testOperationRoles() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        JavaOperationSigMask mask = new JavaOperationSigMask();        mask.restrictRolesTo(Role.STATIC);        mask.coverAbstract();        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isStatic()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.CONSTRUCTOR);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTConstructorDeclaration) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.GETTER_OR_SETTER);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTMethodDeclaration                && ((ASTMethodDeclaration) node).getName().matches("(get|set).*")) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.METHOD);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTMethodDeclaration                && !node.isStatic()                && !((ASTMethodDeclaration) node).getName().matches("(get|set).*")) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertTrue;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.MethodLikeNode;import net.sourceforge.pmd.lang.java.metrics.api.JavaClassMetricKey;import net.sourceforge.pmd.lang.java.metrics.api.JavaOperationMetricKey;import net.sourceforge.pmd.lang.metrics.LanguageMetricsProvider;import net.sourceforge.pmd.lang.metrics.MetricKey;/** * @author Clément Fournier */public class JavaMetricsProviderTest {    private final JavaParsingHelper java8 = JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("1.8");    @Test    public void testComputeAllMetrics() {        LanguageMetricsProvider<?, ?> provider = java8.getHandler("1.8").getLanguageMetricsProvider();        ASTCompilationUnit acu = java8.parse("class Foo { void bar() { System.out.println(1); } }");        ASTAnyTypeDeclaration type = acu.getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> results = provider.computeAllMetricsFor(type);        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            assertTrue(results.containsKey(key));        }        MethodLikeNode op = acu.getFirstDescendantOfType(MethodLikeNode.class);        Map<MetricKey<?>, Double> opResults = provider.computeAllMetricsFor(op);        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            assertTrue(opResults.containsKey(key));        }    }    @Test    public void testThereIsNoMemoisation() {        LanguageMetricsProvider<?, ?> provider = java8.getHandler("1.8").getLanguageMetricsProvider();        ASTAnyTypeDeclaration tdecl1 = java8.parse("class Foo { void bar() { System.out.println(1); } }")                                            .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> reference = provider.computeAllMetricsFor(tdecl1);        // same name, different characteristics        ASTAnyTypeDeclaration tdecl2 = java8.parse("class Foo { void bar(){} \npublic void hey() { System.out.println(1); } }")                                            .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> secondTest = provider.computeAllMetricsFor(tdecl2);        assertNotEquals(reference, secondTest);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;import net.sourceforge.pmd.lang.java.metrics.testdata.GetterDetection;import net.sourceforge.pmd.lang.java.metrics.testdata.SetterDetection;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;/** * Test class for {@link JavaSignature} and its subclasses. * * @author Clément Fournier */public class SignatureTest extends BaseNonParserTest {    // common to operation and field signatures    @Test    public void visibilityTest() {        final String TEST = "class Bzaz{ "            + "public int bar;"            + "String k;"            + "protected double d;"            + "private int i;"            + "protected int x;"            + "public Bzaz(){} "            + "void bar(){} "            + "protected void foo(int x){}"            + "private Bzaz(int y){}"            + "}";        List<ASTMethodOrConstructorDeclaration> operationDeclarations = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<ASTFieldDeclaration> fieldDeclarations = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : operationDeclarations) {            sigs.add(JavaOperationSignature.buildFor(node));        }        // operations        assertEquals(Visibility.PUBLIC, sigs.get(0).visibility);        assertEquals(Visibility.PACKAGE, sigs.get(1).visibility);        assertEquals(Visibility.PROTECTED, sigs.get(2).visibility);        assertEquals(Visibility.PRIVATE, sigs.get(3).visibility);        sigs.clear();        for (ASTFieldDeclaration node : fieldDeclarations) {            sigs.add(JavaFieldSignature.buildFor(node));        }        // fields        assertEquals(Visibility.PUBLIC, sigs.get(0).visibility);        assertEquals(Visibility.PACKAGE, sigs.get(1).visibility);        assertEquals(Visibility.PROTECTED, sigs.get(2).visibility);        assertEquals(Visibility.PRIVATE, sigs.get(3).visibility);    }    @Test    public void operationRoleTest() {        final String TEST = "class Bzaz{ int x; "            + "public static void foo(){} "            + "Bzaz(){} "            + "int getX(){return x;}"            + " void setX(int a){x=a;}"            + " public void doSomething(){}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<JavaOperationSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : nodes) {            sigs.add(JavaOperationSignature.buildFor(node));        }        assertEquals(Role.STATIC, sigs.get(0).role);        assertEquals(Role.CONSTRUCTOR, sigs.get(1).role);        assertEquals(Role.GETTER_OR_SETTER, sigs.get(2).role);        assertEquals(Role.GETTER_OR_SETTER, sigs.get(3).role);        assertEquals(Role.METHOD, sigs.get(4).role);    }    @Test    public void testGetterDetection() {        ASTCompilationUnit compilationUnit = JavaParsingHelper.WITH_PROCESSING.parseClass(GetterDetection.class);        compilationUnit.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertEquals(Role.GETTER_OR_SETTER, Role.get(node));                return data;            }        }, null);    }    @Test    public void testSetterDetection() {        ASTCompilationUnit compilationUnit = JavaParsingHelper.WITH_PROCESSING.parseClass(SetterDetection.class);        compilationUnit.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertEquals(Role.GETTER_OR_SETTER, Role.get(node));                return data;            }        }, null);    }    @Test    public void isAbstractOperationTest() {        final String TEST = "abstract class Bzaz{ int x; "            + "public static abstract void foo();"            + "protected abstract int bar(int x);"            + "int getX(){return x;}"            + "void setX(int a){x=a;}"            + "public void doSomething(){}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<JavaOperationSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : nodes) {            sigs.add(JavaOperationSignature.buildFor(node));        }        assertTrue(sigs.get(0).isAbstract);        assertTrue(sigs.get(1).isAbstract);        assertFalse(sigs.get(2).isAbstract);        assertFalse(sigs.get(3).isAbstract);        assertFalse(sigs.get(4).isAbstract);    }    @Test    public void isFinalFieldTest() {        final String TEST = "class Bzaz{"            + "public String x;"            + "private int y;"            + "private final int a;"            + "protected final double u;"            + "final long v;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaFieldSignature> sigs = new ArrayList<>();        for (ASTFieldDeclaration node : nodes) {            sigs.add(JavaFieldSignature.buildFor(node));        }        assertFalse(sigs.get(0).isFinal);        assertFalse(sigs.get(1).isFinal);        assertTrue(sigs.get(2).isFinal);        assertTrue(sigs.get(3).isFinal);        assertTrue(sigs.get(4).isFinal);    }    @Test    public void isStaticFieldTest() {        final String TEST = "class Bzaz{"            + "public final String x;"            + "private int y;"            + "private static int a;"            + "protected static final double u;"            + "static long v;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaFieldSignature> sigs = new ArrayList<>();        for (ASTFieldDeclaration node : nodes) {            sigs.add(JavaFieldSignature.buildFor(node));        }        assertFalse(sigs.get(0).isStatic);        assertFalse(sigs.get(1).isStatic);        assertTrue(sigs.get(2).isStatic);        assertTrue(sigs.get(3).isStatic);        assertTrue(sigs.get(4).isStatic);    }    // Ensure only one instance of a signature is created.    @Test    public void operationPoolTest() {        final String TEST = "class Bzaz{ "            + "public static void foo(){} "            + "public static void az(){} "            + "public static int getX(){return x;}}";        final String TEST2 = "class Bzaz{ "            + "void foo(){} "            + "void az(){} "            + "int rand(){return x;}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<ASTMethodOrConstructorDeclaration> nodes2 = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST2);        List<JavaOperationSignature> sigs = new ArrayList<>();        List<JavaOperationSignature> sigs2 = new ArrayList<>();        for (int i = 0; i < sigs.size(); i++) {            sigs.add(JavaOperationSignature.buildFor(nodes.get(i)));            sigs2.add(JavaOperationSignature.buildFor(nodes2.get(i)));        }        for (int i = 0; i < sigs.size() - 1; i++) {            assertTrue(sigs.get(i) == sigs.get(i + 1));            assertTrue(sigs2.get(i) == sigs2.get(i + 1));        }    }    // Ensure only one instance of a signature is created.    @Test    public void fieldPoolTest() {        final String TEST = "class Bzaz {"            + "public int bar;"            + "public String k;"            + "public double d;"            + "}";        final String TEST2 = "class Foo {"            + "private final int i;"            + "private final int x;"            + "private final String k;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<ASTFieldDeclaration> nodes2 = getOrderedNodes(ASTFieldDeclaration.class, TEST2);        List<JavaFieldSignature> sigs = new ArrayList<>();        List<JavaFieldSignature> sigs2 = new ArrayList<>();        for (int i = 0; i < nodes.size(); i++) {            sigs.add(JavaFieldSignature.buildFor(nodes.get(i)));            sigs2.add(JavaFieldSignature.buildFor(nodes2.get(i)));        }        for (int i = 0; i < nodes.size() - 1; i++) {            assertTrue(sigs.get(i) == sigs.get(i + 1));            assertTrue(sigs2.get(i) == sigs2.get(i + 1));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.dfa.Structure;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;public class StructureTest {    @Test    public void testAddResultsinDFANodeContainingAddedNode() {        Structure s = new Structure(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getDataFlowHandler());        Node n = new ASTMethodDeclaration(1);        assertEquals(n, s.createNewNode(n).getNode());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(StructureTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.LinkedList;import org.junit.Test;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.dfa.NodeType;import net.sourceforge.pmd.lang.dfa.StartOrEndDataFlowNode;public class DataFlowNodeTest {    @Test    public void testAddPathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        parent.addPathToChild(child);        assertEquals(parent.getChildren().size(), 1);        assertTrue(child.getParents().contains(parent));        assertTrue(parent.getChildren().contains(child));    }    @Test    public void testRemovePathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        parent.addPathToChild(child);        assertTrue(parent.removePathToChild(child));        assertFalse(child.getParents().contains(parent));        assertFalse(parent.getChildren().contains(child));    }    @Test    public void testRemovePathWithNonChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        assertFalse(parent.removePathToChild(child));    }    @Test    public void testReverseParentPathsTo() {        DataFlowNode parent1 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode parent2 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        DataFlowNode child1 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 13, false);        DataFlowNode child2 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 13, false);        parent1.addPathToChild(child1);        parent2.addPathToChild(child1);        assertTrue(parent1.getChildren().contains(child1));        child1.reverseParentPathsTo(child2);        assertTrue(parent1.getChildren().contains(child2));        assertFalse(parent1.getChildren().contains(child1));        assertTrue(parent2.getChildren().contains(child2));        assertFalse(parent2.getChildren().contains(child1));        assertEquals(0, child1.getParents().size());        assertEquals(2, child2.getParents().size());    }    @Test    public void testSetType() {        DataFlowNode node = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        node.setType(NodeType.BREAK_STATEMENT);        assertTrue(node.isType(NodeType.BREAK_STATEMENT));        assertFalse(node.isType(NodeType.CASE_LAST_STATEMENT));    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(DataFlowNodeTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.lang.dfa.VariableAccess;public class VariableAccessTest {    @Test    public void testGetVariableName() {        VariableAccess va = new VariableAccess(VariableAccess.DEFINITION, "foo.bar");        assertEquals("foo", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, ".foobar");        assertEquals("", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar.");        assertEquals("foobar", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar");        assertEquals("foobar", va.getVariableName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.dfa.pathfinder.CurrentPath;import net.sourceforge.pmd.lang.dfa.pathfinder.DAAPathFinder;import net.sourceforge.pmd.lang.dfa.pathfinder.Executable;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;public class DAAPathFinderTest {    @Test    public void testTwoUpdateDefs() {        ASTMethodDeclarator meth = JavaParsingHelper.WITH_PROCESSING.getNodes(ASTMethodDeclarator.class, TWO_UPDATE_DEFS).get(0);        DAAPathFinder a = new DAAPathFinder(meth.getDataFlowNode().getFlow().get(0), new Executable() {            @Override            public void execute(CurrentPath path) {            }        });        // a.run();    }    private static final String TWO_UPDATE_DEFS = "class Foo {" + PMD.EOL + " void bar(int x) {" + PMD.EOL            + "  for (int i=0; i<10; i++, j--) {}" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.dfa.NodeType;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class StatementAndBraceFinderTest extends BaseNonParserTest {    @Test    public void testStatementExpressionParentChildLinks() {        ASTStatementExpression se = getOrderedNodes(ASTStatementExpression.class, TEST1).get(0);        ASTMethodDeclaration seParent = (ASTMethodDeclaration) se.getDataFlowNode().getParents().get(0).getNode();        assertEquals(se, seParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(seParent, se.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testVariableDeclaratorParentChildLinks() {        ASTVariableDeclarator vd = getOrderedNodes(ASTVariableDeclarator.class, TEST2).get(0);        ASTMethodDeclaration vdParent = (ASTMethodDeclaration) vd.getDataFlowNode().getParents().get(0).getNode();        assertEquals(vd, vdParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(vdParent, vd.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testIfStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST3).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.IF_EXPR));        assertTrue(dfn.isType(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE));    }    @Test    public void testWhileStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST4).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.WHILE_EXPR));        assertTrue(dfn.isType(NodeType.WHILE_LAST_STATEMENT));    }    @Test    public void testForStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST5).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.FOR_INIT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.FOR_EXPR));        dfn = exp.getDataFlowNode().getFlow().get(4);        assertTrue(dfn.isType(NodeType.FOR_UPDATE));        assertTrue(dfn.isType(NodeType.FOR_BEFORE_FIRST_STATEMENT));        assertTrue(dfn.isType(NodeType.FOR_END));    }    @Test(expected = RuntimeException.class)    public void testOnlyWorksForMethodsAndConstructors() {        StatementAndBraceFinder sbf = new StatementAndBraceFinder(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler().getDataFlowHandler());        sbf.buildDataFlowFor(new ASTMethodDeclaration(1));        sbf.buildDataFlowFor(new ASTConstructorDeclaration(1));        sbf.buildDataFlowFor(new ASTCompilationUnit(1));    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST2 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x;" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST3 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  if (x) {}" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  while (x) {}" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST5 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL            + "  for (int i=0; i<10; i++) {}" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class GeneralFiddlingTest extends BaseNonParserTest {    /**     * Unit test for https://sourceforge.net/p/pmd/bugs/1325/     */    @Test    public void innerClassShouldWork() {        ASTCompilationUnit acu = java.parse(                "class Foo {" + "    void bar() {" + "        class X {}" + "        int i;" + "    }" + "}");        assertNotNull(acu);    }    @Test    public void test1() {        ASTCompilationUnit acu = java.parse(TEST1);        ASTMethodDeclarator meth = acu.findDescendantsOfType(ASTMethodDeclarator.class).get(0);        DataFlowNode n = meth.getDataFlowNode();        List<DataFlowNode> f = n.getFlow();        assertEquals(6, f.size());        assertEquals("Undefinition(x)", String.valueOf(f.get(0).getVariableAccess().get(0)));        assertEquals(0, f.get(1).getVariableAccess().size());        assertEquals("Definition(x)", String.valueOf(f.get(2).getVariableAccess().get(0)));        assertEquals("Reference(x)", String.valueOf(f.get(3).getVariableAccess().get(0)));        assertEquals("Definition(x)", String.valueOf(f.get(4).getVariableAccess().get(0)));        assertEquals("Undefinition(x)", String.valueOf(f.get(5).getVariableAccess().get(0)));        // for (DataFlowNode dfan : f) {        // System.out.println("Flow starting on line " + dfan.getLine());        // List<VariableAccess> va = dfan.getVariableAccess();        // for (VariableAccess o : va) {        // System.out.println(" variable: " + o);        // }        // }    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x = 2;" + PMD.EOL            + "  foo(x);" + PMD.EOL + "  x = 3;" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;/* * Created on 18.08.2004 */public class AcceptanceTest extends BaseNonParserTest {    @Test    public void testbook() {        getOrderedNodes(ASTMethodDeclarator.class, FOO);    }    private static final String FOO = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    @Test    public void testLabelledBreakLockup() {        getOrderedNodes(ASTMethodDeclarator.class, LABELLED_BREAK_LOCKUP);    }    private static final String LABELLED_BREAK_LOCKUP = "class Foo {" + PMD.EOL + " void bar(int x) {" + PMD.EOL            + "  here: if (x>2) {" + PMD.EOL + "   break here;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + "}";    private boolean check(int[][] array, List<ASTMethodDeclarator> methodNodes) {        for (int i = 0; i < methodNodes.size(); i++) {            ASTMethodDeclarator decl = methodNodes.get(i);            DataFlowNode inode = decl.getDataFlowNode();            for (int j = 0; j < inode.getChildren().size(); j++) {                DataFlowNode child = inode.getChildren().get(j);                if (array[i][j] != child.getIndex() - 1) {                    return false;                }            }        }        return true;    }    @Test    public void test1() {        assertTrue(check(TEST1_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST1)));    }    @Test    public void test2() {        assertTrue(check(TEST2_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST2)));    }    @Test    public void test3() {        assertTrue(check(TEST3_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST3)));    }    @Test    public void test4() {        assertTrue(check(TEST4_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST4)));    }    @Test    public void test6() {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST6)));    }    @Test    public void test7() {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST7)));    }    @Test    public void test8() {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST8)));    }    @Test    public void test9() {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST9)));    }    @Test    public void test10() {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST10)));    }    @Test    public void test11() {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST11)));    }    @Test    public void test12() {        assertTrue(check(TEST12_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST12)));    }    @Test    public void test13() {        assertTrue(check(TEST13_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST13)));    }    @Test    public void test14() {        assertTrue(check(TEST14_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST14)));    }    @Test    public void test15() {        assertTrue(check(TEST15_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST15)));    }    @Test    public void test16() {        assertTrue(check(TEST16_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST16)));    }    @Test    public void test17() {        assertTrue(check(TEST17_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST17)));    }    @Test    public void test18() {        assertTrue(check(TEST18_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST18)));    }    @Test    public void test19() {        assertTrue(check(TEST19_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST19)));    }    @Test    public void test20() {        assertTrue(check(TEST20_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST20)));    }    @Test    public void test21() {        assertTrue(check(TEST21_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST21)));    }    @Test    public void test22() {        assertTrue(check(TEST22_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST22)));    }    @Test    public void test23() {        assertTrue(check(TEST23_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST23)));    }    @Test    public void test24() {        assertTrue(check(TEST24_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST24)));    }    @Test    public void test25() {        assertTrue(check(TEST25_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST25)));    }    @Test    public void test26() {        assertTrue(check(TEST26_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST26)));    }    @Test    public void test27() {        assertTrue(check(TEST27_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST27)));    }    @Test    public void test28() {        assertTrue(check(TEST28_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST28)));    }    @Test    public void test29() {        assertTrue(check(TEST29_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST29)));    }    @Test    public void test30() {        assertTrue(check(TEST30_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST30)));    }    // first dimension: the index of a node    // second dimension: the indices of the children    private static final int[][] TEST1_NODES = { { 1, }, { 2, }, { 3, }, { 4, 6, }, { 5, }, { 6, }, {}, };    private static final String TEST1 = "class Foo {" + PMD.EOL + " void test_1() {" + PMD.EOL + "  int x = 0;"            + PMD.EOL + "  if (x == 0) {" + PMD.EOL + "   x++;" + PMD.EOL + "   x = 0;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + " }";    private static final int[][] TEST2_NODES = { { 1, }, { 2, }, { 3, }, { 5, 7, }, { 3, }, { 6, }, { 4, }, {}, };    private static final String TEST2 = "class Foo {" + PMD.EOL + " public void test_2() {" + PMD.EOL            + "  for (int i = 0; i < 1; i++) {" + PMD.EOL + "   i++;" + PMD.EOL + "   i = 8;" + PMD.EOL + "  }"            + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST3_NODES = { { 1, }, { 2, }, { 3, }, { 4, 5, }, { 3, }, {}, };    private static final String TEST3 = "public class Foo {" + PMD.EOL + " public void test_3() {" + PMD.EOL            + "  for (int i = 0; i < 1; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST4_NODES = { { 1, }, { 2, }, { 3, }, {}, };    private static final String TEST4 = "public class Foo {" + PMD.EOL + " public void test_4() {" + PMD.EOL            + "  for (; ;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST5_NODES = { { 1, }, { 2, }, { 3, }, { 4, }, {}, };    private static final String TEST6 = "public class Foo {" + PMD.EOL + " public void test_6() {" + PMD.EOL            + "  for (int i = 0; ;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final String TEST7 = "public class Foo {" + PMD.EOL + " public void test_7() {" + PMD.EOL            + "  for (int i = 0; i < 0;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST8_NODES = { { 1, }, { 2, }, { 3, }, { 4, 5, }, { 3, }, {}, };    public static final String TEST8 = "public class Foo {" + PMD.EOL + " public void test_8() {" + PMD.EOL            + "  for (int i = 0; ; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    public static final String TEST9 = "public class Foo {" + PMD.EOL + " public void test_9() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  for (; i < 0;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    public static final String TEST10 = "public class Foo {" + PMD.EOL + " public void test_10() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  for (; i < 0; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    public static final String TEST11 = "public class Foo {" + PMD.EOL + " public void test_11() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  for (; ; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST12_NODES = { { 1, }, { 2, }, { 3, }, { 4, 5, }, { 3, }, {}, };    public static final String TEST12 = "public class Foo {" + PMD.EOL + " public void test_12() {" + PMD.EOL            + "  for (; ;) {" + PMD.EOL + "   int i = 0;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST13_NODES = { { 1, }, { 2, }, { 3, }, { 5, 9, }, { 3, }, { 6, }, { 7, 8, }, { 8, }, { 4, },        {}, };    public static final String TEST13 = "public class Foo {" + PMD.EOL + " public void test_13() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   i = 9;" + PMD.EOL + "   if (i < 8) {" + PMD.EOL            + "    i = 7;" + PMD.EOL + "   }" + PMD.EOL + "   i = 6;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + " }";    private static final int[][] TEST14_NODES = { { 1 }, { 2 }, { 3 }, { 5, 8 }, { 3 }, { 6 }, { 7, 4 }, { 4 }, {} };    public static final String TEST14 = "public class Foo {" + PMD.EOL + " public void test_14() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   i = 9;" + PMD.EOL + "   if (i < 8) {" + PMD.EOL            + "    i = 7;" + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST15_NODES = { { 1 }, { 2 }, { 3 }, { 5, 7 }, { 3 }, { 6, 4 }, { 4 }, {} };    public static final String TEST15 = "public class Foo {" + PMD.EOL + " public void test_15() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   if (i < 8) {" + PMD.EOL + "    i = 7;" + PMD.EOL            + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST16_NODES = { { 1 }, { 2 }, { 3 }, { 5, 8 }, { 3 }, { 6, 7 }, { 4 }, { 4 }, {} };    public static final String TEST16 = "public class Foo {" + PMD.EOL + " public void test_16() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   if (i < 8) {" + PMD.EOL + "    i = 7;" + PMD.EOL            + "   } else {" + PMD.EOL + "    i = 6;" + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + " }";    private static final int[][] TEST17_NODES = { { 1 }, { 2 }, { 3 }, { 5, 10 }, { 3 }, { 6, 7 }, { 4 }, { 8, 9 },        { 4 }, { 4 }, {}, };    public static final String TEST17 = "public class Foo {" + PMD.EOL + " public void test_17() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   if (i < 6) {" + PMD.EOL + "    i = 7;" + PMD.EOL            + "   } else if (i > 8) {" + PMD.EOL + "    i = 9;" + PMD.EOL + "   } else {" + PMD.EOL + "    i = 10;"            + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST18_NODES = { { 1 }, { 2 }, { 3 }, { 5, 9 }, { 3 }, { 6 }, { 8, 4 }, { 6 }, { 7 },        {}, };    public static final String TEST18 = "public class Foo {" + PMD.EOL + " public void test_18() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   for (int j = 0; j < 0; j++) {" + PMD.EOL + "    j++;"            + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST19_NODES = { { 1 }, { 2 }, { 3 }, { 4, 5 }, { 10 }, { 6, 7 }, { 10 }, { 8, 9 },        { 10 }, { 10 }, {}, };    public static final String TEST19 = "public class Foo {" + PMD.EOL + " public void test_19() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   i = 2;" + PMD.EOL + "  } else if (i == 3) {"            + PMD.EOL + "   i = 4;" + PMD.EOL + "  } else if (i == 5) {" + PMD.EOL + "   i = 6;" + PMD.EOL            + "  } else {" + PMD.EOL + "   i = 7;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST20_NODES = { { 1 }, { 2 }, { 3 }, { 4, 6 }, { 5, 7 }, { 7 }, { 7 }, {} };    public static final String TEST20 = "public class Foo {" + PMD.EOL + " public void test_20() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   if (i == 2) {" + PMD.EOL + "    i = 3;"            + PMD.EOL + "   }" + PMD.EOL + "  } else {" + PMD.EOL + "   i = 7;" + PMD.EOL + "  }" + PMD.EOL + " }"            + PMD.EOL + " }";    private static final int[][] TEST21_NODES = { { 1 }, { 2 }, { 3 }, { 4, 9 }, { 5 }, { 7, 8 }, { 5 }, { 6 }, { 11 },        { 10, 11 }, { 11 }, {}, };    public static final String TEST21 = "public class Foo {" + PMD.EOL + " public void test_21() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   for (i = 3; i < 4; i++) {" + PMD.EOL            + "    i = 5;" + PMD.EOL + "   }" + PMD.EOL + "   i++;" + PMD.EOL + "  } else if (i < 6) {" + PMD.EOL            + "   i = 7;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST22_NODES = { { 1 }, { 2 }, { 3 }, { 4, 8 }, { 5 }, { 7, 9 }, { 5 }, { 6 }, { 9 },        {}, };    public static final String TEST22 = "public class Foo {" + PMD.EOL + " public void test_22() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   for (i = 3; i < 4; i++) {" + PMD.EOL            + "    i = 5;" + PMD.EOL + "   }" + PMD.EOL + "  } else {" + PMD.EOL + "   i = 7;" + PMD.EOL + "  }"            + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST23_NODES = { { 1 }, { 2 }, { 3 }, { 4, 8 }, { 5 }, { 7, 10 }, { 5 }, { 6 },        { 9, 10 }, { 10 }, {}, };    public static final String TEST23 = "public class Foo {" + PMD.EOL + " public void test_23() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   for (i = 3; i < 4; i++) {" + PMD.EOL            + "    i = 5;" + PMD.EOL + "   }" + PMD.EOL + "  } else if (i < 6) {" + PMD.EOL + "   i = 7;" + PMD.EOL            + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST24_NODES = { { 1 }, { 2 }, { 3 }, { 4, 9 }, { 5 }, { 7, 11 }, { 5 }, { 8, 6 },        { 6 }, { 10, 11 }, { 11 }, {}, };    public static final String TEST24 = "public class Foo {" + PMD.EOL + " public void test_24() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  if (x > 2) {" + PMD.EOL + "   for (int i = 0; i < 1; i++) {" + PMD.EOL            + "    if (x > 3) {" + PMD.EOL + "     x++;" + PMD.EOL + "    }" + PMD.EOL + "   }" + PMD.EOL            + "  } else if (x > 4) {" + PMD.EOL + "   x++;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST25_NODES = { { 1 }, { 2 }, { 3 }, { 4, 5 }, { 5 }, {} };    public static final String TEST25 = "public class Foo {" + PMD.EOL + " public void test_25() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  switch (x) {" + PMD.EOL + "   default:" + PMD.EOL + "    x = 9;" + PMD.EOL            + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST26_NODES = { { 1 }, { 2 }, { 3 }, { 4 }, { 5, 6 }, { 6 }, { 7 }, { 8, 3 }, { 9 },        {}, };    public static final String TEST26 = "public class Foo {" + PMD.EOL + " public void test_26() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  do {" + PMD.EOL + "   if (x > 0) {" + PMD.EOL + "    x++;" + PMD.EOL            + "   }" + PMD.EOL + "   x++;" + PMD.EOL + "  } while (x < 9);" + PMD.EOL + "  x++;" + PMD.EOL + " }"            + PMD.EOL + " }";    private static final int[][] TEST27_NODES = { { 1 }, { 2 }, { 3 }, { 5, 9 }, { 3 }, { 6 }, { 7 }, { 8 }, { 6, 4 }, {}, };    public static final String TEST27 = "public class Foo {" + PMD.EOL + " public void test_27() {" + PMD.EOL            + "  for (int i = 0; i < 36; i++) {" + PMD.EOL + "   int x = 0;" + PMD.EOL + "   do {" + PMD.EOL            + "    x++;" + PMD.EOL + "   } while (x < 9);" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST28_NODES = { { 1 }, { 2 }, { 3 }, { 5, 14 }, { 3 }, { 6 }, { 7 }, { 8, 12 }, { 9 },        { 10, 12 }, { 11 }, { 12 }, { 13 }, { 6, 4 }, {}, };    public static final String TEST28 = "public class Foo {" + PMD.EOL + " private void test_28() {" + PMD.EOL            + "  for (int i = 0; i < 36; i++) {" + PMD.EOL + "   int x = 0;" + PMD.EOL + "   do {" + PMD.EOL            + "    if (x > 0) {" + PMD.EOL + "     x++;" + PMD.EOL + "     switch (i) {" + PMD.EOL + "      case 0:"            + PMD.EOL + "       x = 0;" + PMD.EOL + "       break;" + PMD.EOL + "     }" + PMD.EOL + "    }" + PMD.EOL            + "    x++;" + PMD.EOL + "   } while (x < 9);" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST29_NODES = { { 1 }, { 2 }, { 3, 4, 5 }, { 6 }, { 6 }, { 6 }, {}, };    public static final String TEST29 = "public class Foo {" + PMD.EOL + " private void test_29() {" + PMD.EOL            + "  switch(x) {" + PMD.EOL + "   case 1:" + PMD.EOL + "    break; " + PMD.EOL + "   default: " + PMD.EOL            + "    break;" + PMD.EOL + "   case 2:" + PMD.EOL + "    break;" + PMD.EOL + "  }" + PMD.EOL + " }"            + PMD.EOL + "}";    private static final int[][] TEST30_NODES = { { 1 }, { 2 }, { 3 }, { 4, 7 }, { 5, 6 }, { 4 }, { 3 }, {} };    public static final String TEST30 = "public class Foo {" + PMD.EOL + " private void test_30() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  while (true) {" + PMD.EOL + "   while (x>0) {" + PMD.EOL + "     x++;"            + PMD.EOL + "   }" + PMD.EOL + "   continue;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.multifile;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;import net.sourceforge.pmd.lang.java.ast.JavaQualifiedName;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.multifile.testdata.MultifileVisitorTestData2;import net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;import net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;/** * Tests of the multifile visitor. * * @author Clément Fournier */public class JavaMultifileVisitorTest extends BaseNonParserTest {    @Test    public void testPackageStatsNotNull() {        assertNotNull(PackageStats.INSTANCE);    }    @Before    public void resetMultifile() {        PackageStats.INSTANCE.reset();    }    @Test    public void testOperationsAreThere() {        ASTCompilationUnit acu = java.parseClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaOperationSigMask opMask = new JavaOperationSigMask();        // We could parse qnames from string but probably simpler to do that        acu.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertTrue(toplevel.hasMatchingSig(node.getQualifiedName(), opMask));                return data;            }        }, null);    }    @Test    public void testFieldsAreThere() {        java.parseClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaFieldSigMask fieldSigMask = new JavaFieldSigMask();        JavaTypeQualifiedName clazz = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        String[] fieldNames = {"x", "y", "z", "t"};        Visibility[] visibilities = {Visibility.PUBLIC, Visibility.PRIVATE, Visibility.PROTECTED, Visibility.PACKAGE};        for (int i = 0; i < fieldNames.length; i++) {            fieldSigMask.restrictVisibilitiesTo(visibilities[i]);            assertTrue(toplevel.hasMatchingSig(clazz, fieldNames[i], fieldSigMask));        }    }    @Test    public void testBothClassesOperationsAreThere() {        java.parseClass(MultifileVisitorTestData2.class);        java.parseClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaOperationSigMask operationSigMask = new JavaOperationSigMask();        JavaQualifiedName clazz = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        JavaQualifiedName clazz2 = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        String[] opNames = {"getX()", "getY()", "setX(String)", "setY(String)",                            "mymethod1()", "mymethod2()", "mystatic1()",                            "mystatic2(String)", "mystatic2(String, String)", };        Role[] roles = {Role.GETTER_OR_SETTER, Role.GETTER_OR_SETTER, Role.GETTER_OR_SETTER, Role.GETTER_OR_SETTER,                        Role.METHOD, Role.METHOD, Role.STATIC, Role.STATIC, Role.STATIC, };        for (int i = 0; i < opNames.length; i++) {            operationSigMask.restrictRolesTo(roles[i]);            JavaOperationQualifiedName name1 = (JavaOperationQualifiedName) QualifiedNameFactory.ofString(clazz.toString() + "#" + opNames[i]);            JavaOperationQualifiedName name2 = (JavaOperationQualifiedName) QualifiedNameFactory.ofString(clazz2.toString() + "#" + opNames[i]);            assertTrue(toplevel.hasMatchingSig(name1, operationSigMask));            assertTrue(toplevel.hasMatchingSig(name2, operationSigMask));        }    }    @Test    public void testBothClassesFieldsAreThere() {        java.parseClass(MultifileVisitorTestData2.class);        java.parseClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaFieldSigMask fieldSigMask = new JavaFieldSigMask();        JavaTypeQualifiedName clazz = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        JavaTypeQualifiedName clazz2 = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        String[] fieldNames = {"x", "y", "z", "t"};        Visibility[] visibilities = {Visibility.PUBLIC, Visibility.PRIVATE, Visibility.PROTECTED, Visibility.PACKAGE};        for (int i = 0; i < fieldNames.length; i++) {            fieldSigMask.restrictVisibilitiesTo(visibilities[i]);            assertTrue(toplevel.hasMatchingSig(clazz, fieldNames[i], fieldSigMask));            assertTrue(toplevel.hasMatchingSig(clazz2, fieldNames[i], fieldSigMask));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.multifile;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;import net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;/** * Tests functionality of PackageStats * * @author Clément Fournier */public class PackageStatsTest extends BaseNonParserTest {    private PackageStats pack;    @Before    public void setUp() {        pack = new PackageStats();    }    @Test    public void testAddClass() {        JavaTypeQualifiedName qname = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("org.foo.Boo");        assertNull(pack.getClassStats(qname, false));        assertNotNull(pack.getClassStats(qname, true));        // now it's added, this shouldn't return null        assertNotNull(pack.getClassStats(qname, false));    }    @Test    public void testAddOperation() {        final String TEST = "package org.foo; class Boo{ "            + "public void foo(){}}";        ASTMethodOrConstructorDeclaration node = java.getNodes(ASTMethodDeclaration.class, TEST).get(0);        JavaOperationQualifiedName qname = node.getQualifiedName();        JavaOperationSignature signature = JavaOperationSignature.buildFor(node);        assertFalse(pack.hasMatchingSig(qname, new JavaOperationSigMask()));        ClassStats clazz = pack.getClassStats(qname.getClassName(), true);        clazz.addOperation("foo()", signature);        assertTrue(pack.hasMatchingSig(qname, new JavaOperationSigMask()));    }    @Test    public void testAddField() {        final String TEST = "package org.foo; class Boo{ "            + "public String bar;}";        ASTFieldDeclaration node = java.getNodes(ASTFieldDeclaration.class, TEST).get(0);        JavaTypeQualifiedName qname = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("org.foo.Boo");        String fieldName = "bar";        JavaFieldSignature signature = JavaFieldSignature.buildFor(node);        assertFalse(pack.hasMatchingSig(qname, fieldName, new JavaFieldSigMask()));        ClassStats clazz = pack.getClassStats(qname, true);        clazz.addField(fieldName, signature);        assertTrue(pack.hasMatchingSig(qname, fieldName, new JavaFieldSigMask()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.multifile;import static org.junit.Assert.assertEquals;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.multifile.testdata.SignatureCountTestData;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;/** * @author Clément Fournier */public class ClassStatsTest {    @Before    public void resetMultifile() {        PackageStats.INSTANCE.reset();    }    @Test    @Ignore("Exception in typeresolution visit")    public void testCountOpSigs() {        JavaParsingHelper.WITH_PROCESSING.parseClass(SignatureCountTestData.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final ClassMirror classMirror = toplevel.getClassMirror(QualifiedNameFactory.ofClass(SignatureCountTestData.class));        final FluentOperationSigMask opSigMask = new FluentOperationSigMask();        opSigMask.mask.coverAbstract();        opSigMask.restrictRolesTo(Role.STATIC);        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(2, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));        assertEquals(2, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        opSigMask.restrictRolesTo(Role.METHOD).coverAllVisibilities();        assertEquals(6, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(1, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        assertEquals(1, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PROTECTED)));        assertEquals(2, classMirror.countMatchingOpSigs(opSigMask.forbidAbstract()));        opSigMask.restrictRolesTo(Role.GETTER_OR_SETTER).coverAllVisibilities();        assertEquals(8, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PACKAGE)));        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        opSigMask.restrictRolesTo(Role.CONSTRUCTOR).coverAllVisibilities();        assertEquals(3, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(3, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        FluentFieldSigMask fieldSigMask = new FluentFieldSigMask();        assertEquals(6, classMirror.countMatchingFieldSigs(fieldSigMask.mask));        assertEquals(3, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        assertEquals(1, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PROTECTED)));        assertEquals(2, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));        fieldSigMask.mask.forbidFinal();        assertEquals(0, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));    }    // Containers to clear up tests    private class FluentOperationSigMask {        JavaOperationSigMask mask = new JavaOperationSigMask();        JavaOperationSigMask forbidAbstract() {            mask.coverAbstract(false);            return mask;        }        JavaOperationSigMask restrictVisibilitiesTo(Visibility... visibilities) {            mask.restrictVisibilitiesTo(visibilities);            return mask;        }        JavaOperationSigMask restrictRolesTo(Role... roles) {            mask.restrictRolesTo(roles);            return mask;        }    }    private class FluentFieldSigMask {        JavaFieldSigMask mask = new JavaFieldSigMask();        JavaFieldSigMask restrictVisibilitiesTo(Visibility... visibilities) {            mask.restrictVisibilitiesTo(visibilities);            return mask;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import static net.sourceforge.pmd.lang.java.typeresolution.internal.NullableClassLoader.ClassLoaderWrapper.wrapNullable;import java.util.Map;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.java.typeresolution.internal.NullableClassLoader;public class TypesFromReflectionTest extends BaseNonParserTest {    private static final NullableClassLoader LOADER = wrapNullable(TypesFromReflectionTest.class.getClassLoader());    @Rule    public final ExpectedException expect = ExpectedException.none();    @Test    public void testNestedClass() {        Class<?> c = TypesFromReflection.loadClass(LOADER, "java.util.Map.Entry");        Assert.assertEquals(Map.Entry.class, c);    }    @Test    public void testPrimitiveArray() {        Class<?> c = TypesFromReflection.loadClass(LOADER, "int[ ]");        Assert.assertEquals(int[].class, c);    }    @Test    public void testNestedClassArray() {        Class<?> c = TypesFromReflection.loadClass(LOADER, "java.util.Map.Entry[ ]");        Assert.assertEquals(Map.Entry[].class, c);    }    @Test    public void testInvalidName() {        expect.expect(IllegalArgumentException.class);        TypesFromReflection.loadClass(LOADER, "java.util.Map ]");    }    @Test    public void testInvalidName2() {        expect.expect(IllegalArgumentException.class);        TypesFromReflection.loadClass(LOADER, "[]");    }    @Test    public void testNullName() {        expect.expect(NullPointerException.class);        TypesFromReflection.loadClass(LOADER, null);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import java.io.ObjectStreamField;import java.io.Serializable;import java.lang.annotation.Annotation;import java.util.concurrent.Callable;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.function.ThrowingRunnable;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTType;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;public class TypeTestUtilTest extends BaseNonParserTest {    @Rule    public final ExpectedException expect = ExpectedException.none();    @Test    public void testIsAFallback() {        ASTClassOrInterfaceDeclaration klass =            java.parse("package org; import java.io.Serializable; "                           + "class FooBar implements Serializable {}")                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeTestUtil.isA("org.FooBar", klass));        Assert.assertTrue(TypeTestUtil.isA("java.io.Serializable", klass));        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));    }    @Test    public void testIsAFallbackEnum() {        ASTEnumDeclaration klass =            java.parse("package org; "                           + "enum FooBar implements Iterable {}")                .getFirstDescendantOfType(ASTEnumDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertIsStrictSubtype(klass, Iterable.class);        assertIsStrictSubtype(klass, Enum.class);        assertIsStrictSubtype(klass, Serializable.class);        assertIsStrictSubtype(klass, Object.class);    }    @Test    public void testIsAnArrayClass() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final ObjectStreamField[] serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, ObjectStreamField[].class);        assertIsStrictSubtype(arrayT, Object[].class);        assertIsStrictSubtype(arrayT, Serializable.class);        assertIsNot(arrayT, Serializable[].class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    public void testIsAnAnnotationClass() {        ASTType arrayT =            java.parse("class Foo { org.junit.Test field; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, Test.class);        assertIsStrictSubtype(arrayT, Annotation.class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    public void testIsAPrimitiveArrayClass() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final int[] serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, int[].class);        assertIsNot(arrayT, long[].class);        assertIsNot(arrayT, Object[].class);        assertIsStrictSubtype(arrayT, Serializable.class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    public void testIsAFallbackAnnotation() {        ASTAnnotationTypeDeclaration klass =            java.parse("package org; import foo.Stuff;"                           + "public @interface FooBar {}")                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertIsA(klass, Annotation.class);        assertIsA(klass, Object.class);    }    @Test    public void testAnonClassTypeNPE() {        // #2756        ASTAllocationExpression anon =            java.parseClass(SomeClassWithAnon.class)                .getFirstDescendantOfType(ASTAllocationExpression.class);        Assert.assertNotNull("Type should be resolved", anon.getType());        Assert.assertTrue("Anon class", anon.isAnonymousClass());        Assert.assertTrue("Anon class", anon.getType().isAnonymousClass());        Assert.assertTrue("Should be a Runnable", TypeTestUtil.isA(Runnable.class, anon));        // This is not a canonical name, so we give up early        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + "$1", anon));        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + "$1", anon));        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));    }    /**     * If we don't have the annotation on the classpath,     * we should resolve the full name via the import, if possible     * and compare then. Only after that, we should compare the     * simple names.     */    @Test    public void testIsAFallbackAnnotationSimpleNameImport() {        ASTName annotation = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);        Assert.assertNull(annotation.getType());        Assert.assertTrue(TypeTestUtil.isA("foo.Stuff", annotation));        Assert.assertFalse(TypeTestUtil.isA("other.Stuff", annotation));        // if the searched class name is not fully qualified, then the search should still be successful        Assert.assertTrue(TypeTestUtil.isA("Stuff", annotation));    }    @Test    public void testNullNode() {        Assert.assertFalse(TypeTestUtil.isA(String.class, null));        Assert.assertFalse(TypeTestUtil.isA("java.lang.String", null));        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, null));        Assert.assertFalse(TypeTestUtil.isExactlyA("java.lang.String", null));    }    @Test    public void testNullClass() {        final ASTName node = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                                 .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);        Assert.assertNotNull(node);        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {            @Override            public void run() {                TypeTestUtil.isA((String) null, node);            }        });        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {            @Override            public void run() {                TypeTestUtil.isA((Class<?>) null, node);            }        });        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {            @Override            public void run() {                TypeTestUtil.isExactlyA((Class<?>) null, node);            }        });        Assert.assertThrows(NullPointerException.class, new ThrowingRunnable() {            @Override            public void run() {                TypeTestUtil.isExactlyA((String) null, node);            }        });    }    private void assertIsA(TypeNode node, Class<?> type) {        assertIsA(node, type, false, true);    }    private void assertIsExactlyA(TypeNode node, Class<?> type) {        assertIsA(node, type, true, true);        assertIsA(node, type, false, true);    }    private void assertIsNot(TypeNode node, Class<?> type) {        assertIsA(node, type, true, false);        assertIsA(node, type, false, false);    }    private void assertIsNotExactly(TypeNode node, Class<?> type) {        assertIsA(node, type, true, false);    }    private void assertIsStrictSubtype(TypeNode node, Class<?> type) {        assertIsNotExactly(node, type);        assertIsA(node, type);    }    private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {        Assert.assertEquals("TypeTestUtil::isA with class arg: " + type.getCanonicalName(),                            expectTrue,                            exactly ? TypeTestUtil.isExactlyA(type, node)                                    : TypeTestUtil.isA(type, node));        Assert.assertEquals("TypeTestUtil::isA with string arg: " + type.getCanonicalName(),                            expectTrue,                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)                                    : TypeTestUtil.isA(type.getCanonicalName(), node));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.io.File;import java.util.HashSet;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader;public class TypeSetTest {    private PMDASMClassLoader pmdClassLoader = PMDASMClassLoader.getInstance(TypeSetTest.class.getClassLoader());    @Test    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    @Test    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    @Test    public void testFindClassImplicitImport() throws ClassNotFoundException {        TypeSet t = new TypeSet();        Class<?> clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    @Test    public void testFindClassSamePackage() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd");        Class<?> clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    @Test    public void testFindClassExplicitImport() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class<?> clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    @Test    public void testFindClassImportOnDemand() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class<?> clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    @Test    public void testFindClassPrimitive() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    @Test    public void testFindClassVoid() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    @Test    public void testFindFullyQualified() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    @Test    public void testPrimitiveTypeResolver() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    @Test(expected = ClassNotFoundException.class)    public void testPrimitiveTypeResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        r.resolve(null);    }    @Test    public void testVoidTypeResolver() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    @Test(expected = ClassNotFoundException.class)    public void testVoidTypeResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.VoidResolver();        r.resolve(null);    }    @Test    public void testExplicitImportResolver() throws ClassNotFoundException {        Set<String> imports = new HashSet<>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, imports);        assertEquals(File.class, r.resolve("File"));    }    @Test(expected = ClassNotFoundException.class)    public void testExplicitImportResolverWithNull() throws ClassNotFoundException {        Set<String> imports = new HashSet<>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, imports);        r.resolve(null);    }    @Test(expected = ClassNotFoundException.class)    public void testExplicitImportResolverWithNullAndEmptyImports() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, new HashSet<String>());        r.resolve(null);    }    @Test    public void testImplicitImportResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        assertEquals(String.class, r.resolve("String"));    }    @Test(expected = ClassNotFoundException.class)    public void testImplicitImportResolverPassFail() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        r.resolve("PMD");    }    @Test(expected = ClassNotFoundException.class)    public void testImplicitImportResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        r.resolve(null);    }    @Test    public void testCurrentPackageResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver(pmdClassLoader, "net.sourceforge.pmd");        assertEquals(PMD.class, r.resolve("PMD"));    }    @Test(expected = ClassNotFoundException.class)    public void testCurrentPackageResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver(pmdClassLoader, "net.sourceforge.pmd");        r.resolve(null);    }    @Test    public void testImportOnDemandResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    @Test(expected = ClassNotFoundException.class)    public void testImportOnDemandResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve(null);    }    @Test(expected = ClassNotFoundException.class)    public void importOnDemandResolverFail1() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve("foo");    }    @Test(expected = ClassNotFoundException.class)    public void importOnDemandResolverFail2() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve("String");    }    private TypeSet.Resolver getResolver() {        Set<String> imports = new HashSet<>();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(pmdClassLoader, imports);        return r;    }    @Test(expected = ClassNotFoundException.class)    public void testFullyQualifiedNameResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.FullyQualifiedNameResolver(pmdClassLoader);        r.resolve(null);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.List;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;/** * Base class for tests that usually need processing stages to run when * parsing code. */public abstract class BaseNonParserTest {    protected final JavaParsingHelper java = JavaParsingHelper.WITH_PROCESSING.withResourceContext(getClass());    protected final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    protected ASTCompilationUnit parseCode(final String code) {        return java.parse(code);    }    protected <T extends Node> List<T> getOrderedNodes(Class<T> target, String code) {        return JavaParsingHelper.WITH_PROCESSING.getNodes(target, code);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.Scope;public class VariableNameDeclarationTest extends BaseNonParserTest {    @Test    public void testConstructor() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        Scope s = nodes.get(0).getScope();        NameDeclaration decl = s.getDeclarations().keySet().iterator().next();        assertEquals("bar", decl.getImage());        assertEquals(3, decl.getNode().getBeginLine());    }    @Test    public void testExceptionBlkParam() {        ASTCompilationUnit acu = java.parse(EXCEPTION_PARAMETER);        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(new VariableNameDeclaration(id).isExceptionBlockParameter());    }    @Test    public void testIsArray() {        ASTCompilationUnit acu = parseCode(TEST3);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isArray());    }    @Test    public void testPrimitiveType() {        ASTCompilationUnit acu = parseCode(TEST1);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isPrimitiveType());    }    @Test    public void testArrayIsReferenceType() {        ASTCompilationUnit acu = parseCode(TEST3);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isReferenceType());    }    @Test    public void testPrimitiveTypeImage() {        ASTCompilationUnit acu = parseCode(TEST3);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("int", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testRefTypeImage() {        ASTCompilationUnit acu = parseCode(TEST4);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("String", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testParamTypeImage() {        ASTCompilationUnit acu = parseCode(TEST5);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("String", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordTypeImage() {        ASTCompilationUnit acu = parseCode(TEST6);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("java.util.ArrayList", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordWithPrimitiveTypeImage() {        ASTCompilationUnit acu = parseCode(TEST7);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("long", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordWithIndirectReference() {        ASTCompilationUnit acu = parseCode(TEST8);        Iterator<NameDeclaration> nameDeclarationIterator = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator();        nameDeclarationIterator.next(); // first variable 'bar'        NameDeclaration decl = nameDeclarationIterator.next(); // second variable 'foo'        assertEquals("java.lang.String", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testLamdaParameterTypeImage() {        ASTCompilationUnit acu = parseCode(TEST9);        List<ASTVariableDeclaratorId> variableDeclaratorIds = acu.findDescendantsOfType(                ASTVariableDeclaratorId.class,                true        );        List<VariableNameDeclaration> nameDeclarations = new ArrayList<>();        for (ASTVariableDeclaratorId variableDeclaratorId : variableDeclaratorIds) {            nameDeclarations.add(variableDeclaratorId.getNameDeclaration());        }        assertEquals("Map", nameDeclarations.get(0).getTypeImage()); // variable 'bar'        assertEquals(null, nameDeclarations.get(1).getTypeImage()); // variable 'key'        assertEquals(null, nameDeclarations.get(2).getTypeImage()); // variable 'value'        // variable 'foo'        assertEquals("foo", nameDeclarations.get(3).getName());        assertEquals("long", nameDeclarations.get(3).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, nameDeclarations.get(3).getTypeImage());    }    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int bar = 42;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  try {} catch(Exception e) {}" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int[] x;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  String x;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST5 = "public class Foo {" + PMD.EOL + " void foo(String x) {}" + PMD.EOL + "}";    public static final String TEST6 = "import java.util.ArrayList; public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  var bar = new ArrayList<String>(\"param\");" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST7 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  var bar = 42L;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST8 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  var bar = \"test\";" + PMD.EOL + "  var foo = bar;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST9 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Map<String, Object> bar = new HashMap<>();" + PMD.EOL + "  bar.forEach((key, value) -> {" + PMD.EOL            + "   if (value instanceof String) {" + PMD.EOL + "    var foo = 42L;" + PMD.EOL            + "    System.out.println(value);" + PMD.EOL + "   }" + PMD.EOL + "  });" + PMD.EOL + " }" + PMD.EOL + "}";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VariableNameDeclarationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTBlock;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTIfStatement;public class ScopeCreationVisitorTest extends BaseNonParserTest {    @Test    public void testScopesAreCreated() {        ASTCompilationUnit acu = parseCode(TEST1);        ASTBlock n = acu.getFirstDescendantOfType(ASTIfStatement.class)                .getFirstDescendantOfType(ASTBlock.class);        assertTrue(n.getScope() instanceof LocalScope);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  if (x>2) {}"            + PMD.EOL + " }" + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ScopeCreationVisitorTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.JavaNode;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class ClassScopeTest extends BaseNonParserTest {    @Test    public void testEnumsClassScope() {        java5.parse(ENUM_SCOPE);    }    @Test    public void testEnumTypeParameter() {        java5.parse(ENUM_TYPE_PARAMETER);    }    @Test    public void testVarArgsEmpty() {        java5.parse("public class Foo {\n" + "  public void bar1(String s, Integer... i) {}\n"                + "  public void bar1() {}\n" + "  public void c() {\n" + "    bar1();\n" + "  }\n" + "}\n");    }    // FIXME - these will break when this goes from Anonymous$1 to Foo$1    @Test    public void testAnonymousInnerClassName() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        s = new ClassScope(classDeclaration);        assertEquals("Anonymous$1", s.getClassName());        s = new ClassScope(classDeclaration);        assertEquals("Anonymous$2", s.getClassName());    }    @Test    public void testContains() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testCantContainsSuperToString() {        ASTCompilationUnit cu = java.parse("class Foo { public String toString() { return super.toString(); } }");        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(cu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class));        ClassScope s = new ClassScope("Foo", classDeclaration);        JavaNode node = cu.getFirstDescendantOfType(ASTPrimaryExpression.class); // "super.toString();"        assertFalse(s.contains(new JavaNameOccurrence(node, "super.toString")));    }    @Test    public void testContainsStaticVariablePrefixedWithClassName() {        ASTCompilationUnit cu = java.parse("class Foo { static int X; public int bar() { return Foo.X; } }");        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(cu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class));        ClassScope s = new ClassScope("Foo", classDeclaration);        ASTVariableDeclaratorId node = cu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        s.addDeclaration(new VariableNameDeclaration(node));        JavaNode node2 = cu.getFirstDescendantOfType(ASTName.class);        assertTrue(s.contains(new JavaNameOccurrence(node2, node2.getImage())));    }    @Test    public void testClassName() {        ASTCompilationUnit acu = parseCode(CLASS_NAME);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        assertEquals("Foo", n.getScope().getEnclosingScope(ClassScope.class).getClassName());    }    @Test    public void testMethodDeclarationRecorded() {        ASTCompilationUnit acu = parseCode(METHOD_DECLARATIONS_RECORDED);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope s = (ClassScope) n.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        assertEquals(1, m.size());        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("bar", mnd.getImage());        ASTMethodDeclaration node = (ASTMethodDeclaration) mnd.getNode().getParent();        assertTrue(node.isPrivate());    }    @Test    public void testTwoMethodsSameNameDiffArgs() {        // TODO this won't work with String and java.lang.String        ASTCompilationUnit acu = parseCode(METHODS_WITH_DIFF_ARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        assertEquals(2, m.size());        Iterator<NameDeclaration> i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration) i.next();        assertEquals("bar", mnd.getImage());        assertEquals("bar", ((MethodNameDeclaration) i.next()).getImage());    }    @Test    public final void testOneParam() {        ASTCompilationUnit acu = parseCode(ONE_PARAM);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String)", mnd.getParameterDisplaySignature());    }    @Test    public final void testTwoParams() {        ASTCompilationUnit acu = parseCode(TWO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,int)", mnd.getParameterDisplaySignature());    }    @Test    public final void testNoParams() {        ASTCompilationUnit acu = parseCode(NO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("()", mnd.getParameterDisplaySignature());    }    @Test    public final void testOneParamVararg() {        ASTCompilationUnit acu = java5.parse(ONE_PARAM_VARARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String...)", mnd.getParameterDisplaySignature());    }    @Test    public final void testTwoParamsVararg() {        ASTCompilationUnit acu = java5.parse(TWO_PARAMS_VARARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,String...)", mnd.getParameterDisplaySignature());    }    @Test    public void testNestedClassesOfImportResolution() {        ASTCompilationUnit acu = parseCode(NESTED_CLASSES_OF_IMPORT);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(EnumTest.class, c.resolveType("TheInnerClass.EnumTest"));    }    @Test    public void testNestedClassesResolution() {        final ASTClassOrInterfaceDeclaration n = java.parseClass(InnerClass.class)                                                     .findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(InnerClass.class, c.resolveType("InnerClass"));        assertEquals(TheInnerClass.class, c.resolveType("InnerClass.TheInnerClass"));        assertEquals(TheInnerClass.class, c.resolveType("TheInnerClass")); // Within this scope, we can access it directly    }    @Test    public void testImportNestedClassesResolution() {        ASTCompilationUnit acu = parseCode(IMPORT_NESTED_CLASSES);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(EnumTest.class, c.resolveType("EnumTest"));    }    @Test    public final void testNestedClassDeclFound() {        ASTCompilationUnit acu = parseCode(NESTED_CLASS_FOUND);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope c = (ClassScope) n.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = c.getDeclarations();        ClassNameDeclaration cnd = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals("Buz", cnd.getImage());    }    @Test    public final void testbuz() {        parseCode(METH);        // SymbolTableViewer st = new SymbolTableViewer();        // acu.jjtAccept(st, null);    }    @Test    public void testMethodUsageSeen() {        ASTCompilationUnit acu = parseCode(METHOD_USAGE_SEEN);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Iterator<Map.Entry<NameDeclaration, List<NameOccurrence>>> i = m.entrySet().iterator();        MethodNameDeclaration mnd;        Map.Entry<NameDeclaration, List<NameOccurrence>> entry;        do {            entry = i.next();            mnd = (MethodNameDeclaration) entry.getKey();        } while (!mnd.getImage().equals("bar"));        List<NameOccurrence> usages = entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((JavaNameOccurrence) usages.get(0)).getImage());    }    @Test    public void testMethodUsageSeenWithThis() {        ASTCompilationUnit acu = parseCode(METHOD_USAGE_SEEN_WITH_THIS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Iterator<Map.Entry<NameDeclaration, List<NameOccurrence>>> i = m.entrySet().iterator();        MethodNameDeclaration mnd;        Map.Entry<NameDeclaration, List<NameOccurrence>> entry;        do {            entry = i.next();            mnd = (MethodNameDeclaration) entry.getKey();        } while (!mnd.getImage().equals("bar"));        List<NameOccurrence> usages = entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((JavaNameOccurrence) usages.get(0)).getImage());    }    @Test    public void testMethodUsageSeen2() {        ASTCompilationUnit acu = parseCode(METHOD_USAGE_SEEN2);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        assertEquals(2, m.size());        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            assertEquals("baz", entry.getKey().getImage());            if (entry.getKey().getNode().getBeginLine() == 2) {                // this is the public method declaration - it is not used                // anywhere                assertEquals(0, entry.getValue().size());            } else if (entry.getKey().getNode().getBeginLine() == 5) {                // this is the private (overloaded) method                assertEquals(1, entry.getValue().size());                // it's used once in line 3                assertEquals(3, entry.getValue().get(0).getLocation().getBeginLine());            } else {                fail("unexpected name declaration");            }        }    }    /**     * Test case for bug report #2410201     */    @Test    public void testNestedClassFieldAndParameter() {        ASTCompilationUnit acu = parseCode(NESTED_CLASS_FIELD_AND_PARAM);        ASTMethodDeclaration node = acu.getFirstDescendantOfType(ASTMethodDeclaration.class);        Map<VariableNameDeclaration, List<NameOccurrence>> vd = node.getScope().getDeclarations(VariableNameDeclaration.class);        assertEquals(2, vd.size());        int paramCount = 0;        for (Map.Entry<VariableNameDeclaration, List<NameOccurrence>> entry : vd.entrySet()) {            if (entry.getKey().getDeclaratorId().isFormalParameter()) {                assertEquals("field", entry.getKey().getImage());                List<NameOccurrence> occurrences = entry.getValue();                assertEquals(2, occurrences.size());                NameOccurrence no1 = occurrences.get(0);                assertEquals(8, no1.getLocation().getBeginLine());                NameOccurrence no2 = occurrences.get(1);                assertEquals(9, no2.getLocation().getBeginLine());                paramCount++;            }        }        assertEquals(1, paramCount);    }    @Test    public void testNullType() {        ASTCompilationUnit acu = parseCode(TEST_NULL_TYPE);    }    private static final String NESTED_CLASS_FIELD_AND_PARAM = "public class Foo {" + PMD.EOL + " class Test {"            + PMD.EOL + "   public String field;" + PMD.EOL + "   public Test t;" + PMD.EOL + " }" + PMD.EOL            + " public void foo(String field) {" + PMD.EOL + "   Test t = new Test();" + PMD.EOL + "   t.field = field;"            + PMD.EOL + "   t.t.field = field;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN2 = "public class Foo {" + PMD.EOL + " public void baz() {" + PMD.EOL            + "  baz(x, y);" + PMD.EOL + " }" + PMD.EOL + " private void baz(int x, int y) {}" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN = "public class Foo {" + PMD.EOL + " private void bar() {}" + PMD.EOL            + " public void buz() {" + PMD.EOL + "  bar();" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN_WITH_THIS = "public class Foo {" + PMD.EOL + " private void bar() {}"            + PMD.EOL + " public void buz() {" + PMD.EOL + "  this.bar();" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METH = "public class Test {" + PMD.EOL + "  static { " + PMD.EOL + "   int y; "            + PMD.EOL + "  } " + PMD.EOL + "  void bar(int x) {} " + PMD.EOL + "  void baz(int x) {} " + PMD.EOL + "}";    private static final String NESTED_CLASS_FOUND = "public class Test {" + PMD.EOL + "  private class Buz {} "            + PMD.EOL + "}";    private static final String ONE_PARAM = "public class Test {" + PMD.EOL + "  void bar(String x) {" + PMD.EOL + "  }"            + PMD.EOL + "}";    private static final String TWO_PARAMS = "public class Test {" + PMD.EOL + "  void bar(String x, int y) {" + PMD.EOL            + "  }" + PMD.EOL + "}";    private static final String NO_PARAMS = "public class Test {" + PMD.EOL + "  void bar() {" + PMD.EOL + "  }"            + PMD.EOL + "}";    private static final String ONE_PARAM_VARARG = "public class Test {" + PMD.EOL + "  void bar(String... s) {"            + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String TWO_PARAMS_VARARG = "public class Test {" + PMD.EOL            + "  void bar(String s1, String... s2) {" + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String CLASS_NAME = "public class Foo {}";    private static final String METHOD_DECLARATIONS_RECORDED = "public class Foo {" + PMD.EOL + " private void bar() {}"            + PMD.EOL + "}";    private static final String METHODS_WITH_DIFF_ARG = "public class Foo {" + PMD.EOL            + " private void bar(String x) {}" + PMD.EOL + " private void bar() {}" + PMD.EOL + "}";    private static final String ENUM_SCOPE = "public enum Foo {" + PMD.EOL + " HEAP(\"foo\");" + PMD.EOL            + " private final String fuz;" + PMD.EOL + " public String getFuz() {" + PMD.EOL + "  return fuz;" + PMD.EOL            + " }" + PMD.EOL + "}";    public static final String TEST_NULL_TYPE = "public abstract class NullTypeTest {" + PMD.EOL            + "   protected Comparator<TreeNode> nodesComparator = (o1, o2) -> StringHelper.saveCompare(getFilterableString(o1), getFilterableString(o2));"            + PMD.EOL + "   public abstract String getFilterableString(TreeNode node);" + PMD.EOL + "}";    private static final String ENUM_TYPE_PARAMETER = "public enum Foo {" + PMD.EOL            + "   BAR(isCustomer(BazEnum.FOO_BAR));" + PMD.EOL + "   Foo(boolean isCustomer) { }" + PMD.EOL            + "   private static boolean isCustomer(BazEnum baz) {" + PMD.EOL + "      return false;" + PMD.EOL + "   }"            + PMD.EOL + "}";    private static final String IMPORT_NESTED_CLASSES =            "import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;" + PMD.EOL            + "public class Foo {" + PMD.EOL            + " public EnumTest e;" + PMD.EOL            + "}" + PMD.EOL;    private static final String NESTED_CLASSES_OF_IMPORT =            "import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;" + PMD.EOL            + "public class Foo {" + PMD.EOL            + " public TheInnerClass.EnumTest e;" + PMD.EOL            + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.List;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;public class ScopeAndDeclarationFinderTest extends BaseNonParserTest {    /**     * Unit test for https://sourceforge.net/p/pmd/bugs/1317/     */    @Test    public void testJava8LambdaScoping() {        String source = "public class MultipleLambdas {\n"            + "  Observer a = (o, arg) -> System.out.println(\"a:\" + arg);\n"            + "  Observer b = (o, arg) -> System.out.println(\"b:\" + arg);\n" + "}";        List<ASTLambdaExpression> lambdas = java.parse(source, "1.8").findDescendantsOfType(ASTLambdaExpression.class);        Assert.assertEquals(2, lambdas.size());        LocalScope scope1 = (LocalScope) lambdas.get(0).getScope();        LocalScope scope2 = (LocalScope) lambdas.get(1).getScope();        Assert.assertNotSame(scope1, scope2);        for (ASTLambdaExpression l : lambdas) {            LocalScope scope = (LocalScope) l.getScope();            Assert.assertEquals(2, scope.getVariableDeclarations().size());            Assert.assertTrue(scope.contains(new JavaNameOccurrence(null, "o")));            Assert.assertTrue(scope.contains(new JavaNameOccurrence(null, "arg")));            Set<NameDeclaration> declarations = scope.findVariableHere(new JavaNameOccurrence(null, "arg"));            Assert.assertEquals(1, declarations.size());            NameDeclaration decl = declarations.iterator().next();            Assert.assertEquals(1, scope.getVariableDeclarations().get(decl).size());        }    }    @Test    public void testAnnonInnerClassScoping() {        String source = "public class Foo {" + PMD.EOL                + "  public static final Creator<Foo> CREATOR = new Creator<Foo>() {" + PMD.EOL                + "    @Override public Foo createFromParcel(Parcel source) {" + PMD.EOL                + "      return new Foo();" + PMD.EOL                + "    }" + PMD.EOL                + "    @Override public Foo[] newArray(int size) {" + PMD.EOL                + "      return new Foo[size];" + PMD.EOL                + "    }" + PMD.EOL                + "  };" + PMD.EOL                + "}" + PMD.EOL;        ASTCompilationUnit acu = java.parse(source, "1.6");        ClassScope cs = (ClassScope) acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getScope();        Assert.assertEquals(1, cs.getClassDeclarations().size()); // There should be 1 anonymous class        List<ASTMethodDeclarator> methods = acu.getFirstDescendantOfType(ASTClassOrInterfaceBody.class) // outer class                .getFirstDescendantOfType(ASTClassOrInterfaceBody.class) // inner class                .findDescendantsOfType(ASTMethodDeclarator.class, true); // inner class methods        Assert.assertEquals(2, methods.size());        ClassScope scope1 = methods.get(0).getScope().getEnclosingScope(ClassScope.class);        ClassScope scope2 = methods.get(1).getScope().getEnclosingScope(ClassScope.class);        Assert.assertSame(scope1, scope2);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class LocalScopeTest extends BaseNonParserTest {    @Test    public void testNameWithThisOrSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        name.jjtAddChild(prefix, 1);        JavaNameOccurrence occ = new JavaNameOccurrence(name, "foo");        scope.addNameOccurrence(occ);        assertFalse(scope.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testNameWithSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        name.jjtAddChild(prefix, 1);        JavaNameOccurrence occ = new JavaNameOccurrence(name, "foo");        scope.addNameOccurrence(occ);        assertFalse(scope.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testLocalVariableDeclarationFound() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        assertEquals(1, vars.size());        NameDeclaration decl = vars.keySet().iterator().next();        assertEquals("b", decl.getImage());    }    @Test    public void testQualifiedNameOccurrence() {        ASTCompilationUnit acu = parseCode(TEST2);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        NameDeclaration decl = vars.keySet().iterator().next();        JavaNameOccurrence occ = (JavaNameOccurrence) vars.get(decl).get(0);        assertEquals("b", occ.getImage());    }    @Test    public void testPostfixUsageIsRecorded() {        ASTCompilationUnit acu = parseCode(TEST3);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        NameDeclaration decl = vars.keySet().iterator().next();        List<NameOccurrence> usages = vars.get(decl);        JavaNameOccurrence occ = (JavaNameOccurrence) usages.get(0);        assertEquals(4, occ.getLocation().getBeginLine());    }    @Test    public void testLocalVariableTypesAreRecorded() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        Map<NameDeclaration, List<NameOccurrence>> vars = nodes.get(0).getScope().getDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("Bar", decl.getTypeImage());    }    @Test    public void testMethodArgumentTypesAreRecorded() {        ASTCompilationUnit acu = parseCode(TEST5);        List<ASTFormalParameter> nodes = acu.findDescendantsOfType(ASTFormalParameter.class);        Map<NameDeclaration, List<NameOccurrence>> vars = nodes.get(0).getScope().getDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    @Test    public void testgetEnclosingMethodScope() {        ASTCompilationUnit acu = parseCode(TEST4);        ASTLocalVariableDeclaration node = acu.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        LocalScope scope = (LocalScope) node.getScope();        MethodScope ms = scope.getEnclosingScope(MethodScope.class);        assertEquals(2, ms.getDeclarations().size());    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Bar b = new Bar();" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Bar b = new Bar();" + PMD.EOL + "  b.buz = 2;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x = 2;"            + PMD.EOL + "  x++;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo(String x, String z) { { int x; } }"            + PMD.EOL + "}";    public static final String TEST5 = "public class Foo {" + PMD.EOL + " void foo(String x);" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.swing.JComponent;import javax.swing.JTextField;import org.junit.Assert;import org.junit.Test;/** * Unit test for {@link SimpleTypedNameDeclaration} */public class SimpleTypedNameDeclarationTest {    /**     * Tests the equal method.     */    @Test    public void testEquals() {        Assert.assertEquals(byClass(SimpleTypedNameDeclaration.class), byClass(SimpleTypedNameDeclaration.class));        Assert.assertEquals(byClass(List.class), byClass(ArrayList.class));        Assert.assertEquals(byClass(ArrayList.class), byClass(List.class));        Assert.assertEquals(byName("String"), byName("String"));        Assert.assertEquals(byClass(String.class), byName("String"));        Assert.assertEquals(byClass(JComponent.class), byClass(JTextField.class));        Assert.assertFalse(byClass(Map.class).equals(byClass(List.class)));        Assert.assertFalse(byName("A").equals(byName("B")));        Assert.assertFalse(byClass(String.class).equals(byName("A")));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "double"));        Assert.assertEquals(by(Double.class, "Double"), by(null, "double"));        Assert.assertEquals(by(Character.class, "Character"), by(null, "char"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "float"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "int"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "long"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Long.TYPE, "long"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Long.class, "Long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(null, "int"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Integer.TYPE, "int"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Float.TYPE, "float"), by(null, "long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Long.TYPE, "long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Long.class, "Long"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(null, "char"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(Character.TYPE, "char"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(Character.class, "Character"));        Assert.assertEquals(by(Long.TYPE, "long"), by(null, "int"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Integer.TYPE, "int"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Long.TYPE, "long"), by(null, "char"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Character.TYPE, "char"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Character.class, "Character"));        // should always equal to Object        Assert.assertEquals(by(Object.class, "Object"), by(null, "Something"));        Assert.assertEquals(withNext(byName("Foo.I"), "Foo.B"), byName("Foo.I"));        Assert.assertEquals(byName("Foo.I"), withNext(byName("Foo.I"), "Foo.B"));    }    private static SimpleTypedNameDeclaration byClass(Class<?> c) {        return new SimpleTypedNameDeclaration(c.getSimpleName(), c);    }    private static SimpleTypedNameDeclaration byName(String n) {        return new SimpleTypedNameDeclaration(n, null);    }    private static SimpleTypedNameDeclaration by(Class<?> c, String n) {        return new SimpleTypedNameDeclaration(n, c);    }    private static SimpleTypedNameDeclaration withNext(SimpleTypedNameDeclaration next, String n) {        SimpleTypedNameDeclaration t = new SimpleTypedNameDeclaration(n, null);        t.addNext(next);        return t;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class MethodScopeTest extends BaseNonParserTest {    @Test    public void testMethodParameterOccurrenceRecorded() {        ASTCompilationUnit acu = parseCode(TEST1);        Map<NameDeclaration, List<NameOccurrence>> m = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0)                .getScope().getDeclarations();        NameDeclaration vnd = m.keySet().iterator().next();        assertEquals("bar", vnd.getImage());        List<NameOccurrence> occs = m.get(vnd);        NameOccurrence occ = occs.get(0);        assertEquals(3, occ.getLocation().getBeginLine());    }    @Test    public void testMethodName() {        ASTCompilationUnit acu = parseCode(TEST1);        ASTMethodDeclaration meth = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0);        MethodScope ms = (MethodScope) meth.getScope();        assertEquals(ms.getName(), "foo");    }    @Test    public void testGenerics() {        parseCode(TEST_GENERICS);    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo(int bar) {" + PMD.EOL + "  bar = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST_GENERICS = "public class Tree {" + PMD.EOL + "  private List<Object> subForest;"            + PMD.EOL + "  public <B> Tree<B> fmap(final F<B> f) { return Tree.<B>foo(); }" + PMD.EOL            + "  public List<Object> subForest() { return null; }" + PMD.EOL + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;public class NameOccurrencesTest extends BaseNonParserTest {    @Test    public void testSuper() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("super", occs.getNames().get(0).getImage());    }    @Test    public void testThis() {        ASTCompilationUnit acu = parseCode(TEST2);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("this", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    @Test    public void testNameLinkage() {        ASTCompilationUnit acu = parseCode(TEST2);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        JavaNameOccurrence thisNameOccurrence = occs.getNames().get(0);        assertEquals(thisNameOccurrence.getNameForWhichThisIsAQualifier(), occs.getNames().get(1));    }    @Test    public void testSimpleVariableOccurrence() {        ASTCompilationUnit acu = parseCode(TEST3);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("x", occs.getNames().get(0).getImage());        assertFalse(occs.getNames().get(0).isThisOrSuper());        assertFalse(occs.getNames().get(0).isMethodOrConstructorInvocation());        assertTrue(occs.getNames().get(0).isOnLeftHandSide());    }    @Test    public void testQualifiedOccurrence() {        ASTCompilationUnit acu = parseCode(TEST4);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("b", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    @Test    public void testIsSelfAssignment() {        ASTCompilationUnit acu = parseCode(TEST5);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());        acu = parseCode(TEST6);        nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        occs = new NameFinder(nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());    }    @Test    public void testEnumStaticUsage() {        ASTCompilationUnit acu = parseCode(TEST_ENUM);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(4));        List<JavaNameOccurrence> names = occs.getNames();        assertEquals(3, names.size());        assertEquals("myEnum", names.get(0).getImage());        assertFalse(names.get(0).isMethodOrConstructorInvocation());        assertEquals("desc", names.get(1).getImage());        assertFalse(names.get(1).isMethodOrConstructorInvocation());        assertEquals("equals", names.get(2).getImage());        assertTrue(names.get(2).isMethodOrConstructorInvocation());    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  super.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  this.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  b.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST5 = "public class Foo{" + PMD.EOL + "    private int counter;" + PMD.EOL            + "    private Foo(){" + PMD.EOL + "        counter = 0;" + PMD.EOL + "    }" + PMD.EOL            + "    private int foo(){" + PMD.EOL + "        if (++counter < 3) {" + PMD.EOL + "            return 0;"            + PMD.EOL + "        }" + PMD.EOL + "        return 1;" + PMD.EOL + "    }" + PMD.EOL + "}";    public static final String TEST6 = "public class Foo{" + PMD.EOL + "    private int counter;" + PMD.EOL            + "    private Foo(){" + PMD.EOL + "        counter = 0;" + PMD.EOL + "    }" + PMD.EOL            + "    private int foo(){" + PMD.EOL + "        if (++this.counter < 3) {" + PMD.EOL            + "            return 0;" + PMD.EOL + "        }" + PMD.EOL + "        return 1;" + PMD.EOL + "    }"            + PMD.EOL + "}";    public static final String TEST_ENUM = "public enum MyEnum {" + PMD.EOL + "  A(\"a\");" + PMD.EOL            + "  private final String desc;" + PMD.EOL + "  private MyEnum(String desc) {" + PMD.EOL            + "    this.desc = desc;" + PMD.EOL + "  }" + PMD.EOL + "  public static MyEnum byDesc(String desc) {"            + PMD.EOL + "    for (MyEnum myEnum : value()) {" + PMD.EOL            + "      if (myEnum.desc.equals(desc)) return myEnum;" + PMD.EOL + "    }" + PMD.EOL + "    return null;"            + PMD.EOL + "  }" + PMD.EOL + " }";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(NameOccurrencesTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;import net.sourceforge.pmd.lang.symboltable.Scope;public class GlobalScopeTest extends BaseNonParserTest {    @Test    public void testClassDeclAppears() {        ASTCompilationUnit acu = parseCode(TEST1);        Scope scope = acu.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = scope.getDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    @Test    public void testEnums() {        java5.parse(TEST2);    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "public enum Bar {" + PMD.EOL + "  FOO1 {          " + PMD.EOL            + "    private static final String FIELD_NAME = \"\";" + PMD.EOL + "  }," + PMD.EOL + "  FOO2 {          "            + PMD.EOL + "    private static final String FIELD_NAME = \"\";" + PMD.EOL + "  }" + PMD.EOL + "}"            + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class MethodNameDeclarationTest extends BaseNonParserTest {    @Test    public void testEquality() {        // Verify proper number of nodes are not equal        ASTCompilationUnit acu = java5.parse(SIMILAR);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Set<NameDeclaration> methodNameDeclarations = m.keySet();        assertEquals("Wrong number of method name declarations", methodNameDeclarations.size(), 3);    }    private static final String SIMILAR = "public class Foo {" + PMD.EOL + " public void bar() {" + PMD.EOL            + "  bar(x, y);" + PMD.EOL + " }" + PMD.EOL + " private void bar(int x, int y) {}" + PMD.EOL            + " private void bar(int x, int... y) {}" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class SourceFileScopeTest extends BaseNonParserTest {    @Test    public void testClassDeclAppears() {        ASTCompilationUnit acu = parseCode(TEST1);        Map<NameDeclaration, List<NameOccurrence>> m = acu.getScope().getDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    @Test    public void testPackageIsEmptyString() {        ASTCompilationUnit acu = parseCode(TEST1);        assertEquals(acu.getScope().getEnclosingScope(SourceFileScope.class).getPackageName(), "");    }    @Test    public void testPackageNameFound() {        ASTCompilationUnit acu = parseCode(TEST2);        assertEquals(acu.getScope().getEnclosingScope(SourceFileScope.class).getPackageName(), "foo.bar");    }    @Test    public void testNestedClasses() {        ASTCompilationUnit acu = parseCode(TEST3);        Map<NameDeclaration, List<NameOccurrence>> m = acu.getScope().getDeclarations();        Iterator<NameDeclaration> iterator = m.keySet().iterator();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) iterator.next();        assertEquals(classNameDeclaration.getImage(), "Foo");        assertFalse(iterator.hasNext());    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "package foo.bar;" + PMD.EOL + "public class Foo {" + PMD.EOL + "}" + PMD.EOL;    private static final String TEST3 = "public class Foo {" + PMD.EOL + " public class Bar {" + PMD.EOL + " }"            + PMD.EOL + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.ast.ASTBlock;import net.sourceforge.pmd.lang.java.ast.ASTCatchStatement;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;import net.sourceforge.pmd.lang.java.ast.ASTInitializer;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;import net.sourceforge.pmd.lang.symboltable.Scope;public class AcceptanceTest extends BaseNonParserTest {    @Test    public void testClashingSymbols() {        parseCode(TEST1);    }    @Test    public void testInitializer() {        ASTCompilationUnit acu = parseCode(TEST_INITIALIZERS);        ASTInitializer a = acu.findDescendantsOfType(ASTInitializer.class).get(0);        assertFalse(a.isStatic());        a = acu.findDescendantsOfType(ASTInitializer.class).get(1);        assertTrue(a.isStatic());    }    @Test    public void testCatchBlocks() {        ASTCompilationUnit acu = parseCode(TEST_CATCH_BLOCKS);        ASTCatchStatement c = acu.findDescendantsOfType(ASTCatchStatement.class).get(0);        ASTBlock a = c.findDescendantsOfType(ASTBlock.class).get(0);        Scope s = a.getScope();        Map<NameDeclaration, List<NameOccurrence>> vars = s.getDeclarations();        assertEquals(1, vars.size());        NameDeclaration v = vars.keySet().iterator().next();        assertEquals("e", v.getImage());        assertEquals(1, (vars.get(v)).size());    }    @Test    public void testEq() {        ASTCompilationUnit acu = parseCode(TEST_EQ);        ASTEqualityExpression e = acu.findDescendantsOfType(ASTEqualityExpression.class).get(0);        ASTMethodDeclaration method = e.getFirstParentOfType(ASTMethodDeclaration.class);        Scope s = method.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        assertEquals(2, m.size());        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            NameDeclaration vnd = entry.getKey();            List<NameOccurrence> usages = entry.getValue();            if (vnd.getImage().equals("a") || vnd.getImage().equals("b")) {                assertEquals(1, usages.size());                assertEquals(3, usages.get(0).getLocation().getBeginLine());            } else {                fail("Unknown variable " + vnd);            }        }    }    @Test    public void testFieldFinder() {        ASTCompilationUnit acu = parseCode(TEST_FIELD);        // System.out.println(TEST_FIELD);        ASTVariableDeclaratorId declaration = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(1);        assertEquals(3, declaration.getBeginLine());        assertEquals("bbbbbbbbbb", declaration.getImage());        assertEquals(1, declaration.getUsages().size());        NameOccurrence no = declaration.getUsages().get(0);        Node location = no.getLocation();        assertEquals(6, location.getBeginLine());        // System.out.println("variable " + declaration.getImage() + " is used        // here: " + location.getImage());    }    @Test    public void testDemo() {        ASTCompilationUnit acu = parseCode(TEST_DEMO);        // System.out.println(TEST_DEMO);        ASTMethodDeclaration node = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0);        Scope s = node.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            assertEquals("buz", entry.getKey().getImage());            assertEquals("ArrayList", ((TypedNameDeclaration) entry.getKey()).getTypeImage());            List<NameOccurrence> u = entry.getValue();            assertEquals(1, u.size());            NameOccurrence o = u.get(0);            int beginLine = o.getLocation().getBeginLine();            assertEquals(3, beginLine);            // System.out.println("Variable: " + d.getImage());            // System.out.println("Type: " + d.getTypeImage());            // System.out.println("Usages: " + u.size());            // System.out.println("Used in line " + beginLine);        }    }    @Test    public void testEnum() {        ASTCompilationUnit acu = parseCode(NameOccurrencesTest.TEST_ENUM);        ASTVariableDeclaratorId vdi = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        List<NameOccurrence> usages = vdi.getUsages();        assertEquals(2, usages.size());        assertEquals(5, usages.get(0).getLocation().getBeginLine());        assertEquals(9, usages.get(1).getLocation().getBeginLine());    }    @Test    public void testInnerOuterClass() {        ASTCompilationUnit acu = parseCode(TEST_INNER_CLASS);        ASTVariableDeclaratorId vdi = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(1) // get inner class                .getFirstDescendantOfType(ASTVariableDeclaratorId.class); // get first declaration        List<NameOccurrence> usages = vdi.getUsages();        assertEquals(2, usages.size());        assertEquals(5, usages.get(0).getLocation().getBeginLine());        assertEquals(10, usages.get(1).getLocation().getBeginLine());    }    /**     * Unit test for bug #1490     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1490/">#1490 [java] PMD     *      Error while processing - NullPointerException</a>     */    @Test    public void testNullPointerEnumValueOfOverloaded() {        ASTCompilationUnit acu = parseCode("public enum EsmDcVoltageSensor {\n" + "    A;\n" + "    void bar(int ... args) {\n"                + "        int idx;\n" + "        int startIdx;\n"                + "        String name = EsmDcVoltageSensor.valueOf((byte) (idx - startIdx)).getName();\n" + "    }\n"                // that's the overloaded method                + "    public EsmDCVoltageSensor valueOf(byte b) {\n"                + "    }\n" + "}\n");    }    private static final String TEST_DEMO = "public class Foo  {" + PMD.EOL + " void bar(ArrayList buz) { " + PMD.EOL            + "  buz.add(\"foo\");" + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_EQ = "public class Foo  {" + PMD.EOL + " boolean foo(String a, String b) { "            + PMD.EOL + "  return a == b; " + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST1 = "import java.io.*;" + PMD.EOL + "public class Foo  {" + PMD.EOL            + " void buz( ) {" + PMD.EOL + "  Object o = new Serializable() { int x; };" + PMD.EOL            + "  Object o1 = new Serializable() { int x; };" + PMD.EOL + " }" + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_INITIALIZERS = "public class Foo  {" + PMD.EOL + " {} " + PMD.EOL + " static {} "            + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_CATCH_BLOCKS = "public class Foo  {" + PMD.EOL + " void foo() { " + PMD.EOL            + "  try { " + PMD.EOL + "  } catch (Exception e) { " + PMD.EOL + "   e.printStackTrace(); " + PMD.EOL            + "  } " + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_FIELD = "public class MyClass {" + PMD.EOL + " private int aaaaaaaaaa; " + PMD.EOL            + " boolean bbbbbbbbbb = MyClass.ASCENDING; " + PMD.EOL + " private int zzzzzzzzzz;" + PMD.EOL            + " private void doIt() {" + PMD.EOL + "  if (bbbbbbbbbb) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + "}" + PMD.EOL;    public static final String TEST_INNER_CLASS = "public class Outer {" + PMD.EOL + "  private static class Inner {"            + PMD.EOL + "    private int i;" + PMD.EOL + "    private Inner(int i) {" + PMD.EOL + "      this.i = i;"            + PMD.EOL + "    }" + PMD.EOL + "  }" + PMD.EOL + "  public int modify(int i) {" + PMD.EOL            + "    Inner in = new Inner(i);" + PMD.EOL + "    return in.i;" + PMD.EOL + "  }" + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AcceptanceTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.ImageFinderFunction;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;public class ImageFinderFunctionTest {    @Test    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    @Test    public void testSeveralImages() {        List<String> imgs = new ArrayList<>();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ImageFinderFunctionTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.typeresolution;import static net.sourceforge.pmd.lang.java.typeresolution.internal.NullableClassLoader.ClassLoaderWrapper.wrapNullable;import java.io.Serializable;import java.lang.annotation.Annotation;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMarkerAnnotation;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.java.typeresolution.internal.NullableClassLoader;public class TypeHelperTest extends BaseNonParserTest {    private static final NullableClassLoader LOADER = wrapNullable(TypeHelperTest.class.getClassLoader());    @Rule    public final ExpectedException expect = ExpectedException.none();    @Test    public void testIsAFallback() {        ASTClassOrInterfaceDeclaration klass =            java.parse("package org; import java.io.Serializable; "                           + "class FooBar implements Serializable {}")                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeHelper.isA(klass, "org.FooBar"));        Assert.assertTrue(TypeHelper.isA(klass, "java.io.Serializable"));        Assert.assertTrue(TypeHelper.isA(klass, Serializable.class));    }    @Test    public void testIsAFallbackEnum() {        ASTEnumDeclaration klass =            java.parse("package org; "                           + "enum FooBar implements Iterable {}")                .getFirstDescendantOfType(ASTEnumDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeHelper.isA(klass, "org.FooBar"));        assertIsA(klass, Iterable.class);        assertIsA(klass, Enum.class);        assertIsA(klass, Serializable.class);        assertIsA(klass, Object.class);    }    @Test    public void testIsAFallbackAnnotation() {        ASTAnnotationTypeDeclaration klass =            java.parse("package org; import foo.Stuff;"                           + "public @interface FooBar {}")                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeHelper.isA(klass, "org.FooBar"));        assertIsA(klass, Annotation.class);        assertIsA(klass, Object.class);    }    /**     * If we don't have the annotation on the classpath,     * we should resolve the full name via the import, if possible     * and compare then. Only after that, we should compare the     * simple names.     */    @Test    public void testIsAFallbackAnnotationSimpleNameImport() {        ASTName annotation = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                .getFirstDescendantOfType(ASTMarkerAnnotation.class).getFirstChildOfType(ASTName.class);        Assert.assertNull(annotation.getType());        Assert.assertTrue(TypeHelper.isA(annotation, "foo.Stuff"));        Assert.assertFalse(TypeHelper.isA(annotation, "other.Stuff"));        // if the searched class name is not fully qualified, then the search should still be successful        Assert.assertTrue(TypeHelper.isA(annotation, "Stuff"));    }    private void assertIsA(TypeNode node, Class<?> type) {        Assert.assertTrue("TypeHelper::isA with class arg: " + type.getCanonicalName(),                          TypeHelper.isA(node, type));        Assert.assertTrue("TypeHelper::isA with string arg: " + type.getCanonicalName(),                          TypeHelper.isA(node, type.getCanonicalName()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class HardCodedCryptoKeyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InsecureCryptoIvTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingSerialVersionUIDTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryCaseChangeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLiteralsInIfConditionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryConversionTemporaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeShouldBeProtectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCallingFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperFirstTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MisplacedNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringBufferInstantiationWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodMustBePublicTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptySwitchStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseLocaleWithCaseConversionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseEqualsToCompareStringsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontImportSunTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeOnlyCallsSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ComparisonWithNaNTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotTerminateVMTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodMustImplementCloneableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TestClassWithoutTestCasesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReturnEmptyArrayRatherThanNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JumbledIncrementerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotHardCodeSDCardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentToNonFinalStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitStaticSuiteTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseCorrectExceptionLoggingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitSpellingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeOverloadedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MoreThanOneLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StaticEJBFieldShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DetachedTestCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousEqualsMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseProperClassLoaderTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotCallGarbageCollectionExplicitlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EqualsNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotExtendJavaLangThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NonStaticInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneThrowsCloneNotSupportedExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BrokenNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassCastExceptionWithToArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimpleDateFormatNeedsLocaleTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidEnumAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InvalidLogMessageFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeDoesNotCallSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReturnFromFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProperCloneImplementationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloseResourceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDuplicateLiteralsTest extends PmdRuleTst {    @Test    public void testStringParserEmptyString() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("");        assertTrue(res.isEmpty());    }    @Test    public void testStringParserSimple() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("a,b,c");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("c"));    }    @Test    public void testStringParserEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("a,b,\\,");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains(","));    }    @Test    public void testStringParserEscapedEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("a,b,\\\\");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("\\"));    }    @Test    public void testSeparatorPropertyWarning() throws Exception {        AvoidDuplicateLiteralsRule rule = new AvoidDuplicateLiteralsRule();        Assert.assertFalse(rule.isPropertyOverridden(AvoidDuplicateLiteralsRule.SEPARATOR_DESCRIPTOR));        Rule copy = rule.deepCopy();        Assert.assertFalse(copy.isPropertyOverridden(AvoidDuplicateLiteralsRule.SEPARATOR_DESCRIPTOR));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperLastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ImportFromSamePackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodReturnTypeMustMatchClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyFinalizerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidAssertAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IdempotentOperationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyTryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LoggerIsNotStaticFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CompareObjectsWithEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotThrowExceptionInFinallyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SingleMethodSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BeanMembersShouldSerializeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnconditionalIfStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NonCaseLabelInSwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProperLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLosingExceptionInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingStaticMethodInNonInstantiatableClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidInstanceofChecksInCatchClauseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NullAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidBranchingStatementAsLastInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidMultipleUnaryOperatorsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDecimalLiteralsInBigDecimalConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFieldNameMatchingMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedNullCheckInEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontUseFloatTypeForLoopIndicesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DataflowAnomalyAnalysisTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptySynchronizedBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CheckSkipResultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingOctalValuesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InstantiationToGetClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFieldNameMatchingTypeNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementNotInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessOperationOnImmutableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingNPETest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousOctalEscapeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SingletonClassReturningNewInstanceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousHashcodeMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingBreakInSwitchTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConstructorCallsOverridableMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SignatureDeclareThrowsExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThrowingNullPointerExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AbstractClassWithoutAnyMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseObjectForClearerAPITest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExceptionAsFlowControlTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SwitchDensityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUncheckedExceptionsInSignaturesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessOverridingMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifiedTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassWithOnlyPrivateConstructorsShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GodClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotExtendJavaLangErrorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CouplingBetweenObjectsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseUtilityClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidRethrowingExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ImmutableFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThrowingRawExceptionTypesTest extends PmdRuleTst {    public static class Throwable extends java.lang.Throwable {        private static final long serialVersionUID = 1798165250043760600L;    }    public static class Exception extends java.lang.Throwable {        private static final long serialVersionUID = -2518308549741147689L;    }    public static class RuntimeException extends java.lang.Throwable {        private static final long serialVersionUID = 6341520923058239682L;    }    public static class Error extends java.lang.Throwable {        private static final long serialVersionUID = -6965602141393320558L;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DataClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyConditionalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalFieldCouldBeStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NPathComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import java.io.StringReader;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StdCyclomaticComplexityTest extends PmdRuleTst {    /**     * Make sure the entry stack is empty, if show classes complexity is     * disabled.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1501/">bug #1501</a>     */    @Test    public void entryStackMustBeEmpty() {        StdCyclomaticComplexityRule rule = new StdCyclomaticComplexityRule();        rule.setProperty(StdCyclomaticComplexityRule.SHOW_CLASSES_COMPLEXITY_DESCRIPTOR, Boolean.FALSE);        RuleContext ctx = new RuleContext();        LanguageVersion javaLanguageVersion = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8");        ParserOptions parserOptions = javaLanguageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = javaLanguageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse("test", new StringReader("public class SampleClass {}"));        rule.apply(Arrays.asList(node), ctx);        Assert.assertTrue(rule.entryStack.isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SingularFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanReturnsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MutableStaticStateTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingGenericExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LawOfDemeterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LogicInversionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanExpressionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssCountTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CognitiveComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssConstructorCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ModifiedCyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThrowingNewInstanceOfSameExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssTypeCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LoosePackageCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AppendCharacterWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingShortTypeTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseIOStreamsWithApacheCommonsFileItemTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OptimizableToArrayCallTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseArrayListInsteadOfVectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFileStreamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BigIntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsecutiveAppendsShouldReuseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCalendarDateCreationTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidArrayLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyStartsWithTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AddEmptyStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidInstantiatingObjectsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ByteInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessStringValueOfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsecutiveLiteralAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringToStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RedundantFieldInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseArraysAsListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InefficientStringBufferingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InefficientEmptyStringCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooFewBranchesForASwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LongInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseIndexOfCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InsufficientStringBufferDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BooleanInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryWrapperObjectCreationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseStringBufferLengthTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseStringBufferForStringAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentRequiredTest extends PmdRuleTst {    @Test    public void allCommentTypesIgnored() {        CommentRequiredRule rule = new CommentRequiredRule();        assertNull("By default, the rule should be functional", rule.dysfunctionReason());        List<PropertyDescriptor<?>> propertyDescriptors = getProperties(rule);        // remove  deprecated properties        for (Iterator<PropertyDescriptor<?>> it = propertyDescriptors.iterator(); it.hasNext();) {            PropertyDescriptor<?> property = it.next();            if (property.description().startsWith("Deprecated!")) {                it.remove();            }        }        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Ignored");        }        assertNotNull("All properties are ignored, rule should be dysfunctional", rule.dysfunctionReason());        // now, try out combinations: only one of the properties is required.        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Required");            assertNull("The property " + property.name() + " is set to required, the rule should be functional.",                rule.dysfunctionReason());            setPropertyValue(rule, property, "Ignored");        }    }    private static List<PropertyDescriptor<?>> getProperties(Rule rule) {        List<PropertyDescriptor<?>> result = new ArrayList<>();        for (PropertyDescriptor<?> property : rule.getPropertyDescriptors()) {            if (property != Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR                    && property != Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) {                result.add(property);            }        }        return result;    }    private static <T> void setPropertyValue(Rule rule, PropertyDescriptor<T> property, String value) {        rule.setProperty(property, property.valueFrom(value));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentSizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentContentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UncommentedEmptyMethodBodyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UncommentedEmptyConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import static org.junit.Assert.assertEquals;import java.io.Reader;import java.io.StringReader;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.FormalComment;import net.sourceforge.pmd.lang.java.ast.MultiLineComment;import net.sourceforge.pmd.lang.java.ast.Token;public class AbstractCommentRuleTest {    private AbstractCommentRule testSubject = new AbstractCommentRule() {    };    /**     * Blank lines in comments should not raise an exception. See bug #1048.     */    @Test    public void testFilteredCommentIn() {        Token token = new Token();        token.image = "/* multi line comment with blank lines\n\n\n */";        String filtered = testSubject.filteredCommentIn(new MultiLineComment(token));        assertEquals("multi line comment with blank lines", filtered);        token.image = "/** a formal comment with blank lines\n\n\n */";        filtered = testSubject.filteredCommentIn(new FormalComment(token));        assertEquals("a formal comment with blank lines", filtered);    }    @Test    public void testTagsIndicesIn() {        String comment = "    /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "";        List<Integer> indices = testSubject.tagsIndicesIn(comment);        Assert.assertEquals(2, indices.size());        Assert.assertEquals(79, indices.get(0).intValue());        Assert.assertEquals(123, indices.get(1).intValue());    }    @Test    public void testCommentAssignments() {        LanguageVersionHandler handler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8")                .getLanguageVersionHandler();        Reader source = new StringReader("public class Foo {" + "     /** Comment 1 */\n"                + "        public void method1() {}\n" + "    \n" + "        /** Comment 2 */\n" + "    \n"                + "        /** Comment 3 */\n" + "        public void method2() {}" + "}");        Node node = handler.getParser(handler.getDefaultParserOptions()).parse("test", source);        testSubject.assignCommentsToDeclarations((ASTCompilationUnit) node);        List<ASTMethodDeclaration> methods = node.findDescendantsOfType(ASTMethodDeclaration.class);        Assert.assertEquals("/** Comment 1 */", methods.get(0).comment().getImage());        Assert.assertEquals("/** Comment 3 */", methods.get(1).comment().getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryfullyqualifiedname;public class TestClass {    protected class SomeInnerClass {        public void alsoDoSomething() {            System.out.println("alsoDoSomething");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousConstantFieldNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MDBAndSessionBeanNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalHomeNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ControlStatementBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyStaticImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentDefaultAccessModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OnlyOneReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDollarSignsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PrematureDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingNativeCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DefaultPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExtendsObjectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperInConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopShouldBeWhileLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseDiamondOperatorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryFullyQualifiedNameTest extends PmdRuleTst {    // Do not delete these two enums - it is needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1436 UnnecessaryFullyQualifiedName false positive on clashing static    // imports with enums    public enum ENUM1 {        A, B;    }    public enum ENUM2 {        C, D;    }    // Do not delete these two classes - it is needed for a test case    // see: /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1546 part 1 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    // #1546 part 2 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    public static class PhonyMockito {        public static <T> T mock(Class<T> clazz) {            return null;        }    }    public static class PhonyPowerMockito {        public static <T> T mock(Class<T> clazz) {            return null;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldDeclarationsShouldBeAtStartOfClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryAnnotationValueElementTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryImportTest extends PmdRuleTst {    // these 2 methods are used for a test case, do not delete    public static void assertTrue(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }    public static void assertSomething(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseShortArrayInitializerTest extends PmdRuleTst {  // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFinalLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RemoteInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessQualifiedThisTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IdenticalCatchBranchesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DuplicateImportsTest extends PmdRuleTst {    /**     * This is just for testing DuplicateImports for static imports and     * disambiguation.     */    // Do not delete this method, its needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/DuplicateImports.xml    // #1306 False positive on duplicate when using static imports    public static void assertTrue(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessParenthesesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidProtectedFieldInFinalClassTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryCastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidProtectedMethodInFinalClassNotExtendingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyMethodInAbstractClassShouldBeAbstractTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GenericsNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LongVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PackageCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontImportJavaLangTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AbstractNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AtLeastOneConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseUnderscoresInNumericLiteralsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalInterfaceSessionNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidPrefixingMethodParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RemoteSessionInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LinguisticNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MIsLeadingVariableNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryLocalBeforeReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConfusingTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BooleanGetMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodArgumentCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoubleBraceInitializationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AbstractClassWithoutAbstractMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseVarargsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitUseExpectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopCanBeForeachTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertNullInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4TestShouldUseAfterAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingOverrideTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedPrivateMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertSameInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertEqualsInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReplaceVectorWithListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DefaultLabelNotLastInSwitchStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningCatchVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidMessageDigestFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopVariableCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedFormalParameterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AccessorMethodGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CheckResultSetTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConstantsInInterfaceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReplaceEnumerationWithIteratorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4TestShouldUseTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidStringBufferFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReplaceHashtableWithMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningLoopVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseTryWithResourcesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LooseCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PositionLiteralsFirstInComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PreserveStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopWithLiteralBooleanTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SystemPrintlnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LiteralsFirstInComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedPrivateFieldTest extends PmdRuleTst {    /**     * This test will fail, as soon Lombok classes are on the test classpath.     * The test classpath is used as auxclasspath during unit tests.     * If lombok is present, then the test case for #1952 will never fail     * and won't reproduce the false-negative case anymore.     */    @Test    public void makeSureLombokIsNotOnClasspath() {        try {            Class.forName("lombok.Value");            Assert.fail();        } catch (ClassNotFoundException e) {            // this is ok        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingHardCodedIPTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ArrayIsStoredDirectlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit5TestShouldBePackagePrivateTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseStandardCharsetsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitTestsShouldIncludeAssertTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertTrueInsteadOfAssertEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseCollectionIsEmptyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitTestContainsTooManyAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4SuitesShouldUseSuiteAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GuardLogStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PositionLiteralsFirstInCaseInsensitiveComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4TestShouldUseBeforeAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AccessorClassGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidPrintStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodReturnsInternalArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SwitchStmtsShouldHaveDefaultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseConcurrentHashMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnsynchronizedStaticFormatterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NonThreadSafeSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingVolatileTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontCallThreadRunTest extends PmdRuleTst {    // Used by DontCallThreadRun test cases    public static class TestThread extends Thread {        @Override        public void run() {            System.out.println("test");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoubleCheckedLockingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSynchronizedAtMethodLevelTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThreadGroupTest extends PmdRuleTst {    // Used by AvoidThreadGroup test cases    public static class ThreadGroup {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnsynchronizedStaticDateFormatterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseNotifyAllInsteadOfNotifyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotUseThreadsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.java.rule.codestyle.DuplicateImportsRule;import net.sourceforge.pmd.lang.rule.RuleViolationFactory;/** * @author guofei * */public class JavaRuleViolationFactoryTest {    @Test    public void messageWithSingleBrace() {        RuleViolationFactory factory = JavaRuleViolationFactory.INSTANCE;        factory.addViolation(new RuleContext(), new DuplicateImportsRule(), null, "message with \"'{'\"", null);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.StringReader;import java.util.HashMap;import java.util.Iterator;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.JaxenXPathRuleQuery;import net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;import net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sourceforge.pmd.testframework.RuleTst;/** * @author daniels */public class XPathRuleTest extends RuleTst {    private XPathRule makeXPath(String expression) {        XPathRule rule = new XPathRule(XPathVersion.XPATH_2_0, expression);        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        rule.setMessage("XPath Rule Failed");        return rule;    }    @Test    public void testPluginname() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[string-length(@Name) < 3]");        rule.setMessage("{0}");        Report report = getReportForTestString(rule, TEST1);        RuleViolation rv = report.iterator().next();        assertEquals("a", rv.getDescription());    }    @Test    public void testXPathMultiProperty() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[@Name=$forbiddenNames]");        rule.setMessage("Avoid vars");        PropertyDescriptor<List<String>> varDescriptor            = PropertyFactory.stringListProperty("forbiddenNames")                             .desc("Forbidden names")                             .defaultValues("forbid1", "forbid2")                             .delim('$')                             .build();        rule.definePropertyDescriptor(varDescriptor);        Report report = getReportForTestString(rule, TEST3);        Iterator<RuleViolation> rv = report.iterator();        int i = 0;        for (; rv.hasNext(); ++i) {            rv.next();        }        assertEquals(2, i);    }    @Test    public void testVariables() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[@Name=$var]");        rule.setMessage("Avoid vars");        PropertyDescriptor<String> varDescriptor =            PropertyFactory.stringProperty("var").desc("Test var").defaultValue("").build();        rule.definePropertyDescriptor(varDescriptor);        rule.setProperty(varDescriptor, "fiddle");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.iterator().next();        assertEquals(3, rv.getBeginLine());    }    @Test    public void testFnPrefixOnSaxon() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[fn:matches(@Name, 'fiddle')]");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.iterator().next();        assertEquals(3, rv.getBeginLine());    }    @Test    public void testNoFnPrefixOnSaxon() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[matches(@Name, 'fiddle')]");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.iterator().next();        assertEquals(3, rv.getBeginLine());    }    /**     * Test for problem reported in bug #1219 PrimarySuffix/@Image does not work     * in some cases in xpath 2.0     *     * @throws Exception     *             any error     */    @Test    public void testImageOfPrimarySuffix() throws Exception {        final String SUFFIX = "import java.io.File;\n" + "\n" + "public class TestSuffix {\n"                + "    public static void main(String args[]) {\n" + "        new File(\"subdirectory\").list();\n"                + "    }\n" + "}";        LanguageVersion language = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = language.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = language.getLanguageVersionHandler().getParser(parserOptions);        ASTCompilationUnit cu = (ASTCompilationUnit) parser.parse("test", new StringReader(SUFFIX));        RuleContext ruleContext = new RuleContext();        ruleContext.setLanguageVersion(language);        String xpath = "//PrimarySuffix[@Image='list']";        // XPATH version 1.0        XPathRuleQuery xpathRuleQuery = new JaxenXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_1_0);        List<Node> nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(1, nodes.size());        // XPATH version 1.0 Compatibility        xpathRuleQuery = new SaxonXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_1_0_COMPATIBILITY);        nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(1, nodes.size());        // XPATH version 2.0        xpathRuleQuery = new SaxonXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_2_0);        nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(1, nodes.size());    }    /**     * Following sibling check: See https://sourceforge.net/p/pmd/bugs/1209/     *     * @throws Exception     *             any error     */    @Test    public void testFollowingSibling() throws Exception {        final String SOURCE = "public class dummy {\n" + "  public String toString() {\n"                + "    String test = \"bad example\";\n" + "    test = \"a\";\n" + "    return test;\n" + "  }\n" + "}";        LanguageVersion language = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = language.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = language.getLanguageVersionHandler().getParser(parserOptions);        ASTCompilationUnit cu = (ASTCompilationUnit) parser.parse("test", new StringReader(SOURCE));        RuleContext ruleContext = new RuleContext();        ruleContext.setLanguageVersion(language);        String xpath = "//Block/BlockStatement/following-sibling::BlockStatement";        // XPATH version 1.0        XPathRuleQuery xpathRuleQuery = new JaxenXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_1_0);        List<Node> nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(2, nodes.size());        assertEquals(4, nodes.get(0).getBeginLine());        assertEquals(5, nodes.get(1).getBeginLine());        // XPATH version 2.0        xpathRuleQuery = new SaxonXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_2_0);        nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(2, nodes.size());        assertEquals(4, nodes.get(0).getBeginLine());        assertEquals(5, nodes.get(1).getBeginLine());    }    private static Report getReportForTestString(Rule r, String test) throws PMDException {        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFile(new File("n/a"));        RuleSet rules = RuleSet.forSingleRule(r);        p.getSourceCodeProcessor().processSourceCode(new StringReader(test), new RuleSets(rules), ctx);        return report;    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " int a;" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " int faddle;" + PMD.EOL + " int fiddle;"            + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " int forbid1; int forbid2; int forbid1$forbid2;" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder;/** * @author Philip Graf */public class JavaRuleViolationTest {    /**     * Verifies that {@link JavaRuleViolation} sets the variable name for an     * {@link ASTFormalParameter} node.     */    @Test    public void testASTFormalParameterVariableName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        final ASTFormalParameter node = ast.getFirstDescendantOfType(ASTFormalParameter.class);        final RuleContext context = new RuleContext();        final JavaRuleViolation violation = new JavaRuleViolation(null, context, node, null);        assertEquals("x", violation.getVariableName());    }    private ASTCompilationUnit parse(final String code) {        final LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        final ParserOptions options = languageVersionHandler.getDefaultParserOptions();        final ASTCompilationUnit ast = (ASTCompilationUnit) languageVersionHandler.getParser(options).parse(null,                new StringReader(code));        // set scope of AST nodes        ast.jjtAccept(new ScopeAndDeclarationFinder(), null);        return ast;    }    /**     * Tests that the method name is taken correctly from the given node.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1250/">#1250</a>     */    @Test    public void testMethodName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        final RuleContext context = new RuleContext();        final JavaRuleViolation violation = new JavaRuleViolation(null, context, md, null);        assertEquals("bar", violation.getMethodName());    }    /**     * Tests that the enum name is taken correctly from the given node.     */    @Test    public void testEnumName() {        ASTCompilationUnit ast = parse("enum Foo {FOO; void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        final RuleContext context = new RuleContext();        final JavaRuleViolation violation = new JavaRuleViolation(null, context, md, null);        assertEquals("Foo", violation.getClassName());    }    /**     * Tests that the class name is taken correctly, even if the node is outside     * of a class scope, e.g. a import declaration.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1529/">#1529</a>     */    @Test    public void testPackageAndClassNameForImport() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndClassNameForField() {        ASTCompilationUnit ast = parse("package pkg; public class Foo { int a; }");        ASTClassOrInterfaceDeclaration classDeclaration = ast.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        ASTFieldDeclaration field = ast.getFirstDescendantOfType(ASTFieldDeclaration.class);        JavaRuleViolation violation;        violation = new JavaRuleViolation(null, new RuleContext(), classDeclaration, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());        violation = new JavaRuleViolation(null, new RuleContext(), field, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndEnumName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public enum FooE { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("FooE", violation.getClassName());    }    @Test    public void testDefaultPackageAndClassName() {        ASTCompilationUnit ast = parse("import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndMultipleClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { } public class Bar { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Bar", violation.getClassName());    }    @Test    public void testPackageAndPackagePrivateClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    /**     * Test that the name of the inner class is taken correctly.     * Also check fields.     */    @Test    public void testInnerClass() {        ASTCompilationUnit ast = parse("class Foo { int a; class Bar { int a; } }");        List<ASTClassOrInterfaceDeclaration> classes = ast.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(2, classes.size());        JavaRuleViolation fooViolation = new JavaRuleViolation(null, new RuleContext(), classes.get(0), null);        assertEquals("Foo", fooViolation.getClassName());        JavaRuleViolation barViolation = new JavaRuleViolation(null, new RuleContext(), classes.get(1), null);        assertEquals("Foo$Bar", barViolation.getClassName());        List<ASTFieldDeclaration> fields = ast.findDescendantsOfType(ASTFieldDeclaration.class, true);        assertEquals(2, fields.size());        JavaRuleViolation fieldViolation = new JavaRuleViolation(null, new RuleContext(), fields.get(0), null);        assertEquals("Foo", fieldViolation.getClassName());        JavaRuleViolation innerFieldViolation = new JavaRuleViolation(null, new RuleContext(), fields.get(1), null);        assertEquals("Foo$Bar", innerFieldViolation.getClassName());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java16TreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java16 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("16")                    .withResourceContext(Java16TreeDumpTest.class, "jdkversiontests/java16/");    private final JavaParsingHelper java16p = java16.withDefaultVersion("16-preview");    private final JavaParsingHelper java15 = java16.withDefaultVersion("15");    public Java16TreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java16;    }    @Test    public void patternMatchingInstanceof() {        doTest("PatternMatchingInstanceof");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java16.parseResource("PatternMatchingInstanceof.java");        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);        for (ASTInstanceOfExpression expr : instanceOfExpressions) {            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);            Assert.assertEquals(String.class, variable.getType());            // Note: these variables are not part of the symbol table            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)            Assert.assertNull(variable.getNameDeclaration());        }    }    @Test(expected = ParseException.class)    public void patternMatchingInstanceofBeforeJava16ShouldFail() {        java15.parseResource("PatternMatchingInstanceof.java");    }    @Test    public void localClassAndInterfaceDeclarations() {        doTest("LocalClassAndInterfaceDeclarations");    }    @Test(expected = ParseException.class)    public void localClassAndInterfaceDeclarationsBeforeJava16ShouldFail() {        java15.parseResource("LocalClassAndInterfaceDeclarations.java");    }    @Test(expected = ParseException.class)    public void localAnnotationsAreNotAllowed() {        java16.parse("public class Foo { { @interface MyLocalAnnotation {} } }");    }    @Test    public void localRecords() {        doTest("LocalRecords");    }    @Test    public void recordPoint() {        doTest("Point");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java16.parseResource("Point.java");        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)                .findChildrenOfType(ASTRecordComponent.class);        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());        Assert.assertEquals("int", components.get(0).getVarId().getNameDeclaration().getTypeImage());    }    @Test(expected = ParseException.class)    public void recordPointBeforeJava16ShouldFail() {        java15.parseResource("Point.java");    }    @Test(expected = ParseException.class)    public void recordCtorWithThrowsShouldFail() {        java16.parse("  record R {"                + "   R throws IOException {}"                + "  }");    }    @Test(expected = ParseException.class)    public void recordMustNotExtend() {        java16.parse("record RecordEx(int x) extends Number { }");    }    @Test    public void innerRecords() {        doTest("Records");    }    @Test(expected = ParseException.class)    public void recordIsARestrictedIdentifier() {        java16.parse("public class record {}");    }    @Test    public void sealedAndNonSealedIdentifiers() {        doTest("NonSealedIdentifier");        java16p.parseResource("NonSealedIdentifier.java"); // make sure we can parse it with preview as well    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTPrimarySuffixTest extends BaseParserTest {    @Test    public void testArrayDereference() {        List<ASTPrimarySuffix> ops = java.getNodes(ASTPrimarySuffix.class, TEST1);        assertTrue(ops.get(0).isArrayDereference());    }    @Test    public void testArguments() {        List<ASTPrimarySuffix> ops = java.getNodes(ASTPrimarySuffix.class, TEST2);        assertTrue(ops.get(0).isArguments());    }    private static final String TEST1 = "public class Foo {\n  {x[0] = 2;}\n}";    private static final String TEST2 = "public class Foo {\n  {foo(a);}\n}";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java16PreviewTreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java16p =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("16-preview")                    .withResourceContext(Java16PreviewTreeDumpTest.class, "jdkversiontests/java16p/");    private final JavaParsingHelper java16 = java16p.withDefaultVersion("16");    public Java16PreviewTreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java16p;    }    @Test(expected = ParseException.class)    public void sealedClassBeforeJava16Preview() {        java16.parseResource("geometry/Shape.java");    }    @Test    public void sealedClass() {        doTest("geometry/Shape");    }    @Test    public void nonSealedClass() {        doTest("geometry/Square");    }    @Test(expected = ParseException.class)    public void sealedInterfaceBeforeJava15Preview() {        java16.parseResource("expression/Expr.java");    }    @Test    public void sealedInterface() {        doTest("expression/Expr");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java17TreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java17 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("17")                    .withResourceContext(Java17TreeDumpTest.class, "jdkversiontests/java17/");    private final JavaParsingHelper java17p = java17.withDefaultVersion("17-preview");    private final JavaParsingHelper java16 = java17.withDefaultVersion("16");    public Java17TreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java17;    }    @Test(expected = ParseException.class)    public void sealedClassBeforeJava17() {        java16.parseResource("geometry/Shape.java");    }    @Test    public void sealedClass() {        doTest("geometry/Shape");        java17p.parseResource("geometry/Shape.java"); // make sure we can parse it with preview as well    }    @Test    public void nonSealedClass() {        doTest("geometry/Square");        java17p.parseResource("geometry/Square.java"); // make sure we can parse it with preview as well    }    @Test(expected = ParseException.class)    public void sealedInterfaceBeforeJava17() {        java16.parseResource("expression/Expr.java");    }    @Test    public void sealedInterface() {        doTest("expression/Expr");        java17p.parseResource("expression/Expr.java"); // make sure we can parse it with preview as well    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTLiteralTest extends BaseParserTest {    @Test    public void testIsStringLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST1);        assertTrue(literals.get(0).isStringLiteral());    }    @Test    public void testIsNotStringLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST2);        assertFalse(literals.get(0).isStringLiteral());    }    @Test    public void testIsIntIntLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST3);        assertTrue(literals.get(0).isIntLiteral());    }    @Test    public void testIsIntLongLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST4);        assertTrue(literals.get(0).isLongLiteral());    }    @Test    public void testIsFloatFloatLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST5);        assertTrue(literals.get(0).isFloatLiteral());    }    @Test    public void testIsFloatDoubleLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST6);        assertTrue(literals.get(0).isDoubleLiteral());    }    @Test    public void testIsCharLiteral() {        List<ASTLiteral> literals = java.getNodes(ASTLiteral.class, TEST7);        assertTrue(literals.get(0).isCharLiteral());    }    @Test    public void testIntValueParsing() {        ASTLiteral literal = new ASTLiteral(1);        literal.setIntLiteral();        literal.setImage("1___234");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(1___234, literal.getValueAsInt());    }    @Test    public void testIntValueParsingBinary() {        ASTLiteral literal = new ASTLiteral(1);        literal.setIntLiteral();        literal.setImage("0b0000_0010");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(0b0000_0010, literal.getValueAsInt());    }    @Test    public void testIntValueParsingNegativeHexa() {        ASTLiteral literal = new ASTLiteral(1);        literal.setIntLiteral();        literal.setImage("-0X0000_000f");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(-0X0000_000f, literal.getValueAsInt());    }    @Test    public void testFloatValueParsingNegative() {        ASTLiteral literal = new ASTLiteral(1);        literal.setFloatLiteral();        literal.setImage("-3_456.123_456");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(-3_456.123_456f, literal.getValueAsFloat(), 0);    }    @Test    public void testStringUnicodeEscapesNotEscaped() {        ASTLiteral literal = new ASTLiteral(1);        literal.setStringLiteral();        literal.setImage("abcüabc");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals("abcüabc", literal.getEscapedStringLiteral());        assertEquals("abcüabc", literal.getImage());    }    @Test    public void testStringUnicodeEscapesInvalid() {        ASTLiteral literal = new ASTLiteral(1);        literal.setStringLiteral();        literal.setImage("abc\\uXYZAabc");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(12);        assertEquals("abc\\uXYZAabc", literal.getEscapedStringLiteral());        assertEquals("abc\\uXYZAabc", literal.getImage());    }    @Test    public void testStringUnicodeEscapesValid() {        ASTLiteral literal = new ASTLiteral(1);        literal.setStringLiteral();        literal.setImage("abc\u1234abc");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(12);        assertEquals("abc\\u1234abc", literal.getEscapedStringLiteral());        assertEquals("abcሴabc", literal.getImage());    }    @Test    public void testCharacterUnicodeEscapesValid() {        ASTLiteral literal = new ASTLiteral(1);        literal.setCharLiteral();        literal.setImage("\u0030");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(6);        assertEquals("\\u0030", literal.getEscapedStringLiteral());        assertEquals("0", literal.getImage());    }    private static final String TEST1 = "public class Foo {\n  String x = \"foo\";\n}";    private static final String TEST2 = "public class Foo {\n  int x = 42;\n}";    private static final String TEST3 = "public class Foo {\n  int x = 42;\n}";    private static final String TEST4 = "public class Foo {\n  long x = 42L;\n}";    private static final String TEST5 = "public class Foo {\n  float x = 3.14159f;\n}";    private static final String TEST6 = "public class Foo {\n  double x = 3.14159;\n}";    private static final String TEST7 = "public class Foo {\n  char x = 'x';\n}";    @Test    public void testTextBlockContent() {        assertEquals("empty text block", "",                ASTLiteral.determineTextBlockContent("\"\"\"\n                       \"\"\""));        assertEquals("single line text block", "winter",                ASTLiteral.determineTextBlockContent("\"\"\"\n                winter\"\"\""));        assertEquals("single line text block with LF", "winter\n",                ASTLiteral.determineTextBlockContent("\"\"\"\n"                                                   + "                        winter\n"                                                   + "                        \"\"\""));        assertEquals("basic text block example with html",                  "<html>\n"                + "    <body>\n"                + "        <p>Hello, world</p>\n"                + "    </body>\n"                + "</html>\n",                ASTLiteral.determineTextBlockContent("\"\"\"\n"                                                   + "                      <html>   \n"                                                   + "                          <body>\n"                                                   + "                              <p>Hello, world</p>    \n"                                                   + "                          </body> \n"                                                   + "                      </html>   \n"                                                   + "                      \"\"\""));        assertEquals("text block with escapes",                  "<html>\r\n"                + "    <body>\r\n"                + "        <p>Hello, world</p>\r\n"                + "    </body>\r\n"                + "</html>\r\n",                ASTLiteral.determineTextBlockContent("\"\"\"\n"                                                   + "                      <html>\\r\n"                                                   + "                          <body>\\r\n"                                                   + "                              <p>Hello, world</p>\\r\n"                                                   + "                          </body>\\r\n"                                                   + "                      </html>\\r\n"                                                   + "                      \"\"\""));        assertEquals("escaped text block in inside text block",                  "String text = \"\"\"\n"                + "    A text block inside a text block\n"                + "\"\"\";\n",                ASTLiteral.determineTextBlockContent("\"\"\"\n"                                                   + "            String text = \\\"\"\"\n"                                                   + "                A text block inside a text block\n"                                                   + "            \\\"\"\";\n"                                                   + "            \"\"\""));        assertEquals("new escape: line continuation",                  "Lorem ipsum dolor sit amet, consectetur adipiscing "                + "elit, sed do eiusmod tempor incididunt ut labore "                + "et dolore magna aliqua.",                ASTLiteral.determineTextBlockContent("\"\"\"\n"                                    + "                      Lorem ipsum dolor sit amet, consectetur adipiscing \\\n"                                    + "                      elit, sed do eiusmod tempor incididunt ut labore \\\n"                                    + "                      et dolore magna aliqua.\\\n"                                    + "                      \"\"\""));        assertEquals("new escape: space escape",                  "red   \n"                + "green \n"                + "blue  \n",                ASTLiteral.determineTextBlockContent("\"\"\"\n"                        + "                        red  \\s\n"                        + "                        green\\s\n"                        + "                        blue \\s\n"                        + "                        \"\"\""));        assertEquals("with crlf line endings",                  "<html>\n"                + "    <body>\n"                + "        <p>Hello, world</p>\n"                + "    </body>\n"                + "</html>\n", ASTLiteral.determineTextBlockContent("\"\"\"\r\n"                        + "                      <html>   \r\n"                        + "                          <body>\r\n"                        + "                              <p>Hello, world</p>    \r\n"                        + "                          </body> \r\n"                        + "                      </html>   \r\n"                        + "                      \"\"\""));        assertEquals("with cr line endings",                  "<html>\n"                + "    <body>\n"                + "        <p>Hello, world</p>\n"                + "    </body>\n"                + "</html>\n", ASTLiteral.determineTextBlockContent("\"\"\"\r"                        + "                      <html>   \r"                        + "                          <body>\r"                        + "                              <p>Hello, world</p>    \r"                        + "                          </body> \r"                        + "                      </html>   \r"                        + "                      \"\"\""));        assertEquals("empty line directly after opening",                "\ntest\n", ASTLiteral.determineTextBlockContent("\"\"\"\n"                        + "    \n"                        + "    test\n"                        + "    \"\"\""));        assertEquals("empty crlf line directly after opening",                "\ntest\n", ASTLiteral.determineTextBlockContent("\"\"\"\r\n"                        + "    \r\n"                        + "    test\r\n"                        + "    \"\"\""));        assertEquals("empty line directly after opening without indentation",                "\ntest\n", ASTLiteral.determineTextBlockContent("\"\"\"\n"                        + "\n"                        + "test\n"                        + "\"\"\""));        assertEquals("empty crlf line directly after opening without indentation",                "\ntest\n", ASTLiteral.determineTextBlockContent("\"\"\"\r\n"                        + "\r\n"                        + "test\r\n"                        + "\"\"\""));        assertEquals("text block with backslash escape", "\\test\n",                ASTLiteral.determineTextBlockContent("\"\"\"\n                \\\\test\n                \"\"\""));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class ClassDeclTest extends BaseParserTest {    @Test    public void testPublic() {        String[] access = {"public"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, false, false);    }    @Test    public void testAbstract() {        String[] access = { "abstract" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, true, false, false);    }    @Test    public void testFinal() {        String[] access = { "final" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, true, false);    }    @Test    public void testStrict() {        String[] access = { "strictfp" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, false, true);    }    @Test    public void testPublicFinal() {        String[] access = { "public", "final" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, true, false);    }    public void verifyFlags(ASTClassOrInterfaceDeclaration acd, boolean bPublic, boolean bAbstract, boolean bFinal,            boolean bStrict) {        assertEquals("Public: ", bPublic, acd.isPublic());        assertEquals("Abstract: ", bAbstract, acd.isAbstract());        assertEquals("Final: ", bFinal, acd.isFinal());        assertEquals("Strict: ", bStrict, acd.isStrictfp());    }    public ASTClassOrInterfaceDeclaration getClassDecl(String[] access) {        return AccessNodeTest.getDeclWithModifiers(access, ASTClassOrInterfaceDeclaration.class, "class Test {}");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java17PreviewTreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java17p =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("17-preview")                    .withResourceContext(Java17PreviewTreeDumpTest.class, "jdkversiontests/java17p/");    private final JavaParsingHelper java17 = java17p.withDefaultVersion("17");    public Java17PreviewTreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java17p;    }    @Test(expected = ParseException.class)    public void patternMatchingForSwitchBeforeJava17Preview() {        java17.parseResource("PatternsInSwitchLabels.java");    }    @Test(expected = ParseException.class)    public void dealingWithNullBeforeJava17Preview() {        java17.parseResource("DealingWithNull.java");    }    @Test    public void patternMatchingForSwitch() {        doTest("PatternsInSwitchLabels");    }    @Test    public void enhancedTypeCheckingSwitch() {        doTest("EnhancedTypeCheckingSwitch");    }    @Test    public void scopeOfPatternVariableDeclarations() {        doTest("ScopeOfPatternVariableDeclarations");    }    @Test    public void dealingWithNull() {        doTest("DealingWithNull");    }    @Test    @Ignore("not finished yet")    public void guardedAndParenthesizedPatterns() {        doTest("GuardedAndParenthesizedPatterns");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ast.AccessNodeTest.getDeclWithModifiers;import static org.junit.Assert.assertTrue;import org.junit.Test;public class FieldDeclTest extends BaseParserTest {    public ASTFieldDeclaration getFieldDecl(String[] access) {        return getDeclWithModifiers(access, ASTFieldDeclaration.class, "int j;");    }    @Test    public void testPublic() {        String[] access = { "public" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be public.", afd.isPublic());    }    @Test    public void testProtected() {        String[] access = { "protected" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be protected.", afd.isProtected());    }    @Test    public void testPrivate() {        String[] access = { "private" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());    }    @Test    public void testStatic() {        String[] access = { "private", "static" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be static.", afd.isStatic());        assertTrue("Expecting field to be private.", afd.isPrivate());    }    @Test    public void testFinal() {        String[] access = { "public", "final" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be final.", afd.isFinal());        assertTrue("Expecting field to be public.", afd.isPublic());    }    @Test    public void testTransient() {        String[] access = { "private", "transient" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());        assertTrue("Expecting field to be transient.", afd.isTransient());    }    @Test    public void testVolatile() {        String[] access = { "private", "volatile" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be volatile.", afd.isVolatile());        assertTrue("Expecting field to be private.", afd.isPrivate());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;public class ASTBlockStatementTest {    @Test    public void testIsAllocation() {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAllocationExpression(1), 0);        assertTrue(bs.isAllocation());    }    @Test    public void testIsAllocation2() {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAssertStatement(1), 0);        assertFalse(bs.isAllocation());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertTrue;import org.junit.Test;public class MethodDeclTest {    @Test    public void testPublic() {        String[] access = { "public" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testPrivate() {        String[] access = { "private" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be private.", amd.isPrivate());    }    @Test    public void testProtected() {        String[] access = { "protected" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be protected.", amd.isProtected());    }    @Test    public void testFinal() {        String[] access = { "public", "final" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be final.", amd.isFinal());        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testSynchronized() {        String[] access = { "public", "synchronized" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be synchronized.", amd.isSynchronized());        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testAbstract() {        String[] access = { "public", "abstract" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be abstract.", amd.isAbstract());        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testNative() {        String[] access = { "private", "native" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be native.", amd.isNative());        assertTrue("Expecting method to be private.", amd.isPrivate());    }    @Test    public void testStrict() {        String[] access = { "public", "strictfp" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be strict.", amd.isStrictfp());        assertTrue("Expecting method to be public.", amd.isPublic());    }    private ASTMethodDeclaration getMethodDecl(String[] access) {        return AccessNodeTest.getDeclWithModifiers(access, ASTMethodDeclaration.class, "void stuff(){}");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTImportDeclarationTest extends BaseParserTest {    @Test    public void testImportOnDemand() {        List<ASTImportDeclaration> ops = java.getNodes(ASTImportDeclaration.class, TEST1);        assertTrue(ops.get(0).isImportOnDemand());    }    @Test    public void testGetImportedNameNode() {        ASTImportDeclaration i = java.getNodes(ASTImportDeclaration.class, TEST2).get(0);        assertEquals("foo.bar.Baz", i.getImportedName());    }    @Test    public void testStaticImport() {        List<ASTImportDeclaration> ops = java.getNodes(ASTImportDeclaration.class, TEST3);        ASTImportDeclaration i = ops.get(0);        assertTrue(i.isStatic());    }    @Test(expected = ParseException.class)    public void testStaticImportFailsWithJDK14() {        java.parse(TEST3, "1.4");    }    private static final String TEST1 = "import foo.bar.*;\npublic class Foo {}";    private static final String TEST2 = "import foo.bar.Baz;\npublic class Foo {}";    private static final String TEST3 = "import static foo.bar.Baz;\npublic class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;public class ASTAnnotationTest extends BaseParserTest {    @Test    public void testAnnotationSucceedsWithDefaultMode() {        java.parse(TEST1);    }    @Test(expected = ParseException.class)    public void testAnnotationFailsWithJDK14() {        java.parse(TEST1, "1.4");    }    @Test    public void testAnnotationSucceedsWithJDK15() {        java.parse(TEST1, "1.5");    }    private static final String TEST1 =        "public class Foo extends Buz {\n @Override\n void bar() {\n  // overrides a superclass method\n }\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;public class ASTVariableDeclaratorIdTest extends BaseParserTest {    @Test    public void testIsExceptionBlockParameter() {        ASTCompilationUnit acu = java.parse(EXCEPTION_PARAMETER);        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(id.isExceptionBlockParameter());    }    @Test    public void testTypeNameNode() {        ASTCompilationUnit acu = java.parse(TYPE_NAME_NODE);        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode().getChild(0);        assertEquals("String", name.getImage());    }    @Test    public void testAnnotations() {        ASTCompilationUnit acu = java.parse(TEST_ANNOTATIONS);        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode().getChild(0);        assertEquals("String", name.getImage());    }    @Test    public void testLambdaWithType() throws Exception {        ASTCompilationUnit acu = java8.parse(TEST_LAMBDA_WITH_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertEquals("File", f.getTypeNode().getTypeImage());        assertEquals("File", f.getTypeNameNode().getChild(0).getImage());    }    @Test    public void testLambdaWithoutType() throws Exception {        ASTCompilationUnit acu = java8.parse(TEST_LAMBDA_WITHOUT_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertNull(f.getTypeNode());        assertNull(f.getTypeNameNode());    }    private static final String TYPE_NAME_NODE = "public class Test {\n  private String bar;\n}";    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    private static final String TEST_ANNOTATIONS = "public class Foo {\n    public void bar(@A1 @A2 String s) {}\n}";    private static final String TEST_LAMBDA_WITH_TYPE =        "public class Foo {\n    public void bar() {\n        FileFilter java = (File f) -> f.getName().endsWith(\".java\");\n    }\n}\n";    private static final String TEST_LAMBDA_WITHOUT_TYPE =        "public class Foo {\n    public void bar() {\n        FileFilter java2 = f -> f.getName().endsWith(\".java\");\n    }\n}\n";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ASTVariableDeclaratorIdTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTModuleDeclarationTest extends BaseParserTest {    @Test    public final void jdk9ModuleInfo() {        ASTCompilationUnit ast = java9.parseResource("jdkversiontests/jdk9_module_info.java");        List<ASTModuleDeclaration> modules = ast.findDescendantsOfType(ASTModuleDeclaration.class);        assertEquals(1, modules.size());        ASTModuleDeclaration module = modules.get(0);        assertTrue(module.isOpen());        assertEquals("com.example.foo", module.getImage());        assertEquals(7, module.getNumChildren());        List<ASTModuleDirective> directives = module.findChildrenOfType(ASTModuleDirective.class);        assertEquals(7, directives.size());        // requires com.example.foo.http;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(0).getType());        assertNull(directives.get(0).getRequiresModifier());        assertEquals("com.example.foo.http", directives.get(0).getFirstChildOfType(ASTModuleName.class).getImage());        // requires java.logging;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(1).getType());        assertNull(directives.get(1).getRequiresModifier());        assertEquals("java.logging", directives.get(1).getFirstChildOfType(ASTModuleName.class).getImage());        // requires transitive com.example.foo.network;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(2).getType());        assertEquals(ASTModuleDirective.RequiresModifier.TRANSITIVE.name(), directives.get(2).getRequiresModifier());        assertEquals("com.example.foo.network", directives.get(2).getFirstChildOfType(ASTModuleName.class).getImage());        // exports com.example.foo.bar;        assertEquals(ASTModuleDirective.DirectiveType.EXPORTS.name(), directives.get(3).getType());        assertNull(directives.get(3).getRequiresModifier());        assertEquals("com.example.foo.bar", directives.get(3).getFirstChildOfType(ASTName.class).getImage());        // exports com.example.foo.internal to com.example.foo.probe;        assertEquals(ASTModuleDirective.DirectiveType.EXPORTS.name(), directives.get(4).getType());        assertNull(directives.get(4).getRequiresModifier());        assertEquals("com.example.foo.internal", directives.get(4).getFirstChildOfType(ASTName.class).getImage());        assertEquals("com.example.foo.probe", directives.get(4).getFirstChildOfType(ASTModuleName.class).getImage());        // uses com.example.foo.spi.Intf;        assertEquals(ASTModuleDirective.DirectiveType.USES.name(), directives.get(5).getType());        assertNull(directives.get(5).getRequiresModifier());        assertEquals("com.example.foo.spi.Intf", directives.get(5).getFirstChildOfType(ASTName.class).getImage());        // provides com.example.foo.spi.Intf with com.example.foo.Impl;        assertEquals(ASTModuleDirective.DirectiveType.PROVIDES.name(), directives.get(6).getType());        assertNull(directives.get(6).getRequiresModifier());        assertEquals("com.example.foo.spi.Intf", directives.get(6).getFirstChildOfType(ASTName.class).getImage());        assertEquals("com.example.foo.Impl", directives.get(6).findChildrenOfType(ASTName.class).get(1).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.TokenMgrError;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class ParserCornersTest {    private static final String MULTICATCH = "public class Foo { public void bar() { "        + "try { System.out.println(); } catch (RuntimeException | IOException e) {} } }";    private final JavaParsingHelper java = JavaParsingHelper.WITH_PROCESSING.withResourceContext(ParserCornersTest.class);    private final JavaParsingHelper java8 = java.withDefaultVersion("1.8");    private final JavaParsingHelper java4 = java.withDefaultVersion("1.4");    private final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    private final JavaParsingHelper java7 = java.withDefaultVersion("1.7");    @Rule    public ExpectedException expect = ExpectedException.none();    @Test    public void testInvalidUnicodeEscape() {        expect.expect(TokenMgrError.class); // previously Error        expect.expectMessage("Lexical error in file (no file name provided) at line 1, column 2.  Encountered: Invalid unicode escape");        java.parse("\\u00k0");    }    /**     * #1107 PMD 5.0.4 couldn't parse call of parent outer java class method     * from inner class.     */    @Test    public void testInnerOuterClass() {        java7.parse("/**\n" + " * @author azagorulko\n" + " *\n" + " */\n"                        + "public class TestInnerClassCallsOuterParent {\n" + "\n" + "    public void test() {\n"                        + "        new Runnable() {\n" + "            @Override\n" + "            public void run() {\n"                        + "                TestInnerClassCallsOuterParent.super.toString();\n" + "            }\n"                        + "        };\n" + "    }\n" + "}\n");    }    /**     * #888 PMD 6.0.0 can't parse valid <> under 1.8.     */    @Test    public void testDiamondUsageJava8() {        java8.parse("public class PMDExceptionTest {\n"                + "  private Component makeUI() {\n"                + "    String[] model = {\"123456\", \"7890\"};\n"                + "    JComboBox<String> comboBox = new JComboBox<>(model);\n"                + "    comboBox.setEditable(true);\n"                + "    comboBox.setEditor(new BasicComboBoxEditor() {\n"                + "      private Component editorComponent;\n"                + "      @Override public Component getEditorComponent() {\n"                + "        if (editorComponent == null) {\n"                + "          JTextField tc = (JTextField) super.getEditorComponent();\n"                + "          editorComponent = new JLayer<>(tc, new ValidationLayerUI<>());\n"                + "        }\n"                + "        return editorComponent;\n"                + "      }\n"                + "    });\n"                + "    JPanel p = new JPanel();\n"                + "    p.add(comboBox);\n"                + "    return p;\n"                + "  }\n"                + "}");    }    @Test    public final void testGetFirstASTNameImageNull() {        java4.parse(ABSTRACT_METHOD_LEVEL_CLASS_DECL);    }    @Test    public final void testCastLookaheadProblem() {        java4.parse(CAST_LOOKAHEAD_PROBLEM);    }    /**     * Tests a specific generic notation for calling methods. See:     * https://jira.codehaus.org/browse/MPMD-139     */    @Test    public void testGenericsProblem() {        java5.parse(GENERICS_PROBLEM);        java7.parse(GENERICS_PROBLEM);    }    @Test    public void testParsersCases15() {        java5.parseResource("ParserCornerCases.java");    }    @Test    public void testParsersCases17() {        java7.parseResource("ParserCornerCases17.java");    }    @Test    public void testParsersCases18() throws Exception {        ASTCompilationUnit cu = java8.parseResource("ParserCornerCases18.java");        Assert.assertEquals(21, cu.findChildNodesWithXPath("//FormalParameter").size());        Assert.assertEquals(4,                cu.findChildNodesWithXPath("//FormalParameter[@ExplicitReceiverParameter='true']").size());        Assert.assertEquals(17,                cu.findChildNodesWithXPath("//FormalParameter[@ExplicitReceiverParameter='false']").size());    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1333/     */    @Test    public void testLambdaBug1333() {        java8.parse("final class Bug1333 {\n"                        + "    private static final Logger LOG = LoggerFactory.getLogger(Foo.class);\n" + "\n"                        + "    public void deleteDirectoriesByNamePattern() {\n"                        + "        delete(path -> deleteDirectory(path));\n" + "    }\n" + "\n"                        + "    private void delete(Consumer<? super String> consumer) {\n"                        + "        LOG.debug(consumer.toString());\n" + "    }\n" + "\n"                        + "    private void deleteDirectory(String path) {\n" + "        LOG.debug(path);\n" + "    }\n"                        + "}");    }    @Test    public void testLambdaBug1470() {        java8.parseResource("LambdaBug1470.java");    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1355/     */    @Test    public void emptyFileJustComment() {        java8.parse("// just a comment");    }    @Test    public void testMultipleExceptionCatchingJava5() {        expect.expect(ParseException.class);        expect.expectMessage("Line 1, Column 94: Cannot catch multiple exceptions when running in JDK inferior to 1.7 mode!");        java5.parse(MULTICATCH);    }    @Test    public void testMultipleExceptionCatchingJava7() {        java7.parse(MULTICATCH);    }    @Test    public void testBug1429ParseError() {        java8.parseResource("Bug1429.java");    }    @Test    public void testBug1530ParseError() {        java8.parseResource("Bug1530.java");    }    @Test    public void testGitHubBug207() {        java8.parseResource("GitHubBug207.java");    }    @Test    public void testLambda2783() {        java8.parseResource("LambdaBug2783.java");    }    @Test    public void testGitHubBug2767() {        // PMD fails to parse an initializer block.        // PMD 6.26.0 parses this code just fine.        java.withDefaultVersion("15-preview")            .parse("class Foo {\n"                       + "    {final int I;}\n"                       + "}\n");    }    @Test    public void testBug206() {        java8.parse("public @interface Foo {" + "\n"                        + "static final ThreadLocal<Interner<Integer>> interner =" + "\n"                        + "    ThreadLocal.withInitial(Interners::newStrongInterner);" + "\n"                        + "}");    }    @Test    public void testGitHubBug208ParseError() {        java5.parseResource("GitHubBug208.java");    }    @Test    public void testGitHubBug257NonExistingCast() {        String code = "public class Test {" + "\n"            + "     public static void main(String[] args) {" + "\n"            + "         double a = 4.0;" + "\n"            + "         double b = 2.0;" + "\n"            + "         double result = Math.sqrt((a)   - b);" + "\n"            + "         System.out.println(result);" + "\n"            + "     }" + "\n"            + "}";        assertEquals("A cast was found when none expected",                     0,                     java5.parse(code).findDescendantsOfType(ASTCastExpression.class).size());    }    @Test    public void testGitHubBug309() {        java8.parseResource("GitHubBug309.java");    }    @Test(timeout = 30000)    public void testInfiniteLoopInLookahead() {        expect.expect(ParseException.class);        // https://github.com/pmd/pmd/issues/3117        java8.parseResource("InfiniteLoopInLookahead.java");    }    /**     * This triggered bug #1484 UnusedLocalVariable - false positive -     * parenthesis     */    @Test    public void stringConcatentationShouldNotBeCast() {        String code = "public class Test {\n" + "    public static void main(String[] args) {\n"            + "        System.out.println(\"X\" + (args) + \"Y\");\n" + "    }\n" + "}";        Assert.assertEquals(0, java8.parse(code).findDescendantsOfType(ASTCastExpression.class).size());    }    /**     * Empty statements should be allowed.     * @throws Exception     * @see <a href="https://github.com/pmd/pmd/issues/378">github issue 378</a>     */    @Test    public void testParseEmptyStatements() {        String code = "import a;;import b; public class Foo {}";        ASTCompilationUnit cu = java8.parse(code);        assertNotNull(cu);        Assert.assertEquals(ASTEmptyStatement.class, cu.getChild(1).getClass());        String code2 = "package c;; import a; import b; public class Foo {}";        ASTCompilationUnit cu2 = java8.parse(code2);        assertNotNull(cu2);        Assert.assertEquals(ASTEmptyStatement.class, cu2.getChild(1).getClass());        String code3 = "package c; import a; import b; public class Foo {};";        ASTCompilationUnit cu3 = java8.parse(code3);        assertNotNull(cu3);        Assert.assertEquals(ASTEmptyStatement.class, cu3.getChild(4).getClass());    }    @Test    public void testMethodReferenceConfused() {        ASTCompilationUnit compilationUnit = java.parseResource("MethodReferenceConfused.java", "10");        ASTBlock firstBlock = compilationUnit.getFirstDescendantOfType(ASTBlock.class);        Map<NameDeclaration, List<NameOccurrence>> declarations = firstBlock.getScope().getDeclarations();        boolean foundVariable = false;        for (Map.Entry<NameDeclaration, List<NameOccurrence>> declaration : declarations.entrySet()) {            String varName = declaration.getKey().getImage();            if ("someVarNameSameAsMethodReference".equals(varName)) {                foundVariable = true;                Assert.assertTrue("no usages expected", declaration.getValue().isEmpty());            } else if ("someObject".equals(varName)) {                Assert.assertEquals("1 usage expected", 1, declaration.getValue().size());                Assert.assertEquals(6, declaration.getValue().get(0).getLocation().getBeginLine());            }        }        Assert.assertTrue("Test setup wrong - variable 'someVarNameSameAsMethodReference' not found anymore!", foundVariable);    }    @Test    public void testSwitchWithFallthrough() {        ASTCompilationUnit compilationUnit = java.parseResource("SwitchWithFallthrough.java", "11");        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertEquals(2, switchStatement.findChildrenOfType(ASTSwitchLabel.class).size());    }    @Test    public void testSwitchStatements() {        ASTCompilationUnit compilationUnit = java.parseResource("SwitchStatements.java", "11");        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertEquals(2, switchStatement.findChildrenOfType(ASTSwitchLabel.class).size());    }    private static final String GENERICS_PROBLEM =        "public class Test {\n public void test() {\n   String o = super.<String> doStuff(\"\");\n }\n}";    private static final String ABSTRACT_METHOD_LEVEL_CLASS_DECL =        "public class Test {\n"            + "  void bar() {\n"            + "   abstract class X { public abstract void f(); }\n"            + "   class Y extends X { public void f() { new Y().f(); } }\n"            + "  }\n"            + "}";    private static final String CAST_LOOKAHEAD_PROBLEM =        "public class BadClass {\n  public Class foo() {\n    return (byte[].class);\n  }\n}";    @Test    public void testGithubBug3101UnresolvedTypeParams() {        java.parseResource("GitHubBug3101.java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class ASTLocalVariableDeclarationTest extends BaseParserTest {    @Test    public void testSingleDimArray() {        ASTLocalVariableDeclaration node = java.parse(TEST1).findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(1, node.getArrayDepth());    }    @Test    public void testMultDimArray() {        ASTLocalVariableDeclaration node = java.parse(TEST2).findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(2, node.getArrayDepth());    }    @Test    public void testMultDimArraySplitBraces() {        ASTLocalVariableDeclaration node = java.parse(TEST3).findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    private static final String TEST1 = "class Foo {\n void bar() {int x[] = null;}\n}";    private static final String TEST2 = "class Foo {\n void bar() {int x[][] = null;}\n}";    private static final String TEST3 = "class Foo {\n void bar() {int[] x[][] = null;}\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import org.junit.Test;/** * Created on Jan 19, 2005 * @author mgriffa */public class ASTThrowStatementTest extends BaseParserTest {    @Test    public final void testGetFirstASTNameImageNull() {        ASTThrowStatement t = java.getNodes(ASTThrowStatement.class, NULL_NAME).get(0);        assertNull(t.getFirstClassOrInterfaceTypeImage());    }    @Test    public final void testGetFirstASTNameImageNew() {        ASTThrowStatement t = java.getNodes(ASTThrowStatement.class, OK_NAME).get(0);        assertEquals("FooException", t.getFirstClassOrInterfaceTypeImage());    }    private static final String NULL_NAME = "public class Test {\n  void bar() {\n   throw e;\n  }\n}";    private static final String OK_NAME = "public class Test {\n  void bar() {\n   throw new FooException();\n  }\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.testdata.InterfaceWithNestedClass;public class ASTFieldDeclarationTest extends BaseParserTest {    @Test    public void testIsArray() {        ASTCompilationUnit cu = java.parse(TEST1);        Dimensionable node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertTrue(node.isArray());        assertEquals(1, node.getArrayDepth());    }    @Test    public void testMultiDimensionalArray() {        ASTCompilationUnit cu = java.parse(TEST2);        Dimensionable node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    @Test    public void testIsSyntacticallyPublic() {        ASTCompilationUnit cu = java.parse(TEST3);        ASTFieldDeclaration node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isSyntacticallyPublic());        assertFalse(node.isPackagePrivate());        assertFalse(node.isPrivate());        assertFalse(node.isProtected());        assertTrue(node.isFinal());        assertTrue(node.isStatic());        assertTrue(node.isPublic());    }    @Test    public void testWithEnum() {        ASTCompilationUnit cu = java5.parse(TEST4);        ASTFieldDeclaration node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isInterfaceMember());    }    @Test    public void testWithAnnotation() {        ASTCompilationUnit cu = java5.parse(TEST5);        ASTFieldDeclaration node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isInterfaceMember());        assertTrue(node.isAnnotationMember());    }    private static final String TEST1 = "class Foo {\n String[] foo;\n}";    private static final String TEST2 = "class Foo {\n String[][][] foo;\n}";    private static final String TEST3 = "interface Foo {\n int BAR = 6;\n}";    private static final String TEST4 = "public enum Foo {\n FOO(1);\n private int x;\n}";    private static final String TEST5 = "public @interface Foo {\n int BAR = 6;\n}";    @Test    public void testGetVariableName() {        int id = 0;        ASTFieldDeclaration n = new ASTFieldDeclaration(id++);        ASTType t = new ASTType(id++);        ASTVariableDeclarator decl = new ASTVariableDeclarator(id++);        ASTVariableDeclaratorId declid = new ASTVariableDeclaratorId(id++);        n.jjtAddChild(t, 0);        t.jjtAddChild(decl, 0);        decl.jjtAddChild(declid, 0);        declid.setImage("foo");        assertEquals("foo", n.getVariableName());    }    @Test    public void testPrivateFieldInNestedClassInsideInterface() {        ASTCompilationUnit cu = JavaParsingHelper.WITH_PROCESSING.parseClass(InterfaceWithNestedClass.class, "10");        List<ASTFieldDeclaration> fields = cu.findDescendantsOfType(ASTFieldDeclaration.class, true);        assertEquals(2, fields.size());        assertEquals("MAPPING", fields.get(0).getFirstDescendantOfType(ASTVariableDeclaratorId.class).getImage());        assertTrue(fields.get(0).isPublic());        assertFalse(fields.get(0).isPrivate());        assertEquals("serialVersionUID", fields.get(1).getFirstDescendantOfType(ASTVariableDeclaratorId.class).getImage());        assertFalse(fields.get(1).isPublic());        assertTrue(fields.get(1).isPrivate());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java15PreviewTreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java15p =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("15-preview")                    .withResourceContext(Java15PreviewTreeDumpTest.class, "jdkversiontests/java15p/");    private final JavaParsingHelper java15 = java15p.withDefaultVersion("15");    public Java15PreviewTreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java15p;    }    @Test    public void patternMatchingInstanceof() {        doTest("PatternMatchingInstanceof");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java15p.parseResource("PatternMatchingInstanceof.java");        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);        for (ASTInstanceOfExpression expr : instanceOfExpressions) {            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);            Assert.assertEquals(String.class, variable.getType());            // Note: these variables are not part of the symbol table            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)            Assert.assertNull(variable.getNameDeclaration());        }    }    @Test(expected = ParseException.class)    public void patternMatchingInstanceofBeforeJava15PreviewShouldFail() {        java15.parseResource("PatternMatchingInstanceof.java");    }    @Test    public void recordPoint() {        doTest("Point");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java15p.parseResource("Point.java");        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)                .findChildrenOfType(ASTRecordComponent.class);        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());        Assert.assertEquals("int", components.get(0).getVarId().getNameDeclaration().getTypeImage());    }    @Test(expected = ParseException.class)    public void recordPointBeforeJava15PreviewShouldFail() {        java15.parseResource("Point.java");    }    @Test(expected = ParseException.class)    public void recordCtorWithThrowsShouldFail() {        java15p.parse("  record R {"                + "   R throws IOException {}"                + "  }");    }    @Test(expected = ParseException.class)    public void recordMustNotExtend() {        java15p.parse("record RecordEx(int x) extends Number { }");    }    @Test    public void innerRecords() {        doTest("Records");    }    @Test(expected = ParseException.class)    public void recordIsARestrictedIdentifier() {        java15p.parse("public class record {}");    }    @Test    public void localRecords() {        doTest("LocalRecords");    }    @Test(expected = ParseException.class)    public void sealedClassBeforeJava15Preview() {        java15.parseResource("geometry/Shape.java");    }    @Test    public void sealedClass() {        doTest("geometry/Shape");    }    @Test    public void nonSealedClass() {        doTest("geometry/Square");    }    @Test(expected = ParseException.class)    public void sealedInterfaceBeforeJava15Preview() {        java15.parseResource("expression/Expr.java");    }    @Test    public void sealedInterface() {        doTest("expression/Expr");    }    @Test    public void localInterfaceAndEnums() {        doTest("LocalInterfacesAndEnums");    }    @Test(expected = ParseException.class)    public void localInterfacesAndEnumsBeforeJava15PreviewShouldFail() {        java15.parseResource("LocalInterfacesAndEnums.java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * @author Clément Fournier * @since 6.1.0 */public class ASTClassOrInterfaceDeclarationTest {    private static final String LOCAL_CLASS_IN_METHOD            = "class Foo { void bar() { class Local {}}}";    private static final String NESTED_CLASS_IS_NOT_LOCAL            = "class Foo { class Nested {} void bar() {}}";    private static final String LOCAL_CLASS_IN_INITIALIZER            = "class Foo { { class Local {} } }";    private static final String LOCAL_CLASS_WITH_MODIFIERS            = "class Foo { { abstract class Local {} } }";    private static final String LOCAL_CLASS_WITH_MIXED_MODIFIER_ANNOTATIONS            = "class Foo { { final @F class Local {} } }";    private static final String LOCAL_CHILDREN_ARE_NOT_ALWAYS_LOCAL            = "class Foo { { class Local { class Nested {} void bar() {class Local2 {}}}}}";    @Test    public void testLocalInMethod() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(LOCAL_CLASS_IN_METHOD);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());    }    @Test    public void testLocalInInitializer() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(LOCAL_CLASS_IN_INITIALIZER);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());    }    @Test    public void testLocalAbstractClass() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(LOCAL_CLASS_WITH_MODIFIERS);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());        assertTrue("Local class should preserve its modifiers", classes.get(1).isAbstract());    }    @Test    public void testLocalClassWithMixedModifiers() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(LOCAL_CLASS_WITH_MIXED_MODIFIER_ANNOTATIONS);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());        assertTrue("Local class should preserve its modifiers", classes.get(1).isFinal());    }    @Test    public void testLocalClassVisibility() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(LOCAL_CLASS_WITH_MODIFIERS);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());        assertFalse("Local class is not public", classes.get(1).isPublic());        assertFalse("Local class is not private", classes.get(1).isPrivate());        assertFalse("Local class is not protected", classes.get(1).isProtected());        assertFalse("Local class is not package-private", classes.get(1).isPackagePrivate());    }    @Test    public void testNestedClassIsNotLocal() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(NESTED_CLASS_IS_NOT_LOCAL);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertFalse("Local class false-positive", classes.get(1).isLocal());    }    @Test    public void testLocalChildrenAreNotAlwaysLocal() {        List<ASTClassOrInterfaceDeclaration> classes = getClassDecls(LOCAL_CHILDREN_ARE_NOT_ALWAYS_LOCAL);        assertTrue(classes.size() == 4);        assertFalse("Local class false-positive", classes.get(0).isLocal()); // class Foo        assertTrue("Local class false-negative", classes.get(1).isLocal());  // class Local        assertFalse("Local class false-positive", classes.get(2).isLocal()); // class Nested        assertTrue("Local class false-negative", classes.get(3).isLocal());  // class Local2    }    private List<ASTClassOrInterfaceDeclaration> getClassDecls(String code) {        return JavaParsingHelper.WITH_PROCESSING.getNodes(ASTClassOrInterfaceDeclaration.class, code);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Assert;import org.junit.Test;public class ASTSwitchStatementTest extends BaseParserTest {    @Test    public void exhaustiveEnumSwitchWithDefault() {        ASTSwitchStatement switchStatement = getNodes(ASTSwitchStatement.class,                "import java.nio.file.AccessMode; class Foo { void bar(AccessMode m) {"                + "switch (m) { case READ: break; default: break; } } }")                .get(0);        Assert.assertFalse(switchStatement.isExhaustiveEnumSwitch()); // this should not throw a NPE...        Assert.assertTrue(switchStatement.hasDefaultCase());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;public class ASTInitializerTest extends BaseParserTest {    @Test    public void testDontCrashOnBlockStatement() {        java.parse(TEST1);    }    private static final String TEST1 = "public class Foo {\n {\n   x = 5;\n }\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class AccessNodeTest extends BaseParserTest {    public static class MyAccessNode extends AbstractJavaAccessNode {        public MyAccessNode(int i) {            super(i);        }        public MyAccessNode(JavaParser parser, int i) {            super(parser, i);        }    }    @Test    public void testModifiersOnClassDecl() {        List<ASTClassOrInterfaceDeclaration> ops = java.getNodes(ASTClassOrInterfaceDeclaration.class, TEST1);        assertTrue(ops.get(0).isPublic());    }    private static final String TEST1 = "public class Foo {}";    @Test    public void testStatic() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not static.", node.isStatic());        node.setStatic(true);        assertTrue("Node set to static, not static.", node.isStatic());    }    @Test    public void testPublic() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not public.", node.isPublic());        node.setPublic(true);        assertTrue("Node set to public, not public.", node.isPublic());    }    @Test    public void testProtected() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not protected.", node.isProtected());        node.setProtected(true);        assertTrue("Node set to protected, not protected.", node.isProtected());    }    @Test    public void testPrivate() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not private.", node.isPrivate());        node.setPrivate(true);        assertTrue("Node set to private, not private.", node.isPrivate());    }    @Test    public void testFinal() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not final.", node.isFinal());        node.setFinal(true);        assertTrue("Node set to final, not final.", node.isFinal());    }    @Test    public void testSynchronized() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not synchronized.", node.isSynchronized());        node.setSynchronized(true);        assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());    }    @Test    public void testVolatile() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not volatile.", node.isVolatile());        node.setVolatile(true);        assertTrue("Node set to volatile, not volatile.", node.isVolatile());    }    @Test    public void testTransient() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not transient.", node.isTransient());        node.setTransient(true);        assertTrue("Node set to transient, not transient.", node.isTransient());    }    @Test    public void testNative() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not native.", node.isNative());        node.setNative(true);        assertTrue("Node set to native, not native.", node.isNative());    }    @Test    public void testAbstract() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not abstract.", node.isAbstract());        node.setAbstract(true);        assertTrue("Node set to abstract, not abstract.", node.isAbstract());    }    @Test    public void testStrict() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not strict.", node.isStrictfp());        node.setStrictfp(true);        assertTrue("Node set to strict, not strict.", node.isStrictfp());    }    @Test    public void testPackagePrivate() {        AccessNode node = new MyAccessNode(1);        assertTrue("Node should default to package private.", node.isPackagePrivate());        node.setPrivate(true);        assertFalse("Node set to private, still package private.", node.isPackagePrivate());        node = new MyAccessNode(1);        node.setPublic(true);        assertFalse("Node set to public, still package private.", node.isPackagePrivate());        node = new MyAccessNode(1);        node.setProtected(true);        assertFalse("Node set to protected, still package private.", node.isPackagePrivate());    }    private static String makeAccessJavaCode(String[] access, String declRest) {        String result = "public class Test { ";        for (String s : access) {            result += s + " ";        }        return result + " " + declRest + " }";    }    public static <T extends Node> T getDeclWithModifiers(String[] access, Class<T> target, String declRest) {        ASTCompilationUnit acu = JavaParsingHelper.JUST_PARSE.parse(makeAccessJavaCode(access, declRest));        List<T> declarations = acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class)                            .findDescendantsOfType(target);        assertEquals("Wrong number of declarations", 1, declarations.size());        return declarations.get(0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class ASTPackageDeclarationTest extends BaseParserTest {    private static final String PACKAGE_INFO_ANNOTATED = "@Deprecated\npackage net.sourceforge.pmd.foobar;\n";    /**     * Regression test for bug 3524607.     */    @Test    public void testPackageName() {        ASTCompilationUnit nodes = java.parse(PACKAGE_INFO_ANNOTATED);        assertEquals("net.sourceforge.pmd.foobar", nodes.getPackageDeclaration().getName());        assertEquals("net.sourceforge.pmd.foobar", nodes.getPackageName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class EncodingTest extends BaseParserTest {    @Test    public void testDecodingOfUTF8() {        ASTCompilationUnit acu = java.parse(TEST_UTF8);        String methodName = acu.findDescendantsOfType(ASTMethodDeclarator.class).get(0).getImage();        assertEquals("é", methodName);    }    private static final String TEST_UTF8 = "class Foo {\n  void é() {}\n  void fiddle() {}\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import java.io.FileInputStream;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;public class Java10Test {    private final JavaParsingHelper java10 =        JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("10")                                         .withResourceContext(Java10Test.class, "jdkversiontests/java10/");    private final JavaParsingHelper java9 = java10.withDefaultVersion("9");    @Test    public void testLocalVarInferenceBeforeJava10() {        // note, it can be parsed, but we'll have a ReferenceType of "var"        List<ASTLocalVariableDeclaration> localVars = java9.parseResource("LocalVariableTypeInference.java")                                                           .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        // first: var list = new ArrayList<String>();        ASTType type = localVars.get(0).getFirstChildOfType(ASTType.class);        assertEquals("var", type.getTypeImage());        assertEquals(1, type.getNumChildren());        ASTReferenceType referenceType = type.getFirstChildOfType(ASTReferenceType.class);        assertNotNull(referenceType);        assertEquals(1, referenceType.getNumChildren());        ASTClassOrInterfaceType classType = referenceType.getFirstChildOfType(ASTClassOrInterfaceType.class);        assertNotNull(classType);        assertEquals("var", classType.getImage());        // in that case, we don't have a class named "var", so the type will be null        assertNull(classType.getType());        assertNull(type.getType());        // check the type of the variable initializer's expression        ASTExpression initExpression = localVars.get(0)                .getFirstChildOfType(ASTVariableDeclarator.class)                .getFirstChildOfType(ASTVariableInitializer.class)                .getFirstChildOfType(ASTExpression.class);        assertSame("type should be ArrayList", ArrayList.class, initExpression.getType());    }    @Test    public void testLocalVarInferenceCanBeParsedJava10() {        ASTCompilationUnit compilationUnit = java10.parseResource("LocalVariableTypeInference.java");        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        // first: var list = new ArrayList<String>();        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be ArrayList", ArrayList.class, varDecl.getType());        assertEquals("type should be ArrayList<String>", JavaTypeDefinition.forClass(ArrayList.class, JavaTypeDefinition.forClass(String.class)),                varDecl.getTypeDefinition());        ASTVariableDeclaratorId varId = varDecl.getFirstChildOfType(ASTVariableDeclaratorId.class);        assertEquals("type should be equal", varDecl.getTypeDefinition(), varId.getTypeDefinition());        // second: var stream = list.stream();        assertNull(localVars.get(1).getTypeNode());        //ASTVariableDeclarator varDecl2 = localVars.get(1).getFirstChildOfType(ASTVariableDeclarator.class);        // TODO: return type of method call is unknown        // assertEquals("type should be Stream<String>", JavaTypeDefinition.forClass(Stream.class, JavaTypeDefinition.forClass(String.class)),        //         varDecl2.getTypeDefinition());        // third: var s = "Java 10";        assertNull(localVars.get(2).getTypeNode());        ASTVariableDeclarator varDecl3 = localVars.get(2).getFirstChildOfType(ASTVariableDeclarator.class);        assertEquals("type should be String", JavaTypeDefinition.forClass(String.class), varDecl3.getTypeDefinition());        ASTArgumentList argumentList = compilationUnit.getFirstDescendantOfType(ASTArgumentList.class);        ASTExpression expression3 = argumentList.getFirstChildOfType(ASTExpression.class);        assertEquals("type should be String", JavaTypeDefinition.forClass(String.class), expression3.getTypeDefinition());    }    @Test    public void testForLoopWithVar() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoop.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be int", Integer.TYPE, varDecl.getType());    }    @Test    public void testForLoopEnhancedWithVar() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoopEnhanced.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be String", String.class, varDecl.getType());    }    @Test    public void testForLoopEnhancedWithVar2() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoopEnhanced2.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(4, localVars.size());        assertNull(localVars.get(1).getTypeNode());        ASTVariableDeclarator varDecl2 = localVars.get(1).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be String", String.class, varDecl2.getType());        ASTVariableDeclaratorId varId2 = varDecl2.getFirstChildOfType(ASTVariableDeclaratorId.class);        assertSame("type should be String", String.class, varId2.getType());        assertNull(localVars.get(3).getTypeNode());        ASTVariableDeclarator varDecl4 = localVars.get(3).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be int", Integer.TYPE, varDecl4.getType());    }    @Test    public void testTryWithResourcesWithVar() {        List<ASTResource> resources = java10.parseResource("LocalVariableTypeInferenceTryWithResources.java")                                            .findDescendantsOfType(ASTResource.class);        assertEquals(1, resources.size());        assertNull(resources.get(0).getTypeNode());        ASTVariableDeclaratorId varId = resources.get(0).getVariableDeclaratorId();        assertSame("type should be FileInputStream", FileInputStream.class, varId.getType());    }    @Test    public void testTypeResNullPointer() {        java10.parseResource("LocalVariableTypeInference_typeres.java");    }    @Test    public void testVarAsIdentifier() {        java10.parseResource("LocalVariableTypeInference_varAsIdentifier.java");    }    @Test(expected = ParseException.class)    public void testVarAsTypeIdentifier() {        java10.parseResource("LocalVariableTypeInference_varAsTypeIdentifier.java");    }    @Test(expected = ParseException.class)    public void testVarAsAnnotationName() {        java10.parseResource("LocalVariableTypeInference_varAsAnnotationName.java");    }    @Test(expected = ParseException.class)    public void testVarAsEnumName() {        java10.parseResource("LocalVariableTypeInference_varAsEnumName.java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;public class CommentTest {    @Test    public void testMultiLinesInSingleLine() {        String comment = "/* single line. */";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInSingleLineSimple() {        String comment = "// single line.";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInSingleLineFormal() {        String comment = "/** single line. */";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInMultiLine() {        String comment =                  "/*\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineCrLf() {        String comment =                  "/*\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineFormal() {        String comment =                  "/**\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineFormalCrLf() {        String comment =                  "/**\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineNoAsteriskEmpty() {        String comment =                  "/**\n"                + " * line 1\n"                + "line 2\n"                + "\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    private String filter(String comment) {        Token t = new Token();        t.image = comment;        Comment node = new Comment(t) {        };        return node.getFilteredComment();    }    private int lineCount(String filtered) {        return StringUtils.countMatches(filtered, PMD.EOL) + 1;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Test;public class CommentUtilTest {    @Test    public void testFindJavaDocTags() {        String formalComment =                  "/**\n"                + " * @see something\n"                + " * @author Author1\n"                + " * @author Author2\n"                + " * @param parm1 description\n"                + " */\n";        Map<String, Integer> javadocTagsIn = CommentUtil.javadocTagsIn(formalComment);        Assert.assertEquals(3, javadocTagsIn.size());        Assert.assertEquals(7, javadocTagsIn.get("see").intValue());        Assert.assertEquals("@see", formalComment.substring(7, 7 + 4));        Assert.assertEquals("@author", formalComment.substring(javadocTagsIn.get("author"),                javadocTagsIn.get("author") + "author".length() + 1));    }    @Test    public void testFindJavaDocTagsEmpty() {        Map<String, Integer> javadocTagsIn = CommentUtil.javadocTagsIn("");        Assert.assertEquals(0, javadocTagsIn.size());    }    @Test    public void testFindJavaDocTagsNull() {        Map<String, Integer> javadocTagsIn = CommentUtil.javadocTagsIn(null);        Assert.assertEquals(0, javadocTagsIn.size());    }    @Test    public void testMultiLinesInSingleLine() {        String comment = "/* single line. */";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(1, lines.size());        Assert.assertEquals("single line.", lines.get(0));    }    @Test    public void testMultiLinesInSingleLineSimple() {        String comment = "// single line.";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(1, lines.size());        Assert.assertEquals("single line.", lines.get(0));    }    @Test    public void testMultiLinesInSingleLineFormal() {        String comment = "/** single line. */";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(1, lines.size());        Assert.assertEquals("single line.", lines.get(0));    }    @Test    public void testMultiLinesInMultiLine() {        String comment =                  "/*\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineCrLf() {        String comment =                  "/*\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineFormal() {        String comment =                  "/**\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineFormalCrLf() {        String comment =                  "/**\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineNoAsteriskEmpty() {        String comment =                  "/**\n"                + " * line 1\n"                + "line 2\n"                + "\n"                + " */\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testTrim() {        List<String> lines = Arrays.asList("", "a", "", "");        List<String> trimmed = CommentUtil.trim(lines);        Assert.assertEquals(1, trimmed.size());        Assert.assertEquals("a", trimmed.get(0));    }    @Test    public void testTrimNotMiddle() {        List<String> lines = Arrays.asList("a", "b", "", "c");        List<String> trimmed = CommentUtil.trim(lines);        Assert.assertEquals(4, trimmed.size());        Assert.assertEquals("a", trimmed.get(0));        Assert.assertEquals("b", trimmed.get(1));        Assert.assertEquals("", trimmed.get(2));        Assert.assertEquals("c", trimmed.get(3));    }    @Test    public void testTrimEmpty() {        List<String> trimmed = CommentUtil.trim(new ArrayList<String>());        Assert.assertEquals(0, trimmed.size());    }    @Test    public void testTrimNull() {        List<String> trimmed = CommentUtil.trim(null);        Assert.assertEquals(0, trimmed.size());    }    @Test    public void testWordAfter() {        String wordAfter = CommentUtil.wordAfter("@param param1 Description", "@param".length());        Assert.assertEquals("param1", wordAfter);    }    @Test    public void testWordAfterPositionOutOfBounds() {        String wordAfter = CommentUtil.wordAfter("@param param1 Description", Integer.MAX_VALUE);        Assert.assertNull(wordAfter);    }    @Test    public void testWordAfterNull() {        String wordAfter = CommentUtil.wordAfter(null, 0);        Assert.assertNull(wordAfter);    }    @Test    public void testJavadocAfter() {        String javadocContentAfter = CommentUtil.javadocContentAfter("@param param1 The Description\n",                "@param param1".length());        Assert.assertEquals("The Description", javadocContentAfter);    }    @Test    public void testJavadocAfterOutOfBounds() {        String javadocContentAfter = CommentUtil.javadocContentAfter("@param param1 The Description\n",                Integer.MAX_VALUE);        Assert.assertNull(javadocContentAfter);    }    @Test    public void testJavadocAfterNull() {        String javadocContentAfter = CommentUtil.javadocContentAfter(null, 0);        Assert.assertNull(javadocContentAfter);    }    @Test    public void testJavadoc() {        String comment = "    /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "";        List<String> lines = CommentUtil.multiLinesIn(comment);        lines = CommentUtil.trim(lines);        for (String line : lines) {            Map<String, Integer> tags = CommentUtil.javadocTagsIn(line);            for (String tag : tags.keySet()) {                int pos = tags.get(tag) + tag.length() + 1;                String wordAfter = CommentUtil.wordAfter(line, pos);                pos = pos + wordAfter.length() + 1;                String description = CommentUtil.javadocContentAfter(line, pos);                if ("param".equals(tag)) {                    Assert.assertEquals("node", wordAfter); // the parameter name                    Assert.assertEquals("The node to check", description);                } else if ("return".equals(tag)) {                    Assert.assertEquals("True", wordAfter);                    Assert.assertEquals("if the metric can be computed", description);                }            }        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTBooleanLiteralTest extends BaseParserTest {    @Test    public void testTrue() {        List<ASTBooleanLiteral> ops = java.getNodes(ASTBooleanLiteral.class, TEST1);        ASTBooleanLiteral b = ops.get(0);        assertTrue(b.isTrue());    }    @Test    public void testFalse() {        List<ASTBooleanLiteral> ops = java.getNodes(ASTBooleanLiteral.class, TEST2);        ASTBooleanLiteral b = ops.get(0);        assertFalse(b.isTrue());    }    private static final String TEST1 = "class Foo { \n boolean bar = true; \n} ";    private static final String TEST2 = "class Foo { \n boolean bar = false; \n} ";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.hamcrest.Matchers.instanceOf;import java.util.List;import org.hamcrest.MatcherAssert;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * Tests new java14 standard features. */public class Java14Test {    private final JavaParsingHelper java14 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("14")                                             .withResourceContext(Java14Test.class, "jdkversiontests/java14/");    private final JavaParsingHelper java13 = java14.withDefaultVersion("13");    /**     * Tests switch expressions with yield.     */    @Test    public void switchExpressions() {        parseAndCheckSwitchExpression(java14);    }    /**     * In java13, switch expressions are only available with preview.     */    @Test(expected = ParseException.class)    public void switchExpressions13ShouldFail() {        parseAndCheckSwitchExpression(java13);    }    private void parseAndCheckSwitchExpression(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("SwitchExpressions.java");        List<ASTSwitchStatement> switchStatements = compilationUnit.findDescendantsOfType(ASTSwitchStatement.class);        Assert.assertEquals(2, switchStatements.size());        Assert.assertTrue(switchStatements.get(0).getChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatements.get(0).getChild(1) instanceof ASTSwitchLabeledExpression);        Assert.assertTrue(switchStatements.get(0).getChild(1).getChild(0) instanceof ASTSwitchLabel);        Assert.assertEquals(3, switchStatements.get(0).getChild(1).getChild(0).getNumChildren());        Assert.assertTrue(switchStatements.get(0).getChild(2).getChild(0) instanceof ASTSwitchLabel);        Assert.assertFalse(((ASTSwitchLabel) switchStatements.get(0).getChild(2).getChild(0)).isDefault());        Assert.assertEquals(1, switchStatements.get(0).getChild(2).getChild(0).getNumChildren());        Assert.assertTrue(switchStatements.get(1).getChild(3) instanceof ASTSwitchLabeledExpression);        Assert.assertTrue(switchStatements.get(1).getChild(3).getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(((ASTSwitchLabel) switchStatements.get(1).getChild(3).getChild(0)).isDefault());        List<ASTSwitchExpression> switchExpressions = compilationUnit.findDescendantsOfType(ASTSwitchExpression.class);        Assert.assertEquals(4, switchExpressions.size());        Assert.assertEquals(Integer.TYPE, switchExpressions.get(0).getType());        Assert.assertEquals(4, switchExpressions.get(0).findChildrenOfType(ASTSwitchLabeledExpression.class).size());        Assert.assertEquals(Integer.TYPE, switchExpressions.get(0).getFirstChildOfType(ASTSwitchLabeledExpression.class)                                                           .getFirstChildOfType(ASTExpression.class).getType());        Assert.assertTrue(switchExpressions.get(1).getChild(3) instanceof ASTSwitchLabeledBlock);        Assert.assertEquals(Integer.TYPE, switchExpressions.get(2).getType());        List<ASTYieldStatement> yields = switchExpressions.get(2).findDescendantsOfType(ASTYieldStatement.class);        Assert.assertEquals(4, yields.size());        Assert.assertEquals("SwitchExpressions.BAZ", yields.get(2).getImage());        Assert.assertEquals(String.class, switchExpressions.get(3).getType());    }    @Test    public void checkYieldConditionalBehaviour() {        checkYieldStatements(java14);    }    private void checkYieldStatements(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("YieldStatements.java");        List<JavaNode> stmts = compilationUnit.<JavaNode>findDescendantsOfType(ASTBlockStatement.class);        // fetch the interesting node, on the java-grammar branch this is not needed        for (int i = 0; i < stmts.size(); i++) {            JavaNode child = stmts.get(i).getChild(0);            if (child instanceof ASTStatement) {                stmts.set(i, child.getChild(0));            } else {                stmts.set(i, child);            }        }        Assert.assertEquals(18, stmts.size());        int i = 0;        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTLocalVariableDeclaration.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTIfStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        Assert.assertEquals(i, stmts.size());    }    @Test    public void multipleCaseLabels() {        multipleCaseLabels(java14);    }    private void multipleCaseLabels(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("MultipleCaseLabels.java");        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertTrue(switchStatement.getChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatement.getChild(1) instanceof ASTSwitchLabel);        ASTSwitchLabel switchLabel = switchStatement.getFirstChildOfType(ASTSwitchLabel.class);        Assert.assertEquals(3, switchLabel.findChildrenOfType(ASTExpression.class).size());    }    @Test    public void switchRules() {        switchRules(java14);    }    private void switchRules(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("SwitchRules.java");        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertTrue(switchStatement.getChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatement.getChild(1) instanceof ASTSwitchLabeledExpression);        ASTSwitchLabeledExpression switchLabeledExpression = (ASTSwitchLabeledExpression) switchStatement.getChild(1);        Assert.assertEquals(2, switchLabeledExpression.getNumChildren());        Assert.assertTrue(switchLabeledExpression.getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledExpression.getChild(1) instanceof ASTExpression);        ASTSwitchLabeledBlock switchLabeledBlock = (ASTSwitchLabeledBlock) switchStatement.getChild(4);        Assert.assertEquals(2, switchLabeledBlock.getNumChildren());        Assert.assertTrue(switchLabeledBlock.getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledBlock.getChild(1) instanceof ASTBlock);        ASTSwitchLabeledThrowStatement switchLabeledThrowStatement = (ASTSwitchLabeledThrowStatement) switchStatement.getChild(5);        Assert.assertEquals(2, switchLabeledThrowStatement.getNumChildren());        Assert.assertTrue(switchLabeledThrowStatement.getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledThrowStatement.getChild(1) instanceof ASTThrowStatement);    }    @Test    public void simpleSwitchExpressions() {        simpleSwitchExpressions(java14);    }    private void simpleSwitchExpressions(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("SimpleSwitchExpressions.java");        ASTSwitchExpression switchExpression = compilationUnit.getFirstDescendantOfType(ASTSwitchExpression.class);        Assert.assertEquals(6, switchExpression.getNumChildren());        Assert.assertTrue(switchExpression.getChild(0) instanceof ASTExpression);        Assert.assertEquals(5, switchExpression.findChildrenOfType(ASTSwitchLabeledRule.class).size());        ASTLocalVariableDeclaration localVar = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(1);        ASTVariableDeclarator localVarDecl = localVar.getFirstChildOfType(ASTVariableDeclarator.class);        Assert.assertEquals(Integer.TYPE, localVarDecl.getType());        Assert.assertEquals(Integer.TYPE, switchExpression.getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Assert;import org.junit.Test;public class FormalCommentTest {    @Test    public void testJavadocTagsAsChildren() {        String comment = "    /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "";        Token token = new Token();        token.image = comment;        FormalComment commentNode = new FormalComment(token);        Assert.assertEquals(2, commentNode.getNumChildren());        JavadocElement paramTag = (JavadocElement) commentNode.getChild(0);        Assert.assertEquals("param", paramTag.tag().label);        JavadocElement returnTag = (JavadocElement) commentNode.getChild(1);        Assert.assertEquals("return", returnTag.tag().label);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTSwitchLabelTest extends BaseParserTest {    @Test    public void testDefaultOff() {        List<ASTSwitchLabel> ops = java.getNodes(ASTSwitchLabel.class, TEST1);        assertFalse(ops.get(0).isDefault());    }    @Test    public void testDefaultSet() {        List<ASTSwitchLabel> ops = java.getNodes(ASTSwitchLabel.class, TEST2);        assertTrue(ops.get(0).isDefault());    }    private static final String TEST1 = "public class Foo {\n void bar() {\n  switch (x) {\n   case 1: y = 2;\n  }\n }\n}";    private static final String TEST2 = "public class Foo {\n void bar() {\n  switch (x) {\n   default: y = 2;\n  }\n }\n}";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java15TreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java15 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("15")                    .withResourceContext(Java15TreeDumpTest.class, "jdkversiontests/java15/");    private final JavaParsingHelper java15p = java15.withDefaultVersion("15-preview");    private final JavaParsingHelper java14 = java15.withDefaultVersion("14");    public Java15TreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java15;    }    @Test    public void textBlocks() {        doTest("TextBlocks");        java15p.parseResource("TextBlocks.java"); // make sure we can parse it with preview as well    }    @Test(expected = net.sourceforge.pmd.lang.ast.ParseException.class)    public void textBlocksBeforeJava15ShouldFail() {        java14.parseResource("TextBlocks.java");    }    @Test(expected = ParseException.class)    public void stringEscapeSequenceShouldFail() {        java14.parse("class Foo { String s =\"a\\sb\"; }");    }    @Test    public void sealedAndNonSealedIdentifiers() {        doTest("NonSealedIdentifier");        java15p.parseResource("NonSealedIdentifier.java"); // make sure we can parse it with preview as well    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.util.List;import org.jaxen.JaxenException;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class SimpleNodeTest extends BaseParserTest {    @Test    public void testMethodDiffLines() {        List<ASTMethodDeclaration> methods = java.getNodes(ASTMethodDeclaration.class, METHOD_DIFF_LINES);        verifyNode(methods.iterator().next(), 2, 9, 4, 2);    }    @Test    public void testMethodSameLine() {        List<ASTMethodDeclaration> methods = java.getNodes(ASTMethodDeclaration.class, METHOD_SAME_LINE);        verifyNode(methods.iterator().next(), 2, 9, 2, 21);    }    @Test    public void testNoLookahead() {        List<ASTClassOrInterfaceDeclaration> uCD = java.getNodes(ASTClassOrInterfaceDeclaration.class, NO_LOOKAHEAD);        verifyNode(uCD.iterator().next(), 1, 8, 1, 20);    }    @Test    public void testHasExplicitExtends() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, HAS_EXPLICIT_EXTENDS).iterator().next();        assertTrue(ucd.getChild(0) instanceof ASTExtendsList);    }    @Test    public void testNoExplicitExtends() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, NO_EXPLICIT_EXTENDS).iterator().next();        assertFalse(ucd.getChild(0) instanceof ASTExtendsList);    }    @Test    public void testHasExplicitImplements() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, HAS_EXPLICIT_IMPLEMENTS).iterator().next();        assertTrue(ucd.getChild(0) instanceof ASTImplementsList);    }    @Test    public void testNoExplicitImplements() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, NO_EXPLICIT_IMPLEMENTS).iterator().next();        assertFalse(ucd.getChild(0) instanceof ASTImplementsList);    }    @Test    public void testColumnsOnQualifiedName() {        for (Node node : java.getNodes(ASTName.class, QUALIFIED_NAME)) {            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 1, 19);            }        }    }    @Test    public void testLineNumbersForNameSplitOverTwoLines() {        for (Node node : java.getNodes(ASTName.class, BROKEN_LINE_IN_NAME)) {            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 2, 4);            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 18);            }        }    }    @Test    public void testLineNumbersAreSetOnAllSiblings() {        for (ASTBlock b : java.getNodes(ASTBlock.class, LINE_NUMBERS_ON_SIBLINGS)) {            assertTrue(b.getBeginLine() > 0);        }        for (ASTVariableInitializer b : java.getNodes(ASTVariableInitializer.class, LINE_NUMBERS_ON_SIBLINGS)) {            assertTrue(b.getBeginLine() > 0);        }        for (ASTExpression b : java.getNodes(ASTExpression.class, LINE_NUMBERS_ON_SIBLINGS)) {            assertTrue(b.getBeginLine() > 0);        }    }    @Test    public void testFindDescendantsOfType() {        ASTBlock block = new ASTBlock(2);        block.jjtAddChild(new ASTReturnStatement(1), 0);        assertEquals(1, block.findDescendantsOfType(ASTReturnStatement.class).size());    }    @Test    public void testFindDescendantsOfTypeMultiple() {        ASTBlock block = new ASTBlock(1);        block.jjtAddChild(new ASTBlockStatement(2), 0);        block.jjtAddChild(new ASTBlockStatement(3), 1);        List<ASTBlockStatement> nodes = block.findDescendantsOfType(ASTBlockStatement.class);        assertEquals(2, nodes.size());    }    @Test    public void testFindDescendantsOfTypeRecurse() {        ASTBlock block = new ASTBlock(1);        ASTBlock childBlock = new ASTBlock(2);        block.jjtAddChild(childBlock, 0);        childBlock.jjtAddChild(new ASTMethodDeclaration(3), 0);        List<ASTMethodDeclaration> nodes = block.findDescendantsOfType(ASTMethodDeclaration.class);        assertEquals(1, nodes.size());    }    @Test    public void testGetFirstChild() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstDescendantOfType(ASTStatement.class);        assertNotNull(n);        assertTrue(n instanceof ASTStatement);        assertEquals(x, n);    }    @Test    public void testGetFirstChildNested() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        x.jjtAddChild(x1, 0);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstDescendantOfType(ASTAssignmentOperator.class);        assertNotNull(n);        assertTrue(n instanceof ASTAssignmentOperator);        assertEquals(x1, n);    }    @Test    public void testGetFirstChildNestedDeeper() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        ASTName x2 = new ASTName(5);        x.jjtAddChild(x1, 0);        x1.jjtAddChild(x2, 0);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstDescendantOfType(ASTName.class);        assertNotNull(n);        assertTrue(n instanceof ASTName);        assertEquals(x2, n);    }    @Test    public void testParentMethods() {        ASTCompilationUnit u = JavaParsingHelper.JUST_PARSE.parse(TEST1);        ASTMethodDeclarator d = u.getFirstDescendantOfType(ASTMethodDeclarator.class);        assertSame("getFirstParentOfType ASTMethodDeclaration", d.getParent(),                d.getFirstParentOfType(ASTMethodDeclaration.class));        assertNull("getFirstParentOfType ASTName", d.getFirstParentOfType(ASTName.class));        assertSame("getNthParent 1", d.getParent(), d.getNthParent(1));        assertSame("getNthParent 2", d.getParent().getParent(), d.getNthParent(2));        assertSame("getNthParent 6", u, d.getNthParent(6));        assertNull("getNthParent 7", d.getNthParent(7));        assertNull("getNthParent 8", d.getNthParent(8));    }    private static final String TEST1 = "public class Test {\n  void bar(String s) {\n   s = s.toLowerCase();\n  }\n}";    @Ignore    @Test    public void testContainsNoInner() {        ASTCompilationUnit c = java.getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER).iterator().next();        List<ASTFieldDeclaration> res = c.findDescendantsOfType(ASTFieldDeclaration.class);        assertTrue(res.isEmpty());        /*         * String expectedXml =         * "<CompilationUnit BeginColumn=\"1\" BeginLine=\"5\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<TypeDeclaration BeginColumn=\"1\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"8\" BeginLine=\"1\" EndColumn=\"1\" "         * +         * "EndLine=\"5\" Final=\"false\" Image=\"Test\" Interface=\"false\" Native=\"false\" Nested=\"false\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">"         * +         * "<ClassOrInterfaceBody BeginColumn=\"19\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"3\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">"         * +         * "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"10\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\" Final=\"false\" "         * +         * "Image=\"Inner\" Interface=\"false\" Native=\"false\" Nested=\"true\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" "         * +         * "Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">"         * +         * "<ClassOrInterfaceBody BeginColumn=\"22\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">"         * +         * "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\">"         * +         * "<FieldDeclaration Abstract=\"false\" Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\" Final=\"false\" Native=\"false\" PackagePrivate=\"true\" Private=\"false\" Protected=\"false\" Public=\"false\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" VariableName=\"foo\" Volatile=\"false\"><Type Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"6\" EndLine=\"3\">"         * +         * "<PrimitiveType Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" Boolean=\"false\" EndColumn=\"6\" EndLine=\"3\" Image=\"int\"/>"         * + "</Type>" +         * "<VariableDeclarator BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\">"         * +         * "<VariableDeclaratorId Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\" ExceptionBlockParameter=\"false\" Image=\"foo\"/>"         * +         * "</VariableDeclarator></FieldDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody>"         * +         * "</ClassOrInterfaceDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody></ClassOrInterfaceDeclaration>"         * + "</TypeDeclaration></CompilationUnit>"; assertEquals( expectedXml,         * getXmlString( c ) );         */ }    @Test    public void testContainsNoInnerWithAnonInner() {        ASTCompilationUnit c = java.parse(CONTAINS_NO_INNER_WITH_ANON_INNER);        List<ASTFieldDeclaration> res = c.findDescendantsOfType(ASTFieldDeclaration.class);        assertTrue(res.isEmpty());    }    @Test    public void testContainsChildOfType() {        ASTClassOrInterfaceDeclaration c = java.getNodes(ASTClassOrInterfaceDeclaration.class, CONTAINS_CHILDREN_OF_TYPE)                .iterator().next();        assertTrue(c.hasDescendantOfType(ASTFieldDeclaration.class));    }    @Test    public void testXPathNodeSelect() throws JaxenException {        ASTClassOrInterfaceDeclaration c = java.getNodes(ASTClassOrInterfaceDeclaration.class, TEST_XPATH).iterator().next();        List<Node> nodes = c.findChildNodesWithXPath("//FieldDeclaration");        assertEquals(2, nodes.size());        assertTrue(nodes.get(0) instanceof ASTFieldDeclaration);        assertTrue(c.hasDescendantMatchingXPath("//FieldDeclaration"));        assertFalse(c.hasDescendantMatchingXPath("//MethodDeclaration"));    }    @Test    public void testUserData() {        ASTClassOrInterfaceDeclaration c = java.getNodes(ASTClassOrInterfaceDeclaration.class, HAS_EXPLICIT_EXTENDS)                .iterator().next();        assertNull(c.getUserData());        c.setUserData("foo");        assertEquals("foo", c.getUserData());        c.setUserData(null);        assertNull(c.getUserData());    }    private void verifyNode(Node node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Unexpected beginning line: ", beginLine, node.getBeginLine());        assertEquals("Unexpected beginning column: ", beginCol, node.getBeginColumn());        assertEquals("Unexpected ending line:", endLine, node.getEndLine());        assertEquals("Unexpected ending column:", endCol, node.getEndColumn());    }    private static final String HAS_EXPLICIT_EXTENDS = "public class Test extends Foo {}";    private static final String NO_EXPLICIT_EXTENDS = "public class Test {}";    private static final String HAS_EXPLICIT_IMPLEMENTS = "public class Test implements Foo {}";    private static final String NO_EXPLICIT_IMPLEMENTS = "public class Test {}";    private static final String METHOD_SAME_LINE = "public class Test {\n public void foo() {}\n}";    private static final String QUALIFIED_NAME = "import java.io.File;\npublic class Foo{}";    private static final String BROKEN_LINE_IN_NAME = "import java.io.\nFile;\npublic class Foo{}";    private static final String LINE_NUMBERS_ON_SIBLINGS =        "public class Foo {\n void bar() {\n  try {\n  } catch (Exception1 e) {\n   int x =2;\n  }\n if (x != null) {}\n }\n}";    private static final String NO_LOOKAHEAD = "public class Foo { }";    private static final String METHOD_DIFF_LINES = "public class Test {\n public void foo() {\n  int x;\n }\n}";    private static final String CONTAINS_CHILDREN_OF_TYPE = "public class Test {\n  int x;\n}";    private static final String CONTAINS_NO_INNER = "public class Test {\n  public class Inner {\n   int foo;\n  }\n}";    private static final String CONTAINS_NO_INNER_WITH_ANON_INNER = "public class Test {\n  void bar() {\n   foo(new Fuz() { int x = 2;});\n  }\n}";    private static final String TEST_XPATH = "public class Test {\n  int x = 2;\n  int y = 42;\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class JDKVersionTest {    private final JavaParsingHelper java3 = JavaParsingHelper.JUST_PARSE        .withDefaultVersion("1.3")        .withResourceContext(JDKVersionTest.class, "jdkversiontests/");    private final JavaParsingHelper java4 = java3.withDefaultVersion("1.4");    private final JavaParsingHelper java5 = java3.withDefaultVersion("1.5");    private final JavaParsingHelper java7 = java3.withDefaultVersion("1.7");    private final JavaParsingHelper java8 = java3.withDefaultVersion("1.8");    private final JavaParsingHelper java9 = java3.withDefaultVersion("9");    // enum keyword/identifier    @Test(expected = ParseException.class)    public void testEnumAsKeywordShouldFailWith14() {        java5.parseResource("jdk14_enum.java");    }    @Test    public void testEnumAsIdentifierShouldPassWith14() {        java4.parseResource("jdk14_enum.java");    }    @Test    public void testEnumAsKeywordShouldPassWith15() {        java5.parseResource("jdk15_enum.java");    }    @Test(expected = ParseException.class)    public void testEnumAsIdentifierShouldFailWith15() {        java5.parseResource("jdk14_enum.java");    }    // enum keyword/identifier    // assert keyword/identifier    @Test    public void testAssertAsKeywordVariantsSucceedWith14() {        java4.parseResource("assert_test1.java");        java4.parseResource("assert_test2.java");        java4.parseResource("assert_test3.java");        java4.parseResource("assert_test4.java");    }    @Test(expected = ParseException.class)    public void testAssertAsVariableDeclIdentifierFailsWith14() {        java4.parseResource("assert_test5.java");    }    @Test(expected = ParseException.class)    public void testAssertAsMethodNameIdentifierFailsWith14() {        java4.parseResource("assert_test7.java");    }    @Test    public void testAssertAsIdentifierSucceedsWith13() {        java3.parseResource("assert_test5.java");    }    @Test(expected = ParseException.class)    public void testAssertAsKeywordFailsWith13() {        java3.parseResource("assert_test6.java");    }    // assert keyword/identifier    @Test    public void testVarargsShouldPassWith15() {        java5.parseResource("jdk15_varargs.java");    }    @Test(expected = ParseException.class)    public void testVarargsShouldFailWith14() {        java4.parseResource("jdk15_varargs.java");    }    @Test    public void testJDK15ForLoopSyntaxShouldPassWith15() {        java5.parseResource("jdk15_forloop.java");    }    @Test    public void testJDK15ForLoopSyntaxWithModifiers() {        java5.parseResource("jdk15_forloop_with_modifier.java");    }    @Test(expected = ParseException.class)    public void testJDK15ForLoopShouldFailWith14() {        java4.parseResource("jdk15_forloop.java");    }    @Test    public void testJDK15GenericsSyntaxShouldPassWith15() {        java5.parseResource("jdk15_generics.java");    }    @Test    public void testVariousParserBugs() {        java5.parseResource("fields_bug.java");        java5.parseResource("gt_bug.java");        java5.parseResource("annotations_bug.java");        java5.parseResource("constant_field_in_annotation_bug.java");        java5.parseResource("generic_in_field.java");    }    @Test    public void testNestedClassInMethodBug() {        java5.parseResource("inner_bug.java");        java5.parseResource("inner_bug2.java");    }    @Test    public void testGenericsInMethodCall() {        java5.parseResource("generic_in_method_call.java");    }    @Test    public void testGenericINAnnotation() {        java5.parseResource("generic_in_annotation.java");    }    @Test    public void testGenericReturnType() {        java5.parseResource("generic_return_type.java");    }    @Test    public void testMultipleGenerics() {        // See java/lang/concurrent/CopyOnWriteArraySet        java5.parseResource("funky_generics.java");        // See java/lang/concurrent/ConcurrentHashMap        java5.parseResource("multiple_generics.java");    }    @Test    public void testAnnotatedParams() {        java5.parseResource("annotated_params.java");    }    @Test    public void testAnnotatedLocals() {        java5.parseResource("annotated_locals.java");    }    @Test    public void testAssertAsIdentifierSucceedsWith13Test2() {        java3.parseResource("assert_test5_a.java");    }    @Test    public final void testBinaryAndUnderscoresInNumericalLiterals() {        java7.parseResource("jdk17_numerical_literals.java");    }    @Test    public final void testStringInSwitch() {        java7.parseResource("jdk17_string_in_switch.java");    }    @Test    public final void testGenericDiamond() {        java7.parseResource("jdk17_generic_diamond.java");    }    @Test    public final void testTryWithResources() {        java7.parseResource("jdk17_try_with_resources.java");    }    @Test    public final void testTryWithResourcesSemi() {        java7.parseResource("jdk17_try_with_resources_semi.java");    }    @Test    public final void testTryWithResourcesMulti() {        java7.parseResource("jdk17_try_with_resources_multi.java");    }    @Test    public final void testTryWithResourcesWithAnnotations() {        java7.parseResource("jdk17_try_with_resources_with_annotations.java");    }    @Test    public final void testMulticatch() {        java7.parseResource("jdk17_multicatch.java");    }    @Test    public final void testMulticatchWithAnnotations() {        java7.parseResource("jdk17_multicatch_with_annotations.java");    }    @Test(expected = ParseException.class)    public final void jdk9PrivateInterfaceMethodsInJava18() {        java8.parseResource("jdk9_private_interface_methods.java");    }    @Test    public final void testPrivateMethods() {        java8.parse("public class Foo { private void bar() { } }");    }    @Test    public final void testNestedPrivateMethods() {        java8.parse("public interface Baz { public static class Foo { private void bar() { } } }");    }    @Test    public final void jdk9PrivateInterfaceMethods() {        java9.parseResource("jdk9_private_interface_methods.java");    }    @Test    public final void jdk9InvalidIdentifierInJava18() {        java8.parseResource("jdk9_invalid_identifier.java");    }    @Test(expected = ParseException.class)    public final void jdk9InvalidIdentifier() {        java9.parseResource("jdk9_invalid_identifier.java");    }    @Test(expected = ParseException.class)    public final void jdk9AnonymousDiamondInJava8() {        java8.parseResource("jdk9_anonymous_diamond.java");    }    @Test    public final void jdk9AnonymousDiamond() {        java9.parseResource("jdk9_anonymous_diamond.java");    }    @Test(expected = ParseException.class)    public final void jdk9ModuleInfoInJava8() {        java8.parseResource("jdk9_module_info.java");    }    @Test    public final void jdk9ModuleInfo() {        java9.parseResource("jdk9_module_info.java");    }    @Test    public void testAnnotatedModule() {        java9.parseResource("jdk9_module_info_with_annot.java");    }    @Test(expected = ParseException.class)    public final void jdk9TryWithResourcesInJava8() {        java8.parseResource("jdk9_try_with_resources.java");    }    @Test    public final void jdk9TryWithResources() {        java9.parseResource("jdk9_try_with_resources.java");    }    @Test    public final void jdk7PrivateMethodInnerClassInterface1() {        ASTCompilationUnit acu = java7.parseResource("private_method_in_inner_class_interface1.java");        List<ASTMethodDeclaration> methods = acu.findDescendantsOfType(ASTMethodDeclaration.class, true);        assertEquals(3, methods.size());        for (ASTMethodDeclaration method : methods) {            assertFalse(method.isInterfaceMember());        }    }    @Test    public final void jdk7PrivateMethodInnerClassInterface2() {        try {            ASTCompilationUnit acu = java7.parseResource("private_method_in_inner_class_interface2.java");            fail("Expected exception");        } catch (ParseException e) {            assertTrue(e.getMessage().startsWith("Line 19"));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.List;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * Base class for tests that usually need processing stages to run when * parsing code. */public abstract class BaseParserTest {    protected final JavaParsingHelper java = JavaParsingHelper.JUST_PARSE.withResourceContext(getClass());    protected final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    protected final JavaParsingHelper java8 = java.withDefaultVersion("1.8");    protected final JavaParsingHelper java9 = java.withDefaultVersion("9");    protected ASTCompilationUnit parseCode(final String code) {        return java.parse(code);    }    protected <T extends Node> List<T> getNodes(Class<T> target, String code) {        return JavaParsingHelper.WITH_PROCESSING.getNodes(target, code);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;import net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;/** * @author Clément Fournier */public class JavaQualifiedNameTest {    private <T extends Node> List<T> getNodes(Class<T> target, String code) {        return JavaParsingHelper.WITH_PROCESSING.getNodes(target, code);    }    @Test    public void testEmptyPackage() {        final String TEST = "class Foo {}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("Foo", qname.toString());            assertTrue(qname.getPackageList().isEmpty());            assertTrue(qname.isUnnamedPackage());            assertEquals(1, qname.getClassList().size());        }    }    @Test    public void testPackage() {        final String TEST = "package foo.bar; class Bzaz{}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Bzaz", qname.toString());            assertEquals(2, qname.getPackageList().size());            assertEquals(1, qname.getClassList().size());        }    }    @Test    public void testNestedClass() {        final String TEST = "package foo.bar; class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            switch (coid.getImage()) {            case "Foo":                assertEquals("foo.bar.Bzaz$Bor$Foo",                             qname.toString());                assertEquals(3, qname.getClassList().size());                break;            default:                break;            }        }    }    @Test    public void testNestedEnum() {        final String TEST = "package foo.bar; class Foo { enum Bzaz{HOO;}}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Foo$Bzaz", qname.toString());            assertEquals(2, qname.getPackageList().size());            assertEquals(2, qname.getClassList().size());        }    }    @Test    public void testEnum() {        final String TEST = "package foo.bar; enum Bzaz{HOO;}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Bzaz", qname.toString());            assertEquals(2, qname.getPackageList().size());            assertEquals(1, qname.getClassList().size());        }    }    @Test    public void testEnumMethodMember() {        final String TEST = "package foo.bar; enum Bzaz{HOO; void foo(){}}";        List<ASTMethodDeclaration> nodes = getNodes(ASTMethodDeclaration.class, TEST);        for (ASTMethodDeclaration coid : nodes) {            JavaOperationQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Bzaz#foo()", qname.toString());            assertEquals(2, qname.getClassName().getPackageList().size());            assertEquals(1, qname.getClassName().getClassList().size());            assertEquals("foo()", qname.getOperation());        }    }    @Test    public void testNestedEmptyPackage() {        final String TEST = "class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            switch (coid.getImage()) {            case "Foo":                assertEquals("Bzaz$Bor$Foo",                             qname.toString());                assertTrue(qname.getPackageList().isEmpty());                assertTrue(qname.isUnnamedPackage());                assertEquals(3, qname.getClassList().size());                break;            default:                break;            }        }    }    @Test    public void testMethod() {        final String TEST = "package bar; class Bzaz{ public void foo(){}}";        List<ASTMethodDeclaration> nodes = getNodes(ASTMethodDeclaration.class, TEST);        for (ASTMethodDeclaration declaration : nodes) {            JavaOperationQualifiedName qname = declaration.getQualifiedName();            assertEquals("bar.Bzaz#foo()", qname.toString());            assertNotNull(qname.getOperation());            assertEquals("foo()", qname.getOperation());        }    }    @Test    public void testConstructor() {        final String TEST = "package bar; class Bzaz{ public Bzaz(){}}";        List<ASTConstructorDeclaration> nodes = getNodes(ASTConstructorDeclaration.class, TEST);        for (ASTConstructorDeclaration declaration : nodes) {            JavaOperationQualifiedName qname = declaration.getQualifiedName();            assertEquals("bar.Bzaz#Bzaz()",                         qname.toString());            assertNotNull(qname.getOperation());            assertEquals("Bzaz()", qname.getOperation());        }    }    @Test    public void testConstructorWithParams() {        final String TEST = "package bar; class Bzaz{ public Bzaz(int j, String k){}}";        List<ASTConstructorDeclaration> nodes = getNodes(ASTConstructorDeclaration.class, TEST);        for (ASTConstructorDeclaration declaration : nodes) {            JavaOperationQualifiedName qname = declaration.getQualifiedName();            assertEquals("bar.Bzaz#Bzaz(int, String)", qname.toString());            assertNotNull(qname.getOperation());            assertEquals("Bzaz(int, String)", qname.getOperation());        }    }    @Test    public void testConstructorOverload() {        final String TEST = "package bar; class Bzaz{ public Bzaz(int j) {} public Bzaz(int j, String k){}}";        List<ASTConstructorDeclaration> nodes = getNodes(ASTConstructorDeclaration.class, TEST);        ASTConstructorDeclaration[] arr = nodes.toArray(new ASTConstructorDeclaration[2]);        assertNotEquals(arr[0].getQualifiedName(), arr[1].getQualifiedName());    }    @Test    public void testMethodOverload() {        final String TEST = "package bar; class Bzaz{ public void foo(String j) {} "                + "public void foo(int j){} public void foo(double k){}}";        List<ASTMethodDeclaration> nodes = getNodes(ASTMethodDeclaration.class, TEST);        ASTMethodDeclaration[] arr = nodes.toArray(new ASTMethodDeclaration[3]);        assertNotEquals(arr[0].getQualifiedName(), arr[1].getQualifiedName());        assertNotEquals(arr[1].getQualifiedName(), arr[2].getQualifiedName());    }    @Test    public void testParseClass() {        JavaTypeQualifiedName outer = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz");        JavaTypeQualifiedName nested = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz$Bolg");        assertEquals(1, outer.getClassList().size());        assertEquals("Bzaz", outer.getClassList().get(0));        assertEquals(2, nested.getClassList().size());        assertEquals("Bzaz", nested.getClassList().get(0));        assertEquals("Bolg", nested.getClassList().get(1));    }    @Test    public void testParsePackages() {        JavaTypeQualifiedName packs = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz$Bolg");        JavaTypeQualifiedName nopacks = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("Bzaz");        assertNotNull(packs.getPackageList());        assertEquals("foo", packs.getPackageList().get(0));        assertEquals("bar", packs.getPackageList().get(1));        assertTrue(nopacks.getPackageList().isEmpty());    }    @Test    public void testParseOperation() {        JavaOperationQualifiedName noparams = (JavaOperationQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz$Bolg#bar()");        JavaOperationQualifiedName params = (JavaOperationQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz#bar(String, int)");        assertEquals("bar()", noparams.getOperation());        assertEquals("bar(String, int)", params.getOperation());    }    @Test    public void testParseLocalClasses() {        final String SIMPLE = "foo.bar.Bzaz$1Local";        final String NESTED = "foo.Bar$1Local$Nested";        JavaTypeQualifiedName simple = (JavaTypeQualifiedName) QualifiedNameFactory.ofString(SIMPLE);        JavaTypeQualifiedName nested = (JavaTypeQualifiedName) QualifiedNameFactory.ofString(NESTED);        assertNotNull(simple);        assertTrue(simple.isLocalClass());        assertFalse(simple.isAnonymousClass());        assertNotNull(nested);        assertFalse(nested.isLocalClass());        assertFalse(simple.isAnonymousClass());        assertEquals(SIMPLE, simple.toString());        assertEquals(NESTED, nested.toString());    }    @Test    public void testParseAnonymousClass() {        final String SIMPLE = "Bzaz$12$13";        JavaTypeQualifiedName simple = (JavaTypeQualifiedName) QualifiedNameFactory.ofString(SIMPLE);        assertNotNull(simple);        assertTrue(simple.isAnonymousClass());        assertFalse(simple.isLocalClass());        assertEquals("12", simple.getClassList().get(1));        assertEquals("13", simple.getClassList().get(2));        assertEquals(SIMPLE, simple.toString());    }    @Test    public void testParseLambdaName() {        final String IN_LAMBDA = "foo.bar.Bzaz$1Local#lambda$null$12";        final String STATIC = "foo.bar.Bzaz#lambda$static$12";        final String NEW = "foo.bar.Bzaz#lambda$new$1";        final String IN_METHOD = "Bzaz#lambda$myMethod$4";        for (String s : Arrays.asList(IN_LAMBDA, STATIC, NEW, IN_METHOD)) {            JavaOperationQualifiedName qname = (JavaOperationQualifiedName) QualifiedNameFactory.ofString(s);            assertNotNull(qname);            assertTrue(qname.isLambda());            assertEquals(s, qname.toString());            assertEquals(qname, QualifiedNameFactory.ofString(qname.toString()));        }    }    @Test    public void testParseLambdaInEnumConstant() {        final String LAMBA_IN_ENUM_CONSTANT = "package foo; import java.util.function.Function; enum Bar { CONST(e -> e); Bar(Function<Object,Object> o) {} }";        final String QNAME = "foo.Bar#lambda$static$0";        ASTLambdaExpression node = getNodes(ASTLambdaExpression.class, LAMBA_IN_ENUM_CONSTANT).get(0);        assertNotNull(node);        assertEquals(QualifiedNameFactory.ofString(QNAME), node.getQualifiedName());    }    @Test    public void testParseMalformed() {        assertNull(QualifiedNameFactory.ofString(".foo.bar.Bzaz"));        assertNull(QualifiedNameFactory.ofString("foo.bar."));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#foo"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz()"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#foo(String,)"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#foo(String , int)"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#lambda$static$23(String)"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#lambda$static$"));    }    @Test    public void testSimpleLocalClass() {        final String TEST = "package bar; class Boron { public void foo(String j) { class Local {} } }";        List<ASTClassOrInterfaceDeclaration> classes                = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        JavaQualifiedName qname = QualifiedNameFactory.ofString("bar.Boron$1Local");        assertEquals(qname, classes.get(1).getQualifiedName());    }    @Test    public void testLocalClassNameClash() {        final String TEST = "package bar; class Bzaz{ void foo() { class Local {} } {// initializer\n class Local {}}}";        List<ASTClassOrInterfaceDeclaration> classes                = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertNotEquals(classes.get(1).getQualifiedName(), classes.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("bar.Bzaz$1Local"), classes.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("bar.Bzaz$2Local"), classes.get(2).getQualifiedName());    }    @Test    public void testLocalClassDeepNesting() {        final String TEST                = "class Bzaz{ void foo() { "                + "  class Local { "                + "    class Nested {"                + "      {"                + "        class InnerLocal{}"                + "      }"                + "    }"                + "  }"                + "}}";        List<ASTClassOrInterfaceDeclaration> classes                = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertNotEquals(classes.get(1).getQualifiedName(), classes.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local"), classes.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local$Nested"), classes.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local$Nested$1InnerLocal"), classes.get(3).getQualifiedName());    }    @Test    public void testAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() { "                + "  new Runnable() {"                + "      public void run() {}"                + "  };"                + "}}";        List<ASTAllocationExpression> classes = getNodes(ASTAllocationExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz$1"), classes.get(0).getQualifiedName());        assertFalse(classes.get(0).getQualifiedName().isLocalClass());        assertTrue(classes.get(0).getQualifiedName().isAnonymousClass());        assertTrue("1".equals(classes.get(0).getQualifiedName().getClassSimpleName()));    }    @Test    public void testMultipleAnonymousClasses() {        final String TEST                = "class Bzaz{ void foo() { "                + "  new Runnable() {"                + "      public void run() {}"                + "  };"                + "  new Runnable() {"                + "      public void run() {}"                + "  };"                + "}}";        List<ASTAllocationExpression> classes = getNodes(ASTAllocationExpression.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals(QualifiedNameFactory.ofString("Bzaz$1"), classes.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$2"), classes.get(1).getQualifiedName());    }    @Test    public void testNestedAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() {"                + "  new Runnable() {"                + "    public void run() {"                + "      new Runnable() {"                + "        public void run() {}"                + "      };"                + "    }"                + "  };"                + "}}";        List<ASTAllocationExpression> classes = getNodes(ASTAllocationExpression.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals(QualifiedNameFactory.ofString("Bzaz$1"), classes.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1$1"), classes.get(1).getQualifiedName());    }    @Test    public void testLocalInAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() {"                + "  new Runnable() {"                + "    public void run() {"                + "      class FooRunnable {}"                + "    }"                + "  };"                + "}}";        List<ASTClassOrInterfaceDeclaration> classes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertTrue(classes.get(1).isLocal());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1$1FooRunnable"), classes.get(1).getQualifiedName());    }    @Test    public void testLambdaInStaticInitializer() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  static {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$0"), lambdas.get(0).getQualifiedName());    }    @Test    public void testLambdaInInitializerAndConstructor() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public Bzaz() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$1"), lambdas.get(1).getQualifiedName());    }    @Test    public void testLambdaField() {        final String TEST                = "import java.util.function.*;"                + "public class Bzaz { "                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     public static Consumer<String> k = s -> {"                + "         System.out.println(s);"                + "     };"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$1"), lambdas.get(1).getQualifiedName());    }    @Test    public void testLambdaInterfaceField() {        final String TEST                = "import java.util.function.*;"                + "public interface Bzaz { "                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     public static Consumer<String> k = s -> {"                + "         System.out.println(s);"                + "     };"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$1"), lambdas.get(1).getQualifiedName());    }    @Test    public void testLambdaLocalClassField() {        final String TEST                = "import java.util.function.*;"                + "public class Bzaz { "                + "  public void boo() {"                + "     class Local {"                + "         Consumer<String> l = s -> {"                + "             System.out.println(s);"                + "         };"                + "     }"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local#lambda$Local$0"), lambdas.get(0).getQualifiedName());    }    @Test    public void testLambdaAnonymousClassField() {        final String TEST                = "import java.util.function.*;"                + "public class Bzaz { "                + "  public void boo() {"                + "     new Anonymous() {"                + "         Consumer<String> l = s -> {"                + "             System.out.println(s);"                + "         };"                + "     };"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz$1#lambda$$0"), lambdas.get(0).getQualifiedName());        // This is here because of a bug with the regex parsing, which failed on "Bzaz$1#lambda$$0"        // because the second segment of the lambda name was the empty string        assertTrue(lambdas.get(0).getQualifiedName().isLambda());        assertEquals("lambda$$0", lambdas.get(0).getQualifiedName().getOperation());        assertEquals(2, lambdas.get(0).getQualifiedName().getClassName().getClassList().size());    }    @Test    public void testLambdasInMethod() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  public void bar() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public void fooBar() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public void gollum() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$bar$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$fooBar$1"), lambdas.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$gollum$2"), lambdas.get(2).getQualifiedName());    }    @Test    public void testLambdaCounterBelongsToClass() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  static {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public Bzaz() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public void gollum() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "     new Runnable() {"                + "       public void run() {"                + "         Runnable r = () -> {};"                + "         r.run();"                + "       }"                + "     }.run();"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = getNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$1"), lambdas.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$gollum$2"), lambdas.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1#lambda$run$0"), lambdas.get(3).getQualifiedName()); // counter starts over for anon class        // This is here because of a bug with the regex parsing, which caused "Bzaz$1#lambda$run$0"        // to be parsed as        // * classes == List("Bzaz", "#lambda", "run", "0").reverse()        // * localIndices == List(-1, 1, -1, -1)        // * operation == null        assertTrue(lambdas.get(3).getQualifiedName().isLambda());        assertEquals("lambda$run$0", lambdas.get(3).getQualifiedName().getOperation());        assertEquals(2, lambdas.get(3).getQualifiedName().getClassName().getClassList().size());    }    @Test    public void testGetType() {        JavaTypeQualifiedName qname = QualifiedNameFactory.ofClass(ASTAdditiveExpression.class);        assertEquals(qname.getType(), ASTAdditiveExpression.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTAssignmentOperatorTest extends BaseParserTest {    @Test    public void testSimpleAssignmentRecognized() {        List<ASTAssignmentOperator> ops = java.getNodes(ASTAssignmentOperator.class, TEST1);        assertFalse(ops.get(0).isCompound());    }    @Test    public void testCompoundAssignmentPlusRecognized() {        List<ASTAssignmentOperator> ops = java.getNodes(ASTAssignmentOperator.class, TEST2);        assertTrue(ops.get(0).isCompound());    }    @Test    public void testCompoundAssignmentMultRecognized() {        List<ASTAssignmentOperator> ops = java.getNodes(ASTAssignmentOperator.class, TEST3);        assertTrue(ops.get(0).isCompound());    }    private static final String TEST1 = "public class Foo {\n void bar() {\n  int x;\n  x=2;\n }\n}";    private static final String TEST2 = "public class Foo {\n void bar() {\n  int x;\n  x += 2;\n }\n}";    private static final String TEST3 = "public class Foo {\n void bar() {\n  int x;\n  x *= 2;\n }\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTFormalParameterTest extends BaseParserTest {    @Test    public void testVarargs() {        int nrOfVarArgs = 0;        int nrOfNoVarArgs = 0;        List<ASTFormalParameter> ops = java.getNodes(ASTFormalParameter.class, TEST1, "1.5");        for (ASTFormalParameter b : ops) {            ASTVariableDeclaratorId variableDeclId = b.getFirstDescendantOfType(ASTVariableDeclaratorId.class);            if (!"x".equals(variableDeclId.getImage())) {                assertTrue(b.isVarargs());                nrOfVarArgs++;            } else {                assertFalse(b.isVarargs());                nrOfNoVarArgs++;            }        }        // Ensure that both possibilities are tested        assertEquals(1, nrOfVarArgs);        assertEquals(1, nrOfNoVarArgs);    }    private static final String TEST1 = "class Foo {\n void bar(int x, int... others) {}\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetLoader;public class PMD5RulesetTest {    @Test    public void loadRuleset() throws Exception {        RuleSetFactory ruleSetFactory = new RuleSetLoader().toFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet("net/sourceforge/pmd/lang/java/pmd5ruleset.xml");        Assert.assertNotNull(ruleset);        Assert.assertNull(ruleset.getRuleByName("GuardLogStatementJavaUtil"));        Assert.assertNull(ruleset.getRuleByName("GuardLogStatement"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import java.util.logging.Handler;import java.util.logging.LogRecord;import java.util.logging.Logger;import org.junit.After;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.RuleSetNotFoundException;public class QuickstartRulesetTest {    @Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    @After    public void cleanup() {        Handler[] handlers = Logger.getLogger(RuleSetFactory.class.getName()).getHandlers();        for (Handler handler : handlers) {            Logger.getLogger(RuleSetFactory.class.getName()).removeHandler(handler);        }    }    @Test    public void noDeprecations() throws RuleSetNotFoundException {        Logger.getLogger(RuleSetFactory.class.getName()).addHandler(new Handler() {            @Override            public void publish(LogRecord record) {                Assert.fail("No Logging expected: " + record.getMessage());            }            @Override            public void flush() {            }            @Override            public void close() throws SecurityException {            }        });        RuleSetFactory ruleSetFactory = new RuleSetLoader().enableCompatibility(false).toFactory();        RuleSet quickstart = ruleSetFactory.createRuleSet("rulesets/java/quickstart.xml");        Assert.assertFalse(quickstart.getRules().isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;import net.sourceforge.pmd.testframework.RuleTst;public class SuppressWarningsTest extends RuleTst {    private static class BarRule extends AbstractJavaRule {        @Override        public Object visit(ASTCompilationUnit cu, Object ctx) {            // Convoluted rule to make sure the violation is reported for the            // ASTCompilationUnit node            for (ASTClassOrInterfaceDeclaration c : cu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class)) {                if (c.getImage().equalsIgnoreCase("bar")) {                    addViolation(ctx, cu);                }            }            return super.visit(cu, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    public void testClassLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST1, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());        runTestFromString(TEST2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testInheritedSuppression() {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testMethodLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST4, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testConstructorLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST5, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testFieldLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST6, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testParameterLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST7, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testLocalVariableLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST8, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppression() {        Report rpt = new Report();        runTestFromString(TEST9, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionValue1() {        Report rpt = new Report();        runTestFromString(TEST9_VALUE1, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionValue2() {        Report rpt = new Report();        runTestFromString(TEST9_VALUE2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionValue3() {        Report rpt = new Report();        runTestFromString(TEST9_VALUE3, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionMulitpleValues1() {        Report rpt = new Report();        runTestFromString(TEST9_MULTIPLE_VALUES_1, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testSpecificSuppressionMulitpleValues2() {        Report rpt = new Report();        runTestFromString(TEST9_MULTIPLE_VALUES_2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testNoSuppressionBlank() {        Report rpt = new Report();        runTestFromString(TEST10, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(2, rpt.size());    }    @Test    public void testNoSuppressionSomethingElseS() {        Report rpt = new Report();        runTestFromString(TEST11, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(2, rpt.size());    }    @Test    public void testSuppressAll() {        Report rpt = new Report();        runTestFromString(TEST12, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testSpecificSuppressionAtTopLevel() {        Report rpt = new Report();        runTestFromString(TEST13, new BarRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    private static final String TEST1 = "@SuppressWarnings(\"PMD\")\npublic class Foo {}";    private static final String TEST2 = "@SuppressWarnings(\"PMD\")\npublic class Foo {\n void bar() {\n  int foo;\n }\n}";    private static final String TEST3 = "public class Baz {\n @SuppressWarnings(\"PMD\")\n public class Bar {\n  void bar() {\n   int foo;\n  }\n }\n}";    private static final String TEST4 = "public class Foo {\n @SuppressWarnings(\"PMD\")\n void bar() {\n  int foo;\n }\n}";    private static final String TEST5 = "public class Bar {\n @SuppressWarnings(\"PMD\")\n public Bar() {\n  int foo;\n }\n}";    private static final String TEST6 = "public class Bar {\n @SuppressWarnings(\"PMD\")\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST7 = "public class Bar {\n int foo;\n void bar(@SuppressWarnings(\"PMD\") int foo) {}\n}";    private static final String TEST8 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"PMD\") int foo;\n }\n}";    private static final String TEST9 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"PMD.NoFoo\") int foo;\n }\n}";    private static final String TEST9_VALUE1 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(value = \"PMD.NoFoo\") int foo;\n }\n}";    private static final String TEST9_VALUE2 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings({\"PMD.NoFoo\"}) int foo;\n }\n}";    private static final String TEST9_VALUE3 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(value = {\"PMD.NoFoo\"}) int foo;\n }\n}";    private static final String TEST9_MULTIPLE_VALUES_1 = "@SuppressWarnings({\"PMD.NoFoo\", \"PMD.NoBar\"})\npublic class Bar {\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST9_MULTIPLE_VALUES_2 = "@SuppressWarnings(value = {\"PMD.NoFoo\", \"PMD.NoBar\"})\npublic class Bar {\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST10 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"\") int foo;\n }\n}";    private static final String TEST11 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"SomethingElse\") int foo;\n }\n}";    private static final String TEST12 = "public class Bar {\n @SuppressWarnings(\"all\") int foo;\n}";    private static final String TEST13 = "@SuppressWarnings(\"PMD.NoBar\")\npublic class Bar {\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class JavaTokenizerTest extends CpdTextComparisonTest {    public JavaTokenizerTest() {        super(".java");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        JavaTokenizer javaTokenizer = new JavaTokenizer();        javaTokenizer.setProperties(properties);        return javaTokenizer;    }    @Override    protected String getResourcePrefix() {        return "../lang/java/cpd/testdata";    }    @Test    public void testCommentsIgnored() {        doTest("simpleClassWithComments");    }    @Test    public void testDiscardedElements() {        doTest("discardedElements", "_ignore_annots", ignoreAnnotations());    }    @Test    public void testDiscardedElementsExceptAnnots() {        doTest("discardedElements", "_no_ignore_annots");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testIgnoreBetweenSpecialAnnotation() {        doTest("ignoreSpecialAnnotations");    }    @Test    public void testIgnoreBetweenSpecialAnnotationAndIgnoreAnnotations() {        doTest("ignoreSpecialAnnotations", "_ignore_annots", ignoreAnnotations());    }    @Test    public void testIgnoreIdentifiersDontAffectConstructors() {        doTest("ignoreIdentsPreservesCtor", "", ignoreIdents());    }    @Test    public void testIgnoreIdentifiersHandlesEnums() {        doTest("ignoreIdentsPreservesEnum", "", ignoreIdents());    }    @Test    public void testIgnoreIdentifiersWithClassKeyword() {        doTest("ignoreIdentsPreservesClassLiteral", "", ignoreIdents());    }    @Test    public void testIgnoreLiterals() {        doTest("ignoreLiterals", "", ignoreLiterals());    }    @Test    public void testNoIgnoreLiterals() {        doTest("ignoreLiterals", "_noignore");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    private static Properties ignoreAnnotations() {        return properties(true, false, false);    }    private static Properties ignoreIdents() {        return properties(false, false, true);    }    private static Properties ignoreLiterals() {        return properties(false, true, false);    }    @Override    public Properties defaultProperties() {        return properties(false, false, false);    }    private static Properties properties(boolean ignoreAnnotations,                                         boolean ignoreLiterals,                                         boolean ignoreIdents) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.IGNORE_ANNOTATIONS, Boolean.toString(ignoreAnnotations));        properties.setProperty(Tokenizer.IGNORE_IDENTIFIERS, Boolean.toString(ignoreIdents));        properties.setProperty(Tokenizer.IGNORE_LITERALS, Boolean.toString(ignoreLiterals));        return properties;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.util.regex.Pattern;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;/** * Unit test for {@link CPDCommandLineInterface}. * */public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    /**     * Test ignore identifiers argument.     */    @Test    public void testIgnoreIdentifiers() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 7 line (36 tokens) duplication"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * Test ignore identifiers argument with failOnViolation=false     */    @Test    public void testIgnoreIdentifiersFailOnViolationFalse() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--failOnViolation",                "false");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 7 line (36 tokens) duplication"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * Test excludes option.     */    @Test    public void testExcludes() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--ignore-identifiers", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--exclude",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/File2.java");        String out = getOutput();        Assert.assertFalse(out.contains("Found a 7 line (34 tokens) duplication"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * #1144 CPD encoding argument has no effect     */    @Test    public void testEncodingOption() throws Exception {        String origEncoding = System.getProperty("file.encoding");        // set the default encoding under Windows        System.setProperty("file.encoding", "Cp1252");        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--format", "xml",                // request UTF-8 for CPD                "--encoding", "UTF-8");        // reset default encoding        System.setProperty("file.encoding", origEncoding);        String out = getOutput();        Assert.assertTrue(out.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));        Assert.assertTrue(Pattern.compile("System\\.out\\.println\\([ij] \\+ \"ä\"\\);").matcher(out).find());        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1178/     *     * @throws IOException     *             any error     */    @Test    public void testBrokenAndValidFile() throws IOException {        runCPD("--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/badandgood/", "--format", "text", "--skip-lexical-errors");        String out = getOutput();        Assert.assertTrue(                Pattern.compile("Skipping .*?BadFile\\.java\\. Reason: Lexical error in file").matcher(out).find());        Assert.assertTrue(out.contains("Found a 5 line (13 tokens) duplication"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    @Test    public void testFormatXmlWithoutEncoding() throws Exception {        runCPD("--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--format", "xml");        String out = getOutput();        Assert.assertTrue(out.contains("<duplication lines=\"3\" tokens=\"10\">"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    @Test    public void testCSVFormat() throws Exception {        runCPD("--minimum-tokens", "100", "--files", "src/test/resources/net/sourceforge/pmd/cpd/badandgood/",                "--language", "c", "--format", "csv");        String out = getOutput();        Assert.assertFalse(out.contains("Couldn't instantiate renderer"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.io.IOException;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.junit.Test;public class MatchAlgorithmTest {    private static final String LINE_1 = "public class Foo { ";    private static final String LINE_2 = " public void bar() {";    private static final String LINE_3 = "  System.out.println(\"hello\");";    private static final String LINE_4 = "  System.out.println(\"hello\");";    private static final String LINE_5 = "  int i = 5";    private static final String LINE_6 = "  System.out.print(\"hello\");";    private static final String LINE_7 = " }";    private static final String LINE_8 = "}";    private static String getSampleCode() {        return LINE_1 + "\n" + LINE_2 + "\n" + LINE_3 + "\n" + LINE_4 + "\n" + LINE_5 + "\n" + LINE_6                + "\n" + LINE_7 + "\n" + LINE_8;    }    @Test    public void testSimple() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(41, tokens.size());        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        Mark mark1 = marks.next();        Mark mark2 = marks.next();        assertFalse(marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals("Foo.java", mark1.getFilename());        assertEquals(LINE_3, mark1.getSourceCodeSlice());        assertEquals(4, mark2.getBeginLine());        assertEquals("Foo.java", mark2.getFilename());        assertEquals(LINE_4, mark2.getSourceCodeSlice());    }    @Test    public void testIgnore() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        tokenizer.setIgnoreLiterals(true);        tokenizer.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        marks.next();        marks.next();        marks.next();        assertFalse(marks.hasNext());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.Locale;import org.apache.commons.io.FileUtils;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.ExternalResource;import org.junit.rules.TestRule;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testNoFormattersValidation() {        executeTarget("testNoFormattersValidation");        assertOutputContaining("Fields should be declared at the top of the class");    }    @Test    public void testNestedRuleset() {        executeTarget("testNestedRuleset");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testFormatterWithProperties() {        executeTarget("testFormatterWithProperties");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");        assertOutputContaining("link_prefix");        assertOutputContaining("line_prefix");    }    @Test    public void testAbstractNames() {        executeTarget("testAbstractNames");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testAbstractNamesInNestedRuleset() {        executeTarget("testAbstractNamesInNestedRuleset");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testCommaInRulesetfiles() {        executeTarget("testCommaInRulesetfiles");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testRelativeRulesets() {        executeTarget("testRelativeRulesets");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testRelativeRulesetsInRulesetfiles() {        executeTarget("testRelativeRulesetsInRulesetfiles");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at");    }    @Test    public void testExplicitRuleInRuleSet() {        executeTarget("testExplicitRuleInRuleSet");        assertOutputContaining("Avoid really long methods");    }    @Test    public void testClasspath() {        executeTarget("testClasspath");    }    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @Rule    public final TestRule restoreLocale = new ExternalResource() {        private Locale originalLocale;        @Override        protected void before() throws Throwable {            originalLocale = Locale.getDefault();        }        @Override        protected void after() {            Locale.setDefault(originalLocale);        }    };    private static void setDefaultCharset(String charsetName) {        System.setProperty("file.encoding", charsetName);    }    @Rule    public final TestRule restoreDefaultCharset = new ExternalResource() {        private Charset defaultCharset;        @Override        protected void before() throws Throwable {            defaultCharset = Charset.defaultCharset();        }        @Override        protected void after() {            setDefaultCharset(defaultCharset.name());        }    };    @Test    public void testFormatterEncodingWithXML() throws Exception {        Locale.setDefault(Locale.FRENCH);        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXML");        String report = FileUtils.readFileToString(currentTempFile(), "UTF-8");        assertTrue(report.contains("someVariableWithÜmlaut"));    }    private static String convert(String report) {        // reinterpret output as cp1252 - ant BuildFileRule can only unicode        StringBuilder sb = new StringBuilder(report.length());        for (int i = 0; i < report.length(); i++) {            char c = report.charAt(i);            if (c > 0x7f) {                sb.append((char) (c & 0xff));            } else {                sb.append(c);            }        }        return sb.toString();    }    @Test    public void testFormatterEncodingWithXMLConsole() throws UnsupportedEncodingException {        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXMLConsole");        String report = convert(buildRule.getOutput());        assertTrue(report.startsWith("<?xml version=\"1.0\" encoding=\"windows-1252\"?>"));        assertTrue(report.contains("someVariableWithÜmlaut"));    }    @Test    public void testMissingCacheLocation() {        executeTarget("testMissingCacheLocation");        assertOutputContaining("Avoid really long methods");        assertContains(buildRule.getLog(), "This analysis could be faster");    }    @Test    public void testAnalysisCache() {        executeTarget("testAnalysisCache");        assertOutputContaining("Avoid really long methods");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertTrue(currentTempFile().exists());    }    @Test    public void testDisableIncrementalAnalysis() {        executeTarget("testDisableIncrementalAnalysis");        assertOutputContaining("Avoid really long methods");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertFalse(currentTempFile().exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;import net.sourceforge.pmd.testframework.TestDescriptor;public class RegexpAcceptanceTest extends SimpleAggregatorTst {    private static final String XPATH = "//ClassOrInterfaceDeclaration[matches(@Image, 'F?o')]";    @Override    protected void setUp() {        // not registering any rule    }    @Test    public void testSimple() {        Rule r = new XPathRule(XPATH);        r.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        r.setMessage("");        TestDescriptor[] testDescriptors = extractTestsFromXml(r, "RegexpAcceptance");        for (TestDescriptor testDescriptor : testDescriptors) {            testDescriptor.setReinitializeRule(false);        }        runTests(testDescriptors);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertSame;import static org.junit.Assert.fail;import java.util.Iterator;import java.util.List;import org.jaxen.BaseXPath;import org.jaxen.JaxenException;import org.jaxen.UnsupportedAxisException;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.xpath.DocumentNavigator;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.ASTStatement;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;import net.sourceforge.pmd.testframework.RuleTst;public class DocumentNavigatorTest extends RuleTst {    private TestRule rule;    private class TestRule extends AbstractJavaRule {        private Node compilationUnit;        private Node importDeclaration;        private Node statement;        private Node primaryPrefix;        private Node primaryExpression;        /**         * @see net.sourceforge.pmd.lang.java.ast.JavaParserVisitor#visit(ASTCompilationUnit,         *      Object)         */        public Object visit(ASTCompilationUnit node, Object data) {            this.compilationUnit = node;            return super.visit(node, data);        }        public Object visit(ASTImportDeclaration node, Object data) {            this.importDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTStatement node, Object data) {            this.statement = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryPrefix node, Object data) {            this.primaryPrefix = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryExpression node, Object data) {            this.primaryExpression = node;            return super.visit(node, data);        }    }    @Before    public void setUp() {        try {            rule = new TestRule();            runTestFromString(TEST, rule, new Report(),                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion());        } catch (Throwable xx) {            xx.printStackTrace();            fail();        }    }    @Test    public void testChildAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getChildAxisIterator(rule.compilationUnit);        assertSame(rule.compilationUnit.getChild(0), iter.next());        assertSame(rule.compilationUnit.getChild(1), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testParentAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getParentAxisIterator(rule.importDeclaration);        assertSame(rule.importDeclaration.getParent(), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testParentAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getParentAxisIterator(rule.compilationUnit);        assertFalse(iter.hasNext());    }    @Test    public void testDescendantAxisIterator() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator<?> iter = nav.getDescendantAxisIterator(rule.statement);        Node statementExpression = rule.statement.getChild(0);        assertSame(statementExpression, iter.next());        Node primaryExpression = statementExpression.getChild(0);        assertSame(primaryExpression, iter.next());        Node primaryPrefix = primaryExpression.getChild(0);        assertSame(primaryPrefix, iter.next());        Node primarySuffix = primaryExpression.getChild(1);        // assertSame(primarySuffix, iter.next());        Node name = primaryPrefix.getChild(0);        // assertSame(name, iter.next());        Node arguments = primarySuffix.getChild(0);        // assertSame(arguments, iter.next());        // assertFalse(iter.hasNext());    }    @Test    public void testDescendantAxisIterator2() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator<?> iter = nav.getDescendantAxisIterator(rule.primaryPrefix);        Node name = rule.primaryPrefix.getChild(0);        assertSame(name, iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testFollowingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.getChild(0));        assertSame(rule.primaryExpression.getChild(1), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testFollowingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.getChild(1));        assertFalse(iter.hasNext());    }    @Test    public void testPrecedingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.getChild(1));        assertSame(rule.primaryExpression.getChild(0), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testPrecedingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.getChild(0));        assertFalse(iter.hasNext());    }    @Test    public void testXPath() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List<?> matches = xPath.selectNodes(rule.statement);        assertEquals(6, matches.size());    }    @Test    public void testXPath2() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List<?> matches = xPath.selectNodes(rule.importDeclaration);        assertEquals(1, matches.size());    }    public static final String TEST = "import java.io.*;" + PMD.EOL + "public class Foo {" + PMD.EOL + " public Foo() {"            + PMD.EOL + "  try {" + PMD.EOL + "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL            + "  } catch (Exception e) {}" + PMD.EOL + "  try {" + PMD.EOL            + "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL + "  } catch (Exception e) {" + PMD.EOL            + "   e.printStackTrace();" + PMD.EOL + "   // this shouldn't show up on the report" + PMD.EOL + "  }"            + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution.typedefinition;import java.util.ArrayList;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;public class JavaTypeDefinitionSimpleTest {    /**     * Tests the raw type {@code ArrayList}.     */    @Test    public void arrayListWithoutBoundGenerics() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(ArrayList.class);        Assert.assertTrue(typeDef.isGeneric());        Assert.assertTrue(typeDef.isRawType());        Assert.assertEquals(1, typeDef.getTypeParameterCount());        JavaTypeDefinition genericType = typeDef.getGenericType(0);        Assert.assertFalse(genericType.isGeneric());        Assert.assertEquals(Object.class, genericType.getType());    }    /**     * Tests the type {@code ArrayList<String>}.     */    @Test    public void arrayListOfString() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(ArrayList.class, JavaTypeDefinition.forClass(String.class));        Assert.assertTrue(typeDef.isGeneric());        Assert.assertEquals(1, typeDef.getTypeParameterCount());        Assert.assertTrue(typeDef.isClassOrInterface());        Assert.assertFalse(typeDef.isArrayType());        JavaTypeDefinition genericType = typeDef.getGenericType(0);        Assert.assertFalse(genericType.isGeneric());        Assert.assertEquals(String.class, genericType.getType());        JavaTypeDefinition genericTypeByName = typeDef.getGenericType("E");        Assert.assertEquals(String.class, genericTypeByName.getType());    }    @Test    public void array() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(String[].class);        Assert.assertFalse(typeDef.isGeneric());        Assert.assertTrue(typeDef.isArrayType());        Assert.assertFalse(typeDef.isClassOrInterface());        Assert.assertEquals(String.class, typeDef.getElementType().getType());        Assert.assertFalse(typeDef.isPrimitive());    }    @Test    public void primitive() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(int.class);        Assert.assertTrue(typeDef.isPrimitive());        Assert.assertFalse(typeDef.isClassOrInterface());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.CONTAINS;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.EQUALITY;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.LOOSE_INVOCATION;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.SUBTYPE;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Bound;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.BoundOrConstraint;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Constraint;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.TypeInferenceResolver;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Variable;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA2;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther2;public class TypeInferenceTest {    private JavaTypeDefinition number = JavaTypeDefinition.forClass(Number.class);    private JavaTypeDefinition integer = JavaTypeDefinition.forClass(Integer.class);    private JavaTypeDefinition primitiveInt = JavaTypeDefinition.forClass(int.class);    private JavaTypeDefinition generic = JavaTypeDefinition.forClass(Map.class, number, integer);    private Variable alpha = new Variable();    private Variable beta = new Variable();    private JavaTypeDefinition s = JavaTypeDefinition.forClass(int.class);    private JavaTypeDefinition t = JavaTypeDefinition.forClass(double.class);    @Test    public void testEqualityReduceProperVsProper() {        // If S and T are proper types, the constraint reduces to true if S is the same as T (§4.3.4), and false        // otherwise.        assertTrue(new Constraint(number, number, EQUALITY).reduce().isEmpty());        assertNull(new Constraint(number, integer, EQUALITY).reduce());        // Otherwise, if S or T is the null type, the constraint reduces to false. TODO    }    @Test    public void testEqualityReduceVariableVsNotPrimitive() {        // Otherwise, if S is an inference variable, α, and T is not a primitive type, the constraint reduces to        // the bound α = T.        List<BoundOrConstraint> result = new Constraint(alpha, number, EQUALITY).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, number, EQUALITY, Bound.class);    }    @Test    public void testEqualityReduceNotPrimitiveVsVariable() {        // Otherwise, if T is an inference variable, α, and S is not a primitive type, the constraint reduces        // to the bound S = α.        List<BoundOrConstraint> result = new Constraint(number, alpha, EQUALITY).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, alpha, EQUALITY, Bound.class);        result = new Constraint(alpha, beta, EQUALITY).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, beta, EQUALITY, Bound.class);    }    @Test    public void testEqualityReduceSameErasure() {        // Otherwise, if S and T are class or interface types with the same erasure, where S has type        // arguments B1, ..., Bn and T has type arguments A1, ..., An, the constraint reduces to the        // following new constraints: for all i (1 ≤ i ≤ n), ‹Bi = Ai›.        List<BoundOrConstraint> result = new Constraint(generic, generic, EQUALITY).reduce();        assertEquals(2, result.size());        testBoundOrConstraint(result.get(0), number, number, EQUALITY, Constraint.class);        testBoundOrConstraint(result.get(1), integer, integer, EQUALITY, Constraint.class);    }    @Test    public void testEqualityReduceArrayTypes() {        // Otherwise, if S and T are array types, S'[] and T'[], the constraint reduces to ‹S' = T'›.        List<BoundOrConstraint> result = new Constraint(JavaTypeDefinition.forClass(Number[].class),                                                        JavaTypeDefinition.forClass(Integer[].class), EQUALITY)                .reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, integer, EQUALITY, Constraint.class);    }    @Test    public void testSubtypeReduceProperVsProper() {        // A constraint formula of the form ‹S <: T› is reduced as follows:        // If S and T are proper types, the constraint reduces to true if S is a subtype of T (§4.10),        // and false otherwise.        List<BoundOrConstraint> result = new Constraint(integer, number, SUBTYPE).reduce();        assertEquals(0, result.size());        result = new Constraint(number, integer, SUBTYPE).reduce();        assertNull(result);        // Otherwise, if S is the null type, the constraint reduces to true. TODO        // Otherwise, if T is the null type, the constraint reduces to false. TODO    }    @Test    public void testSubtypeReduceVariableVsAny() {        // Otherwise, if S is an inference variable, α, the constraint reduces to the bound α <: T.        List<BoundOrConstraint> result = new Constraint(alpha, integer, SUBTYPE).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, integer, SUBTYPE, Bound.class);    }    @Test    public void testSubtypeReduceAnyVsVariable() {        // Otherwise, if T is an inference variable, α, the constraint reduces to the bound S <: α.        List<BoundOrConstraint> result = new Constraint(integer, alpha, SUBTYPE).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), integer, alpha, SUBTYPE, Bound.class);        result = new Constraint(alpha, beta, SUBTYPE).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, beta, SUBTYPE, Bound.class);    }    @Test    public void testLooseInvocationProperVsProper() {        // A constraint formula of the form ‹S → T› is reduced as follows:        // If S and T are proper types, the constraint reduces to true if S is compatible in a loose invocation        // context with T (§5.3), and false otherwise.        List<BoundOrConstraint> result = new Constraint(number, integer, LOOSE_INVOCATION).reduce();        assertNull(result);        result = new Constraint(integer, number, LOOSE_INVOCATION).reduce();        assertEquals(0, result.size());    }    @Test    public void testLooseInvocationLeftBoxing() {        // Otherwise, if S is a primitive type, let S' be the result of applying boxing conversion (§5.1.7) to S.        // Then the constraint reduces to ‹S' → T›.        List<BoundOrConstraint> result = new Constraint(primitiveInt, number, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), integer, number, LOOSE_INVOCATION, Constraint.class);    }    @Test    public void testLooseInvocationRightBoxing() {        // Otherwise, if T is a primitive type, let T' be the result of applying boxing conversion (§5.1.7) to T.        // Then the constraint reduces to ‹S = T'›.        List<BoundOrConstraint> result = new Constraint(number, primitiveInt, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, integer, EQUALITY, Constraint.class);        // Otherwise, if T is a parameterized type of the form G<T1, ..., Tn>, and there exists no type of the        // form G<...> that is a supertype of S, but the raw type G is a supertype of S, then the constraint        // reduces to true. TODO        // Otherwise, if T is an array type of the form G<T1, ..., Tn>[]k, and there exists no type of the form        // G<...>[]k that is a supertype of S, but the raw type G[]k is a supertype of S, then the constraint        // reduces to true. (The notation []k indicates an array type of k dimensions.) TODO    }    @Test    public void testLooseInvocationAnythingElse() {        // Otherwise, the constraint reduces to ‹S<:T›.        List<BoundOrConstraint> result = new Constraint(number, alpha, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, alpha, SUBTYPE, Constraint.class);        result = new Constraint(alpha, number, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, number, SUBTYPE, Constraint.class);    }    @Test    public void testContainmentReduceTypeVsType() {        // A constraint formula of the form ‹S <= T›, where S and T are type arguments (§4.5.1), is reduced as        // follows:        // If T is a type: // If S is a type, the constraint reduces to ‹S = T›.        List<BoundOrConstraint> result = new Constraint(number, integer, CONTAINS).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, integer, EQUALITY, Constraint.class);        // If T is a type: // If S is a wildcard, the constraint reduces to false. TODO        // If T is a wildcard of the form ?, the constraint reduces to true. TODO        // If T is a wildcard of the form ? extends T': TODO        // If T is a wildcard of the form ? super T': TODO    }    @Test    public void testIncorporationEqualityAndEquality() {        List<Constraint> result;        // ### Original rule 1. : α = S and α = T imply ‹S = T›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(alpha, t, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);        // α = S and T = α imply ‹S = T›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(t, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);        // S = α and α = T imply ‹S = T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(alpha, t, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);        // S = α and T = α imply ‹S = T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(t, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);    }    @Test    public void testIncorporationEqualityAndSubtypeLeftVariable() {        List<Constraint> result;        // ### Original rule 2. : α = S and α <: T imply ‹S <: T›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(alpha, t, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // S = α and α <: T imply ‹S <: T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(alpha, t, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // α <: T and α = S imply ‹S <: T›        result = incorporationResult(new Bound(alpha, t, SUBTYPE), new Bound(alpha, s, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // α <: T and S = α imply ‹S <: T›        result = incorporationResult(new Bound(alpha, t, SUBTYPE), new Bound(s, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);    }    @Test    public void testIncorporationEqualityAndSubtypeRightVariable() {        List<Constraint> result;        // ### Original rule 3. : α = S and T <: α imply ‹T <: S›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(t, alpha, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);        // S = α and T <: α imply ‹T <: S›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(t, alpha, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);        // T <: α and α = S imply ‹T <: S›        result = incorporationResult(new Bound(t, alpha, SUBTYPE), new Bound(alpha, s, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);        // T <: α and S = α imply ‹T <: S›        result = incorporationResult(new Bound(t, alpha, SUBTYPE), new Bound(s, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);    }    @Test    public void testIncorporationSubtypeAndSubtype() {        List<Constraint> result;        // ### Original rule 4. : S <: α and α <: T imply ‹S <: T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(alpha, t, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // α <: T and S <: α imply ‹S <: T›        result = incorporationResult(new Bound(alpha, t, SUBTYPE), new Bound(s, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);    }    @Test    public void testErasedCandidateSet() {        List<JavaTypeDefinition> types = new ArrayList<>();        types.add(JavaTypeDefinition.forClass(List.class));        types.add(JavaTypeDefinition.forClass(Set.class));        Set<Class<?>> erasedCandidate = TypeInferenceResolver.getErasedCandidateSet(types);        assertEquals(3, erasedCandidate.size());        assertTrue(erasedCandidate.contains(Object.class));        assertTrue(erasedCandidate.contains(Collection.class));        assertTrue(erasedCandidate.contains(Iterable.class));        Set<Class<?>> emptySet = TypeInferenceResolver.getErasedCandidateSet(Collections.<JavaTypeDefinition>emptyList());        assertNotNull(emptySet);        assertEquals(0, emptySet.size());    }    @Test    public void testMinimalErasedCandidateSet() {        Set<Class<?>> minimalSet = TypeInferenceResolver.getMinimalErasedCandidateSet(                JavaTypeDefinition.forClass(List.class).getErasedSuperTypeSet());        assertEquals(1, minimalSet.size());        assertTrue(minimalSet.contains(List.class));    }    @Test    public void testLeastUpperBound() {        List<JavaTypeDefinition> lowerBounds = new ArrayList<>();        lowerBounds.add(JavaTypeDefinition.forClass(SuperClassA.class));        lowerBounds.add(JavaTypeDefinition.forClass(SuperClassAOther.class));        lowerBounds.add(JavaTypeDefinition.forClass(SuperClassAOther2.class));        assertEquals(JavaTypeDefinition.forClass(SuperClassA2.class), TypeInferenceResolver.lub(lowerBounds));    }    @Test    public void testResolution() {        List<Bound> bounds = new ArrayList<>();        bounds.add(new Bound(JavaTypeDefinition.forClass(SuperClassA.class), alpha, SUBTYPE));        bounds.add(new Bound(JavaTypeDefinition.forClass(SuperClassAOther.class), alpha, SUBTYPE));        Map<Variable, JavaTypeDefinition> result = TypeInferenceResolver.resolveVariables(bounds);        assertEquals(1, result.size());        assertEquals(JavaTypeDefinition.forClass(SuperClassA2.class), result.get(alpha));    }    private List<Constraint> incorporationResult(Bound firstBound, Bound secondBound) {        List<Bound> current = new ArrayList<>();        List<Bound> newBounds = new ArrayList<>();        current.add(firstBound);        newBounds.add(secondBound);        return TypeInferenceResolver.incorporateBounds(current, newBounds);    }    private void testBoundOrConstraint(BoundOrConstraint val, JavaTypeDefinition left, JavaTypeDefinition right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftProper());        assertEquals(right, val.rightProper());        assertEquals(rule, val.ruleType());    }    private void testBoundOrConstraint(BoundOrConstraint val, JavaTypeDefinition left, Variable right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftProper());        assertEquals(right, val.rightVariable());        assertEquals(rule, val.ruleType());    }    private void testBoundOrConstraint(BoundOrConstraint val, Variable left, JavaTypeDefinition right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftVariable());        assertEquals(right, val.rightProper());        assertEquals(rule, val.ruleType());    }    private void testBoundOrConstraint(BoundOrConstraint val, Variable left, Variable right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftVariable());        assertEquals(right, val.rightVariable());        assertEquals(rule, val.ruleType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.fail;import java.util.Map;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader;public class PMDASMClassLoaderTest {    private PMDASMClassLoader cl;    @Before    public void setUp() throws Exception {        cl = PMDASMClassLoader.getInstance(getClass().getClassLoader());    }    @Test    public void testLoadClassWithImportOnDemand() throws Exception {        String className = "net.sourceforge.pmd.typeresolution.ClassWithImportOnDemand";        Class<?> clazz = cl.loadClass(className);        assertNotNull(clazz);        Map<String, String> imports = cl.getImportedClasses(className);        assertNotNull(imports);        assertEquals("java.util.List", imports.get("List"));        assertEquals("java.util.ArrayList", imports.get("ArrayList"));        assertEquals("java.lang.Object", imports.get("Object"));        assertEquals("net.sourceforge.pmd.typeresolution.ClassWithImportOnDemand",                imports.get("ClassWithImportOnDemand"));    }    @Test    public void testClassWithImportInnerOnDemand() throws Exception {        String className = "net.sourceforge.pmd.typeresolution.ClassWithImportInnerOnDemand";        Class<?> clazz = cl.loadClass(className);        assertNotNull(clazz);        Map<String, String> imports = cl.getImportedClasses(className);        assertNotNull(imports);        assertEquals("java.util.Iterator", imports.get("Iterator"));        assertEquals("java.util.Map", imports.get("Map"));        assertEquals("java.util.Set", imports.get("Set"));        assertEquals("java.util.Map$Entry", imports.get("Entry"));        assertEquals("java.util.Map$Entry", imports.get("Map$Entry"));        assertEquals("java.lang.Object", imports.get("Object"));        assertEquals("java.util.StringTokenizer", imports.get("StringTokenizer"));        assertEquals("net.sourceforge.pmd.typeresolution.ClassWithImportInnerOnDemand",                imports.get("ClassWithImportInnerOnDemand"));    }    /**     * Unit test for bug 3546093.     *     * @throws Exception     *             any error     */    @Test    public void testCachingOfNotFoundClasses() throws Exception {        MockedClassLoader mockedClassloader = new MockedClassLoader();        PMDASMClassLoader cl = PMDASMClassLoader.getInstance(mockedClassloader);        String notExistingClassname = "that.clazz.doesnot.Exist";        try {            cl.loadClass(notExistingClassname);            fail();        } catch (ClassNotFoundException e) {            // expected        }        try {            cl.loadClass(notExistingClassname);            fail();        } catch (ClassNotFoundException e) {            // expected        }        assertEquals(1, mockedClassloader.findClassCalls);    }    private static class MockedClassLoader extends ClassLoader {        int findClassCalls = 0;        @Override        protected Class<?> findClass(String name) throws ClassNotFoundException {            findClassCalls++;            return super.findClass(name);        }    }    /**     * With this test you can verify, how much memory could be consumed by the     * dontBother cache.     *     * @throws Exception     *             any error     */    @Ignore    @Test    public void testCachingMemoryConsumption() throws Exception {        MockedClassLoader mockedClassLoader = new MockedClassLoader();        PMDASMClassLoader cl = PMDASMClassLoader.getInstance(mockedClassLoader);        Runtime runtime = Runtime.getRuntime();        System.gc();        long usedBytesBefore = runtime.totalMemory() - runtime.freeMemory();        for (long i = 0; i < 3000; i++) {            try {                cl.loadClass("com.very.long.package.name.and.structure.MyClass" + i);            } catch (ClassNotFoundException e) {                // expected            }        }        long usedBytesAfter = runtime.totalMemory() - runtime.freeMemory();        System.out.println((usedBytesAfter - usedBytesBefore) / (1024.0 * 1024.0) + " mb needed");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static org.junit.Assert.assertSame;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.MethodTypeResolution;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;public class MethodTypeResolutionTest {    @Test    public void testBoxingRules() {        assertSame(Boolean.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(boolean.class)).getType());        assertSame(Double.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(double.class)).getType());        assertSame(Float.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(float.class)).getType());        assertSame(Long.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(long.class)).getType());        assertSame(Integer.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(int.class)).getType());        assertSame(Character.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(char.class)).getType());        assertSame(Short.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(short.class)).getType());        assertSame(Byte.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(byte.class)).getType());        assertSame(Void.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(void.class)).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static junit.framework.TestCase.assertTrue;import static net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition.forClass;import static net.sourceforge.pmd.lang.java.typeresolution.typedefinition.TypeDefinitionType.LOWER_WILDCARD;import static net.sourceforge.pmd.lang.java.typeresolution.typedefinition.TypeDefinitionType.UPPER_WILDCARD;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.LOOSE_INVOCATION;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.SUBTYPE;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collection;import java.util.Comparator;import java.util.HashSet;import java.util.List;import java.util.Objects;import java.util.Set;import java.util.StringTokenizer;import org.jaxen.JaxenException;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;import net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBodyDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTEnumConstant;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTLiteral;import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;import net.sourceforge.pmd.lang.java.ast.ASTReferenceType;import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;import net.sourceforge.pmd.lang.java.ast.ASTType;import net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.AbstractJavaNode;import net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;import net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;import net.sourceforge.pmd.lang.java.typeresolution.MethodType;import net.sourceforge.pmd.lang.java.typeresolution.MethodTypeResolution;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Bound;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Constraint;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Variable;import net.sourceforge.pmd.typeresolution.testdata.AbstractReturnTypeUseCase;import net.sourceforge.pmd.typeresolution.testdata.AnonymousClassFromInterface;import net.sourceforge.pmd.typeresolution.testdata.AnonymousExtendingObject;import net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;import net.sourceforge.pmd.typeresolution.testdata.ArrayAccess;import net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;import net.sourceforge.pmd.typeresolution.testdata.ArrayTypes;import net.sourceforge.pmd.typeresolution.testdata.ArrayVariableDeclaration;import net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;import net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;import net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;import net.sourceforge.pmd.typeresolution.testdata.FieldAccess;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericBounds;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericNested;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericParameter;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericRaw;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericSimple;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessNested;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessPrimaryGenericSimple;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessShadow;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessStatic;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessSuper;import net.sourceforge.pmd.typeresolution.testdata.GenericMethodsImplicit;import net.sourceforge.pmd.typeresolution.testdata.GenericsArrays;import net.sourceforge.pmd.typeresolution.testdata.InnerClass;import net.sourceforge.pmd.typeresolution.testdata.JavaTypeDefinitionToStringNPE;import net.sourceforge.pmd.typeresolution.testdata.Literals;import net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass;import net.sourceforge.pmd.typeresolution.testdata.MethodAccessibility;import net.sourceforge.pmd.typeresolution.testdata.MethodCallExpressionTypes;import net.sourceforge.pmd.typeresolution.testdata.MethodFirstPhase;import net.sourceforge.pmd.typeresolution.testdata.MethodGenericExplicit;import net.sourceforge.pmd.typeresolution.testdata.MethodGenericParam;import net.sourceforge.pmd.typeresolution.testdata.MethodMostSpecific;import net.sourceforge.pmd.typeresolution.testdata.MethodPotentialApplicability;import net.sourceforge.pmd.typeresolution.testdata.MethodSecondPhase;import net.sourceforge.pmd.typeresolution.testdata.MethodStaticAccess;import net.sourceforge.pmd.typeresolution.testdata.MethodThirdPhase;import net.sourceforge.pmd.typeresolution.testdata.NestedAllocationExpressions;import net.sourceforge.pmd.typeresolution.testdata.NestedAnonymousClass;import net.sourceforge.pmd.typeresolution.testdata.Operators;import net.sourceforge.pmd.typeresolution.testdata.OverloadedMethodsUsage;import net.sourceforge.pmd.typeresolution.testdata.PmdStackOverflow;import net.sourceforge.pmd.typeresolution.testdata.Promotion;import net.sourceforge.pmd.typeresolution.testdata.SubTypeUsage;import net.sourceforge.pmd.typeresolution.testdata.SuperExpression;import net.sourceforge.pmd.typeresolution.testdata.ThisExpression;import net.sourceforge.pmd.typeresolution.testdata.VarArgsMethodUseCase;import net.sourceforge.pmd.typeresolution.testdata.VarargsAsFixedArity;import net.sourceforge.pmd.typeresolution.testdata.VarargsZeroArity;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.Converter;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.GenericClass;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.JavaTypeDefinitionEquals;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.StaticMembers;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA2;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther2;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassB;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassB2;// TODO split that classpublic class ClassTypeResolverTest {    private final JavaParsingHelper java8 = JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("1.8");    private final JavaParsingHelper java4 = java8.withDefaultVersion("1.4");    private final JavaParsingHelper java5 = java8.withDefaultVersion("1.5");    private final JavaParsingHelper java7 = java8.withDefaultVersion("1.7");    private final JavaParsingHelper java11 = java8.withDefaultVersion("11");    private final JavaParsingHelper java9 = java8.withDefaultVersion("9");    @Test    public void stackOverflowTest() {        // See #831 https://github.com/pmd/pmd/issues/831 - [java] StackOverflow in JavaTypeDefinitionSimple.toString        java5.parseClass(PmdStackOverflow.class);    }    @Test    public void testClassNameExists() {        ClassTypeResolver classTypeResolver = new ClassTypeResolver();        assertEquals(true, classTypeResolver.classNameExists("java.lang.System"));        assertEquals(false, classTypeResolver.classNameExists("im.sure.that.this.does.not.Exist"));        assertEquals(true, classTypeResolver.classNameExists("java.awt.List"));    }    @Test    public void acceptanceTest() {        ASTCompilationUnit acu = java5.parseClass(ArrayListFound.class);        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());        assertEquals(ArrayListFound.class,                     acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);        assertEquals("java.util", id.getPackage().getName());        assertEquals(ArrayList.class, id.getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());        acu = java5.parseClass(DefaultJavaLangImport.class);        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());    }    /**     * See bug #1138 Anonymous inner class in enum causes NPE     */    @Test    public void testEnumAnonymousInnerClass() {        ASTCompilationUnit acu = java5.parseClass(EnumWithAnonymousInnerClass.class);        // try it in jshell, an enum constant with a body is compiled to an anonymous class,        // the counter is shared with other anonymous classes of the enum        Class<?> enumAnon = acu.getFirstDescendantOfType(ASTEnumConstant.class).getQualifiedName().getType();        assertEquals("net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1", enumAnon.getName());        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)                .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();        assertEquals("net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$2", inner.getName());    }    /**     * See bug #899 toString causes NPE     */    @Test    public void testNPEInJavaTypeDefinitionToString() {        // Just parsing this file throws a NPE        java8.parseClass(JavaTypeDefinitionToStringNPE.class);    }    @Test    public void testExtraTopLevelClass() throws ClassNotFoundException {        ASTCompilationUnit acu = java5.parseClass(ExtraTopLevelClass.class);        Class<?> theExtraTopLevelClass = Class                .forName("net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass");        // First class        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.getChild(1);        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());        assertEquals(ExtraTopLevelClass.class,                     typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());        // Second class        typeDeclaration = (ASTTypeDeclaration) acu.getChild(2);        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());        assertEquals(theExtraTopLevelClass,                     typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());    }    @Test    public void testInnerClass() throws ClassNotFoundException {        ASTCompilationUnit acu = java5.parseClass(InnerClass.class);        Class<?> theInnerClass = Class.forName("net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass");        // Outer class        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);        assertEquals(InnerClass.class, typeDeclaration.getType());        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(InnerClass.class, outerClassDeclaration.getType());        // Inner class        assertEquals(theInnerClass,                     outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());        // Method parameter as inner class        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);        assertEquals(theInnerClass, formalParameter.getType());    }    /**     * If we don't have the auxclasspath, we might not find the inner class. In     * that case, we'll need to search by name for a match.     *     * @throws Exception     */    @Test    public void testInnerClassNotCompiled() throws Exception {        Node acu = java8.parse("public class TestInnerClass {\n" + "    public void foo() {\n"                                                        + "        Statement statement = new Statement();\n" + "    "                                                        + "}\n" + "    static class Statement {\n"                                                        + "    }\n"                                                        + "}");        ASTClassOrInterfaceType statement = acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class);        Assert.assertTrue(statement.isReferenceToClassSameCompilationUnit());    }    @Test    public void testAnonymousClassFromInterface() throws Exception {        Node acu = java8.parseClass(AnonymousClassFromInterface.class);        ASTAllocationExpression allocationExpression = acu.getFirstDescendantOfType(ASTAllocationExpression.class);        TypeNode child = (TypeNode) allocationExpression.getChild(0);        Assert.assertTrue(Comparator.class.isAssignableFrom(child.getType()));        Assert.assertSame(Integer.class, child.getTypeDefinition().getGenericType(0).getType());    }    @Test    public void testNestedAnonymousClass() throws Exception {        Node acu = java8.parseClass(NestedAnonymousClass.class);        ASTAllocationExpression allocationExpression = acu.getFirstDescendantOfType(ASTAllocationExpression.class);        ASTAllocationExpression nestedAllocation                = allocationExpression.getFirstDescendantOfType(ASTClassOrInterfaceBodyDeclaration.class) // get the declaration (boundary)                .getFirstDescendantOfType(ASTAllocationExpression.class); // and dive for the nested allocation        TypeNode child = (TypeNode) nestedAllocation.getChild(0);        Assert.assertTrue(Converter.class.isAssignableFrom(child.getType()));        Assert.assertSame(String.class, child.getTypeDefinition().getGenericType(0).getType());    }    @Test    public void testAnonymousExtendingObject() throws Exception {        Node acu = java8.parseClass(AnonymousExtendingObject.class);        ASTAllocationExpression allocationExpression = acu.getFirstDescendantOfType(ASTAllocationExpression.class);        TypeNode child = (TypeNode) allocationExpression.getChild(0);        Assert.assertTrue(Object.class.isAssignableFrom(child.getType()));    }    @Test    public void testAnonymousInnerClass() throws ClassNotFoundException {        ASTCompilationUnit acu = java5.parseClass(AnonymousInnerClass.class);        Class<?> theAnonymousInnerClass = Class                .forName("net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1");        // Outer class        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());        // Anonymous Inner class        assertEquals(theAnonymousInnerClass,                     outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());    }    @Test    public void testLiterals() throws JaxenException {        List<ASTLiteral> literals = selectNodes(Literals.class, ASTLiteral.class);        int index = 0;        // String s = "s";        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(String.class, literals.get(index++).getType());        // boolean boolean1 = false;        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());        assertEquals(Boolean.TYPE, literals.get(index++).getType());        // boolean boolean2 = true;        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());        assertEquals(Boolean.TYPE, literals.get(index++).getType());        // Object obj = null;        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());        assertNull(literals.get(index++).getType());        // byte byte1 = 0;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // byte byte2 = 0x0F;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // byte byte3 = -007;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // short short1 = 0;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // short short2 = 0x0F;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // short short3 = -007;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char1 = 0;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char2 = 0x0F;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char3 = 007;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char4 = 'a';        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // int int1 = 0;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // int int2 = 0x0F;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // int int3 = -007;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // int int4 = 'a';        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // long long1 = 0;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // long long2 = 0x0F;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // long long3 = -007;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // long long4 = 0L;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Long.TYPE, literals.get(index++).getType());        // long long5 = 0x0Fl;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Long.TYPE, literals.get(index++).getType());        // long long6 = -007L;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Long.TYPE, literals.get(index++).getType());        // long long7 = 'a';        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // float float1 = 0.0f;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Float.TYPE, literals.get(index++).getType());        // float float2 = -10e+01f;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Float.TYPE, literals.get(index++).getType());        // float float3 = 0x08.08p3f;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Float.TYPE, literals.get(index++).getType());        // float float4 = 0xFF;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // float float5 = 'a';        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // double double1 = 0.0;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Double.TYPE, literals.get(index++).getType());        // double double2 = -10e+01;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Double.TYPE, literals.get(index++).getType());        // double double3 = 0x08.08p3;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Double.TYPE, literals.get(index++).getType());        // double double4 = 0xFF;        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // double double5 = 'a';        assertEquals(0, literals.get(index).getNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // Make sure we got them all.        assertEquals("All literals not tested", index, literals.size());    }    @Test    public void testUnaryNumericPromotion() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Promotion.class);        List<ASTExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'unaryNumericPromotion']/Block//Expression[UnaryExpression]"),                ASTExpression.class);        int index = 0;        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryNumericPromotion() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Promotion.class);        List<ASTExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'binaryNumericPromotion']/Block//Expression[AdditiveExpression]"),                ASTExpression.class);        int index = 0;        // LHS = byte        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = short        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = char        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = int        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = long        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = float        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = double        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryStringPromotion() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Promotion.class);        List<ASTExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'binaryStringPromotion']/Block//Expression"),                ASTExpression.class);        int index = 0;        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testUnaryLogicalOperators() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Operators.class);        List<ASTExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'unaryLogicalOperators']/Block//Expression"),                ASTExpression.class);        int index = 0;        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryLogicalOperators() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Operators.class);        List<ASTExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'binaryLogicalOperators']/Block//Expression"),                ASTExpression.class);        int index = 0;        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testUnaryNumericOperators() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Operators.class);        List<TypeNode> expressions = new ArrayList<>();        final String baseXPath = "//MethodDeclaration[@Name = 'unaryNumericOperators']/Block";        expressions.addAll(convertList(                acu.findChildNodesWithXPath(                        baseXPath + "//Expression"),                TypeNode.class));        expressions.addAll(convertList(                acu.findChildNodesWithXPath(                        baseXPath + "//PostfixExpression"),                TypeNode.class));        expressions.addAll(convertList(                acu.findChildNodesWithXPath(                        baseXPath + "//PreIncrementExpression"),                TypeNode.class));        expressions.addAll(convertList(                acu.findChildNodesWithXPath(                        baseXPath + "//PreDecrementExpression"),                TypeNode.class));        int index = 0;        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryNumericOperators() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Operators.class);        List<ASTExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'binaryNumericOperators']/Block//Expression"),                ASTExpression.class);        int index = 0;        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testAssignmentOperators() throws JaxenException {        ASTCompilationUnit acu = java5.parseClass(Operators.class);        List<ASTStatementExpression> expressions = convertList(                acu.findChildNodesWithXPath(                        "//MethodDeclaration[@Name = 'assignmentOperators']/Block//StatementExpression"),                ASTStatementExpression.class);        int index = 0;        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    /**     * The type should be filled also on the ASTVariableDeclaratorId node, not     * only on the variable name declaration.     */    @Test    public void testFullyQualifiedType() {        String source = "public class Foo {\n" + "    public void bar() {\n"                + "        java.util.StringTokenizer st = new StringTokenizer(\"a.b.c.d\", \".\");\n"                + "        while (st.hasMoreTokens()) {\n" + "            System.out.println(st.nextToken());\n"                + "        }\n" + "    }\n" + "}";        ASTCompilationUnit acu = java5.parse(source);        List<ASTName> names = acu.findDescendantsOfType(ASTName.class);        ASTName theStringTokenizer = null;        for (ASTName name : names) {            if (name.hasImageEqualTo("st.hasMoreTokens")) {                theStringTokenizer = name;                break;            }        }        Assert.assertNotNull(theStringTokenizer);        VariableNameDeclaration declaration = (VariableNameDeclaration) theStringTokenizer.getNameDeclaration();        Assert.assertNotNull(declaration);        Assert.assertEquals("java.util.StringTokenizer", declaration.getTypeImage());        Assert.assertNotNull(declaration.getType());        Assert.assertSame(StringTokenizer.class, declaration.getType());        ASTVariableDeclaratorId id = (ASTVariableDeclaratorId) declaration.getNode();        Assert.assertNotNull(id.getType());        Assert.assertSame(StringTokenizer.class, id.getType());    }    @Test    public void testThisExpression() {        ASTCompilationUnit compilationUnit = java5.parseClass(ThisExpression.class);        // need to cross borders, to find expressions of the nested classes        List<ASTPrimaryExpression> expressions = compilationUnit.findDescendantsOfType(ASTPrimaryExpression.class, true);        List<ASTPrimaryPrefix> prefixes = compilationUnit.findDescendantsOfType(ASTPrimaryPrefix.class, true);        int index = 0;        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.ThisExprNested.class, expressions.get(index).getType());        assertEquals(ThisExpression.ThisExprNested.class, prefixes.get(index++).getType());        // Qualified this        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index).getType());        assertEquals(ThisExpression.class, ((TypeNode) expressions.get(index++).getChild(1)).getType());        assertEquals(ThisExpression.ThisExprStaticNested.class, expressions.get(index).getType());        assertEquals(ThisExpression.ThisExprStaticNested.class, prefixes.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());        assertEquals("All expressions not tested", index, prefixes.size());    }    @Test    public void testSuperExpression() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(SuperExpression.class, AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix");        int index = 0;        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperExpression.class, ((TypeNode) expressions.get(index).getParent().getChild(0))                .getType());        assertEquals(SuperClassA.class, ((TypeNode) expressions.get(index++).getParent().getChild(1)).getType());        assertEquals(SuperExpression.class, expressions.get(index++).getType());        assertEquals(SuperExpression.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testArrayTypes() throws JaxenException {        // We must not select the expression in the dimensions        List<ASTExpression> expressions = selectNodes(ArrayTypes.class, ASTExpression.class, "//VariableInitializer/Expression");        int index = 0;        // int[] a = new int[1];        //           ----------        assertEquals(int[].class, expressions.get(index++).getType());        // Object[][] b = new Object[1][0];        //                ----------------        assertEquals(Object[][].class, expressions.get(index++).getType());        // ArrayTypes[][][] c = new ArrayTypes[][][] { new ArrayTypes[1][2] };        //                      ---------------------------------------------        assertEquals(ArrayTypes[][][].class, expressions.get(index++).getType());        // ArrayTypes[][][] c = new ArrayTypes[][][] { new ArrayTypes[1][2] };        //                                             --------------------        assertEquals(ArrayTypes[][].class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testArrayAccess() throws JaxenException {        List<ASTExpression> expressions = selectNodes(ArrayAccess.class, ASTExpression.class, "//VariableInitializer/Expression");        int index = 1;        // int aElement = a[0];        assertEquals(int.class, expressions.get(index).getType());        index += 2;        // Object bElement = b[0][0];        assertEquals(Object.class, expressions.get(index).getType());        index += 3;        // ArrayAccess cElement = c[0][0][0];        assertEquals(ArrayAccess.class, expressions.get(index).getType());    }    @Test    public void testReferenceType() {        List<ASTReferenceType> referenceTypes = selectNodes(ArrayTypes.class, ASTReferenceType.class);        int index = 0;        // int[] a = new int[1];        // -----        assertEquals(int[].class, referenceTypes.get(index++).getType());        // Object[][] b = new Object[1][0];        // ----------        assertEquals(Object[][].class, referenceTypes.get(index++).getType());        // ArrayTypes[][][] c = new ArrayTypes[][][] { ... };        // ----------------        assertEquals(ArrayTypes[][][].class, referenceTypes.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, referenceTypes.size());    }    @Test    public void testHeterogeneousArrayFieldDeclaration() throws JaxenException {        List<ASTFieldDeclaration> fields = selectNodes(ArrayVariableDeclaration.class, ASTFieldDeclaration.class);        List<ASTLocalVariableDeclaration> locals = selectNodes(ArrayVariableDeclaration.class, ASTLocalVariableDeclaration.class);        // public int[] a, b[];        testPrimitiveTypeFieldDecl(fields.get(0));        testPrimitiveTypeFieldDecl(locals.get(0));        // public String[] c, d[];        testRefTypeFieldDecl(fields.get(1));        testRefTypeFieldDecl(locals.get(1));    }    // subtest    private void testPrimitiveTypeFieldDecl(Node declaration) throws JaxenException {        // public int[] a, b[];        ASTReferenceType typeNode = declaration.getFirstChildOfType(ASTType.class).getFirstChildOfType(ASTReferenceType.class);        assertNotNull(typeNode);        assertTrue(typeNode.isArray());        assertEquals(1, typeNode.getArrayDepth());        assertEquals("int", typeNode.getFirstChildOfType(ASTPrimitiveType.class).getImage());        ASTVariableDeclaratorId aID = declaration.getFirstChildOfType(ASTVariableDeclarator.class).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(aID);        assertEquals("a", aID.getImage());        assertFalse(aID.isArray());        assertEquals(0, aID.getArrayDepth());        assertEquals(int[].class, aID.getType());        ASTVariableDeclaratorId bID = declaration.findChildrenOfType(ASTVariableDeclarator.class).get(1).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(bID);        assertEquals("b", bID.getImage());        assertTrue(bID.isArray());        assertEquals(1, bID.getArrayDepth());        assertEquals(int[][].class, bID.getType());    }    // subtest    private void testRefTypeFieldDecl(Node declaration) throws JaxenException {        // public String[] c, d[];        ASTReferenceType typeNode = declaration.getFirstChildOfType(ASTType.class).getFirstChildOfType(ASTReferenceType.class);        assertNotNull(typeNode);        assertTrue(typeNode.isArray());        assertEquals(1, typeNode.getArrayDepth());        assertEquals("String", typeNode.getFirstChildOfType(ASTClassOrInterfaceType.class).getImage());        ASTVariableDeclaratorId cID = declaration.getFirstChildOfType(ASTVariableDeclarator.class).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(cID);        assertEquals("c", cID.getImage());        assertFalse(cID.isArray());        assertEquals(0, cID.getArrayDepth());        assertEquals(String[].class, cID.getType());        ASTVariableDeclaratorId dID = declaration.findChildrenOfType(ASTVariableDeclarator.class).get(1).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(dID);        assertEquals("d", dID.getImage());        assertTrue(dID.isArray());        assertEquals(1, dID.getArrayDepth());        assertEquals(String[][].class, dID.getType());    }    @Test    public void testFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccess.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // param.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // local.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // f.f.f.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // (this).f.f.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(FieldAccess.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccess.class, getChildType(expressions.get(index), 1));        assertEquals(FieldAccess.class, getChildType(expressions.get(index), 2));        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 3));        // field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessNested() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessNested.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // a = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 0));        // net.sourceforge.pmd.typeresolution.testdata.FieldAccessNested.Nested.this.a = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // FieldAccessNested.Nested.this.a = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessShadow() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessShadow.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // field = "shadow";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // this.field = new Integer(10);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(FieldAccessShadow.class, getChildType(expressions.get(index), 0));        assertEquals(Integer.class, getChildType(expressions.get(index++), 1));        // (this).field = new Integer(10);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(FieldAccessShadow.class, getChildType(expressions.get(index), 0));        assertEquals(Integer.class, getChildType(expressions.get(index++), 1));        // s2 = new SuperClassB2();        assertEquals(SuperClassB2.class, expressions.get(index).getType());        assertEquals(SuperClassB2.class, getChildType(expressions.get(index++), 0));        // privateShadow = 10;        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessSuper() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessSuper.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 0));        // (this).s.s2 = new SuperClassA2();        assertEquals(SuperClassA2.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA2.class, getChildType(expressions.get(index++), 2));        // s.s.s2 = new SuperClassA2();        assertEquals(SuperClassA2.class, expressions.get(index).getType());        assertEquals(SuperClassA2.class, getChildType(expressions.get(index++), 0));        // super.s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 1));        // net.sourceforge.pmd.typeresolution.testdata.FieldAccessSuper.this.s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 0));        // bs = new SuperClassB();        assertEquals(SuperClassB.class, expressions.get(index).getType());        assertEquals(SuperClassB.class, getChildType(expressions.get(index++), 0));        // FieldAccessSuper.Nested.super.bs = new SuperClassB();        assertEquals(SuperClassB.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.Nested.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassB.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassB.class, getChildType(expressions.get(index++), 2));        // FieldAccessSuper.super.s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBoundsGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericBounds.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // superGeneric.first = ""; // ? super String        assertEquals(forClass(LOWER_WILDCARD, String.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(LOWER_WILDCARD, String.class), getChildTypeDef(expressions.get(index++), 0));        // superGeneric.second = null; // ?        assertEquals(forClass(UPPER_WILDCARD, Object.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, Object.class), getChildTypeDef(expressions.get(index++), 0));        // inheritedSuperGeneric.first = ""; // ? super String        assertEquals(forClass(LOWER_WILDCARD, String.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(LOWER_WILDCARD, String.class), getChildTypeDef(expressions.get(index++), 0));        // inheritedSuperGeneric.second = null; // ?        assertEquals(forClass(UPPER_WILDCARD, Object.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, Object.class), getChildTypeDef(expressions.get(index++), 0));        // upperBound.first = null; // ? extends Number        assertEquals(forClass(UPPER_WILDCARD, Number.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, Number.class), getChildTypeDef(expressions.get(index++), 0));        // inheritedUpperBound.first = null; // ? extends String        assertEquals(forClass(UPPER_WILDCARD, String.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, String.class), getChildTypeDef(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testParameterGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericParameter.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // classGeneric = null; // Double        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        // localGeneric = null; // Character        assertEquals(Character.class, expressions.get(index).getType());        assertEquals(Character.class, getChildType(expressions.get(index++), 0));        // parameterGeneric.second.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // localGeneric = null; // Number        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testSimpleGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericSimple.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // genericField.first = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // genericField.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        //genericTypeArg.second.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        // param.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // local.second = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // param.generic.first = new Character('c');        assertEquals(Character.class, expressions.get(index).getType());        assertEquals(Character.class, getChildType(expressions.get(index++), 0));        // local.generic.second = new Float(0);        assertEquals(Float.class, expressions.get(index).getType());        assertEquals(Float.class, getChildType(expressions.get(index++), 0));        // genericField.generic.generic.generic.first = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        // fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // fieldB.generic.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // fieldAcc.fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testRawGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericRaw.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // rawGeneric.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // rawGeneric.third = new Object();        assertEquals(Object.class, expressions.get(index).getType());        assertEquals(Object.class, getChildType(expressions.get(index++), 0));        // rawGeneric.fourth.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // rawGeneric.rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.third = new Object();        assertEquals(Object.class, expressions.get(index).getType());        assertEquals(Object.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.fourth.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.third = new Object();        assertEquals(Object.class, expressions.get(index).getType());        assertEquals(Object.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.fourth.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // bug #471        // rawGeneric.fifth = new GenericClass();        assertEquals(GenericClass.class, expressions.get(index).getType());        assertEquals(GenericClass.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.fifth = new GenericClass();        assertEquals(GenericClass.class, expressions.get(index).getType());        assertEquals(GenericClass.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.fifth = new GenericClass();        assertEquals(GenericClass.class, expressions.get(index).getType());        assertEquals(GenericClass.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testPrimarySimpleGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessPrimaryGenericSimple.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // this.genericField.first = "";        assertEquals(String.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 1, String.class, Double.class);        assertEquals(String.class, getChildType(expressions.get(index++), 2));        // (this).genericField.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 1, String.class, Double.class);        assertEquals(Double.class, getChildType(expressions.get(index++), 2));        // this.genericTypeArg.second.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 2, Number.class, Double.class);        assertEquals(Double.class, getChildType(expressions.get(index++), 3));        // (this).genericField.generic.generic.generic.first = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 5));        // (this).fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 1));        // this.fieldB.generic.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 3));        // super.fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 0, Long.class);        assertEquals(Long.class, getChildType(expressions.get(index++), 1));        // super.fieldB.generic.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 3));        // this.field.first = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessGenericNested() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericNested.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // n.field = null;        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // n.generic.first = null;        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessStatic() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessStatic.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // staticPrimitive = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // staticGeneric.first = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // StaticMembers.staticPrimitive = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // net.sourceforge.pmd.typeresolution.testdata.dummytypes.StaticMembers.staticPrimitive = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // net.sourceforge.pmd.typeresolution.testdata.dummytypes.StaticMembers        //       .staticGeneric.generic.second = new Long(10);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // staticPrimitive = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // staticChar = 3.1; // it's a double        assertEquals(Double.TYPE, expressions.get(index).getType());        assertEquals(Double.TYPE, getChildType(expressions.get(index++), 0));        // FieldAccessStatic.Nested.staticPrimitive = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodPotentialApplicability() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodPotentialApplicability.class, AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int a = vararg("");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // int b = vararg("", 10);        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // String c = notVararg(0, 0);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Number d = noArguments();        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index), 0));        assertEquals(Number.class, getChildType(expressions.get(index++), 1));        // Number e = field.noArguments();        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(MethodPotentialApplicability.class, getChildType(expressions.get(index), 0));        assertEquals(Number.class, getChildType(expressions.get(index++), 1));        // int f = this.vararg("");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 1));        assertEquals(int.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodAccessibility() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodAccessibility.class, AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // SuperClassA a = inheritedA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 1));        // SuperClassB b = inheritedB();        assertEquals(SuperClassB.class, expressions.get(index).getType());        assertEquals(SuperClassB.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassB.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodFirstPhase() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodFirstPhase.class, "1.8", AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int a = subtype(10, 'a', "");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // Exception b = vararg((Object) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // Set<String> set = new HashSet<>();        assertEquals(HashSet.class, expressions.get(index++).getType());        // List<String> myList = new ArrayList<>();        assertEquals(ArrayList.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodMostSpecific() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodMostSpecific.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // String a = moreSpecific((Number) null, (AbstractCollection) null);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Exception b = moreSpecific((Integer) null, (AbstractList) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int c = moreSpecific((Double) null, (RoleList) null);        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodSecondPhase() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodSecondPhase.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // String a = boxing(10, "");        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Exception b = boxing('a', "");        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int c = boxing(10L, "");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // String d = unboxing("", (Integer) null);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Exception e = unboxing("", (Character) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int f = unboxing("", (Byte) null);        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodThirdPhase() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodThirdPhase.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // Exception a = vararg(10, (Number) null, (Number) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // Exception b = vararg(10);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int c = vararg(10, "", "", "");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // String d = mostSpecific(10, 10, 10);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodStaticAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodStaticAccess.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int a = primitiveStaticMethod();        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // StaticMembers b = staticInstanceMethod();        assertEquals(StaticMembers.class, expressions.get(index).getType());        assertEquals(StaticMembers.class, getChildType(expressions.get(index), 0));        assertEquals(StaticMembers.class, getChildType(expressions.get(index++), 1));        // int c = StaticMembers.primitiveStaticMethod();        assertEquals(int.class, expressions.get(index).getType());        assertEquals(StaticMembers.class, getChildType(expressions.get(index), 0)); // PrimaryPrefix        assertEquals(int.class, getChildType(expressions.get(index++), 1)); // PrimarySuffix        // String c = MethodStaticAccess.Nested.primitiveStaticMethod();        assertEquals(String.class, expressions.get(index).getType());        assertEquals(MethodStaticAccess.Nested.class, getChildType(expressions.get(index), 0)); // PrimaryPrefix        assertEquals(String.class, getChildType(expressions.get(index++), 1)); // PrimarySuffix        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodGenericExplicit() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodGenericExplicit.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // String s = this.<String>foo();        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 1));        assertEquals(String.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testGenericArrays() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(GenericsArrays.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // List<String> var = Arrays.asList(params);        AbstractJavaTypeNode expression = expressions.get(index++);        // TODO : Type inference is still incomplete, we fail to detect the return type of the method        //assertEquals(List.class, expression.getTypeDefinition().getType());        //assertEquals(String.class, expression.getTypeDefinition().getGenericType(0).getType());        // List<String> var2 = Arrays.<String>asList(params);        AbstractJavaTypeNode expression2 = expressions.get(index++);        assertEquals(List.class, expression2.getTypeDefinition().getType());        assertEquals(String.class, expression2.getTypeDefinition().getGenericType(0).getType());        // List<String[]> var3 = Arrays.<String[]>asList(params);        AbstractJavaTypeNode expression3 = expressions.get(index++);        assertEquals(List.class, expression3.getTypeDefinition().getType());        assertEquals(String[].class, expression3.getTypeDefinition().getGenericType(0).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testGenericArrayUnresolved() {        // InnerClass cannot be resolved as no compiled code is available        // we should not throw a NPE when trying to parse/type resolve.        java11.parse("import java.util.*;"                + "class Foo {"                + "  private static class InnerClass {}"                + "  void useInnerClass(InnerClass... classes) {"                + "    List<InnerClass> result = new ArrayList<>(Arrays.<InnerClass>asList(classes));"                + "  }"                + "}");    }    @Test    public void testMethodTypeInference() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(GenericMethodsImplicit.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // SuperClassA2 a = bar((SuperClassA) null, (SuperClassAOther) null, null, (SuperClassAOther2) null);        assertEquals(SuperClassA2.class, expressions.get(index).getType());        assertEquals(SuperClassA2.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA2.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodTypeInferenceVarargsZeroArity() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(VarargsZeroArity.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int var = aMethod();        assertEquals(int.class, expressions.get(index++).getType());        //String var2 = aMethod("");        assertEquals(String.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodTypeInferenceVarargsAsFixedArity() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(VarargsAsFixedArity.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int var = aMethod("");        assertEquals(int.class, expressions.get(index++).getType());        // String var2 = aMethod();        assertEquals(String.class, expressions.get(index++).getType());        // String var3 = aMethod("", "");        assertEquals(String.class, expressions.get(index++).getType());        // String var4 = aMethod(new Object[] { null });        assertEquals(String.class, expressions.get(index++).getType());        // null literal has null type        assertNull(expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testJavaTypeDefinitionEquals() {        JavaTypeDefinition a = forClass(Integer.class);        JavaTypeDefinition b = forClass(Integer.class);        // test non-generic types        assertEquals(a, b);        assertNotEquals(a, null);        // test generic arg equality        b = forClass(List.class, a);        a = forClass(List.class, a);        assertEquals(a, b);        a = forClass(List.class, forClass(String.class));        assertNotEquals(a, b);        assertNotEquals(b, a);        // test raw vs proper, proper vs raw        a = forClass(JavaTypeDefinitionEquals.class);        b = forClass(JavaTypeDefinitionEquals.class,                                        forClass(List.class, a));        assertNotEquals(a, b);        assertNotEquals(b, a);    }    @Test    public void testJavaTypeDefinitionGetSuperTypeSet() {        JavaTypeDefinition originalTypeDef = forClass(List.class,                                                                         forClass(Integer.class));        Set<JavaTypeDefinition> set = originalTypeDef.getSuperTypeSet();        assertEquals(set.size(), 4);        assertTrue(set.contains(forClass(Object.class)));        assertTrue(set.contains(originalTypeDef));        assertTrue(set.contains(forClass(Collection.class,                                         forClass(Integer.class))));        assertTrue(set.contains(forClass(Iterable.class,                                         forClass(Integer.class))));    }    @Test    public void testJavaTypeDefinitionGetErasedSuperTypeSet() {        JavaTypeDefinition originalTypeDef = forClass(List.class,                                                                         forClass(Integer.class));        Set<Class<?>> set = originalTypeDef.getErasedSuperTypeSet();        assertEquals(set.size(), 4);        assertTrue(set.contains(Object.class));        assertTrue(set.contains(Collection.class));        assertTrue(set.contains(Iterable.class));        assertTrue(set.contains(List.class));    }    @Test    public void testMethodInitialBounds() throws NoSuchMethodException {        JavaTypeDefinition context = forClass(GenericMethodsImplicit.class,                                                                 forClass(Thread.class));        List<Variable> variables = new ArrayList<>();        List<Bound> initialBounds = new ArrayList<>();        Method method = GenericMethodsImplicit.class.getMethod("foo");        MethodTypeResolution.produceInitialBounds(method, context, variables, initialBounds);        assertEquals(initialBounds.size(), 6);        // A        assertTrue(initialBounds.contains(new Bound(variables.get(0),                                                    forClass(Object.class), SUBTYPE)));        // B        assertTrue(initialBounds.contains(new Bound(variables.get(1),                                                    forClass(Number.class), SUBTYPE)));        assertTrue(initialBounds.contains(new Bound(variables.get(1),                                                    forClass(Runnable.class), SUBTYPE)));        // C        assertTrue(initialBounds.contains(new Bound(variables.get(2), variables.get(3), SUBTYPE)));        assertTrue(initialBounds.contains(new Bound(variables.get(2),                                                    forClass(Object.class), SUBTYPE)));        // D        assertTrue(initialBounds.contains(new Bound(variables.get(3),                                                    forClass(Thread.class), SUBTYPE)));    }    @Test    public void testMethodInitialConstraints() throws NoSuchMethodException, JaxenException {        List<AbstractJavaNode> expressions = selectNodes(GenericMethodsImplicit.class, AbstractJavaNode.class, "//ArgumentList");        List<Variable> variables = new ArrayList<>();        for (int i = 0; i < 2; ++i) {            variables.add(new Variable());        }        Method method = GenericMethodsImplicit.class.getMethod("bar", Object.class, Object.class,                                                               Integer.class, Object.class);        ASTArgumentList argList = (ASTArgumentList) expressions.get(0);        List<Constraint> constraints = MethodTypeResolution.produceInitialConstraints(method, argList, variables);        assertEquals(constraints.size(), 3);        // A        assertTrue(constraints.contains(new Constraint(forClass(SuperClassA.class),                                                       variables.get(0), LOOSE_INVOCATION)));        assertTrue(constraints.contains(new Constraint(forClass(SuperClassAOther.class),                                                       variables.get(0),                                                       LOOSE_INVOCATION)));        // B        assertTrue(constraints.contains(new Constraint(forClass(SuperClassAOther2.class),                                                       variables.get(1),                                                       LOOSE_INVOCATION)));    }    @Test    public void testMethodParameterization() throws NoSuchMethodException {        ASTArgumentList argList = selectNodes(GenericMethodsImplicit.class, ASTArgumentList.class).get(0);        JavaTypeDefinition context = forClass(GenericMethodsImplicit.class, forClass(Thread.class));        Method method = GenericMethodsImplicit.class.getMethod("bar", Object.class, Object.class,                                                               Integer.class, Object.class);        MethodType inferedMethod = MethodTypeResolution.parameterizeInvocation(context, method, argList);        assertEquals(inferedMethod.getParameterTypes().get(0),                     forClass(SuperClassA2.class));        assertEquals(inferedMethod.getParameterTypes().get(1),                     forClass(SuperClassA2.class));        assertEquals(inferedMethod.getParameterTypes().get(2),                     forClass(Integer.class));        assertEquals(inferedMethod.getParameterTypes().get(3),                     forClass(SuperClassAOther2.class));    }    @Test    public void testNestedAllocationExpressions() {        ASTCompilationUnit acu = java5.parseClass(NestedAllocationExpressions.class);        List<ASTAllocationExpression> allocs = acu.findDescendantsOfType(ASTAllocationExpression.class);        assertFalse(allocs.get(0).isAnonymousClass());        assertEquals(Thread.class, allocs.get(0).getType());        assertTrue(allocs.get(1).isAnonymousClass());        // FUTURE 1.8 use Class.getTypeName() instead of toString        assertTrue(allocs.get(1).getType().toString().endsWith("NestedAllocationExpressions$1"));    }    @Test    public void testAnnotatedTypeParams() {        java8.parse("public class Foo { public static <T extends @NonNull Enum<?>> T getEnum() { return null; } }");    }    @Test    public void testMethodOverrides() throws Exception {        java8.parseClass(SubTypeUsage.class);    }    @Test    public void testMethodWildcardParam() throws Exception {        java8.parseClass(MethodGenericParam.class);    }    @Test    public void testAbstractMethodReturnType() throws Exception {        java8.parseClass(AbstractReturnTypeUseCase.class);    }    @Test    public void testMethodOverloaded() throws Exception {        java8.parseClass(OverloadedMethodsUsage.class);    }    @Test    public void testVarArgsMethodUseCase() throws Exception {        java8.parseClass(VarArgsMethodUseCase.class);    }    @Test    public void testLocalGenericClass() throws Exception {        java9.parseClass(LocalGenericClass.class);    }    @Test    public void testMethodCallExpressionTypes() throws Exception {        ASTCompilationUnit cu = java11.parseClass(MethodCallExpressionTypes.class);        ASTPrimaryExpression expr = cu.getFirstDescendantOfType(ASTPrimaryExpression.class);        assertEquals(forClass(String.class), expr.getTypeDefinition());        assertEquals(forClass(Objects.class), expr.getFirstChildOfType(ASTPrimaryPrefix.class).getTypeDefinition());    }    private JavaTypeDefinition getChildTypeDef(Node node, int childIndex) {        return ((TypeNode) node.getChild(childIndex)).getTypeDefinition();    }    private Class<?> getChildType(Node node, int childIndex) {        return ((TypeNode) node.getChild(childIndex)).getType();    }    private <T> List<T> selectNodes(String source, Class<T> resultType, String xpath) throws JaxenException {        return selectNodes(source, "1.5", resultType, xpath);    }    // This is the master overload, others just default the parameters    private <T> List<T> selectNodes(String source, String version, Class<T> resultType, String xpath) throws JaxenException {        ASTCompilationUnit acu = java4.parse(source, version);        return convertList(acu.findChildNodesWithXPath(xpath), resultType);    }    private <T> List<T> selectNodes(Class<?> source, Class<T> resultType) {        return java5.parseClass(source).findDescendantsOfType(resultType);    }    private <T> List<T> selectNodes(Class<?> source, Class<T> resultType, String xpath) throws JaxenException {        return selectNodes(source, "1.5", resultType, xpath);    }    private <T> List<T> selectNodes(Class<?> source, String version, Class<T> resultType, String xpath) throws JaxenException {        ASTCompilationUnit acu = java4.parseClass(source, version);        return convertList(acu.findChildNodesWithXPath(xpath), resultType);    }    private void assertChildTypeArgsEqualTo(Node node, int childIndex, Class<?>... classes) {        JavaTypeDefinition typeDef = ((TypeNode) node.getChild(childIndex)).getTypeDefinition();        for (int index = 0; index < classes.length; ++index) {            assertSame(classes[index], typeDef.getGenericType(index).getType());        }    }    private static <T> List<T> convertList(List<Node> nodes, Class<T> target) {        List<T> converted = new ArrayList<>();        for (Node n : nodes) {            converted.add(target.cast(n));        }        return converted;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.regex.Pattern;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.util.FileUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CLITest extends BaseCLITest {    @Test    public void minimalArgs() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/bestpractices.xml,category/java/design.xml", };        runTest(args, "minimalArgs");    }    @Test    public void minimumPriority() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-min", "1", };        runTest(args, "minimumPriority");    }    @Test    public void usingDebug() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-debug", };        runTest(args, "minimalArgsWithDebug");    }    @Test    public void changeJavaVersion() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-version", "1.5", "-language",            "java", "-debug", };        String resultFilename = runTest(args, "chgJavaVersion");        assertTrue("Invalid Java version",                FileUtil.findPatternInFile(new File(resultFilename), "Using Java version: Java 1.5"));    }    @Test    public void exitStatusNoViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", };        runTest(args, "exitStatusNoViolations");    }    @Test    public void exitStatusWithViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/errorprone.xml", };        String resultFilename = runTest(args, "exitStatusWithViolations", 4);        assertTrue(FileUtil.findPatternInFile(new File(resultFilename), "Avoid empty if"));    }    @Test    public void exitStatusWithViolationsAndWithoutFailOnViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/errorprone.xml", "-failOnViolation", "false", };        String resultFilename = runTest(args, "exitStatusWithViolationsAndWithoutFailOnViolations", 0);        assertTrue(FileUtil.findPatternInFile(new File(resultFilename), "Avoid empty if"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRuleset() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename),                "Can't find resource 'category/java/designn.xml' for rule 'null'." + "  Make sure the resource is a valid file"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulesetWithRulename() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml/UseCollectionIsEmpty", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename),                "Can't find resource 'category/java/designn.xml' for rule " + "'UseCollectionIsEmpty'."));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulename() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml/ThisRuleDoesNotExist", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename), Pattern                .quote("No rules found. Maybe you misspelled a rule name?" + " (category/java/design.xml/ThisRuleDoesNotExist)")));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on Java file with default options.     * Always the latest non-preview version will be the default version.     */    @Test    public void testJavaFileUsingDefaults() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion latest = determineLatestNonPreviewVersion();        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals("Latest language version must be default", latest, languageVersion);    }    private LanguageVersion determineLatestNonPreviewVersion() {        LanguageVersion latest = null;        for (LanguageVersion lv : LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersions()) {            if (!lv.getName().endsWith("preview")) {                latest = lv;            }        }        return latest;    }    /**     * Test on Java file with Java version set to 1.4.     */    @Test    public void testJavaFileUsing14() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        discoverer.setDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"));        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals("LanguageVersion must be Java 1.4!",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), languageVersion);    }    @Test    public void testLanguageVersionDiscoverer() {        PMDConfiguration configuration = new PMDConfiguration();        LanguageVersionDiscoverer languageVersionDiscoverer = configuration.getLanguageVersionDiscoverer();        assertEquals("Default Java version", determineLatestNonPreviewVersion(),                languageVersionDiscoverer                        .getDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)));        configuration                .setDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals("Modified Java version", LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"),                languageVersionDiscoverer                        .getDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.3",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.3"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.4",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.5",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.6",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.6"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.7",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.7"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.8",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "9",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("9"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "10",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("10"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "11",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("11"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("12"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("12-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "14",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("14"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "14-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("14-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "15",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("15"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "15-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("15-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "16",                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("16"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "16-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("16-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "17",                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("17"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "17-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("17-preview"), },            // this one won't be found: case sensitive!            { "JAVA", "JAVA", "1.7", null, },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.testframework.RuleTst;public class ReportTest extends RuleTst {    private LanguageVersion defaultLanguage = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion();    @Test    public void testBasic() {        Report r = new Report();        runTestFromString(TEST1, new FooRule(), r, defaultLanguage);        assertFalse(r.isEmpty());    }    @Test    public void testExclusionsInReportWithRuleViolationSuppressRegex() {        Report rpt = new Report();        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR, ".*No Foo.*");        runTestFromString(TEST1, rule, rpt, defaultLanguage);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithRuleViolationSuppressXPath() {        Report rpt = new Report();        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR, ".[@SimpleName = 'Foo']");        runTestFromString(TEST1, rule, rpt, defaultLanguage);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithAnnotations() {        Report rpt = new Report();        runTestFromString(TEST2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithAnnotationsFullName() {        Report rpt = new Report();        runTestFromString(TEST2_FULL, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithNOPMD() {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt, defaultLanguage);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "@SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST2_FULL = "@java.lang.SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST3 = "public class Foo {} // NOPMD";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertNull;import org.junit.Test;/** * Test java's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    @Test    public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"category/java/codestyle.xml\">\n"                        + "    <exclude name=\"UselessParentheses\"/>\n" + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        Rule rule = ruleset.getRuleByName("UselessParentheses");        assertNull(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.StringReader;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.testframework.RuleTst;import net.sourceforge.pmd.testframework.TestDescriptor;public class ExcludeLinesTest extends RuleTst {    private Rule rule;    @Before    public void setUp() {        rule = findRule("java-unusedcode", "UnusedLocalVariable");    }    @Test    public void testAcceptance() {        runTest(new TestDescriptor(TEST1, "NOPMD should work", 0, rule));        runTest(new TestDescriptor(TEST2, "Should fail without exclude marker", 1, rule));    }    @Test    public void testAlternateMarker() throws Exception {        PMD p = new PMD();        p.getConfiguration().setSuppressMarker("FOOBAR");        RuleContext ctx = new RuleContext();        Report r = new Report();        ctx.setReport(r);        ctx.setSourceCodeFile(new File("n/a"));        ctx.setLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion());        RuleSet rules = RuleSet.forSingleRule(rule);        p.getSourceCodeProcessor().processSourceCode(new StringReader(TEST3), new RuleSets(rules), ctx);        assertTrue(r.isEmpty());        assertEquals(r.getSuppressedRuleViolations().size(), 1);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x; //NOPMD "            + PMD.EOL + " } " + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x;"            + PMD.EOL + " } " + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  int x; // FOOBAR" + PMD.EOL + " } " + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoUnsanitizedJSPExpressionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IframeMissingSrcAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JspEncodingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoScriptletsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineStyleInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoLongScriptsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineScriptTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DuplicateJspImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontNestJsfInJstlIterationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoHtmlCommentsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoJspForwardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoClassAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;/** * Test parsing of a JSP in document style, by checking the generated AST. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be * */public class JspDocStyleTest extends AbstractJspNodesTst {    /**     * Smoke test for JSP parser.     */    @Test    public void testSimplestJsp() {        List<ASTElement> nodes = jsp.getNodes(ASTElement.class, TEST_SIMPLEST_HTML);        assertEquals("Exactly " + 1 + " element(s) expected", 1, nodes.size());    }    /**     * Test the information on a Element and Attribute.     */    @Test    public void testElementAttributeAndNamespace() {        ASTCompilationUnit root = jsp.parse(TEST_ELEMENT_AND_NAMESPACE);        List<ASTElement> elementNodes = root.findDescendantsOfType(ASTElement.class);        assertEquals("One element node expected!", 1, elementNodes.size());        ASTElement element = elementNodes.get(0);        assertEquals("Correct name expected!", "h:html", element.getName());        assertTrue("Has namespace prefix!", element.isHasNamespacePrefix());        assertTrue("Element is empty!", element.isEmpty());        assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "html", element.getLocalName());        List<ASTAttribute> attributeNodes = root.findDescendantsOfType(ASTAttribute.class);        assertEquals("One attribute node expected!", 1, attributeNodes.size());        ASTAttribute attribute = attributeNodes.get(0);        assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());        assertTrue("Has namespace prefix!", attribute.isHasNamespacePrefix());        assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix", attribute.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    public void testAttributeValueContainingHash() {        ASTCompilationUnit root = jsp.parse(TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        List<ASTAttribute> attrsList = root.findDescendantsOfType(ASTAttribute.class);        assertEquals("Three attributes expected!", 3, attrsList.size());        ASTAttribute attr = attrsList.get(0);        assertEquals("Correct attribute name expected!", "something", attr.getName());        assertEquals("Correct attribute value expected!", "#yes#",                     attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());        attr = attrsList.get(1);        assertEquals("Correct attribute name expected!", "foo", attr.getName());        assertEquals("Correct attribute value expected!", "CREATE",                     attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());        attr = attrsList.get(2);        assertEquals("Correct attribute name expected!", "href", attr.getName());        assertEquals("Correct attribute value expected!", "#",                     attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());    }    /**     * Test correct parsing of CDATA.     */    @Test    public void testCData() {        List<ASTCData> cdataNodes = jsp.getNodes(ASTCData.class, TEST_CDATA);        assertEquals("One CDATA node expected!", 1, cdataNodes.size());        ASTCData cdata = cdataNodes.get(0);        assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());    }    /**     * Test parsing of Doctype declaration.     */    @Test    public void testDoctype() {        ASTCompilationUnit root = jsp.parse(TEST_DOCTYPE);        List<ASTDoctypeDeclaration> docTypeDeclarations = root.findDescendantsOfType(ASTDoctypeDeclaration.class);        assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());        List<ASTDoctypeExternalId> externalIds = root.findDescendantsOfType(ASTDoctypeExternalId.class);        assertEquals("One doctype external id expected!", 1, externalIds.size());        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());        assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",                externalId.getUri());    }    /**     * Test parsing of a XML comment.     *     */    @Test    public void testComment() {        List<ASTCommentTag> comments = jsp.getNodes(ASTCommentTag.class, TEST_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTCommentTag comment = comments.iterator().next();        assertEquals("Correct comment content expected!", "comment", comment.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScript() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Correct script content expected!", "Script!", script.getImage());    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be valid     * html but it is likely to appear in .JSP files.     */    @Test    public void testImportHtmlScript() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttributeValue> value = script.findDescendantsOfType(ASTAttributeValue.class);        assertEquals("filename.js", value.get(0).getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScriptWithAttribute() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Correct script content expected!", "Script!", script.getImage());        List<ASTAttributeValue> attrs = script.findDescendantsOfType(ASTAttributeValue.class);        assertTrue("text/javascript".equals(attrs.get(0).getImage()));    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    public void testComplexHtmlScript() {        List<ASTHtmlScript> script = jsp.getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals("One script expected!", 1, script.size());        ASTHtmlScript next = script.iterator().next();        assertTrue(next.getImage().contains("<!--"));        List<ASTCommentTag> comments = jsp.getNodes(ASTCommentTag.class, TEST_COMPLEX_SCRIPT);        assertEquals("One comment expected!", 1, comments.size());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testInlineCss() {        List<ASTElement> scripts = jsp.getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals("Three elements expected!", 3, scripts.size());    }    /**     * Test parsing of HTML text within element.     */    @Test    public void testTextInTag() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals("One text chunk expected!", 1, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    public void noSpacesBetweenTags() {        List<ASTElement> elmts = jsp.getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals("Two tags expected!", 2, elmts.size());        assertEquals("Correct content expected!", "a", elmts.get(0).getName());        assertEquals("Correct content expected!", "b", elmts.get(1).getName());    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    public void unclosedTagsWithDollar() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " $ ", script.getImage());    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    public void unclosedTagsWithELWithin() {        List<ASTElExpression> scripts = jsp.getNodes(ASTElExpression.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals("Two EL expressions expected!", 2, scripts.size());        List<ASTElExpression> exprs = sortByImage(scripts);        Iterator<ASTElExpression> iterator = exprs.iterator();        ASTElExpression script = iterator.next();        assertEquals("Correct content expected!", "expr1", script.getImage());        script = iterator.next();        assertEquals("Correct content expected!", "expr2", script.getImage());    }    /**     * Make sure mixed expressions don't confuse the parser     */    @Test    public void mixedExpressions() {        List<ASTJspExpression> exprs = jsp.getNodes(ASTJspExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("One JSP expression expected!", 1, exprs.size());        assertEquals("Image of expression should be \"expr\"", "expr", exprs.iterator().next().getImage());        List<ASTElExpression> els = jsp.getNodes(ASTElExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("Two EL expression expected!", 2, els.size());        assertEquals("Image of el should be \"expr\"", "expr", els.iterator().next().getImage());        List<ASTUnparsedText> unparsedtexts = jsp.getNodes(ASTUnparsedText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        List<ASTUnparsedText> sortedUnparsedTxts = sortByImage(unparsedtexts);        assertEquals("Two unparsed texts expected!", 2, sortedUnparsedTxts.size());        Iterator<ASTUnparsedText> iterator = sortedUnparsedTxts.iterator();        assertEquals("Image of text should be \"\\${expr}\"", " \\${expr} ", iterator.next().getImage());        assertEquals("Image of text should be \" aaa \"", " aaa ", iterator.next().getImage());        // ASTText should contain the text between two tags.        List<ASTText> texts = jsp.getNodes(ASTText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        List<ASTText> sortedTxts = sortByImage(texts);        assertEquals("Two regular texts expected!", 2, sortedTxts.size());        Iterator<ASTText> iterator2 = sortedTxts.iterator();        assertEquals("Image of text should be \"\\${expr}\"", " \\${expr} ", iterator2.next().getImage());        assertEquals("Image of text should be all text between two nodes" + " \"  aaa ${expr}#{expr} \"",                " aaa ${expr}#{expr}", iterator2.next().getImage());    }    /**     * Make sure JSP expressions are properly detected when they are next to     * unclosed tags.     */    @Test    public void unclosedTagsWithJspExpressionWithin() {        List<ASTJspExpression> scripts = jsp.getNodes(ASTJspExpression.class, TEST_TAGS_WITH_EXPRESSION_WITHIN);        assertEquals("Two JSP expressions expected!", 2, scripts.size());        ASTJspExpression script = scripts.iterator().next();        assertEquals("Correct content expected!", "expr", script.getImage());    }    /**     * A dangling unopened ( just &lt;/closed&gt; ) tag should not influence the     * parsing.     */    @Test    @Ignore // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    public void textBetweenUnopenedTag() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TEXT_WITH_UNOPENED_TAG);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", "$", script.getImage());    }    /**     * Parser should be able to handle documents which start or end with     * unparsed text     */    @Test    @Ignore // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    public void textMultipleClosingTags() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_MULTIPLE_CLOSING_TAGS);        assertEquals("Four text chunks expected!", 4, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void textAfterOpenAndClosedTag() {        List<ASTElement> nodes = jsp.getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two elements expected!", 2, nodes.size());        assertEquals("First element should be a", "a", nodes.get(0).getName());        assertFalse("first element should be closed", nodes.get(0).isUnclosed());        assertEquals("Second element should be b", "b", nodes.get(1).getName());        assertTrue("Second element should not be closed", nodes.get(1).isUnclosed());        List<ASTText> text = jsp.getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two text chunks expected!", 2, text.size());    }    @Test    public void quoteEL() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "${something}", attr.getImage());    }    @Test    public void quoteExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_EXPRESSION);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something%>", attr.getImage());    }    @Test    @Ignore // tags contain quotes and break attribute parsing    public void quoteTagInAttribute() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<bean:write name=\"x\" property=\"z\">",                attr.getImage());    }    /**     * smoke test for a non-quoted attribute value     */    @Test    public void noQuoteAttrValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "yes|", attr.getImage());    }    /**     * tests whether JSP el is properly detected as attribute value     */    @Test    public void noQuoteAttrWithJspEL() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr2 = iterator.next();        if ("url".equals(attr2.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr2 = iterator.next();        }        assertEquals("Expected to detect proper value for EL in attribute!", "${something}", attr2.getImage());    }    /**     * tests whether parse correctly detects presence of JSP expression &lt;%= %&gt;     * within an non-quoted attribute value     */    @Test    public void noQuoteAttrWithJspExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EXPRESSION);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something%>", attr.getImage());    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    public void noQuoteAttrEmpty() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_EMPTY_ATTR);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", "", attr.getImage());    }    /**     * tests whether parse correctly interprets an cr lf instead of an attribute     */    @Test    public void noQuoteAttrCrLf() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_CR_LF_ATTR);        assertEquals("One attribute expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", "\r\n", attr.getImage());    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    public void noQuoteAttrTab() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAB_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        assertEquals("Expected to detect proper value for attribute!", "\t", attr.getImage());    }    /**     * tests whether parse does not fail in the presence of unclosed JSP     * expression &lt;%= within an non-quoted attribute value     */    @Test    public void noQuoteAttrWithMalformedJspExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something", attr.getImage());    }    /**     * test a no quote attribute value which contains a scriptlet &lt;% %&gt; within     * its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithScriptletInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a no quote attribute value can contain a tag (e.g.     * attr=&lt;bean:write property="value" /&gt;)     *     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithBeanWriteTagAsValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a quote attribute value can contain a tag (e.g.     * attr="&lt;bean:write property="value" /&gt;" ) Not sure if it's legal JSP code     * but most JSP engine accept and properly treat this value at runtime     */    @Test    @Ignore // nice test for future development    public void quoteAttrWithBeanWriteTagAsValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a no quote attribute value which contains the EL dollar sign $     * within its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithDollarSignInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_DOLLAR);        assertEquals("One attribute expected!", 2, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "${something", attr.getImage());    }    /**     * test a no quote attribute value which contains the EL sharp sign # within     * its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithSharpSymbolInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_HASH);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "#{something", attr.getImage());    }    @Test    public void unclosedTag() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be tag:someTag", "tag:someTag", elements.get(0).getName());        assertEquals("Second element should be sorted tag:if", "tag:if", elements.get(1).getName());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());    }    @Test    public void unclosedTagAndNoQuotesForAttribute() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_NO_QUOTE_ATTR);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be sorted tag:if", "tag:if", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());    }    @Test    public void unclosedTagMultipleLevels() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("3 tags expected", 3, elements.size());        assertEquals("First element should be sorted tag:someTag", "tag:someTag", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertEquals("Third element should be tag:x", "tag:x", sortedElmnts.get(2).getName());        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        assertFalse(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    public void nestedEmptyTags() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Third element should be html", "html", sortedElmnts.get(3).getName());        // a1        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2        assertTrue(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());        // html        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt; &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    public void nestedMultipleTags() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 6, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be a3", "a3", sortedElmnts.get(2).getName());        assertEquals("Forth element should be a4", "a4", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be b", "b", sortedElmnts.get(4).getName());        assertEquals("Sixth element should be html", "html", sortedElmnts.get(5).getName());        // a1 not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2 not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // a3 empty and not closed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // a4 empty but closed        assertTrue(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());        // b empty but closed        assertTrue(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());        // html not empty and closed        assertFalse(sortedElmnts.get(5).isEmpty());        assertFalse(sortedElmnts.get(5).isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt; .     * Here x is the first tag to be closed thus rendering the next close of a (&lt;/a&gt;)     * to be disregarded.     */    @Test    public void unclosedParentTagClosedBeforeChild() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt; An unmatched closing of 'z' appears     * randomly in the document. This should be disregarded and structure of     * children and parents should not be influenced. in other words &lt;/a&gt; should     * close the first &lt;a&gt; tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    public void unmatchedTagDoesNotInfluenceStructure() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a is not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This     * should be disregarded and structure of children and parents should not be influenced.     * Also un unclosed &lt;a&gt; tag appears at the start of the document     */    @Test    public void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("5 tags expected", 5, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be a", "a", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be b", "b", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be x", "x", sortedElmnts.get(4).getName());        // first a is empty and unclosed        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // second a not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(3).isEmpty());        assertTrue(sortedElmnts.get(3).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());    }    /**     * {@link #TEST_UNCLOSED_END_OF_DOC}     * &lt;tag:x&gt; &lt;tag:y&gt;     * Tests whether parser breaks on no closed tags at all     */    // This is yet to be improved. If a closing tag does not    // exist no tags will be marked as empty :(    @Ignore    @Test    public void unclosedEndOfDoc() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_END_OF_DOC);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be 'tag:x'", "tag:x", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:y", "tag:y", sortedElmnts.get(1).getName());        // b        // assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());    }    /**     * will sort the AST element in list in alphabetical order and if tag name     * is the same it will sort against o1.getBeginColumn() +""+     * o1.getBeginLine(). so first criteria is the name, then the second is the     * column +""+line string.     *     * @param elements     * @return     */    private List<ASTElement> sortNodesByName(Collection<ASTElement> elements) {        List<ASTElement> list = new ArrayList<>(elements);        Collections.sort(list, new Comparator<ASTElement>() {            public int compare(ASTElement o1, ASTElement o2) {                if (o1.getName() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getName() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getName().equals(o2.getName())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getName().compareTo(o2.getName());            }        });        return list;    }    /**     * will sort the AST node by the image name.     *     * @param elements     * @return     */    private <T extends Node> List<T> sortByImage(Collection<T> elements) {        List<T> list = new ArrayList<>(elements);        Collections.sort(list, new Comparator<Node>() {            public int compare(Node o1, Node o2) {                if (o1.getImage() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getImage() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getImage().equals(o2.getImage())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getImage().compareTo(o2.getImage());            }        });        return list;    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_COMMENT = "<html><!-- comment --></html>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" type=\"text/javascript\"/></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>#{expr1}<b>${expr2}</a>";    private static final String TEST_TAGS_WITH_MIXED_EXPRESSIONS = "<a> aaa ${expr} #{expr} <%=expr%> <b> \\${expr} </a>";    private static final String TEST_TAGS_WITH_EXPRESSION_WITHIN = "<a> <%=expr%> <b> <%=expr%> </a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_TEXT_WITH_UNOPENED_TAG = "<a> some text </b> some text </a>";    private static final String TEST_MULTIPLE_CLOSING_TAGS = "<a> some text </b> </b> </b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"${something}\" > </tag:if>";    private static final String TEST_QUOTE_EXPRESSION = "<tag:if something=\"<%=something%>\" >  </tag:if>";    private static final String TEST_QUOTE_TAG_IN_ATTR = "<tag:if something=\"<bean:write name=\"x\" property=\"z\">\" >  "            + "<a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR = "<tag:if something=yes| > </tag:if>";    private static final String TEST_NO_QUOTE_EMPTY_ATTR = "<tag:if something= >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAG_IN_ATTR = "<tag:if something=<bean:write name=\"x\" property=\"z\"> >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_CR_LF_ATTR = "<tag:if something=\r\n >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAB_ATTR = "<tag:if something=\t >   </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<tag:if something=${something} >  <a href=url >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EXPRESSION = "<tag:if something=<%=something%> >  </tag:if>";    /**     * same as {@link #TEST_NO_QUOTE_ATTR_WITH_EXPRESSION} only expression is     * not properly closed     */    private static final String TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR = "<tag:if something=<%=something >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET = "<tag:if something=<% String a = \"1\";%>x >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_DOLLAR = "<tag:if something=${something >  <a href=${ >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_HASH = "<tag:if something=#{something >  <a href=#{url} >foo</a> </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if something=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag something=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_END_OF_DOC = "<tag:x> <tag:y>";    private static final String TEST_UNCLOSED_NO_QUOTE_ATTR = "<tag:someTag> <tag:if something=x > </tag:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import java.util.List;import org.junit.Test;public class JspPageStyleTest extends AbstractJspNodesTst {    /**     * Test parsing of a JSP comment.     */    @Test    public void testComment() {        List<ASTJspComment> comments = jsp.getNodes(ASTJspComment.class, JSP_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTJspComment comment = comments.iterator().next();        assertEquals("Correct comment content expected!", "some comment", comment.getImage());    }    /**     * Test parsing a JSP directive.     */    @Test    public void testDirective() {        ASTCompilationUnit root = jsp.parse(JSP_DIRECTIVE);        List<ASTJspDirective> directives = root.findDescendantsOfType(ASTJspDirective.class);        assertEquals("One directive expected!", 1, directives.size());        ASTJspDirective directive = directives.iterator().next();        assertEquals("Correct directive name expected!", "page", directive.getName());        List<ASTJspDirectiveAttribute> directiveAttrs = root.findDescendantsOfType(ASTJspDirectiveAttribute.class);        assertEquals("Two directive attributes expected!", 2, directiveAttrs.size());        ASTJspDirectiveAttribute attr = directiveAttrs.get(0);        assertEquals("Correct directive attribute name expected!", "language", attr.getName());        assertEquals("Correct directive attribute value expected!", "java", attr.getValue());        attr = directiveAttrs.get(1);        assertEquals("Correct directive attribute name expected!", "session", attr.getName());        assertEquals("Correct directive attribute value expected!", "true", attr.getValue());    }    /**     * Test parsing of a JSP declaration.     */    @Test    public void testDeclaration() {        List<ASTJspDeclaration> declarations = jsp.getNodes(ASTJspDeclaration.class, JSP_DECLARATION);        assertEquals("One declaration expected!", 1, declarations.size());        ASTJspDeclaration declaration = declarations.iterator().next();        assertEquals("Correct declaration content expected!", "String someString = \"s\";", declaration.getImage());    }    /**     * Test parsing of a JSP scriptlet.     */    @Test    public void testScriptlet() {        List<ASTJspScriptlet> scriptlets = jsp.getNodes(ASTJspScriptlet.class, JSP_SCRIPTLET);        assertEquals("One scriptlet expected!", 1, scriptlets.size());        ASTJspScriptlet scriptlet = scriptlets.iterator().next();        assertEquals("Correct scriptlet content expected!", "someString = someString + \"suffix\";",                scriptlet.getImage());    }    /**     * Test parsing of a JSP expression.     */    @Test    public void testExpression() {        List<ASTJspExpression> expressions = jsp.getNodes(ASTJspExpression.class, JSP_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "someString", expression.getImage());    }    /**     * Test parsing of a JSP expression in an attribute.     */    @Test    public void testExpressionInAttribute() {        List<ASTJspExpressionInAttribute> expressions = jsp.getNodes(ASTJspExpressionInAttribute.class, JSP_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpressionInAttribute expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "style.getClass()", expression.getImage());    }    /**     * Test parsing of a EL expression.     */    @Test    public void testElExpression() {        List<ASTElExpression> expressions = jsp.getNodes(ASTElExpression.class, JSP_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "myBean.get(\"${ World }\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testElExpressionInAttribute() {        List<ASTElExpression> expressions = jsp.getNodes(ASTElExpression.class, JSP_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "myValidator.find(\"'jsp'\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testJsfValueBinding() {        List<ASTValueBinding> valueBindings = jsp.getNodes(ASTValueBinding.class, JSF_VALUE_BINDING);        assertEquals("One value binding expected!", 1, valueBindings.size());        ASTValueBinding valueBinding = valueBindings.iterator().next();        assertEquals("Correct expression content expected!", "myValidator.find(\"'jsf'\")", valueBinding.getImage());    }    private static final String JSP_COMMENT = "<html> <%-- some comment --%> </html>";    private static final String JSP_DIRECTIVE = "<html> <%@ page language=\"java\" session='true'%> </html>";    private static final String JSP_DECLARATION = "<html><%! String someString = \"s\"; %></html>";    private static final String JSP_SCRIPTLET = "<html> <% someString = someString + \"suffix\"; %> </html>";    private static final String JSP_EXPRESSION = "<html><head><title> <%= someString %> </title></head></html>";    private static final String JSP_EXPRESSION_IN_ATTRIBUTE = "<html> <body> <p class='<%= style.getClass() %>'> Hello </p> </body> </html>";    private static final String JSP_EL_EXPRESSION = "<html><title>Hello ${myBean.get(\"${ World }\") } .jsp</title></html>";    private static final String JSP_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').${myValidator.find(\"'jsp'\")}\" /> </html>";    private static final String JSF_VALUE_BINDING = "<html> <body> <p class='#{myValidator.find(\"'jsf'\")}'> Hello </p> </body> </html>";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(JspPageStyleTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import java.io.StringReader;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.testframework.RuleTst;public class XPathJspRuleTest extends RuleTst {    /**     * Test matching a XPath expression against a JSP source.     * @throws PMDException     */    @Test    public void testExpressionMatching() throws PMDException {        Rule rule = new XPathRule(XPATH_EXPRESSION);        rule.setMessage("Test");        rule.setLanguage(LanguageRegistry.getLanguage(JspLanguageModule.NAME));        RuleSet rules = RuleSet.forSingleRule(rule);        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        ctx.setLanguageVersion(LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion());        PMD p = new PMD();        p.getSourceCodeProcessor().processSourceCode(new StringReader(MATCH), new RuleSets(rules), ctx);        assertEquals("One violation expected!", 1, report.size());        RuleViolation rv = report.iterator().next();        assertEquals(1, rv.getBeginLine());    }    private static final String MATCH = "<html><hr/></html>";    private static final String XPATH_EXPRESSION = "//Element [@Name='hr']";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @Before    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *     */    @Test    public void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp;import java.io.File;import java.io.StringReader;import java.nio.file.Paths;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for JSP parsing. * */public class JspParserTest {    /**     * Verifies bug #939 Jsp parser fails on $     */    @Test    public void testParseDollar() {        Node node = parse(                "<span class=\"CostUnit\">$</span><span class=\"CostMain\">129</span><span class=\"CostFrac\">.00</span>");        Assert.assertNotNull(node);    }    @Test    public void testParseELAttribute() {        Node node = parse(                "<div ${something ? 'class=\"red\"' : ''}> Div content here.</div>");        Assert.assertNotNull(node);    }    @Test    public void testParseELAttributeValue() {        Node node = parse(                "<div class=\"${something == 0 ? 'zero_something' : something == 1 ? 'one_something' : 'other_something'}\">Div content here.</div>");        Assert.assertNotNull(node);    }    /**     * Verifies bug #311 Jsp parser fails on boolean attribute     */    @Test    public void testParseBooleanAttribute() {        Node node = parse(                "<label><input type='checkbox' checked name=cheese disabled=''> Cheese</label>");        Assert.assertNotNull(node);    }    @Test    public void testParseJsp() {        testInternalJspFile(Paths.get("sample.jsp").toFile());        testInternalJspFile(Paths.get("sample.jspx").toFile());    }    @Test    public void testParseTag() {        testInternalJspFile(Paths.get("sample.tag").toFile());    }    @Test(expected = AssertionError.class)    public void testParseWrong() {        testInternalJspFile(Paths.get("sample.xxx").toFile());    }    private void testInternalJspFile(File jspFile) {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(jspFile);        Assert.assertEquals("LanguageVersion must be JSP!",                LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), languageVersion);    }    private Node parse(String code) {        LanguageVersionHandler jspLang = LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler();        Parser parser = jspLang.getParser(jspLang.getDefaultParserOptions());        Node node = parser.parse(null, new StringReader(code));        return node;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class JSPTokenizerTest extends CpdTextComparisonTest {    public JSPTokenizerTest() {        super(".jsp");    }    @Override    protected String getResourcePrefix() {        return "../lang/jsp/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new JSPTokenizer();    }    @Test    public void scriptletWithString() {        doTest("scriptletWithString");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on JSP file.     */    @Test    public void testJspFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File jspFile = new File("/path/to/MyPage.jsp");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(jspFile);        assertEquals("LanguageVersion must be JSP!",                LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { JspLanguageModule.NAME, JspLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test jsp's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * @author rpelisse * */public class FortranTokenizerTest extends CpdTextComparisonTest {    public FortranTokenizerTest() {        super(".for");    }    @Override    protected String getResourcePrefix() {        return "../lang/fortran/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new FortranLanguage().getTokenizer();    }    @Test    public void testSample() {        doTest("sample");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.FileSystems;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.SystemUtils;import org.junit.Before;import org.junit.Test;import org.yaml.snakeyaml.DumperOptions;import org.yaml.snakeyaml.DumperOptions.FlowStyle;import org.yaml.snakeyaml.DumperOptions.LineBreak;import org.yaml.snakeyaml.Yaml;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RulesetsFactoryUtils;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;public class SidebarGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    @Before    public void setup() {        writer.reset();    }    @Test    public void testSidebar() throws IOException {        Map<Language, List<RuleSet>> rulesets = new HashMap<>();        RuleSet ruleSet1 = RulesetsFactoryUtils.defaultFactory().createNewRuleSet("test", "test", "bestpractices.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        RuleSet ruleSet2 = RulesetsFactoryUtils.defaultFactory().createNewRuleSet("test2", "test", "codestyle.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        rulesets.put(LanguageRegistry.findLanguageByTerseName("java"), Arrays.asList(ruleSet1, ruleSet2));        rulesets.put(LanguageRegistry.findLanguageByTerseName("ecmascript"), Arrays.asList(ruleSet1));        SidebarGenerator generator = new SidebarGenerator(writer, FileSystems.getDefault().getPath(".."));        List<Map<String, Object>> result = generator.generateRuleReferenceSection(rulesets);        DumperOptions options = new DumperOptions();        options.setDefaultFlowStyle(FlowStyle.BLOCK);        if (SystemUtils.IS_OS_WINDOWS) {            options.setLineBreak(LineBreak.WIN);        }        String yaml = new Yaml(options).dump(result);        String expected = MockedFileWriter.normalizeLineSeparators(                IOUtils.toString(SidebarGeneratorTest.class.getResourceAsStream("sidebar.yml"), StandardCharsets.UTF_8));        assertEquals(expected, yaml);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import java.util.List;import org.apache.commons.io.FilenameUtils;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.docs.MockedFileWriter.FileEntry;public class RuleDocGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    private Path root;    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Before    public void setup() throws IOException {        writer.reset();        root = folder.newFolder().toPath();        Files.createDirectories(root.resolve("docs/_data/sidebars"));        List<String> mockedSidebar = Arrays.asList(                "entries:",                "- title: sidebar",                "  folders:",                "  - title: 1",                "  - title: 2",                "  - title: 3",                "  - title: Rules");        Files.write(root.resolve("docs/_data/sidebars/pmd_sidebar.yml"), mockedSidebar);    }    private static String loadResource(String name) throws IOException {        return MockedFileWriter.normalizeLineSeparators(                IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name), StandardCharsets.UTF_8));    }    @Test    public void testSingleRuleset() throws IOException {        RuleDocGenerator generator = new RuleDocGenerator(writer, root);        RuleSetLoader rsl = new RuleSetLoader().includeDeprecatedRuleReferences(true);        RuleSet ruleset = rsl.loadFromResource("rulesets/ruledoctest/sample.xml");        generator.generate(Arrays.asList(ruleset),                Arrays.asList(                        "rulesets/ruledoctest/sample-deprecated.xml",                        "rulesets/ruledoctest/other-ruleset.xml"));        assertEquals(3, writer.getData().size());        FileEntry languageIndex = writer.getData().get(0);        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith("docs/pages/pmd/rules/java.md"));        assertEquals(loadResource("/expected/java.md"), languageIndex.getContent());        FileEntry ruleSetIndex = writer.getData().get(1);        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith("docs/pages/pmd/rules/java/sample.md"));        assertEquals(loadResource("/expected/sample.md"), ruleSetIndex.getContent());        FileEntry sidebar = writer.getData().get(2);        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith("docs/_data/sidebars/pmd_sidebar.yml"));        assertEquals(loadResource("/expected/pmd_sidebar.yml"), sidebar.getContent());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.fail;import java.nio.file.FileSystems;import java.nio.file.Path;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.apache.commons.io.FilenameUtils;import org.junit.Test;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.RulesetsFactoryUtils;public class RuleSetResolverTest {    private static List<String> excludedRulesets = new ArrayList<>();    static {        excludedRulesets.add(FilenameUtils.normalize("pmd-test/src/main/resources/rulesets/dummy/basic.xml"));    }    @Test    public void resolveAllRulesets() {        Path basePath = FileSystems.getDefault().getPath(".").resolve("..").toAbsolutePath().normalize();        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);        filterRuleSets(additionalRulesets);        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        for (String filename : additionalRulesets) {            try {                ruleSetFactory.createRuleSet(filename);            } catch (RuntimeException | RuleSetNotFoundException e) {                fail("Couldn't load ruleset " + filename + ": " + e.getMessage());            }        }    }    private void filterRuleSets(List<String> additionalRulesets) {        Iterator<String> it = additionalRulesets.iterator();        while (it.hasNext()) {            String filename = it.next();            for (String exclusion : excludedRulesets) {                if (filename.endsWith(exclusion)) {                    it.remove();                    break;                }            }        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import java.nio.file.FileSystems;import java.util.List;import org.junit.Assert;import org.junit.Test;public class RuleTagCheckerTest {    @Test    public void testAllChecks() throws Exception {        RuleTagChecker checker = new RuleTagChecker(FileSystems.getDefault().getPath("src/test/resources/ruletagchecker"));        List<String> issues = checker.check();        Assert.assertEquals(7, issues.size());        Assert.assertEquals("ruletag-examples.md: 9: Rule tag for \"java/bestpractices/AvoidPrintStackTrace\" is not closed properly",                issues.get(0));        Assert.assertEquals("ruletag-examples.md:12: Rule \"java/notexistingcategory/AvoidPrintStackTrace\" is not found",                issues.get(1));        Assert.assertEquals("ruletag-examples.md:14: Rule \"java/bestpractices/NotExistingRule\" is not found",                issues.get(2));        Assert.assertEquals("ruletag-examples.md:16: Rule tag for \"java/bestpractices/OtherRule has a missing quote",                issues.get(3));        Assert.assertEquals("ruletag-examples.md:17: Rule tag for java/bestpractices/OtherRule\" has a missing quote",                issues.get(4));        Assert.assertEquals("ruletag-examples.md:21: Rule tag for \"OtherRule has a missing quote", issues.get(5));        Assert.assertEquals("ruletag-examples.md:22: Rule tag for OtherRule\" has a missing quote", issues.get(6));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.List;import org.junit.Test;public class EscapeUtilsTest {    @Test    public void testEscapeMarkdown() {        assertEquals("This is a \\\\backslash", EscapeUtils.escapeMarkdown("This is a \\backslash"));        assertEquals("This \"\\*\" is not a emphasis", EscapeUtils.escapeMarkdown("This \"*\" is not a emphasis"));        assertEquals("This \"\\*\\*\" is not a strong style", EscapeUtils.escapeMarkdown("This \"**\" is not a strong style"));        assertEquals("This \"\\[foo\\]\" does not start a link", EscapeUtils.escapeMarkdown("This \"[foo]\" does not start a link"));        assertEquals("This \"\\~bar\\~\" is not a strike-through", EscapeUtils.escapeMarkdown("This \"~bar~\" is not a strike-through"));        assertEquals("That's \"\\|\" just a bar", EscapeUtils.escapeMarkdown("That's \"|\" just a bar"));        assertEquals("This \"\\_\" is just a underscore", EscapeUtils.escapeMarkdown("This \"_\" is just a underscore"));    }    @Test    public void testEscapeHtmlWithinMarkdownSingleLine() {        assertEquals("a &lt;script&gt; tag outside of `<script>` backticks should be escaped",                EscapeUtils.escapeSingleLine("a <script> tag outside of `<script>` backticks should be escaped"));        assertEquals("a &lt;script&gt; &quot;tag&quot; outside of `<script>` backticks should be escaped &lt;multiple&gt; times `<strong>`.",                EscapeUtils.escapeSingleLine("a <script> \"tag\" outside of `<script>` backticks should be escaped <multiple> times `<strong>`."));        assertEquals("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links",                EscapeUtils.escapeSingleLine("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links"));        assertEquals("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links",                EscapeUtils.escapeSingleLine("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links"));        assertEquals("URL: <http://www.google.com> is a url without ssl",                EscapeUtils.escapeSingleLine("URL: <http://www.google.com> is a url without ssl"));        assertEquals("> this is a quote line",                EscapeUtils.escapeSingleLine("> this is a quote line"));        assertEquals("combination of URLs and backticks: <https://pmd.github.io> but `<script>` &lt;strong&gt;escaped&lt;/strong&gt;",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: <https://pmd.github.io> but `<script>` <strong>escaped</strong>"));        assertEquals("combination of URLs and backticks: `<script>` &lt;strong&gt;escaped&lt;/strong&gt; but <https://pmd.github.io>",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: `<script>` <strong>escaped</strong> but <https://pmd.github.io>"));    }    @Test    public void testEscapeHtmlWithinMarkdownBlocks() {        String text = "paragraph\n\n> quote <script>\n> quote line \"2\"\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        String expected = "paragraph\n\n> quote &lt;script&gt;\n> quote line &quot;2&quot;\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        List<String> escaped = EscapeUtils.escapeLines(Arrays.asList(text.split("\n")));        assertEquals(Arrays.asList(expected.split("\n")), escaped);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.designer;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;/** * Unit tests for {@link Designer} */public class DesignerTest {    /**     * Unit test for https://sourceforge.net/p/pmd/bugs/1168/     */    @Test    public void testCopyXmlToClipboard() {        Node compilationUnit = Designer.getCompilationUnit(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler(),                "doesn't matter");        String xml = Designer.getXmlTreeCode(compilationUnit);        assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                + "<dummyNode BeginColumn=\"1\" BeginLine=\"1\" EndColumn=\"0\" EndLine=\"0\" FindBoundary=\"false\"\n"                + "           Image=\"Foo\"\n" + "           SingleLine=\"false\"/>", xml);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import javax.xml.transform.Source;import org.junit.Assert;import org.junit.Test;/** * * @author sturton */public class ResourceResolverTest {    /**     * Test of resolve method, of class ResourceResolver.     */    @Test    public void testResolve() throws Exception {        System.out.println("resolve");        String href = "";        String base = "";        ResourceResolver instance = new ResourceResolver();        Source expResult = null;        Source result = instance.resolve(href, base);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.File;import java.io.FileOutputStream;import java.io.PrintStream;import java.util.Map.Entry;import java.util.Properties;import java.util.ResourceBundle;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;/** * * @author sturton */public class DBTypeTest {    private File absoluteFile;    private Properties testProperties;    private Properties includeProperties;    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Before    public void setUp() throws Exception {        testProperties = new Properties();        testProperties.put("prop1", "value1");        testProperties.put("prop2", "value2");        testProperties.put("prop3", "value3");        includeProperties = new Properties();        includeProperties.putAll(testProperties);        includeProperties.put("prop3", "include3");        absoluteFile = folder.newFile();        try (FileOutputStream fileOutputStream = new FileOutputStream(absoluteFile);             PrintStream printStream = new PrintStream(fileOutputStream)) {            for (Entry<?, ?> entry : testProperties.entrySet()) {                printStream.printf("%s=%s\n", entry.getKey(), entry.getValue());            }        }    }    @After    public void tearDown() throws Exception {        testProperties = null;    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetPropertiesFromFile() throws Exception {        System.out.println("getPropertiesFromFile");        DBType instance = new DBType(absoluteFile.getAbsolutePath());        Properties expResult = testProperties;        Properties result = instance.getProperties();        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetProperties() throws Exception {        System.out.println("testGetProperties");        DBType instance = new DBType("test");        Properties expResult = testProperties;        System.out.println("testGetProperties: expected results " + testProperties);        Properties result = instance.getProperties();        System.out.println("testGetProperties: actual results " + result);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetIncludeProperties() throws Exception {        System.out.println("testGetIncludeProperties");        DBType instance = new DBType("include");        Properties expResult = includeProperties;        System.out.println("testGetIncludeProperties: expected results " + includeProperties);        Properties result = instance.getProperties();        System.out.println("testGetIncludeProperties: actual results " + result);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getResourceBundleAsProperties method, of class DBType.     */    @Test    public void testAsProperties() {        System.out.println("asProperties");        ResourceBundle bundle = ResourceBundle.getBundle(DBType.class.getPackage().getName() + ".test");        Properties expResult = testProperties;        Properties result = DBType.getResourceBundleAsProperties(bundle);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.InputStream;import org.junit.Assert;import org.junit.Test;/** * * @author sturton */public class ResourceLoaderTest {    /**     * Test of getResourceStream method, of class ResourceLoader.     */    @Test    public void testGetResourceStream() throws Exception {        System.out.println("getResourceStream");        String path = "";        ResourceLoader instance = new ResourceLoader();        InputStream expResult = null;        InputStream result = instance.getResourceStream(path);        Assert.assertNotNull(result);        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.Assert.assertEquals;import java.net.URI;import java.net.URISyntaxException;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;/** * * @author sturton */public class DBURITest {    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    /*     * Expected values from testdefaults.properties     */    static final String C_DEFAULT_USER = "scott";    static final String C_DEFAULT_PASSWORD = "tiger";    static final String C_DEFAULT_LANGUAGES = "java,plsql";    static final String C_DEFAULT_SCHEMAS = "scott,system";    static final String C_DEFAULT_SOURCE_CODE_TYPES = "table,view";    static final String C_DEFAULT_SOURCE_CODE_NAMES = "emp,dept";    static final String C_DEFAULT_CHARACTERSET = "utf8";    /**     * Fully specified URI, overriding defaults in testdefaults.properties     */    static final String C_TEST_EXPLICIT = "jdbc:oracle:testdefault:system/oracle@//192.168.100.21:1521/ORCL?characterset=us7ascii&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    /*     * Expected values from testdefaults.properties, with values overridden by     * URI query parameters     */    static final String C_EXPLICIT_USER = "system";    static final String C_EXPLICIT_PASSWORD = "oracle";    static final String C_EXPLICIT_LANGUAGES = "plsql,java";    static final String C_EXPLICIT_SCHEMAS = "scott,hr,sh,system";    static final String C_EXPLICIT_SOURCE_CODE_TYPES = "procedures,functions,triggers,package,types";    static final String C_EXPLICIT_SOURCE_CODE_NAMES = "PKG_%%,PRC_%%";    static final String C_EXPLICIT_CHARACTERSET = "us7ascii";    static final String C_TEST_URI = "test?param1=x%261&param2=&param3=";    static final String C_ORACLE_OCI_1 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_OCI_2 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_OCI_3 = "jdbc:oracle:oci:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_THIN_2 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_POSTGRES_1 = "jdbc:postgresql://host/database";    static final String C_HTTP = "http://localhost:80?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static void dump(String description, URI dburi) {        System.err.printf(                "Test %s\n: isOpaque=%s, isAbsolute=%s Scheme=%s,\n SchemeSpecificPart=%s,\n Host=%s,\n Port=%s,\n Path=%s,\n Fragment=%s,\n Query=%s\n",                description, dburi.isOpaque(), dburi.isAbsolute(), dburi.getScheme(), dburi.getSchemeSpecificPart(),                dburi.getHost(), dburi.getPort(), dburi.getPath(), dburi.getFragment(), dburi.getQuery());        String query = dburi.getQuery();        if (null != query && !"".equals(query)) {            String[] params = query.split("&");            Map<String, String> map = new HashMap<>();            for (String param : params) {                String[] splits = param.split("=");                String name = splits[0];                String value = null;                if (splits.length > 1) {                    value = splits[1];                }                map.put(name, value);                System.err.printf("name=%s,value=%s\n", name, value);            }        }        // return map;    }    /**     * Test of dump method, of class DBURI.     */    @Test    public void testDump() throws URISyntaxException, Exception {        System.out.println("dump");        String description = "";        DBURI dburi = new DBURI(C_TEST_URI);        DBURI.dump(description, dburi.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getUri method, of class DBURI.     */    @Test    public void testGetUri() throws URISyntaxException, Exception {        System.out.println("getUri");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        URI expResult = new URI(C_ORACLE_OCI_1);        URI result = instance.getUri();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setUri method, of class DBURI.     */    @Test    public void testSetUri() throws URISyntaxException, Exception {        System.out.println("setUri");        URI uri = new URI(C_ORACLE_OCI_1);        DBURI instance = new DBURI(C_TEST_URI);        instance.setUri(uri);        assertEquals(uri, instance.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    public void testGetDbType() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_POSTGRES_1);        DBType expResult = new DBType("postgresql");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    public void testGetDbType2() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        DBType expResult = new DBType("oci");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDbType method, of class DBURI.     */    @Test    public void testSetDbType() throws URISyntaxException, Exception {        System.out.println("setDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        DBType dbType = new DBType("postgresql");        instance.setDbType(dbType);        assertEquals(dbType, instance.getDbType());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSchemasList method, of class DBURI.     */    @Test    public void testGetSchemasList() throws URISyntaxException, Exception {        System.out.println("getSchemasList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult;        expResult = Arrays.asList("scott,hr,sh,system".split(","));        List<String> result = instance.getSchemasList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSchemasList method, of class DBURI.     */    @Test    public void testSetSchemasList() throws URISyntaxException, Exception {        System.out.println("setSchemasList");        List<String> schemasList = Arrays.asList("scott,hr,sh,system".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSchemasList(schemasList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeTypesList method, of class DBURI.     */    @Test    public void testGetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeTypesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("procedures,functions,triggers,package,types".split(","));        List<String> result = instance.getSourceCodeTypesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeTypesList method, of class DBURI.     */    @Test    public void testSetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeTypesList");        List<String> sourcecodetypesList = Arrays.asList("procedures,functions,triggers,package,types".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeTypesList(sourcecodetypesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeNamesList method, of class DBURI.     */    @Test    public void testGetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeNamesList");        DBURI instance = new DBURI(C_ORACLE_OCI_3);        List<String> expResult = Arrays.asList("PKG_%%,PRC_%%".split(","));        List<String> result = instance.getSourceCodeNamesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeNamesList method, of class DBURI.     */    @Test    public void testSetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeNamesList");        List<String> sourceCodeNamesList = Arrays.asList("PKG_%%,TRG_%%".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSourceCodeNamesList(sourceCodeNamesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getLanguagesList method, of class DBURI.     */    @Test    public void testGetLanguagesList() throws URISyntaxException, Exception {        System.out.println("getLanguagesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("plsql,java".split(","));        List<String> result = instance.getLanguagesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setLanguagesList method, of class DBURI.     */    @Test    public void testSetLanguagesList() throws URISyntaxException, Exception {        System.out.println("setLanguagesList");        List<String> languagesList = Arrays.asList("plsql,java".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setLanguagesList(languagesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    public void testGetDriverClass() throws URISyntaxException, Exception {        System.out.println("getDriverClass");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetDriverClass: driverClass=" + result);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    public void testGetThinDriverClass() throws URISyntaxException, Exception {        System.out.println("getThinDriverClass");        DBURI instance = new DBURI(C_ORACLE_THIN_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetThinDriverClass: driverClass=" + result);        System.out.println("testGetThinDriverClass: getDbType().getProperties() follows");        System.out                .println("testGetThinDriverClass: getDbType().getProperties()=" + instance.getDbType().getProperties());        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDriverClass method, of class DBURI.     */    @Test    public void testSetDriverClass() throws URISyntaxException, Exception {        System.out.println("setDriverClass");        String driverClass = "oracle.jdbc.driver.OracleDriver";        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setDriverClass(driverClass);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getCharacterSet method, of class DBURI.     */    @Test    public void testGetCharacterSet() throws URISyntaxException, Exception {        System.out.println("getCharacterSet");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "utf8";        String result = instance.getCharacterSet();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setCharacterSet method, of class DBURI.     */    @Test    public void testSetCharacterSet() throws URISyntaxException, Exception {        System.out.println("setCharacterSet");        String characterSet = "utf8";        DBURI instance = new DBURI(C_POSTGRES_1);        instance.setCharacterSet(characterSet);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeType method, of class DBURI.     */    @Test    public void testGetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("getSourceCodeType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        int expResult = 2005; // CLOB        int result = instance.getSourceCodeType();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeType method, of class DBURI.     */    @Test    public void testSetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("setSourceCodeType");        int sourceCodeType = 5;        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeType(sourceCodeType);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubprotocol method, of class DBURI.     */    @Test    public void testGetSubprotocol() throws URISyntaxException, Exception {        System.out.println("getSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oracle";        String result = instance.getSubprotocol();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubprotocol method, of class DBURI.     */    public void testSetSubprotocol() throws URISyntaxException, Exception {        System.out.println("setSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String subprotocol = "oracle";        instance.setSubprotocol(subprotocol);        String result = instance.getSubprotocol();        assertEquals(subprotocol, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubnamePrefix method, of class DBURI.     */    @Test    public void testGetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("getSubnamePrefix");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oci";        String result = instance.getSubnamePrefix();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubnamePrefix method, of class DBURI.     */    @Test    public void testSetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("setSubnamePrefix");        String subnamePrefix = "oci8";        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSubnamePrefix(subnamePrefix);        String result = instance.getSubnamePrefix();        assertEquals(subnamePrefix, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getParameters method, of class DBURI.     */    @Test    public void testGetParameters() throws URISyntaxException, Exception {        System.out.println("getParameters");        DBURI instance = new DBURI(C_TEST_URI);        Map<String, String> expResult = new HashMap<>();        expResult.put("param1", "x&1");        expResult.put("param2", null);        expResult.put("param3", null);        Map<String, String> result = instance.getParameters();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setParameters method, of class DBURI.     */    @Test    public void testSetParameters() throws URISyntaxException, Exception {        System.out.println("setParameters");        Map<String, String> parameters = new HashMap<>();        parameters.put("param1", "x%FFF");        parameters.put("param2", "IAmParameter2");        parameters.put("param3", "IAmParameter3");        DBURI instance = new DBURI(C_TEST_URI);        instance.setParameters(parameters);        // TODO review the generated test code and remove the default call to        // fail.        assertEquals(parameters, instance.getParameters());    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultLanguagesList() throws URISyntaxException, Exception {        System.out.println("testDefaultLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_DEFAULT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default CharacterSet are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultCharacterSet() throws URISyntaxException, Exception {        System.out.println("testDefaultCharacterSet");        DBURI instance = new DBURI(C_TEST_DEFAULTS);        String result = instance.getCharacterSet();        assertEquals(C_DEFAULT_CHARACTERSET, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultSchemasList() throws URISyntaxException, Exception {        System.out.println("testDefaultSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_DEFAULT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default Source Code Types are returned if non are provided in     * the DBURI.     */    @Test    public void testDefaultSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitLanguagesList() throws URISyntaxException, Exception {        System.out.println("testExplicitLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_EXPLICIT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that CharacterSet are returned if provided in the DBURI.     */    @Test    public void testExplicitCharacterSet() throws URISyntaxException, Exception {        System.out.println("testExplicitCharacterSet");        DBURI instance = new DBURI(C_TEST_EXPLICIT);        String result = instance.getCharacterSet();        assertEquals(C_EXPLICIT_CHARACTERSET, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitSchemasList() throws URISyntaxException, Exception {        System.out.println("testExplicitSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_EXPLICIT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that Source Code Types are returned if provided in the DBURI.     */    @Test    public void testExplicitSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.IOException;import java.io.Reader;import java.net.URISyntaxException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.List;import java.util.Properties;import java.util.logging.Level;import java.util.logging.Logger;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;/** * * @author sturton */@Ignorepublic class DBMSMetadataTest {    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:scott/tiger@//192.168.100.21:5521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:scott/oracle@//192.168.100.21:1521/orcl?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_4 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_5 = "jdbc:oracle:thin:@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25&amp;user=system&amp;password=oracle";    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    private DBURI dbURI;    private DBURI dbURI4;    private DBURI dbURI5;    private DBURI dbURIDefault;    public DBMSMetadataTest() throws URISyntaxException, Exception {        dbURI = new DBURI(C_ORACLE_THIN_3);        dbURI4 = new DBURI(C_ORACLE_THIN_4);        dbURI5 = new DBURI(C_ORACLE_THIN_5);        dbURIDefault = new DBURI(C_TEST_DEFAULTS);    }    /**     * Convert Readers to Strings for eay output and comparison.     */    private static String getStringFromReader(Reader reader) throws IOException {        StringBuilder stringBuilder = new StringBuilder(1024);        char[] charArray = new char[1024];        int readChars;        while ((readChars = reader.read(charArray)) > 0) {            System.out.println("Reader.read(CharArray)==" + readChars);            stringBuilder.append(charArray, 0, readChars);        }        reader.close();        return stringBuilder.toString();    }    /**     * Dump ResultSet     */    private static void dumpResultSet(ResultSet resultSet, String description) {        try {            ResultSetMetaData metaData = resultSet.getMetaData();            int columnCount = metaData.getColumnCount();            System.out.format("ResultSet \"%s\" has %d columns and contains ...\n[", description, columnCount);            /*             * Walk through the column names, writing out a header line             */            for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                System.out.format("%s%s", ((columnNumber > 1) ? "," : ""), metaData.getColumnName(columnNumber));            }            System.out.format("\n");            // Output each row            while (resultSet.next()) {                /*                 * Walk through the columns of this row, writing out a row line                 */                for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                    System.out.format("%s%s", ((columnNumber > 0) ? "," : ""), resultSet.getString(columnNumber));                }                System.out.format("\n");            }        } catch (SQLException ex) {            Logger.getLogger(DBMSMetadataTest.class.getName()).log(Level.SEVERE, null, ex);        }        System.out.format("...\n]\n");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @org.junit.Test    public void testGetConnection() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(dbURI.getURL()).connect(dbURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @Test    public void testGetConnectionWithConnectionParameters() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI5.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI5.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI5.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.putAll(dbURI5.getParameters());        Connection expResult = DriverManager.getDriver(dbURI5.getURL()).connect(dbURI5.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI5);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCode method, of class DBMSMetadata.     */    @Test    public void testGetSourceCode() throws Exception {        System.out.println("getSourceCode");        // String objectType = "PACKAGE";        // String name = "DBMS_REPCAT_AUTH";        // String schema = "SYSTEM";        String objectType = "TABLE";        String name = "EMP";        String schema = "SCOTT";        System.out.println("dbURI.driverClass==" + dbURI.getDriverClass());        System.out.println("dbURI.URL==" + dbURI.getURL());        System.out.println("dbURI.getDBType.getProperties()==" + dbURI.getDbType().getProperties());        System.out.println("dbURI.getDBType.getSourceCodeReturnType()==" + dbURI.getDbType().getSourceCodeReturnType());        System.out.println("dbURI.getDBType.getProperties()=="                + dbURI.getDbType().getProperties().getProperty("getSourceCodeStatement"));        DBMSMetadata instance = new DBMSMetadata(dbURI);        Reader expResult = null;        Reader result = instance.getSourceCode(objectType, name, schema);        /*         * StringBuilder stringBuilder = new StringBuilder(1024); char[]         * charArray = new char[1024]; int readChars = 0; while(( readChars =         * result.read(charArray)) > 0 ) {         * System.out.println("Reader.read(CharArray)=="+readChars);         * stringBuilder.append(charArray, 0, readChars); } result.close();         *         * System.out.println("getSourceCode()==\""+stringBuilder.toString()+         * "\"" );         *         * assertTrue(stringBuilder.toString().startsWith("\n  CREATE "));         */        String resultString = getStringFromReader(result);        System.out.println("getSourceCode()==\"" + resultString);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    public void testGetSchemas() throws Exception {        System.out.println("getSchemas");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        ResultSet allSchemas = result.getMetaData().getSchemas();        dumpResultSet(allSchemas, "All Schemas");        ResultSet allCatalogues = result.getMetaData().getCatalogs();        dumpResultSet(allCatalogues, "All Catalogues");        String catalog = null;        String schemasPattern = "PHPDEMO";        String tablesPattern = null;        String proceduresPattern = null;        // Not until Java6 ResultSet matchedSchemas =        // result.getMetaData().getSchemas(catalog, schemasPattern) ;        // Not until Java6 dumpResultSet (matchedSchemas, "Matched Schemas") ;        ResultSet matchedTables = result.getMetaData().getTables(catalog, schemasPattern, tablesPattern, null);        dumpResultSet(matchedTables, "Matched Tables");        ResultSet matchedProcedures = result.getMetaData().getProcedures(catalog, schemasPattern, proceduresPattern);        dumpResultSet(matchedProcedures, "Matched Procedures");        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    public void testGetSourceObjectList() throws Exception {        System.out.println("getConnection");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        List<SourceObject> sourceObjectList = instance.getSourceObjectList();        Assert.assertNotNull(sourceObjectList);        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());        System.out.print("sourceObjectList ...\n");        for (SourceObject sourceObject : sourceObjectList) {            System.out.printf("sourceObject=%s\n", sourceObject);            System.out.printf("sourceCode=[%s]\n", getStringFromReader(instance.getSourceCode(sourceObject)));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.filter;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;public class RegexStringFilterTest {    @Test    public void testFilterAbsoluteWithExtension() {        String pattern = "C:/workspace/project/X.java";        verifyFilterFalse("same relative path w/ extension", pattern, "X.java");        verifyFilterFalse("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterTrue("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterFalse("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testFilterAbsoluteWithoutExtension() {        String pattern = "C:/workspace/project/X";        verifyFilterFalse("same relative path w/ extension", pattern, "X.java");        verifyFilterFalse("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterFalse("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterTrue("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testFilterRelativeWithExtension() {        String pattern = ".*X.java";        verifyFilterTrue("same relative path w/ extension", pattern, "X.java");        verifyFilterFalse("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterTrue("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterFalse("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testFilterRelativeWithoutExtension() {        String pattern = ".*X";        verifyFilterFalse("same relative path w/ extension", pattern, "X.java");        verifyFilterTrue("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterFalse("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterTrue("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testEndsWith() {        // These patterns cannot be optimized to use String.endsWith        verifyEndsWith("no literal path", ".*", null);        verifyEndsWith("not ends with", "x", null);        verifyEndsWith("glob on end", ".*XXX.*", null);        verifyEndsWith("special character \\", ".*X\\Y", null);        verifyEndsWith("special character [", ".*X[Y", null);        verifyEndsWith("special character (", ".*X(Y", null);        verifyEndsWith("special character *", ".*X*Y", null);        verifyEndsWith("special character ?", ".*X?Y", null);        verifyEndsWith("special character +", ".*X+Y", null);        verifyEndsWith("special character |", ".*X|Y", null);        verifyEndsWith("special character {", ".*X{Y", null);        verifyEndsWith("special character $", ".*X$Y", null);        verifyEndsWith("too many .", ".*X.Y.java", null);        // These patterns can be optimized to use String.endsWith        verifyEndsWith("unescaped .", ".*X.java", "X.java");        verifyEndsWith("escaped .", ".*X\\.java", "X.java");        verifyEndsWith("no extension", ".*X", "X");        verifyEndsWith("begin anchor, unescaped .", "^.*X.java", "X.java");        verifyEndsWith("begin anchor, escaped .", "^.*X\\.java", "X.java");        verifyEndsWith("begin anchor, no extension", "^.*X", "X");        verifyEndsWith("end anchor, unescaped .", ".*X.java$", "X.java");        verifyEndsWith("end anchor, escaped .", ".*X\\.java$", "X.java");        verifyEndsWith("end anchor, no extension", ".*X$", "X");        verifyEndsWith("begin and end anchors, unescaped .", "^.*X.java$", "X.java");        verifyEndsWith("begin and end anchors, escaped .", "^.*X\\.java$", "X.java");        verifyEndsWith("begin and end anchors, no extension", "^.*X$", "X");    }    private static void verifyFilterTrue(final String message, final String pattern, final String file) {        assertTrue("filter: " + message, new RegexStringFilter(pattern).filter(file));    }    private static void verifyFilterFalse(final String message, final String pattern, final String file) {        assertFalse("filter: " + message, new RegexStringFilter(pattern).filter(file));    }    private static void verifyEndsWith(final String message, final String pattern, final String endsWith) {        assertEquals("endsWith: " + message, endsWith, new RegexStringFilter(pattern).getEndsWith());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(RegexStringFilterTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.hamcrest.MatcherAssert;import org.hamcrest.Matchers;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertySource;/** * */public class TreeRenderersTest {    @Rule    public ExpectedException expect = ExpectedException.none();    @Test    public void testStandardRenderersAreRegistered() {        Assert.assertEquals(TreeRenderers.XML, TreeRenderers.findById(TreeRenderers.XML.id()));    }    @Test    public void testXmlPropertiesAvailable() {        PropertySource properties = TreeRenderers.XML.newPropertyBundle();        MatcherAssert.assertThat(properties.getPropertyDescriptors(),                          Matchers.<PropertyDescriptor<?>>containsInAnyOrder(TreeRenderers.XML_LINE_SEPARATOR,                                                                             TreeRenderers.XML_RENDER_COMMON_ATTRIBUTES,                                                                             TreeRenderers.XML_RENDER_PROLOG,                                                                             TreeRenderers.XML_USE_SINGLE_QUOTES));    }    @Test    public void testXmlDescriptorDump() throws IOException {        PropertySource bundle = TreeRenderers.XML.newPropertyBundle();        bundle.setProperty(TreeRenderers.XML_RENDER_PROLOG, false);        bundle.setProperty(TreeRenderers.XML_USE_SINGLE_QUOTES, false);        bundle.setProperty(TreeRenderers.XML_LINE_SEPARATOR, "\n");        TreeRenderer renderer = TreeRenderers.XML.produceRenderer(bundle);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummyTree1(), out);        Assert.assertEquals("<dummyNode foo=\"bar\" ohio=\"4\">\n"                                + "    <dummyNode o=\"ha\" />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    public MyDummyNode dummyTree1() {        MyDummyNode dummy = new MyDummyNode();        dummy.setXPathAttribute("foo", "bar");        dummy.setXPathAttribute("ohio", "4");        MyDummyNode dummy1 = new MyDummyNode();        dummy1.setXPathAttribute("o", "ha");        MyDummyNode dummy2 = new MyDummyNode();        dummy.jjtAddChild(dummy1, 0);        dummy.jjtAddChild(dummy2, 1);        return dummy;    }    private static class MyDummyNode extends DummyNode {        private final Map<String, String> attributes = new HashMap<>();        public void setXPathAttribute(String name, String value) {            attributes.put(name, value);        }        @Override        public Iterator<Attribute> getXPathAttributesIterator() {            List<Attribute> attrs = new ArrayList<>();            for (String name : attributes.keySet()) {                attrs.add(new Attribute(this, name, attributes.get(name)));            }            return attrs.iterator();        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer.XmlRenderingConfig;/** */public class XmlTreeRendererTest {    @Rule    public ExpectedException expect = ExpectedException.none();    @Test    public void testRenderWithAttributes() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig();        strat.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testRenderWithCustomLineSep() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig();        strat.lineSeparator("\r\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\r\n"                                + "<dummyNode foo='bar' ohio='4'>\r\n"                                + "    <dummyNode o='ha' />\r\n"                                + "    <dummyNode />\r\n"                                + "</dummyNode>\r\n", out.toString());    }    @Test    public void testRenderWithCustomIndent() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("").indentWith("");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>"                                + "<dummyNode foo='bar' ohio='4'>"                                + "<dummyNode o='ha' />"                                + "<dummyNode />"                                + "</dummyNode>", out.toString());    }    @Test    public void testRenderWithNoAttributes() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig() {            @Override            public boolean takeAttribute(Node node, Attribute attribute) {                return false;            }        }.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode>\n"                                + "    <dummyNode />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testRenderFilterAttributes() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strategy = new XmlRenderingConfig() {            @Override            public boolean takeAttribute(Node node, Attribute attribute) {                return attribute.getName().equals("ohio");            }        }.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strategy);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode ohio='4'>\n"                                + "    <dummyNode />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testInvalidAttributeName() throws IOException {        MyDummyNode dummy = dummyTree1();        dummy.setXPathAttribute("&notAName", "foo");        XmlRenderingConfig config = new XmlRenderingConfig();        config.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(config);        StringBuilder out = new StringBuilder();        expect.expect(IllegalArgumentException.class);        renderer.renderSubtree(dummy, out);    }    @Test    public void testEscapeAttributes() throws IOException {        MyDummyNode dummy = dummyTree1();        dummy.setXPathAttribute("eh", " 'a &> b\" ");        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode eh=' &apos;a &amp;> b\" ' foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testEscapeDoubleAttributes() throws IOException {        MyDummyNode dummy = dummyTree1();        dummy.setXPathAttribute("eh", " 'a &> b\" ");        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n").singleQuoteAttributes(false);        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"                                + "<dummyNode eh=\" 'a &amp;> b&quot; \" foo=\"bar\" ohio=\"4\">\n"                                + "    <dummyNode o=\"ha\" />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testNoProlog() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n").renderProlog(false);        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<dummyNode foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testDefaultLineSep() throws IOException {        DummyNode dummy = dummyTree1();        XmlTreeRenderer renderer = new XmlTreeRenderer();        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>" + System.lineSeparator()                                + "<dummyNode foo='bar' ohio='4'>" + System.lineSeparator()                                + "    <dummyNode o='ha' />" + System.lineSeparator()                                + "    <dummyNode />" + System.lineSeparator()                                + "</dummyNode>" + System.lineSeparator(), out.toString());    }    public MyDummyNode dummyTree1() {        MyDummyNode dummy = new MyDummyNode();        dummy.setXPathAttribute("foo", "bar");        dummy.setXPathAttribute("ohio", "4");        MyDummyNode dummy1 = new MyDummyNode();        dummy1.setXPathAttribute("o", "ha");        MyDummyNode dummy2 = new MyDummyNode();        dummy.jjtAddChild(dummy1, 0);        dummy.jjtAddChild(dummy2, 1);        return dummy;    }    private static class MyDummyNode extends DummyNode {        private final Map<String, String> attributes = new HashMap<>();        public void setXPathAttribute(String name, String value) {            attributes.put(name, value);        }        @Override        public Iterator<Attribute> getXPathAttributesIterator() {            List<Attribute> attrs = new ArrayList<>();            for (String name : attributes.keySet()) {                attrs.add(new Attribute(this, name, attributes.get(name)));            }            return attrs.iterator();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.datasource;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.IOException;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class FileDataSourceTest {    @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();    private static final String SOMEFILE_DIR = "path/";    private static final String SOMEFILE_TXT = "somefile.txt";    private static final String SOMEFILE_TXT_FULL_PATH = SOMEFILE_DIR + SOMEFILE_TXT;    private FileDataSource ds;    private File someFile;    private File someFolder;    @Before    public void setup() throws IOException {        someFolder = tempFolder.newFolder(SOMEFILE_DIR);        someFile = tempFolder.newFile(SOMEFILE_TXT_FULL_PATH);        ds = new FileDataSource(someFile);    }    @Test    public void testShortNamesSingleFile() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFile.getAbsolutePath()));    }    @Test    public void testShortNamesSingleDir() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFolder.getAbsolutePath()));    }    @Test    public void testShortNamesNullBase() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, null));    }    @Test    public void testShortNamesCommaSeparatedDirs() {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }    @Test    public void testShortNamesCommaSeparatedFiles() {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }    @Test    public void testShortNamesCommaSeparatedMixed() {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }    @Test    public void testLongNamesSingleFile() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFile.getAbsolutePath()));    }    @Test    public void testLongNamesSingleDir() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFolder.getAbsolutePath()));    }    @Test    public void testLongNamesNullBase() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, null));    }    @Test    public void testLongNamesCommaSeparatedDirs() throws IOException {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }    @Test    public void testLongNamesCommaSeparatedFiles() throws IOException {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }    @Test    public void testLongNamesCommaSeparatedMixed() throws IOException {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.NoSuchElementException;import org.junit.Before;import org.junit.Test;public class CompoundListTest {    private List<String> l1;    private List<String> l2;    private Iterator<String> iterator;    @Before    public void setUp() {        l1 = new ArrayList<>();        l1.add("1");        l1.add("2");        l2 = new ArrayList<>();        l2.add("3");        l2.add("4");        iterator = new CompoundIterator<>(l1.iterator(), l2.iterator());    }    @Test    public void testHappyPath() {        assertTrue(iterator.hasNext());        assertEquals("1", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("2", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("3", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("4", iterator.next());        assertFalse(iterator.hasNext());        assertEquals(2, l1.size());        assertEquals(2, l2.size());    }    @Test    public void testHappyPathRemove() {        assertTrue(iterator.hasNext());        assertEquals("1", iterator.next());        iterator.remove();        assertTrue(iterator.hasNext());        assertEquals("2", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("3", iterator.next());        iterator.remove();        assertTrue(iterator.hasNext());        assertEquals("4", iterator.next());        assertFalse(iterator.hasNext());        assertEquals(1, l1.size());        assertEquals("2", l1.get(0));        assertEquals(1, l2.size());        assertEquals("4", l2.get(0));    }    @Test    public void testEmpty() {        Iterator<?> iterator = new CompoundIterator();        assertFalse(iterator.hasNext());    }    @Test(expected = NoSuchElementException.class)    public void testEmptyBadNext() {        Iterator<?> iterator = new CompoundIterator();        iterator.next();    }    @Test(expected = IllegalStateException.class)    public void testEmptyBadRemove() {        Iterator<?> iterator = new CompoundIterator();        iterator.remove();    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(CompoundListTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.fail;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Test;/** * Evaluates all major functionality of the TypeMap class. * * @author Brian Remedios */public class TypeMapTest {    @Test    public void testAddClassOfQ() {        TypeMap map = new TypeMap(2);        map.add(List.class);        try {            map.add(java.awt.List.class);        } catch (IllegalArgumentException ex) {            return; // caught ok        }        fail("Uncaught error inserting type with same root names");    }    @Test    public void testContainsClassOfQ() {        TypeMap map = new TypeMap(2);        map.add(String.class);        map.add(List.class);        Assert.assertTrue(map.contains(String.class));        Assert.assertTrue(map.contains(List.class));        Assert.assertFalse(map.contains(Map.class));    }    @Test    public void testContainsString() {        TypeMap map = new TypeMap(2);        map.add(String.class);        map.add(List.class);        Assert.assertTrue(map.contains("String"));        Assert.assertTrue(map.contains("java.lang.String"));    }    @Test    public void testTypeFor() {        TypeMap map = new TypeMap(2);        map.add(String.class);        map.add(List.class);        Assert.assertTrue(map.typeFor("String") == String.class);        Assert.assertTrue(map.typeFor("java.lang.String") == String.class);        Assert.assertTrue(map.typeFor("List") == List.class);        Assert.assertTrue(map.typeFor("java.util.List") == List.class);    }    @Test    public void testSize() {        TypeMap map = new TypeMap(4);        map.add(String.class);        map.add(HashMap.class);        map.add(Integer.class);        Assert.assertTrue(map.size() == 6);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.assertEquals;import java.util.Collection;import org.junit.Test;import net.sourceforge.pmd.ReadableDurationTest;/** * * @author Brian Remedios */public class DateTimeUtilTest {    @Test    public void testConversions() {        Collection<Object[]> stringNumberPairs = ReadableDurationTest.data();        for (Object[] stringAndNumber : stringNumberPairs) {            String result = (String) stringAndNumber[0];            Integer milliseconds = (Integer) stringAndNumber[1];            assertEquals(result, DateTimeUtil.asHoursMinutesSeconds(milliseconds));        }    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(DateTimeUtilTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.Assert.assertEquals;import org.junit.Test;public class StringUtilTest {    @Test    public void testColumnNumber() {        assertEquals(-1, StringUtil.columnNumberAt("f\rah\nb", -1));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 0));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 1));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 2));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 3));        assertEquals(3, StringUtil.columnNumberAt("f\rah\nb", 4));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 5));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 6));        assertEquals(-1, StringUtil.columnNumberAt("f\rah\nb", 7));    }    @Test    public void testColumnNumberCrLf() {        assertEquals(-1, StringUtil.columnNumberAt("f\r\nb", -1));        assertEquals(1, StringUtil.columnNumberAt("f\r\nb", 0));        assertEquals(2, StringUtil.columnNumberAt("f\r\nb", 1));        assertEquals(3, StringUtil.columnNumberAt("f\r\nb", 2));        assertEquals(1, StringUtil.columnNumberAt("f\r\nb", 3));        assertEquals(2, StringUtil.columnNumberAt("f\r\nb", 4));        assertEquals(-1, StringUtil.columnNumberAt("f\r\nb", 5));    }    @Test    public void testColumnNumberTrailing() {        assertEquals(1, StringUtil.columnNumberAt("\n", 0));        assertEquals(2, StringUtil.columnNumberAt("\n", 1));        assertEquals(-1, StringUtil.columnNumberAt("\n", 2));    }    @Test    public void testColumnNumberEmpty() {        assertEquals(1, StringUtil.columnNumberAt("", 0));        assertEquals(-1, StringUtil.columnNumberAt("", 1));    }    @Test    public void testReplaceWithOneChar() {        assertEquals("faa", StringUtil.replaceString("foo", 'o', "a"));    }    @Test    public void testReplaceWithMultipleChars() {        assertEquals("faaaa", StringUtil.replaceString("foo", 'o', "aa"));    }    @Test    public void testReplaceStringWithString() {        assertEquals("foo]]&gt;bar", StringUtil.replaceString("foo]]>bar", "]]>", "]]&gt;"));    }    @Test    public void testReplaceStringWithString2() {        assertEquals("replaceString didn't work with a >", "foobar",                StringUtil.replaceString("foobar", "]]>", "]]&gt;"));    }    @Test    public void testReplaceWithNull() {        assertEquals("replaceString didn't work with a char", "f", StringUtil.replaceString("foo", 'o', null));    }    @Test    public void testUTF8NotSupported() {        StringBuilder sb = new StringBuilder();        String test = "é";        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#xe9;", sb.toString());    }    @Test    public void testUTF8NotSupportedSurrogates() {        // D8 34 DD 1E -> U+1D11E        StringBuilder sb = new StringBuilder();        String test = new String(new char[] {0xd834, 0xdd1e});        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#x1d11e;", sb.toString());    }    @Test    public void testUTF8Supported() {        StringBuilder sb = new StringBuilder();        String test = "é";        StringUtil.appendXmlEscaped(sb, test, true);        assertEquals("é", sb.toString());    }    @Test    public void testRemoveSurrounding() {        assertThat(StringUtil.removeSurrounding("", 'q'), equalTo(""));        assertThat(StringUtil.removeSurrounding("q", 'q'), equalTo("q"));        assertThat(StringUtil.removeSurrounding("qq", 'q'), equalTo(""));        assertThat(StringUtil.removeSurrounding("qqq", 'q'), equalTo("q"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.processor;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.RulesetsFactoryUtils;import net.sourceforge.pmd.ThreadSafeReportListener;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.renderers.AbstractAccumulatingRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.stat.Metric;import net.sourceforge.pmd.util.datasource.DataSource;import net.sourceforge.pmd.util.datasource.internal.AbstractDataSource;public class MultiThreadProcessorTest {    private RuleContext ctx;    private MultiThreadProcessor processor;    private RuleSetFactory ruleSetFactory;    private List<DataSource> files;    private SimpleReportListener reportListener;    public void setUpForTest(final String ruleset) {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setRuleSets(ruleset);        configuration.setThreads(2);        files = new ArrayList<>();        files.add(new StringDataSource("file1-violation.dummy", "ABC"));        files.add(new StringDataSource("file2-foo.dummy", "DEF"));        reportListener = new SimpleReportListener();        ctx = new RuleContext();        ctx.getReport().addListener(reportListener);        processor = new MultiThreadProcessor(configuration);        ruleSetFactory = RulesetsFactoryUtils.defaultFactory();    }    @Test    public void testRulesDysnfunctionalLog() throws IOException {        setUpForTest("rulesets/MultiThreadProcessorTest/dysfunctional.xml");        final SimpleRenderer renderer = new SimpleRenderer(null, null);        renderer.start();        processor.processFiles(ruleSetFactory, files, ctx, Collections.<Renderer>singletonList(renderer));        renderer.end();        final Iterator<ConfigurationError> configErrors = renderer.getReport().configErrors();        final ConfigurationError error = configErrors.next();        Assert.assertEquals("Dysfunctional rule message not present",                DysfunctionalRule.DYSFUNCTIONAL_RULE_REASON, error.issue());        Assert.assertEquals("Dysfunctional rule is wrong",                DysfunctionalRule.class, error.rule().getClass());        Assert.assertFalse("More configuration errors found than expected", configErrors.hasNext());    }    @Test    public void testRulesThreadSafety() {        setUpForTest("rulesets/MultiThreadProcessorTest/basic.xml");        processor.processFiles(ruleSetFactory, files, ctx, Collections.<Renderer>emptyList());        // if the rule is not executed, then maybe a        // ConcurrentModificationException happened        Assert.assertEquals("Test rule has not been executed", 2, NotThreadSafeRule.count.get());        // if the violation is not reported, then the rule instances have been        // shared between the threads        Assert.assertEquals("Missing violation", 1, reportListener.violations.get());    }    private static class StringDataSource extends AbstractDataSource {        private final String data;        private final String name;        StringDataSource(String name, String data) {            this.name = name;            this.data = data;        }        @Override        public InputStream getInputStream() throws IOException {            return new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));        }        @Override        public String getNiceFileName(boolean shortNames, String inputFileName) {            return name;        }    }    public static class NotThreadSafeRule extends AbstractRule {        public static AtomicInteger count = new AtomicInteger(0);        private boolean hasViolation; // this variable will be overridden        // between the threads        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            count.incrementAndGet();            if (ctx.getSourceCodeFilename().contains("violation")) {                hasViolation = true;            } else {                letTheOtherThreadRun(10);                hasViolation = false;            }            letTheOtherThreadRun(100);            if (hasViolation) {                addViolation(ctx, nodes.get(0));            }        }        private void letTheOtherThreadRun(int millis) {            try {                Thread.yield();                Thread.sleep(millis);            } catch (InterruptedException e) {                // ignored            }        }    }    public static class DysfunctionalRule extends AbstractRule {        public static final String DYSFUNCTIONAL_RULE_REASON = "dysfunctional rule is dysfunctional";        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            // noop        }        @Override        public String dysfunctionReason() {            return DYSFUNCTIONAL_RULE_REASON;        }    }    private static class SimpleReportListener implements ThreadSafeReportListener {        public AtomicInteger violations = new AtomicInteger(0);        @Override        public void ruleViolationAdded(RuleViolation ruleViolation) {            violations.incrementAndGet();        }        @Override        public void metricAdded(Metric metric) {        }    }    private static class SimpleRenderer extends AbstractAccumulatingRenderer {        /* default */ SimpleRenderer(String name, String description) {            super(name, description);        }        @Override        public String defaultFileExtension() {            return null;        }        @Override        public void end() throws IOException {        }        public Report getReport() {            return report;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.document;import static org.junit.Assert.assertEquals;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class DocumentFileTest {    private static final String FILE_PATH = "psvm.java";    @Rule    public TemporaryFolder temporaryFolder = new TemporaryFolder();    private File temporaryFile;    @Before    public void setUpTemporaryFiles() throws IOException {        temporaryFile = temporaryFolder.newFile(FILE_PATH);    }    @Test    public void insertAtStartOfTheFileShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void shouldPreserveNewlines() throws IOException {        final String testFileContent = IOUtils.toString(                DocumentFileTest.class.getResource("ShouldPreserveNewlines.java"), StandardCharsets.UTF_8);        writeContentToTemporaryFile(testFileContent);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public " + testFileContent, actualContent);        }    }    private byte[] readAllBytes(final FileInputStream stream) throws IOException {        final int defaultBufferSize = 8192;        final int maxBufferSize = Integer.MAX_VALUE - 8;        byte[] buf = new byte[defaultBufferSize];        int capacity = buf.length;        int nread = 0;        int n;        while (true) {            // read to EOF which may read more or less than initial buffer size            while ((n = stream.read(buf, nread, capacity - nread)) > 0) {                nread += n;            }            // if the last call to read returned -1, then we're done            if (n < 0) {                break;            }            // need to allocate a larger buffer            if (capacity <= maxBufferSize - capacity) {                capacity = capacity << 1;            } else {                if (capacity == maxBufferSize) {                    throw new OutOfMemoryError("Required array size too large");                }                capacity = maxBufferSize;            }            buf = Arrays.copyOf(buf, capacity);        }        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);    }    @Test    public void insertVariousTokensIntoTheFileShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.insert(0, 17, "final ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(final String[] args) {}", actualContent);        }    }    @Test    public void insertAtTheEndOfTheFileShouldSucceed() throws IOException {        final String code = "public static void main(String[] args)";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, code.length(), "{}");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args){}", actualContent);        }    }    @Test    public void removeTokenShouldSucceed() throws IOException {        final String code = "public static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.delete(new RegionByLineImp(0, 0, 24, 30));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndRemoveTokensShouldSucceed() throws IOException {        final String code = "static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.delete(new RegionByLineImp(0, 0, 17, 23));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndDeleteVariousTokensShouldSucceed() throws IOException {        final String code = "void main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.insert(0, 0, "static ");            documentFile.delete(new RegionByLineImp(0, 0, 0, 4));            documentFile.insert(0, 10, "final ");            documentFile.delete(new RegionByLineImp(0, 0, 25, 28));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static  main(final String[] args) ", actualContent);        }    }    @Test    public void replaceATokenShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.replace(new RegionByLineImp(0, 0, 0, 3), "void");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void main(String[] args) {}", actualContent);        }    }    @Test    public void replaceVariousTokensShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.replace(new RegionByLineImp(0, 0, 0, "int".length()), "void");            documentFile.replace(new RegionByLineImp(0, 0, 4, 4 + "main".length()), "foo");            documentFile.replace(new RegionByLineImp(0, 0, 9, 9 + "String".length()), "CharSequence");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void foo(CharSequence[] args) {}", actualContent);        }    }    @Test    public void insertDeleteAndReplaceVariousTokensShouldSucceed() throws IOException {        final String code = "static int main(CharSequence[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public");            documentFile.delete(new RegionByLineImp(0, 0, 0, 6));            documentFile.replace(new RegionByLineImp(0, 0, 7, 7 + "int".length()), "void");            documentFile.insert(0, 16, "final ");            documentFile.replace(new RegionByLineImp(0, 0, 16, 16 + "CharSequence".length()), "String");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public void main(final String[] args) {}", actualContent);        }    }    @Test    public void lineToOffsetMappingWithLineFeedShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + '\n'                + "int var;" + '\n'                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(40);        expectedLineToOffset.add(49);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    @Test    public void lineToOffsetMappingWithCarriageReturnFeedLineFeedShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + "\r\n"                + "int var;" + "\r\n"                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(41);        expectedLineToOffset.add(51);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    @Test    public void lineToOffsetMappingWithMixedLineSeparatorsShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + "\r\n"                + "int var;" + "\n"                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(41);        expectedLineToOffset.add(50);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    private void writeContentToTemporaryFile(final String content) throws IOException {        try (BufferedWriter writer = Files.newBufferedWriter(temporaryFile.toPath(), StandardCharsets.UTF_8)) {            writer.write(content);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.document;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.Collections;import java.util.LinkedList;import java.util.List;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class DocumentOperationsApplierForNonOverlappingRegionsWithDocumentFileTest {    private static final String FILE_PATH = "psvm.java";    @Rule    public TemporaryFolder temporaryFolder = new TemporaryFolder();    private File temporaryFile;    private DocumentOperationsApplierForNonOverlappingRegions applier;    @Before    public void setUpTemporaryFiles() throws IOException {        temporaryFile = temporaryFolder.newFile(FILE_PATH);    }    @Test    public void insertAtStartOfTheDocumentShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    private byte[] readAllBytes(final FileInputStream stream) throws IOException {        final int defaultBufferSize = 8192;        final int maxBufferSize = Integer.MAX_VALUE - 8;        byte[] buf = new byte[defaultBufferSize];        int capacity = buf.length;        int nread = 0;        int n;        while (true) {            // read to EOF which may read more or less than initial buffer size            while ((n = stream.read(buf, nread, capacity - nread)) > 0) {                nread += n;            }            // if the last call to read returned -1, then we're done            if (n < 0) {                break;            }            // need to allocate a larger buffer            if (capacity <= maxBufferSize - capacity) {                capacity = capacity << 1;            } else {                if (capacity == maxBufferSize) {                    throw new OutOfMemoryError("Required array size too large");                }                capacity = maxBufferSize;            }            buf = Arrays.copyOf(buf, capacity);        }        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);    }    @Test    public void removeTokenShouldSucceed() throws IOException {        writeContentToTemporaryFile("public static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 7, 13));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public  void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndRemoveTokensShouldSucceed() throws IOException {        final String code = "static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 17, 23));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndDeleteVariousTokensShouldSucceed() throws IOException {        final String code = "void main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "static "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 0, 4));            applier.addDocumentOperation(new InsertDocumentOperation(0, 10, "final "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 25, 27));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static  main(final String[] args) ", actualContent);        }    }    @Test    public void replaceATokenShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new ReplaceDocumentOperation(0, 0, 0, "int".length(), "void"));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void main(String[] args) {}", actualContent);        }    }    @Test    public void replaceVariousTokensShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        final List<DocumentOperation> documentOperations = new LinkedList<>();        documentOperations.add(new ReplaceDocumentOperation(0, 0, 0, "int".length(), "void"));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 4, 4 + "main".length(), "foo"));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 9, 9 + "String".length(), "CharSequence"));        shuffleAndApplyOperations(documentOperations);        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void foo(CharSequence[] args) {}", actualContent);        }    }    private void shuffleAndApplyOperations(List<DocumentOperation> documentOperations) throws IOException {        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            Collections.shuffle(documentOperations);            for (final DocumentOperation operation : documentOperations) {                applier.addDocumentOperation(operation);            }            applier.apply();        }    }    @Test    public void insertDeleteAndReplaceVariousTokensShouldSucceed() throws IOException {        final String code = "static int main(CharSequence[] args) {}";        writeContentToTemporaryFile(code);        final List<DocumentOperation> documentOperations = new LinkedList<>();        documentOperations.add(new InsertDocumentOperation(0, 0, "public"));        documentOperations.add(new DeleteDocumentOperation(0, 0, 0, 6));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 7, 7 + "int".length(), "void"));        documentOperations.add(new InsertDocumentOperation(0, 16, "final "));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 16, 16 + "CharSequence".length(), "String"));        shuffleAndApplyOperations(documentOperations);        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public void main(final String[] args) {}", actualContent);        }    }    private void writeContentToTemporaryFile(final String content) throws IOException {        try (FileWriter writer = new FileWriter(temporaryFile)) {            writer.write(content);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html *//** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package net.sourceforge.pmd.stat;import static net.sourceforge.pmd.lang.rule.stat.StatisticalRule.MINIMUM_DESCRIPTOR;import static net.sourceforge.pmd.lang.rule.stat.StatisticalRule.SIGMA_DESCRIPTOR;import static net.sourceforge.pmd.lang.rule.stat.StatisticalRule.TOP_SCORE_DESCRIPTOR;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Random;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.stat.StatisticalRule;import junit.framework.AssertionFailedError;/** * This class tests the Statistical Rules in PMD. * * <p>The idea is, that we fill up 999 datapoints into the Stat Rule, and then * throw random parameters at it.</p> * * <p>The three parameters which are checked are: sigma - # Sigmas over the mean. * topscore - Only the top 5 or so items. minimum - Only things of score 10 or * better</p> * * <p>When more than one parameter is lumped together, then we expect the one which * would return the fewest to determine what gets sent back.</p> * * <p>So, we throw each collection of parameters, where each one is a different * order into the system. We check the results off of what the smallest value * should be.</p> * * <p>If you are going to work with StatisticalRule any, please bump the * "NUM_TESTS" number up to something like 128. That way you are more likely to * identify problems. It is set low now to make building and running tests * easier (when we aren't touching the file.)</p> * * <p>Note also, that when verifying the Sigma, I wasn't quite able to determine * how many results it would return (it would vary from -2 to 2 of what I * expected.) That is what the delta parameter on the verify method takes. If * you can figure it out exactly, (without stealing code from the StatRule) then * feel free to change it and tighten the deltas.</p> */public class StatisticalRuleTest {    private static final int POINTS = 100;    private DataPoint[] points = new DataPoint[POINTS];    private MockStatisticalRule ruleUnderTest = null;    // FIXME - why/when was this added. It was never set.    private String testName = "";    private Random random = new Random();    public static final double MAX_MINIMUM = POINTS;    public static final double NO_MINIMUM = -1.0;    public static final double MAX_SIGMA = 5.0;    public static final double NO_SIGMA = -1.0;    public static final int MIN_TOPSCORE = 0;    public static final int NO_TOPSCORE = -1;    public static final double MEAN = 49.5;    public static final double SIGMA = 29.0115;    public static final int NUM_TESTS = 1;    public static final double DELTA = 0.005;    @Before    public void setUp() {        ruleUnderTest = new MockStatisticalRule();        if (testName.endsWith("0")) {            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                DummyNode s = new DummyNode(1);                s.testingOnlySetBeginLine(i);                s.testingOnlySetBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                ruleUnderTest.addDataPoint(points[i]);            }        } else if (testName.endsWith("1")) {            for (int i = POINTS - 1; i >= 0; i--) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                DummyNode s = new DummyNode(1);                s.testingOnlySetBeginLine(i);                s.testingOnlySetBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                ruleUnderTest.addDataPoint(points[i]);            }        } else {            List<DataPoint> lPoints = new ArrayList<>();            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                DummyNode s = new DummyNode(1);                s.testingOnlySetBeginLine(i);                s.testingOnlySetBeginColumn(1);                s.testingOnlySetBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                lPoints.add(points[i]);            }            Collections.shuffle(lPoints);            for (int i = 0; i < POINTS; i++) {                ruleUnderTest.addDataPoint(lPoints.get(i));            }        }    }    /**     * This test verifies that the Stat rule creates a Metric, with the proper     * values.     */    @Test    public void testMetrics() {        Report report = makeReport(ruleUnderTest);        Iterator<Metric> metrics = report.metrics();        assertTrue(metrics.hasNext());        Metric m = metrics.next();        assertEquals("net.sourceforge.pmd.stat.MockStatisticalRule", m.getMetricName());        assertEquals(0.0, m.getLowValue(), 0.05);        assertEquals(POINTS - 1.0, m.getHighValue(), 0.05);        assertEquals(MEAN, m.getAverage(), 0.05);        assertEquals(SIGMA, m.getStandardDeviation(), 0.05);    }    /**     * This returns a Random value for Sigma which will return some values.     */    public double randomSigma() {        return random.nextDouble() * 1.0;    }    /**     * This returns a Random value for Sigma which value is greater than the     * parameter.     */    public double randomSigma(int minimum) {        double minSigma = ((POINTS - 1 - minimum) - MEAN) / SIGMA;        if ((minSigma <= 0) || (minSigma > 2)) {            return randomSigma();        }        return minSigma + (random.nextDouble() * (2 - minSigma));    }    /**     * This returns the expected number of results when the Sigma rating is the     * smallest.     */    public int expectedSigma(double sigma) {        long expectedMin = Math.round(MEAN + (sigma * SIGMA));        if (((POINTS - 1) - expectedMin) < 0) {            return 0;        }        return (POINTS - 1) - (int) expectedMin;    }    /**     * This generates a random minimum value for testing.     */    public double randomMinimum() {        return random.nextDouble() * (POINTS - 1);    }    /**     * This generates a random minimum value for which fewer results would be     * returned.     */    public double randomMinimum(int minimum) {        double diffTarget = 1.0 * (POINTS - 1 - minimum);        return (random.nextDouble() * minimum) + diffTarget;    }    /**     * This returns the expected number of reports.     *     * <p>If the Minimum comes in at 521.569 then we expect 522, 523, ... 999 will     * pass.</p>     */    public int expectedMinimum(double minimum) {        Double d = Double.valueOf(minimum);        return POINTS - 1 - d.intValue();    }    @Test    public void testExpectedMinimum() {        for (int i = 0; i < POINTS - 1; i++) {            assertEquals("Integer Min", POINTS - 1 - i, expectedMinimum(i * 1.0));            assertEquals("Double Min", POINTS - 1 - i, expectedMinimum((i * 1.0) + 0.5));        }    }    /**     * This returns a random value for Top Score.     */    public int randomTopScore() {        return random.nextInt(POINTS - 1);    }    /**     * This will return a random value for the Top Score which will return more     * than the minimum provided.     */    public int randomTopScore(double target) {        if (target < 0) {            return 0;        }        return random.nextInt(Double.valueOf(target).intValue());    }    /**     * This will return the expected number of results with the given Top Score.     */    public int expectedTopScore(int target) {        return target;    }    // Test Single Datapoint    @Test    public void testSingleDatapoint() {        StatisticalRule rule = new MockStatisticalRule();        DataPoint point = new DataPoint();        point.setScore(POINTS + 1.0);        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(POINTS + 1);        s.testingOnlySetBeginColumn(1);        point.setNode(s);        point.setMessage("SingleDataPoint");        rule.setProperty(MINIMUM_DESCRIPTOR, (double) POINTS);        rule.addDataPoint(point);        Report report = makeReport(rule);        assertEquals("Expecting only one result", 1, report.size());    }    // Okay, we have three properties we need to    // test in Combination:    // S = Sigma    // T = Top Score    // M = Minimum    //    // They are listed in decreasing order of what    // to expect.    //    // Thus testSM() should have the Sigma less than    // the minimum, so we expect the Minimum # of results.    //    @Test    public void testS() {        verifyResults(MAX_SIGMA, NO_MINIMUM, NO_TOPSCORE, 0, 2);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            verifyResults(sigma, -1.0, -1, expectedSigma(sigma), 2);        }    }    @Test    public void testS1() {        testS();    }    @Test    public void testS2() {        testS();    }    @Test    public void testS3() {        testS();    }    @Test    public void testS4() {        testS();    }    @Test    public void testS5() {        testS();    }    @Test    public void testT() {        verifyResults(NO_SIGMA, NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            verifyResults(-1.0, -1.0, topScore, expectedTopScore(topScore), 0);        }    }    @Test    public void testT1() {        testT();    }    @Test    public void testT2() {        testT();    }    @Test    public void testT3() {        testT();    }    @Test    public void testT4() {        testT();    }    @Test    public void testT5() {        testT();    }    @Test    public void testM() {        verifyResults(NO_SIGMA, MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            verifyResults(-1.0, minimum, -1, expectedMinimum(minimum), 0);        }    }    @Test    public void testM1() {        testM();    }    @Test    public void testM2() {        testM();    }    @Test    public void testM3() {        testM();    }    @Test    public void testM4() {        testM();    }    @Test    public void testM5() {        testM();    }    @Test    public void testST() {        verifyResults(randomSigma(), NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            verifyResults(sigma, NO_MINIMUM, topScore, expectedTopScore(topScore), 0);        }    }    @Test    public void testST1() {        testST();    }    @Test    public void testST2() {        testST();    }    @Test    public void testST3() {        testST();    }    @Test    public void testST4() {        testST();    }    @Test    public void testST5() {        testST();    }    @Test    public void testTS() {        verifyResults(MAX_SIGMA, NO_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            verifyResults(sigma, -1.0, topScore, expectedSigma(sigma), 2);        }    }    @Test    public void testTS1() {        testTS();    }    @Test    public void testTS2() {        testTS();    }    @Test    public void testTS3() {        testTS();    }    @Test    public void testTS4() {        testTS();    }    @Test    public void testTS5() {        testTS();    }    @Test    public void testSM() {        verifyResults(randomSigma(), MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, -1, expectedMinimum(minimum), 0);        }    }    @Test    public void testSM1() {        testSM();    }    @Test    public void testSM2() {        testSM();    }    @Test    public void testSM3() {        testSM();    }    @Test    public void testSM4() {        testSM();    }    @Test    public void testSM5() {        testSM();    }    @Test    public void testMS() {        verifyResults(MAX_SIGMA, randomMinimum(), NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, -1, expectedSigma(sigma), 2);        }    }    @Test    public void testMS1() {        testMS();    }    @Test    public void testMS2() {        testMS();    }    @Test    public void testMS3() {        testMS();    }    @Test    public void testMS4() {        testMS();    }    @Test    public void testMS5() {        testMS();    }    @Test    public void testTM() {        verifyResults(NO_SIGMA, MAX_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(NO_SIGMA, minimum, topScore, expectedMinimum(minimum), 0);        }    }    @Test    public void testTM1() {        testTM();    }    @Test    public void testTM2() {        testTM();    }    @Test    public void testTM3() {        testTM();    }    @Test    public void testTM4() {        testTM();    }    @Test    public void testTM5() {        testTM();    }    @Test    public void testMT() {        verifyResults(NO_SIGMA, randomMinimum(), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(NO_SIGMA, minimum, topScore, expectedTopScore(topScore), 0);        }    }    @Test    public void testMT1() {        testMT();    }    @Test    public void testMT2() {        testMT();    }    @Test    public void testMT3() {        testMT();    }    @Test    public void testMT4() {        testMT();    }    @Test    public void testMT5() {        testMT();    }    @Test    public void testSTM() {        double sigma = randomSigma();        verifyResults(sigma, MAX_MINIMUM, randomTopScore(expectedSigma(sigma)), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    @Test    public void testSTM1() {        testSTM();    }    @Test    public void testSTM2() {        testSTM();    }    @Test    public void testSTM3() {        testSTM();    }    @Test    public void testSTM4() {        testSTM();    }    @Test    public void testSTM5() {        testSTM();    }    @Test    public void testSMT() {        double sigma = randomSigma();        verifyResults(sigma, randomMinimum(expectedSigma(sigma)), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedTopScore(topScore), 0);        }    }    @Test    public void testSMT1() {        testSMT();    }    @Test    public void testSMT2() {        testSMT();    }    @Test    public void testSMT3() {        testSMT();    }    @Test    public void testSMT4() {        testSMT();    }    @Test    public void testSMT5() {        testSMT();    }    @Test    // because of random failures during continuous integration,    // tests are disabled in regress mode until somebody figures out    // what the tests are supposed to measure and why they sometime fail    @Ignore("random failures during continuous integration")    public void testTSM() {        int topScore = randomTopScore();        verifyResults(randomSigma(expectedTopScore(topScore)), MAX_MINIMUM, topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    @Test    @Ignore("random failures during continuous integration")    public void testTSM1() {        testTSM();    }    @Test    @Ignore("random failures during continuous integration")    public void testTSM2() {        testTSM();    }    @Test    @Ignore("random failures during continuous integration")    public void testTSM3() {        testTSM();    }    @Test    @Ignore("random failures during continuous integration")    public void testTSM4() {        testTSM();    }    @Test    @Ignore("random failures during continuous integration")    public void testTSM5() {        testTSM();    }    @Test    public void testTMS() {        int topScore = randomTopScore();        verifyResults(MAX_SIGMA, randomMinimum(expectedTopScore(topScore)), topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedSigma(sigma), 2);        }    }    @Test    public void testTMS1() {        testTMS();    }    @Test    public void testTMS2() {        testTMS();    }    @Test    public void testTMS3() {        testTMS();    }    @Test    public void testTMS4() {        testTMS();    }    @Test    public void testTMS5() {        testTMS();    }    /**     * Verifies what happens when you pass these parameters into the thing.     * DELTA is the amount of error allowed. Usually DELTA is only used for     * Sigma, as we really can't calculate it exactly.     */    public void verifyResults(double sigma, double minimum, int topScore, int expected, int delta) {        try {            setUp();            if (sigma >= 0) {                ruleUnderTest.setProperty(SIGMA_DESCRIPTOR, sigma);            }            if (minimum >= 0) {                ruleUnderTest.setProperty(MINIMUM_DESCRIPTOR, minimum);            }            if (topScore >= 0) {                ruleUnderTest.setProperty(TOP_SCORE_DESCRIPTOR, topScore);            }            Report report = makeReport(ruleUnderTest);            if (delta == 0) {                assertEquals(                        "Unexpected number of results: sigma= " + Double.toString(sigma) + " min= "                                + Double.toString(minimum) + " topscore= " + Integer.toString(topScore),                        expected, report.size());            } else {                String assertStr = "Unexpected number of results: sigma= " + Double.toString(sigma) + " min= "                        + Double.toString(minimum) + " topscore= " + Integer.toString(topScore) + " expected= "                        + Integer.toString(expected) + " +/- " + Integer.toString(delta) + " actual-result= "                        + report.size();                assertTrue(assertStr, report.size() >= (expected - delta));                assertTrue(assertStr, report.size() <= (expected + delta));            }        } catch (AssertionFailedError afe) {            System.err.println("******** " + testName + " ***********");            if (sigma != NO_SIGMA) {                System.err.println(                        "SIGMA: " + Double.toString(sigma) + " EXPECT: " + Integer.toString(expectedSigma(sigma)));            }            if (minimum != NO_MINIMUM) {                System.err.println(                        "MIN: " + Double.toString(minimum) + " EXPECT: " + Integer.toString(expectedMinimum(minimum)));            }            if (topScore != NO_TOPSCORE) {                System.err.println("TOP: " + Integer.toString(topScore) + " EXPECT: "                        + Integer.toString(expectedTopScore(topScore)));            }            throw afe;        }    }    public Report makeReport(Rule rule) {        List<Node> list = new ArrayList<>();        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFile(new File(testName));        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        rule.apply(list, ctx);        return report;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html *//** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package net.sourceforge.pmd.stat;import static org.junit.Assert.assertEquals;import java.util.Random;import org.junit.Test;/** * @author David Dixon-Peugh */public class MetricTest {    private String testName = "";    private Random random = new Random();    @Test    public void testGetMetricName() {        Metric metric = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(testName, metric.getMetricName());    }    @Test    public void testGetCount() {        int count = random.nextInt();        Metric metric = new Metric(testName, count, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(count, metric.getCount());    }    @Test    public void testGetTotal() {        double total = random.nextDouble();        Metric metric = new Metric(testName, 0, total, 0.0, 0.0, 0.0, 0.0);        assertEquals(total, metric.getTotal(), 0.05);    }    @Test    public void testGetLowValue() {        double low = random.nextDouble();        Metric metric = new Metric(testName, 0, 0.0, low, 0.0, 0.0, 0.0);        assertEquals(low, metric.getLowValue(), 0.05);    }    @Test    public void testGetHighValue() {        double high = random.nextDouble();        Metric metric = new Metric(testName, 0, 0.0, 0.0, high, 0.0, 0.0);        assertEquals(high, metric.getHighValue(), 0.05);    }    @Test    public void testGetAverage() {        double mean = random.nextDouble();        Metric metric = new Metric(testName, 0, 0.0, 0.0, 0.0, mean, 0.0);        assertEquals(mean, metric.getAverage(), 0.05);    }    @Test    public void testGetStandardDeviation() {        double stdev = random.nextDouble();        Metric metric = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, stdev);        assertEquals(stdev, metric.getStandardDeviation(), 0.05);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache.internal;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.util.zip.Adler32;import java.util.zip.Checksum;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import java.util.zip.ZipOutputStream;import org.junit.Assert;import org.junit.Test;public class ZipFileFingerprinterTest extends AbstractClasspathEntryFingerprinterTest {    @Test    public void zipEntryMetadataDoesNotAffectFingerprint() throws IOException {        final File file = createValidNonEmptyFile();        final long baselineFingerprint = getBaseLineFingerprint(file);        final long originalFileSize = file.length();        // Change zip entry's metadata        try (ZipFile zip = new ZipFile(file)) {            final ZipEntry zipEntry = zip.entries().nextElement();            zipEntry.setComment("some comment");            zipEntry.setTime(System.currentTimeMillis() + 1000);            overwriteZipFileContents(file, zipEntry);        }        Assert.assertEquals(baselineFingerprint, updateFingerprint(file));        Assert.assertNotEquals(originalFileSize, file.length());    }    @Override    protected ClasspathEntryFingerprinter newFingerPrinter() {        return new ZipFileFingerprinter();    }    @Override    protected String[] getValidFileExtensions() {        return new String[] { "zip", "jar" };    }    @Override    protected String[] getInvalidFileExtensions() {        return new String[] { "xml" };    }    @Override    protected File createValidNonEmptyFile() throws IOException {        final File zipFile = tempFolder.newFile("foo.jar");        overwriteZipFileContents(zipFile, new ZipEntry("lib/Foo.class"));        return zipFile;    }    private void overwriteZipFileContents(final File zipFile, final ZipEntry... zipEntries) throws IOException {        try (ZipOutputStream zipOS = new ZipOutputStream(Files.newOutputStream(zipFile.toPath()))) {            for (final ZipEntry zipEntry : zipEntries) {                zipOS.putNextEntry(zipEntry);                zipOS.write("content of zip entry".getBytes(StandardCharsets.UTF_8));                zipOS.closeEntry();            }        }    }    private long getBaseLineFingerprint(final File file) throws MalformedURLException, IOException {        final Checksum checksum = new Adler32();        fingerprinter.fingerprint(file.toURI().toURL(), checksum);        return checksum.getValue();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache.internal;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import com.google.common.io.Files;public class RawFileFingerprinterTest extends AbstractClasspathEntryFingerprinterTest {    @Override    protected ClasspathEntryFingerprinter newFingerPrinter() {        return new RawFileFingerprinter();    }    @Override    protected String[] getValidFileExtensions() {        return new String[] { "class" };    }    @Override    protected String[] getInvalidFileExtensions() {        return new String[] { "xml" };    }    @Override    protected File createValidNonEmptyFile() throws IOException {        final File file = tempFolder.newFile("Foo.class");        Files.write("some content", file, StandardCharsets.UTF_8);        return file;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache.internal;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.util.zip.Adler32;import java.util.zip.Checksum;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import org.junit.runner.RunWith;import junitparams.JUnitParamsRunner;import junitparams.Parameters;@RunWith(JUnitParamsRunner.class)public abstract class AbstractClasspathEntryFingerprinterTest {    @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();    protected ClasspathEntryFingerprinter fingerprinter = newFingerPrinter();    protected Checksum checksum = new Adler32();    @Before    public void setUp() {        checksum.reset();    }    protected abstract ClasspathEntryFingerprinter newFingerPrinter();    protected abstract String[] getValidFileExtensions();    protected abstract String[] getInvalidFileExtensions();    protected abstract File createValidNonEmptyFile() throws IOException;    @Test    public void appliesToNullIsSafe() {        fingerprinter.appliesTo(null);    }    @Parameters(method = "getValidFileExtensions")    @Test    public void appliesToValidFile(final String extension) {        Assert.assertTrue(fingerprinter.appliesTo(extension));    }    @Parameters(method = "getInvalidFileExtensions")    @Test    public void doesNotApplyToInvalidFile(final String extension) {        Assert.assertFalse(fingerprinter.appliesTo(extension));    }    @Test    public void fingerprintNonExistingFile() throws MalformedURLException, IOException {        final long prevValue = checksum.getValue();        fingerprinter.fingerprint(new File("non-existing").toURI().toURL(), checksum);        Assert.assertEquals(prevValue, checksum.getValue());    }    @Test    public void fingerprintExistingValidFile() throws IOException {        final long prevValue = checksum.getValue();        final File file = createValidNonEmptyFile();        Assert.assertNotEquals(prevValue, updateFingerprint(file));    }    protected long updateFingerprint(final File file) throws MalformedURLException, IOException {        fingerprinter.fingerprint(file.toURI().toURL(), checksum);        return checksum.getValue();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.util.Collections;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TemporaryFolder;import org.mockito.Mockito;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.Language;public class FileAnalysisCacheTest {    @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();    @Rule    public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    private File unexistingCacheFile;    private File newCacheFile;    private File emptyCacheFile;    private File sourceFile;    @Before    public void setUp() throws IOException {        unexistingCacheFile = new File(tempFolder.getRoot(), "non-existing-file.cache");        newCacheFile = new File(tempFolder.getRoot(), "pmd-analysis.cache");        emptyCacheFile = tempFolder.newFile();        sourceFile = tempFolder.newFile("Source.java");    }    @Test    public void testLoadFromNonExistingFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        assertNotNull("Cache creation from non existing file failed.", cache);    }    @Test    public void testLoadFromEmptyFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        assertNotNull("Cache creation from empty file failed.", cache);    }    @Test    public void testLoadFromDirectoryShouldntThrow() throws IOException {        new FileAnalysisCache(tempFolder.getRoot());    }    @Test    public void testLoadFromUnreadableFileShouldntThrow() throws IOException {        emptyCacheFile.setReadable(false);        new FileAnalysisCache(emptyCacheFile);    }    @Test    public void testStoreCreatesFile() {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        cache.persist();        assertTrue("Cache file doesn't exist after store", unexistingCacheFile.exists());    }    @Test    public void testStoreOnUnwritableFileShouldntThrow() {        emptyCacheFile.setWritable(false);        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        cache.persist();    }    @Test    public void testStorePersistsFilesWithViolations() {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        cache.checkValidity(mock(RuleSets.class), mock(ClassLoader.class));        cache.isUpToDate(sourceFile);        final RuleViolation rv = mock(RuleViolation.class);        when(rv.getFilename()).thenReturn(sourceFile.getPath());        final net.sourceforge.pmd.Rule rule = mock(net.sourceforge.pmd.Rule.class, Mockito.RETURNS_SMART_NULLS);        when(rule.getLanguage()).thenReturn(mock(Language.class));        when(rv.getRule()).thenReturn(rule);        cache.ruleViolationAdded(rv);        cache.persist();        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(mock(RuleSets.class), mock(ClassLoader.class));        assertTrue("Cache believes unmodified file with violations is not up to date",                reloadedCache.isUpToDate(sourceFile));        final List<RuleViolation> cachedViolations = reloadedCache.getCachedViolations(sourceFile);        assertEquals("Cached rule violations count mismatch", 1, cachedViolations.size());    }    @Test    public void testCacheValidityWithNoChanges() {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date without ruleset / classpath changes",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testCacheValidityWithIrrelevantChanges() throws IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] {});        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final File classpathFile = tempFolder.newFile("foo.xml");        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date without ruleset / classpath changes",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testRulesetChangeInvalidatesCache() {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(rs.getChecksum()).thenReturn(1L);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes unmodified file is up to date after ruleset changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathNonExistingAuxclasspathEntriesIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { new File(tempFolder.getRoot(), "non-existing-dir").toURI().toURL(), });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache analysisCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] {});        analysisCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date after non-existing auxclasspath entry removed",                analysisCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathChangeWithoutDFAorTypeResolutionDoesNotInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] { tempFolder.newFile().toURI().toURL(), });        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date after auxclasspath changed when no rule cares",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        final File classpathFile = tempFolder.newFile("foo.class");        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        // Make sure the auxclasspath file is not empty        Files.write(classpathFile.toPath(), "some text".getBytes());        final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.isDfa()).thenReturn(true);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes unmodified file is up to date after auxclasspath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathJarContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        final File classpathFile = tempFolder.newFile("foo.class");        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.isDfa()).thenReturn(true);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Edit the auxclasspath referenced file        Files.write(classpathFile.toPath(), "some text".getBytes());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when a auxclasspath file changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testClasspathNonExistingEntryIsIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator                + tempFolder.getRoot().getAbsolutePath() + File.separator + "non-existing-dir");        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        try {            reloadedCache.checkValidity(rs, cl);        } catch (final Exception e) {            fail("Validity check failed when classpath includes non-existing directories");        }    }    @Test    public void testClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        final File classpathFile = tempFolder.newFile("foo.class");        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Edit the classpath referenced file        Files.write(classpathFile.toPath(), "some text".getBytes());        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testClasspathContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        final File classpathFile = tempFolder.newFile("foo.class");        // Add a file to classpath        Files.write(classpathFile.toPath(), "some text".getBytes());        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Change the file's contents        Files.write(classpathFile.toPath(), "some other text".getBytes());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when a classpath file changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testWildcardClasspath() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Prepare two class files        createZipFile("mylib1.jar");        createZipFile("mylib2.jar");        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.getRoot().getAbsolutePath() + "/*");        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testWildcardClasspathContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        // Prepare two jar files        final File classpathJar1 = createZipFile("mylib1.jar");        createZipFile("mylib2.jar");        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.getRoot().getAbsolutePath() + "/*");        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Change one file's contents (ie: adding more entries)        classpathJar1.delete();        createZipFile(classpathJar1.getName(), 2);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testUnknownFileIsNotUpToDate() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse("Cache believes an unknown file is up to date",                cache.isUpToDate(sourceFile));    }    @Test    public void testFileIsUpToDate() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        cache.checkValidity(mock(RuleSets.class), mock(ClassLoader.class));        assertTrue("Cache believes a known, unchanged file is not up to date",                cache.isUpToDate(sourceFile));    }    @Test    public void testFileIsNotUpToDateWhenEdited() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);        // Edit the file        Files.write(sourceFile.toPath(), "some text".getBytes());        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse("Cache believes a known, changed file is up to date",                cache.isUpToDate(sourceFile));    }    private void setupCacheWithFiles(final File cacheFile, final RuleSets ruleSets,            final ClassLoader classLoader, final File... files) {        // Setup a cache file with an entry for an empty Source.java with no violations        final FileAnalysisCache cache = new FileAnalysisCache(cacheFile);        cache.checkValidity(ruleSets, classLoader);        for (final File f : files) {            cache.isUpToDate(f);        }        cache.persist();    }    private File createZipFile(String fileName) throws IOException {        return createZipFile(fileName, 1);    }    private File createZipFile(String fileName, int numEntries) throws IOException {        final File zipFile = tempFolder.newFile(fileName);        try (ZipOutputStream zipOS = new ZipOutputStream(Files.newOutputStream(zipFile.toPath()))) {            for (int i = 0; i < numEntries; i++) {                zipOS.putNextEntry(new ZipEntry("lib/foo" + i + ".class"));                zipOS.write(("content of " + fileName + " entry " + i).getBytes(StandardCharsets.UTF_8));                zipOS.closeEntry();            }        }        return zipFile;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.dfa.report;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import org.junit.Test;import net.sourceforge.pmd.RuleViolation;/** * @author Philip Graf */public final class ViolationNodeTest {    /**     * Verifies that two violations nodes with equal     * {@code filename, beginLine, endLine, beginColumn, endColumn} and     * {@code variableName} are equal.     */    @Test    public void testEqualsNodeWithTwoEqualViolations() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        assertTrue("Two equal violations should result in equal nodes", node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code filename} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentFilename() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Bar.java", 1, 1, 5, 15, "");        assertFalse("Two violations with different filename should result in not equal nodes", node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code beginLine} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentBeginLine() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 2, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 2, 2, 5, 15, "");        assertFalse("Two violations with different beginLine should result in not equal nodes",                node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code endLine} are not     * equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentEndLine() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 2, 5, 15, "");        assertFalse("Two violations with different endLine should result in not equal nodes", node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code beginColumn} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentBeginColumn() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 7, 15, "");        assertFalse("Two violations with different beginColumn should result in not equal nodes",                node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code endColumn} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentEndColumn() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 5, 17, "");        assertFalse("Two violations with different end column should result in not equal nodes",                node1.equalsNode(node2));    }    /**     * Verifies that two violations with different {@code variableName} are not     * equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentVariableName() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "a");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 5, 15, "b");        assertFalse("Two violations with different variableName should result in not equal nodes",                node1.equalsNode(node2));    }    private ViolationNode createViolationNode(final String filename, final int beginLine, final int endLine,            final int beginColumn, final int endColumn, final String variableName) {        final RuleViolation violation = mock(RuleViolation.class);        when(violation.getFilename()).thenReturn(filename);        when(violation.getBeginLine()).thenReturn(beginLine);        when(violation.getEndLine()).thenReturn(endLine);        when(violation.getBeginColumn()).thenReturn(beginColumn);        when(violation.getEndColumn()).thenReturn(endColumn);        when(violation.getVariableName()).thenReturn(variableName);        return new ViolationNode(violation);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.symboltable;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.util.SearchFunction;public class ApplierTest {    private static class MyFunction implements SearchFunction<Object> {        private int numCallbacks = 0;        private final int maxCallbacks;        MyFunction(int maxCallbacks) {            this.maxCallbacks = maxCallbacks;        }        @Override        public boolean applyTo(Object o) {            this.numCallbacks++;            return numCallbacks < maxCallbacks;        }        public int getNumCallbacks() {            return this.numCallbacks;        }    }    @Test    public void testSimple() {        MyFunction f = new MyFunction(Integer.MAX_VALUE);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(l.size(), f.getNumCallbacks());    }    @Test    public void testLimit() {        MyFunction f = new MyFunction(2);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(2, f.getNumCallbacks());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ApplierTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.saxon;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;import net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;public class ElementNodeTest {    @Test    public void testCompareOrder() {        DummyNode node = new DummyNode(1, false, "dummy");        DummyNode foo1 = new DummyNode(2, false, "foo");        foo1.testingOnlySetBeginLine(1);        DummyNode foo2 = new DummyNode(2, false, "foo");        foo2.testingOnlySetBeginLine(2);        node.jjtAddChild(foo1, 0);        node.jjtAddChild(foo2, 1);        DocumentNode document = new DocumentNode(node);        ElementNode elementFoo1 = document.nodeToElementNode.get(foo1);        ElementNode elementFoo2 = document.nodeToElementNode.get(foo2);        Assert.assertFalse(elementFoo1.isSameNodeInfo(elementFoo2));        Assert.assertFalse(elementFoo2.isSameNodeInfo(elementFoo1));        Assert.assertTrue(elementFoo1.compareOrder(elementFoo2) < 0);        Assert.assertTrue(elementFoo2.compareOrder(elementFoo1) > 0);        Assert.assertEquals(0, elementFoo1.compareOrder(elementFoo1));    }    @Test    public void testCompareOrderSamePosition() {        DummyNode node = new DummyNode(1, false, "dummy");        DummyNode foo1 = new DummyNode(2, false, "foo");        foo1.testingOnlySetBeginLine(1);        foo1.testingOnlySetBeginColumn(1);        DummyNode foo2 = new DummyNode(2, false, "foo");        foo2.testingOnlySetBeginLine(1);        foo2.testingOnlySetBeginColumn(1);        node.jjtAddChild(foo1, 0);        node.jjtAddChild(foo2, 1);        DocumentNode document = new DocumentNode(node);        ElementNode elementFoo1 = document.nodeToElementNode.get(foo1);        ElementNode elementFoo2 = document.nodeToElementNode.get(foo2);        Assert.assertFalse(elementFoo1.isSameNodeInfo(elementFoo2));        Assert.assertFalse(elementFoo2.isSameNodeInfo(elementFoo1));        Assert.assertTrue(elementFoo1.compareOrder(elementFoo2) < 0);        Assert.assertTrue(elementFoo2.compareOrder(elementFoo1) > 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.hamcrest.CoreMatchers;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNodeWithListAndEnum;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sf.saxon.expr.Expression;public class SaxonXPathRuleQueryTest {    @Rule    public final ExpectedException expected = ExpectedException.none();    @Test    public void testListAttribute() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        assertQuery(1, "//dummyNode[@List = \"A\"]", dummy);        assertQuery(1, "//dummyNode[@List = \"B\"]", dummy);        assertQuery(0, "//dummyNode[@List = \"C\"]", dummy);        assertQuery(1, "//dummyNode[@Enum = \"FOO\"]", dummy);        assertQuery(0, "//dummyNode[@Enum = \"BAR\"]", dummy);        assertQuery(1, "//dummyNode[@EnumList = \"FOO\"]", dummy);        assertQuery(1, "//dummyNode[@EnumList = \"BAR\"]", dummy);        assertQuery(1, "//dummyNode[@EnumList = (\"FOO\", \"BAR\")]", dummy);        assertQuery(0, "//dummyNode[@EmptyList = (\"A\")]", dummy);    }    @Test    public void testInvalidReturn() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        expected.expect(RuntimeException.class);        expected.expectMessage(CoreMatchers.containsString("XPath rule expression returned a non-node"));        expected.expectMessage(CoreMatchers.containsString("Int64Value"));        createQuery("1+2").evaluate(dummy, new RuleContext());    }    @Test    public void testRootExpression() {        DummyNode dummy = new DummyNode(); // todo in pmd 7 this should be a RootNode        List<Node> result = assertQuery(1, "/", dummy);        Assert.assertEquals(dummy, result.get(0));    }    @Test    public void testRootExpressionIsADocumentNode() {        DummyNode dummy = new DummyNode(); // todo in pmd 7 this should be a RootNode        List<Node> result = assertQuery(1, "(/)[self::document-node()]", dummy);        Assert.assertEquals(dummy, result.get(0));    }    @Test    public void testRootExpressionWithName() {        DummyNode dummy = new DummyNode(0, false, "DummyNodeA"); // todo in pmd 7 this should be a RootNode        List<Node> result = assertQuery(1, "(/)[self::document-node(element(DummyNodeA))]", dummy);        Assert.assertEquals(dummy, result.get(0));        assertQuery(0, "(/)[self::document-node(element(DummyNodeX))]", dummy);    }    @Test    public void ruleChainVisits() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Image='baz']/foo | //bar[@Public = 'true'] | //dummyNode[@Public = false()] | //dummyNode");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(2, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertTrue(ruleChainVisits.contains("bar"));        Assert.assertEquals(3, query.nodeNameToXPaths.size());        assertExpression("((self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Image, xs:anyAtomicType)), ($qq:qq106374177 singleton eq \"baz\"))])/child::element(foo, xs:anyType))", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("(self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq609962972 singleton eq false()))])", query.nodeNameToXPaths.get("dummyNode").get(1));        assertExpression("self::node()", query.nodeNameToXPaths.get("dummyNode").get(2));        assertExpression("(self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq232307208 singleton eq \"true\"))])", query.nodeNameToXPaths.get("bar").get(0));        assertExpression("(((DocumentSorter(((((/)/descendant::element(dummyNode, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Image, xs:anyAtomicType)), ($qq:qq000 singleton eq \"baz\"))])/child::element(foo, xs:anyType))) | (((/)/descendant::element(bar, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq000 singleton eq \"true\"))])) | (((/)/descendant::element(dummyNode, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq000 singleton eq false()))])) | ((/)/descendant::element(dummyNode, xs:anyType)))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    @Test    public void ruleChainVisitsMultipleFilters() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Test1 = false()][@Test2 = true()]");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("((self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Test2, xs:anyAtomicType)), ($qq:qq1741979653 singleton eq true()))])[QuantifiedExpression(Atomizer(attribute::attribute(Test1, xs:anyAtomicType)), ($qq:qq1529060733 singleton eq false()))])", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("((((/)/descendant::element(dummyNode, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Test2, xs:anyAtomicType)), ($qq:qq1741979653 singleton eq true()))])[QuantifiedExpression(Atomizer(attribute::attribute(Test1, xs:anyAtomicType)), ($qq:qq1529060733 singleton eq false()))])", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    @Test    public void ruleChainVisitsCustomFunctions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[pmd-dummy:typeIs(@Image)]");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(self::node()[pmd-dummy:typeIs(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer(attribute::attribute(Image, xs:anyAtomicType))))))])", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("DocumentSorter((((/)/descendant-or-self::node())/(child::element(dummyNode, xs:anyType)[pmd-dummy:typeIs(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer(attribute::attribute(Image, xs:anyAtomicType))))))])))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    /**     * If a query contains another unbounded path expression other than the first one, it must be     * excluded from rule chain execution. Saxon itself optimizes this quite good already.     */    @Test    public void ruleChainVisitsUnboundedPathExpressions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[//ClassOrInterfaceType]");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(0, ruleChainVisits.size());        Assert.assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("LetExpression(LazyExpression(((/)/descendant::element(ClassOrInterfaceType, xs:anyType))), (((/)/descendant::element(dummyNode, xs:anyType))[$zz:zz771775563]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));        // second sample, more complex        query = createQuery("//dummyNode[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType]]");        ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(0, ruleChainVisits.size());        Assert.assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("LetExpression(LazyExpression(((/)/descendant::element(ClassOrInterfaceType, xs:anyType))), (((/)/descendant::element(dummyNode, xs:anyType))[(ancestor::element(ClassOrInterfaceDeclaration, xs:anyType)[$zz:zz106374177])]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));        // third example, with boolean expr        query = createQuery("//dummyNode[//ClassOrInterfaceType or //OtherNode]");        ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(0, ruleChainVisits.size());        Assert.assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("LetExpression(LazyExpression((((/)/descendant::element(ClassOrInterfaceType, xs:anyType)) or ((/)/descendant::element(OtherNode, xs:anyType)))), (((/)/descendant::element(dummyNode, xs:anyType))[$zz:zz1364913072]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    @Test    public void ruleChainVisitsNested() {        SaxonXPathRuleQuery query = createQuery("//dummyNode/foo/*/bar[@Test = 'false']");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("((((self::node()/child::element(foo, xs:anyType))/child::element())/child::element(bar, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Test, xs:anyAtomicType)), ($qq:qq166794956 singleton eq \"false\"))])", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("DocumentSorter(((((((/)/descendant::element(dummyNode, xs:anyType))/child::element(foo, xs:anyType))/child::element())/child::element(bar, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Test, xs:anyAtomicType)), ($qq:qq166794956 singleton eq \"false\"))]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    @Test    public void ruleChainVisitsNested2() {        SaxonXPathRuleQuery query = createQuery("//dummyNode/foo[@Baz = 'a']/*/bar[@Test = 'false']");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(((((self::node()/child::element(foo, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Baz, xs:anyAtomicType)), ($qq:qq306612792 singleton eq \"a\"))])/child::element())/child::element(bar, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Test, xs:anyAtomicType)), ($qq:qq1803669141 singleton eq \"false\"))])", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("DocumentSorter((((((((/)/descendant::element(dummyNode, xs:anyType))/child::element(foo, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Baz, xs:anyAtomicType)), ($qq:qq306612792 singleton eq \"a\"))])/child::element())/child::element(bar, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Test, xs:anyAtomicType)), ($qq:qq1803669141 singleton eq \"false\"))]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    @Test    public void ruleChainVisitWithVariable() {        PropertyDescriptor<String> testClassPattern = PropertyFactory.stringProperty("testClassPattern").desc("test").defaultValue("a").build();        SaxonXPathRuleQuery query = createQuery("//dummyNode[matches(@SimpleName, $testClassPattern)]", testClassPattern);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("LetExpression(LazyExpression(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer($testClassPattern))))), (self::node()[matches(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer(attribute::attribute(SimpleName, xs:anyAtomicType))))), $zz:zz952562199)]))", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("LetExpression(LazyExpression(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer($testClassPattern))))), (((/)/descendant::element(dummyNode, xs:anyType))[matches(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer(attribute::attribute(SimpleName, xs:anyAtomicType))))), $zz:zz952562199)]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    @Test    public void ruleChainVisitWithVariable2() {        PropertyDescriptor<String> testClassPattern = PropertyFactory.stringProperty("testClassPattern").desc("test").defaultValue("a").build();        SaxonXPathRuleQuery query = createQuery("//dummyNode[matches(@SimpleName, $testClassPattern)]/foo", testClassPattern);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(LetExpression(LazyExpression(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer($testClassPattern))))), (self::node()[matches(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer(attribute::attribute(SimpleName, xs:anyAtomicType))))), $zz:zz952562199)]))/child::element(foo, xs:anyType))", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("DocumentSorter((LetExpression(LazyExpression(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer($testClassPattern))))), (((/)/descendant::element(dummyNode, xs:anyType))[matches(CardinalityChecker(ItemChecker(UntypedAtomicConverter(Atomizer(attribute::attribute(SimpleName, xs:anyAtomicType))))), $zz:zz952562199)]))/child::element(foo, xs:anyType)))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    private static void assertExpression(String expected, Expression actual) {        Assert.assertEquals(normalizeExprDump(expected),                            normalizeExprDump(actual.toString()));        //Assert.assertEquals(expected, actual);    }    private static String normalizeExprDump(String dump) {        return dump.replaceAll("\\$qq:qq-?\\d+", "\\$qq:qq000")                   .replaceAll("\\$zz:zz-?\\d+", "\\$zz:zz000");    }    @Test    public void ruleChainVisitsCompatibilityMode() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Image='baz']/foo | //bar[@Public = 'true'] | //dummyNode[@Public = 'false']");        query.setVersion(XPathRuleQuery.XPATH_1_0_COMPATIBILITY);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(2, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertTrue(ruleChainVisits.contains("bar"));        Assert.assertEquals(3, query.nodeNameToXPaths.size());        assertExpression("((self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Image, xs:anyAtomicType)), ($qq:qq6519275 singleton eq \"baz\"))])/child::element(foo, xs:anyType))", query.nodeNameToXPaths.get("dummyNode").get(0));        assertExpression("(self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq1529060733 singleton eq \"false\"))])", query.nodeNameToXPaths.get("dummyNode").get(1));        assertExpression("(self::node()[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq1484171695 singleton eq \"true\"))])", query.nodeNameToXPaths.get("bar").get(0));        assertExpression("((DocumentSorter(((((/)/descendant::element(dummyNode, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Image, xs:anyAtomicType)), ($qq:qq692331943 singleton eq \"baz\"))])/child::element(foo, xs:anyType))) | (((/)/descendant::element(bar, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq2127036371 singleton eq \"true\"))])) | (((/)/descendant::element(dummyNode, xs:anyType))[QuantifiedExpression(Atomizer(attribute::attribute(Public, xs:anyAtomicType)), ($qq:qq1529060733 singleton eq \"false\"))]))", query.nodeNameToXPaths.get(SaxonXPathRuleQuery.AST_ROOT).get(0));    }    private static List<Node> assertQuery(int resultSize, String xpath, Node node) {        SaxonXPathRuleQuery query = createQuery(xpath);        List<Node> result = query.evaluate(node, new RuleContext());        Assert.assertEquals(resultSize, result.size());        return result;    }    private static SaxonXPathRuleQuery createQuery(String xpath, PropertyDescriptor<?> ...descriptors) {        SaxonXPathRuleQuery query = new SaxonXPathRuleQuery();        query.setVersion(XPathRuleQuery.XPATH_2_0);        if (descriptors != null) {            Map<PropertyDescriptor<?>, Object> props = new HashMap<PropertyDescriptor<?>, Object>();            for (PropertyDescriptor<?> prop : descriptors) {                props.put(prop, prop.defaultValue());            }            query.setProperties(props);        } else {            query.setProperties(Collections.<PropertyDescriptor<?>, Object>emptyMap());        }        query.setXPath(xpath);        return query;    }    @Test    public void ruleChainWithUnions() {        SaxonXPathRuleQuery query = createQuery("(//ForStatement | //WhileStatement | //DoStatement)//AssignmentOperator");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(0, ruleChainVisits.size());    }    @Test    public void ruleChainWithUnionsAndFilter() {        SaxonXPathRuleQuery query = createQuery("(//ForStatement | //WhileStatement | //DoStatement)//AssignmentOperator[@Image='foo']");        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(0, ruleChainVisits.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath;import java.util.Collections;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNodeWithListAndEnum;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.properties.PropertyDescriptor;public class JaxenXPathRuleQueryTest {    @Test    public void testListAttribute() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        assertQuery(1, "//dummyNode[@SimpleAtt = \"foo\"]", dummy);        assertQuery(1, "//dummyNode[@Enum = \"FOO\"]", dummy);        assertQuery(0, "//dummyNode[@Enum = \"BAR\"]", dummy);        // queries with lists are not supported with xpath 1.0        assertQuery(0, "//dummyNode[@List = \"[A, B]\"]", dummy);        assertQuery(0, "//dummyNode[contains(@List, \"B\")]", dummy);        assertQuery(0, "//dummyNode[@List = \"C\"]", dummy);        assertQuery(0, "//dummyNode[@EnumList = \"[FOO, BAR]\"]", dummy);        assertQuery(0, "//dummyNode[contains(@EnumList, \"BAR\")]", dummy);        assertQuery(0, "//dummyNode[@EmptyList = \"A\"]", dummy);    }    @Test    public void ruleChainVisits() {        final String xpath = "//dummyNode[@Image='baz']/foo | //bar[@Public = 'true'] | //dummyNode[@Public = 'false'] | //dummyNode";        JaxenXPathRuleQuery query = createQuery(xpath);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(3, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertTrue(ruleChainVisits.contains("bar"));        // Note: Having AST_ROOT in the rule chain visits is probably a mistake. But it doesn't hurt, it shouldn't        // match a real node name.        Assert.assertTrue(ruleChainVisits.contains(JaxenXPathRuleQuery.AST_ROOT));        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        RuleContext data = new RuleContext();        data.setLanguageVersion(LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion());        query.evaluate(dummy, data);        // note: the actual xpath queries are only available after evaluating        Assert.assertEquals(3, query.nodeNameToXPaths.size());        Assert.assertEquals("self::node()", query.nodeNameToXPaths.get("dummyNode").get(0).toString());        Assert.assertEquals("self::node()[(attribute::Public = \"false\")]", query.nodeNameToXPaths.get("dummyNode").get(1).toString());        Assert.assertEquals("self::node()[(attribute::Image = \"baz\")]/child::foo", query.nodeNameToXPaths.get("dummyNode").get(2).toString());        Assert.assertEquals("self::node()[(attribute::Public = \"true\")]", query.nodeNameToXPaths.get("bar").get(0).toString());        Assert.assertEquals(xpath, query.nodeNameToXPaths.get(JaxenXPathRuleQuery.AST_ROOT).get(0).toString());    }    @Test    public void ruleChainVisitsMultipleFilters() {        final String xpath = "//dummyNode[@Test1 = 'false'][@Test2 = 'true']";        JaxenXPathRuleQuery query = createQuery(xpath);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(2, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        // Note: Having AST_ROOT in the rule chain visits is probably a mistake. But it doesn't hurt, it shouldn't        // match a real node name.        Assert.assertTrue(ruleChainVisits.contains(JaxenXPathRuleQuery.AST_ROOT));        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        RuleContext data = new RuleContext();        data.setLanguageVersion(LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion());        query.evaluate(dummy, data);        // note: the actual xpath queries are only available after evaluating        Assert.assertEquals(2, query.nodeNameToXPaths.size());        Assert.assertEquals("self::node()[(attribute::Test1 = \"false\")][(attribute::Test2 = \"true\")]", query.nodeNameToXPaths.get("dummyNode").get(0).toString());        Assert.assertEquals(xpath, query.nodeNameToXPaths.get(JaxenXPathRuleQuery.AST_ROOT).get(0).toString());    }    @Test    public void ruleChainVisitsNested() {        final String xpath = "//dummyNode/foo/*/bar[@Test = 'false']";        JaxenXPathRuleQuery query = createQuery(xpath);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(2, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        // Note: Having AST_ROOT in the rule chain visits is probably a mistake. But it doesn't hurt, it shouldn't        // match a real node name.        Assert.assertTrue(ruleChainVisits.contains(JaxenXPathRuleQuery.AST_ROOT));        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        RuleContext data = new RuleContext();        data.setLanguageVersion(LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion());        query.evaluate(dummy, data);        // note: the actual xpath queries are only available after evaluating        Assert.assertEquals(2, query.nodeNameToXPaths.size());        Assert.assertEquals("self::node()/child::foo/child::*/child::bar[(attribute::Test = \"false\")]", query.nodeNameToXPaths.get("dummyNode").get(0).toString());        Assert.assertEquals(xpath, query.nodeNameToXPaths.get(JaxenXPathRuleQuery.AST_ROOT).get(0).toString());    }    @Test    public void ruleChainVisitsNested2() {        final String xpath = "//dummyNode/foo[@Baz = 'a']/*/bar[@Test = 'false']";        JaxenXPathRuleQuery query = createQuery(xpath);        List<String> ruleChainVisits = query.getRuleChainVisits();        Assert.assertEquals(2, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        // Note: Having AST_ROOT in the rule chain visits is probably a mistake. But it doesn't hurt, it shouldn't        // match a real node name.        Assert.assertTrue(ruleChainVisits.contains(JaxenXPathRuleQuery.AST_ROOT));        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        RuleContext data = new RuleContext();        data.setLanguageVersion(LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion());        query.evaluate(dummy, data);        // note: the actual xpath queries are only available after evaluating        Assert.assertEquals(2, query.nodeNameToXPaths.size());        Assert.assertEquals("self::node()/child::foo[(attribute::Baz = \"a\")]/child::*/child::bar[(attribute::Test = \"false\")]", query.nodeNameToXPaths.get("dummyNode").get(0).toString());        Assert.assertEquals(xpath, query.nodeNameToXPaths.get(JaxenXPathRuleQuery.AST_ROOT).get(0).toString());    }    private static void assertQuery(int resultSize, String xpath, Node node) {        JaxenXPathRuleQuery query = createQuery(xpath);        RuleContext data = new RuleContext();        data.setLanguageVersion(LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion());        List<Node> result = query.evaluate(node, data);        Assert.assertEquals(resultSize, result.size());    }    private static JaxenXPathRuleQuery createQuery(String xpath) {        JaxenXPathRuleQuery query = new JaxenXPathRuleQuery();        query.setVersion("1.0");        query.setProperties(Collections.<PropertyDescriptor<?>, Object>emptyMap());        query.setXPath(xpath);        return query;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import static java.util.Collections.singletonList;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.Assert.assertEquals;import org.hamcrest.Matchers;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNodeWithDeprecatedAttribute;import net.sourceforge.pmd.lang.ast.DummyNodeWithListAndEnum;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;public class XPathRuleTest {    @Rule    public JavaUtilLoggingRule loggingRule = new JavaUtilLoggingRule(Attribute.class.getName());    /**     * It's easy to forget the attribute "typeResolution=true" when     * defining XPath rules in xml. Therefore we by default enable     * typeresolution. For Java rules, type resolution was enabled by     * default long time ago.     *     * @see <a href="https://github.com/pmd/pmd/issues/2048">#2048 [core] Enable type resolution by default for XPath     *     rules</a>     */    @Test    public void typeResolutionShouldBeEnabledByDefault() {        XPathRule rule = new XPathRule();        Assert.assertTrue(rule.isTypeResolution());        XPathRule rule2 = new XPathRule(".");        Assert.assertTrue(rule2.isTypeResolution());    }    @Test    public void testAttributeDeprecation10() {        testDeprecation(XPathVersion.XPATH_1_0);    }    @Test    public void testAttributeDeprecation20() {        testDeprecation(XPathVersion.XPATH_2_0);    }    @Test    public void testListAttributeDeprecation20() {        XPathRule xpr = makeRuleWithList("TestRuleWithListAccess");        loggingRule.clear();        RuleContext ctx = new RuleContext();        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        DummyNode firstNode = newNodeWithList();        eval(ctx, xpr, firstNode);        assertEquals(1, ctx.getReport().size());        String log = loggingRule.getLog();        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@List' by XPath rule 'TestRuleWithListAccess'"));        loggingRule.clear();        eval(ctx, xpr, newNodeWithList()); // with another node        assertEquals(2, ctx.getReport().size());        assertEquals("", loggingRule.getLog()); // no additional warnings        // with another rule forked from the same one (in multithreaded processor)        eval(ctx, xpr.deepCopy(), newNodeWithList());        assertEquals(3, ctx.getReport().size());        assertEquals("", loggingRule.getLog()); // no additional warnings        // with another rule on the same node, new warnings        XPathRule otherRule = makeRuleWithList("OtherTestRuleWithListAccess");        otherRule.setRuleSetName("rset.xml");        eval(ctx, otherRule, firstNode);        assertEquals(4, ctx.getReport().size());        log = loggingRule.getLog();        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@List' by XPath rule 'OtherTestRuleWithListAccess' (in ruleset 'rset.xml')"));    }    private XPathRule makeRuleWithList(String name) {        XPathRule xpr = new XPathRule(XPathVersion.XPATH_2_0, "//dummyNode[@List = 'A']");        xpr.setName(name);        xpr.setMessage("list is 'a'");        return xpr;    }    private DummyNode newNodeWithList() {        DummyNode firstNode = new DummyNodeWithListAndEnum(0);        firstNode.setCoords(1, 1, 1, 2);        return firstNode;    }    public void testDeprecation(XPathVersion version) {        XPathRule xpr = makeRule(version, "SomeRule");        loggingRule.clear();        RuleContext ctx = new RuleContext();        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        DummyNode firstNode = newNode();        eval(ctx, xpr, firstNode);        assertEquals(1, ctx.getReport().size());        String log = loggingRule.getLog();        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Size' by XPath rule 'SomeRule'"));        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Name' by XPath rule 'SomeRule', please use @Image instead"));        loggingRule.clear();        eval(ctx, xpr, newNode()); // with another node        assertEquals(2, ctx.getReport().size());        assertEquals("", loggingRule.getLog()); // no additional warnings        // with another rule forked from the same one (in multithreaded processor)        eval(ctx, xpr.deepCopy(), newNode());        assertEquals(3, ctx.getReport().size());        assertEquals("", loggingRule.getLog()); // no additional warnings        // with another rule on the same node, new warnings        XPathRule otherRule = makeRule(version, "OtherRule");        otherRule.setRuleSetName("rset.xml");        eval(ctx, otherRule, firstNode);        assertEquals(4, ctx.getReport().size());        log = loggingRule.getLog();        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Size' by XPath rule 'OtherRule' (in ruleset 'rset.xml')"));        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Name' by XPath rule 'OtherRule' (in ruleset 'rset.xml'), please use @Image instead"));    }    public XPathRule makeRule(XPathVersion version, String name) {        XPathRule xpr = new XPathRule(version, "//dummyNode[@Size >= 2 and @Name='foo']");        xpr.setName(name);        xpr.setMessage("gotcha");        return xpr;    }    public void eval(RuleContext ctx, net.sourceforge.pmd.Rule rule, DummyNode node) {        rule.apply(singletonList(node), ctx);    }    public DummyNode newNode() {        DummyNode dummy = new DummyNodeWithDeprecatedAttribute(2);        dummy.setCoords(1, 1, 1, 2);        return dummy;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import java.util.List;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.Node;public class AbstractRuleViolationFactoryTest {    private RuleContext ruleContext;    private RuleViolationFactory factory;    private static class TestRuleViolationFactory extends AbstractRuleViolationFactory {        @Override        protected RuleViolation createRuleViolation(Rule rule, RuleContext ruleContext, Node node, String message) {            return new ParametricRuleViolation<>(rule, ruleContext, node, message);        }        @Override        protected RuleViolation createRuleViolation(Rule rule, RuleContext ruleContext, Node node, String message,                int beginLine, int endLine) {            ParametricRuleViolation<Node> violation = new ParametricRuleViolation<>(rule, ruleContext, node, message);            violation.setLines(beginLine, endLine);            return violation;        }    }    private static class TestRule extends AbstractRule {        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            throw new UnsupportedOperationException("not implemented");        }    }    @Before    public void setup() {        ruleContext = new RuleContext();        factory = new TestRuleViolationFactory();    }    @Test    public void testMessage() {        factory.addViolation(ruleContext, new TestRule(), null, "message with \"'{'\"", null);        RuleViolation violation = ruleContext.getReport().iterator().next();        Assert.assertEquals("message with \"{\"", violation.getDescription());    }    @Test    public void testMessageArgs() {        factory.addViolation(ruleContext, new TestRule(), null, "message with 1 argument: \"{0}\"", new Object[] {"testarg1"});        RuleViolation violation = ruleContext.getReport().iterator().next();        Assert.assertEquals("message with 1 argument: \"testarg1\"", violation.getDescription());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.xpath;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for {@link AttributeAxisIterator} */public class AttributeAxisIteratorTest {    /**     * Test hasNext and next.     */    @Test    public void testAttributeAxisIterator() {        DummyNode dummyNode = new DummyNode(1);        dummyNode.testingOnlySetBeginLine(1);        dummyNode.testingOnlySetBeginColumn(1);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Map<String, Attribute> atts = toMap(it);        Assert.assertEquals(7, atts.size());        assertTrue(atts.containsKey("BeginColumn"));        assertTrue(atts.containsKey("BeginLine"));        assertTrue(atts.containsKey("FindBoundary"));        assertTrue(atts.containsKey("Image"));        assertTrue(atts.containsKey("SingleLine"));        assertTrue(atts.containsKey("EndColumn"));        assertTrue(atts.containsKey("EndLine"));    }    @Test    public void testAttributeAxisIteratorWithEnum() {        DummyNodeWithEnum dummyNode = new DummyNodeWithEnum(1);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Map<String, Attribute> atts = toMap(it);        Assert.assertEquals(8, atts.size());        assertTrue(atts.containsKey("Enum"));        assertEquals(DummyNodeWithEnum.MyEnum.FOO, atts.get("Enum").getValue());    }    @Test    public void testAttributeAxisIteratorWithList() {        DummyNodeWithList dummyNode = new DummyNodeWithList(1);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Map<String, Attribute> atts = toMap(it);        Assert.assertEquals(8, atts.size());        assertTrue(atts.containsKey("List"));        assertEquals(Arrays.asList("A", "B"), atts.get("List").getValue());        assertFalse(atts.containsKey("NodeList"));    }    private Map<String, Attribute> toMap(AttributeAxisIterator it) {        Map<String, Attribute> atts = new HashMap<>();        while (it.hasNext()) {            Attribute attribute = it.next();            atts.put(attribute.getName(), attribute);        }        return atts;    }    public static class DummyNodeWithEnum extends DummyNode {        public DummyNodeWithEnum(int id) {            super(id);        }        public enum MyEnum {            FOO, BAR        }        public MyEnum getEnum() {            return MyEnum.FOO;        }    }    public static class DummyNodeWithList extends DummyNode {        public DummyNodeWithList(int id) {            super(id);        }        public List<String> getList() {            return Arrays.asList("A", "B");        }        public List<Node> getNodeList() {            return Collections.emptyList();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.xpath;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.fail;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;/** * Unit test for {@link DocumentNavigator} */public class DocumentNavigatorTest {    private static class DummyRootNode extends DummyNode implements RootNode {        DummyRootNode(int id) {            super(id);        }    }    @Test    public void getDocumentNode() {        DocumentNavigator nav = new DocumentNavigator();        try {            nav.getDocumentNode(null);            fail();        } catch (RuntimeException e) {            assertNotNull(e);        }        Node root = new DummyRootNode(1);        Node n = new DummyNode(1);        root.jjtAddChild(n, 0);        n.jjtSetParent(root);        assertSame(root, nav.getDocumentNode(n));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Before;import org.junit.Test;/** * Unit test for {@link AbstractNode} tree transversal methods */public class AbstractNodeTransversalTest {    private int id;    private Node rootNode;    private int nextId() {        return id++;    }    private Node newDummyNode(boolean boundary) {        return new DummyNode(nextId(), boundary);    }    private Node addChild(final Node parent, final Node child) {        parent.jjtAddChild(child, parent.getNumChildren()); // Append child at the end        child.jjtSetParent(parent);        return parent;    }    @Before    public void setUpSampleNodeTree() {        id = 0;        rootNode = newDummyNode(false);    }    @Test    public void testBoundaryIsHonored() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class);        assertEquals(1, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());    }    @Test    public void testSearchFromBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class).get(0).findDescendantsOfType(DummyNode.class);        assertEquals(1, descendantsOfType.size());        assertFalse(descendantsOfType.get(0).isFindBoundary());    }    @Test    public void testSearchIgnoringBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class, true);        assertEquals(2, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());        assertFalse(descendantsOfType.get(1).isFindBoundary());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;/** * Unit test for {@link SourceCodePositioner}. */public class SourceCodePositionerTest {    private static final String SOURCE_CODE = "abcd\ndefghi\n\njklmn\nopq";    /**     * Tests whether the lines and columns are calculated correctly.     */    @Test    public void testLineNumberFromOffset() {        SourceCodePositioner positioner = new SourceCodePositioner(SOURCE_CODE);        int offset;        offset = SOURCE_CODE.indexOf('a');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(1, positioner.columnFromOffset(1, offset));        offset = SOURCE_CODE.indexOf('b');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(1, offset));        offset = SOURCE_CODE.indexOf('e');        assertEquals(2, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(2, offset));        offset = SOURCE_CODE.indexOf('q');        assertEquals(5, positioner.lineNumberFromOffset(offset));        assertEquals(3, positioner.columnFromOffset(5, offset));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.jaxen.JaxenException;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.runner.RunWith;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import junitparams.JUnitParamsRunner;import junitparams.Parameters;/** * Unit test for {@link AbstractNode}. */@RunWith(JUnitParamsRunner.class)public class AbstractNodeTest {    private static final int NUM_CHILDREN = 3;    private static final int NUM_GRAND_CHILDREN = 3;    @Rule    public JavaUtilLoggingRule loggingRule = new JavaUtilLoggingRule(Attribute.class.getName());    // Note that in order to successfully run JUnitParams, we need to explicitly use `Integer` instead of `int`    private Integer[] childrenIndexes() {        return getIntRange(NUM_CHILDREN);    }    private Integer[] grandChildrenIndexes() {        return getIntRange(NUM_GRAND_CHILDREN);    }    private static Integer[] getIntRange(final int exclusiveLimit) {        final Integer[] childIndexes = new Integer[exclusiveLimit];        for (int i = 0; i < exclusiveLimit; i++) {            childIndexes[i] = i;        }        return childIndexes;    }    public Object childrenAndGrandChildrenIndexes() {        final Integer[] childrenIndexes = childrenIndexes();        final Integer[] grandChildrenIndexes = grandChildrenIndexes();        final Object[] indexes = new Object[childrenIndexes.length * grandChildrenIndexes.length];        int i = 0;        for (final int childIndex : childrenIndexes) {            for (final int grandChildIndex : grandChildrenIndexes) {                indexes[i++] = new Integer[] { childIndex, grandChildIndex };            }        }        return indexes;    }    private int id;    private Node rootNode;    private int nextId() {        return id++;    }    private Node newDummyNode() {        return new DummyNode(nextId());    }    private static Node addChild(final Node parent, final Node child) {        parent.jjtAddChild(child, parent.getNumChildren()); // Append child at the end        child.jjtSetParent(parent);        return parent;    }    @Before    public void setUpSampleNodeTree() {        id = 0;        rootNode = newDummyNode();        for (int i = 0; i < NUM_CHILDREN; i++) {            final Node child = newDummyNode();            for (int j = 0; j < NUM_GRAND_CHILDREN; j++) {                final Node grandChild = newDummyNode();                addChild(child, grandChild);            }            addChild(rootNode, child);        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method     */    @Test    @Parameters(method = "childrenIndexes")    public void testRemoveChildOfRootNode(final int childIndex) {        final Node child = rootNode.getChild(childIndex);        final Node[] grandChildren = new Node[child.getNumChildren()];        for (int i = 0; i < grandChildren.length; i++) {            final Node grandChild = child.getChild(i);            grandChildren[i] = grandChild;        }        // Do the actual removal        child.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.getNumChildren());        assertNull(child.getParent());        // The child node is expected to still have all its children and vice versa        assertEquals(NUM_GRAND_CHILDREN, child.getNumChildren());        for (final Node grandChild : grandChildren) {            assertEquals(child, grandChild.getParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * This is a border case as the root node does not have any parent.     */    @Test    public void testRemoveRootNode() {        // Check that the root node has the expected properties        final Node[] children = new Node[rootNode.getNumChildren()];        for (int i = 0; i < children.length; i++) {            final Node child = rootNode.getChild(i);            children[i] = child;        }        // Do the actual removal        rootNode.remove();        // Check that conditions have been successfully changed, i.e.,        //  the root node is expected to still have all its children and vice versa        assertEquals(NUM_CHILDREN, rootNode.getNumChildren());        assertNull(rootNode.getParent());        for (final Node aChild : children) {            assertEquals(rootNode, aChild.getParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * These are border cases as grandchildren nodes do not have any child.     */    @Test    @Parameters(method = "childrenAndGrandChildrenIndexes")    public void testRemoveGrandChildNode(final int childIndex, final int grandChildIndex) {        final Node child = rootNode.getChild(childIndex);        final Node grandChild = child.getChild(grandChildIndex);        // Do the actual removal        grandChild.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_GRAND_CHILDREN - 1, child.getNumChildren());        assertEquals(0, grandChild.getNumChildren());        assertNull(grandChild.getParent());    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     */    @Test    @Parameters(method = "childrenIndexes")    public void testRemoveRootNodeChildAtIndex(final int childIndex) {        final Node[] originalChildren = new Node[rootNode.getNumChildren()];        for (int i = 0; i < originalChildren.length; i++) {            originalChildren[i] = rootNode.getChild(i);        }        // Do the actual removal        rootNode.removeChildAtIndex(childIndex);        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.getNumChildren());        int j = 0;        for (int i = 0; i < rootNode.getNumChildren(); i++) {            if (j == childIndex) { // Skip the removed child                j++;            }            // Check that the nodes have been rightly shifted            assertEquals(originalChildren[j], rootNode.getChild(i));            // Check that the child index has been updated            assertEquals(i, rootNode.getChild(i).getIndexInParent());            j++;        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * Test that invalid indexes cases are handled without exception.     */    @Test    public void testRemoveChildAtIndexWithInvalidIndex() {        try {            rootNode.removeChildAtIndex(-1);            rootNode.removeChildAtIndex(rootNode.getNumChildren());        } catch (final Exception e) {            fail("No exception was expected.");        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * This is a border case as the method invocation should do nothing.     */    @Test    @Parameters(method = "grandChildrenIndexes")    public void testRemoveChildAtIndexOnNodeWithNoChildren(final int grandChildIndex) {        // grandChild does not have any child        final Node grandChild = rootNode.getChild(grandChildIndex).getChild(grandChildIndex);        // Do the actual removal        grandChild.removeChildAtIndex(0);        // If here, no exception has been thrown        // Check that this node still does not have any children        assertEquals(0, grandChild.getNumChildren());    }    @Test    public void testDeprecatedAttributeXPathQuery() throws JaxenException {        class MyRootNode extends DummyNode implements RootNode {            private MyRootNode(int id) {                super(id);            }        }        Node root = addChild(new MyRootNode(nextId()), new DummyNodeWithDeprecatedAttribute(2));        root.findChildNodesWithXPath("//dummyNode[@Size=1]");        String log = loggingRule.getLog();        assertTrue(log.contains("deprecated"));        assertTrue(log.contains("attribute"));        assertTrue(log.contains("dummyNode/@Size"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;public class LanguageRegistryTest {    @Test    public void getDefaultLanguageTest() {        Language defaultLanguage = LanguageRegistry.getDefaultLanguage();        Assert.assertNotNull(defaultLanguage);        // as we don't have java language in this test, we get the first        // available language now -> DummyLanguage        Assert.assertSame(DummyLanguageModule.class, defaultLanguage.getClass());    }    @Test    public void getDefaultVersionLanguageTest() {        LanguageVersion dummy12 = LanguageRegistry.findLanguageVersionByTerseName("dummy 1.2");        Assert.assertNotNull(dummy12);        Language dummy = LanguageRegistry.findLanguageByTerseName("dummy");        LanguageVersion dummyDefault = dummy.getDefaultVersion();        LanguageVersion dummyDefault2 = LanguageRegistry.findLanguageVersionByTerseName("dummy ");        Assert.assertNotNull(dummyDefault2);        Assert.assertSame(dummyDefault, dummyDefault2);    }    @Test    public void getLanguageVersionByNameAliasTest() {        LanguageVersion dummy17 = LanguageRegistry.findLanguageVersionByTerseName("dummy 1.7");        Assert.assertNotNull(dummy17);        Assert.assertEquals("1.7", dummy17.getVersion());        LanguageVersion dummy7 = LanguageRegistry.findLanguageVersionByTerseName("dummy 7");        Assert.assertNotNull(dummy7);        Assert.assertEquals("1.7", dummy17.getVersion());        Assert.assertSame(dummy17, dummy7);    }    @Test    public void getLanguageVersionByAliasTest() {        Language dummy = LanguageRegistry.findLanguageByTerseName("dummy");        LanguageVersion dummy17 = dummy.getVersion("1.7");        Assert.assertNotNull(dummy17);        Assert.assertEquals("1.7", dummy17.getVersion());        LanguageVersion dummy7 = dummy.getVersion("7");        Assert.assertNotNull(dummy7);        Assert.assertEquals("1.7", dummy17.getVersion());        Assert.assertSame(dummy17, dummy7);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;public class BaseLanguageModuleTest {    @Test    public void testHashCodeEquals() {        Language l1 = new DummyLanguageModule();        Language l1a = new DummyLanguageModule();        Language l2 = new Dummy2LanguageModule();        Assert.assertEquals(l1.hashCode(), l1a.hashCode());        Assert.assertNotEquals(l1.hashCode(), l2.hashCode());        Assert.assertEquals(l1, l1a);        Assert.assertNotEquals(l1, l2);    }    @Test    public void testCompareTo() {        Language l1 = new DummyLanguageModule();        Language l2 = new Dummy2LanguageModule();        Assert.assertTrue(l1.compareTo(l2) < 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties.constraints;import org.junit.Assert;import org.junit.Test;public class NumericConstraintsTest {    @Test    public void testInRangeInteger() {        PropertyConstraint<Integer> constraint = NumericConstraints.inRange(1, 10);        Assert.assertTrue(constraint.test(1));        Assert.assertTrue(constraint.test(5));        Assert.assertTrue(constraint.test(10));        Assert.assertFalse(constraint.test(0));        Assert.assertFalse(constraint.test(-1));        Assert.assertFalse(constraint.test(11));        Assert.assertFalse(constraint.test(100));    }    @Test    public void testInRangeDouble() {        PropertyConstraint<Double> constraint = NumericConstraints.inRange(1.0, 10.0);        Assert.assertTrue(constraint.test(1.0));        Assert.assertTrue(constraint.test(5.5));        Assert.assertTrue(constraint.test(10.0));        Assert.assertFalse(constraint.test(0.0));        Assert.assertFalse(constraint.test(-1.0));        Assert.assertFalse(constraint.test(11.1));        Assert.assertFalse(constraint.test(100.0));    }    @Test    public void testPositive() {        PropertyConstraint<Number> constraint = NumericConstraints.positive();        Assert.assertTrue(constraint.test(1));        Assert.assertTrue(constraint.test(1.5f));        Assert.assertTrue(constraint.test(1.5d));        Assert.assertTrue(constraint.test(100));        Assert.assertFalse(constraint.test(0));        Assert.assertFalse(constraint.test(0.1f));        Assert.assertFalse(constraint.test(0.9d));        Assert.assertFalse(constraint.test(-1));        Assert.assertFalse(constraint.test(-100));        Assert.assertFalse(constraint.test(-0.1f));        Assert.assertFalse(constraint.test(-0.1d));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import java.util.regex.Pattern;/** * Since there's no RegexMultiProperty the base class is only partially implemented, * and some tests are overridden with no-op ones. * * @author Clément Fournier * @since 6.2.0 */@Deprecatedpublic class RegexPropertyTest extends AbstractPropertyDescriptorTester<Pattern> {    public RegexPropertyTest() {        super("Regex");    }    @Override    protected Pattern createValue() {        return Pattern.compile("abc++");    }    @Override    protected Pattern createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Pattern> createProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa)+").desc("the description").build();    }    @Override    protected PropertyDescriptor<Pattern> createBadProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa").desc("the description").build();    }    // The following are deliberately unimplemented, since they are only relevant to the tests of the multiproperty    @Override    protected PropertyDescriptor<List<Pattern>> createMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    protected PropertyDescriptor<List<Pattern>> createBadMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    public void testAddAttributesMulti() {    }    @Override    public void testAsDelimitedString() {    }    @Override    public void testErrorForBadMulti() {    }    @Override    public void testErrorForCorrectMulti() {    }    @Override    public void testFactoryMultiValueDefaultDelimiter() {    }    @Override    public void testFactoryMultiValueCustomDelimiter() {    }    @Override    public void testTypeMulti() {    }    @Override    public void testIsMultiValueMulti() {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Observer;import java.util.Set;/** * Evaluates the functionality of the TypeProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid Type values per * the allowable packages, and serialize/deserialize groups of types onto/from a * string buffer. * * We're using java.lang classes for 'normal' constructors and applying * java.util types as ones we expect to fail. * * @author Brian Remedios */public class TypePropertyTest extends AbstractPackagedPropertyDescriptorTester<Class> {    private static final List<Class> JAVA_LANG_CLASSES = Arrays.<Class>asList(String.class, Integer.class, Thread.class,                                                                              Object.class, Runtime.class);    private static final List<Class> JAVA_UTIL_CLASSES = Arrays.<Class>asList(HashMap.class, Map.class,                                                                              Comparator.class, Set.class,                                                                              Observer.class);    public TypePropertyTest() {        super("Class");    }    @Override    protected Class createBadValue() {        return JAVA_UTIL_CLASSES.get(randomInt(0, JAVA_UTIL_CLASSES.size()));    }    @Override    protected PropertyDescriptor<Class> createProperty() {        return new TypeProperty("testType", "Test type property", createValue(), new String[] {"java.lang"},                                1.0f);    }    @Override    protected Class createValue() {        return JAVA_LANG_CLASSES.get(randomInt(0, JAVA_LANG_CLASSES.size()));    }    @Override    protected PropertyDescriptor<List<Class>> createMultiProperty() {        return new TypeMultiProperty("testType", "Test type property", JAVA_LANG_CLASSES, new String[] {"java.lang"},                                     1.0f);    }    @Override    protected PropertyDescriptor<Class> createBadProperty() {        return new TypeProperty("testType", "Test type property", createValue(), new String[] {"java.util"},                                1.0f);    }    @Override    protected PropertyDescriptor<List<Class>> createBadMultiProperty() {        return new TypeMultiProperty("testType", "Test type property", Collections.<Class>singletonList(Set.class),                                     new String[] {"java.lang"}, 1.0f);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assume;import org.junit.Test;import net.sourceforge.pmd.properties.modules.MethodPropertyModule;import net.sourceforge.pmd.util.ClassUtil;/** * Evaluates the functionality of the MethodProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid methods per the * allowable packages, and serialize/deserialize groups of methods onto/from a * string buffer. * * We're using methods from java.lang classes for 'normal' constructors and * applying ones from java.util types as ones we expect to fail. * * @author Brian Remedios */public class MethodPropertyTest extends AbstractPackagedPropertyDescriptorTester<Method> {    private static final Method[] ALL_METHODS;    private static final String[] METHOD_SIGNATURES = {"String#indexOf(int)", "String#substring(int,int)",                                                       "java.lang.String#substring(int,int)", "Integer#parseInt(String)", "java.util.HashMap#put(Object,Object)",                                                       "HashMap#containsKey(Object)", };    static {        List<Method> allMethods = new ArrayList<>();        for (Method m : String.class.getDeclaredMethods()) {            // exclude String.resolveConstantDesc to avoid random test failure with java12            // there are two methods with the same signature available, but different return types...            if (!m.getName().equals("resolveConstantDesc")) {                allMethods.add(m);            }        }        ALL_METHODS = allMethods.toArray(new Method[0]);    }    public MethodPropertyTest() {        super("Method");    }    @Override    @Test    public void testMissingPackageNames() {        Map<PropertyDescriptorField, String> attributes = getPropertyDescriptorValues();        attributes.remove(PropertyDescriptorField.LEGAL_PACKAGES);        new MethodProperty("p", "d", ALL_METHODS[1], null, 1.0f); // no exception, null is ok        new MethodMultiProperty("p", "d", new Method[]{ALL_METHODS[2], ALL_METHODS[3]}, null, 1.0f); // no exception, null is ok    }    @Test    public void testAsStringOn() {        Method method;        for (String methodSignature : METHOD_SIGNATURES) {            method = ValueParserConstants.METHOD_PARSER.valueOf(methodSignature);            assertNotNull("Unable to identify method: " + methodSignature, method);        }    }    @Test    public void testAsMethodOn() {        Method[] methods = new Method[METHOD_SIGNATURES.length];        for (int i = 0; i < METHOD_SIGNATURES.length; i++) {            methods[i] = ValueParserConstants.METHOD_PARSER.valueOf(METHOD_SIGNATURES[i]);            assertNotNull("Unable to identify method: " + METHOD_SIGNATURES[i], methods[i]);        }        String translatedMethod;        for (int i = 0; i < methods.length; i++) {            translatedMethod = MethodPropertyModule.asString(methods[i]);            assertTrue("Translated method does not match", ClassUtil.withoutPackageName(METHOD_SIGNATURES[i])                                                                    .equals(ClassUtil.withoutPackageName(translatedMethod)));        }    }    @Override    protected Method createValue() {        return randomChoice(ALL_METHODS);    }    @Override    protected Method createBadValue() {        return randomChoice(HashMap.class.getDeclaredMethods());    }    @Override    protected PropertyDescriptor<Method> createProperty() {        return new MethodProperty("methodProperty", "asdf", ALL_METHODS[1], new String[]{"java.lang", "org.apache"},            1.0f);    }    @Override    protected PropertyDescriptor<List<Method>> createMultiProperty() {        return new MethodMultiProperty("methodProperty", "asdf", new Method[]{ALL_METHODS[2], ALL_METHODS[3]},            new String[]{"java.lang"}, 1.0f);    }    @Override    protected PropertyDescriptor<Method> createBadProperty() {        return new MethodProperty("methodProperty", "asdf", ALL_METHODS[1], new String[]{"java.util"}, 1.0f);    }    @Override    protected PropertyDescriptor<List<Method>> createBadMultiProperty() {        return new MethodMultiProperty("methodProperty", "asdf", new Method[]{ALL_METHODS[2], ALL_METHODS[3]},            new String[]{"java.util"}, 1.0f);    }    @Override    @Test    public void testFactorySingleValue() {        Assume.assumeTrue("MethodProperty cannot be built from XPath (#762)", false);    }    @Override    @Test    public void testFactoryMultiValueCustomDelimiter() {        Assume.assumeTrue("MethodProperty cannot be built from XPath (#762)", false);    }    @Override    @Test    public void testFactoryMultiValueDefaultDelimiter() {        Assume.assumeTrue("MethodProperty cannot be built from XPath (#762)", false);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.Test;/** * @author Brian Remedios */public class BooleanPropertyTest extends AbstractPropertyDescriptorTester<Boolean> {    public BooleanPropertyTest() {        super("Boolean");    }    @Override    protected Boolean createValue() {        return randomBool();    }    @Override    @Test    public void testErrorForBadSingle() {        // override, cannot create a 'bad' boolean per se    }    @Override    @Test    public void testErrorForBadMulti() {        // override, cannot create a 'bad' boolean per se    }    @Override    protected Boolean createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Boolean> createProperty() {        return new BooleanProperty("testBoolean", "Test boolean property", false, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createMultiProperty() {        return new BooleanMultiProperty("testBoolean", "Test boolean property",                                        new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createBadMultiProperty() {        return new BooleanMultiProperty("", "Test boolean property", new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<Boolean> createBadProperty() {        return new BooleanProperty("testBoolean", "", false, 1.0f);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the StringProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid strings per any * specified expressions, and serialize/deserialize groups of strings onto/from * a string buffer. * * @author Brian Remedios */public class StringPropertyTest extends AbstractPropertyDescriptorTester<String> {    private static final int MAX_STRING_LENGTH = 52;    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    public StringPropertyTest() {        super("String");    }    @Override    protected String createValue() {        return newString();    }    /**     * Method newString.     *     * @return String     */    private String newString() {        int strLength = randomInt(1, MAX_STRING_LENGTH);        char[] chars = new char[strLength];        for (int i = 0; i < chars.length; i++) {            chars[i] = randomCharIn(CHARSET);        }        return new String(chars);    }    /**     * Method randomCharIn.     *     * @param chars char[]     *     * @return char     */    private char randomCharIn(char[] chars) {        return randomChar(chars);    }    @Override    protected String createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<String> createProperty() {        return new StringProperty("testString", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world"}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<String> createBadProperty() {        return new StringProperty("", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createBadMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world", "a" + DELIMITER + "b"}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.allOf;import static org.hamcrest.Matchers.hasItem;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;import org.apache.commons.lang3.StringUtils;import org.hamcrest.Matcher;import org.hamcrest.Matchers;import org.hamcrest.core.SubstringMatcher;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.properties.constraints.PropertyConstraint;/** * Mostly TODO, I'd rather implement tests on the final version of the framework. * * @author Clément Fournier * @since 7.0.0 */public class PropertyDescriptorTest {    @Rule    public ExpectedException thrown = ExpectedException.none();    @Test    public void testConstraintViolationCausesDysfunctionalRule() {        PropertyDescriptor<Integer> intProperty = PropertyFactory.intProperty("fooProp")                                                                 .desc("hello")                                                                 .defaultValue(4)                                                                 .require(inRange(1, 10))                                                                 .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(intProperty);        rule.setProperty(intProperty, 1000);        RuleSet ruleSet = RuleSet.forSingleRule(rule);        List<net.sourceforge.pmd.Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    public void testConstraintViolationCausesDysfunctionalRuleMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(descriptor);        rule.setProperty(descriptor, Collections.singletonList(1000d)); // not in range        RuleSet ruleSet = RuleSet.forSingleRule(rule);        List<net.sourceforge.pmd.Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    public void testDefaultValueConstraintViolationCausesFailure() {        PropertyConstraint<Integer> constraint = inRange(1, 10);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                                   containsIgnoreCase(constraint.getConstraintDescription())));        PropertyFactory.intProperty("fooProp")                       .desc("hello")                       .defaultValue(1000)                       .require(constraint)                       .build();    }    @Test    public void testDefaultValueConstraintViolationCausesFailureMulti() {        PropertyConstraint<Double> constraint = inRange(1d, 10d);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                                   containsIgnoreCase(constraint.getConstraintDescription())));        PropertyFactory.doubleListProperty("fooProp")                       .desc("hello")                       .defaultValues(2., 11.) // 11. is out of range                       .requireEach(constraint)                       .build();    }    @Test    public void testNoConstraintViolationCausesIsOkMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertThat(descriptor.defaultValue(), Matchers.contains(2., 11.));    }    @Test    public void testNoConstraintViolationCausesIsOk() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValue("bazooli")                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("bazooli", descriptor.defaultValue());    }    @Test    public void testIntProperty() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        assertEquals("intProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Integer.valueOf(1), descriptor.defaultValue());        assertEquals(Integer.valueOf(5), descriptor.valueFrom("5"));        assertEquals(Integer.valueOf(5), descriptor.valueFrom(" 5 "));        PropertyDescriptor<List<Integer>> listDescriptor = PropertyFactory.intListProperty("intListProp")                .desc("hello")                .defaultValues(1, 2)                .build();        assertEquals("intListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1, 2), listDescriptor.defaultValue());        assertEquals(Arrays.asList(5, 7), listDescriptor.valueFrom("5,7"));        assertEquals(Arrays.asList(5, 7), listDescriptor.valueFrom(" 5 , 7 "));    }    @Test    public void testIntPropertyInvalidValue() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        thrown.expect(NumberFormatException.class);        thrown.expectMessage("not a number");        descriptor.valueFrom("not a number");    }    @Test    public void testDoubleProperty() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        assertEquals("doubleProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Double.valueOf(1.0), descriptor.defaultValue());        assertEquals(Double.valueOf(2.0), descriptor.valueFrom("2.0"));        assertEquals(Double.valueOf(2.0), descriptor.valueFrom("  2.0  "));        PropertyDescriptor<List<Double>> listDescriptor = PropertyFactory.doubleListProperty("doubleListProp")                .desc("hello")                .defaultValues(1.0, 2.0)                .build();        assertEquals("doubleListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1.0, 2.0), listDescriptor.defaultValue());        assertEquals(Arrays.asList(2.0, 3.0), listDescriptor.valueFrom("2.0,3.0"));        assertEquals(Arrays.asList(2.0, 3.0), listDescriptor.valueFrom(" 2.0 , 3.0 "));    }    @Test    public void testDoublePropertyInvalidValue() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        thrown.expect(NumberFormatException.class);        thrown.expectMessage("this is not a number");        descriptor.valueFrom("this is not a number");    }    @Test    public void testStringProperty() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("stringProp")                .desc("hello")                .defaultValue("default value")                .build();        assertEquals("stringProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("default value", descriptor.defaultValue());        assertEquals("foo", descriptor.valueFrom("foo"));        assertEquals("foo", descriptor.valueFrom("  foo   "));        PropertyDescriptor<List<String>> listDescriptor = PropertyFactory.stringListProperty("stringListProp")                .desc("hello")                .defaultValues("v1", "v2")                .build();        assertEquals("stringListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList("v1", "v2"), listDescriptor.defaultValue());        assertEquals(Arrays.asList("foo", "bar"), listDescriptor.valueFrom("foo|bar"));        assertEquals(Arrays.asList("foo", "bar"), listDescriptor.valueFrom("  foo |  bar  "));    }    private enum SampleEnum { A, B, C }    private static Map<String, SampleEnum> nameMap = new LinkedHashMap<>();    static {        nameMap.put("TEST_A", SampleEnum.A);        nameMap.put("TEST_B", SampleEnum.B);        nameMap.put("TEST_C", SampleEnum.C);    }    @Test    public void testEnumProperty() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        assertEquals("enumProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(SampleEnum.B, descriptor.defaultValue());        assertEquals(SampleEnum.C, descriptor.valueFrom("TEST_C"));        PropertyDescriptor<List<SampleEnum>> listDescriptor = PropertyFactory.enumListProperty("enumListProp", nameMap)                .desc("hello")                .defaultValues(SampleEnum.A, SampleEnum.B)                .build();        assertEquals("enumListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(SampleEnum.A, SampleEnum.B), listDescriptor.defaultValue());        assertEquals(Arrays.asList(SampleEnum.B, SampleEnum.C), listDescriptor.valueFrom("TEST_B|TEST_C"));    }    @Test    public void testEnumPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(containsIgnoreCase("null value"));        PropertyFactory.enumProperty("enumProp", map);    }    @Test    public void testEnumListPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(containsIgnoreCase("null value"));        PropertyFactory.enumListProperty("enumProp", map);    }    @Test    public void testEnumPropertyInvalidValue() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage("Value was not in the set [TEST_A, TEST_B, TEST_C]");        descriptor.valueFrom("InvalidEnumValue");    }    @Test    public void testRegexProperty() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        assertEquals("regexProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("^[A-Z].*$", descriptor.defaultValue().toString());        assertEquals("[0-9]+", descriptor.valueFrom("[0-9]+").toString());    }    @Test    public void testRegexPropertyInvalidValue() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        thrown.expect(PatternSyntaxException.class);        thrown.expectMessage("Unclosed character class");        descriptor.valueFrom("[open class");    }    @Test    public void testRegexPropertyInvalidDefaultValue() {        thrown.expect(PatternSyntaxException.class);        thrown.expectMessage("Unclosed character class");        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("[open class")                .build();    }    private static Matcher<String> containsIgnoreCase(final String substring) {        return new SubstringMatcher("containing (ignoring case)", true, substring) {            @Override            protected boolean evalSubstringOf(String string) {                return StringUtils.indexOfIgnoreCase(string, substring) != -1;            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.Test;/** * Evaluates the functionality of the CharacterProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid characters, * and serialize/deserialize any default values. * * @author Brian Remedios */@Deprecatedpublic class CharacterPropertyTest extends AbstractPropertyDescriptorTester<Character> {    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    public CharacterPropertyTest() {        super("Character");    }    @Override    @Test    public void testErrorForBadSingle() {    } // not until char properties use illegal chars    @Override    @Test    public void testErrorForBadMulti() {    } // not until char properties use illegal chars    @Override    protected Character createValue() {        return randomChar(CHARSET);    }    @Override    protected Character createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Character> createProperty() {        return new CharacterProperty("testCharacter", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<Character> createBadProperty() {        return new CharacterProperty("", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createBadMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the IntegerProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of integers onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedpublic class IntegerPropertyTest extends AbstractNumericPropertyDescriptorTester<Integer> {    private static final int MIN = 1;    private static final int MAX = 12;    private static final int SHIFT = 4;    public IntegerPropertyTest() {        super("Integer");    }    /*   @Override       @Test       public void testErrorForBadSingle() {       } // not until int properties get ranges       @Override       @Test       public void testErrorForBadMulti() {       } // not until int properties get ranges   */    @Override    protected Integer createValue() {        return randomInt(MIN, MAX);    }    @Override    protected Integer createBadValue() {        return randomBool() ? randomInt(MIN - SHIFT, MIN - 1) : randomInt(MAX + 1, MAX + SHIFT);    }    protected IntegerProperty.IntegerPBuilder singleBuilder() {        return IntegerProperty.named("test").desc("foo")                              .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected IntegerMultiProperty.IntegerMultiPBuilder multiBuilder() {        return IntegerMultiProperty.named("test").desc("foo")                                   .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Integer> createProperty() {        return new IntegerProperty("testInteger", "Test integer property", MIN, MAX, MAX - 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createMultiProperty() {        return new IntegerMultiProperty("testInteger", "Test integer property", MIN, MAX,                                        new Integer[] {MIN, MIN + 1, MAX - 1, MAX}, 1.0f);    }    @Override    protected PropertyDescriptor<Integer> createBadProperty() {        return new IntegerProperty("", "Test integer property", MIN, MAX, MAX + 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createBadMultiProperty() {        return new IntegerMultiProperty("testInteger", "", MIN, MAX, new Integer[] {MIN - 1, MAX}, 1.0f);    }    @Override    protected Integer min() {        return MIN;    }    @Override    protected Integer max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the FloatProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of float values onto/from a string * buffer. * * @author Brian Remedios */public class FloatPropertyTest extends AbstractNumericPropertyDescriptorTester<Float> {    private static final float MIN = 1.0f;    private static final float MAX = 11.0f;    private static final float SHIFT = 3.0f;    public FloatPropertyTest() {        super("Float");    }    @Override    protected Float createValue() {        return randomFloat(MIN, MAX);    }    @Override    protected Float createBadValue() {        return randomBool() ? randomFloat(MIN - SHIFT, MIN) : randomFloat(MAX + 1, MAX + SHIFT);    }    @Override    protected FloatProperty.FloatPBuilder singleBuilder() {        return FloatProperty.named("test").desc("foo")                            .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected FloatMultiProperty.FloatMultiPBuilder multiBuilder() {        return FloatMultiProperty.named("test").desc("foo")                                 .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Float> createProperty() {        return new FloatProperty("testFloat", "Test float property", MIN, MAX, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", MIN, MAX,            new Float[]{6f, 9f, 1f, 2f}, 1.0f);    }    @Override    protected PropertyDescriptor<Float> createBadProperty() {        return new FloatProperty("testFloat", "Test float property", 5f, 4f, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createBadMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", 0f, 5f,            new Float[]{-1f, 0f, 1f, 2f}, 1.0f);    }    @Override    protected Float min() {        return MIN;    }    @Override    protected Float max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the DoubleProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of double values onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedpublic class DoublePropertyTest extends AbstractNumericPropertyDescriptorTester<Double> {    private static final double MIN = -10.0;    private static final double MAX = 100.0;    private static final double SHIFT = 5.0;    public DoublePropertyTest() {        super("Double");    }    @Override    protected Double createValue() {        return randomDouble(MIN, MAX);    }    @Override    protected Double createBadValue() {        return randomBool() ? randomDouble(MIN - SHIFT, MIN - 0.01) : randomDouble(MAX + 0.01, MAX + SHIFT);    }    protected DoubleProperty.DoublePBuilder singleBuilder() {        return DoubleProperty.named("test").desc("foo")                             .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected DoubleMultiProperty.DoubleMultiPBuilder multiBuilder() {        return DoubleMultiProperty.named("test").desc("foo")                                  .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Double> createProperty() {        return new DoubleProperty("testDouble", "Test double property", MIN, MAX, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {-1d, 0d, 1d, 2d}, 1.0f);    }    @Override    protected PropertyDescriptor<Double> createBadProperty() {        return new DoubleProperty("testDouble", "Test double property", MAX, MIN, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createBadMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {MIN - SHIFT, MIN, MIN + SHIFT, MAX + SHIFT}, 1.0f);    }    @Override    protected Double min() {        return MIN;    }    @Override    protected Double max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * @author Clément Fournier */@Deprecatedpublic class LongPropertyTest extends AbstractNumericPropertyDescriptorTester<Long> {    private static final long MIN = 10L;    private static final long MAX = 11000L;    private static final long SHIFT = 300L;    public LongPropertyTest() {        super("Long");    }    @Override    protected Long createValue() {        return randomLong(MIN, MAX);    }    @Override    protected Long createBadValue() {        return randomBool() ? randomLong(MIN - SHIFT, MIN) : randomLong(MAX + 1, MAX + SHIFT);    }    @Override    protected LongProperty.LongPBuilder singleBuilder() {        return LongProperty.named("test").desc("foo")                           .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected LongMultiProperty.LongMultiPBuilder multiBuilder() {        return LongMultiProperty.named("test").desc("foo")                                .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Long> createProperty() {        return new LongProperty("testFloat", "Test float property", MIN, MAX, 90L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", MIN, MAX,            new Long[]{1000L, 10L, 100L, 20L}, 1.0f);    }    @Override    protected PropertyDescriptor<Long> createBadProperty() {        return new LongProperty("testFloat", "Test float property", 200L, -400L, 900L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createBadMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", 0L, 5L,            new Long[]{-1000L, 0L, 100L, 20L}, 1.0f);    }    @Override    protected Long min() {        return MIN;    }    @Override    protected Long max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assume;import org.junit.Test;import net.sourceforge.pmd.properties.SimpleEnumeratedPropertyTest.Foo;/** * Evaluates the functionality of the EnumeratedProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid selections, * and serialize/deserialize selection options. * * @author Brian Remedios */@Deprecatedpublic class SimpleEnumeratedPropertyTest extends AbstractPropertyDescriptorTester<Foo> {    private static final String[] KEYS = {"bar", "na", "bee", "coo"};    private static final Foo[] VALUES = {Foo.BAR, Foo.NA, Foo.BEE, Foo.COO};    private static final Map<String, Foo> MAPPINGS;    static {        Map<String, Foo> map = new HashMap<>();        map.put("bar", Foo.BAR);        map.put("na", Foo.NA);        map.put("bee", Foo.BEE);        map.put("coo", Foo.COO);        MAPPINGS = Collections.unmodifiableMap(map);    }    public SimpleEnumeratedPropertyTest() {        super("Enum");    }    @Test    public void testMappings() {        EnumeratedPropertyDescriptor<Foo, Foo> prop            = (EnumeratedPropertyDescriptor<Foo, Foo>) createProperty();        EnumeratedPropertyDescriptor<Foo, List<Foo>> multi            = (EnumeratedPropertyDescriptor<Foo, List<Foo>>) createMultiProperty();        assertEquals(MAPPINGS, prop.mappings());        assertEquals(MAPPINGS, multi.mappings());    }    @Override    protected PropertyDescriptor<Foo> createProperty() {        return new EnumeratedProperty<>("testEnumerations",                                        "Test enumerations with complex types",                                        KEYS,                                        VALUES, 0, Foo.class,                                        1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations",                                             "Test enumerations with complex types",                                             KEYS,                                             VALUES,                                             new int[] {0, 1}, Foo.class, 1.0f);    }    @Test(expected = IllegalArgumentException.class)    public void testDefaultIndexOutOfBounds() {        new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                                KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Test(expected = IllegalArgumentException.class)    public void testNoMappingForDefault() {        new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                      MAPPINGS, Collections.singletonList(Foo.IGNORED), Foo.class, 1.0f);    }    @Test    public void creationTest() {        PropertyDescriptor<Foo> prop = createProperty();        PropertyDescriptor<List<Foo>> multi = createMultiProperty();        for (Map.Entry<String, Foo> e : MAPPINGS.entrySet()) {            assertEquals(e.getValue(), prop.valueFrom(e.getKey()));            assertTrue(multi.valueFrom(e.getKey()).contains(e.getValue()));        }    }    @Override    protected Foo createValue() {        return randomChoice(VALUES);    }    @Override    protected Foo createBadValue() {        return Foo.IGNORED; // not in the set of values    }    @Override    protected PropertyDescriptor<Foo> createBadProperty() {        return new EnumeratedProperty<>("testEnumerations", "Test enumerations with simple type",                                        new String[0], VALUES, -1, Foo.class, 1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createBadMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                             KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Override    @Test    public void testFactorySingleValue() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    @Override    @Test    public void testFactoryMultiValueCustomDelimiter() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    @Override    @Test    public void testFactoryMultiValueDefaultDelimiter() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    enum Foo {        BAR, NA, BEE, COO, IGNORED    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd.token.internal;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.Collections;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;import org.junit.Test;import net.sourceforge.pmd.lang.TokenManager;import net.sourceforge.pmd.lang.ast.GenericToken;public class BaseTokenFilterTest {    class StringToken implements GenericToken {        private final String text;        StringToken(final String text) {            this.text = text;        }        @Override        public GenericToken getNext() {            return null;        }        @Override        public GenericToken getPreviousComment() {            return null;        }        @Override        public String getImage() {            return text;        }        @Override        public int getBeginLine() {            return 0;        }        @Override        public int getEndLine() {            return 0;        }        @Override        public int getBeginColumn() {            return 0;        }        @Override        public int getEndColumn() {            return 0;        }        @Override        public int getKind() {            return 0;        }    }    class StringTokenManager implements TokenManager {        Iterator<String> iterator = Collections.unmodifiableList(Arrays.asList("a", "b", "c")).iterator();        @Override        public Object getNextToken() {            if (iterator.hasNext()) {                return new StringToken(iterator.next());            } else {                return null;            }        }        @Override        public void setFileName(final String fileName) {        }    }    class DummyTokenFilter<T extends GenericToken> extends BaseTokenFilter<T> {        Iterable<T> remainingTokens;        DummyTokenFilter(final TokenManager tokenManager) {            super(tokenManager);        }        @Override        protected boolean shouldStopProcessing(final T currentToken) {            return currentToken == null;        }        @Override        protected void analyzeTokens(final T currentToken, final Iterable<T> remainingTokens) {            this.remainingTokens = remainingTokens;        }        public Iterable getRemainingTokens() {            return remainingTokens;        }    }    @Test    public void testRemainingTokensFunctionality1() {        final TokenManager tokenManager = new StringTokenManager();        final DummyTokenFilter tokenFilter = new DummyTokenFilter(tokenManager);        final GenericToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator it1 = iterable.iterator();        final Iterator it2 = iterable.iterator();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValFirstIt = (StringToken) it1.next();        final StringToken firstValSecondIt = (StringToken) it2.next();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken secondValFirstIt = (StringToken) it1.next();        assertFalse(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken secondValSecondIt = (StringToken) it2.next();        assertFalse(it2.hasNext());        assertEquals("b", firstValFirstIt.getImage());        assertEquals("b", firstValSecondIt.getImage());        assertEquals("c", secondValFirstIt.getImage());        assertEquals("c", secondValSecondIt.getImage());    }    @Test    public void testRemainingTokensFunctionality2() {        final TokenManager tokenManager = new StringTokenManager();        final DummyTokenFilter tokenFilter = new DummyTokenFilter(tokenManager);        final GenericToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator it1 = iterable.iterator();        final Iterator it2 = iterable.iterator();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValFirstIt = (StringToken) it1.next();        assertTrue(it1.hasNext());        final StringToken secondValFirstIt = (StringToken) it1.next();        assertFalse(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValSecondIt = (StringToken) it2.next();        assertTrue(it2.hasNext());        final StringToken secondValSecondIt = (StringToken) it2.next();        assertFalse(it2.hasNext());        assertEquals("b", firstValFirstIt.getImage());        assertEquals("b", firstValSecondIt.getImage());        assertEquals("c", secondValFirstIt.getImage());        assertEquals("c", secondValSecondIt.getImage());    }    @Test(expected = NoSuchElementException.class)    public void testRemainingTokensFunctionality3() {        final TokenManager tokenManager = new StringTokenManager();        final DummyTokenFilter tokenFilter = new DummyTokenFilter(tokenManager);        final GenericToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator it1 = iterable.iterator();        final Iterator it2 = iterable.iterator();        it1.next();        it1.next();        it2.next();        it2.next();        it1.next();    }    @Test(expected = ConcurrentModificationException.class)    public void testRemainingTokensFunctionality4() {        final TokenManager tokenManager = new StringTokenManager();        final DummyTokenFilter tokenFilter = new DummyTokenFilter(tokenManager);        final GenericToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator it1 = iterable.iterator();        final GenericToken secondToken = tokenFilter.getNextToken();        assertEquals("b", secondToken.getImage());        it1.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertTrue;import org.junit.Test;public class LanguageFactoryTest {    @Test    public void testSimple() {        assertTrue(LanguageFactory.createLanguage("Cpddummy") instanceof CpddummyLanguage);        assertTrue(LanguageFactory.createLanguage("not_existing_language") instanceof AnyLanguage);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Iterator;import org.junit.Test;public class MatchTest {    @Test    public void testSimple() {        int lineCount1 = 10;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount1, codeFragment1);        int lineCount2 = 20;        String codeFragment2 = "code fragment 2";        Mark mark2 = createMark("class", "/var/Foo.java", 1, lineCount2, codeFragment2);        Match match = new Match(1, mark1, mark2);        assertEquals(1, match.getTokenCount());        // Returns the line count of the first mark        assertEquals(lineCount1, match.getLineCount());        // Returns the source code of the first mark        assertEquals(codeFragment1, match.getSourceCodeSlice());        Iterator<Mark> i = match.iterator();        Mark occurrence1 = i.next();        Mark occurrence2 = i.next();        assertFalse(i.hasNext());        assertEquals(mark1, occurrence1);        assertEquals(lineCount1, occurrence1.getLineCount());        assertEquals(codeFragment1, occurrence1.getSourceCodeSlice());        assertEquals(mark2, occurrence2);        assertEquals(lineCount2, occurrence2.getLineCount());        assertEquals(codeFragment2, occurrence2.getSourceCodeSlice());    }    @Test    public void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1),                new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MatchTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.File;import java.io.StringWriter;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import javax.xml.transform.ErrorListener;import javax.xml.transform.Templates;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;public class CpdXsltTest {    /* Sample ant build.xml file. Run with "ant cpdxsl".<project>  <target name="cpdxslt">    <xslt in="src/test/resources/net/sourceforge/pmd/cpd/SampleCpdReport.xml" style="etc/xslt/cpdhtml.xslt" out="cpd.html" />  </target></project>     */    @Test    public void cpdhtml() throws Exception {        XSLTErrorListener errorListener = new XSLTErrorListener();        // note: using the default JDK factory, otherwise we would use Saxon from PMD's classpath        // which supports more xslt features.        TransformerFactory factory = TransformerFactory                .newInstance("com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl", null);        factory.setErrorListener(errorListener);        StreamSource xslt = new StreamSource(new File("etc/xslt/cpdhtml.xslt"));        Templates template = factory.newTemplates(xslt);        StreamSource cpdReport = new StreamSource(CpdXsltTest.class.getResourceAsStream("SampleCpdReport.xml"));        StreamResult result = new StreamResult(new StringWriter());        Transformer transformer = template.newTransformer();        transformer.setErrorListener(errorListener);        transformer.transform(cpdReport, result);        String expected = IOUtils.toString(CpdXsltTest.class.getResourceAsStream("ExpectedCpdHtmlReport.html"), StandardCharsets.UTF_8);        Assert.assertEquals(expected, result.getWriter().toString());        Assert.assertTrue("XSLT errors occured: " + errorListener, errorListener.hasNoErrors());    }    private static class XSLTErrorListener implements ErrorListener {        final List<TransformerException> errors = new ArrayList<>();        @Override        public void warning(TransformerException exception) throws TransformerException {            errors.add(exception);        }        @Override        public void fatalError(TransformerException exception) throws TransformerException {            errors.add(exception);        }        @Override        public void error(TransformerException exception) throws TransformerException {            errors.add(exception);        }        public boolean hasNoErrors() {            return errors.isEmpty();        }        @Override        public String toString() {            return errors.toString();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.cpd.SourceCode.FileCodeLoader;public class SourceCodeTest {    private static final String BASE_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String SAMPLE_CODE = "Line 1\n" + "Line 2\n" + "Line 3\n" + "Line 4\n";    @Test    public void testSlice() {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(SAMPLE_CODE, "Foo.java"));        assertEquals("Foo.java", sourceCode.getFileName());        assertEquals("Line 1", sourceCode.getSlice(1, 1));        assertEquals("Line 2", sourceCode.getSlice(2, 2));        assertEquals("Line 1\nLine 2", sourceCode.getSlice(1, 2));        sourceCode.getCodeBuffer(); // load into soft reference, must not change behavior        assertEquals("Line 1\nLine 2", sourceCode.getSlice(1, 2));    }    @Test    public void testEncodingDetectionFromBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(new File(BASE_RESOURCE_PATH + "file_with_utf8_bom.java"),                "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("UTF-8", loader.getEncoding());    }    @Test    public void testEncodingIsNotChangedWhenThereIsNoBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(                new File(BASE_RESOURCE_PATH + "file_with_ISO-8859-1_encoding.java"), "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("ISO-8859-1", loader.getEncoding());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.rules.TestRule;public class CPDCommandLineInterfaceTest {    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @Rule    public final SystemOutRule log = new SystemOutRule().enableLog();    @Test    public void testEmptyResultRendering() {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPDCommandLineInterface.main(new String[] { "--minimum-tokens", "340", "--language", "java", "--files",            "src/test/resources/net/sourceforge/pmd/cpd/files/", "--format", "xml", });        Assert.assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "\n" + "<pmd-cpd/>", log.getLog());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.HashMap;import java.util.Map;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;public class CPDConfigurationTest {    @Test    public void testRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            Renderer r = CPDConfiguration.getRendererFromString(entry.getKey(), "UTF-8");            Assert.assertNotNull(r);            Assert.assertSame(entry.getValue(), r.getClass());        }    }    @Test    public void testCPDRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            CPDRenderer r = CPDConfiguration.getCPDRendererFromString(entry.getKey(), "UTF-8");            Assert.assertNotNull(r);            Assert.assertSame(entry.getValue(), r.getClass());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import org.junit.Test;/** * @author Philippe T'Seyen */public class FileReporterTest {    @Test    public void testCreation() {        new FileReporter((String) null);        new FileReporter((File) null);    }    @Test    public void testEmptyReport() throws ReportException {        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");        assertTrue(reportFile.exists());        assertEquals(0L, reportFile.length());        assertTrue(reportFile.delete());    }    @Test    public void testReport() throws ReportException, IOException {        String testString = "first line\nsecond line";        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report(testString);        assertEquals(testString, readFile(reportFile));        assertTrue(reportFile.delete());    }    @Test(expected = ReportException.class)    public void testInvalidFile() throws ReportException {        File reportFile = new File("/invalid_folder/report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");    }    private String readFile(File file) throws IOException {        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {            StringBuilder buffer = new StringBuilder();            String line = reader.readLine();            while (line != null) {                buffer.append(line);                line = reader.readLine();                if (line != null) {                    buffer.append('\n');                }            }            return buffer.toString();        }    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(FileReporterTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;public class AnyTokenizerTest {    @Test    public void testMultiLineMacros() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        compareResult(tokenizer, TEST1, EXPECTED);    }    @Test    public void testStringEscape() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        compareResult(tokenizer, "a = \"oo\\n\"", listOf("a", "=", "\"oo\\n\"", "EOF"));    }    @Test    public void testMultilineString() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        Tokens tokens = compareResult(tokenizer, "a = \"oo\n\";", listOf("a", "=", "\"oo\n\"", ";", "EOF"));        TokenEntry string = tokens.getTokens().get(2);        assertEquals("\"oo\n\"", getTokenImage(string));        assertEquals(1, string.getBeginLine());        assertEquals(5, string.getBeginColumn());        assertEquals(1, string.getEndColumn()); // ends on line 2        TokenEntry semi = tokens.getTokens().get(3);        assertEquals(";", getTokenImage(semi));        assertEquals(2, semi.getBeginLine());        assertEquals(2, semi.getBeginColumn());        assertEquals(2, semi.getEndColumn());    }    /**     * Tests that [core][cpd] AnyTokenizer doesn't count columns correctly #2760 is actually fixed.     */    @Test    public void testTokenPosition() {        AnyTokenizer tokenizer = new AnyTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader("a;\nbbbb\n;"));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        TokenEntry bbbbToken = tokens.getTokens().get(2);        assertEquals(2, bbbbToken.getBeginLine());        assertEquals(1, bbbbToken.getBeginColumn());        assertEquals(4, bbbbToken.getEndColumn());    }    private Tokens compareResult(AnyTokenizer tokenizer, String source, List<String> expectedImages) {        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(source));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        List<String> tokenStrings = new ArrayList<>();        for (TokenEntry token : tokens.getTokens()) {            tokenStrings.add(getTokenImage(token));        }        assertEquals(expectedImages, tokenStrings);        return tokens;    }    private String getTokenImage(TokenEntry t) {        return t.toString();    }    private static final List<String> EXPECTED = listOf(        "using", "System", ";",        "namespace", "HelloNameSpace", "{",        "public", "class", "HelloWorld", "{", // note: comment is excluded        "static", "void", "Main", "(", "string", "[", "]", "args", ")", "{",        "Console", ".", "WriteLine", "(", "\"Hello World!\"", ")", ";",        "}", "}", "}", "EOF"    );    private static final String TEST1 =        "using System;\n"            + "namespace HelloNameSpace {\n"            + "\n"            + "    public class HelloWorld { // A comment\n"            + "        static void Main(string[] args) {\n"            + "\n"            + "            Console.WriteLine(\"Hello World!\");\n"            + "        }\n"            + "    }\n"            + "\n"            + "}\n";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;public class CSVRendererTest {    @Test    public void testLineCountPerFile() throws IOException {        CPDRenderer renderer = new CSVRenderer(true);        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "tokens,occurrences" + PMD.EOL + "75,2,48,10,/var/Foo.java,73,20,/var/Bar.java"                + PMD.EOL;        assertEquals(expectedReport, report);    }    @Test    public void testFilenameEscapes() throws IOException {        CPDRenderer renderer = new CSVRenderer();        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var,with,commas/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var,with,commas/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "lines,tokens,occurrences" + PMD.EOL                + "10,75,2,48,\"/var,with,commas/Foo.java\",73,\"/var,with,commas/Bar.java\"" + PMD.EOL;        assertEquals(expectedReport, report);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader;public class MarkTest {    @Test    public void testSimple() {        String filename = "/var/Foo.java";        int beginLine = 1;        TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1);        Mark mark = new Mark(token);        int lineCount = 10;        mark.setLineCount(lineCount);        String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(-1, mark.getBeginColumn());        assertEquals(-1, mark.getEndColumn());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }    @Test    public void testColumns() {        final String filename = "/var/Foo.java";        final int beginLine = 1;        final int beginColumn = 2;        final int endColumn = 3;        final TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1, beginColumn, beginColumn + "public".length());        final TokenEntry endToken = new TokenEntry("}", "/var/Foo.java", 5, endColumn - 1, endColumn);        final Mark mark = new Mark(token);        final int lineCount = 10;        mark.setLineCount(lineCount);        mark.setEndToken(endToken);        final String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(beginColumn, mark.getBeginColumn());        assertEquals(endColumn, mark.getEndColumn());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MarkTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.io.FilenameUtils;import org.junit.Test;public class CPDFilelistTest {    @Test    public void testFilelist() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);        List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(FilenameUtils.getName(path));        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }    @Test    public void testFilelistMultipleLines() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist2.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);        List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(FilenameUtils.getName(path));        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;public class TokenEntryTest {    @Test    public void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());        assertEquals(-1, mark.getBeginColumn());        assertEquals(-1, mark.getEndColumn());    }    @Test    public void testColumns() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1, 2, 3);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());        assertEquals(2, mark.getBeginColumn());        assertEquals(3, mark.getEndColumn());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(TokenEntryTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import javax.xml.parsers.DocumentBuilderFactory;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;/** * @author Philippe T'Seyen * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class XMLRendererTest {    private static final String ENCODING = (String) System.getProperties().get("file.encoding");    private static final String FORM_FEED = "\u000C"; // this character is invalid in XML 1.0 documents    private static final String FORM_FEED_ENTITY = "&#12;"; // this is also not allowed in XML 1.0 documents    @Test    public void testWithNoDuplication() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList nodes = doc.getChildNodes();            Node n = nodes.item(0);            assertEquals("pmd-cpd", n.getNodeName());            assertEquals(0, doc.getElementsByTagName("duplication").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testWithOneDuplication() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList dupes = doc.getElementsByTagName("duplication");            assertEquals(1, dupes.getLength());            Node file = dupes.item(0).getFirstChild();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            if (file != null) {                assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());                assertEquals("6", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals(null, file.getAttributes().getNamedItem("column"));                assertEquals(null, file.getAttributes().getNamedItem("endcolumn"));                file = file.getNextSibling();                while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                    file = file.getNextSibling();                }            }            if (file != null) {                assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("78", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals(null, file.getAttributes().getNamedItem("column"));                assertEquals(null, file.getAttributes().getNamedItem("endcolumn"));            }            assertEquals(1, doc.getElementsByTagName("codefragment").getLength());            assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testRenderWithMultipleMatch() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount1 = 6;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, lineCount1, codeFragment1);        Mark mark2 = createMark("void", "/var/Foo.java", 73, lineCount1, codeFragment1);        Match match1 = new Match(75, mark1, mark2);        int lineCount2 = 7;        String codeFragment2 = "code fragment 2";        Mark mark3 = createMark("void", "/var/Foo2.java", 49, lineCount2, codeFragment2);        Mark mark4 = createMark("stuff", "/var/Foo2.java", 74, lineCount2, codeFragment2);        Match match2 = new Match(76, mark3, mark4);        list.add(match1);        list.add(match2);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            assertEquals(2, doc.getElementsByTagName("duplication").getLength());            assertEquals(4, doc.getElementsByTagName("file").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testWithOneDuplicationWithColumns() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment, 2, 3);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment, 4, 5);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList dupes = doc.getElementsByTagName("duplication");            assertEquals(1, dupes.getLength());            Node file = dupes.item(0).getFirstChild();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            if (file != null) {                assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());                assertEquals("6", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals("2", file.getAttributes().getNamedItem("column").getNodeValue());                assertEquals("3", file.getAttributes().getNamedItem("endcolumn").getNodeValue());                file = file.getNextSibling();                while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                    file = file.getNextSibling();                }            }            if (file != null) {                assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("78", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals("4", file.getAttributes().getNamedItem("column").getNodeValue());                assertEquals("5", file.getAttributes().getNamedItem("endcolumn").getNodeValue());            }            assertEquals(1, doc.getElementsByTagName("codefragment").getLength());            assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testRendererEncodedPath() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        final String espaceChar = "&lt;";        Mark mark1 = createMark("public", "/var/A<oo.java" + FORM_FEED, 48, 6, "code fragment");        Mark mark2 = createMark("void", "/var/B<oo.java", 73, 6, "code fragment");        Match match1 = new Match(75, mark1, mark2);        list.add(match1);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertTrue(report.contains(espaceChar));        assertFalse(report.contains(FORM_FEED));        assertFalse(report.contains(FORM_FEED_ENTITY));    }    @Test    public void testRendererXMLEscaping() throws IOException {        String codefragment = "code fragment" + FORM_FEED + "\nline2\nline3\nno & escaping necessary in CDATA\nx=\"]]>\";";        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        Mark mark1 = createMark("public", "file1", 1, 5, codefragment);        Mark mark2 = createMark("public", "file2", 5, 5, codefragment);        Match match1 = new Match(75, mark1, mark2);        list.add(match1);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertFalse(report.contains(FORM_FEED));        assertFalse(report.contains(FORM_FEED_ENTITY));        assertTrue(report.contains("no & escaping necessary in CDATA"));        assertFalse(report.contains("x=\"]]>\";")); // must be escaped        assertTrue(report.contains("x=\"]]]]><![CDATA[>\";"));    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code, int beginColumn, int endColumn) {        final TokenEntry beginToken = new TokenEntry(image, tokenSrcID, beginLine, beginColumn, beginColumn + 1);        final TokenEntry endToken = new TokenEntry(image, tokenSrcID, beginLine + lineCount, endColumn - 1, endColumn);        final Mark result = new Mark(beginToken);        result.setLineCount(lineCount);        result.setEndToken(endToken);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.File;import java.util.Iterator;import org.apache.commons.lang3.SystemUtils;import org.junit.Assert;import org.junit.Assume;import org.junit.Before;import org.junit.Test;/** * Unit test for {@link CPD} */public class CPDTest {    private static final String BASE_TEST_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String TARGET_TEST_RESOURCE_PATH = "target/classes/net/sourceforge/pmd/cpd/files/";    private CPD cpd;    // Symlinks are not well supported under Windows - so the tests are    // simply executed only on linux.    private boolean canTestSymLinks = SystemUtils.IS_OS_UNIX;    @Before    public void setup() throws Exception {        CPDConfiguration theConfiguration = new CPDConfiguration();        theConfiguration.setLanguage(new AnyLanguage("any"));        theConfiguration.setMinimumTileSize(10);        theConfiguration.postContruct();        cpd = new CPD(theConfiguration);    }    /**     * As java doesn't support symlinks in zip files, maven does not, too. So,     * we are creating the symlinks manually here before the test.     *     * @throws Exception     *             any error     */    private void prepareSymLinks() throws Exception {        Assume.assumeTrue("Skipping unit tests with symlinks.", canTestSymLinks);        Runtime runtime = Runtime.getRuntime();        if (!new File(TARGET_TEST_RESOURCE_PATH, "symlink-for-real-file.txt").exists()) {            runtime.exec(new String[] { "ln", "-s", BASE_TEST_RESOURCE_PATH + "real-file.txt",                TARGET_TEST_RESOURCE_PATH + "symlink-for-real-file.txt", }).waitFor();        }        if (!new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test").exists()) {            runtime.exec(new String[] { "ln", "-s", "broken-sym-link",                TARGET_TEST_RESOURCE_PATH + "this-is-a-broken-sym-link-for-test", }).waitFor();        }    }    /**     * A broken symlink (which is basically a not existing file), should be     * skipped.     *     * @throws Exception     *             any error     */    @Test    public void testFileSectionWithBrokenSymlinks() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(0);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test"));        listener.verify();    }    /**     * A file should be added only once - even if it was found twice, because of     * a sym link.     *     * @throws Exception     *             any error     */    @Test    public void testFileAddedAsSymlinkAndReal() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "real-file.txt"));        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "symlink-for-real-file.txt"));        listener.verify();    }    /**     * Add a file with a relative path - should still be added and not be     * detected as a sym link.     *     * @throws Exception     *             any error     */    @Test    public void testFileAddedWithRelativePath() throws Exception {        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "real-file.txt"));        listener.verify();    }    /**     * The order of the duplicates is dependent on the order the files are added to CPD.     * See also https://github.com/pmd/pmd/issues/1196     * @throws Exception     */    @Test    public void testFileOrderRelevance() throws Exception {        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup2.java"));        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup1.java"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        while (matches.hasNext()) {            Match match = matches.next();            // the file added first was dup2.            Assert.assertTrue(match.getFirstMark().getFilename().endsWith("dup2.java"));            Assert.assertTrue(match.getSecondMark().getFilename().endsWith("dup1.java"));        }    }    /**     * Simple listener that fails, if too many files were added and not skipped.     */    private static class NoFileAssertListener implements CPDListener {        private int expectedFilesCount;        private int files;        NoFileAssertListener(int expectedFilesCount) {            this.expectedFilesCount = expectedFilesCount;            this.files = 0;        }        @Override        public void addedFile(int fileCount, File file) {            files++;            if (files > expectedFilesCount) {                Assert.fail("File was added! - " + file);            }        }        @Override        public void phaseUpdate(int phase) {            // not needed for this test        }        public void verify() {            Assert.assertEquals("Expected " + expectedFilesCount + " files, but " + files + " have been added.",                    expectedFilesCount, files);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.fail;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.BuildFileRule;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;public class PMDTaskTest {    @Rule    public final BuildFileRule buildRule = new BuildFileRule();    @Before    public void setUp() {        buildRule.configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/pmdtasktest.xml");    }    @Test    public void testFormatterWithNoToFileAttribute() {        try {            buildRule.executeTarget("testFormatterWithNoToFileAttribute");            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals("toFile or toConsole needs to be specified in Formatter", ex.getMessage());        }    }    @Test    public void testNoRuleSets() {        try {            buildRule.executeTarget("testNoRuleSets");            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals("No rulesets specified", ex.getMessage());        }    }    @Test    public void testBasic() {        buildRule.executeTarget("testBasic");    }    @Test    public void testInvalidLanguageVersion() {        try {            buildRule.executeTarget("testInvalidLanguageVersion");            Assert.assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    buildRule.getLog());            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    ex.getMessage());        }    }    @Test    public void testWithShortFilenames() throws IOException {        buildRule.executeTarget("testWithShortFilenames");        try (InputStream in = new FileInputStream("target/pmd-ant-test.txt")) {            String actual = IOUtils.toString(in, StandardCharsets.UTF_8);            // remove any trailing newline            actual = actual.replaceAll("\n|\r", "");            Assert.assertEquals("sample.dummy:0:\tSampleXPathRule:\tTest Rule 2", actual);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;public class FormatterTest {    @Test    public void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.createRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.createRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.createRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.createRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            f.createRenderer();            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException be) {            assertTrue(be.getMessage().startsWith("Can't find the custom format FAIL"));        }    }    @Test    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isNoOutputSupplied());        f.setToFile(new File("foo"));        assertFalse("Formatter toFile should not be null!", f.isNoOutputSupplied());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertTrue;import java.io.File;import org.apache.tools.ant.BuildFileRule;import org.junit.Before;import org.junit.Rule;import org.junit.Test;/** * * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CPDTaskTest {    @Rule    public final BuildFileRule buildRule = new BuildFileRule();    @Before    public void setUp() {        buildRule.configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/cpdtasktest.xml");    }    @Test    public void testBasic() {        buildRule.executeTarget("testBasic");        // FIXME: This clearly needs to be improved - but I don't like to write        // test, so feel free to contribute :)        assertTrue(new File("target/cpd.ant.tests").exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator;public class AttributeAxisIteratorTest {    @Test(expected = UnsupportedOperationException.class)    public void testRemove() {        DummyNode n = new DummyNode(0);        n.testingOnlySetBeginColumn(1);        n.testingOnlySetBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        iter.remove();    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AttributeAxisIteratorTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import static org.junit.Assert.assertEquals;import java.lang.reflect.Method;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.Attribute;public class AttributeTest {    @Test    public void testConstructor() {        DummyNode p = new DummyNode(1);        p.testingOnlySetBeginLine(5);        Method[] methods = p.getClass().getMethods();        Method m = null;        for (int i = 0; i < methods.length; i++) {            if (methods[i].getName().equals("getBeginLine")) {                m = methods[i];                break;            }        }        Attribute a = new Attribute(p, "BeginLine", m);        assertEquals("BeginLine", a.getName());        assertEquals(5, a.getValue());        assertEquals("5", a.getStringValue());        assertEquals(p, a.getParent());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AttributeTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.jaxen.Context;import org.jaxen.FunctionCallException;import org.junit.Test;import net.sourceforge.pmd.lang.ast.AbstractNode;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.lang.xpath.MatchesFunction;public class MatchesFunctionTest {    public static class MyNode extends AbstractNode {        private String className;        public MyNode() {            super(1);        }        @Override        public String toString() {            return "MyNode";        }        public void setClassName(String className) {            this.className = className;        }        public String getClassName() {            return className;        }        @Override        public String getXPathNodeName() {            return "MyNode";        }    }    @Test    public void testMatch() throws FunctionCallException, NoSuchMethodException {        MyNode myNode = new MyNode();        myNode.setClassName("Foo");        assertTrue(tryRegexp(myNode, "Foo") instanceof List);    }    @Test    public void testNoMatch() throws FunctionCallException, NoSuchMethodException {        MyNode myNode = new MyNode();        myNode.setClassName("bar");        assertTrue(tryRegexp(myNode, "Foo") instanceof Boolean);        myNode.setClassName("FobboBar");        assertTrue(tryRegexp(myNode, "Foo") instanceof Boolean);    }    private Object tryRegexp(MyNode myNode, String exp) throws FunctionCallException, NoSuchMethodException {        MatchesFunction function = new MatchesFunction();        List<Object> list = new ArrayList<>();        List<Attribute> attrs = new ArrayList<>();        attrs.add(new Attribute(myNode, "matches", myNode.getClass().getMethod("getClassName", new Class[0])));        list.add(attrs);        list.add(exp);        Context c = new Context(null);        c.setNodeSet(new ArrayList<>());        return function.call(c, list);    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MatchesFunctionTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RulePriority;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class SarifRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new SarifRenderer();    }    @Override    public String getExpected() {        return readFile("expected.sarif.json");    }    @Override    public String getExpectedEmpty() {        return readFile("empty.sarif.json");    }    @Override    public String getExpectedMultiple() {        return readFile("expected-multiple.sarif.json");    }    @Override    public String getExpectedError(Report.ProcessingError error) {        String expected = readFile("expected-error.sarif.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    public String getExpectedError(Report.ConfigurationError error) {        return readFile("expected-configerror.sarif.json");    }    @Override    public String getExpectedErrorWithoutMessage(Report.ProcessingError error) {        String expected = readFile("expected-error-nomessage.sarif.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    public String filter(String expected) {        return expected.replaceAll("\r\n", "\n"); // make the test run on Windows, too    }    @Override    @Test    public void testRendererMultiple() throws Exception {        // Setup        Report rep = reportTwoViolations();        // Exercise        String actual = ReportTest.render(getRenderer(), rep);        // Verify that both rules are and rule ids are linked in the results         // Initially was comparing whole files but order of rules rendered can't be guaranteed when the report is being rendered        // Refer to pmd-core/src/test/resources/net/sourceforge/pmd/renderers/sarif/expected-multiple.sarif.json to see an example data structure        assertThat(filter(actual), containsString("\"ruleId\": \"Foo\""));        assertThat(filter(actual), containsString("\"ruleId\": \"Boo\""));        assertThat(filter(actual), containsString("\"id\": \"Foo\""));        assertThat(filter(actual), containsString("\"id\": \"Boo\""));    }    private Report reportTwoViolations() {        Report report = new Report();        RuleViolation informationalRuleViolation = newRuleViolation(1, "Foo");        informationalRuleViolation.getRule().setPriority(RulePriority.LOW);        report.addRuleViolation(informationalRuleViolation);        RuleViolation severeRuleViolation = newRuleViolation(2, "Boo");        severeRuleViolation.getRule().setPriority(RulePriority.HIGH);        report.addRuleViolation(severeRuleViolation);        return report;    }    private RuleViolation newRuleViolation(int endColumn, String ruleName) {        DummyNode node = createNode(endColumn);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        AbstractRule fooRule = new FooRule();        fooRule.setName(ruleName);        return new ParametricRuleViolation<Node>(fooRule, ctx, node, "blah");    }    private String readFile(String name) {        try (InputStream in = SarifRendererTest.class.getResourceAsStream("sarif/" + name)) {            String asd = IOUtils.toString(in, StandardCharsets.UTF_8);            return asd;        } catch (IOException e) {            throw new RuntimeException(e);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.XPathRule;public class CodeClimateRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new CodeClimateRenderer();    }    @Override    public String getExpected() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    public String getExpectedWithProperties() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "multiString | default1,default2 | multi string property\\n"                + "stringProperty | the string value\\nsecond line with 'quotes' | simple string property\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL + "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: High\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"blocker\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Test    public void testXPathRule() throws Exception {        DummyNode node = createNode(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        Report report = new Report();        XPathRule theRule = new XPathRule();        theRule.setProperty(XPathRule.XPATH_DESCRIPTOR, "//dummyNode");        // Setup as FooRule        theRule.setDescription("desc");        theRule.setName("Foo");        report.addRuleViolation(new ParametricRuleViolation<Node>(theRule, ctx, node, "blah"));        String rendered = ReportTest.render(getRenderer(), report);        // Output should be the exact same as for non xpath rules        assertEquals(filter(getExpected()), filter(rendered));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.IOException;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;public class HTMLRendererTest extends AbstractRendererTest {    @Override    protected String getSourceCodeFilename() {        return "someFilename<br>thatNeedsEscaping.ext";    }    private String getEscapedFilename() {        return "someFilename&lt;br&gt;thatNeedsEscaping.ext";    }    @Override    public Renderer getRenderer() {        return new HTMLRenderer();    }    @Override    public String getExpected() {        return getExpected(null, null);    }    private String getExpected(String linkPrefix, String lineAnchor) {        String filename = getEscapedFilename();        if (linkPrefix != null) {            filename = "<a href=\"" + linkPrefix + filename + "#" + lineAnchor + "\">"                    + filename + "</a>";        }        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + filename + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader()                + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "<tr> " + PMD.EOL                + "<td align=\"center\">2</td>" + PMD.EOL + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader()                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>file</td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader()                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    private String getHeader() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL;    }    @Test    public void testLinkPrefix() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        final String linePrefix = "L";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        renderer.setProperty(HTMLRenderer.LINE_PREFIX, linePrefix);        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        Report rep = reportOneViolation();        String actual = ReportTest.render(renderer, rep);        assertEquals(filter(getExpected(linkPrefix, "L1")), filter(actual));    }    @Test    public void testLinePrefixNotSet() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        // dont set line prefix renderer.setProperty(HTMLRenderer.LINE_PREFIX, linePrefix);        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        Report rep = reportOneViolation();        String actual = ReportTest.render(renderer, rep);        assertEquals(filter(getExpected(linkPrefix, "")), filter(actual));    }    @Test    public void testEmptyLinePrefix() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        renderer.setProperty(HTMLRenderer.LINE_PREFIX, "");        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        Report rep = reportOneViolation();        String actual = ReportTest.render(renderer, rep);        assertEquals(filter(getExpected(linkPrefix, "1")), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RulePriority;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.RuleWithProperties;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public abstract class AbstractRendererTest {    public abstract Renderer getRenderer();    public abstract String getExpected();    public String getExpectedWithProperties() {        return getExpected();    }    public abstract String getExpectedEmpty();    public abstract String getExpectedMultiple();    public String getExpectedError(ProcessingError error) {        return "";    }    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return getExpectedError(error);    }    public String getExpectedError(ConfigurationError error) {        return "";    }    public String filter(String expected) {        return expected;    }    protected String getSourceCodeFilename() {        return "notAvailable.ext";    }    @Test(expected = NullPointerException.class)    public void testNullPassedIn() throws Exception {        getRenderer().renderFileReport(null);    }    protected Report reportOneViolation() {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1));        return report;    }    private Report reportTwoViolations() {        Report report = new Report();        RuleViolation informationalRuleViolation = newRuleViolation(1);        informationalRuleViolation.getRule().setPriority(RulePriority.LOW);        report.addRuleViolation(informationalRuleViolation);        RuleViolation severeRuleViolation = newRuleViolation(2);        severeRuleViolation.getRule().setPriority(RulePriority.HIGH);        report.addRuleViolation(severeRuleViolation);        return report;    }    protected RuleViolation newRuleViolation(int endColumn) {        DummyNode node = createNode(endColumn);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        return new ParametricRuleViolation<Node>(new FooRule(), ctx, node, "blah");    }    protected static DummyNode createNode(int endColumn) {        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        node.testingOnlySetEndLine(1);        node.testingOnlySetEndColumn(endColumn);        return node;    }    @Test    public void testRuleWithProperties() throws Exception {        DummyNode node = createNode(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        Report report = new Report();        RuleWithProperties theRule = new RuleWithProperties();        theRule.setProperty(RuleWithProperties.STRING_PROPERTY_DESCRIPTOR,                "the string value\nsecond line with \"quotes\"");        report.addRuleViolation(new ParametricRuleViolation<Node>(theRule, ctx, node, "blah"));        String rendered = ReportTest.render(getRenderer(), report);        assertEquals(filter(getExpectedWithProperties()), filter(rendered));    }    @Test    public void testRenderer() throws Exception {        Report rep = reportOneViolation();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpected()), filter(actual));    }    @Test    public void testRendererEmpty() throws Exception {        Report rep = new Report();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedEmpty()), filter(actual));    }    @Test    public void testRendererMultiple() throws Exception {        Report rep = reportTwoViolations();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedMultiple()), filter(actual));    }    @Test    public void testError() throws Exception {        Report rep = new Report();        Report.ProcessingError err = new Report.ProcessingError(new RuntimeException("Error"), "file");        rep.addError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedError(err)), filter(actual));    }    @Test    public void testErrorWithoutMessage() throws Exception {        Report rep = new Report();        Report.ProcessingError err = new Report.ProcessingError(new NullPointerException(), "file");        rep.addError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedErrorWithoutMessage(err)), filter(actual));    }    @Test    public void testConfigError() throws Exception {        Report rep = new Report();        Report.ConfigurationError err = new Report.ConfigurationError(new FooRule(), "a configuration error");        rep.addConfigError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedError(err)), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class IDEAJRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        Renderer result = new IDEAJRenderer();        result.setProperty(IDEAJRenderer.SOURCE_PATH, "");        result.setProperty(IDEAJRenderer.CLASS_AND_METHOD_NAME, "Foo <init>");        result.setProperty(IDEAJRenderer.FILE_NAME, "Foo.java");        return result;    }    @Override    public String getExpected() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL + "blah" + PMD.EOL                + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class TextPadRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new TextPadRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL + getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(TextPadRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.FileNotFoundException;import java.io.Reader;import java.io.StringReader;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class PapariTextRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        TextColorRenderer result = new TextColorRenderer() {            @Override            protected Reader getReader(String sourceFile) throws FileNotFoundException {                return new StringReader("public class Foo {}");            }        };        result.setProperty(TextColorRenderer.COLOR, "false");        return result;    }    @Override    public String getExpected() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL                + "Summary:" + PMD.EOL + PMD.EOL + " : 1" + PMD.EOL + "* warnings: 1" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + "    src:  "                + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL + "    msg:  blah" + PMD.EOL                + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL                + PMD.EOL + " : 2" + PMD.EOL + "* warnings: 2" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  RuntimeException: Error" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  NullPointerException: null" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* rule: Foo" + PMD.EOL                + "    err:  a configuration error" + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(PapariTextRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class XSLTRendererTest {    @Test    public void testDefaultStylesheet() throws Exception {        XSLTRenderer renderer = new XSLTRenderer();        Report report = new Report();        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        RuleViolation rv = new ParametricRuleViolation<Node>(new FooRule(), new RuleContext(), node,                "violation message");        report.addRuleViolation(rv);        String result = ReportTest.render(renderer, report);        Assert.assertTrue(result.contains("violation message"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class EmacsRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new EmacsRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL + getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.Map;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;public class JsonRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new JsonRenderer();    }    @Override    public String getExpected() {        return readFile("expected.json");    }    @Override    public String getExpectedEmpty() {        return readFile("empty.json");    }    @Override    public String getExpectedMultiple() {        return readFile("expected-multiple.json");    }    @Override    public String getExpectedError(ProcessingError error) {        String expected = readFile("expected-processingerror.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    public String getExpectedError(ConfigurationError error) {        return readFile("expected-configurationerror.json");    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        String expected = readFile("expected-processingerror-no-message.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    private String readFile(String name) {        try (InputStream in = JsonRendererTest.class.getResourceAsStream("json/" + name)) {            return IOUtils.toString(in, StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Override    public String filter(String expected) {        String result = expected                .replaceAll("\"timestamp\":\\s*\"[^\"]+\"", "\"timestamp\": \"--replaced--\"")                .replaceAll("\"pmdVersion\":\\s*\"[^\"]+\"", "\"pmdVersion\": \"unknown\"")                .replaceAll("\r\n", "\n"); // make the test run on Windows, too        return result;    }    @Test    public void suppressedViolations() throws IOException {        Report rep = new Report();        Map<Integer, String> suppressedLines = new HashMap<>();        suppressedLines.put(1, "test");        rep.suppress(suppressedLines);        rep.addRuleViolation(newRuleViolation(1));        String actual = ReportTest.render(getRenderer(), rep);        String expected = readFile("expected-suppressed.json");        Assert.assertEquals(filter(expected), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class VBHTMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new VBHTMLRenderer();    }    @Override    public String getExpected() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL + "--></style><body><center><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL                + "<tr id=RowColor1><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.getFile() + "</font></td><td><font class=body><pre>" + error.getDetail() + "</pre></font></td></tr></table></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Configuration problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.rule().getName() + "</font></td><td><font class=body>" + error.issue() + "</font></td></tr></table></center></body></html>" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VBHTMLRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import org.junit.Test;public class EmptyRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new EmptyRenderer();    }    // Overriding the annotation from the super class, this renderer doesn't care, so no NPE.    @Test    @Override    public void testNullPassedIn() throws Exception {        super.testNullPassedIn();    }    @Override    public String getExpected() {        return "";    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class CSVRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new CSVRenderer();    }    @Override    public String getExpected() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader();    }    @Override    public String getExpectedMultiple() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL                + "\"2\",\"\",\"" + getSourceCodeFilename() + "\",\"1\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader();    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader();    }    private String getHeader() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(CSVRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class TextRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new TextRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL                + getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "file\t-\tRuntimeException: Error" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return "file\t-\tNullPointerException: null" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "Foo\t-\ta configuration error" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.StringReader;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import javax.xml.parsers.DocumentBuilderFactory;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TemporaryFolder;import org.w3c.dom.Document;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDVersion;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class XMLRendererTest extends AbstractRendererTest {    @Rule // Restores system properties after test    public final RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Override    public Renderer getRenderer() {        return new XMLRenderer();    }    @Override    public String getExpected() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader() + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"2\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"1\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"RuntimeException: Error\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"NullPointerException: null\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader() + "<configerror rule=\"Foo\" msg=\"a configuration error\"/>"                + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String filter(String expected) {        String result = expected.replaceAll(" timestamp=\"[^\"]+\">", " timestamp=\"\">");        return result;    }    private RuleViolation createRuleViolation(String description) {        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        node.testingOnlySetEndLine(1);        node.testingOnlySetEndColumn(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        return new ParametricRuleViolation<Node>(new FooRule(), ctx, node, description);    }    private void verifyXmlEscaping(Renderer renderer, String shouldContain, Charset charset) throws Exception {        renderer.setProperty(XMLRenderer.ENCODING, charset.name());        Report report = new Report();        String surrogatePair = "\ud801\udc1c";        String msg = "The String 'literal' \"TokénizĀr " + surrogatePair + "\" appears...";        report.addRuleViolation(createRuleViolation(msg));        String actual = renderTempFile(renderer, report, charset);        Assert.assertTrue(actual.contains(shouldContain));        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new InputSource(new StringReader(actual)));        NodeList violations = doc.getElementsByTagName("violation");        Assert.assertEquals(1, violations.getLength());        Assert.assertEquals(msg, violations.item(0).getTextContent().trim());    }    @Test    public void testXMLEscapingWithUTF8() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "\ud801\udc1c", StandardCharsets.UTF_8);    }    @Test    public void testXMLEscapingWithUTF16() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "&#x1041c;", StandardCharsets.UTF_16);    }    @Test    public void testXMLEscapingWithoutUTF8() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "&#x1041c;", StandardCharsets.ISO_8859_1);    }    public String getHeader() {        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + PMD.EOL                + "<pmd xmlns=\"http://pmd.sourceforge.net/report/2.0.0\""                + " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""                + " xsi:schemaLocation=\"http://pmd.sourceforge.net/report/2.0.0 http://pmd.sourceforge.net/report_2_0_0.xsd\""                + " version=\"" + PMDVersion.VERSION + "\" timestamp=\"2014-10-06T19:30:51.262\">" + PMD.EOL;    }    @Test    public void testCorrectCharset() throws Exception {        System.setProperty("file.encoding", StandardCharsets.ISO_8859_1.name());        Renderer renderer = getRenderer();        Report report = new Report();        String formFeed = "\u000C";        // é = U+00E9 : can be represented in ISO-8859-1 as is        // Ā = U+0100 : cannot be represented in ISO-8859-1 -> would be a unmappable character, needs to be escaped        String specialChars = "éĀ";        String originalChars = formFeed + specialChars; // u000C should be removed, é should be encoded correctly as UTF-8        String msg = "The String literal \"" + originalChars + "\" appears...";        report.addRuleViolation(createRuleViolation(msg));        String actual = renderTempFile(renderer, report, StandardCharsets.UTF_8);        Assert.assertTrue(actual.contains(specialChars));        Assert.assertFalse(actual.contains(formFeed));        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new InputSource(new StringReader(actual)));        NodeList violations = doc.getElementsByTagName("violation");        Assert.assertEquals(1, violations.getLength());        Assert.assertEquals(msg.replaceAll(formFeed, ""), violations.item(0).getTextContent().trim());    }    private String renderTempFile(Renderer renderer, Report report, Charset expectedCharset) throws IOException {        File reportFile = folder.newFile();        renderer.setReportFile(reportFile.getAbsolutePath());        renderer.start();        renderer.renderFileReport(report);        renderer.end();        renderer.flush();        try (FileInputStream input = new FileInputStream(reportFile)) {            return IOUtils.toString(input, expectedCharset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.regex.Pattern;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class YAHTMLRendererTest extends AbstractRendererTest {    private File outputDir;    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Before    public void setUp() throws IOException {        outputDir = folder.newFolder("pmdtest");    }    private RuleViolation newRuleViolation(int endColumn, final String packageNameArg, final String classNameArg) {        DummyNode node = createNode(endColumn);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        return new ParametricRuleViolation<Node>(new FooRule(), ctx, node, "blah") {            {                packageName = packageNameArg;                className = classNameArg;            }        };    }    @Override    protected RuleViolation newRuleViolation(int endColumn) {        return newRuleViolation(endColumn, "net.sf.pmd.test", "YAHTMLSampleClass");    }    @Test    public void testReportMultipleViolations() throws Exception {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1, "net.sf.pmd.test", "YAHTMLSampleClass1"));        report.addRuleViolation(newRuleViolation(2, "net.sf.pmd.test", "YAHTMLSampleClass1"));        report.addRuleViolation(newRuleViolation(1, "net.sf.pmd.other", "YAHTMLSampleClass2"));        String actual = ReportTest.render(getRenderer(), report);        assertEquals(filter(getExpected()), filter(actual));        String[] htmlFiles = outputDir.list();        assertEquals(3, htmlFiles.length);        Arrays.sort(htmlFiles);        assertEquals("YAHTMLSampleClass1.html", htmlFiles[0]);        assertEquals("YAHTMLSampleClass2.html", htmlFiles[1]);        assertEquals("index.html", htmlFiles[2]);        for (String file : htmlFiles) {            try (FileInputStream in = new FileInputStream(new File(outputDir, file));                    InputStream expectedIn = YAHTMLRendererTest.class.getResourceAsStream("yahtml/" + file)) {                String data = IOUtils.toString(in, StandardCharsets.UTF_8);                String expected = normalizeLineSeparators(IOUtils.toString(expectedIn, StandardCharsets.UTF_8));                assertEquals("File " + file + " is different", expected, data);            }        }    }    private static String normalizeLineSeparators(String s) {        return s.replaceAll(Pattern.quote(IOUtils.LINE_SEPARATOR_WINDOWS), IOUtils.LINE_SEPARATOR_UNIX)                .replaceAll(Pattern.quote(IOUtils.LINE_SEPARATOR_UNIX), PMD.EOL);    }    @Override    public Renderer getRenderer() {        Renderer result = new YAHTMLRenderer();        result.setProperty(YAHTMLRenderer.OUTPUT_DIR, outputDir.getAbsolutePath());        return result;    }    @Override    public String getExpected() {        return "<h3 align=\"center\">The HTML files are located in '" + outputDir + "'.</h3>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getExpected();    }    @Override    public String getExpectedMultiple() {        return getExpected();    }    @Override    public String getExpectedError(ProcessingError error) {        return getExpected();    }    @Override    public String getExpectedError(ConfigurationError error) {        return getExpected();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.util.HashMap;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class SummaryHTMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        Renderer result = new SummaryHTMLRenderer();        result.setProperty(HTMLRenderer.LINK_PREFIX, "link_prefix");        result.setProperty(HTMLRenderer.LINE_PREFIX, "line_prefix");        result.setProperty(HTMLRenderer.HTML_EXTENSION, true);        return result;    }    @Override    protected String getSourceCodeFilename() {        return "notAvailable";    }    @Override    public String getExpected() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>1</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>2</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "<tr> " + PMD.EOL + "<td align=\"center\">2</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td><a href=\"link_prefixfile.html#\">file</a></td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Test    public void testShowSuppressions() throws Exception {        Report rep = createEmptyReportWithSuppression();        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(true);        String actual = ReportTest.render(renderer, rep);        assertEquals("<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>"                + PMD.EOL + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Suppressed warnings</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Line</th><th>Rule</th><th>NOPMD or Annotation</th><th>Reason</th></tr>"                + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"left\"><a href=\"link_prefix.html#line_prefix1\"></a></td>" + PMD.EOL                + "<td align=\"center\">1</td>" + PMD.EOL + "<td align=\"center\">Foo</td>" + PMD.EOL                + "<td align=\"center\">NOPMD</td>" + PMD.EOL + "<td align=\"center\">test</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL, actual);    }    @Test    public void testHideSuppressions() throws Exception {        Report rep = createEmptyReportWithSuppression();        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(false);        String actual = ReportTest.render(renderer, rep);        assertEquals(getExpectedEmpty(), actual);    }    private Report createEmptyReportWithSuppression() {        Report rep = new Report();        Map<Integer, String> suppressions = new HashMap<>();        suppressions.put(1, "test");        rep.suppress(suppressions);        RuleContext ctx = new RuleContext();        ParametricRuleViolation<Node> violation = new ParametricRuleViolation<>(new FooRule(), ctx, null,                "suppress test");        violation.setLines(1, 1);        rep.addRuleViolation(violation);        return rep;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.List;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.util.datasource.DataSource;public class PMDFilelistTest {    @Test    public void testGetApplicableFiles() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(2, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("anotherfile.dummy"));    }    @Test    public void testGetApplicableFilesMultipleLines() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist2.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(3, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("anotherfile.dummy"));        Assert.assertTrue(applicableFiles.get(2).getNiceFileName(false, "").endsWith("somefile.dummy"));    }    @Test    public void testGetApplicatbleFilesWithIgnores() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist3.txt");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(2, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile2.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("somefile4.dummy"));    }    @Test    public void testGetApplicatbleFilesWithDirAndIgnores() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputPaths("src/test/resources/net/sourceforge/pmd/cli/src");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(4, applicableFiles.size());        Collections.sort(applicableFiles, new Comparator<DataSource>() {            @Override            public int compare(DataSource o1, DataSource o2) {                if (o1 == null && o2 != null) {                    return -1;                } else if (o1 != null && o2 == null) {                    return 1;                } else {                    return o1.getNiceFileName(false, "").compareTo(o2.getNiceFileName(false, ""));                }            }        });        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("anotherfile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(2).getNiceFileName(false, "").endsWith("somefile2.dummy"));        Assert.assertTrue(applicableFiles.get(3).getNiceFileName(false, "").endsWith("somefile4.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.ExpectedSystemExit;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.cache.NoopAnalysisCache;/** * Unit test for {@link PMDCommandLineInterface} */public class PMDCommandLineInterfaceTest {    @Rule    public final ExpectedSystemExit exit = ExpectedSystemExit.none();    @Rule // Restores system properties after test    public final RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    @Before    public void clearSystemProperties() {        System.clearProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN);        System.clearProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY);    }    @Test    public void testProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "yahtml", "-P", "outputDir=output_folder", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        Assert.assertEquals("output_folder", params.getProperties().getProperty("outputDir"));    }    @Test    public void testMultipleProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "ideaj", "-P", "sourcePath=/home/user/source/", "-P",            "fileName=Foo.java", "-P", "classAndMethodName=Foo.method", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        Assert.assertEquals("/home/user/source/", params.getProperties().getProperty("sourcePath"));        Assert.assertEquals("Foo.java", params.getProperties().getProperty("fileName"));        Assert.assertEquals("Foo.method", params.getProperties().getProperty("classAndMethodName"));    }    @Test    public void testNoCacheSwitch() {        PMDParameters params = new PMDParameters();        String[] args = {"-d", "source_folder", "-f", "ideaj", "-R", "java-empty", "-cache", "/home/user/.pmd/cache", "-no-cache", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertTrue(params.isIgnoreIncrementalAnalysis());        PMDConfiguration config = params.toConfiguration();        assertTrue(config.isIgnoreIncrementalAnalysis());        assertTrue(config.getAnalysisCache() instanceof NoopAnalysisCache);    }    @Test    public void testSetStatusCodeOrExitDoExit() {        exit.expectSystemExitWithStatus(0);        PMDCommandLineInterface.setStatusCodeOrExit(0);    }    @Test    public void testSetStatusCodeOrExitSetStatus() {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "1");        PMDCommandLineInterface.setStatusCodeOrExit(0);        Assert.assertEquals(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY), "0");    }    @Test    public void testBuildUsageText() {        // no exception..        Assert.assertNotNull(PMDCommandLineInterface.buildUsageText());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.PMD;/** * */public class CoreCliTest {    private static final String DUMMY_RULESET = "net/sourceforge/pmd/cli/FakeRuleset.xml";    private static final String STRING_TO_REPLACE = "__should_be_replaced__";    @Rule    public TemporaryFolder tempDir = new TemporaryFolder();    @Rule    public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    private Path srcDir;    @Before    public void setup() throws IOException {        // set current directory to wd        Path root = tempRoot();        System.setProperty("user.dir", root.toString());        // create a few files        srcDir = Files.createDirectories(root.resolve("src"));        writeString(srcDir.resolve("someSource.dummy"), "dummy text");    }    @Test    public void testPreExistingReportFile() throws IOException {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        // now we create the file        Files.createDirectories(reportFile.getParent());        writeString(reportFile, STRING_TO_REPLACE);        assertTrue("Report file should exist", Files.exists(reportFile));        runPmdSuccessfully("-d", srcDir, "-R", DUMMY_RULESET, "-r", reportFile);        assertNotEquals(readString(reportFile), STRING_TO_REPLACE);    }    @Test    public void testNonExistentReportFile() {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        assertFalse("Report file should not exist", Files.exists(reportFile));        runPmdSuccessfully("-d", srcDir, "-R", DUMMY_RULESET, "-r", reportFile);        assertTrue("Report file should have been created", Files.exists(reportFile));    }    // utilities    private Path tempRoot() {        return tempDir.getRoot().toPath();    }    private static void runPmdSuccessfully(Object... args) {        runPmd(0, args);    }    private static String[] argsToString(Object... args) {        String[] result = new String[args.length];        for (int i = 0; i < args.length; i++) {            result[i] = args[i].toString();        }        return result;    }    // available in Files on java 11+    private static void writeString(Path path, String text) throws IOException {        ByteBuffer encoded = StandardCharsets.UTF_8.encode(text);        Files.write(path, encoded.array());    }    // available in Files on java 11+    private static String readString(Path path) throws IOException {        byte[] bytes = Files.readAllBytes(path);        ByteBuffer buf = ByteBuffer.wrap(bytes);        return StandardCharsets.UTF_8.decode(buf).toString();    }    private static void runPmd(int expectedExitCode, Object[] args) {        int actualExitCode = PMD.run(argsToString(args));        assertEquals("Exit code", expectedExitCode, actualExitCode);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import org.apache.commons.lang3.reflect.FieldUtils;import org.junit.Assert;import org.junit.Test;public class PMDParametersTest {    @Test    public void testVersion() throws Exception {        PMDParameters parameters = new PMDParameters();        // no language set, uses default language        Assert.assertEquals("1.7", parameters.getVersion());        // now set language        FieldUtils.writeDeclaredField(parameters, "language", "dummy2", true);        Assert.assertEquals("1.0", parameters.getVersion());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.Reader;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.util.ResourceLoader;public class RuleSetFactoryCompatibilityTest {    @Test    public void testCorrectOldReference() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\" />\n" + "</ruleset>\n";        RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();        factory.getCompatibilityFilter().addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);        Assert.assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));    }    @Test    public void testCorrectMovedAndRename() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/OldDummyBasicMockRule\" />\n" + "</ruleset>\n";        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "OldDummyBasicMockRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldDummyBasicMockRule", "NewNameForDummyBasicMockRule");        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertFalse(out.contains("notexisting.xml"));        Assert.assertFalse(out.contains("OldDummyBasicMockRule"));        Assert.assertTrue(out.contains("<rule ref=\"rulesets/dummy/basic.xml/NewNameForDummyBasicMockRule\" />"));    }    @Test    public void testExclusion() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n" + " <rule ref=\"rulesets/dummy/basic.xml\">\n"                + "   <exclude name=\"OldNameOfSampleXPathRule\"/>\n" + " </rule>\n" + "</ruleset>\n";        RuleSetFactory factory = RulesetsFactoryUtils.defaultFactory();        factory.getCompatibilityFilter().addFilterRuleRenamed("dummy", "basic", "OldNameOfSampleXPathRule",                "SampleXPathRule");        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);        Assert.assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));        Assert.assertNull(createdRuleSet.getRuleByName("SampleXPathRule"));    }    @Test    public void testExclusionRenamedAndMoved() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/oldbasic.xml\">\n"                + "   <exclude name=\"OldDummyBasicMockRule\"/>\n"                + " </rule>\n"                + "</ruleset>\n";        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMovedAndRenamed("dummy", "oldbasic", "OldDummyBasicMockRule", "basic", "NewNameForDummyBasicMockRule");        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertTrue(out.contains("OldDummyBasicMockRule"));    }    @Test    public void testFilter() throws Exception {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        rsfc.addFilterRuleRemoved("dummy", "basic", "DeletedRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldNameOfBasicMockRule", "NewNameOfBasicMockRule");        String in = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\" />\n"                + " <rule ref=\"rulesets/dummy/basic.xml/DeletedRule\" />\n"                + " <rule ref=\"rulesets/dummy/basic.xml/OldNameOfBasicMockRule\" />\n" + "</ruleset>\n";        InputStream stream = new ByteArrayInputStream(in.getBytes(StandardCharsets.ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertFalse(out.contains("notexisting.xml"));        Assert.assertTrue(out.contains("<rule ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\" />"));        Assert.assertFalse(out.contains("DeletedRule"));        Assert.assertFalse(out.contains("OldNameOfBasicMockRule"));        Assert.assertTrue(out.contains("<rule ref=\"rulesets/dummy/basic.xml/NewNameOfBasicMockRule\" />"));    }    @Test    public void testExclusionFilter() throws Exception {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleRenamed("dummy", "basic", "AnotherOldNameOfBasicMockRule", "NewNameOfBasicMockRule");        String in = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n" + " <rule ref=\"rulesets/dummy/basic.xml\">\n"                + "   <exclude name=\"AnotherOldNameOfBasicMockRule\"/>\n" + " </rule>\n" + "</ruleset>\n";        InputStream stream = new ByteArrayInputStream(in.getBytes(StandardCharsets.ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertFalse(out.contains("OldNameOfBasicMockRule"));        Assert.assertTrue(out.contains("<exclude name=\"NewNameOfBasicMockRule\" />"));    }    @Test    public void testEncoding() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        String testString;        testString = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><x></x>";        Assert.assertEquals("ISO-8859-1", rsfc.determineEncoding(testString.getBytes(StandardCharsets.ISO_8859_1)));        testString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x></x>";        Assert.assertEquals("UTF-8", rsfc.determineEncoding(testString.getBytes(StandardCharsets.ISO_8859_1)));    }    private RuleSet createRulesetFromString(final String ruleset, RuleSetFactory factory)            throws RuleSetNotFoundException {        return factory.createRuleSet(new RuleSetReferenceId(null) {            @Override            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {                return new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.UTF_8));            }        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.IOException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Locale;import javax.xml.XMLConstants;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.stream.StreamSource;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import org.junit.Before;import org.junit.Test;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.xml.sax.EntityResolver;import org.xml.sax.ErrorHandler;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;public class RuleSetSchemaTest {    private CollectingErrorHandler errorHandler;    @Before    public void setUp() {        Locale.setDefault(Locale.ROOT);        errorHandler = new CollectingErrorHandler();    }    @Test    public void verifyVersion2() throws Exception {        String ruleset = generateRuleSet("2.0.0");        Document doc = parseWithVersion2(ruleset);        assertNotNull(doc);        assertTrue(errorHandler.isValid());        assertEquals("Custom ruleset", ((Attr) doc.getElementsByTagName("ruleset").item(0).getAttributes().getNamedItem("name")).getValue());    }    @Test    public void validateOnly() throws Exception {        Validator validator = PMDRuleSetEntityResolver.getSchemaVersion2().newValidator();        validator.setErrorHandler(errorHandler);        validator.validate(new StreamSource(new ByteArrayInputStream(generateRuleSet("2.0.0").getBytes(StandardCharsets.UTF_8))));        assertTrue(errorHandler.isValid());        errorHandler.reset();    }    private Document parseWithVersion2(String ruleset) throws SAXException, ParserConfigurationException, IOException {        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        dbf.setNamespaceAware(true);        dbf.setFeature("http://apache.org/xml/features/validation/schema", true);        DocumentBuilder builder = dbf.newDocumentBuilder();        builder.setErrorHandler(errorHandler);        builder.setEntityResolver(new PMDRuleSetEntityResolver());        Document doc = builder.parse(new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.UTF_8)));        return doc;    }    private String generateRuleSet(String version) {        String versionUnderscore = version.replaceAll("\\.", "_");        String ruleset = "<?xml version=\"1.0\"?>" + PMD.EOL                + "<ruleset " + PMD.EOL                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/" + version + "\"" + PMD.EOL                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" + PMD.EOL                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/" + version + " https://pmd.sourceforge.io/ruleset_" + versionUnderscore + ".xsd\""                + "    name=\"Custom ruleset\" >" + PMD.EOL                + "  <description>" + PMD.EOL                + "  This ruleset checks my code for bad stuff" + PMD.EOL                + "  </description>" + PMD.EOL                + "  <rule name=\"DummyBasicMockRule\" language=\"dummy\" since=\"1.0\" message=\"Test Rule 1\"" + PMD.EOL                + "        class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL                + "        externalInfoUrl=\"${pmd.website.baseurl}/rules/dummy/basic.xml#DummyBasicMockRule\"" + PMD.EOL                + "  >" + PMD.EOL                + "        <description>" + PMD.EOL                + "           Just for test" + PMD.EOL                + "     </description>" + PMD.EOL                + "        <priority>3</priority>" + PMD.EOL                + "        <example>" + PMD.EOL                + " <![CDATA[" + PMD.EOL                + " ]]>" + PMD.EOL                + "     </example>" + PMD.EOL                + "    </rule>" + PMD.EOL                + "  <rule ref=\"rulesets/dummy/basic.xml#DummyBasicMockRule\"/>" + PMD.EOL                + "</ruleset>" + PMD.EOL;        return ruleset;    }    public static class PMDRuleSetEntityResolver implements EntityResolver {        private static URL schema2 = RuleSetFactory.class.getResource("/ruleset_2_0_0.xsd");        private static SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);        @Override        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {            if ("https://pmd.sourceforge.io/ruleset_2_0_0.xsd".equals(systemId)) {                return new InputSource(schema2.toExternalForm());            }            throw new IllegalArgumentException("Unable to resolve entity (publicId=" + publicId + ", systemId=" + systemId + ")");        }        public static Schema getSchemaVersion2() throws SAXException {            return schemaFactory.newSchema(schema2);        }    }    public static class CollectingErrorHandler implements ErrorHandler {        private List<SAXParseException> warnings = new ArrayList<>();        private List<SAXParseException> errors = new ArrayList<>();        private List<SAXParseException> fatalErrors = new ArrayList<>();        public boolean isValid() {            return warnings.isEmpty() && errors.isEmpty() && fatalErrors.isEmpty();        }        public List<SAXParseException> getWarnings() {            return warnings;        }        public List<SAXParseException> getErrors() {            return errors;        }        public List<SAXParseException> getFatalErrors() {            return fatalErrors;        }        @Override        public void warning(SAXParseException exception) throws SAXException {            warnings.add(exception);        }        @Override        public void error(SAXParseException exception) throws SAXException {            errors.add(exception);        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {            fatalErrors.add(exception);        }        @Override        public String toString() {            return "Warnings: " + warnings + "; Errors: " + errors + "; Fatal Errors: " + fatalErrors;        }        public void reset() {            warnings.clear();            errors.clear();            fatalErrors.clear();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageFilenameFilter;import net.sourceforge.pmd.lang.LanguageRegistry;/** * Tests on FileSelector. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be */public class FileSelectorTest {    /**     * Test wanted selection of a source file.     */    @Test    public void testWantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/myFile.dummy");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("This file should be selected !", true, selected);    }    /**     * Test unwanted selection of a non source file.     */    @Test    public void testUnwantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/myFile.txt");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("Not-source file must not be selected!", false, selected);    }    /**     * Test unwanted selection of a java file.     */    @Test    public void testUnwantedJavaFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/MyClass.java");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("Unwanted java file must not be selected!", false, selected);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;import junit.framework.JUnit4TestAdapter;@RunWith(Parameterized.class)public class ReadableDurationTest {    private Integer value;    private String expected;    public ReadableDurationTest(String expected, Integer value) {        this.value = value;        this.expected = expected;    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { "0s", 35 }, { "25s", (25 * 1000) }, { "5m 0s", (60 * 1000 * 5) },            { "2h 0m 0s", (60 * 1000 * 120) }, });    }    @Test    public void test() {        assertEquals(expected, new Report.ReadableDuration(value).getTime());    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(ReadableDurationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertSame;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Random;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class RuleViolationComparatorTest {    @Test    public void testComparator() {        Rule rule1 = new MockRule("name1", "desc", "msg", "rulesetname1");        Rule rule2 = new MockRule("name2", "desc", "msg", "rulesetname2");        // RuleViolations created in pre-sorted order        RuleViolation[] expectedOrder = new RuleViolation[12];        int index = 0;        // Different begin line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 20, "desc1", 0, 20, 80);        // Different description        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc2", 0, 20, 80);        // Different begin column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 10, 20, 80);        // Different end line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 0, 30, 80);        // Different end column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 0, 20, 90);        // Different rule name        expectedOrder[index++] = createJavaRuleViolation(rule1, "file6", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule2, "file6", 10, "desc1", 0, 20, 80);        // Randomize        List<RuleViolation> ruleViolations = new ArrayList<>(Arrays.asList(expectedOrder));        long seed = System.nanoTime();        Random random = new Random(seed);        Collections.shuffle(ruleViolations, random);        // Sort        Collections.sort(ruleViolations, RuleViolation.DEFAULT_COMPARATOR);        // Check        int count = 0;        for (int i = 0; i < expectedOrder.length; i++) {            count++;            assertSame("Wrong RuleViolation " + i + ", used seed: " + seed, expectedOrder[i], ruleViolations.get(i));        }        assertEquals("Missing assertion for every RuleViolation", expectedOrder.length, count);    }    private RuleViolation createJavaRuleViolation(Rule rule, String fileName, int beginLine, String description,            int beginColumn, int endLine, int endColumn) {        RuleContext ruleContext = new RuleContext();        ruleContext.setSourceCodeFile(new File(fileName));        DummyNode simpleNode = new DummyNode(1);        simpleNode.testingOnlySetBeginLine(beginLine);        simpleNode.testingOnlySetBeginColumn(beginColumn);        simpleNode.testingOnlySetEndLine(endLine);        simpleNode.testingOnlySetEndColumn(endColumn);        RuleViolation ruleViolation = new ParametricRuleViolation<Node>(rule, ruleContext, simpleNode, description);        return ruleViolation;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.StringProperty;public class RuleReferenceTest {    @Test    public void testRuleSetReference() {        RuleReference ruleReference = new RuleReference();        RuleSetReference ruleSetReference = new RuleSetReference("somename");        ruleReference.setRuleSetReference(ruleSetReference);        assertEquals("Not same rule set reference", ruleSetReference, ruleReference.getRuleSetReference());    }    @Test    public void testOverride() {        final StringProperty PROPERTY1_DESCRIPTOR = new StringProperty("property1", "Test property", null, 0f);        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final StringProperty PROPERTY2_DESCRIPTOR = new StringProperty("property2", "Test property", null, 0f);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverriddenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, ruleReference);    }    @Test    public void testDeepCopyOverride() {        final StringProperty PROPERTY1_DESCRIPTOR = new StringProperty("property1", "Test property", null, 0f);        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final StringProperty PROPERTY2_DESCRIPTOR = new StringProperty("property2", "Test property", null, 0f);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverriddenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, (RuleReference) ruleReference.deepCopy());    }    private void validateOverriddenValues(final StringProperty propertyDescriptor1,                                          final StringProperty propertyDescriptor2, RuleReference ruleReference) {        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getOverriddenLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getOverriddenMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getMaximumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getOverriddenMaximumLanguageVersion());        assertEquals("Override failed", false, ruleReference.getRule().isDeprecated());        assertEquals("Override failed", true, ruleReference.isDeprecated());        assertEquals("Override failed", true, ruleReference.isOverriddenDeprecated());        assertEquals("Override failed", "name2", ruleReference.getName());        assertEquals("Override failed", "name2", ruleReference.getOverriddenName());        assertEquals("Override failed", "value2", ruleReference.getProperty(propertyDescriptor1));        assertEquals("Override failed", "value3", ruleReference.getProperty(propertyDescriptor2));        assertTrue("Override failed", ruleReference.getPropertyDescriptors().contains(propertyDescriptor1));        assertTrue("Override failed", ruleReference.getPropertyDescriptors().contains(propertyDescriptor2));        assertFalse("Override failed", ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor1));        assertTrue("Override failed", ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor2));        assertTrue("Override failed",                ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1));        assertTrue("Override failed",                ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2));        assertTrue("Override failed",                ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1));        assertTrue("Override failed",                ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2));        assertEquals("Override failed", "message2", ruleReference.getMessage());        assertEquals("Override failed", "message2", ruleReference.getOverriddenMessage());        assertEquals("Override failed", "description2", ruleReference.getDescription());        assertEquals("Override failed", "description2", ruleReference.getOverriddenDescription());        assertEquals("Override failed", 2, ruleReference.getExamples().size());        assertEquals("Override failed", "example1", ruleReference.getExamples().get(0));        assertEquals("Override failed", "example2", ruleReference.getExamples().get(1));        assertEquals("Override failed", "example2", ruleReference.getOverriddenExamples().get(0));        assertEquals("Override failed", "externalInfoUrl2", ruleReference.getExternalInfoUrl());        assertEquals("Override failed", "externalInfoUrl2", ruleReference.getOverriddenExternalInfoUrl());        assertEquals("Override failed", RulePriority.MEDIUM_HIGH, ruleReference.getPriority());        assertEquals("Override failed", RulePriority.MEDIUM_HIGH, ruleReference.getOverriddenPriority());    }    @Test    public void testNotOverride() {        final StringProperty PROPERTY1_DESCRIPTOR = new StringProperty("property1", "Test property", null, 0f);        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        rule.setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(false);        ruleReference.setName("name1");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value1");        ruleReference.setMessage("message1");        ruleReference.setDescription("description1");        ruleReference.addExample("example1");        ruleReference.setExternalInfoUrl("externalInfoUrl1");        ruleReference.setPriority(RulePriority.HIGH);        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getLanguage());        assertNull("Override failed", ruleReference.getOverriddenLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getMinimumLanguageVersion());        assertNull("Override failed", ruleReference.getOverriddenMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getMaximumLanguageVersion());        assertNull("Override failed", ruleReference.getOverriddenMaximumLanguageVersion());        assertEquals("Override failed", false, ruleReference.isDeprecated());        assertNull("Override failed", ruleReference.isOverriddenDeprecated());        assertEquals("Override failed", "name1", ruleReference.getName());        assertNull("Override failed", ruleReference.getOverriddenName());        assertEquals("Override failed", "value1", ruleReference.getProperty(PROPERTY1_DESCRIPTOR));        assertEquals("Override failed", "message1", ruleReference.getMessage());        assertNull("Override failed", ruleReference.getOverriddenMessage());        assertEquals("Override failed", "description1", ruleReference.getDescription());        assertNull("Override failed", ruleReference.getOverriddenDescription());        assertEquals("Override failed", 1, ruleReference.getExamples().size());        assertEquals("Override failed", "example1", ruleReference.getExamples().get(0));        assertNull("Override failed", ruleReference.getOverriddenExamples());        assertEquals("Override failed", "externalInfoUrl1", ruleReference.getExternalInfoUrl());        assertNull("Override failed", ruleReference.getOverriddenExternalInfoUrl());        assertEquals("Override failed", RulePriority.HIGH, ruleReference.getPriority());        assertNull("Override failed", ruleReference.getOverriddenPriority());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.io.ByteArrayOutputStream;import java.util.Random;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.rule.RuleReference;/** * Unit test for {@link RuleSetWriter}. * */public class RuleSetWriterTest {    private ByteArrayOutputStream out;    private RuleSetWriter writer;    /**     * Prepare the output stream.     */    @Before    public void setupOutputStream() {        out = new ByteArrayOutputStream();        writer = new RuleSetWriter(out);    }    /**     * Closes the output stream at the end.     */    @After    public void cleanupStream() {        if (writer != null) {            writer.close();        }    }    /**     * Tests the exclude rule behavior. See bug #945.     *     * @throws Exception     *             any error     */    @Test    public void testWrite() throws Exception {        RuleSet braces = RulesetsFactoryUtils.defaultFactory().createRuleSet("net/sourceforge/pmd/TestRuleset1.xml");        RuleSet ruleSet = new RuleSetBuilder(new Random().nextLong())                .withName("ruleset")                .withDescription("ruleset description")                .addRuleSetByReference(braces, true, "MockRule2")                .build();        writer.write(ruleSet);        String written = out.toString("UTF-8");        Assert.assertTrue(written.contains("<exclude name=\"MockRule2\""));    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     * @throws Exception     *             any error     */    @Test    public void testRuleReferenceOverriddenName() throws Exception {        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet rs = ruleSetFactory.createRuleSet("dummy-basic");        RuleSetReference ruleSetReference = new RuleSetReference("rulesets/dummy/basic.xml");        RuleReference ruleRef = new RuleReference();        ruleRef.setRule(rs.getRuleByName("DummyBasicMockRule"));        ruleRef.setRuleSetReference(ruleSetReference);        ruleRef.setName("Foo"); // override the name        RuleSet ruleSet = RuleSet.forSingleRule(ruleRef);        writer.write(ruleSet);        String written = out.toString("UTF-8");        Assert.assertTrue(written.contains("ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\""));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sourceforge.pmd.properties.StringProperty;public class AbstractRuleTest {    public static class MyRule extends AbstractRule {        private static final StringProperty FOO_PROPERTY = new StringProperty("foo", "foo property", "x", 1.0f);        private static final PropertyDescriptor<String> FOO_DEFAULT_PROPERTY = PropertyFactory.stringProperty("fooDefault")                .defaultValue("bar")                .desc("Property without value uses default value")                .build();        private static final StringProperty XPATH_PROPERTY = new StringProperty("xpath", "xpath property", "", 2.0f);        public MyRule() {            definePropertyDescriptor(FOO_PROPERTY);            definePropertyDescriptor(XPATH_PROPERTY);            definePropertyDescriptor(FOO_DEFAULT_PROPERTY);            setName("MyRule");            setMessage("my rule msg");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {        }    }    private static class MyOtherRule extends AbstractRule {        private static final PropertyDescriptor FOO_PROPERTY = new StringProperty("foo", "foo property", "x", 1.0f);        MyOtherRule() {            definePropertyDescriptor(FOO_PROPERTY);            setName("MyOtherRule");            setMessage("my other rule");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {        }    }    @Test    public void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginColumn(5);        s.testingOnlySetBeginLine(5);        RuleViolation rv = new ParametricRuleViolation(r, ctx, s, r.getMessage());        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule msg mismatch!", "my rule msg", rv.getDescription());        assertEquals("RuleSet name mismatch!", "foo", rv.getRule().getRuleSetName());    }    @Test    public void testCreateRV2() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginColumn(5);        s.testingOnlySetBeginLine(5);        RuleViolation rv = new ParametricRuleViolation<>(r, ctx, s, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }    @Test    public void testRuleWithVariableInMessage() {        MyRule r = new MyRule();        r.definePropertyDescriptor(PropertyFactory.intProperty("testInt").desc("description").require(inRange(0, 100)).defaultValue(10).build());        r.setMessage("Message ${packageName} ${className} ${methodName} ${variableName} ${testInt} ${noSuchProperty}");        RuleContext ctx = new RuleContext();        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        ctx.setReport(new Report());        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginColumn(5);        s.testingOnlySetBeginLine(5);        s.setImage("TestImage");        r.addViolation(ctx, s);        RuleViolation rv = ctx.getReport().getViolationTree().iterator().next();        assertEquals("Message foo    10 ${noSuchProperty}", rv.getDescription());    }    @Test    public void testRuleSuppress() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        Map<Integer, String> m = new HashMap<>();        m.put(Integer.valueOf(5), "");        ctx.setReport(new Report());        ctx.getReport().suppress(m);        ctx.setSourceCodeFile(new File("filename"));        DummyNode n = new DummyNode(1);        n.testingOnlySetBeginColumn(5);        n.testingOnlySetBeginLine(5);        RuleViolation rv = new ParametricRuleViolation<>(r, ctx, n, "specificdescription");        ctx.getReport().addRuleViolation(rv);        assertTrue(ctx.getReport().isEmpty());    }    @Test    public void testEquals1() {        MyRule r = new MyRule();        assertFalse("A rule is never equals to null!", r.equals(null));    }    @Test    public void testEquals2() {        MyRule r = new MyRule();        assertEquals("A rule must be equals to itself", r, r);    }    @Test    public void testEquals3() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        assertEquals("Two instances of the same rule are equal", r1, r2);        assertEquals("Hashcode for two instances of the same rule must be equal", r1.hashCode(), r2.hashCode());    }    @Test    public void testEquals4() {        MyRule myRule = new MyRule();        assertFalse("A rule cannot be equal to an object of another class", myRule.equals("MyRule"));    }    @Test    public void testEquals5() {        MyRule myRule = new MyRule();        MyOtherRule myOtherRule = new MyOtherRule();        assertFalse("Two rules from different classes cannot be equal", myRule.equals(myOtherRule));    }    @Test    public void testEquals6() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setName("MyRule2");        assertFalse("Rules with different names cannot be equal", r1.equals(r2));    }    @Test    public void testEquals7() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setPriority(RulePriority.HIGH);        assertFalse("Rules with different priority levels cannot be equal", r1.equals(r2));    }    @Test    public void testEquals8() {        MyRule r1 = new MyRule();        r1.setProperty(MyRule.XPATH_PROPERTY, "something");        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse("Rules with different properties values cannot be equal", r1.equals(r2));    }    @Test    public void testEquals9() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse("Rules with different properties cannot be equal", r1.equals(r2));    }    @Test    public void testEquals10() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setMessage("another message");        assertEquals("Rules with different messages are still equal", r1, r2);        assertEquals("Rules that are equal must have the an equal hashcode", r1.hashCode(), r2.hashCode());    }    @Test    public void testDeepCopyRule() {        MyRule r1 = new MyRule();        MyRule r2 = (MyRule) r1.deepCopy();        assertEquals(r1.getDescription(), r2.getDescription());        assertEquals(r1.getExamples(), r2.getExamples());        assertEquals(r1.getExternalInfoUrl(), r2.getExternalInfoUrl());        assertEquals(r1.getLanguage(), r2.getLanguage());        assertEquals(r1.getMaximumLanguageVersion(), r2.getMaximumLanguageVersion());        assertEquals(r1.getMessage(), r2.getMessage());        assertEquals(r1.getMinimumLanguageVersion(), r2.getMinimumLanguageVersion());        assertEquals(r1.getName(), r2.getName());        assertEquals(r1.getPriority(), r2.getPriority());        assertEquals(r1.getPropertyDescriptors(), r2.getPropertyDescriptors());        assertEquals(r1.getRuleChainVisits(), r2.getRuleChainVisits());        assertEquals(r1.getRuleClass(), r2.getRuleClass());        assertEquals(r1.getRuleSetName(), r2.getRuleSetName());        assertEquals(r1.getSince(), r2.getSince());        assertEquals(r1.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY),                r2.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;import static com.github.tomakehurst.wiremock.client.WireMock.findAll;import static com.github.tomakehurst.wiremock.client.WireMock.get;import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.head;import static com.github.tomakehurst.wiremock.client.WireMock.headRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;import static com.github.tomakehurst.wiremock.client.WireMock.verify;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.util.ResourceLoader;import com.github.tomakehurst.wiremock.junit.WireMockRule;public class RuleSetReferenceIdTest {    private static void assertRuleSetReferenceId(final boolean expectedExternal, final String expectedRuleSetFileName,            final boolean expectedAllRules, final String expectedRuleName, final String expectedToString,            final RuleSetReferenceId reference) {        assertEquals("Wrong external", expectedExternal, reference.isExternal());        assertEquals("Wrong RuleSet file name", expectedRuleSetFileName, reference.getRuleSetFileName());        assertEquals("Wrong all Rule reference", expectedAllRules, reference.isAllRules());        assertEquals("Wrong Rule name", expectedRuleName, reference.getRuleName());        assertEquals("Wrong toString()", expectedToString, reference.toString());    }    @Test(expected = IllegalArgumentException.class)    public void testCommaInSingleId() {        new RuleSetReferenceId("bad,id");    }    @Test(expected = IllegalArgumentException.class)    public void testInternalWithInternal() {        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("SomeOtherRule"));    }    @Test(expected = IllegalArgumentException.class)    public void testExternalWithExternal() {        new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test(expected = IllegalArgumentException.class)    public void testExternalWithInternal() {        new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("SomeOtherRule"));    }    @Test    public void testInteralWithExternal() {        // This is okay        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test    public void testEmptyRuleSet() {        // This is representative of how the Test framework creates        // RuleSetReferenceId from static RuleSet XMLs        RuleSetReferenceId reference = new RuleSetReferenceId(null);        assertRuleSetReferenceId(true, null, true, null, "anonymous all Rule", reference);    }    @Test    public void testInternalWithExternalRuleSet() {        // This is representative of how the RuleSetFactory temporarily pairs an        // internal reference        // with an external reference.        RuleSetReferenceId internalRuleSetReferenceId = new RuleSetReferenceId("MockRuleName");        assertRuleSetReferenceId(false, null, false, "MockRuleName", "MockRuleName", internalRuleSetReferenceId);        RuleSetReferenceId externalRuleSetReferenceId = new RuleSetReferenceId("rulesets/java/basic.xml");        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                externalRuleSetReferenceId);        RuleSetReferenceId pairRuleSetReferenceId = new RuleSetReferenceId("MockRuleName", externalRuleSetReferenceId);        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "MockRuleName",                "rulesets/java/basic.xml/MockRuleName", pairRuleSetReferenceId);    }    @Test    public void testConstructorGivenHttpUrlIdSucceedsAndProcessesIdCorrectly() {        final String sonarRulesetUrlId = "http://localhost:54321/profiles/export?format=pmd&language=java&name=Sonar%2520way";        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + sonarRulesetUrlId + "  ");        assertRuleSetReferenceId(true, sonarRulesetUrlId, true, null, sonarRulesetUrlId, ruleSetReferenceId);    }    @org.junit.Rule    public WireMockRule wireMockRule = new WireMockRule(0);    @Test    public void testConstructorGivenHttpUrlInputStream() throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String rulesetUrl = "http://localhost:" + wireMockRule.port() + path;        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200)));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody("xyz")));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + rulesetUrl + "  ");        assertRuleSetReferenceId(true, rulesetUrl, true, null, rulesetUrl, ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtils.toString(inputStream, StandardCharsets.UTF_8);            assertEquals("xyz", loaded);        }        verify(1, headRequestedFor(urlEqualTo(path)));        verify(0, headRequestedFor(urlEqualTo("/profiles")));        verify(1, getRequestedFor(urlEqualTo(path)));        assertEquals(1, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    public void testConstructorGivenHttpUrlSingleRuleInputStream() throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String completePath = path + "/DummyBasicMockRule";        String hostpart = "http://localhost:" + wireMockRule.port();        String basicRuleSet = IOUtils                .toString(RuleSetReferenceId.class.getResourceAsStream("/rulesets/dummy/basic.xml"), StandardCharsets.UTF_8);        stubFor(head(urlEqualTo(completePath)).willReturn(aResponse().withStatus(404)));        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml")));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody(basicRuleSet)));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + hostpart + completePath + "  ");        assertRuleSetReferenceId(true, hostpart + path, false, "DummyBasicMockRule", hostpart + completePath,                ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtils.toString(inputStream, StandardCharsets.UTF_8);            assertEquals(basicRuleSet, loaded);        }        verify(1, headRequestedFor(urlEqualTo(completePath)));        verify(1, headRequestedFor(urlEqualTo(path)));        verify(1, getRequestedFor(urlEqualTo(path)));        verify(0, getRequestedFor(urlEqualTo(completePath)));        assertEquals(2, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    public void testOneSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));    }    @Test    public void testMultipleSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-unusedcode,dummy-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(1));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1201/     */    @Test    public void testMultipleRulesWithSpaces() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic, dummy-unusedcode, dummy2-basic");        assertEquals(3, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(1));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(2));    }    @Test    public void testOneReleaseRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("50");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/releases/50.xml", true, null, "rulesets/releases/50.xml",                references.get(0));    }    @Test    public void testOneFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));    }    @Test    public void testOneFullRuleSetURL() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("file://somepath/rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", true, null,                "file://somepath/rulesets/java/unusedcode.xml", references.get(0));    }    @Test    public void testMultipleFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("rulesets/java/unusedcode.xml,rulesets/java/basic.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                references.get(1));    }    @Test    public void testMixRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/dummy/unusedcode.xml,dummy2-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(1));    }    @Test    public void testUnknownRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("nonexistant.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(0));    }    @Test    public void testUnknownAndSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic,nonexistant.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(1));    }    @Test    public void testSimpleRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic/DummyBasicMockRule");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", false, "DummyBasicMockRule",                "rulesets/dummy/basic.xml/DummyBasicMockRule", references.get(0));    }    @Test    public void testFullRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/basic.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "EmptyCatchBlock",                "rulesets/java/basic.xml/EmptyCatchBlock", references.get(0));    }    @Test    public void testFullRuleSetURLAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", false, "EmptyCatchBlock",                "file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock", references.get(0));    }    @Test    public void testInternalRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(false, null, false, "EmptyCatchBlock", "EmptyCatchBlock", references.get(0));    }    @Test    public void testRelativePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "pmd/pmd-ruleset.xml", true, null, "pmd/pmd-ruleset.xml", references.get(0));    }    @Test    public void testAbsolutePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("/home/foo/pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "/home/foo/pmd/pmd-ruleset.xml", true, null, "/home/foo/pmd/pmd-ruleset.xml",                references.get(0));    }    @Test    public void testFooRules() throws Exception {        String fooRulesFile = new File("./src/test/resources/net/sourceforge/pmd/rulesets/foo-project/foo-rules")                .getCanonicalPath();        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(fooRulesFile);        assertEquals(1, references.size());        assertRuleSetReferenceId(true, fooRulesFile, true, null, fooRulesFile, references.get(0));    }    @Test    public void testNullRulesetString() throws Exception {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(null);        assertTrue(references.isEmpty());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(RuleSetReferenceIdTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.Set;import java.util.regex.Pattern;import org.apache.commons.io.FilenameUtils;import org.junit.Test;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.util.CollectionUtil;public class RuleSetTest {    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresName() {        new RuleSetBuilder(new Random().nextLong())            .withName(null);    }    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresDescription() {        new RuleSetBuilder(new Random().nextLong())            .withName("some name")            .withDescription(null);    }    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresName2() {        new RuleSetBuilder(new Random().nextLong()).build();    }    @Test    public void testNoDFA() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        mock.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        RuleSet rs = RuleSet.forSingleRule(mock);        assertFalse(rs.usesDFA(LanguageRegistry.getLanguage(DummyLanguageModule.NAME)));    }    @Test    public void testIncludesRuleWithDFA() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        mock.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        mock.setDfa(true);        RuleSet rs = RuleSet.forSingleRule(mock);        assertTrue(rs.usesDFA(LanguageRegistry.getLanguage(DummyLanguageModule.NAME)));    }    @Test    public void testAccessors() {        RuleSet rs = new RuleSetBuilder(new Random().nextLong())                .withFileName("baz")                .withName("foo")                .withDescription("bar")                .build();        assertEquals("file name mismatch", "baz", rs.getFileName());        assertEquals("name mismatch", "foo", rs.getName());        assertEquals("description mismatch", "bar", rs.getDescription());    }    @Test    public void testGetRuleByName() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = RuleSet.forSingleRule(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    @Test    public void testGetRuleByName2() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = RuleSet.forSingleRule(mock);        assertNull("the rule FooRule must not be found!", rs.getRuleByName("FooRule"));    }    @Test    public void testRuleList() {        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet ruleset = RuleSet.forSingleRule(rule);        assertEquals("Size of RuleSet isn't one.", 1, ruleset.size());        Collection<Rule> rules = ruleset.getRules();        Iterator<Rule> i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    private RuleSetBuilder createRuleSetBuilder(String name) {        return new RuleSetBuilder(new Random().nextLong())                .withName(name)                .withDescription("Description for " + name);    }    @Test    public void testAddRuleSet() {        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet set2 = createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSet(set1)                .build();        assertEquals("ruleset size wrong", 2, set2.size());    }    @Test(expected = RuntimeException.class)    public void testAddRuleSetByReferenceBad() {        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSetByReference(set1, false)                .build();    }    @Test    public void testAddRuleSetByReferenceAllRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")                .withFileName("foo")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, true)                .build();        assertEquals("wrong rule size", 2, set1.getRules().size());        for (Rule rule : set1.getRules()) {            assertTrue("not a rule reference", rule instanceof RuleReference);            RuleReference ruleReference = (RuleReference) rule;            assertEquals("wrong ruleset file name", "foo", ruleReference.getRuleSetReference().getRuleSetFileName());            assertTrue("not all rule reference", ruleReference.getRuleSetReference().isAllRules());        }    }    @Test    public void testAddRuleSetByReferenceSingleRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")                .withFileName("foo")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, false)                .build();        assertEquals("wrong rule size", 2, set1.getRules().size());        for (Rule rule : set1.getRules()) {            assertTrue("not a rule reference", rule instanceof RuleReference);            RuleReference ruleReference = (RuleReference) rule;            assertEquals("wrong ruleset file name", "foo", ruleReference.getRuleSetReference().getRuleSetFileName());            assertFalse("should not be all rule reference", ruleReference.getRuleSetReference().isAllRules());        }    }    @Test    public void testApply0Rules() throws Exception {        RuleSet ruleset = createRuleSetBuilder("ruleset").build();        verifyRuleSet(ruleset, 0, new HashSet<RuleViolation>());    }    @Test    public void testEquals1() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertFalse("A ruleset cannot be equals to null", s.equals(null));    }    @Test    @SuppressWarnings("PMD.UseAssertEqualsInsteadOfAssertTrue")    public void testEquals2() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertTrue("A rulset must be equals to itself", s.equals(s));    }    @Test    public void testEquals3() {        RuleSet s = new RuleSetBuilder(new Random().nextLong())                .withName("basic rules")                .withDescription("desc")                .build();        assertFalse("A ruleset cannot be equals to another kind of object", s.equals("basic rules"));    }    @Test    public void testEquals4() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        assertEquals("2 rulesets with same name and rules must be equals", s1, s2);        assertEquals("Equals rulesets must have the same hashcode", s1.hashCode(), s2.hashCode());    }    @Test    public void testEquals5() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my other ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        assertFalse("2 rulesets with different name but same rules must not be equals", s1.equals(s2));    }    @Test    public void testEquals6() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("other rule", "desc", "msg", "rulesetname"))                .build();        assertFalse("2 rulesets with same name but different rules must not be equals", s1.equals(s2));    }    @Test    public void testLanguageApplies() {        Rule rule = new MockRule();        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertFalse("Different languages should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME).getDefaultVersion()));        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertTrue("Same language with no min/max should apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5")));        rule.setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5"));        assertTrue("Same language with valid min only should apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5")));        rule.setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.6"));        assertTrue("Same language with valid min and max should apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5")));        assertFalse("Same language with outside range of min/max should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.4")));        assertFalse("Same language with outside range of min/max should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7")));    }    @Test    public void testAddExcludePattern() {        RuleSet ruleSet =            createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertEquals("Invalid number of patterns", 1, ruleSet.getExcludePatterns().size());    }    @Test    public void testExcludePatternAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(Pattern.compile(".*"))                .withFileExclusions(Pattern.compile(".*ha"))                .build();        assertEquals("Exclude pattern", Arrays.asList(".*", ".*ha"), ruleSet2.getExcludePatterns());    }    @Test    public void testIncludePatternsAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileInclusions(Pattern.compile(".*"))                .withFileInclusions(Arrays.asList(Pattern.compile(".*ha"), Pattern.compile(".*hb")))                .build();        assertEquals("Exclude pattern", Arrays.asList(".*", ".*ha", ".*hb"), ruleSet2.getIncludePatterns());    }    @Test    public void testAddExcludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of patterns", 1, ruleSet.getFileExclusions().size());        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(ruleSet.getFileExclusions())                .build();        assertNotNull("Exclude patterns", ruleSet2.getFileExclusions());        assertEquals("Invalid number of patterns", 1, ruleSet2.getFileExclusions().size());    }    @Test    public void testSetExcludePatterns() {        List<Pattern> excludePatterns = new ArrayList<>();        excludePatterns.add(Pattern.compile("ah*"));        excludePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset").replaceFileExclusions(excludePatterns).build();        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 2, ruleSet.getFileExclusions().size());        assertEquals("Exclude pattern", "ah*", ruleSet.getFileExclusions().get(0).pattern());        assertEquals("Exclude pattern", ".*", ruleSet.getFileExclusions().get(1).pattern());        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of include patterns", 0, ruleSet.getFileInclusions().size());    }    @Test    public void testAddIncludePattern() {        RuleSet ruleSet = createRuleSetBuilder("ruleset")                .withFileInclusions(Pattern.compile(".*"))                .build();        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of patterns", 1, ruleSet.getFileInclusions().size());        assertEquals("Include pattern", ".*", ruleSet.getFileInclusions().get(0).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testAddIncludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")                .withFileInclusions(Pattern.compile("ah*"), Pattern.compile(".*"))                .build();        RuleSet ruleSet2 = createRuleSetBuilder("ruleset1")                .withFileInclusions(ruleSet.getFileInclusions())                .build();        assertNotNull("Include patterns", ruleSet2.getFileInclusions());        assertEquals("Invalid number of patterns", 2, ruleSet2.getFileInclusions().size());        assertEquals("Include pattern", "ah*", ruleSet2.getFileInclusions().get(0).pattern());        assertEquals("Include pattern", ".*", ruleSet2.getFileInclusions().get(1).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testSetIncludePatterns() {        List<Pattern> includePatterns = new ArrayList<>();        includePatterns.add(Pattern.compile("ah*"));        includePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset")            .replaceFileInclusions(includePatterns)            .build();        assertEquals("Include patterns", includePatterns, ruleSet.getFileInclusions());        assertNotNull("Exclude patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testIncludeExcludeApplies() {        File file = new File("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java");        RuleSet ruleSet = createRuleSetBuilder("ruleset").build();        assertTrue("No patterns", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .build();        assertTrue("Non-matching exclude", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"), Pattern.compile(".*/package/.*"))                .build();        assertFalse("Matching exclude", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .build();        assertFalse("Non-matching include", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .withFileInclusions(Pattern.compile(".*/random/.*"))                .build();        assertTrue("Matching include", ruleSet.applies(file));    }    @Test    public void testIncludeExcludeMultipleRuleSetWithRuleChainApplies() throws PMDException {        File file = new File("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java");        Rule rule = new FooRule();        rule.setName("FooRule1");        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.addRuleChainVisit("dummyNode");        assertTrue("RuleChain rule", rule.isRuleChain());        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")                .addRule(rule)                .build();        RuleSet ruleSet2 = createRuleSetBuilder("RuleSet2")                .addRule(rule)                .build();        RuleSets ruleSets = new RuleSets();        ruleSets.addRuleSet(ruleSet1);        ruleSets.addRuleSet(ruleSet2);        // Two violations        RuleContext ctx = new RuleContext();        Report r = new Report();        ctx.setReport(r);        ctx.setSourceCodeFile(file);        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        ruleSets.apply(makeCompilationUnits(), ctx, LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertEquals("Violations", 2, r.size());        // One violation        ruleSet1 = createRuleSetBuilder("RuleSet1")                .withFileExclusions(Pattern.compile(".*/package/.*"))                .addRule(rule)                .build();        ruleSets = new RuleSets();        ruleSets.addRuleSet(ruleSet1);        ruleSets.addRuleSet(ruleSet2);        r = new Report();        ctx.setReport(r);        ruleSets.apply(makeCompilationUnits(), ctx, LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertEquals("Violations", 1, r.size());    }    @Test    public void copyConstructorDeepCopies() {        Rule rule = new FooRule();        rule.setName("FooRule1");        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.addRuleChainVisit("dummyNode");        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")                .addRule(rule)                .build();        RuleSet ruleSet2 = new RuleSet(ruleSet1);        assertEquals(ruleSet1, ruleSet2);        assertNotSame(ruleSet1, ruleSet2);        assertEquals(rule, ruleSet2.getRuleByName("FooRule1"));        assertNotSame(rule, ruleSet2.getRuleByName("FooRule1"));    }    private void verifyRuleSet(RuleSet ruleset, int size, Set<RuleViolation> values) {        RuleContext context = new RuleContext();        Set<RuleViolation> reportedValues = new HashSet<>();        context.setReport(new Report());        ruleset.apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().size());        Iterator<RuleViolation> violations = context.getReport().iterator();        while (violations.hasNext()) {            RuleViolation violation = violations.next();            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        Iterator<RuleViolation> expected = values.iterator();        while (expected.hasNext()) {            RuleViolation violation = expected.next();            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    private List<Node> makeCompilationUnits() {        List<Node> nodes = new ArrayList<>();        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        node.setImage("Foo");        nodes.add(node);        return nodes;    }    @Test    public void ruleExceptionShouldBeReported() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")                .addRule(new MockRule() {                    @Override                    public void apply(List<? extends Node> nodes, RuleContext ctx) {                        throw new RuntimeException("Test exception while applying rule");                    }                })                .build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        ruleset.apply(makeCompilationUnits(), context);        List<ProcessingError> errors = context.getReport().getProcessingErrors();        assertTrue("Report should have processing errors", !errors.isEmpty());        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);    }    @Test(expected = RuntimeException.class)    public void ruleExceptionShouldBeThrownIfNotIgnored() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")                .addRule(new MockRule() {                    @Override                    public void apply(List<? extends Node> nodes, RuleContext ctx) {                        throw new RuntimeException("Test exception while applying rule");                    }                })                .build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeThrownIfNotIgnored"));        context.setIgnoreExceptions(false);        ruleset.apply(makeCompilationUnits(), context);    }    @Test    public void ruleExceptionShouldNotStopProcessingFile() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                throw new RuntimeException("Test exception while applying rule");            }        }).addRule(new MockRule() {            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                for (Node node : nodes) {                    addViolationWithMessage(ctx, node, "Test violation of the second rule in the ruleset");                }            }        }).build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName(), "ruleExceptionShouldBeReported.java"));        context.setIgnoreExceptions(true); // the default        ruleset.apply(makeCompilationUnits(), context);        assertTrue("Report should have processing errors", context.getReport().hasErrors());        List<ProcessingError> errors = CollectionUtil.toList(context.getReport().errors());        assertEquals("Errors expected", 1, errors.size());        ProcessingError processingError = errors.get(0);        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", processingError.getMsg());        assertTrue("Should be a RuntimeException", processingError.getError() instanceof RuntimeException);        assertEquals("Wrong filename in processing error",                "net.sourceforge.pmd.RuleSetTest/ruleExceptionShouldBeReported.java",                FilenameUtils.normalize(processingError.getFile(), true));        assertEquals("There should be a violation", 1, context.getReport().size());    }    @Test    public void ruleExceptionShouldNotStopProcessingFileWithRuleChain() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            {                addRuleChainVisit("dummyNode");            }            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                throw new RuntimeException("Test exception while applying rule");            }        }).addRule(new MockRule() {            {                addRuleChainVisit("dummyNode");            }            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                for (Node node : nodes) {                    addViolationWithMessage(ctx, node, "Test violation of the second rule in the ruleset");                }            }        }).build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        RuleSets rulesets = new RuleSets(ruleset);        rulesets.apply(makeCompilationUnits(), context, LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertTrue("Report should have processing errors", context.getReport().hasErrors());        List<ProcessingError> errors = CollectionUtil.toList(context.getReport().errors());        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);        assertEquals("There should be a violation", 1, context.getReport().size());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.io.StringWriter;import java.util.Iterator;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;import net.sourceforge.pmd.stat.Metric;public class ReportTest implements ThreadSafeReportListener {    private boolean violationSemaphore;    private boolean metricSemaphore;    @Override    public void ruleViolationAdded(RuleViolation ruleViolation) {        violationSemaphore = true;    }    @Override    public void metricAdded(Metric metric) {        metricSemaphore = true;    }    @Test    public void testMetric0() {        Report r = new Report();        assertFalse("Default report shouldn't contain metrics", r.hasMetrics());    }    @Test    public void testMetric1() {        Report r = new Report();        assertFalse("Default report shouldn't contain metrics", r.hasMetrics());        r.addMetric(new Metric("m1", 0, 0.0, 1.0, 2.0, 3.0, 4.0));        assertTrue("Expected metrics weren't there", r.hasMetrics());        Iterator<Metric> ms = r.metrics();        assertTrue("Should have some metrics in there now", ms.hasNext());        Object o = ms.next();        assertTrue("Expected Metric, got " + o.getClass(), o instanceof Metric);        Metric m = (Metric) o;        assertEquals("metric name mismatch", "m1", m.getMetricName());        assertEquals("wrong low value", 1.0, m.getLowValue(), 0.05);        assertEquals("wrong high value", 2.0, m.getHighValue(), 0.05);        assertEquals("wrong avg value", 3.0, m.getAverage(), 0.05);        assertEquals("wrong std dev value", 4.0, m.getStandardDeviation(), 0.05);    }    // Files are grouped together now.    @Test    public void testSortedReportFile() throws IOException {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("foo"));        Node s = getNode(10, 5);        Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule1, ctx, s, rule1.getMessage()));        ctx.setSourceCodeFile(new File("bar"));        Node s1 = getNode(10, 5);        Rule rule2 = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule2, ctx, s1, rule2.getMessage()));        Renderer rend = new XMLRenderer();        String result = render(rend, r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    @Test    public void testSortedReportLine() throws IOException {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("foo1")); // same file!!        Node node1 = getNode(20, 5); // line 20: after rule2 violation        Rule rule1 = new MockRule("rule1", "rule1", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule1, ctx, node1, rule1.getMessage()));        ctx.setSourceCodeFile(new File("foo1")); // same file!!        Node node2 = getNode(10, 5); // line 10: before rule1 violation        Rule rule2 = new MockRule("rule2", "rule2", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule2, ctx, node2, rule2.getMessage()));        Renderer rend = new XMLRenderer();        String result = render(rend, r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    @Test    public void testListener() {        Report rpt = new Report();        rpt.addListener(this);        violationSemaphore = false;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("file"));        Node s = getNode(5, 5);        Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");        rpt.addRuleViolation(new ParametricRuleViolation<>(rule1, ctx, s, rule1.getMessage()));        assertTrue(violationSemaphore);        metricSemaphore = false;        rpt.addMetric(new Metric("test", 0, 0.0, 0.0, 0.0, 0.0, 0.0));        assertTrue("no metric", metricSemaphore);    }    @Test    public void testSummary() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("foo1"));        Node s = getNode(5, 5);        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule, ctx, s, rule.getMessage()));        ctx.setSourceCodeFile(new File("foo2"));        Rule mr = new MockRule("rule1", "rule1", "msg", "rulesetname");        Node s1 = getNode(20, 5);        Node s2 = getNode(30, 5);        r.addRuleViolation(new ParametricRuleViolation<>(mr, ctx, s1, mr.getMessage()));        r.addRuleViolation(new ParametricRuleViolation<>(mr, ctx, s2, mr.getMessage()));        Map<String, Integer> summary = r.getSummary();        assertEquals(summary.keySet().size(), 2);        assertTrue(summary.values().contains(Integer.valueOf(1)));        assertTrue(summary.values().contains(Integer.valueOf(2)));    }    @Test    public void testTreeIterator() {        Report r = new Report();        RuleContext ctx = new RuleContext();        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Node node1 = getNode(5, 5, true);        r.addRuleViolation(new ParametricRuleViolation<>(rule, ctx, node1, rule.getMessage()));        Node node2 = getNode(5, 6, true);        r.addRuleViolation(new ParametricRuleViolation<>(rule, ctx, node2, rule.getMessage()));        Iterator<RuleViolation> violations = r.iterator();        int violationCount = 0;        while (violations.hasNext()) {            violations.next();            violationCount++;        }        assertEquals(2, violationCount);        Iterator<RuleViolation> treeIterator = r.treeIterator();        int treeCount = 0;        while (treeIterator.hasNext()) {            treeIterator.next();            treeCount++;        }        assertEquals(2, treeCount);    }    private static Node getNode(int line, int column) {        DummyNode s = new DummyNode(2);        DummyNode parent = new DummyNode(1);        parent.testingOnlySetBeginLine(line);        parent.testingOnlySetBeginColumn(column);        s.jjtSetParent(parent);        s.testingOnlySetBeginLine(line);        s.testingOnlySetBeginColumn(column);        return s;    }    private static Node getNode(int line, int column, boolean nextLine) {        DummyNode s = (DummyNode) getNode(line, column);        if (nextLine) {            s.testingOnlySetBeginLine(line + 1);            s.testingOnlySetBeginColumn(column + 4);        }        return s;    }    public static String render(Renderer renderer, Report report) throws IOException {        StringWriter writer = new StringWriter();        renderer.setWriter(writer);        renderer.start();        renderer.renderFileReport(report);        renderer.end();        return writer.toString();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.junit.LocaleRule;public class RuleSetFactoryDuplicatedRuleLoggingTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    @org.junit.Rule    public LocaleRule localeRule = LocaleRule.en();    @org.junit.Rule    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());    @Test    public void duplicatedRuleReferenceShouldWarn() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("duplicatedRuleReference.xml");        assertEquals(1, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.MEDIUM, mockRule.getPriority());        assertTrue(logging.getLog().contains("The rule DummyBasicMockRule is referenced multiple times in \"Custom Rules\". "                + "Only the last rule configuration is used."));    }    @Test    public void duplicatedRuleReferenceWithOverrideShouldNotWarn() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("duplicatedRuleReferenceWithOverride.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    @Test    public void duplicatedRuleReferenceWithOverrideBeforeShouldNotWarn() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("duplicatedRuleReferenceWithOverrideBefore.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    @Test    public void multipleDuplicates() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("multipleDuplicates.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.MEDIUM_HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().contains("The rule DummyBasicMockRule is referenced multiple times in \"Custom Rules\". "                + "Only the last rule configuration is used."));        assertTrue(logging.getLog().contains("The ruleset rulesets/dummy/basic.xml is referenced multiple times in \"Custom Rules\"."));    }    private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        return rsf.createRuleSet("net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/" + ruleSetFilename);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.Properties;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.cache.FileAnalysisCache;import net.sourceforge.pmd.cache.NoopAnalysisCache;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.util.ClasspathClassLoader;public class ConfigurationTest {    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Test    public void testSuppressMarker() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default suppress marker", PMD.SUPPRESS_MARKER, configuration.getSuppressMarker());        configuration.setSuppressMarker("CUSTOM_MARKER");        assertEquals("Changed suppress marker", "CUSTOM_MARKER", configuration.getSuppressMarker());    }    @Test    public void testThreads() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default threads", Runtime.getRuntime().availableProcessors(), configuration.getThreads());        configuration.setThreads(0);        assertEquals("Changed threads", 0, configuration.getThreads());    }    @Test    public void testClassLoader() throws IOException {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default ClassLoader", PMDConfiguration.class.getClassLoader(), configuration.getClassLoader());        configuration.prependClasspath("some.jar");        assertEquals("Prepended ClassLoader class", ClasspathClassLoader.class,                configuration.getClassLoader().getClass());        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        assertEquals("urls length", 1, urls.length);        assertTrue("url[0]", urls[0].toString().endsWith("/some.jar"));        assertEquals("parent classLoader", PMDConfiguration.class.getClassLoader(),                configuration.getClassLoader().getParent());        configuration.setClassLoader(null);        assertEquals("Revert to default ClassLoader", PMDConfiguration.class.getClassLoader(),                configuration.getClassLoader());    }    @Test    public void auxClasspathWithRelativeFileEmpty() throws IOException {        String relativeFilePath = "src/test/resources/net/sourceforge/pmd/cli/auxclasspath-empty.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        Assert.assertEquals(0, urls.length);    }    @Test    public void auxClasspathWithRelativeFileEmpty2() throws IOException {        String relativeFilePath = "./src/test/resources/net/sourceforge/pmd/cli/auxclasspath-empty.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        Assert.assertEquals(0, urls.length);    }    @Test    public void auxClasspathWithRelativeFile() throws IOException, URISyntaxException {        final String FILE_SCHEME = "file";        String currentWorkingDirectory = new File("").getAbsoluteFile().toURI().getPath();        String relativeFilePath = "src/test/resources/net/sourceforge/pmd/cli/auxclasspath.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        URI[] uris = new URI[urls.length];        for (int i = 0; i < urls.length; i++) {            uris[i] = urls[i].toURI();        }        URI[] expectedUris = new URI[] {            new URI(FILE_SCHEME, null, currentWorkingDirectory + "lib1.jar", null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "other/directory/lib2.jar", null),            new URI(FILE_SCHEME, null, new File("/home/jondoe/libs/lib3.jar").getAbsoluteFile().toURI().getPath(), null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "classes", null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "classes2", null),            new URI(FILE_SCHEME, null, new File("/home/jondoe/classes").getAbsoluteFile().toURI().getPath(), null),            new URI(FILE_SCHEME, null, currentWorkingDirectory, null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "relative source dir/bar", null),        };        Assert.assertArrayEquals(expectedUris, uris);    }    @Test    public void testRuleSets() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default RuleSets", null, configuration.getRuleSets());        configuration.setRuleSets("/rulesets/basic.xml");        assertEquals("Changed RuleSets", "/rulesets/basic.xml", configuration.getRuleSets());    }    @Test    public void testMinimumPriority() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default minimum priority", RulePriority.LOW, configuration.getMinimumPriority());        configuration.setMinimumPriority(RulePriority.HIGH);        assertEquals("Changed minimum priority", RulePriority.HIGH, configuration.getMinimumPriority());    }    @Test    public void testSourceEncoding() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default source encoding", System.getProperty("file.encoding"), configuration.getSourceEncoding().name());        configuration.setSourceEncoding(StandardCharsets.UTF_16LE.name());        assertEquals("Changed source encoding", StandardCharsets.UTF_16LE, configuration.getSourceEncoding());    }    @Test    public void testInputPaths() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default input paths", null, configuration.getInputPaths());        configuration.setInputPaths("a,b,c");        assertEquals("Changed input paths", "a,b,c", configuration.getInputPaths());    }    @Test    public void testReportShortNames() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report short names", false, configuration.isReportShortNames());        configuration.setReportShortNames(true);        assertEquals("Changed report short names", true, configuration.isReportShortNames());    }    @Test    public void testReportFormat() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report format", null, configuration.getReportFormat());        configuration.setReportFormat("csv");        assertEquals("Changed report format", "csv", configuration.getReportFormat());    }    @Test    public void testCreateRenderer() {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setReportFormat("csv");        Renderer renderer = configuration.createRenderer();        assertEquals("Renderer class", CSVRenderer.class, renderer.getClass());        assertEquals("Default renderer show suppressed violations", false, renderer.isShowSuppressedViolations());        configuration.setShowSuppressedViolations(true);        renderer = configuration.createRenderer();        assertEquals("Renderer class", CSVRenderer.class, renderer.getClass());        assertEquals("Changed renderer show suppressed violations", true, renderer.isShowSuppressedViolations());    }    @Test    public void testReportFile() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report file", null, configuration.getReportFile());        configuration.setReportFile("somefile");        assertEquals("Changed report file", "somefile", configuration.getReportFile());    }    @Test    public void testShowSuppressedViolations() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default show suppressed violations", false, configuration.isShowSuppressedViolations());        configuration.setShowSuppressedViolations(true);        assertEquals("Changed show suppressed violations", true, configuration.isShowSuppressedViolations());    }    @Test    public void testReportProperties() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report properties size", 0, configuration.getReportProperties().size());        configuration.getReportProperties().put("key", "value");        assertEquals("Changed report properties size", 1, configuration.getReportProperties().size());        assertEquals("Changed report properties value", "value", configuration.getReportProperties().get("key"));        configuration.setReportProperties(new Properties());        assertEquals("Replaced report properties size", 0, configuration.getReportProperties().size());    }    @Test    public void testDebug() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default debug", false, configuration.isDebug());        configuration.setDebug(true);        assertEquals("Changed debug", true, configuration.isDebug());    }    @Test    public void testStressTest() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default stress test", false, configuration.isStressTest());        configuration.setStressTest(true);        assertEquals("Changed stress test", true, configuration.isStressTest());    }    @Test    public void testBenchmark() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default benchmark", false, configuration.isBenchmark());        configuration.setBenchmark(true);        assertEquals("Changed benchmark", true, configuration.isBenchmark());    }    @Test    public void testAnalysisCache() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        assertNotNull("Default cache is null", configuration.getAnalysisCache());        assertTrue("Default cache is not a noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setAnalysisCache(null);        assertNotNull("Default cache was set to null", configuration.getAnalysisCache());        final File cacheFile = folder.newFile();        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertSame("Configured cache not stored", analysisCache, configuration.getAnalysisCache());    }    @Test    public void testAnalysisCacheLocation() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        configuration.setAnalysisCacheLocation(null);        assertNotNull("Null cache location accepted", configuration.getAnalysisCache());        assertTrue("Null cache location accepted", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setAnalysisCacheLocation("pmd.cache");        assertNotNull("Not null cache location produces null cache", configuration.getAnalysisCache());        assertTrue("File cache location doesn't produce a file cache",                configuration.getAnalysisCache() instanceof FileAnalysisCache);    }    @Test    public void testIgnoreIncrementalAnalysis() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        // set dummy cache location        final File cacheFile = folder.newFile();        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertNotNull("Null cache location accepted", configuration.getAnalysisCache());        assertFalse("Non null cache location, cache should not be noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setIgnoreIncrementalAnalysis(true);        assertTrue("Ignoring incremental analysis should turn the cache into a noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.lang3.StringUtils;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.junit.LocaleRule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.ResourceLoader;public class RuleSetFactoryTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    @org.junit.Rule    public LocaleRule localeRule = LocaleRule.en();    @Test    public void testRuleSetFileName() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertNull("RuleSet file name not expected", rs.getFileName());        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        rs = rsf.createRuleSet("net/sourceforge/pmd/TestRuleset1.xml");        assertEquals("wrong RuleSet file name", rs.getFileName(), "net/sourceforge/pmd/TestRuleset1.xml");    }    @Test    public void testNoRuleSetFileName() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertNull("RuleSet file name not expected", rs.getFileName());    }    @Test    public void testRefs() throws Exception {        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        RuleSet rs = rsf.createRuleSet("net/sourceforge/pmd/TestRuleset1.xml");        assertNotNull(rs.getRuleByName("TestRuleRef"));    }    @Test    public void testExtendedReferences() throws Exception {        InputStream in = new ResourceLoader().loadClassPathResourceAsStream("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        assertNotNull("Test ruleset not found - can't continue with test!", in);        in.close();        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        RuleSets rs = rsf.createRuleSets("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        // added by referencing a complete ruleset (TestRuleset1.xml)        assertNotNull(rs.getRuleByName("MockRule1"));        assertNotNull(rs.getRuleByName("MockRule2"));        assertNotNull(rs.getRuleByName("MockRule3"));        assertNotNull(rs.getRuleByName("TestRuleRef"));        // added by specific reference        assertNotNull(rs.getRuleByName("TestRule"));        // this is from TestRuleset2.xml, but not referenced        assertNull(rs.getRuleByName("TestRule2Ruleset2"));        Rule mockRule3 = rs.getRuleByName("MockRule3");        assertEquals("Overridden message", mockRule3.getMessage());        assertEquals(2, mockRule3.getPriority().getPriority());        Rule mockRule2 = rs.getRuleByName("MockRule2");        assertEquals("Just combine them!", mockRule2.getMessage());        // assert that MockRule2 is only once added to the ruleset, so that it        // really        // overwrites the configuration inherited from TestRuleset1.xml        assertEquals(1, countRule(rs, "MockRule2"));        Rule mockRule1 = rs.getRuleByName("MockRule1");        assertNotNull(mockRule1);        PropertyDescriptor<?> prop = mockRule1.getPropertyDescriptor("testIntProperty");        Object property = mockRule1.getProperty(prop);        assertEquals("5", String.valueOf(property));        // included from TestRuleset3.xml        assertNotNull(rs.getRuleByName("Ruleset3Rule2"));        // excluded from TestRuleset3.xml        assertNull(rs.getRuleByName("Ruleset3Rule1"));        // overridden to 5        Rule ruleset4Rule1 = rs.getRuleByName("Ruleset4Rule1");        assertNotNull(ruleset4Rule1);        assertEquals(5, ruleset4Rule1.getPriority().getPriority());        assertEquals(1, countRule(rs, "Ruleset4Rule1"));        // priority overridden for whole TestRuleset4 group        Rule ruleset4Rule2 = rs.getRuleByName("Ruleset4Rule2");        assertNotNull(ruleset4Rule2);        assertEquals(2, ruleset4Rule2.getPriority().getPriority());    }    private int countRule(RuleSets rs, String ruleName) {        int count = 0;        for (Rule r : rs.getAllRules()) {            if (ruleName.equals(r.getName())) {                count++;            }        }        return count;    }    @Test(expected = RuleSetNotFoundException.class)    public void testRuleSetNotFound() throws RuleSetNotFoundException {        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        rsf.createRuleSet("fooooo");    }    @Test    public void testCreateEmptyRuleSet() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    @Test    public void testSingleRule() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(SINGLE_RULE);        assertEquals(1, rs.size());        Rule r = rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("net.sourceforge.pmd.lang.rule.MockRule", r.getRuleClass());        assertEquals("avoid the mock rule", r.getMessage());    }    @Test    public void testMultipleRules() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(MULTIPLE_RULES);        assertEquals(2, rs.size());        Set<String> expected = new HashSet<>();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Rule rule : rs.getRules()) {            assertTrue(expected.contains(rule.getName()));        }    }    @Test    public void testSingleRuleWithPriority() throws RuleSetNotFoundException {        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());    }    @Test    @SuppressWarnings("unchecked")    public void testProps() throws RuleSetNotFoundException {        Rule r = loadFirstRule(PROPERTIES);        assertEquals("bar", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor("fooString")));        assertEquals(new Integer(3), r.getProperty((PropertyDescriptor<Integer>) r.getPropertyDescriptor("fooInt")));        assertTrue(r.getProperty((PropertyDescriptor<Boolean>) r.getPropertyDescriptor("fooBoolean")));        assertEquals(3.0d, r.getProperty((PropertyDescriptor<Double>) r.getPropertyDescriptor("fooDouble")), 0.05);        assertNull(r.getPropertyDescriptor("BuggleFish"));        assertNotSame(r.getDescription().indexOf("testdesc2"), -1);    }    @Test    public void testStringMultiPropertyDefaultDelimiter() throws Exception {        Rule r = loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ruleset name=\"the ruleset\">\n  <description>Desc</description>\n"                                   + "     <rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s instead.\" \n"                                   + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                                   + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                                   + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                                   + " value=\"com.aptsssss|com.abc\" \ntype=\"List[String]\" "                                   + "description=\"valid packages\"/>\n         </properties></rule></ruleset>");        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor("packageRegEx");        List<String> values = r.getProperty(prop);        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), values);    }    @Test    public void testStringMultiPropertyDelimiter() throws Exception {        Rule r = loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n "                                   + " <description>ruleset desc</description>\n     "                                   + "<rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s"                                   + " instead.\" \n" + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                                   + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                                   + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                                   + " value=\"com.aptsssss,com.abc\" \ntype=\"List[String]\" delimiter=\",\" "                                   + "description=\"valid packages\"/>\n"                                   + "         </properties></rule>" + "</ruleset>");        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor("packageRegEx");        List<String> values = r.getProperty(prop);        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), values);    }    @Test    public void testRuleSetWithDeprecatedRule() throws Exception {        RuleSet rs = loadRuleSet("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"ruleset\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule deprecated=\"true\" ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\"/>"                + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("DummyBasicMockRule");        assertNotNull(rule);    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole, we shouldn't get a deprecation warning. The deprecated     * rule reference should be ignored, so at the end, we only have the new rule name in the ruleset.     * This is because the deprecated reference points to a rule in the same ruleset.     *     * @throws Exception     */    @Test    public void testRuleSetWithDeprecatedButRenamedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                + "         <description>d</description>\n" + "         <priority>2</priority>\n" + "     </rule>"                + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("NewName");        assertNotNull(rule);        assertNull(rs.getRuleByName("OldName"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole for generating the documentation, we should still     * include the deprecated rule reference, so that we can create a nice documentation.     *     * @throws Exception     */    @Test    public void testRuleSetWithDeprecatedRenamedRuleForDoc() throws Exception {        RuleSetFactory rsf = RulesetsFactoryUtils.createFactory(RulePriority.LOW, false, false, true);        RuleSet rs = rsf.createRuleSet(createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                + "         <description>d</description>\n" + "         <priority>2</priority>\n" + "     </rule>"                + "</ruleset>"));        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("NewName"));        assertNotNull(rs.getRuleByName("OldName"));    }    /**     * This is an example of a custom user ruleset, that references a rule, that has been renamed.     * The user should get a deprecation warning.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesADeprecatedRenamedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule\"/>" + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("OldNameOfDummyBasicMockRule");        assertNotNull(rule);        assertEquals(1,            StringUtils.countMatches(logging.getLog(),                "WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule."));    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Although the referenced ruleset contains     * a deprecated rule, there should be no warning about it, because all deprecated rules are ignored,     * if a whole ruleset is referenced.     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesRulesetWithADeprecatedRenamedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"/>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule. The deprecated     * rule is excluded.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Since the deprecated rule is excluded,     * there should be no deprecation warning at all, although the deprecated ruleset would have been     * excluded by default (without explictly excluding it).     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesRulesetWithAExcludedDeprecatedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"DeprecatedRule\"/></rule>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     * There is a exclusion of a rule, that no longer exists.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset.     * Since the rule to be excluded doesn't exist, there should be a warning about that.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesRulesetWithAExcludedNonExistingRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"NonExistingRule\"/></rule>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertEquals(0,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Discontinue using Rule rulesets/dummy/basic.xml/DeprecatedRule as it is scheduled for removal from PMD."));        assertEquals(1,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Unable to exclude rules [NonExistingRule] from ruleset reference rulesets/dummy/basic.xml; perhaps the rule name is misspelled or the rule doesn't exist anymore?"));    }    /**     * When a custom ruleset references a ruleset that only contains deprecated rules, then this ruleset itself is     * considered deprecated and the user should get a deprecation warning for the ruleset.     */    @Test    public void testRuleSetReferencesDeprecatedRuleset() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/deprecated.xml\" />" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertEquals(1,                StringUtils.countMatches(logging.getLog(),                    "WARNING: The RuleSet rulesets/dummy/deprecated.xml has been deprecated and will be removed in PMD"));    }    /**     * When a custom ruleset references a ruleset that contains both rules and rule references, that are left     * for backwards compatibility, because the rules have been moved to a different ruleset, then there should be     * no warning about deprecation - since the deprecated rules are not used.     */    @Test    public void testRuleSetReferencesRulesetWithAMovedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic2.xml\" />" + "</ruleset>");        assertEquals(1, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasic2MockRule"));        assertEquals(0,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic2.xml/DummyBasicMockRule. PMD"));    }    @Test    @SuppressWarnings("unchecked")    public void testXPath() throws RuleSetNotFoundException {        Rule r = loadFirstRule(XPATH);        PropertyDescriptor<String> xpathProperty = (PropertyDescriptor<String>) r.getPropertyDescriptor("xpath");        assertNotNull("xpath property descriptor", xpathProperty);        assertNotSame(r.getProperty(xpathProperty).indexOf(" //Block "), -1);    }    @Test    public void testFacadesOffByDefault() throws RuleSetNotFoundException {        Rule r = loadFirstRule(XPATH);        assertFalse(r.isDfa());    }    @Test    public void testDFAFlag() throws RuleSetNotFoundException {        assertTrue(loadFirstRule(DFA).isDfa());    }    @Test    public void testExternalReferenceOverride() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REF_OVERRIDE);        assertEquals("TestNameOverride", r.getName());        assertEquals("Test message override", r.getMessage());        assertEquals("Test description override", r.getDescription());        assertEquals("Test that both example are stored", 2, r.getExamples().size());        assertEquals("Test example override", r.getExamples().get(1));        assertEquals(RulePriority.MEDIUM, r.getPriority());        PropertyDescriptor<?> test2Descriptor = r.getPropertyDescriptor("test2");        assertNotNull("test2 descriptor", test2Descriptor);        assertEquals("override2", r.getProperty(test2Descriptor));        PropertyDescriptor<?> test3Descriptor = r.getPropertyDescriptor("test3");        assertNotNull("test3 descriptor", test3Descriptor);        assertEquals("override3", r.getProperty(test3Descriptor));    }    @Test    public void testExternalReferenceOverrideNonExistent() throws RuleSetNotFoundException {        ex.expect(IllegalArgumentException.class);        ex.expectMessage("Cannot set non-existent property 'test4' on Rule TestNameOverride");        loadFirstRule(REF_OVERRIDE_NONEXISTENT);    }    @Test    public void testReferenceInternalToInternal() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull("Could not find Rule MockRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull("Could not find Rule MockRuleNameRef", ruleRef);    }    @Test    public void testReferenceInternalToInternalChain() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull("Could not find Rule MockRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull("Could not find Rule MockRuleNameRef", ruleRef);        Rule ruleRefRef = ruleSet.getRuleByName("MockRuleNameRefRef");        assertNotNull("Could not find Rule MockRuleNameRefRef", ruleRefRef);    }    @Test    public void testReferenceInternalToExternal() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull("Could not find Rule ExternalRefRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRef", ruleRef);    }    @Test    public void testReferenceInternalToExternalChain() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull("Could not find Rule ExternalRefRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRef", ruleRef);        Rule ruleRefRef = ruleSet.getRuleByName("ExternalRefRuleNameRefRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRefRef", ruleRefRef);    }    @Test    public void testReferencePriority() throws RuleSetNotFoundException {        RuleSetLoader config = new RuleSetLoader().warnDeprecated(false).enableCompatibility(true);        RuleSetFactory rsf = config.filterAbovePriority(RulePriority.LOW).toFactory();        RuleSet ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));        assertEquals("Number of Rules", 3, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleName"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.MEDIUM_HIGH).toFactory();        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));        assertEquals("Number of Rules", 2, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.HIGH).toFactory();        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));        assertEquals("Number of Rules", 1, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.LOW).toFactory();        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));        assertEquals("Number of Rules", 3, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleName"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.MEDIUM_HIGH).toFactory();        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));        assertEquals("Number of Rules", 2, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.HIGH).toFactory();        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));        assertEquals("Number of Rules", 1, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));    }    @Test    public void testOverridePriorityLoadWithMinimum() throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_LOW).warnDeprecated(true).enableCompatibility(true).toFactory();        RuleSet ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        // only one rule should remain, since we filter out the other rule by minimum priority        assertEquals("Number of Rules", 1, ruleset.getRules().size());        // Priority is overridden and applied, rule is missing        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        // now, load with default minimum priority        rsf = RulesetsFactoryUtils.defaultFactory();        ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        assertEquals("Number of Rules", 2, ruleset.getRules().size());        Rule dummyBasicMockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertEquals("Wrong Priority", RulePriority.LOW, dummyBasicMockRule.getPriority());    }    @Test    public void testExcludeWithMinimumPriority() throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetLoader().filterAbovePriority(RulePriority.HIGH).toFactory();        RuleSet ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // no rules should be loaded        assertEquals("Number of Rules", 0, ruleset.getRules().size());        // now, load with default minimum priority        rsf = new RuleSetLoader().filterAbovePriority(RulePriority.LOW).toFactory();        ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // only one rule, we have excluded one...        assertEquals("Number of Rules", 1, ruleset.getRules().size());        // rule is excluded        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));    }    @Test    public void testOverrideMessage() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test    public void testOverrideMessageOneElem() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectExternalRef() throws IllegalArgumentException, RuleSetNotFoundException {        loadFirstRule(REF_MISSPELLED_XREF);    }    @Test    public void testSetPriority() throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_HIGH).warnDeprecated(false).toFactory();        assertEquals(0, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());        rsf = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_LOW).warnDeprecated(false).toFactory();        assertEquals(1, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());    }    @Test    public void testLanguage() throws RuleSetNotFoundException {        Rule r = loadFirstRule(LANGUAGE);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME), r.getLanguage());    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectLanguage() throws RuleSetNotFoundException {        loadFirstRule(INCORRECT_LANGUAGE);    }    @Test    public void testMinimumLanguageVersion() throws RuleSetNotFoundException {        Rule r = loadFirstRule(MINIMUM_LANGUAGE_VERSION);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.4"),                r.getMinimumLanguageVersion());    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectMinimumLanguageVersion() throws RuleSetNotFoundException {        loadFirstRule(INCORRECT_MINIMUM_LANGUAGE_VERSION);    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectMinimumLanugageVersionWithLanguageSetInJava() throws RuleSetNotFoundException {        loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                          + "<ruleset name=\"TODO\">\n"                          + "    <description>TODO</description>\n"                          + "\n"                          + "    <rule name=\"TODO\"\n"                          + "          message=\"TODO\"\n"                          + "          class=\"net.sourceforge.pmd.util.FooRuleWithLanguageSetInJava\"\n"                          + "          minimumLanguageVersion=\"12\">\n"                          + "        <description>TODO</description>\n"                          + "        <priority>2</priority>\n"                          + "    </rule>\n"                          + "\n"                          + "</ruleset>");    }    @Test    public void testMaximumLanugageVersion() throws RuleSetNotFoundException {        Rule r = loadFirstRule(MAXIMUM_LANGUAGE_VERSION);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                r.getMaximumLanguageVersion());    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectMaximumLanguageVersion() throws RuleSetNotFoundException {        loadFirstRule(INCORRECT_MAXIMUM_LANGUAGE_VERSION);    }    @Test(expected = IllegalArgumentException.class)    public void testInvertedMinimumMaximumLanugageVersions() throws RuleSetNotFoundException {        loadFirstRule(INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS);    }    @Test    public void testDirectDeprecatedRule() throws RuleSetNotFoundException {        Rule r = loadFirstRule(DIRECT_DEPRECATED_RULE);        assertNotNull("Direct Deprecated Rule", r);        assertTrue(r.isDeprecated());    }    @Test    public void testReferenceToDeprecatedRule() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REFERENCE_TO_DEPRECATED_RULE);        assertNotNull("Reference to Deprecated Rule", r);        assertTrue("Rule Reference", r instanceof RuleReference);        assertFalse("Not deprecated", r.isDeprecated());        assertTrue("Original Rule Deprecated", ((RuleReference) r).getRule().isDeprecated());        assertEquals("Rule name", r.getName(), DEPRECATED_RULE_NAME);    }    @Test    public void testRuleSetReferenceWithDeprecatedRule() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE);        assertNotNull("RuleSet", ruleSet);        assertFalse("RuleSet empty", ruleSet.getRules().isEmpty());        // No deprecated Rules should be loaded when loading an entire RuleSet        // by reference - unless it contains only deprecated rules - then all rules would be added        Rule r = ruleSet.getRuleByName(DEPRECATED_RULE_NAME);        assertNull("Deprecated Rule Reference", r);        for (Rule rule : ruleSet.getRules()) {            assertFalse("Rule not deprecated", rule.isDeprecated());        }    }    @Test    public void testDeprecatedRuleSetReference() throws RuleSetNotFoundException {        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleSet = ruleSetFactory.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-deprecated.xml");        assertEquals(2, ruleSet.getRules().size());    }    @Test    public void testExternalReferences() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);        assertEquals(1, rs.size());        assertEquals(MockRule.class.getName(), rs.getRuleByName("MockRule").getRuleClass());    }    @Test    public void testIncludeExcludePatterns() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(INCLUDE_EXCLUDE_RULESET);        assertNotNull("Include patterns", ruleSet.getIncludePatterns());        assertEquals("Include patterns size", 2, ruleSet.getIncludePatterns().size());        assertEquals("Include pattern #1", "include1", ruleSet.getIncludePatterns().get(0));        assertEquals("Include pattern #2", "include2", ruleSet.getIncludePatterns().get(1));        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertEquals("Exclude patterns size", 3, ruleSet.getExcludePatterns().size());        assertEquals("Exclude pattern #1", "exclude1", ruleSet.getExcludePatterns().get(0));        assertEquals("Exclude pattern #2", "exclude2", ruleSet.getExcludePatterns().get(1));        assertEquals("Exclude pattern #3", "exclude3", ruleSet.getExcludePatterns().get(2));    }    /**     * Rule reference can't be resolved - ref is used instead of class and the     * class is old (pmd 4.3 and not pmd 5).     *     * @throws Exception     *             any error     */    @Test(expected = RuleSetNotFoundException.class)    public void testBug1202() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset>\n"                + "  <rule ref=\"net.sourceforge.pmd.rules.XPathRule\">\n" + "    <priority>1</priority>\n"                + "    <properties>\n" + "      <property name=\"xpath\" value=\"//TypeDeclaration\" />\n"                + "      <property name=\"message\" value=\"Foo\" />\n" + "    </properties>\n" + "  </rule>\n"                + "</ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        ruleSetFactory.createRuleSet(ref);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1225/     *     * @throws Exception     *             any error     */    @Test    public void testEmptyRuleSetFile() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "\n"                + "<ruleset name=\"Custom ruleset\" xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http:www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "    <description>PMD Ruleset.</description>\n" + "\n"                + "    <exclude-pattern>.*Test.*</exclude-pattern>\n" + "\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        assertEquals(0, ruleset.getRules().size());    }    /**     * See https://github.com/pmd/pmd/issues/782     * Empty ruleset should be interpreted as deprecated.     *     * @throws Exception     *             any error     */    @Test    public void testEmptyRuleSetReferencedShouldNotBeDeprecated() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "\n"                + "<ruleset name=\"Custom ruleset\" xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http:www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "    <description>Ruleset which references a empty ruleset</description>\n" + "\n"                + "    <rule ref=\"rulesets/dummy/empty-ruleset.xml\" />\n"                + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetLoader().loadResourcesWith(new ResourceLoader()).filterAbovePriority(RulePriority.LOW).warnDeprecated(true).enableCompatibility(true).toFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        assertEquals(0, ruleset.getRules().size());        assertTrue(logging.getLog().isEmpty());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     *     * @throws Exception     *             any error     */    @Test(expected = IllegalArgumentException.class)    public void testWrongRuleNameReferenced() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\"?>\n"                + "<ruleset name=\"Custom ruleset for tests\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Custom ruleset for tests</description>\n"                + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/ThisRuleDoesNotExist\"/>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        ruleSetFactory.createRuleSet(ref);    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     * @throws Exception     *             any error     */    @Test    public void testRuleReferenceWithNameOverridden() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                + "<ruleset xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "         name=\"pmd-eclipse\"\n"                + "         xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "   <description>PMD Plugin preferences rule set</description>\n" + "\n"                + "<rule name=\"OverriddenDummyBasicMockRule\"\n"                + "    ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\">\n" + "</rule>\n" + "\n" + "</ruleset>");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet rs = ruleSetFactory.createRuleSet(ref);        Rule r = rs.getRules().toArray(new Rule[1])[0];        assertEquals("OverriddenDummyBasicMockRule", r.getName());        RuleReference ruleRef = (RuleReference) r;        assertEquals("DummyBasicMockRule", ruleRef.getRule().getName());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     *     * <p>See https://github.com/pmd/pmd/issues/1978 - with that, it should not be an error anymore.     *     * @throws Exception     *             any error     */    @Test    public void testWrongRuleNameExcluded() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml\">\n"                        + "    <exclude name=\"ThisRuleDoesNotExist\"/>\n" + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        assertEquals(4, ruleset.getRules().size());    }    /**     * This unit test manifests the current behavior - which might change in the     * future. See #1537.     *     * Currently, if a ruleset is imported twice, the excludes of the first     * import are ignored. Duplicated rules are silently ignored.     *     * @throws Exception     *             any error     * @see <a href="https://sourceforge.net/p/pmd/bugs/1537/">#1537 Implement     *      strict ruleset parsing</a>     * @see <a href=     *      "http://stackoverflow.com/questions/40299075/custom-pmd-ruleset-not-working">stackoverflow     *      - custom ruleset not working</a>     */    @Test    public void testExcludeAndImportTwice() throws Exception {        RuleSetReferenceId ref1 = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\">\n" + "    <exclude name=\"DummyBasicMockRule\"/>\n"                        + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref1);        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        RuleSetReferenceId ref2 = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\">\n" + "    <exclude name=\"DummyBasicMockRule\"/>\n"                        + "  </rule>\n" + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory2 = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleset2 = ruleSetFactory2.createRuleSet(ref2);        assertNotNull(ruleset2.getRuleByName("DummyBasicMockRule"));        RuleSetReferenceId ref3 = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n" + "  <rule ref=\"rulesets/dummy/basic.xml\">\n"                        + "    <exclude name=\"DummyBasicMockRule\"/>\n" + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory3 = RulesetsFactoryUtils.defaultFactory();        RuleSet ruleset3 = ruleSetFactory3.createRuleSet(ref3);        assertNotNull(ruleset3.getRuleByName("DummyBasicMockRule"));    }    @org.junit.Rule    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());    @Test    public void testMissingRuleSetNameIsWarning() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset \n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                        + "  </ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        ruleSetFactory.createRuleSet(ref);        assertTrue(logging.getLog().contains("RuleSet name is missing."));    }    @Test    public void testMissingRuleSetDescriptionIsWarning() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"then name\"\n"                    + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                    + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                    + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                    + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                    + "  </ruleset>\n");        RuleSetFactory ruleSetFactory = RulesetsFactoryUtils.defaultFactory();        ruleSetFactory.createRuleSet(ref);        assertTrue(logging.getLog().contains("RuleSet description is missing."));    }    private static final String REF_OVERRIDE_ORIGINAL_NAME = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "\n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"> \n"        + "\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_MISSPELLED_XREF = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/FooMockRule1\"> \n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"/> \n"        + "\n"        + "</ruleset>";    private static final String REF_OVERRIDE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" \n"        + "  name=\"TestNameOverride\" \n"        + "\n"        + "  message=\"Test message override\"> \n"        + "  <description>Test description override</description>\n"        + "  <example>Test example override</example>\n"        + "  <priority>3</priority>\n"        + "  <properties>\n"        + "   <property name=\"test2\" description=\"test2\" type=\"String\" value=\"override2\"/>\n"        + "   <property name=\"test3\" type=\"String\" description=\"test3\"><value>override3</value></property>\n"        + "\n"        + "  </properties>\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_OVERRIDE_NONEXISTENT = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" \n"        + "  name=\"TestNameOverride\" \n"        + "\n"        + "  message=\"Test message override\"> \n"        + "  <description>Test description override</description>\n"        + "  <example>Test example override</example>\n"        + "  <priority>3</priority>\n"        + "  <properties>\n"        + "   <property name=\"test4\" description=\"test4\" type=\"String\" value=\"new property\"/>\n"        + "  </properties>\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "</rule>\n"        + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"/> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL_CHAIN = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "</rule>\n"        + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"><priority>2</priority></rule> \n"        + " <rule ref=\"MockRuleNameRef\" name=\"MockRuleNameRefRef\"><priority>1</priority></rule> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "name=\"ExternalRefRuleName\" \n"        + "ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\"/>\n"        + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"/> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL_CHAIN = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "name=\"ExternalRefRuleName\" \n"        + "ref=\"net/sourceforge/pmd/TestRuleset2.xml/TestRule\"/>\n"        + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"><priority>2</priority></rule> \n"        + "\n"        + " <rule ref=\"ExternalRefRuleNameRef\" name=\"ExternalRefRuleNameRefRef\"><priority>1</priority></rule> \n"        + "\n"        + "</ruleset>";    private static final String EMPTY_RULESET = "<?xml version=\"1.0\"?>\n<ruleset name=\"test\">\n<description>testdesc</description>\n</ruleset>";    private static final String SINGLE_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "</rule></ruleset>";    private static final String MULTIPLE_RULES = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + "<description>testdesc</description>\n"        + "<rule name=\"MockRuleName1\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "\n"        + "</rule>\n"        + "<rule name=\"MockRuleName2\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "\n"        + "</rule></ruleset>";    private static final String PROPERTIES = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule name=\"MockRuleName\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "\n"        + "<description>testdesc2</description>\n"        + "<properties>\n"        + "<property name=\"fooBoolean\" description=\"test\" type=\"Boolean\" value=\"true\" />\n"        + "<property name=\"fooChar\" description=\"test\" type=\"Character\" value=\"B\" />\n"        + "<property name=\"fooInt\" description=\"test\" type=\"Integer\" min=\"1\" max=\"10\" value=\"3\" />\n"        + "\n"        + "<property name=\"fooFloat\" description=\"test\" type=\"Float\" min=\"1.0\" max=\"1.0\" value=\"1.0\"  />\n"        + "\n"        + "<property name=\"fooDouble\" description=\"test\" type=\"Double\" min=\"1.0\" max=\"9.0\" value=\"3.0\"  />\n"        + "\n"        + "<property name=\"fooString\" description=\"test\" type=\"String\" value=\"bar\" />\n"        + "</properties>\n"        + "</rule></ruleset>";    private static final String XPATH = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule name=\"MockRuleName\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "\n"        + "<description>testdesc2</description>\n"        + "<properties>\n"        + "<property name=\"xpath\" description=\"test\" type=\"String\">\n"        + "<value>\n"        + "<![CDATA[ //Block ]]>\n"        + "</value>\n"        + "</property>\n"        + "</properties>\n"        + "</rule></ruleset>";    private static final String PRIORITY = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "</rule></ruleset>";    private static final String LANGUAGE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" "        + "language=\"dummy\">\n"        + "</rule></ruleset>";    private static final String INCORRECT_LANGUAGE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "\n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"bogus\">\n"        + "</rule></ruleset>";    private static final String MINIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " minimumLanguageVersion=\"1.4\">\n"        + "</rule></ruleset>";    private static final String INCORRECT_MINIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " minimumLanguageVersion=\"bogus\">\n"        + "</rule></ruleset>";    private static final String MAXIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " maximumLanguageVersion=\"1.7\">\n"        + "</rule></ruleset>";    private static final String INCORRECT_MAXIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " maximumLanguageVersion=\"bogus\">\n"        + "</rule></ruleset>";    private static final String INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" \n"        + "language=\"dummy\"\n"        + " minimumLanguageVersion=\"1.7\"\n"        + "maximumLanguageVersion=\"1.4\">\n"        + "</rule></ruleset>";    private static final String DIRECT_DEPRECATED_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" deprecated=\"true\">\n"        + "</rule></ruleset>";    // Note: Update this RuleSet name to a different RuleSet with deprecated    // Rules when the Rules are finally removed.    private static final String DEPRECATED_RULE_RULESET_NAME = "net/sourceforge/pmd/TestRuleset1.xml";    // Note: Update this Rule name to a different deprecated Rule when the one    // listed here is finally removed.    private static final String DEPRECATED_RULE_NAME = "MockRule3";    private static final String REFERENCE_TO_DEPRECATED_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule " + "ref=\"" + DEPRECATED_RULE_RULESET_NAME + "/" + DEPRECATED_RULE_NAME + "\" />\n"        + "</ruleset>";    private static final String REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule " + "ref=\"" + DEPRECATED_RULE_RULESET_NAME + "\" />\n"        + "</ruleset>";    private static final String DFA = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "dfa=\"true\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"><priority>3</priority>\n"        + "</rule></ruleset>";    private static final String INCLUDE_EXCLUDE_RULESET = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<include-pattern>include1</include-pattern>\n"        + "<include-pattern>include2</include-pattern>\n"        + "\n"        + "<exclude-pattern>exclude1</exclude-pattern>\n"        + "<exclude-pattern>exclude2</exclude-pattern>\n"        + "<exclude-pattern>exclude3</exclude-pattern>\n"        + "\n"        + "</ruleset>";    private static final String EXTERNAL_REFERENCE_RULE_SET = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule ref=\"net/sourceforge/pmd/external-reference-ruleset.xml/MockRule\"/>\n"        + "</ruleset>";    private Rule loadFirstRule(String ruleSetXml) throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(ruleSetXml);        return rs.getRules().iterator().next();    }    private RuleSet loadRuleSet(String ruleSetXml) throws RuleSetNotFoundException {        RuleSetFactory rsf = RulesetsFactoryUtils.defaultFactory();        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));    }    private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetLoader().warnDeprecated(true).enableCompatibility(false).toFactory();        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));    }    private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {        return new RuleSetReferenceId(null) {            @Override            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {                return new ByteArrayInputStream(ruleSetXml.getBytes(StandardCharsets.UTF_8));            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Test;import junit.framework.JUnit4TestAdapter;public class RuleContextTest {    @Test    public void testReport() {        RuleContext ctx = new RuleContext();        assertEquals(0, ctx.getReport().size());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    @Test    public void testSourceCodeFilename() {        RuleContext ctx = new RuleContext();        assertEquals("filename should be empty", "", ctx.getSourceCodeFilename());        ctx.setSourceCodeFile(new File("dir/foo.java"));        assertEquals("filename mismatch", "foo.java", ctx.getSourceCodeFilename());    }    @Test    public void testSourceCodeFile() {        RuleContext ctx = new RuleContext();        assertNull("file should be null", ctx.getSourceCodeFile());        ctx.setSourceCodeFile(new File("somefile.java"));        assertEquals("filename mismatch", new File("somefile.java"), ctx.getSourceCodeFile());    }    @Test    public void testAttributes() {        RuleContext ctx1 = new RuleContext();        Object obj1 = new Object();        Object obj2 = new Object();        assertNull("attribute should be null", ctx1.getAttribute("attribute"));        boolean set = ctx1.setAttribute("attribute", obj1);        assertTrue("attribute should have been set", set);        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute"));        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute"), obj1);        set = ctx1.setAttribute("attribute", obj2);        assertFalse("attribute should not have been set", set);        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute"), obj1);        Object value = ctx1.removeAttribute("attribute");        assertSame("attribute value should be expected instance", value, obj1);        assertNull("attribute should be null", ctx1.getAttribute("attribute"));    }    @Test    public void testSharedAttributes() {        RuleContext ctx1 = new RuleContext();        RuleContext ctx2 = new RuleContext(ctx1);        StringBuilder obj1 = new StringBuilder();        StringBuilder obj2 = new StringBuilder();        ctx1.setAttribute("attribute1", obj1);        ctx2.setAttribute("attribute2", obj2);        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute1"));        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute2"));        assertNotNull("attribute should not be null", ctx2.getAttribute("attribute1"));        assertNotNull("attribute should not be null", ctx2.getAttribute("attribute2"));        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute1"), obj1);        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute2"), obj2);        assertSame("attribute should be expected instance", ctx2.getAttribute("attribute1"), obj1);        assertSame("attribute should be expected instance", ctx2.getAttribute("attribute2"), obj2);        ctx1.removeAttribute("attribute1");        assertNull("attribute should be null", ctx1.getAttribute("attribute1"));        assertNull("attribute should be null", ctx2.getAttribute("attribute1"));        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute2"));        assertNotNull("attribute should not be null", ctx2.getAttribute("attribute2"));        StringBuilder value = (StringBuilder) ctx1.getAttribute("attribute2");        assertEquals("attribute value should be empty", "", value.toString());        value.append("x");        StringBuilder value1 = (StringBuilder) ctx1.getAttribute("attribute2");        assertEquals("attribute value should be 'x'", "x", value1.toString());        StringBuilder value2 = (StringBuilder) ctx2.getAttribute("attribute2");        assertEquals("attribute value should be 'x'", "x", value2.toString());    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(RuleContextTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.Comparator;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import junit.framework.JUnit4TestAdapter;public class RuleViolationTest {    @Test    public void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(2);        s.testingOnlySetBeginColumn(1);        RuleViolation r = new ParametricRuleViolation<Node>(rule, ctx, s, rule.getMessage());        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());    }    @Test    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(2);        s.testingOnlySetBeginColumn(1);        RuleViolation r = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    @Test    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename1"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(10);        s.testingOnlySetBeginColumn(1);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        ctx.setSourceCodeFile(new File("filename2"));        DummyNode s1 = new DummyNode(1);        s1.testingOnlySetBeginLine(10);        s1.testingOnlySetBeginColumn(1);        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, ctx, s1, "description");        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    @Test    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(10);        s.testingOnlySetBeginColumn(1);        DummyNode s1 = new DummyNode(1);        s1.testingOnlySetBeginLine(20);        s1.testingOnlySetBeginColumn(1);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, ctx, s1, "description");        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    @Ignore    @Test    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(10);        s.testingOnlySetBeginColumn(1);        DummyNode s1 = new DummyNode(1);        s1.testingOnlySetBeginLine(10);        s1.testingOnlySetBeginColumn(1);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, ctx, s1, "description");        assertEquals(1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(RuleViolationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.resolver;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.modelica.ModelicaParsingHelper;import net.sourceforge.pmd.lang.modelica.ast.ASTExtendsClause;import net.sourceforge.pmd.lang.modelica.ast.ASTStoredDefinition;import net.sourceforge.pmd.lang.modelica.ast.ModelicaClassSpecifierNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaParserVisitorAdapter;public class ModelicaResolverTest {    private final ModelicaParsingHelper modelica = ModelicaParsingHelper.DEFAULT;    private static class NodeFinder extends ModelicaParserVisitorAdapter {        private ModelicaNode result;        private Class<?> nodeClass;        private String nodeName;        NodeFinder(Class<?> nodeClass, String nodeName) {            this.nodeClass = nodeClass;            this.nodeName = nodeName;        }        @Override        public Object visit(ModelicaNode node, Object data) {            if (nodeClass.isInstance(node) && node.getImage().equals(nodeName)) {                Assert.assertNull(result);                result = node;            }            return super.visit(node, data);        }        ModelicaNode getResult() {            return result;        }    }    private ModelicaNode findNodeByClassAndImage(ASTStoredDefinition ast, Class<?> clazz, String image) {        NodeFinder vis = new NodeFinder(clazz, image);        ast.jjtAccept(vis, null);        return vis.getResult();    }    private void ensureCounts(ResolutionResult result, int best, int hidden) {        Assert.assertFalse(result.wasTimedOut());        Assert.assertEquals(best, result.getBestCandidates().size());        Assert.assertEquals(hidden, result.getHiddenCandidates().size());    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, SubcomponentResolver resolver, boolean absolute, String[] names) {        ResolutionResult<ResolvableEntity> result = resolver.safeResolveComponent(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, ModelicaScope resolver, boolean absolute, String[] names) {        ResolutionResult<ResolvableEntity> result = resolver.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, SubcomponentResolver scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedComponentCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forComponentReference(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testLexicallyResolvedComponents(int best, int hidden, ModelicaClassScope scope, boolean absolute, String... names) {        ResolutionState state = ResolutionState.forComponentReference();        ResolutionResult<ResolvableEntity> result = scope.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    @Test    public void verySimpleScopeTest() {        String contents =              "model TestPackage"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        Assert.assertNotNull(ast);        Assert.assertTrue(ast.getMostSpecificScope() instanceof ModelicaSourceFileScope);        ModelicaSourceFileScope scope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        Assert.assertTrue(scope.getParent() instanceof RootScope);        Assert.assertNull(scope.getParent().getParent());    }    @Test    public void simpleScopeTest() {        String contents =              "package TestPackage"            + "  connector TestConnector"            + "  end TestConnector;"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        ModelicaSourceFileScope sourceFileScope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        Assert.assertEquals(1, sourceFileScope.getContainedDeclarations().size());        ModelicaNode testSubmodel = findNodeByClassAndImage(ast, ModelicaClassSpecifierNode.class, "TestSubmodel");        Assert.assertNotNull(testSubmodel);        Assert.assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:TestSubmodel",                ((AbstractModelicaScope) testSubmodel.getMostSpecificScope()).getNestingRepresentation()        );        ModelicaScope testPackage = testSubmodel.getMostSpecificScope().getParent().getParent();        Assert.assertTrue(testPackage instanceof ModelicaClassScope);        Assert.assertEquals("TestPackage", ((ModelicaClassScope) testPackage).getClassDeclaration().getSimpleTypeName());        Assert.assertEquals(3, testPackage.getContainedDeclarations().size());    }    @Test    public void extendsScopeTest() {        String contents =                  "package Test"                + "  model A"                + "    extends B;"                + "  end A;"                + "  model B"                + "  end B;"                + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ASTExtendsClause> extendsClauses = ast.findDescendantsOfType(ASTExtendsClause.class);        Assert.assertEquals(1, extendsClauses.size());        ASTExtendsClause extendsB = extendsClauses.get(0);        Assert.assertEquals("#ROOT#FILE#Class:Test#Class:A", ((AbstractModelicaScope) extendsB.getMostSpecificScope()).getNestingRepresentation());    }    @Test    public void absoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    public void nonAbsoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    public void multipleResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model A"            + "    end A;"            + "  end TestModel;"            + "  model A"            + "  end A;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        ResolutionResult<ResolvableEntity> testModelCandidates = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel");        ModelicaClassScope testModelScope = ((ModelicaClassType) testModelCandidates.getBestCandidates().get(0)).getClassScope();        Assert.assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel",                testModelScope.getNestingRepresentation()        );        ResolutionResult<ResolvableEntity> aCandidates = testLexicallyResolvedComponents(1, 1, testModelScope, false, "A");        ModelicaClassType aBest = (ModelicaClassType) aCandidates.getBestCandidates().get(0);        ModelicaClassType aHidden = (ModelicaClassType) aCandidates.getHiddenCandidates().get(0);        Assert.assertEquals("#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:A",                aBest.getClassScope().getNestingRepresentation());        Assert.assertEquals("#ROOT#FILE#Class:TestPackage#Class:A",                aHidden.getClassScope().getNestingRepresentation());    }    @Test    public void constantComponentResolutionTest() {        String contents =              "model Test"            + "  model A"            + "    constant Real x = 1;"            + "  end A;"            + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ResolvableEntity> xs = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "A", "x").getBestCandidates();        Assert.assertEquals(            "#ROOT#FILE#Class:Test#Class:A",                ((ModelicaComponentDeclaration) xs.get(0)).getContainingScope().getNestingRepresentation()        );    }    @Test    public void nestedStoredDefinitionTest() {        String contents =              "within TestPackage.SubPackage;\n"            + "model Test\n"            + "end Test;\n";        ASTStoredDefinition ast = modelica.parse(contents);        RootScope rootScope = (RootScope) ast.getMostSpecificScope().getParent();        List<ResolvableEntity> nestedTest = testResolvedTypeCount(1, 0, rootScope, false, "TestPackage", "SubPackage", "Test").getBestCandidates();        Assert.assertEquals(                "#ROOT#FILE#Class:Test",                ((ModelicaClassType) nestedTest.get(0)).getClassScope().getNestingRepresentation()        );        // Simple names are visible from within the same file        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test");        // ... but from other files they should be resolved w.r.t. the within clause        testResolvedTypeCount(0, 0, rootScope, false, "Test");    }    @Test    public void extendsTest() {        String contents =              "model A\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "B", "X");    }    @Test    public void importTest() {        String contents =              "model I\n"            + "  model Z\n"            + "  end Z;\n"            + "end I;\n"            + "model A\n"            + "  import I.Z;\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "A", "Z");        testResolvedTypeCount(0, 0, ast.getMostSpecificScope(), false, "B", "Z");    }    @Test    public void builtinTest() {        String contents =              "model A"            + "  encapsulated model B"            + "    Real x;"            + "  end B;"            + "end A;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ResolvableEntity> xs = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), true, "A", "B", "x").getBestCandidates();        ModelicaComponentDeclaration x = (ModelicaComponentDeclaration) xs.get(0);        ResolutionResult<ModelicaType> xTypes = x.getTypeCandidates();        ensureCounts(xTypes, 1, 0);        ResolvableEntity tpe = xTypes.getBestCandidates().get(0);        Assert.assertTrue(tpe instanceof ModelicaBuiltinType);        Assert.assertEquals(ModelicaBuiltinType.BaseType.REAL, ((ModelicaBuiltinType) tpe).getBaseType());    }    @Test    public void testRepeatingNameResolution() {        String contents =                  "package Test"                + "  model X"                + "    model X"                + "    end X;"                + "    Test.X.X mdl;"                + "  end X;"                + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "Test", "X", "X");        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "X");        ResolutionResult<ResolvableEntity> result = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "mdl");        ModelicaComponentDeclaration mdl = (ModelicaComponentDeclaration) result.getBestCandidates().get(0);        ensureCounts(mdl.getTypeCandidates(), 1, 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConnectUsingNonConnectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassStartNameEqualsEndNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AmbiguousResolutionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica;import org.junit.Test;public class ModelicaParserTest {    @Test    public void testParsingGrapgical() {        ModelicaParsingHelper.DEFAULT.parseResource("ParserTestGraphical.mo");    }    @Test    public void testParsingTextual() {        ModelicaParsingHelper.DEFAULT.parseResource("ParserTestTextual.mo");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.modelica.ModelicaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ModelicaLanguageModule.NAME, ModelicaLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(ModelicaLanguageModule.NAME).getDefaultVersion(),            },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class MatlabTokenizerTest extends CpdTextComparisonTest {    public MatlabTokenizerTest() {        super(".m");    }    @Override    protected String getResourcePrefix() {        return "../lang/matlab/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new MatlabTokenizer();    }        @Test    public void testLongSample() {        doTest("sample-matlab");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testComments() {        doTest("comments");    }    @Test    public void testBlockComments() {        doTest("multilineComments");    }    @Test    public void testQuestionMark() {        doTest("questionMark");    }    @Test    public void testDoubleQuotedStrings() {        doTest("doubleQuotedStrings");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class LuaTokenizerTest extends CpdTextComparisonTest {    public LuaTokenizerTest() {        super(".lua");    }    @Override    protected String getResourcePrefix() {        return "../lang/lua/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new LuaTokenizer();    }    @Test    public void testSimple() {        doTest("helloworld");    }    @Test    public void testFactorial() {        doTest("factorial");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class RubyTokenizerTest extends CpdTextComparisonTest {    public RubyTokenizerTest() {        super(".rb");    }    @Override    protected String getResourcePrefix() {        return "../lang/ruby/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new RubyLanguage().getTokenizer();    }    @Test    public void testSimple() {        doTest("server");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.cpp;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.io.StringReader;import org.junit.Test;public class CppCharStreamTest {    @Test    public void testContinuationUnix() throws IOException {        CppCharStream stream = new CppCharStream(new StringReader("a\\\nb"));        assertStream(stream, "ab");    }    @Test    public void testContinuationWindows() throws IOException {        CppCharStream stream = new CppCharStream(new StringReader("a\\\r\nb"));        assertStream(stream, "ab");    }    @Test    public void testBackup() throws IOException {        CppCharStream stream = new CppCharStream(new StringReader("a\\b\\\rc"));        assertStream(stream, "a\\b\\\rc");    }    private void assertStream(CppCharStream stream, String token) throws IOException {        char c = stream.BeginToken();        assertEquals(token.charAt(0), c);        for (int i = 1; i < token.length(); i++) {            c = stream.readChar();            assertEquals(token.charAt(i), c);        }        assertEquals(token, stream.GetImage());        assertEquals(token, new String(stream.GetSuffix(token.length())));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class CPPTokenizerTest extends CpdTextComparisonTest {    public CPPTokenizerTest() {        super(".cpp");    }    @Override    protected String getResourcePrefix() {        return "../lang/cpp/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties props) {        CPPTokenizer tok = new CPPTokenizer();        tok.setProperties(props);        return tok;    }    @Override    public Properties defaultProperties() {        return dontSkipBlocks();    }    @Test    public void testUTFwithBOM() {        Tokenizer tokenizer = newTokenizer(dontSkipBlocks());        Tokens tokens = tokenize(tokenizer, "\ufeffint start()\n{ int ret = 1;\nreturn ret;\n}\n");        assertEquals(15, tokens.size());    }    @Test    public void testContinuation() {        doTest("continuation");    }    @Test    public void testContinuationInIdent() {        doTest("continuation_intra_token");    }    @Test    public void testContinuationBetweenTokens() {        doTest("continuation_inter_token");    }    @Test    public void testUnicodeStringSupport() {        doTest("unicodeStrings");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testMultiLineMacros() {        doTest("multilineMacros");    }    @Test    public void testIdentifierValidChars() {        doTest("identifierChars");    }    @Test    public void testWrongUnicodeInIdentifier() {        expectTokenMgrError(" void main() { int ⚜ = __; }");    }    @Test    public void testTokenizerWithSkipBlocks() {        doTest("simpleSkipBlocks", "_skipDefault", skipBlocks());    }    @Test    public void testTokenizerWithSkipBlocksPattern() {        doTest("simpleSkipBlocks", "_skipDebug", skipBlocks("#if debug|#endif"));    }    @Test    public void testTokenizerWithoutSkipBlocks() {        doTest("simpleSkipBlocks", "_noSkip", dontSkipBlocks());    }    @Test    public void testAsm() {        // ASM code containing the '@' character        doTest("asm", "", dontSkipBlocks());    }    @Test    public void testPreprocessingDirectives() {        doTest("preprocessorDirectives");    }    @Test    public void testLiterals() {        doTest("literals");    }    @Test    public void testLexicalErrorFilename() {        expectTokenMgrError(sourceText("issue-1559"), dontSkipBlocks());    }    @Test    public void testRawStringLiterals() {        doTest("issue-1784");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    @Test    public void testLongListsOfNumbersAreNotIgnored() {        doTest("listOfNumbers");    }    @Test    public void testLongListsOfNumbersAreIgnored() {        doTest("listOfNumbers", "_ignored", skipLiteralSequences());    }    private static Properties skipBlocks(String skipPattern) {        return properties(true, skipPattern, false);    }    private static Properties skipBlocks() {        return skipBlocks(null);    }    private static Properties dontSkipBlocks() {        return properties(false, null, false);    }    private static Properties skipLiteralSequences() {        return properties(false, null, true);    }    private static Properties properties(boolean skipBlocks, String skipPattern, boolean skipLiteralSequences) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS, Boolean.toString(skipBlocks));        if (skipPattern != null) {            properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS_PATTERN, skipPattern);        }        properties.setProperty(Tokenizer.OPTION_IGNORE_LITERAL_SEQUENCES, Boolean.toString(skipLiteralSequences));        return properties;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestAccessEvaluator.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import java.util.HashSet;import java.util.Objects;import java.util.Set;import net.sourceforge.pmd.annotation.InternalApi;import apex.jorje.semantic.compiler.Namespace;import apex.jorje.semantic.compiler.StructuredVersion;import apex.jorje.semantic.compiler.sfdc.AccessEvaluator;import apex.jorje.semantic.compiler.sfdc.PlaceholderOrgPerm;import apex.jorje.semantic.symbol.type.SObjectTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfoImpl;import apex.jorje.semantic.symbol.type.TypeInfo;import com.google.common.collect.HashMultimap;import com.google.common.collect.Iterables;import com.google.common.collect.SetMultimap;/** * For now everything returns false. * If you actually need to override something, it would be easier to probably mock and adjust what you needed. * Otherwise this is simply to create a concrete representation and not force a mockito init. * * @author jspagnola */@Deprecated@InternalApipublic class TestAccessEvaluator implements AccessEvaluator {    private final SetMultimap<Namespace, StructuredVersion> validPageVersions;    private final SetMultimap<SObjectTypeInfo, TypeInfo> visibleSetupEntitiesToTypes;    private final Set<Namespace> accessibleSystemNamespaces;    private final Set<PlaceholderOrgPerm> orgPerm;    private final Set<AllowedPermGuard> allowedPermGuards;    private final Set<Namespace> reservedNamespaces;    private final Set<String> globalComponents;    private final Set<Namespace> managedPackagesNotInstalled;    private final Set<String> typesWithConnectApiDeserializers;    private boolean hasInternalSfdc;    private boolean isRunningTests;    private boolean hasPrivateApi;    private boolean isTrustedApplication;    private boolean hasLocalizedTranslation;    private boolean isSfdc;    private boolean isReallyRunningTests;    private boolean hasApexGenericTypes;    private boolean hasRemoteActionPerm;    private boolean hasPersonAccountApiAvailable;    public TestAccessEvaluator() {        validPageVersions = HashMultimap.create();        visibleSetupEntitiesToTypes = HashMultimap.create();        managedPackagesNotInstalled = new HashSet<>();        accessibleSystemNamespaces = new HashSet<>();        orgPerm = new HashSet<>();        allowedPermGuards = new HashSet<>();        reservedNamespaces = new HashSet<>();        globalComponents = new HashSet<>();        typesWithConnectApiDeserializers = new HashSet<>();        hasRemoteActionPerm = true;        hasPersonAccountApiAvailable = true;    }    @Override    public boolean hasPermission(final PlaceholderOrgPerm orgPerm) {        return this.orgPerm.contains(orgPerm);    }    @Override    public boolean hasPermissionForPermGuard(final Namespace referencingNamespace, final String orgPerm) {        return allowedPermGuards.contains(new AllowedPermGuard(referencingNamespace, orgPerm));    }    @Override    public boolean hasPersonAccountApiAvailable() {        return hasPersonAccountApiAvailable;    }    @Override    public boolean hasPrivateApi() {        return hasPrivateApi;    }    @Override    public boolean hasLocalizedTranslation() {        return hasLocalizedTranslation;    }    @Override    public boolean hasInternalSfdc() {        return hasInternalSfdc;    }    @Override    public boolean isTrustedApplication(TypeInfo arg0) {        return isTrustedApplication;    }    @Override    public boolean isReservedNamespace(final Namespace namespace) {        return reservedNamespaces.contains(namespace);    }    @Override    public boolean isReservedNamespace(final Namespace namespace, final boolean excludePackages) {        return reservedNamespaces.contains(namespace);    }    /**     * See {@link #isAccessibleOrTrustedNamespace(Namespace)}     */    @Override    public boolean isAccessibleSystemNamespace(final Namespace namespace) {        return accessibleSystemNamespaces.contains(namespace);    }    /**     * Okay so this check and its partner isAccessibleSystemNamespace are used slightly differently.     * This is like a black list check, that prevents referencing code from seeing things in a reserved namespace.     * The other check allows code to see certain things if the code's namespace is a reserved namespace.     * <p>     * Hence here we return true by default, and the {@link #isAccessibleSystemNamespace(Namespace)} returns false     * by default.     */    @Override    public boolean isAccessibleOrTrustedNamespace(final Namespace namespace) {        return true;    }    @Override    public boolean isRunningTests() {        return isRunningTests;    }    @Override    public boolean isReallyRunningTests() {        return isReallyRunningTests;    }    @Override    public boolean isSfdc() {        return isSfdc;    }    @Override    public boolean hasApexParameterizedTypes() {        return hasApexGenericTypes;    }    @Override    public boolean isValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        return validPageVersions.containsEntry(namespace, version);    }    /**     * @return 'true' for everything EXCEPT namespaces you've added through {@link #addManagedPackageNotInstalled(Namespace)}     */    @Override    public boolean isManagedPackageInstalled(final Namespace namespace) {        return !managedPackagesNotInstalled.contains(namespace);    }    @Override    public boolean isSetupEntityVisibleToType(final SObjectTypeInfo type, final TypeInfo referencingType) {        final TypeInfo visibleReferencingType = Iterables.getFirst(visibleSetupEntitiesToTypes.get(type), null);        return visibleReferencingType != null            && visibleReferencingType.getBytecodeName().equals(referencingType.getBytecodeName());    }    @Override    public boolean hasConnectDeserializer(final TypeInfo type) {        return typesWithConnectApiDeserializers.contains(type.getApexName());    }    @Override    public boolean hasRemoteAction(final TypeInfo type) {        return false;    }    @Override    public boolean hasRemoteActionPerm() {        return hasRemoteActionPerm;    }    @Override    public boolean isGlobalComponent(final TypeInfo type) {        return globalComponents.contains(type.getApexName());    }    /**     * Things isManagedPackageInstalled will say 'false' to.     */    public TestAccessEvaluator addManagedPackageNotInstalled(final Namespace namespace) {        managedPackagesNotInstalled.add(namespace);        return this;    }    public TestAccessEvaluator addReservedNamespace(final Namespace namespace) {        reservedNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator addPermission(final PlaceholderOrgPerm orgPerm) {        this.orgPerm.add(orgPerm);        return this;    }    public TestAccessEvaluator setHasInternalSfdc(final boolean hasInternalSfdc) {        this.hasInternalSfdc = hasInternalSfdc;        return this;    }    public TestAccessEvaluator addValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        validPageVersions.put(namespace, version);        return this;    }    public TestAccessEvaluator addSetupEntityVisibleToType(        final SObjectTypeInfo type,        final String typeName    ) {        final StandardTypeInfo typeInfo = StandardTypeInfoImpl.builder()            .setApexName(typeName)            .setBytecodeName(typeName)            .buildResolved();        visibleSetupEntitiesToTypes.put(type, typeInfo);        return this;    }    public TestAccessEvaluator setIsRunningTests(final boolean isRunningTests) {        this.isRunningTests = isRunningTests;        return this;    }    public TestAccessEvaluator setHasPrivateApi(final boolean hasPrivateApi) {        this.hasPrivateApi = hasPrivateApi;        return this;    }    public TestAccessEvaluator setIsTrustedApplication(final boolean isTrustedApplication) {        this.isTrustedApplication = isTrustedApplication;        return this;    }    public TestAccessEvaluator setHasLocalizedTranslation(final boolean hasLocalizedTranslation) {        this.hasLocalizedTranslation = hasLocalizedTranslation;        return this;    }    public TestAccessEvaluator setIsSfdc(final boolean isSfdc) {        this.isSfdc = isSfdc;        return this;    }    public TestAccessEvaluator setIsReallyRunningTests(final boolean isReallyRunningTests) {        this.isReallyRunningTests = isReallyRunningTests;        return this;    }    public TestAccessEvaluator setAccessibleSystemNamespace(final Namespace namespace) {        accessibleSystemNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator setHasApexGenericType(final boolean hasApexGenericTypes) {        this.hasApexGenericTypes = hasApexGenericTypes;        return this;    }    public TestAccessEvaluator allowPermGuard(final Namespace namespace, final String permGuard) {        allowedPermGuards.add(new AllowedPermGuard(namespace, permGuard));        return this;    }    /**     * It appears that remote action is enabled by default in most orgs, at least test orgs.     * So we will behave the same.     */    public TestAccessEvaluator setHasRemoteActionPerm(final boolean hasRemoteActionPerm) {        this.hasRemoteActionPerm = hasRemoteActionPerm;        return this;    }    public TestAccessEvaluator setTypeWithConnectApiDeserializer(final String typeName) {        typesWithConnectApiDeserializers.add(typeName);        return this;    }    public void setGlobalComponent(final String globalComponent) {        globalComponents.add(globalComponent);    }    private static class AllowedPermGuard {        private final Namespace referencingNamespace;        private final String permGuard;        AllowedPermGuard(final Namespace namespace, final String permGuard) {            referencingNamespace = namespace;            this.permGuard = permGuard;        }        @Override        public int hashCode() {            return Objects.hash(referencingNamespace, permGuard);        }        @Override        public boolean equals(final Object obj) {            if (this == obj) {                return true;            }            if (obj == null || getClass() != obj.getClass()) {                return false;            }            final AllowedPermGuard other = (AllowedPermGuard) obj;            return Objects.equals(referencingNamespace, other.referencingNamespace)                && Objects.equals(permGuard, other.permGuard);        }    }    @Override    public boolean isSecondGenerationPackagingNamespace(Namespace namespace) {        return false;    }    @Override    public boolean useTestValueForAnonymousScriptLengthLimit() {        return false;    }    @Override    public boolean hasNamespaceGuardedAccess(Namespace namespace, String arg1) {        return false;    }    @Override    public boolean isNamespaceGuardNamespace(Namespace arg0) {        return false;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestQueryValidators.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import net.sourceforge.pmd.annotation.InternalApi;import apex.jorje.semantic.ast.expression.SoqlExpression;import apex.jorje.semantic.ast.expression.SoslExpression;import apex.jorje.semantic.ast.visitor.ValidationScope;import apex.jorje.semantic.compiler.sfdc.QueryValidator;import apex.jorje.semantic.symbol.resolver.SymbolResolver;/** * The test query validators will return back the query it was given. The real implementation actually creates its own * query. * * @author jspagnola */@SuppressWarnings("PMD.MissingStaticMethodInNonInstantiatableClass") // this class provides utility classes@Deprecated@InternalApipublic final class TestQueryValidators {    private TestQueryValidators() {    }    public static class Noop implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope typeInfo,            final SoslExpression sosl        ) {            return sosl.getCanonicalQuery();        }    }    public static class Error implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            scope.getErrors().markInvalid(soql, "Bad Soql");            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope scope,            final SoslExpression sosl        ) {            scope.getErrors().markInvalid(sosl, "Bad Sosl");            return sosl.getCanonicalQuery();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.metrics.impl;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clément Fournier */public class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/apex/metrics_test.xml";    @Override    public void setUp() {        addRule(RULESET, "CycloTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "CognitiveComplexityTest");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.apex.ast.ASTMethod;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.apex.ast.ApexParserVisitorAdapter;import net.sourceforge.pmd.lang.apex.metrics.impl.AbstractApexClassMetric;import net.sourceforge.pmd.lang.apex.metrics.impl.AbstractApexOperationMetric;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricKeyUtil;import net.sourceforge.pmd.lang.metrics.MetricOptions;import net.sourceforge.pmd.lang.metrics.MetricsUtil;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clément Fournier */public class ApexProjectMirrorTest extends ApexParserTestBase {    private static ApexNode<Compilation> acu;    private MetricKey<ASTUserClassOrInterface<?>> classMetricKey = MetricKeyUtil.of(null, new RandomClassMetric());    private MetricKey<ASTMethod> opMetricKey = MetricKeyUtil.of(null, new RandomOperationMetric());    @Before    public void setup() {        acu = parseResource("../multifile/MetadataDeployController.cls");    }    @Test    public void memoizationTest() {        List<Integer> expected = visitWith(acu, true);        List<Integer> real = visitWith(acu, false);        assertEquals(expected, real);    }    @Test    public void forceMemoizationTest() {        List<Integer> reference = visitWith(acu, true);        List<Integer> real = visitWith(acu, true);        assertEquals(reference.size(), real.size());        // we force recomputation so each result should be different        for (int i = 0; i < reference.size(); i++) {            assertNotEquals(reference.get(i), real.get(i));        }    }    private List<Integer> visitWith(ApexNode<Compilation> acu, final boolean force) {        final List<Integer> result = new ArrayList<>();        acu.jjtAccept(new ApexParserVisitorAdapter() {            @Override            public Object visit(ASTMethod node, Object data) {                if (opMetricKey.supports(node)) {                    result.add((int) MetricsUtil.computeMetric(opMetricKey, node, MetricOptions.emptyOptions(), force));                }                return super.visit(node, data);            }            @Override            public Object visit(ASTUserClass node, Object data) {                if (classMetricKey.supports(node)) {                    result.add((int) MetricsUtil.computeMetric(classMetricKey, node, MetricOptions.emptyOptions(), force));                }                return super.visit(node, data);            }        }, null);        return result;    }    private static class RandomOperationMetric extends AbstractApexOperationMetric {        private Random random = new Random();        @Override        public double computeFor(ASTMethod node, MetricOptions options) {            return random.nextInt();        }    }    private static class RandomClassMetric extends AbstractApexClassMetric {        private Random random = new Random();        @Override        public double computeFor(ASTUserClassOrInterface<?> node, MetricOptions options) {            return random.nextInt();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.multifile;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.io.IOException;import org.junit.Test;import net.sourceforge.pmd.lang.apex.ast.ASTMethod;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.apex.ast.ApexParserVisitorAdapter;import net.sourceforge.pmd.lang.apex.metrics.ApexSignatureMatcher;import net.sourceforge.pmd.lang.apex.metrics.signature.ApexOperationSigMask;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clément Fournier */public class ApexMultifileVisitorTest extends ApexParserTestBase {    @Test    public void testProjectMirrorNotNull() {        assertNotNull(ApexProjectMirror.INSTANCE);    }    @Test    public void testOperationsAreThere() throws IOException {        ApexNode<Compilation> acu = parseResource("MetadataDeployController.cls");        final ApexSignatureMatcher toplevel = ApexProjectMirror.INSTANCE;        final ApexOperationSigMask opMask = new ApexOperationSigMask();        // We could parse qnames from string but probably simpler to do that        acu.jjtAccept(new ApexParserVisitorAdapter() {            @Override            public Object visit(ASTMethod node, Object data) {                if (!node.getImage().matches("(<clinit>|<init>|clone)")) {                    assertTrue(toplevel.hasMatchingSig(node.getQualifiedName(), opMask));                }                return data;            }        }, null);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexBadCryptoTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexXSSFromURLParamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexCRUDViolationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexInsecureEndpointTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexXSSFromEscapeFalseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.stream.Collectors;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.testframework.RuleTst;/** * <p>Sharing settings are not inherited by inner classes. Sharing settings need to be declared on the class that * contains the Database method, DML, SOQL, or SOSL.</p> * * <p>This test runs against Apex code that has an Outer class and and Inner class. Different Apex code is generated * based on the boolean permutations. Any classes that includes data access cod, but doesn't declare a sharing setting * should trigger a violation.</p> */@RunWith(Parameterized.class)public class ApexSharingViolationsNestedClassTest extends RuleTst {    /**     * Type of operation that may require a sharing declaration.     */    private enum Operation {        NONE(null),        DML_DELETE("Contact c = new Contact(); delete c;"),        DML_INSERT("Contact c = new Contact(); insert c;"),        DML_MERGE("Contact c1 = new Contact(); Contact c2 = new Contact(); merge c1 c2;"),        DML_UNDELETE("Contact c = new Contact(); undelete c;"),        DML_UPDATE("Contact c = new Contact(); update c;"),        DML_UPSERT("Contact c = new Contact(); upsert c;"),        METHOD_DATABASE("Database.query('Select Id from Contact LIMIT 100');"),        SOQL("[SELECT Name FROM Contact];"),        SOSL("[FIND 'Foo' IN ALL FIELDS RETURNING Account(Name)];");        final boolean requiresSharingDeclaration;        final String codeSnippet;        Operation(String codeSnippet) {            this.requiresSharingDeclaration = codeSnippet != null;            this.codeSnippet = codeSnippet;        }    }    /**     * The permutations used for class generation. See {@link #generateClass(boolean, Operation, boolean, Operation)}     */    private final boolean outerSharingDeclared;    private final Operation outerOperation;    private final boolean innerSharingDeclared;    private final Operation innerOperation;    /**     * Track the expected violations based on the permutations.     */    private final int expectedViolations;    private final List<Integer> expectedLineNumbers;    public ApexSharingViolationsNestedClassTest(boolean outerSharingDeclared, Operation outerOperation,                                                boolean innerSharingDeclared, Operation innerOperation,                                                int expectedViolations, List<Integer> expectedLineNumbers) {        this.outerSharingDeclared = outerSharingDeclared;        this.outerOperation = outerOperation;        this.innerSharingDeclared = innerSharingDeclared;        this.innerOperation = innerOperation;        this.expectedViolations = expectedViolations;        this.expectedLineNumbers = expectedLineNumbers;    }    @Test    public void testSharingPermutation() {        String apexClass = generateClass(outerSharingDeclared, outerOperation, innerSharingDeclared, innerOperation);        Report rpt = new Report();        runTestFromString(apexClass, new ApexSharingViolationsRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        List<RuleViolation> violations = rpt.getViolations();        assertEquals("Unexpected Violation Size\n" + apexClass, expectedViolations, violations.size());        List<Integer> lineNumbers = violations.stream().map(v -> v.getBeginLine()).collect(Collectors.toList());        assertEquals("Unexpected Line Numbers\n" + apexClass, expectedLineNumbers, lineNumbers);    }    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/apex/security.xml", "ApexSharingViolations");        return Collections.singletonList(rule);    }    /**     * Parameter provider that covers are all permutations     */    @Parameterized.Parameters    public static Collection<?> data() {        List<Object[]> data = new ArrayList<>();        boolean[] boolPermutations = {false, true};        for (boolean outerSharingDeclared : boolPermutations) {            for (Operation outerOperation : Operation.values()) {                for (boolean innerSharingDeclared : boolPermutations) {                    for (Operation innerOperation : Operation.values()) {                        int expectedViolations = 0;                        List<Integer> expectedLineNumbers = new ArrayList<>();                        if (outerOperation.requiresSharingDeclaration && !outerSharingDeclared) {                            // The outer class contains SOQL but doesn't declare sharing                            expectedViolations++;                            expectedLineNumbers.add(1);                        }                        if (innerOperation.requiresSharingDeclaration && !innerSharingDeclared) {                            // The inner class contains SOQL but doesn't declare sharing                            expectedViolations++;                            // The location of the inner class declaration depends upon the content of the outer class                            expectedLineNumbers.add(outerOperation.requiresSharingDeclaration ? 3 : 2);                        }                        data.add(new Object[]{outerSharingDeclared, outerOperation, innerSharingDeclared, innerOperation,                                              expectedViolations, expectedLineNumbers});                    }                }            }        }        return data;    }    /**     * <p>Generate an Apex class with various Sharing/Database/DML/SOQL/SOSL permutations. An example of the class     * returned when invoked with generateClass(true, SOQL, true, SOQL).</p>     *     * <pre>     * public with sharing class Outer {     *    public void outerSOQL() {[SELECT Name FROM Contact];}     *    public with sharing class Inner {     *       public void innerSOQL() {[SELECT Name FROM Contact];}     *    }     * }     * </pre>     *     * @param outerSharing Add 'with sharing' to Outer class definition     * @param outerOperation Add a method to Outer class that performs the given operation     * @param innerSharing Add 'with sharing' to Inner class definition     * @param innerOperation Add a method to Inner class that performs the given operation     * @return String that represents Apex code     */    private static String generateClass(boolean outerSharing, Operation outerOperation, boolean innerSharing,                                        Operation innerOperation) {        StringBuilder sb = new StringBuilder();        sb.append("public ");        if (outerSharing) {            sb.append("with sharing ");        }        sb.append("class Outer {\n");        switch (outerOperation) {        case NONE:            // Do nothing            break;        default:            sb.append(String.format("\t\tpublic void outer%s(){ %s }\n", outerOperation.name(), outerOperation.codeSnippet));            break;        }        sb.append("\tpublic ");        if (innerSharing) {            sb.append("with sharing ");        }        sb.append("class Inner {\n");        switch (innerOperation) {        case NONE:            // DO Nothing            break;        default:            sb.append(String.format("\t\tpublic void inner%s(){ %s }\n", innerOperation.name(), innerOperation.codeSnippet));            break;        }        sb.append("\t}\n"); // Closes class Inner        sb.append("}\n"); // Closes class Outer        return sb.toString();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSOQLInjectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexOpenRedirectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSuggestUsingNamedCredTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexDangerousMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSharingViolationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyTryOrFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidNonExistentAnnotationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexCSRFTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TestMethodsMustBeInTestClassesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDirectAccessTriggerMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidHardcodingIdTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InaccessibleAuraEnabledGetterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import java.io.StringReader;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StdCyclomaticComplexityTest extends PmdRuleTst {    /**     * Make sure the entry stack is empty, if show classes complexity is     * disabled.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1501/">bug #1501</a>     */    @Test    public void entryStackMustBeEmpty() {        StdCyclomaticComplexityRule rule = new StdCyclomaticComplexityRule();        rule.setProperty(StdCyclomaticComplexityRule.SHOW_CLASSES_COMPLEXITY_DESCRIPTOR, Boolean.FALSE);        RuleContext ctx = new RuleContext();        LanguageVersion javaLanguageVersion = LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = javaLanguageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = javaLanguageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse("test", new StringReader("public class SampleClass {}"));        rule.apply(Arrays.asList(node), ctx);        Assert.assertTrue(rule.entryStack.isEmpty());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CognitiveComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssConstructorCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssTypeCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSoqlInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDebugStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OperationWithLimitsInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDmlStatementsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSoslInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexDocTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldDeclarationsShouldBeAtStartTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PropertyNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLogicInTriggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestClassShouldHaveAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidGlobalModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestMethodShouldHaveIsTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestShouldNotUseSeeAllDataTrueTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DebugsShouldUseLoggingLevelTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule;import static org.junit.Assert.assertEquals;import java.util.Collections;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.apex.ast.ASTAnonymousClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;import net.sourceforge.pmd.lang.apex.ast.ASTUserInterface;import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import apex.jorje.semantic.ast.compilation.Compilation;public class AbstractApexRuleTest extends ApexParserTestBase {    @Test    public void shouldVisitTopLevelClass() {        run("class Foo { }");    }    @Test    public void shouldVisitTopLevelInterface() {        run("interface Foo { }");    }    @Test    public void shouldVisitTopLevelTrigger() {        run("trigger Foo on Account (before insert, before update) { }");    }    @Test    public void shouldVisitTopLevelEnum() {        run("enum Foo { }");    }    private void run(String code) {        ApexNode<Compilation> node = parse(code);        RuleContext ctx = new RuleContext();        ctx.setLanguageVersion(apex.getDefaultVersion());        TopLevelRule rule = new TopLevelRule();        rule.apply(Collections.singletonList(node), ctx);        assertEquals(1, ctx.getReport().size());    }    private static class TopLevelRule extends AbstractApexRule {        @Override        public Object visit(ASTUserClass node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserInterface node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserTrigger node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserEnum node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTAnonymousClass node, Object data) {            addViolation(data, node);            return data;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexParserXPathTest extends ApexParserTestBase {    @Test    public void testBooleanExpressions() throws Exception {        ApexNode<Compilation> node = parse(IOUtils.toString(ApexParserXPathTest.class.getResourceAsStream("BooleanExpressions.cls"),                StandardCharsets.UTF_8));        List<ASTBooleanExpression> booleanExpressions = node.findDescendantsOfType(ASTBooleanExpression.class);        Assert.assertEquals(2, booleanExpressions.size());        Assert.assertEquals("&&", booleanExpressions.get(0).getOperator().toString());        Assert.assertEquals("!=", booleanExpressions.get(1).getOperator().toString());        List<? extends Node> xpathResult = node.findChildNodesWithXPath("//BooleanExpression[@Operator='&&']");        Assert.assertEquals(1, xpathResult.size());        Assert.assertSame(booleanExpressions.get(0), xpathResult.get(0));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserEnumTest extends ApexParserTestBase {    @Test    public void testEnumName() {        ApexNode<Compilation> node = parse("class Foo { enum Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserEnum enumNode = node.getFirstDescendantOfType(ASTUserEnum.class);        Assert.assertNotNull(enumNode);        Assert.assertEquals("Bar", enumNode.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;public class ApexCompilerTest extends ApexParserTestBase {    @Test(expected = ParseException.class)    public void compileShouldFail() {        apex.parse("public class Foo { private String myField = \"a\"; }");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;public class ASTUserTriggerTest extends ApexParserTestBase {    @Test    public void testTriggerName() {        ApexNode<?> node = parse("trigger HelloWorldTrigger on Book__c (before insert, after update) {\n"                + "   Book__c[] books = Trigger.new;\n" + "   MyHelloWorld.applyDiscount(books);\n" + "}\n");        Assert.assertSame(ASTUserTrigger.class, node.getClass());        Assert.assertEquals("HelloWorldTrigger", node.getImage());        ASTUserTrigger trigger = (ASTUserTrigger) node;        Assert.assertEquals("Book__c", trigger.getTargetName());        Assert.assertEquals(Arrays.asList(TriggerUsage.AFTER_UPDATE, TriggerUsage.BEFORE_INSERT), trigger.getUsages());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserClassTest extends ApexParserTestBase {    @Test    public void testClassName() {        ApexNode<Compilation> node = parse("class Foo { }");        Assert.assertSame(ASTUserClass.class, node.getClass());        Assert.assertEquals("Foo", node.getImage());    }    @Test    public void testInnerClassName() {        ApexNode<Compilation> node = parse("class Foo { class Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass innerNode = node.getFirstDescendantOfType(ASTUserClass.class);        Assert.assertNotNull(innerNode);        Assert.assertEquals("Bar", innerNode.getImage());    }    @Test    public void testSuperClassName() {        ApexNode<?> node = parse("public class AccountTriggerHandler extends TriggerHandler {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals("TriggerHandler", toplevel.getSuperClassName());    }    @Test    public void testSuperClassName2() {        ApexNode<?> node = parse("public class AccountTriggerHandler extends Other.TriggerHandler {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals("Other.TriggerHandler", toplevel.getSuperClassName());    }    @Test    public void testInterfaces() {        ApexNode<?> node = parse("public class AccountTriggerHandler implements TriggerHandler, Other.Interface2 {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals(Arrays.asList("TriggerHandler", "Other.Interface2"), toplevel.getInterfaceNames());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTTryCatchFinallyBlockStatementTest extends ApexParserTestBase {    @Test    public void testTryFinally() {        ApexNode<Compilation> node = parse("class Foo { void bar() { try { methodCall(); } finally { methodCall(); } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        Assert.assertNotNull(statement.getTryBlock());        Assert.assertEquals(0, statement.getTryBlock().getIndexInParent());        Assert.assertNotNull(statement.getFinallyBlock());        Assert.assertEquals(1, statement.getFinallyBlock().getIndexInParent());        Assert.assertEquals(0, statement.getCatchClauses().size());    }    @Test    public void testTryCatch() {        ApexNode<Compilation> node = parse("class Foo { void bar() { try { methodCall(); } catch (Exception e) { methodCall(); } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        Assert.assertNotNull(statement.getTryBlock());        Assert.assertEquals(0, statement.getTryBlock().getIndexInParent());        Assert.assertNull(statement.getFinallyBlock());        Assert.assertEquals(1, statement.getCatchClauses().size());        Assert.assertNotNull(statement.getCatchClauses().get(0).getBody());        Assert.assertEquals(1, statement.getCatchClauses().get(0).getIndexInParent());    }    @Test    public void testTryCatchFinally() {        ApexNode<Compilation> node = parse("class Foo { void bar() { try { methodCall(); } catch (Exception e) { methodCall(); } finally { } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        Assert.assertNotNull(statement.getTryBlock());        Assert.assertEquals(0, statement.getTryBlock().getIndexInParent());        Assert.assertNotNull(statement.getFinallyBlock());        Assert.assertEquals(2, statement.getFinallyBlock().getIndexInParent());        Assert.assertEquals(1, statement.getCatchClauses().size());        Assert.assertNotNull(statement.getCatchClauses().get(0).getBody());        Assert.assertEquals(1, statement.getCatchClauses().get(0).getIndexInParent());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;public class ApexTreeDumpTest extends BaseTreeDumpTest {    public ApexTreeDumpTest() {        super(new RelevantAttributePrinter(), ".cls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return ApexParsingHelper.DEFAULT;    }    @Test    public void safeNavigationOperator() throws Exception {        doTest("SafeNavigationOperator");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTFieldTest extends ApexParserTestBase {    @Test    public void testGetType() {        ApexNode<Compilation> node = parse("public class Foo { private String myField = 'a'; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertEquals("myField", field.getImage());        Assert.assertEquals("String", field.getType());        Assert.assertEquals("a", field.getValue());    }    @Test    public void testGetValue() {        ApexNode<Compilation> node = parse("public class Foo { private String myField = 'a'; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertEquals("a", field.getValue());    }    @Test    public void testGetNoValue() {        ApexNode<Compilation> node = parse("public class Foo { private String myField; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertNull(field.getValue());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTSwitchStatementTest extends ApexParserTestBase {    @Test    public void testExamples() {        ApexNode<Compilation> node = parseResource("SwitchStatements.cls");        List<ASTSwitchStatement> switchStatements = node.findDescendantsOfType(ASTSwitchStatement.class);        Assert.assertEquals(4, switchStatements.size());        Assert.assertTrue(switchStatements.get(0).getChild(0) instanceof ASTVariableExpression);        Assert.assertEquals(5, switchStatements.get(0).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(3, switchStatements.get(0).findChildrenOfType(ASTValueWhenBlock.class)                .get(1).findChildrenOfType(ASTLiteralCase.class).size());        Assert.assertEquals(1, switchStatements.get(0).findChildrenOfType(ASTElseWhenBlock.class).size());        Assert.assertTrue(switchStatements.get(1).getChild(0) instanceof ASTMethodCallExpression);        Assert.assertEquals(2, switchStatements.get(1).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(1, switchStatements.get(1).findChildrenOfType(ASTElseWhenBlock.class).size());        Assert.assertTrue(switchStatements.get(2).getChild(0) instanceof ASTVariableExpression);        Assert.assertEquals(2, switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class).size());        Assert.assertEquals("Account", switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class)                .get(0).getType());        Assert.assertEquals("a", switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class)                .get(0).getName());        Assert.assertEquals(1, switchStatements.get(2).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(1, switchStatements.get(2).findChildrenOfType(ASTElseWhenBlock.class).size());        Assert.assertTrue(switchStatements.get(3).getChild(0) instanceof ASTVariableExpression);        Assert.assertEquals(2, switchStatements.get(3).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(1, switchStatements.get(3).findChildrenOfType(ASTElseWhenBlock.class).size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.antlr.runtime.ANTLRStringStream;import org.antlr.runtime.CharStream;import org.antlr.runtime.CommonTokenStream;import org.antlr.runtime.Token;import org.junit.Assert;import org.junit.Test;import apex.jorje.data.ast.CompilationUnit;import apex.jorje.parser.impl.ApexLexer;import apex.jorje.parser.impl.ApexParser;public class ApexLexerTest {    private static final String CODE = "public class Foo {\n"            + "   public List<SObject> test1() {\n"            + "       return Database.query(\"Select Id from Account LIMIT 100\");\n"            + "   }\n"            + "}\n";    @Test    public void testLexer() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        Token token = lexer.nextToken();        int tokenCount = 0;        while (token.getType() != Token.EOF) {            tokenCount++;            token = lexer.nextToken();        }        Assert.assertEquals(43, tokenCount);    }    @Test    public void testParser() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        ApexParser parser = new ApexParser(new CommonTokenStream(lexer));        CompilationUnit compilationUnit = parser.compilationUnit();        Assert.assertNotNull(compilationUnit);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Test;public class ApexCompilerSoqlTest extends ApexParserTestBase {    private static final String CODE = "public class Foo {\n"        + "   public List<SObject> test1() {\n"        + "       return Database.query(\'Select Id from Account LIMIT 100\');\n"        + "   }\n"        + "}\n";    @Test    public void testSoqlCompilation() {        apex.parse(CODE);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTSoqlExpressionTest extends ApexParserTestBase {    @Test    public void testQuery() {        ApexNode<Compilation> node = parse("class Foo { void test1() { Account acc = [SELECT col FROM Account]; } }");        ASTSoqlExpression soqlExpression = node.getFirstDescendantOfType(ASTSoqlExpression.class);        Assert.assertEquals("SELECT col FROM Account", soqlExpression.getQuery());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTNewKeyValueObjectExpressionTest extends ApexParserTestBase {    @Test    public void testParameterName() {        ApexNode<Compilation> node = parse("public class Foo { \n"                + "    public void foo(String newName, String tempID) { \n"                + "        if (Contact.sObjectType.getDescribe().isCreateable() && Contact.sObjectType.getDescribe().isUpdateable()) {\n"                + "            upsert new Contact(FirstName = 'First', LastName = 'Last', Phone = '414-414-4414');\n"                + "        }\n" + "    } \n" + "}");        ASTNewKeyValueObjectExpression keyValueExpr = node.getFirstDescendantOfType(ASTNewKeyValueObjectExpression.class);        Assert.assertEquals(3, keyValueExpr.getParameterCount());        List<ASTLiteralExpression> literals = keyValueExpr.findDescendantsOfType(ASTLiteralExpression.class);        Assert.assertEquals(3, literals.size());        Assert.assertEquals("FirstName", literals.get(0).getName());        Assert.assertEquals("LastName", literals.get(1).getName());        Assert.assertEquals("Phone", literals.get(2).getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.util.List;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clément Fournier */public class ApexQualifiedNameTest extends ApexParserTestBase {    @Test    public void testClass() {        ApexNode<Compilation> root = parse("public class Foo {}");        ApexQualifiedName qname = ASTUserClass.class.cast(root).getQualifiedName();        assertEquals("c__Foo", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    public void testNestedClass() {        ApexNode<Compilation> root = parse("public class Foo { class Bar {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTUserClass.class).getQualifiedName();        assertEquals("c__Foo.Bar", qname.toString());        assertEquals(2, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    public void testSimpleMethod() {        ApexNode<Compilation> root = parse("public class Foo { String foo() {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTMethod.class).getQualifiedName();        assertEquals("c__Foo#foo()", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo()", qname.getOperation());    }    @Test    public void testMethodWithArguments() {        ApexNode<Compilation> root = parse("public class Foo { String foo(String h, Foo g) {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTMethod.class).getQualifiedName();        assertEquals("c__Foo#foo(String, Foo)", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo(String, Foo)", qname.getOperation());    }    @Test    public void testOverLoads() {        ApexNode<Compilation> root = parse("public class Foo { "                                                                 + "String foo(String h) {} "                                                                 + "String foo(int c) {}"                                                                 + "String foo(Foo c) {}}");        List<ASTMethod> methods = root.findDescendantsOfType(ASTMethod.class);        for (ASTMethod m1 : methods) {            for (ASTMethod m2 : methods) {                if (m1 != m2) {                    assertNotEquals(m1.getQualifiedName(), m2.getQualifiedName());                }            }        }    }    @Test    public void testTrigger() {        ApexNode<Compilation> root = parse("trigger myAccountTrigger on Account (before insert, before update) {}");        List<ASTMethod> methods = root.findDescendantsOfType(ASTMethod.class);        for (ASTMethod m : methods) {            assertEquals("c__trigger.Account#myAccountTrigger", m.getQualifiedName().toString());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.core.IsInstanceOf.instanceOf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexParserTest extends ApexParserTestBase {    @Test    public void understandsSimpleFile() {        // Setup        String code = "@isTest\n public class SimpleClass {\n" + "    @isTest\n public static void testAnything() {\n"            + "        \n" + "    }\n" + "}";        // Exercise        ApexNode<Compilation> rootNode = parse(code);        // Verify        List<ASTMethod> methods = rootNode.findDescendantsOfType(ASTMethod.class);        assertEquals(4, methods.size());    }    private String testCodeForLineNumbers =              "public class SimpleClass {\n" // line 1            + "    public void method1() {\n" // line 2            + "        System.out.println('abc');\n" // line 3            + "        // this is a comment\n" // line 4            + "    }\n" // line 5            + "}\n"; // line 6    @Test    public void verifyLineColumnNumbers() {        ApexNode<Compilation> rootNode = parse(testCodeForLineNumbers);        assertLineNumbersForTestCode(rootNode);    }    @Test    public void verifyLineColumnNumbersWithWindowsLineEndings() {        String windowsLineEndings = testCodeForLineNumbers.replaceAll(" \n", "\r\n");        ApexNode<Compilation> rootNode = parse(windowsLineEndings);        assertLineNumbersForTestCode(rootNode);    }    private void assertLineNumbersForTestCode(ApexNode<Compilation> rootNode) {        // whole source code, well from the beginning of the class        // name Modifier of the class - doesn't work. This node just        // sees the identifier ("SimpleClass")        // assertPosition(rootNode.getChild(0), 1, 1, 1, 6);        // "public"        assertPosition(rootNode, 1, 14, 6, 2);        // "method1" - starts with identifier until end of its block statement        Node method1 = rootNode.getChild(1);        assertPosition(method1, 2, 17, 5, 5);        // Modifier of method1 - doesn't work. This node just sees the        // identifier ("method1")        // assertPosition(method1.getChild(0), 2, 17, 2, 20); // "public" for        // method1        // BlockStatement - the whole method body        Node blockStatement = method1.getChild(1);        assertTrue(((ASTBlockStatement) blockStatement).hasCurlyBrace());        assertPosition(blockStatement, 2, 27, 5, 5);        // the expression ("System.out...")        Node expressionStatement = blockStatement.getChild(0);        assertPosition(expressionStatement, 3, 9, 3, 34);    }    @Test    public void verifyEndLine() {        String code = "public class SimpleClass {\n" // line 1                + "    public void method1() {\n" // line 2                + "    }\n" // line 3                + "    public void method2() {\n" // line 4                + "    }\n" // line 5                + "}\n"; // line 6        ApexNode<Compilation> rootNode = parse(code);        Node method1 = rootNode.getChild(1);        assertEquals("Wrong begin line", 2, method1.getBeginLine());        assertEquals("Wrong end line", 3, method1.getEndLine());        Node method2 = rootNode.getChild(2);        assertEquals("Wrong begin line", 4, method2.getBeginLine());        assertEquals("Wrong end line", 5, method2.getEndLine());    }    @Test    public void checkComments() {        String code = "public  /** Comment on Class */ class SimpleClass {\n" // line 1            + "    /** Comment on m1 */"            + "    public void method1() {\n" // line 2            + "    }\n" // line 3            + "    public void method2() {\n" // line 4            + "    }\n" // line 5            + "}\n"; // line 6        ApexNode<Compilation> root = parse(code);        assertThat(root, instanceOf(ASTUserClass.class));        ApexNode<?> comment = root.getChild(0);        assertThat(comment, instanceOf(ASTFormalComment.class));        assertPosition(comment, 1, 9, 1, 31);        assertEquals("/** Comment on Class */", ((ASTFormalComment) comment).getToken());        ApexNode<?> m1 = root.getChild(2);        assertThat(m1, instanceOf(ASTMethod.class));        ApexNode<?> comment2 = m1.getChild(0);        assertThat(comment2, instanceOf(ASTFormalComment.class));        assertEquals("/** Comment on m1 */", ((ASTFormalComment) comment2).getToken());    }    @Test    public void parsesRealWorldClasses() throws Exception {        File directory = new File("src/test/resources");        File[] fList = directory.listFiles();        for (File file : fList) {            if (file.isFile() && file.getName().endsWith(".cls")) {                String sourceCode = FileUtils.readFileToString(file, StandardCharsets.UTF_8);                ApexNode<Compilation> rootNode = parse(sourceCode);                Assert.assertNotNull(rootNode);            }        }    }    /**     * See github issue #1546     * @see <a href="https://github.com/pmd/pmd/issues/1546">[apex] PMD parsing exception for Apex classes using 'inherited sharing' keyword</a>     */    @Test    public void parseInheritedSharingClass() throws IOException {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("InheritedSharing.cls"),                StandardCharsets.UTF_8);        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);    }    /**     * See bug #1485     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1485/">#1485 [apex] Analysis of some apex classes cause a stackoverflow error</a>     */    @Test    public void stackOverflowDuringClassParsing() throws Exception {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("StackOverflowClass.cls"),                StandardCharsets.UTF_8);        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);        int count = visitPosition(rootNode, 0);        Assert.assertEquals(487, count);    }    @Test    public void verifyLineColumnNumbersInnerClasses() throws Exception {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("InnerClassLocations.cls"),                StandardCharsets.UTF_8);        source = source.replaceAll("\r\n", "\n");        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);        visitPosition(rootNode, 0);        Assert.assertEquals("InnerClassLocations", rootNode.getImage());        // Note: Apex parser doesn't provide positions for "public class" keywords. The        // position of the UserClass node is just the identifier. So, the node starts        // with the identifier and not with the first keyword in the file...        assertPosition(rootNode, 1, 14, 16, 2);        List<ASTUserClass> classes = rootNode.findDescendantsOfType(ASTUserClass.class);        Assert.assertEquals(2, classes.size());        Assert.assertEquals("bar1", classes.get(0).getImage());        List<ASTMethod> methods = classes.get(0).findChildrenOfType(ASTMethod.class);        Assert.assertEquals(2, methods.size()); // m() and synthetic clone()        Assert.assertEquals("m", methods.get(0).getImage());        assertPosition(methods.get(0), 4, 21, 7, 9);        Assert.assertEquals("clone", methods.get(1).getImage());        assertPosition(methods.get(1), 7, 9, 7, 9);        // Position of the first inner class: starts with the identifier "bar1" and ends with        // the last real method m(). The last bracket it actually on the next line 8, but we        // don't see this in the AST.        assertPosition(classes.get(0), 3, 18, 7, 9);        Assert.assertEquals("bar2", classes.get(1).getImage());        assertPosition(classes.get(1), 10, 18, 14, 9);    }    // TEST HELPER    private int visitPosition(Node node, int count) {        int result = count + 1;        Assert.assertTrue(node.getBeginLine() > 0);        Assert.assertTrue(node.getBeginColumn() > 0);        Assert.assertTrue(node.getEndLine() > 0);        Assert.assertTrue(node.getEndColumn() > 0);        for (int i = 0; i < node.getNumChildren(); i++) {            result = visitPosition(node.getChild(i), result);        }        return result;    }    private static void assertPosition(Node node, int beginLine, int beginColumn, int endLine, int endColumn) {        assertEquals("Wrong begin line", beginLine, node.getBeginLine());        assertEquals("Wrong begin column", beginColumn, node.getBeginColumn());        assertEquals("Wrong end line", endLine, node.getEndLine());        assertEquals("Wrong end column", endColumn, node.getEndColumn());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTMethodTest extends ApexParserTestBase {    @Test    public void testConstructorName() {        ApexNode<Compilation> node = parse("public class Foo { public Foo() {} public void bar() {} }");        Assert.assertSame(ASTUserClass.class, node.getClass());        List<ASTMethod> methods = node.findChildrenOfType(ASTMethod.class);        Assert.assertEquals("Foo", methods.get(0).getImage()); // constructor        Assert.assertEquals("<init>", methods.get(0).getCanonicalName());        Assert.assertEquals("bar", methods.get(1).getImage()); // normal method    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserInterfaceTest extends ApexParserTestBase {    @Test    public void testInterfaceName() {        ApexNode<Compilation> node = parse("interface Foo { }");        Assert.assertSame(ASTUserInterface.class, node.getClass());        Assert.assertEquals("Foo", node.getImage());    }    @Test    public void testInnerInterfaceName() {        ApexNode<Compilation> node = parse("class Foo { interface Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserInterface innerNode = node.getFirstDescendantOfType(ASTUserInterface.class);        Assert.assertNotNull(innerNode);        Assert.assertEquals("Bar", innerNode.getImage());    }    @Test    public void testSuperInterface() {        ApexNode<?> node = parse("public interface CustomInterface extends A {}");        Assert.assertSame(ASTUserInterface.class, node.getClass());        ASTUserInterface toplevel = (ASTUserInterface) node;        Assert.assertEquals("A", toplevel.getSuperInterfaceName());    }    @Test    public void testSuperInterface2() {        ApexNode<?> node = parse("public interface CustomInterface extends Other.A {}");        Assert.assertSame(ASTUserInterface.class, node.getClass());        ASTUserInterface toplevel = (ASTUserInterface) node;        Assert.assertEquals("Other.A", toplevel.getSuperInterfaceName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;import net.sourceforge.pmd.testframework.RuleTst;public class SuppressWarningsTest extends RuleTst {    private static class BarRule extends AbstractApexRule {        @Override        public Object visit(ASTUserClass clazz, Object ctx) {            if (clazz.getImage().equalsIgnoreCase("bar")) {                addViolation(ctx, clazz);            }            return super.visit(clazz, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    public void testClassLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST1, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());        runTestFromString(TEST2, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testInheritedSuppression() {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testMethodLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST4, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testConstructorLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST5, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testFieldLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST6, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testParameterLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST7, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testLocalVariableLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST8, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppression() {        Report rpt = new Report();        runTestFromString(TEST9, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionMulitpleValues() {        Report rpt = new Report();        runTestFromString(TEST9_MULTIPLE_VALUES, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testNoSuppressionBlank() {        Report rpt = new Report();        runTestFromString(TEST10, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(2, rpt.size());    }    @Test    public void testNoSuppressionSomethingElseS() {        Report rpt = new Report();        runTestFromString(TEST11, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(2, rpt.size());    }    @Test    public void testSuppressAll() {        Report rpt = new Report();        runTestFromString(TEST12, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testSpecificSuppressionAtTopLevel() {        Report rpt = new Report();        runTestFromString(TEST13, new BarRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testCommentSuppression() {        Report rpt = new Report();        runTestFromString(TEST14, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());        List<Report.SuppressedViolation> suppressions = rpt.getSuppressedRuleViolations();        assertEquals(1, suppressions.size());    }    @Test    public void testMessageWithCommentSuppression() {        Report rpt = new Report();        runTestFromString(TEST15, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());        List<Report.SuppressedViolation> suppressions = rpt.getSuppressedRuleViolations();        assertEquals(1, suppressions.size());        Report.SuppressedViolation suppression = suppressions.get(0);        assertTrue(suppression.suppressedByNOPMD());        assertEquals("We allow foo here", suppression.getUserMessage());    }    private static final String TEST1 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {}";    private static final String TEST2 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST3 = "public class Baz {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public class Bar {" + PMD.EOL + "  void bar() {" + PMD.EOL + "   Integer foo;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "public class Foo {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST5 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public Bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST6 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST7 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL            + " void bar(@SuppressWarnings('PMD') Integer foo) {}" + PMD.EOL + "}";    private static final String TEST8 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD.NoFoo') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_MULTIPLE_VALUES = "@SuppressWarnings('PMD.NoFoo, PMD.NoBar')"            + PMD.EOL + "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL            + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST10 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST11 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('SomethingElse') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST12 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('all') Integer foo;"            + PMD.EOL + "}";    private static final String TEST13 = "@SuppressWarnings('PMD.NoBar')" + PMD.EOL + "public class Bar {" + PMD.EOL            + "}";    private static final String TEST14 = "public class Bar {" + PMD.EOL + "Integer foo; // NOPMD" + PMD.EOL + "}";    private static final String TEST15 = "public class Bar {" + PMD.EOL + "Integer foo; //NOPMD We allow foo here" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.AbstractLanguageVersionTest;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<?> data() {        return Arrays.asList(new Object[][] { { ApexLanguageModule.NAME, ApexLanguageModule.TERSE_NAME, "35",            LanguageRegistry.getLanguage("Apex").getVersion("35"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.logging.Handler;import java.util.logging.LogRecord;import java.util.logging.Logger;import org.junit.After;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetLoader;public class DefaultRulesetTest {    @Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    private RuleSetFactory factory = new RuleSetLoader().enableCompatibility(false).toFactory();    @Test    public void loadDefaultRuleset() throws Exception {        RuleSet ruleset = factory.createRuleSet("rulesets/apex/ruleset.xml");        Assert.assertNotNull(ruleset);    }    @After    public void cleanup() {        Handler[] handlers = Logger.getLogger(RuleSetFactory.class.getName()).getHandlers();        for (Handler handler : handlers) {            Logger.getLogger(RuleSetFactory.class.getName()).removeHandler(handler);        }    }    @Test    public void loadQuickstartRuleset() throws Exception {        Logger.getLogger(RuleSetFactory.class.getName()).addHandler(new Handler() {            @Override            public void publish(LogRecord record) {                Assert.fail("No Logging expected: " + record.getMessage());            }            @Override            public void flush() {            }            @Override            public void close() throws SecurityException {            }        });        RuleSet ruleset = factory.createRuleSet("rulesets/apex/quickstart.xml");        Assert.assertNotNull(ruleset);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;import net.sourceforge.pmd.lang.apex.rule.ApexXPathRule;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    public RuleSetFactoryTest() {        super();        validXPathClassNames.add(ApexXPathRule.class.getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.util.Iterator;import org.apache.commons.io.FilenameUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;public class ApexCpdTest {    private File testdir;    @Before    public void setUp() {        String path = FilenameUtils.normalize("src/test/resources/net/sourceforge/pmd/cpd/issue427");        testdir = new File(path);    }    @Test    public void testIssue427() throws IOException {        CPDConfiguration configuration = new CPDConfiguration();        configuration.setMinimumTileSize(10);        configuration.setLanguage(LanguageFactory.createLanguage(ApexLanguageModule.TERSE_NAME));        CPD cpd = new CPD(configuration);        cpd.add(new File(testdir, "SFDCEncoder.cls"));        cpd.add(new File(testdir, "SFDCEncoderConstants.cls"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        int duplications = 0;        while (matches.hasNext()) {            matches.next();            duplications++;        }        assertEquals(1, duplications);        Match firstDuplication = cpd.getMatches().next();        assertTrue(firstDuplication.getSourceCodeSlice().startsWith("global with sharing class SFDCEncoder"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class ApexTokenizerTest extends CpdTextComparisonTest {    public ApexTokenizerTest() {        super(".cls");    }    @Override    protected String getResourcePrefix() {        return "../lang/apex/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        ApexTokenizer tokenizer = new ApexTokenizer();        tokenizer.setProperties(properties);        return tokenizer;    }    @Test    public void testTokenize() {        doTest("Simple");    }    @Test    public void testTokenizeCaseSensitive() {        doTest("Simple", "_caseSensitive", caseSensitive());    }    /**     * Comments are ignored since using ApexLexer.     */    @Test    public void testTokenizeWithComments() {        doTest("comments");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    private Properties caseSensitive() {        return properties(true);    }    private Properties properties(boolean caseSensitive) {        Properties properties = new Properties();        properties.setProperty(ApexTokenizer.CASE_SENSITIVE, Boolean.toString(caseSensitive));        return properties;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.it;import java.io.File;import java.nio.file.Path;import org.junit.BeforeClass;import org.junit.ClassRule;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.PMDVersion;public abstract class AbstractBinaryDistributionTest {    protected static File getBinaryDistribution() {        return new File(".", "target/pmd-bin-" + PMDVersion.VERSION + ".zip");    }    @ClassRule    public static TemporaryFolder folder = new TemporaryFolder();    /**     * The temporary directory, to which the binary distribution will be extracted.     * It will be deleted again after the test.     */    protected static Path tempDir;    @BeforeClass    public static void setupTempDirectory() throws Exception {        tempDir = folder.newFolder().toPath();        if (getBinaryDistribution().exists()) {            ZipFileExtractor.extractZipFile(getBinaryDistribution().toPath(), tempDir);        }    }}