/* *  */package test.net.sourceforge.pmd.jdbc;import com.mockobjects.sql.MockConnection;import com.mockobjects.sql.MockDriver;import com.mockobjects.sql.MockPreparedStatement;import com.mockobjects.sql.MockSingleRowResultSet;import junit.framework.TestCase;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.jdbc.JDBCReportListener;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.MockRule;import java.sql.Date;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JDBCReportListenerTest extends TestCase {    private MockDriver driver = null;    private MockPreparedStatement violInsert = null;    private MockPreparedStatement metInsert = null;    public void setUp() {driver = new MockDriver();try {    DriverManager.registerDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    public void tearDown() {try {    DriverManager.deregisterDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    private class MockInsertPMDRunsextends MockPreparedStatement    {private int runId = 0;public MockInsertPMDRuns( int projectId, int runId ) {    //    setExpectedQueryString("INSERT INTO PMD_RUNS (PROJECT_ID, RUN_DATE) VALUES (?, ?)");    addExpectedSetParameter( 1, projectId );    this.runId = runId;}public void setDate( int position, Date dateTime ) {    assertEquals("Date in wrong position.", 2, position);    assertTrue( "Didn't add the current date.",dateTime.getTime() > System.currentTimeMillis() - 5000);    assertTrue( "Set a future date.",dateTime.getTime() < System.currentTimeMillis() + 5000);}public ResultSet getGeneratedKeys() {    MockSingleRowResultSet RC = new MockSingleRowResultSet();    RC.addExpectedIndexedValues( new Object[] { new Integer(runId) });    return RC;}    }    private class MockPMDConxextends MockConnection    {public MockPMDConx( int projectId, int runId ) {    super();    setupAddPreparedStatement( new MockInsertPMDRuns( projectId, runId ) );    violInsert = new MockPreparedStatement();    setupAddPreparedStatement( violInsert );        metInsert = new MockPreparedStatement();    setupAddPreparedStatement( metInsert );}public PreparedStatement prepareStatement( String sql, int returnKeys )    throws SQLException{    assertEquals( "Not set to return generated keys.",   returnKeys, Statement.RETURN_GENERATED_KEYS );    return prepareStatement( sql );}    }    public JDBCReportListener getIUT(int projectId) throws SQLException    {return new JDBCReportListener( "jdbc:mock:getIUT",       "iut_user", "iut_pw", projectId );    }    public void testLongConstructor() throws Throwable {MockConnection conx = new MockPMDConx(1, 5);driver.setupConnect( conx );new JDBCReportListener("jdbc:mock:testLongConstructor", "tlc_user", "tlc_pw", 1);    }    public void testPropConstructor() throws Throwable {MockConnection conx = new MockPMDConx(2, 8);driver.setupConnect( conx );Properties props = new Properties();props.put( JDBCReportListener.JDBC_URL, "jdbc:mock:testPropConstructor" );props.put( JDBCReportListener.JDBC_USER, "tpc_user" );props.put( JDBCReportListener.JDBC_PASSWORD, "tpc_pw" );props.put( JDBCReportListener.JDBC_PROJECTID, "2");new JDBCReportListener(props);    }    public void testSingleViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );JDBCReportListener IUT = getIUT( 16 );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));    }    public void testMultiViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 16 );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1a" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileAa" );      // File NameviolInsert.addExpectedSetParameter( 4, 2561 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageBa" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classCa" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msga" );ctx = new RuleContext();ctx.setSourceCodeFilename( "fileAa" );ctx.setPackageName( "packageBa" );ctx.setClassName( "classCa" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1a", "Descriptiona", "msga" ),    2561, ctx ));    }    public void testSingleMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "single" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));JDBCReportListener IUT = getIUT( 18 );IUT.metricAdded( new Metric("single", 5, 30, 1.0, 6.0, 3.0, 1.5) );    }    public void testMultiMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 18 );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "first" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));IUT.metricAdded( new Metric("first", 5, 30, 1.0, 6.0, 3.0, 1.5) );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "second" );metInsert.addExpectedSetParameter( 3, new Double( 1.01 ));metInsert.addExpectedSetParameter( 4, new Double( 6.01 ));metInsert.addExpectedSetParameter( 5, new Double( 3.01 ));metInsert.addExpectedSetParameter( 6, new Double( 1.51 ));IUT.metricAdded( new Metric("second", 7, 32.5, 1.01, 6.01, 3.01, 1.51) );    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.util;import junit.framework.TestCase;import net.sourceforge.pmd.util.Applier;import net.sourceforge.pmd.util.UnaryFunction;import java.util.ArrayList;import java.util.List;public class ApplierTest extends TestCase {    private static class MyFunction implements UnaryFunction {        private boolean gotCallback;        public void applyTo(Object o) {            this.gotCallback = true;        }        public boolean gotCallback() {            return this.gotCallback;        }    }    public void testSimple() {        MyFunction f = new MyFunction();        List l = new ArrayList();        l.add(new Object());        Applier.apply(f, l.iterator());        assertTrue(f.gotCallback());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.util;import junit.framework.TestCase;import net.sourceforge.pmd.util.StringUtil;public class StringUtilTest extends TestCase {    public void testReplaceWithOneChar() {        assertEquals("faa", StringUtil.replaceString("foo", 'o', "a"));    }    public void testReplaceWithMultipleChars() {        assertEquals("faaaa", StringUtil.replaceString("foo", 'o', "aa"));    }    public void testReplaceStringWithString() {        assertEquals("foo]]&gt;bar", StringUtil.replaceString("foo]]>bar", "]]>", "]]&gt;"));    }    public void testReplaceStringWithString2() {        assertEquals("foobar", StringUtil.replaceString("foobar", "]]>", "]]&gt;"));    }    public void testReplaceWithNull() {        assertEquals("f", StringUtil.replaceString("foo", 'o', null));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.testframework;import net.sourceforge.pmd.Rule;public class TestDescriptor {    public String code;    public String description;    public int numberOfProblemsExpected;    public Rule rule;    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;    }}
/** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.AssertionFailedError;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.stat.DataPoint;import net.sourceforge.pmd.stat.Metric;import net.sourceforge.pmd.stat.StatisticalRule;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Random;/** * This class tests the Statistical Rules in PMD. * * The idea is, that we fill up 999 datapoints into * the Stat Rule, and then throw random parameters * at it. * * The three parameters which are checked are: * sigma - # Sigmas over the mean. * topscore - Only the top 5 or so items. * minimum - Only things of score 10 or better * * When more than one parameter is lumped together, then * we expect the one which would return the fewest to * determine what gets sent back. * * So, we throw each collection of parameters, where each * one is a different order into the system.  We check the * results off of what the smallest value should be. * * If you are going to work with StatisticalRule any, please * bump the "NUM_TESTS" number up to something like 128.  That * way you are more likely to identify problems.  It is set low * now to make building and running tests easier (when we aren't * touching the file.) * * Note also, that when verifying the Sigma, I wasn't quite able * to determine how many results it would return (it would vary * from -2 to 2 of what I expected.)  That is what the delta * parameter on the verify method takes.  If you can figure it * out exactly, (without stealing code from the StatRule) then * feel free to change it and tighten the deltas. */public class StatisticalRuleTest extends TestCase {    private static final int POINTS = 100;    private DataPoint points[] = new DataPoint[POINTS];    private MockStatisticalRule IUT = null;    private String testName = null;    private Random random = new Random();    public static final double MAX_MINIMUM = POINTS;    public static final double NO_MINIMUM = -1.0;    public static final double MAX_SIGMA = 5.0;    public static final double NO_SIGMA = -1.0;    public static final int MIN_TOPSCORE = 0;    public static final int NO_TOPSCORE = -1;    public static final double MEAN = 49.5;    public static final double SIGMA = 29.0115;    public static final int NUM_TESTS = 1;    public static final double DELTA = 0.005;    public StatisticalRuleTest(String name) {        super(name);        this.testName = name;    }    public void setUp() {        IUT = new MockStatisticalRule();        if (testName.endsWith("0")) {            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                points[i].setLineNumber(i);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else if (testName.endsWith("1")) {            for (int i = POINTS-1; i >= 0; i--) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                points[i].setLineNumber(i);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else {            List lPoints = new ArrayList();            for (int i = 0; i < POINTS; i++) {                DataPoint point = new DataPoint();                point.setScore(1.0 * i);                point.setLineNumber(i);                point.setMessage("DataPoint[" + Integer.toString(i) + "]");                lPoints.add(point);            }            Collections.shuffle(lPoints);            for (int i = 0; i < POINTS; i++) {                IUT.addDataPoint((DataPoint) lPoints.get(i));            }        }    }    /**     * This test verifies that the Stat rule creates a Metric,     * with the proper values.     */    public void testMetrics() throws Throwable {        Report report = makeReport(IUT);        Iterator metrics = report.metrics();        assertTrue(metrics.hasNext());        Object o = metrics.next();        assertTrue(o instanceof Metric);        Metric m = (Metric) o;        assertEquals("test.net.sourceforge.pmd.stat.MockStatisticalRule", m.getMetricName());        assertEquals(0.0, m.getLowValue(), 0.05);        assertEquals(POINTS -1.0, m.getHighValue(), 0.05);        assertEquals(MEAN, m.getAverage(), 0.05);        assertEquals(SIGMA, m.getStandardDeviation(), 0.05);    }    /**     * This returns a Random value for Sigma which will     * return some values.     */    public double randomSigma() {        return random.nextDouble() * 1.0;    }    /**     * This returns a Random value for Sigma which value     * is greater than the parameter.     */    public double randomSigma(int minimum) {        double minSigma = ((POINTS -1 - minimum) - MEAN) / SIGMA;        if ((minSigma <= 0) || (minSigma > 2))            return randomSigma();        return minSigma + (random.nextDouble() * (2 - minSigma));    }    /**     * This returns the expected number of results when     * the Sigma rating is the smallest.     */    public int expectedSigma(double sigma) {        long expectedMin = Math.round(MEAN + (sigma * SIGMA));        if (((POINTS -1) - expectedMin) < 0)            return 0;        return (POINTS -1) - (int) expectedMin;    }    /**     * This generates a random minimum value for testing.     */    public double randomMinimum() {        return random.nextDouble() * (POINTS -1);    }    /**     * This generates a random minimum value for which fewer     * results would be returned.     */    public double randomMinimum(int minimum) {        double diffTarget = 1.0 * (POINTS -1 - minimum);        return (random.nextDouble() * minimum) + diffTarget;    }    /**     * This returns the expected number of reports.     *     * If the Minimum comes in at 521.569 then we expect     * 522, 523, ... 999 will pass.     */    public int expectedMinimum(double minimum) {        Double d = new Double(minimum);        return POINTS -1 - d.intValue();    }    public void testExpectedMinimum() {        for (int i = 0; i < POINTS -1; i++) {            assertEquals("Integer Min", POINTS -1 - i, expectedMinimum(i * 1.0));            assertEquals("Double Min", POINTS -1 - i, expectedMinimum((i * 1.0) + 0.5));        }    }    /**     * This returns a random value for Top Score.     */    public int randomTopScore() {        return random.nextInt(POINTS -1);    }    /**     * This will return a random value for the Top Score     * which will return more than the minimum provided.     */    public int randomTopScore(double target) {        if (target < 0)            return 0;        return random.nextInt((new Double(target)).intValue());    }    /**     * This will return the expected number of results     * with the given Top Score.     */    public int expectedTopScore(int target) {        return target;    }    // Test Single Datapoint    public void testSingleDatapoint() {        StatisticalRule IUT = new MockStatisticalRule();        DataPoint point = new DataPoint();        point.setScore(POINTS + 1.0);        point.setLineNumber(POINTS + 1);        point.setMessage("SingleDataPoint");        IUT.addProperty("minimum", Integer.toString(POINTS));        IUT.addDataPoint(point);        Report report = makeReport(IUT);        assertEquals("Expecting only one result.", 1, report.size());    }    // Okay, we have three properties we need to    // test in Combination:    //  S = Sigma    //  T = Top Score    //  M = Minimum    //    // They are listed in decreasing order of what    // to expect.    //    // Thus testSM() should have the Sigma less than    // the minimum, so we expect the Minimum # of results.    //    public void testS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, NO_TOPSCORE, 0, 2);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            verifyResults(sigma, -1.0, -1, expectedSigma(sigma), 2);        }    }    public void testS1() throws Throwable {        testS();    }    public void testS2() throws Throwable {        testS();    }    public void testS3() throws Throwable {        testS();    }    public void testS4() throws Throwable {        testS();    }    public void testS5() throws Throwable {        testS();    }    public void testT() throws Throwable {        verifyResults(NO_SIGMA, NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            verifyResults(-1.0, -1.0, topScore, expectedTopScore(topScore), 0);        }    }    public void testT1() throws Throwable {        testT();    }    public void testT2() throws Throwable {        testT();    }    public void testT3() throws Throwable {        testT();    }    public void testT4() throws Throwable {        testT();    }    public void testT5() throws Throwable {        testT();    }    public void testM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            verifyResults(-1.0, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testM1() throws Throwable {        testM();    }    public void testM2() throws Throwable {        testM();    }    public void testM3() throws Throwable {        testM();    }    public void testM4() throws Throwable {        testM();    }    public void testM5() throws Throwable {        testM();    }    public void testST() throws Throwable {        verifyResults(randomSigma(), NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            verifyResults(sigma, NO_MINIMUM, topScore, expectedTopScore(topScore), 0);        }    }    public void testST1() throws Throwable {        testST();    }    public void testST2() throws Throwable {        testST();    }    public void testST3() throws Throwable {        testST();    }    public void testST4() throws Throwable {        testST();    }    public void testST5() throws Throwable {        testST();    }    public void testTS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            verifyResults(sigma, -1.0, topScore, expectedSigma(sigma), 2);        }    }    public void testTS1() throws Throwable {        testTS();    }    public void testTS2() throws Throwable {        testTS();    }    public void testTS3() throws Throwable {        testTS();    }    public void testTS4() throws Throwable {        testTS();    }    public void testTS5() throws Throwable {        testTS();    }    public void testSM() throws Throwable {        verifyResults(randomSigma(), MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testSM1() throws Throwable {        testSM();    }    public void testSM2() throws Throwable {        testSM();    }    public void testSM3() throws Throwable {        testSM();    }    public void testSM4() throws Throwable {        testSM();    }    public void testSM5() throws Throwable {        testSM();    }    public void testMS() throws Throwable {        verifyResults(MAX_SIGMA, randomMinimum(), NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, -1, expectedSigma(sigma), 2);        }    }    public void testMS1() throws Throwable {        testMS();    }    public void testMS2() throws Throwable {        testMS();    }    public void testMS3() throws Throwable {        testMS();    }    public void testMS4() throws Throwable {        testMS();    }    public void testMS5() throws Throwable {        testMS();    }    public void testTM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(NO_SIGMA, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTM1() throws Throwable {        testTM();    }    public void testTM2() throws Throwable {        testTM();    }    public void testTM3() throws Throwable {        testTM();    }    public void testTM4() throws Throwable {        testTM();    }    public void testTM5() throws Throwable {        testTM();    }    public void testMT() throws Throwable {        verifyResults(NO_SIGMA, randomMinimum(), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(NO_SIGMA, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testMT1() throws Throwable {        testMT();    }    public void testMT2() throws Throwable {        testMT();    }    public void testMT3() throws Throwable {        testMT();    }    public void testMT4() throws Throwable {        testMT();    }    public void testMT5() throws Throwable {        testMT();    }    public void testSTM() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, MAX_MINIMUM, randomTopScore(expectedSigma(sigma)), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testSTM1() throws Throwable {        testSTM();    }    public void testSTM2() throws Throwable {        testSTM();    }    public void testSTM3() throws Throwable {        testSTM();    }    public void testSTM4() throws Throwable {        testSTM();    }    public void testSTM5() throws Throwable {        testSTM();    }    public void testSMT() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, randomMinimum(expectedSigma(sigma)), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testSMT1() throws Throwable {        testSMT();    }    public void testSMT2() throws Throwable {        testSMT();    }    public void testSMT3() throws Throwable {        testSMT();    }    public void testSMT4() throws Throwable {        testSMT();    }    public void testSMT5() throws Throwable {        testSMT();    }    public void testTSM() throws Throwable {        int topScore = randomTopScore();        verifyResults(randomSigma(expectedTopScore(topScore)), MAX_MINIMUM, topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTSM1() throws Throwable {        testTSM();    }    public void testTSM2() throws Throwable {        testTSM();    }    public void testTSM3() throws Throwable {        testTSM();    }    public void testTSM4() throws Throwable {        testTSM();    }    public void testTSM5() throws Throwable {        testTSM();    }    public void testTMS() throws Throwable {        int topScore = randomTopScore();        verifyResults(MAX_SIGMA, randomMinimum(expectedTopScore(topScore)), topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedSigma(sigma), 2);        }    }    public void testTMS1() throws Throwable {        testTMS();    }    public void testTMS2() throws Throwable {        testTMS();    }    public void testTMS3() throws Throwable {        testTMS();    }    public void testTMS4() throws Throwable {        testTMS();    }    public void testTMS5() throws Throwable {        testTMS();    }    /**     * Verifies what happens when you pass these parameters     * into the thing.  DELTA is the amount of error allowed.     * Usually DELTA is only used for Sigma, as we really can't     * calculate it exactly.     */    public void verifyResults(double sigma, double minimum, int topScore, int expected, int delta) {        try {            setUp();            if (sigma >= 0) {                IUT.addProperty("sigma", Double.toString(sigma));            }            if (minimum >= 0) {                IUT.addProperty("minimum", Double.toString(minimum));            }            if (topScore >= 0) {                IUT.addProperty("topscore", Integer.toString(topScore));            }            Report report = makeReport(IUT);            if (delta == 0) {                assertEquals("Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore), expected, report.size());            } else {                String assertStr = "Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore) + " expected= " + Integer.toString(expected) + " +/- " + Integer.toString(delta) + " actual-result= " + report.size();                assertTrue(assertStr, report.size() >= (expected - delta));                assertTrue(assertStr, report.size() <= (expected + delta));            }        } catch (AssertionFailedError afe) {            System.err.println("******** " + testName + " ***********");            if (sigma != NO_SIGMA) {                System.err.println("SIGMA: " + Double.toString(sigma) + " EXPECT: " + Integer.toString(expectedSigma(sigma)));            }            if (minimum != NO_MINIMUM) {                System.err.println("MIN: " + Double.toString(minimum) + " EXPECT: " + Integer.toString(expectedMinimum(minimum)));            }            if (topScore != NO_TOPSCORE) {                System.err.println("TOP: " + Integer.toString(topScore) + " EXPECT: " + Integer.toString(expectedTopScore(topScore)));            }            throw afe;        }    }    public Report makeReport(Rule IUT) {        List list = new ArrayList();        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFilename(testName);        IUT.apply(list, ctx);        return report;    }}
/** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.TestCase;import net.sourceforge.pmd.stat.Metric;import java.util.Random;/** * @author David Dixon-Peugh */public class MetricTest extends TestCase {    private String testName = null;    private Random random = new Random();    /**     * Constructor for MetricTest.     * @param arg0     */    public MetricTest(String arg0) {        super(arg0);        this.testName = arg0;    }    public void testGetMetricName() {        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(testName, IUT.getMetricName());    }    public void testGetCount() {        int count = random.nextInt();        Metric IUT = new Metric(testName, count, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(count, IUT.getCount());    }    public void testGetTotal() {        double total = random.nextDouble();        Metric IUT = new Metric(testName, 0, total, 0.0, 0.0, 0.0, 0.0);        assertEquals(total, IUT.getTotal(), 0.05);    }    public void testGetLowValue() {        double low = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, low, 0.0, 0.0, 0.0);        assertEquals(low, IUT.getLowValue(), 0.05);    }    public void testGetHighValue() {        double high = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, high, 0.0, 0.0);        assertEquals(high, IUT.getHighValue(), 0.05);    }    public void testGetAverage() {        double mean = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, mean, 0.0);        assertEquals(mean, IUT.getAverage(), 0.05);    }    public void testGetStandardDeviation() {        double stdev = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, stdev);        assertEquals(stdev, IUT.getStandardDeviation(), 0.05);    }}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeDoesNotCallSuperFinalizeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/finalizers.xml", "FinalizeDoesNotCallSuperFinalize");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "ok, super.finalize called in try..finally", 0, rule),           new TestDescriptor(TEST4, "ok, super.finalize called in try..catch..finally", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  try {} finally {" + PMD.EOL +    "   super.finalize();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  try {} catch(Exception e) {} finally {" + PMD.EOL +    "   super.finalize();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeOnlyCallsSuperFinalizeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/finalizers.xml", "FinalizeOnlyCallsSuperFinalize");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeOverloadedRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/finalizers.xml", "FinalizeOverloaded");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize(int foo) {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  doSomething();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExplicitCallToFinalizeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/finalizers.xml", "ExplicitCallToFinalize");    }    // todo: how do we flag this.finalize() ?    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "call to own finalizer", 1, rule),           new TestDescriptor(TEST2, "call to other object's finalizer", 1, rule),           new TestDescriptor(TEST3, "call to this.finalize, TODO", 0, rule),           new TestDescriptor(TEST4, "ok, call to super.finalize", 0, rule),           new TestDescriptor(TEST5, "ok, call to overloaded finalizer", 0, rule),           new TestDescriptor(TEST6, "ok, call to overloaded this.finalizer", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {finalize();}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo(Bar b) {b.finalize();}" + PMD.EOL +    "}";    // TODO this should be a rule violation    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {this.finalize();}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {super.finalize();}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {finalize(5);}" + PMD.EOL +    " void finalize(int x) {}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {this.finalize(5);}" + PMD.EOL +    " void finalize(int x) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.junit.JUnitAssertionsShouldIncludeMessageRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitAssertionsShouldIncludeMessageRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "assertEquals ok", 0, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST2, "assertEquals bad", 1, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST3, "assertTrue ok", 0, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST4, "assertTrue bad", 1, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST5, "assertNull OK", 0, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST6, "assertNull bad", 1, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST7, "assertSame OK", 0, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST8, "assertSame badd", 1, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST9, "assertNotNull OK", 0, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST10, "assertNotNull bad", 1, new JUnitAssertionsShouldIncludeMessageRule()),           new TestDescriptor(TEST11, "find that pesky bug", 0, new JUnitAssertionsShouldIncludeMessageRule()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertEquals(\"1 == 1\", 1, 1);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertEquals(1, 1);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(\"foo\", \"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(\"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNull(\"it's not null\", null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNull(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertSame(\"not same!\", null, null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertSame(null, null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNotNull(\"foo\", null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNotNull(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  this.test1(\"foo\");" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitStaticSuiteRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/junit.xml", "JUnitStaticSuite");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "nonstatic is bad", 1, rule),           new TestDescriptor(TEST2, "public static with no params is OK", 0, rule),           new TestDescriptor(TEST3, "private suite() is bad", 1, rule),           new TestDescriptor(TEST4, "if there are params, just skip it", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public TestSuite suite() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public static TestSuite suite() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private static TestSuite suite() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " protected static Test suite(Foo foo) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitSpellingRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/junit.xml", "JUnitSpelling");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "testSetupMisspellings1", 2, rule),           new TestDescriptor(TEST2, "testTeardownMisspellings", 2, rule),           new TestDescriptor(TEST3, "testMethodsSpelledOK", 0, rule),           new TestDescriptor(TEST4, "testUnrelatedMethods", 0, rule),           new TestDescriptor(TEST5, "testMethodWithParams", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void setup() {}" + PMD.EOL +    " public void SetUp() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void TearDown() {}" + PMD.EOL +    " public void teardown() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void setUp() {}" + PMD.EOL +    " public void tearDown() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void utility() {}" + PMD.EOL +    " public void foobr() {}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public void setup(String x) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.LongParameterListRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class LongParameterListRuleTest extends RuleTst {    private static final String TEST1 =    "public class LongParameterList0 {" + PMD.EOL +    "    public void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class LongParameterList1 {" + PMD.EOL +    "    public void foo(int p01, int p02, int p03, int p04, int p05," + PMD.EOL +    "                   int p06, int p07, int p08, int p09, int p10 ) { }" + PMD.EOL +    "    public void bar(int p01, int p02, int p03, int p04, int p05 ) { }" + PMD.EOL +    "}";    public LongParameterListRule getIUT() {        LongParameterListRule IUT = new LongParameterListRule();        IUT.addProperty("minimum", "9");        return IUT;    }    public void testShortMethod() throws Throwable {        runTestFromString(TEST1, 0, getIUT());    }    public void testOneLongMethod() throws Throwable {        runTestFromString(TEST2, 1, getIUT());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.design.SwitchDensityRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SwitchDensityTest  extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new SwitchDensityRule();        rule.addProperty("minimum", "4");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "Five stmts in one switch case, should be flagged", 1, rule),           new TestDescriptor(TEST2, "One stmt in one switch case, ok", 0, rule),           new TestDescriptor(TEST3, "Five stmts, 5 cases, OK", 0, rule),       });    }    private static final String TEST1 =    "// Switch Density = 5.0" + PMD.EOL +    "public class SwitchDensity1 {" + PMD.EOL +    " public void foo(int i) {" + PMD.EOL +    "  switch (i) {" + PMD.EOL +    "  case 0:" + PMD.EOL +    "  {" + PMD.EOL + pad(5) +    "  }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "// Switch Density = 1.0" + PMD.EOL +    "public class SwitchDensity2 {" + PMD.EOL +    "       public void foo(int i) {" + PMD.EOL +    "               switch (i) {" + PMD.EOL +    "                       case 0:" + PMD.EOL +    "                       {" + PMD.EOL + pad(1) +    "                       }" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST3 =    "// Switch Density = 1.0" + PMD.EOL +    "public class SwitchDensity3 {" + PMD.EOL +    "       public void foo(int i) {" + PMD.EOL +    "               switch (i) {" + PMD.EOL +    "                       case 0:" + PMD.EOL +    "                       case 1:" + PMD.EOL +    "                       case 2:" + PMD.EOL +    "                       case 3:" + PMD.EOL +    "                       case 4:" + PMD.EOL +    "                       {" + PMD.EOL + pad(5) +    "                       }" + PMD.EOL +    "               } " + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static String pad(int times) {        String x = "";        for (int i = 0; i < times; i++) {            x += "System.err.println(\"I am a fish.\");" + PMD.EOL;        }        return x;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.rules.design.UseSingletonRule;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseSingletonRuleTest extends SimpleAggregatorTst implements ReportListener {    private int callbacks;    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "should be singleton since all static, public constructor", 1, new UseSingletonRule()),           new TestDescriptor(TEST2, "ok, uses non-static", 0, new UseSingletonRule()),           new TestDescriptor(TEST3, "should be singleton, couple of statics, no constructor", 1, new UseSingletonRule()),           new TestDescriptor(TEST4, "no constructor, one static - ok", 0, new UseSingletonRule()),           new TestDescriptor(TEST5, "classic singleton - ok", 0, new UseSingletonRule()),           new TestDescriptor(TEST6, "abstract, so ok", 0, new UseSingletonRule()),           new TestDescriptor(TEST7, "has no fields, so ok", 0, new UseSingletonRule()),           new TestDescriptor(TEST8, "has public static field, so need to check", 1, new UseSingletonRule()),       });    }    public void testResetState() throws Throwable {        callbacks = 0;        Rule rule = new UseSingletonRule();        Report report = new Report();        report.addListener(this);        runTestFromString(TEST3, rule, report);        runTestFromString(TEST4, rule, report);        assertEquals(1, callbacks);    }    public void ruleViolationAdded(RuleViolation ruleViolation) {        callbacks++;    }    public void metricAdded(Metric metric) {}    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() { }" + PMD.EOL +    " public static void doSomething() {}" + PMD.EOL +    " public static void main(String args[]) {" + PMD.EOL +    "  doSomething();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    public Foo() { }" + PMD.EOL +    "    public void doSomething() { }" + PMD.EOL +    "    public static void main(String args[]) { }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "    public static void doSomething1() { }" + PMD.EOL +    "    public static void doSomething2() { }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "    public Foo() { }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private Foo() {}" + PMD.EOL +    " public static Foo get() {" + PMD.EOL +    "  return null;" + PMD.EOL +    " }     " + PMD.EOL +    "}";    private static final String TEST6 =    "public abstract class Foo {" + PMD.EOL +    "    public static void doSomething1() { }" + PMD.EOL +    "    public static void doSomething2() { }" + PMD.EOL +    "    public static void doSomething3() { }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public Foo() { }" + PMD.EOL +    " private int x;" + PMD.EOL +    " public static void doSomething() {}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public static final int x = 5;" + PMD.EOL +    " public static void doSomething() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.ConfusingTernary;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ConfusingTernaryRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "!=, bad", 1, new ConfusingTernary()),           new TestDescriptor(TEST2, "==, good", 0, new ConfusingTernary()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x = a != b ? c : d;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x = a == b ? c : d;" + PMD.EOL +    " }" + PMD.EOL +    "}";    /*public class BadTernaries {  public static void main(String[] args) {    int i = 0;    int j = 1;    int k = 2;    boolean x = true;    boolean y = false;    boolean z = true;    // flag all of these, lines 11 - 42:    if (i != 11) {a();} else {b();}    if (i != 12 && j != 0) {a();} else {b();}    if (i != 13 || j != 0) {a();} else {b();}    if (i != 14 && j != 0 && k != 0) {a();} else {b();}    if (i != 15 || j != 0 || k != 0) {a();} else {b();}    if (i != 16) {a();} else if (i != j) {b();} else{c();}    if (i != 17) {a();} else if (i == j) {b();} else{c();}    if (i == 18) {a();} else if (i != j) {b();} else{c();}    x = (!y ? x : y);    x = (!(x && y) ? y : z);    x = (!(x || y) ? y : z);    x = ((!x && !y) ? y : z);    x = ((!x || !y) ? y : z);    if (i != 24 && !x) {a();} else {b();}    if (i != 25 || !x) {a();} else {b();}    if (i != 26 && j != 0 && !y) {a();} else {b();}    if (i != 27 || j != 0 || !y) {a();} else {b();}    if (i != 28) {a();} else if (!x) {b();} else{c();}    if (i != 29) {a();} else if (x) {b();} else{c();}    if (i == 30) {a();} else if (!x) {b();} else{c();}    x = !(c() == y) ? y : !z;    if (!c()) {a();} else {b();}    if (c() != x) {a();} else {b();}    if (!c() != x) {a();} else {b();}    if (!c() != !x) {a();} else {b();}    if ((i != 36) || !(j == 0)) {a();} else {b();}    if ((i != 37) || !(x ? y : z)) {a();} else {b();}    if ((i != 38)) {a();} else {b();}    if (i != 39 || (j != 0 || k != 0)) {a();} else {b();}    if (i != 40 && (j != 0 && k != 0)) {a();} else {b();}    if (!x && (j != 41 && k != 0)) {a();} else {b();}    if (((x != y)) || !(x)) { a(); } else { b(); }    // don't flag these:    if (i != 0) {a();}    if (!x) {a();}    if (i == 0) {a();} else {b();}    if (i == 0 && j != 0) {a();} else {b();}    if (i == 0 || j != 0) {a();} else {b();}    if (i == 0 && !x) {a();} else {b();}    if (x) {a();} else {b();}    if (x ? y : !z) {a();} else {b();}    if (c() == !x) {a();} else {b();}    if (c() ? !x : !c()) {a();} else {b();}    if (!x && d() instanceof String) {a();} else {b();}    if (!x && (d() instanceof String)) {a();} else {b();}  }  private static void a() { }  private static void b() { }  private static boolean c() { return true; }  private static Object d() { return null; }}    */}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.NullAssignmentRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NullAssignmentRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "initial assignment", 0, new NullAssignmentRule()),           new TestDescriptor(TEST2, "bad assignment", 1, new NullAssignmentRule()),           new TestDescriptor(TEST3, "check test", 0, new NullAssignmentRule()),           new TestDescriptor(TEST4, "null param on right hand sidel", 0, new NullAssignmentRule()),       });    }    private static final String TEST1 =    "public class NullAssignment1 {" + PMD.EOL +    " public Object foo() {" + PMD.EOL +    "  Object x = null; // OK" + PMD.EOL +    "  return x;" + PMD.EOL +    " }       " + PMD.EOL +    "}";    private static final String TEST2 =    "public class NullAssignment2 {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  Object x;" + PMD.EOL +    "  x = new Object();" + PMD.EOL +    "  for (int y = 0; y < 10; y++) {" + PMD.EOL +    "   System.err.println(y);  " + PMD.EOL +    "  }" + PMD.EOL +    "  x = null; // This is bad" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class NullAssignment3 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               Object x;" + PMD.EOL +    "               if (x == null) { // This is OK" + PMD.EOL +    "                       return;" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class NullAssignment4 {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  String x = null;" + PMD.EOL +    "  x = new String(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.PositionalIteratorRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class PositionalIteratorRuleTest extends RuleTst {    private static final String TEST1 =    "public class PositionalIterator1 {" + PMD.EOL +    " public void foo(Iterator i) {" + PMD.EOL +    "  while(i.hasNext()) {" + PMD.EOL +    "   Object one = i.next();" + PMD.EOL +    "   " + PMD.EOL +    "   // 2 calls to next() inside the loop == bad!" + PMD.EOL +    "   Object two = i.next(); " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class PositionalIterator2 {" + PMD.EOL +    " public void foo(Iterator i) {" + PMD.EOL +    "  while(i.hasNext()) {" + PMD.EOL +    "   Object one = i.next();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class PositionalIterator3 {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  Iterator i = (new List()).iterator();" + PMD.EOL +    "  while(i.hasNext()) {" + PMD.EOL +    "   Object one = i.next();" + PMD.EOL +    "   Iterator j = (new List()).iterator();" + PMD.EOL +    "   while (j.hasNext()) {" + PMD.EOL +    "    j.next();" + PMD.EOL +    "   }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    public void test1() throws Throwable {        runTestFromString(TEST1, 1, new PositionalIteratorRule());    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, new PositionalIteratorRule());    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, new PositionalIteratorRule());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.LongMethodRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class LongMethodRuleTest extends RuleTst {    private LongMethodRule getIUT() {        LongMethodRule IUT = new LongMethodRule();        IUT.addProperty("minimum", "10");        return IUT;    }    public void testShortMethod() throws Throwable {        runTestFromString(TEST1, 0, getIUT());    }    public void testReallyLongMethod() throws Throwable {        runTestFromString(TEST2, 1, getIUT());    }    public void testReallyLongMethodWithLongerRange() throws Throwable {        LongMethodRule IUT = getIUT();        IUT.addProperty("minimum", "20");        runTestFromString(TEST2, 0, IUT);    }    public void testNotQuiteLongMethod() throws Throwable {        runTestFromString(TEST3, 0, getIUT());    }    public void testLongMethod() throws Throwable {        runTestFromString(TEST4, 1, getIUT());    }    private static final String TEST1 =    "public class LongMethod1 {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "System.err.println(\"This is short.\");" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class LongMethod2 {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "System.err.println(\"This is long.\");" + PMD.EOL +    "    } // 11 lines - violation" + PMD.EOL +    "}";    private static final String TEST3 =    "public class LongMethod2 {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "System.err.println(\"This is long, but not a violation\");" + PMD.EOL +    "    } // 9 lines - Not a violation" + PMD.EOL +    "}";    private static final String TEST4 =    "public class LongMethod2 {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "System.err.println(\"This is long, and is a violation\");" + PMD.EOL +    "    } // > 10 lines - Not a violation" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.LongClassRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class LongClassRuleTest extends RuleTst {    public LongClassRule getIUT() {        LongClassRule IUT = new LongClassRule();        IUT.addProperty("minimum", "10");        return IUT;    }    public void testShortClass() throws Throwable {        runTestFromString(TEST0, 0, getIUT());    }    public void testLongClass() throws Throwable {        runTestFromString(TEST1, 1, getIUT());    }    public void testLongClassWithLongerTest() throws Throwable {        LongClassRule IUT = getIUT();        IUT.addProperty("minimum", "2000");        runTestFromString(TEST1, 0, IUT);    }    private static final String TEST0 =    "public class LongMethod1 {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "System.err.println(\"This is short.\");" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST1 =    "public class LongClass1" + PMD.EOL +    "{" + PMD.EOL +    "    public void method0() {" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "System.err.println(\"This is a long class.\");" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.OnlyOneReturnRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class OnlyOneReturnRuleTest extends RuleTst {    private static final String TEST1 =    "public class OnlyOneReturn1 {" + PMD.EOL +    " public String foo(int x) {    " + PMD.EOL +    "  if (x > 0) {" + PMD.EOL +    "   return \"hey\";" + PMD.EOL +    "  }" + PMD.EOL +    "  return \"hi\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class OnlyOneReturn2 {" + PMD.EOL +    " public String foo(int x) {    " + PMD.EOL +    "  return \"hi\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class OnlyOneReturn3 {" + PMD.EOL +    " public void foo(int x) {      " + PMD.EOL +    "  int y =2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class OnlyOneReturn4 {" + PMD.EOL +    " public void foo(int x) {      " + PMD.EOL +    "  if (x>2) {" + PMD.EOL +    "    return;" + PMD.EOL +    "  }" + PMD.EOL +    "  int y =2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class OnlyOneReturn5 {" + PMD.EOL +    " public int foo(int x) {" + PMD.EOL +    "  try {" + PMD.EOL +    "   x += 2;" + PMD.EOL +    "   return x;" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   System.err.println(\"WunderBuggy!\");" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class OnlyOneReturn6 {" + PMD.EOL +    " public int foo() {" + PMD.EOL +    "  FileFilter f = new FileFilter() {" + PMD.EOL +    "   public boolean accept(File file) {" + PMD.EOL +    "    return false;" + PMD.EOL +    "   }" + PMD.EOL +    "  };" + PMD.EOL +    "  return 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public void testTwoReturns() throws Throwable {        runTestFromString(TEST1, 1, new OnlyOneReturnRule());    }    public void testOneReturn() throws Throwable {        runTestFromString(TEST2, 0, new OnlyOneReturnRule());    }    public void testNoReturns() throws Throwable {        runTestFromString(TEST3, 0, new OnlyOneReturnRule());    }    public void testVoidRtn() throws Throwable {        runTestFromString(TEST4, 0, new OnlyOneReturnRule());    }    public void testFinally() throws Throwable {        runTestFromString(TEST5, 0, new OnlyOneReturnRule());    }    public void testReturnInsideAnonymousInnerClass() throws Throwable {        runTestFromString(TEST6, 0, new OnlyOneReturnRule());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.LooseCouplingRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LooseCouplingRuleTest extends SimpleAggregatorTst {    private LooseCouplingRule rule;    public void setUp() {        rule = new LooseCouplingRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "returning a HashSet, bad", 1, rule),           new TestDescriptor(TEST2, "returning a Map, OK", 0, rule),           new TestDescriptor(TEST3, "no problemo", 0, rule),           new TestDescriptor(TEST4, "returning a set", 0, rule),           new TestDescriptor(TEST5, "field declared of type HashSet", 1, rule),           new TestDescriptor(TEST6, "field, return type both HashSet", 2, rule),           new TestDescriptor(TEST7, "two fields", 2, rule),           new TestDescriptor(TEST8, "method param is HashMap", 1, rule),           new TestDescriptor(TEST9, "Vector could be List", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " HashSet foo() {" + PMD.EOL +    "  return new HashSet();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Map getFoo() {" + PMD.EOL +    "  return new HashMap();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " Set fooSet = new HashSet(); // OK" + PMD.EOL +    " Set foo() {" + PMD.EOL +    "  return fooSet;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +    " HashSet foo() { // NOT OK" + PMD.EOL +    "  return fooSet;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " HashSet fooSet = new HashSet();" + PMD.EOL +    " HashMap fooMap = new HashMap();" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " void foo(HashMap bar) {}" + PMD.EOL +    "}";    private static final String TEST9 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo(Vector bar) {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyStatementNotInLoopRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyStatementNotInLoop");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, semicolon after for", 0, rule),           new TestDescriptor(TEST2, "ok, semicolon after while", 0, rule),           new TestDescriptor(TEST3, "bad, random semicolon", 1, rule),           new TestDescriptor(TEST4, "bad, double semicolon", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  for (int i=2; i<10; i++);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  while (i++ < 20);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  ;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class IfElseStmtsMustUseBracesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("rulesets/braces.xml", "IfElseStmtsMustUseBracesRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "else without braces", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "two sets of missing braces", 2, rule),           new TestDescriptor(TEST4, "elseif with missing braces", 1, rule),           new TestDescriptor(TEST5, "elseif with braces after else", 0, rule),           new TestDescriptor(TEST6, "elseif with missing braces, first braces on separate line", 1, rule),           new TestDescriptor(TEST7, "bug 976643 - nested ifs without braces", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else {" + PMD.EOL +    "   x=4;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) " + PMD.EOL +    "   y=2;" + PMD.EOL +    "  else " + PMD.EOL +    "   x=4;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else if (true) { " + PMD.EOL +    "   x = 3; " + PMD.EOL +    "  } else " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else if (true) { " + PMD.EOL +    "   x = 3; " + PMD.EOL +    "  } else { " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) " + PMD.EOL +    "  {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } " + PMD.EOL +    "  else " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  if (true) " + PMD.EOL +    "   if (false) " + PMD.EOL +    "    x=2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ForLoopsMustUseBracesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/braces.xml", "ForLoopsMustUseBracesRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "", 1, rule),           new TestDescriptor(TEST4, "", 1, rule),           new TestDescriptor(TEST5, "", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int i=0; i<42;i++)" + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (int i=0; i<42;i++) {" + PMD.EOL +    "       foo();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (int i=0; i<42;) " + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (int i=0;;) " + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (;;) " + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class IfStmtsMustUseBracesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/braces.xml", "IfStmtsMustUseBraces");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "nested ifs", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  if (true) x=2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   if (true) bar();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class WhileLoopsMustUseBracesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/braces.xml", "WhileLoopsMustUseBracesRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "no braces", 1, rule),           new TestDescriptor(TEST2, "with braces", 0, rule),       });    }    private static final String TEST1 =    "public class WhileLoopsNeedBraces1 {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  int x =0;" + PMD.EOL +    "  while (true)" + PMD.EOL +    "   x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class WhileLoopsNeedBraces2 {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  int x =0;" + PMD.EOL +    "  while (true) {" + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.clone;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ProperCloneImplementationRuleTest extends SimpleAggregatorTst{  private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/clone.xml", "ProperCloneImplementationRule");    }  public void testAll() {     runTests(new TestDescriptor[] {         new TestDescriptor(TEST1, "ok, calls super.clone", 0, rule),         new TestDescriptor(TEST2, "bad, Foo.clone() calls new Foo();", 1, rule),         new TestDescriptor(TEST3, "clone([whatever]) is fine", 0, rule),     });  }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    "  super.clone();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    "  Foo f = new Foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void clone(String fiddle) {" + PMD.EOL +    "  Foo f = new Foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.clone;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CloneThrowsCloneNotSupportedExceptionRuleTest  extends SimpleAggregatorTst{  private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/clone.xml", "CloneThrowsCloneNotSupportedException");    }  public void testAll() {     runTests(new TestDescriptor[] {         new TestDescriptor(TEST1, "ok, throws CloneNotSupportedException", 0, rule),         new TestDescriptor(TEST2, "bad", 1, rule),         new TestDescriptor(TEST3, "final class, rule does not apply", 0, rule),         new TestDescriptor(TEST4, "testing with multiple methods", 1, rule),     });  }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void clone() throws CloneNotSupportedException {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public final class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void clone() {}" + PMD.EOL +    " void foo() {}" + PMD.EOL +    " void bar() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.clone;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CloneMethodMustImplementCloneableRuleTest extends SimpleAggregatorTst{  private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/clone.xml", "CloneMethodMustImplementCloneable");    }  public void testAll() {     runTests(new TestDescriptor[] {         new TestDescriptor(TEST1, "ok, implements Cloneable", 0, rule),         new TestDescriptor(TEST2, "bad, doesn't implement Cloneable", 1, rule),     });  }    private static final String TEST1 =    "public class Foo implements Cloneable {" + PMD.EOL +    " void clone() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void clone() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidThrowingCertainExceptionTypesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/strictexception.xml", "AvoidThrowingCertainExceptionTypesRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "throwing various types", 5, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  throw new Throwable();" + PMD.EOL +    "  throw new Exception();" + PMD.EOL +    "  throw new Error();" + PMD.EOL +    "  throw new RuntimeException();" + PMD.EOL +    "  throw new NullPointerException();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidCatchingNPERuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/strictexception.xml", "AvoidCatchingNPERule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "catching another type, ok", 0, rule),           new TestDescriptor(TEST3, "throwing it, ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (NullPointerException e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (FooException e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  throw new NullPointerException();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.strictexception.ExceptionTypeChecking;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExceptionTypeCheckingRuleTest extends SimpleAggregatorTst  {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "checks for NPE", 1, new ExceptionTypeChecking()),           new TestDescriptor(TEST2, "ok", 0, new ExceptionTypeChecking()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (Exception e) {" + PMD.EOL +    "   if (e instanceof NullPointerException) {}" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.strictexception.AvoidCatchingThrowable;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidCatchingThrowableRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, new AvoidCatchingThrowable()),           new TestDescriptor(TEST2, "ok", 0, new AvoidCatchingThrowable()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (Throwable t) {}   " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (RuntimeException t) {}   " + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.ExceptionAsFlowControlRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExceptionAsFlowControlRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, new ExceptionAsFlowControlRule()),           new TestDescriptor(TEST2, "normal throw catch", 0, new ExceptionAsFlowControlRule())       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   try {" + PMD.EOL +    "   } catch (Exception e) {" + PMD.EOL +    "    throw new WrapperException(e);" + PMD.EOL +    "    // this is essentially a GOTO to the WrapperException catch block" + PMD.EOL +    "   }" + PMD.EOL +    "  } catch (WrapperException e) {" + PMD.EOL +    "   // do some more stuff " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.strictexception.ExceptionSignatureDeclaration;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExceptionSignatureDeclarationRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "method throws Exception", 1, new ExceptionSignatureDeclaration()),           new TestDescriptor(TEST2, "ok", 0, new ExceptionSignatureDeclaration()),           new TestDescriptor(TEST3, "constructor throws Exception", 1, new ExceptionSignatureDeclaration()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() throws Exception {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " Foo() throws Exception {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyStaticInitializerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyStaticInitializer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " static {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " static {" + PMD.EOL +    "  x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JumbledIncrementerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "JumbledIncrementer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "", 1, rule),           new TestDescriptor(TEST2, "", 0, rule),           new TestDescriptor(TEST3, "", 0, rule),           new TestDescriptor(TEST4, "using outer loop incrementor as array index is OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i = 0; i < 10; i++) { " + PMD.EOL +    "   for (int k = 0; k < 20; i++) { " + PMD.EOL +    "    int x = 2; " + PMD.EOL +    "   } " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i = 0; i < 10; i++) { " + PMD.EOL +    "   for (int k = 0; k < 20; k++) { " + PMD.EOL +    "    int x = 2; " + PMD.EOL +    "   } " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i=0; i<5; ) {" + PMD.EOL +    "   i++;" + PMD.EOL +    "  }" + PMD.EOL +    "  for (int i=0;;) {" + PMD.EOL +    "   if (i<5) {" + PMD.EOL +    "    break;" + PMD.EOL +    "   }" + PMD.EOL +    "   i++;" + PMD.EOL +    "  }" + PMD.EOL +    "  for (;;) {" + PMD.EOL +    "   int x =5;" + PMD.EOL +    "  }" + PMD.EOL +    "  for (int i=0; i<5;i++) ;" + PMD.EOL +    "  for (int i=0; i<5;i++) " + PMD.EOL +    "   foo();" + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i = 0; i < 10; i++) { " + PMD.EOL +    "   for (int k = 0; k < 20; j[i]++) { " + PMD.EOL +    "    int x = 2; " + PMD.EOL +    "   } " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeShouldBeProtectedRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/finalizers.xml", "FinalizeShouldBeProtected");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "public finalize", 1, rule),           new TestDescriptor(TEST2, "finalize with some params", 0, rule),           new TestDescriptor(TEST3, "legitimate overriding", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize(int x) {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " protected void finalize() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptySynchronizedBlockRuleTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptySynchronizedBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  synchronized (this) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  synchronized (this) {int x = 2;}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MethodWithSameNameAsEnclosingClassRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "MethodWithSameNameAsEnclosingClass");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "doesn't crash on interfaces", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " int Foo(double x) {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " void voo();" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class InstantiationToGetClassRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/newrules.xml", "InstantiationToGetClass");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "should catch param to constructor", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " Class clazz = new String().getClass();" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Class clazz = getFoo().getClass();" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " Class clazz = new Integer(10).getClass();" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class BooleanInstantiationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "BooleanInstantiation");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "new java.lang.Boolean", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " Boolean b = new Boolean(\"true\");" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Boolean b = new java.lang.Boolean(\"true\");" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " Boolean b = Boolean.TRUE;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.UnusedPrivateFieldRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedPrivateFieldRuleTest extends SimpleAggregatorTst {    private UnusedPrivateFieldRule rule;    public void setUp() {        rule = new UnusedPrivateFieldRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple unused private field", 1, rule),           new TestDescriptor(TEST2, "private field referenced in another field's initializer", 0, rule),           new TestDescriptor(TEST3, "private field with field of same name in anonymous inner class", 1, rule),           new TestDescriptor(TEST4, "field is used semantically before it's declared syntactically", 0, rule),           new TestDescriptor(TEST5, "private field referenced via 'this' modifier", 0, rule),           new TestDescriptor(TEST6, "private referenced by anonymous inner class", 0, rule),           new TestDescriptor(TEST7, "interface sanity test", 0, rule),           new TestDescriptor(TEST8, "unused private field in static inner class", 1, rule),           new TestDescriptor(TEST9, "private field referenced in nonstatic inner class", 0, rule),           new TestDescriptor(TEST10, "unused private static field", 1, rule),           new TestDescriptor(TEST11, "private static final referenced with qualifier", 0, rule),           new TestDescriptor(TEST12, "unused private field after class decl", 1, rule),           new TestDescriptor(TEST13, "two unused private fields in separate inner classes", 2, rule),           new TestDescriptor(TEST14, "method param shadows unused private field", 1, rule),           new TestDescriptor(TEST15, "private field referenced via 'this' not shadowed by param of same name", 0, rule),           new TestDescriptor(TEST16, "don't catch public fields", 0, rule),           new TestDescriptor(TEST17, "instantiate self and reference private field on other object", 0, rule),           new TestDescriptor(TEST18, "don't count Serialization fields as being unused", 0, rule),           new TestDescriptor(TEST19, "an assignment does not a usage make", 1, rule),           new TestDescriptor(TEST20, "assignment to field member is a usage", 0, rule),           new TestDescriptor(TEST21, "assignment to field member using this modifier is a usage", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "private String foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = foo;" + PMD.EOL +    " void buz() {" + PMD.EOL +    "  bar = bar + 1;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " void baz() {" + PMD.EOL +    "  Runnable r = new Runnable() {" + PMD.EOL +    "   public void run() {" + PMD.EOL +    "    String foo = \"buz\";" + PMD.EOL +    "   }" + PMD.EOL +    "  };   " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  foo[0] = foo[0] + 1;" + PMD.EOL +    " }" + PMD.EOL +    " private int[] foo;" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " void bar() {   " + PMD.EOL +    "  bar = this.foo;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private static final String FOO = \"foo\";" + PMD.EOL +    "  public Runnable bar() {      " + PMD.EOL +    "   return new Runnable() {" + PMD.EOL +    "    public void run() {" + PMD.EOL +    "     FOO.toString();" + PMD.EOL +    "    }" + PMD.EOL +    "   };" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    " public static final String FOO = \"FOO\"; " + PMD.EOL +    " public boolean equals(Object another);" + PMD.EOL +    " public int hashCode();" + PMD.EOL +    " public String toString();" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public static class Services {" + PMD.EOL +    "  private String x;    " + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " private class Bar {" + PMD.EOL +    "  void baz() {" + PMD.EOL +    "   x = x + 2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " private static String foo;" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " private static final int BAR = 2;" + PMD.EOL +    " int x = Foo.BAR;" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " public class Foo {}" + PMD.EOL +    " private int x;" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " public class Foo {private int x;}" + PMD.EOL +    " public class Bar {private int x;}" + PMD.EOL +    "}";    private static final String TEST14 =    "public class Foo {" + PMD.EOL +    " private int value;" + PMD.EOL +    " int doSomething(int value) { " + PMD.EOL +    "  return value + 1; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST15 =    "public class Foo {" + PMD.EOL +    " private int x; " + PMD.EOL +    " public Foo(int x) {" + PMD.EOL +    "  this.x= this.x + 1;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + PMD.EOL +    " public static final int FOO = 1;" + PMD.EOL +    "}";    private static final String TEST17 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  Foo foo = new Foo();  " + PMD.EOL +    "  foo.x = foo.x + 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST18 =    "public class Foo {" + PMD.EOL +    " private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"foo\", String.class)};" + PMD.EOL +    "}";    private static final String TEST19 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x = 4;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST20 =    "public class Foo {" + PMD.EOL +    " private Foo x = new Foo();" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x.y = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST21 =    "public class Foo {" + PMD.EOL +    " private Foo x = new Foo();" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  this.x.y = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LongVariableRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "LongVariable");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "param", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "local", 1, rule),           new TestDescriptor(TEST4, "field", 1, rule),           new TestDescriptor(TEST5, "for", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    void foo(String argsWithExtraMustard) {} " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    void foo() {" + PMD.EOL +    "       int bugleDeWump = -1;" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "" + PMD.EOL +    "    void foo() {" + PMD.EOL +    "       int abcdefghijklmnopqrstuvwxyz = -1; " + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "   void foo() {" + PMD.EOL +    "       for (int interestingIntIterator = 0; " + PMD.EOL +    "            interestingIntIterator < 10; " + PMD.EOL +    "            interestingIntIterator++) { }" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "    private int abcdefghijklmnopqrstuvwxyz;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AssignmentInOperandRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/controversial.xml", "AssignmentInOperandRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "assignment in if conditional expression", 0, rule),           new TestDescriptor(TEST4, "assignment in while conditional expression", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  if ((x = getX()) == 3) {" + PMD.EOL +    "   System.out.println(\"3!\");" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    " private int getX() {" + PMD.EOL +    "  return 3;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  if (false) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  if (false) {" + PMD.EOL +    "   int x =2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  while ( (x = getX()) != 0 ) {}" + PMD.EOL +    " }" + PMD.EOL +    " private int getX() {return 2;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.SimplifyBooleanReturnsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimplifyBooleanReturnsRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, new SimplifyBooleanReturnsRule()),           new TestDescriptor(TEST2, "bad", 1, new SimplifyBooleanReturnsRule()),           new TestDescriptor(TEST3, "ok", 0, new SimplifyBooleanReturnsRule()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void foo() {   " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   return true;" + PMD.EOL +    "  } else {" + PMD.EOL +    "   return false;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public boolean foo() {        " + PMD.EOL +    "  if (true) " + PMD.EOL +    "   return true;" + PMD.EOL +    "   else " + PMD.EOL +    "  return false;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Object foo() { " + PMD.EOL +    "  if (!true) {" + PMD.EOL +    "   return null;" + PMD.EOL +    "  } else {}" + PMD.EOL +    "  return null;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.ExcessivePublicCountRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class ExcessivePublicCountRuleTest extends RuleTst {    private ExcessivePublicCountRule rule;    public void setUp() {        rule = new ExcessivePublicCountRule();    }    public void testSimpleOK() throws Throwable {        rule.addProperty("minimum", "50");        runTestFromString(TEST1, 0, rule);    }    public void testSimpleBad() throws Throwable {        rule.addProperty("minimum", "2");        runTestFromString(TEST2, 1, rule);    }    private static final String TEST1 =    "public class ExcessivePublicCountRule1 {" + PMD.EOL +    " public int foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class ExcessivePublicCountRule2 {" + PMD.EOL +    " public int foo;" + PMD.EOL +    " public int bif;" + PMD.EOL +    " public int baz;" + PMD.EOL +    " public int bof;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.UnusedLocalVariableRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedLocalVariableTest extends SimpleAggregatorTst {    private UnusedLocalVariableRule rule;    public void setUp() {        rule = new UnusedLocalVariableRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "unused local with assignment", 1, rule),           new TestDescriptor(TEST2, "unused local w/o assignment", 1, rule),           new TestDescriptor(TEST3, "unused local in constructor", 1, rule),           new TestDescriptor(TEST4, "local used on rhs", 0, rule),           new TestDescriptor(TEST5, "unused local in static initializer", 1, rule),           new TestDescriptor(TEST6, "unused field", 0, rule),           new TestDescriptor(TEST7, "loop indexes are not unused locals", 0, rule),           new TestDescriptor(TEST8, "local used in anonymous inner class", 0, rule),           new TestDescriptor(TEST9, "two unused locals of same name, one in nested class", 2, rule),           new TestDescriptor(TEST10, "local variable in initializer of for loop", 0, rule),           new TestDescriptor(TEST11, "two locals declared on same line", 2, rule),           new TestDescriptor(TEST12, "an assignment does not a usage make", 1, rule),           new TestDescriptor(TEST13, "a compound assignment operator doth a usage make", 0, rule),           new TestDescriptor(TEST14, "assignment to a member field means used", 0, rule),           new TestDescriptor(TEST15, "make sure scopes are working", 3, rule),           new TestDescriptor(TEST16, "another scope test", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "   String fr = new String();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x;" + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST3 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "    public Foo() {" + PMD.EOL +    "       List a = new ArrayList();" + PMD.EOL +    "    }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST4 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "    public Foo() {" + PMD.EOL +    "       List a = new ArrayList();" + PMD.EOL +    "       if (true) {" + PMD.EOL +    "               a.size();" + PMD.EOL +    "       }" + PMD.EOL +    "    }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST5 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " static {" + PMD.EOL +    "  String x;" + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public int x;" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int i=0;i<10; i++);" + PMD.EOL +    "  for (int i=0;i<10; i++);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  final int x = 2;" + PMD.EOL +    "   new Runnable() {" + PMD.EOL +    "    public void run() {" + PMD.EOL +    "     System.out.println(x);" + PMD.EOL +    "    }" + PMD.EOL +    "   };  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST9=    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  class Bar {" + PMD.EOL +    "   void buz() {" + PMD.EOL +    "    int x = 4;" + PMD.EOL +    "   }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int x = 0; ; ) { // USED" + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x,y=0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x;" + PMD.EOL +    "   x = 4;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 0;" + PMD.EOL +    "   x += 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST14 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   Bar b = new Bar();" + PMD.EOL +    "   b.buz = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST15 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   if (true) {int y =2;int j =3;} " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   if (true) {int y =2;foo(y);int j =3;foo(j);} " + PMD.EOL +    " }" + PMD.EOL +    " void bar2() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   fiddle(x);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.DoubleCheckedLockingRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DoubleCheckedLockingRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple ok", 0, new DoubleCheckedLockingRule()),           new TestDescriptor(TEST2, "simple failure", 1, new DoubleCheckedLockingRule()),           new TestDescriptor(TEST3, "skip interfaces", 0, new DoubleCheckedLockingRule()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "      Object baz;" + PMD.EOL +    "      Object bar() {" + PMD.EOL +    "        if(baz == null) { //baz may be non-null yet not fully created" + PMD.EOL +    "          synchronized(this){" + PMD.EOL +    "            if(baz == null){" + PMD.EOL +    "              baz = new Object();" + PMD.EOL +    "            }" + PMD.EOL +    "          }" + PMD.EOL +    "        }" + PMD.EOL +    "        return baz;" + PMD.EOL +    "      }" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " void foo();" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ForLoopShouldBeWhileLoopRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "ForLoopShouldBeWhileLoop");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "for loop like this: for (;;) {} ", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  for (;x<5;) { " + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int x=2;x<5;) { " + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (;;) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AbstractNamingRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "AbstractNamingRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, abstract class AbstractFoo", 0, rule),           new TestDescriptor(TEST2, "bad, abstract class named Foo", 1, rule),           new TestDescriptor(TEST3, "ok, concrete class named AbstractFoo", 0, rule),           new TestDescriptor(TEST4, "ok, concrete class named Foo", 0, rule),       });    }    private static final String TEST1 =    "public abstract class AbstractFoo {}";    private static final String TEST2 =    "public abstract class Foo {}";    private static final String TEST3 =    "public class AbstractFoo {}";    private static final String TEST4 =    "public class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.UnusedFormalParameterRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedFormalParameterRuleTest extends SimpleAggregatorTst {    private UnusedFormalParameterRule rule;    public void setUp() {        rule = new UnusedFormalParameterRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "one parameter", 1, rule),           new TestDescriptor(TEST2, "fully qualified parameter", 0, rule),           new TestDescriptor(TEST3, "one parameter with a method call", 0, rule),           new TestDescriptor(TEST4, "interface", 0, rule)       });    }    private static final String TEST1 =    "class UnusedFormalParam1 {" + PMD.EOL +    "    private void testMethod(String param1) {" + PMD.EOL +    "        //System.out.println(param1);" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "class UnusedFormalParam2 {" + PMD.EOL +    "    private void foo (String s) " + PMD.EOL +    "    {String str = s.toString();}" + PMD.EOL +    "}";    private static final String TEST3 =    "class UnusedFormalParam3 {" + PMD.EOL +    "    private void t1(String s) {" + PMD.EOL +    "        s.toString();" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo {" + PMD.EOL +    " void foo(String bar);" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalFieldCouldBeStaticRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "FinalFieldCouldBeStatic");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "already static, OK", 0, rule),           new TestDescriptor(TEST3, "non-final, OK", 0, rule),           new TestDescriptor(TEST4, "non-primitive failure case - only works for String", 1, rule),           new TestDescriptor(TEST5, "final field that's a thread, OK", 0, rule),           new TestDescriptor(TEST6, "don't flag interfaces", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public final int BAR = 42;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public static final int BAR = 42;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public int BAR = 42;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public final String BAR = \"42\";" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public final Thread BAR = new Thread();" + PMD.EOL +    "}";    private static final String TEST6 =    "public interface Foo {" + PMD.EOL +    " public final int BAR = 42;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class OverrideBothEqualsAndHashcodeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "OverrideBothEqualsAndHashcodeRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "hash code only", 1, rule),           new TestDescriptor(TEST2, "equals only", 1, rule),           new TestDescriptor(TEST3, "overrides both", 0, rule),           new TestDescriptor(TEST4, "overrides neither", 0, rule),           new TestDescriptor(TEST5, "equals sig uses String, not Object", 1, rule),           new TestDescriptor(TEST6, "interface", 0, rule),           new TestDescriptor(TEST7, "java.lang.Object", 0, rule),       });    }    private static final String TEST1 =    "public class OverrideBothEqualsAndHashcode1 {" + PMD.EOL +    " public int hashCode() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class OverrideBothEqualsAndHashcode2 {" + PMD.EOL +    " public boolean equals(Object other) {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class OverrideBothEqualsAndHashcode3 {" + PMD.EOL +    " public boolean equals(Object other) {}" + PMD.EOL +    " public int hashCode() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class OverrideBothEqualsAndHashcode4 {" + PMD.EOL +    "}";    private static final String TEST5 =    "public class OverrideBothEqualsAndHashcode5 {" + PMD.EOL +    " public boolean equals(String o) {" + PMD.EOL +    "  return true;" + PMD.EOL +    " }" + PMD.EOL +    " public int hashCode() {" + PMD.EOL +    "  return 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public interface OverrideBothEqualsAndHashcode6 {" + PMD.EOL +    " public boolean equals(Object o);" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public boolean equals(java.lang.Object o) {" + PMD.EOL +    "  return true;" + PMD.EOL +    " }" + PMD.EOL +    " public int hashCode() {" + PMD.EOL +    "  return 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ShortVariableRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "ShortVariable");        rule.setMessage("{0}");        rule.addProperty("pluginname", "true");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "param", 1, rule),           new TestDescriptor(TEST2, "none", 0, rule),           new TestDescriptor(TEST3, "local", 1, rule),           new TestDescriptor(TEST4, "for", 0, rule),           new TestDescriptor(TEST5, "field", 1, rule),           new TestDescriptor(TEST6, "catch(Exception e) is OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public static void main(String a[]) { // a should trigger it." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "       int bugleDeWump = -1;" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "       int ab = -1; " + PMD.EOL +    "       // Should trigger ShortVariable rule." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "       for (int i = 0; i < 10; i++) { } // Should NOT!! trigger." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "    private int qx; // Should cause a problem." + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    "    private void bar() {" + PMD.EOL +    "     try {} catch (Exception e) {}" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.rules.XPathRule;import test.net.sourceforge.pmd.testframework.RuleTst;import java.io.StringReader;/** * @author daniels */public class XPathRuleTest extends RuleTst {    XPathRule rule;    public void setUp() {        rule = new XPathRule();        rule.setMessage("XPath Rule Failed");    }    public void testPluginname() throws Throwable {        Rule rule = new XPathRule();        rule.addProperty("xpath", "//VariableDeclaratorId[string-length(@Image) < 3]");        rule.setMessage("{0}");        rule.addProperty("pluginname", "true");        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        RuleSet rules = new RuleSet();        rules.addRule(rule);        p.processFile(new StringReader(TEST1), rules, ctx);        RuleViolation rv = (RuleViolation)report.iterator().next();        assertEquals("a", rv.getDescription());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    int a;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.ConstructorCallsOverridableMethodRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ConstructorCallsOverridableMethodRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "calling public method from constructor", 1, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST2, "calling protected method from constructor", 1, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST3, "calling package private method from constructor", 1, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST4, "calling private method, ok", 0, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST5, "overloaded constructors, calling public method", 1, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST6, "calling method on literal bug", 0, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST7, "method in anonymous inner class is ok", 0, new ConstructorCallsOverridableMethodRule()),           new TestDescriptor(TEST8, "bug report 975407", 0, new ConstructorCallsOverridableMethodRule()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " protected void bar() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " void bar() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  this(\"Bar\");" + PMD.EOL +    " }" + PMD.EOL +    " private Foo(String bar) {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public Foo(String s) {" + PMD.EOL +    "  \"foo\".equals(s);" + PMD.EOL +    " }" + PMD.EOL +    " public void equals(String bar) {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public Foo(String s) {" + PMD.EOL +    "  addActionListener(new ActionListener() {" + PMD.EOL +    "   public void actionPerformed(ActionEvent e) {bar();}" + PMD.EOL +    "  });" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EqualsNullRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "EqualsNull");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "object.equals(null), bad", 1, rule),           new TestDescriptor(TEST2, "object == null, ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (foo.equals(null)) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (foo == null) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.DuplicateImportsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DuplicateImportsRuleTest extends SimpleAggregatorTst {    private DuplicateImportsRule rule;    public void setUp() {        rule = new DuplicateImportsRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "duplicate single type imports", 1, rule),           new TestDescriptor(TEST2, "duplicate wildcard imports", 1, rule),           new TestDescriptor(TEST3, "single type import after wildcard import", 1, rule),           new TestDescriptor(TEST4, "subpackage import, ok", 0, rule),       });    }    private static final String TEST1 =    "import java.io.File;" + PMD.EOL +    "import java.util.*;" + PMD.EOL +    "import java.io.File;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import java.io.*;" + PMD.EOL +    "import java.io.*;" + PMD.EOL +    "public class Foo {}";    private static final String TEST3 =    "import java.util.*;" + PMD.EOL +    "import java.net.*;" + PMD.EOL +    "import java.io.*;" + PMD.EOL +    "import java.io.File;" + PMD.EOL +    "public class Foo {}";    private static final String TEST4 =    "import javax.servlet.*;" + PMD.EOL +    "import javax.servlet.http.*;" + PMD.EOL +    "public class Foo {}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousEqualsMethodNameRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/newrules.xml", "SuspiciousEqualsMethodName");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad, equals(Foo foo)", 1, rule),           new TestDescriptor(TEST2, "ok, equals(Object foo)", 0, rule),           new TestDescriptor(TEST3, "bad, equal(Object foo)", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public boolean equals(Foo foo) {return true;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public boolean equals(Object foo) {return true;}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public boolean equal(Object foo) {return true;}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidDollarSignsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "AvoidDollarSigns");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "class Fo$o", 1, rule),           new TestDescriptor(TEST2, "variable fo$oo", 1, rule),           new TestDescriptor(TEST3, "method foo$oo", 1, rule),           new TestDescriptor(TEST4, "interface fo$oo", 1, rule),           new TestDescriptor(TEST5, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class F$oo {}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " int fo$o;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void fo$o() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo$oo {}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    " int buz;" + PMD.EOL +    "}" + PMD.EOL +    "public interface Baz {} ";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DontImportSunRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/controversial.xml", "DontImportSunRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad, import from sun.", 1, rule),           new TestDescriptor(TEST2, "ok, signal is ok", 0, rule),       });    }    private static final String TEST1 =    "import sun.Foo;" + PMD.EOL +    "public class Bar {}";    private static final String TEST2 =    "import sun.misc.Signal;" + PMD.EOL +    "public class Bar {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyTryBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyTryBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "bad", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule)       });    }    private static final String TEST1 =    "public class EmptyTryBlock1 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               try {" + PMD.EOL +    "               } catch (Exception e) {" + PMD.EOL +    "                       e.printStackTrace();" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class EmptyTryBlock2 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               try {" + PMD.EOL +    "               } finally {" + PMD.EOL +    "                       int x = 5;" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class EmptyTryBlock3 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               try {" + PMD.EOL +    "                       int f =2;" + PMD.EOL +    "               } finally {" + PMD.EOL +    "                       int x = 5;" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.UnnecessaryConversionTemporaryRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class UnnecessaryTemporariesRuleTest extends RuleTst {    private static final String TEST1 =    " public class UnnecessaryTemporary1 {" + PMD.EOL +    "     void method (int x) {" + PMD.EOL +    "        new Integer(x).toString(); " + PMD.EOL +    "        new Long(x).toString(); " + PMD.EOL +    "        new Float(x).toString(); " + PMD.EOL +    "        new Byte((byte)x).toString(); " + PMD.EOL +    "        new Double(x).toString(); " + PMD.EOL +    "        new Short((short)x).toString(); " + PMD.EOL +    "     }" + PMD.EOL +    " }";    public void testSimple() throws Throwable {        runTestFromString(TEST1, 6, new UnnecessaryConversionTemporaryRule());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ReturnFromFinallyBlockTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "ReturnFromFinallyBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "throw exception but return from finally", 1, rule),           new TestDescriptor(TEST2, "lots of returns", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " String bugga() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   throw new Exception( \"My Exception\" );" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   throw e;" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   return \"A. O. K.\"; // Very bad." + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " String getBar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   return \"buz\";" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   return \"biz\";" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   return \"fiddle!\"; // bad!" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "  String getBar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   return \"buz\";" + PMD.EOL +    "  } finally {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class StringInstantiationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/strings.xml", "StringInstantiation");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "new 'new String's", 2, rule),           new TestDescriptor(TEST2, "new String array", 0, rule),           new TestDescriptor(TEST3, "using multiple parameter constructor", 0, rule),           new TestDescriptor(TEST4, "using 4 parameter constructor", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private String bar = new String(\"bar\");" + PMD.EOL +    " private String baz = new String();" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private String[] bar = new String[5];" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  byte[] bytes = new byte[50];" + PMD.EOL +    "  String bar = new String(bytes, 0, bytes.length);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  byte[] bytes = new byte[50];" + PMD.EOL +    "  String bar = new String(bytes, 0, bytes.length, \"some-encoding\");" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.StringToStringRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class StringToStringRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "local var", 1, new StringToStringRule()),           new TestDescriptor(TEST2, "parameter", 1, new StringToStringRule()),           new TestDescriptor(TEST3, "field", 1, new StringToStringRule()),           new TestDescriptor(TEST4, "primitive", 0, new StringToStringRule()),           new TestDescriptor(TEST5, "multiple similar params", 0, new StringToStringRule()),           new TestDescriptor(TEST6, "string array", 1, new StringToStringRule())       });    }   private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private String baz() {" + PMD.EOL +    "  String bar = \"howdy\";" + PMD.EOL +    "  return bar.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private String baz(String bar) {" + PMD.EOL +    "  return bar.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private String baz;" + PMD.EOL +    " private int getBaz() {" + PMD.EOL +    "  return baz.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private int baz;" + PMD.EOL +    " private int getBaz() {" + PMD.EOL +    "  return baz;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private String getBaz(String foo, StringBuffer buffer) {" + PMD.EOL +    "  return buffer.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private String getBaz() {" + PMD.EOL +    "  String[] foo = {\"hi\"};" + PMD.EOL +    "  return foo[0].toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.CloseConnectionRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CloseConnectionRuleTest extends SimpleAggregatorTst  {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "connection is closed, ok", 0, new CloseConnectionRule()),           new TestDescriptor(TEST2, "connection not closed, should have failed", 1, new CloseConnectionRule()),           new TestDescriptor(TEST3, "java.sql.* not imported, ignore", 0, new CloseConnectionRule()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  Connection c = pool.getConnection();" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   c.close();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "import java.sql.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  Connection c = pool.getConnection();" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "import some.pckg.Connection;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  Connection c = pool.getConnection();" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.UnusedPrivateMethodRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedPrivateMethodRuleTest extends SimpleAggregatorTst {    private UnusedPrivateMethodRule rule;    public void setUp() {        rule = new UnusedPrivateMethodRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "private method called by public method", 0, rule),           new TestDescriptor(TEST2, "simple unused private method", 1, rule),           new TestDescriptor(TEST3, "anonymous inner class calls private method", 0, rule),           new TestDescriptor(TEST4, "two private methods with same name but different parameters", 1, rule),           new TestDescriptor(TEST5, "calling private method after instantiating new copy of myself", 0, rule),           new TestDescriptor(TEST6, "calling private method using 'this' modifier", 0, rule),           new TestDescriptor(TEST7, "simple unused private static method", 1, rule),           new TestDescriptor(TEST8, "readResolve/writeReplace/etc are OK", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  foo();" + PMD.EOL +    " }" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  new Runnable() {" + PMD.EOL +    "   public void run() {" + PMD.EOL +    "    foo();" + PMD.EOL +    "   }" + PMD.EOL +    "  };" + PMD.EOL +    " }" + PMD.EOL +    "" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    " private void foo(String baz) {}" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private void foo(String[] args) {}" + PMD.EOL +    " public static void main(String[] args) {" + PMD.EOL +    "  Foo u = new Foo();" + PMD.EOL +    "  u.foo(args); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  this.foo();" + PMD.EOL +    " }" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " private static void foo() {}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private void readResolve() {}" + PMD.EOL +    " private void writeReplace() {}" + PMD.EOL +    " private void readObject() {}" + PMD.EOL +    " private void writeObject() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DefaultLabelNotLastInSwitchStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "DefaultLabelNotLastInSwitchStmt");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "bad", 1, rule),           new TestDescriptor(TEST3, "ok, no default", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch(x) { " + PMD.EOL +    "  case 1: " + PMD.EOL +    "   break; " + PMD.EOL +    "  default:" + PMD.EOL +    "   break;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch(x) { " + PMD.EOL +    "  case 1: " + PMD.EOL +    "   break; " + PMD.EOL +    "  default:" + PMD.EOL +    "   break;" + PMD.EOL +    "  case 2: " + PMD.EOL +    "   break; " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch(x) { " + PMD.EOL +    "  case 1: " + PMD.EOL +    "   break; " + PMD.EOL +    "  case 2: " + PMD.EOL +    "   break; " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.AvoidReassigningParametersRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidReassigningParametersRuleTest extends SimpleAggregatorTst {    private AvoidReassigningParametersRule rule;    public void setUp() {        rule = new AvoidReassigningParametersRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "reassigned parameter, bad", 1, rule),           new TestDescriptor(TEST2, "one parameter, not reassigned, good", 0, rule),           new TestDescriptor(TEST3, "instance variable and parameter have same name", 1, rule),           new TestDescriptor(TEST4, "qualified instance variable same name as parameter", 0, rule),           new TestDescriptor(TEST5, "qualified name same as parameter", 0, rule),           new TestDescriptor(TEST6, "assignment to parameter public field", 0, rule),           new TestDescriptor(TEST7, "assignment to array parameter slot", 0, rule),       });    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo(int bar) {" + PMD.EOL +    "  bar = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo(int bar) {}" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private int bar;" + PMD.EOL +    " void foo(float bar) {" + PMD.EOL +    "  bar = 2.2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private int bar;" + PMD.EOL +    " void foo(float bar) {" + PMD.EOL +    "  this.bar = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST5 =    "public class Faz {" + PMD.EOL +    " private class Foo {" + PMD.EOL +    "  public String bar;" + PMD.EOL +    " }" + PMD.EOL +    " void foo(String bar) {" + PMD.EOL +    "  Foo f = new Foo();" + PMD.EOL +    "  f.bar = bar;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo(Bar bar) {" + PMD.EOL +    "  bar.buz = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo(Bar[] bar) {" + PMD.EOL +    "  bar[0] = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.CouplingBetweenObjectsRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class CouplingBetweenObjectsRuleTest extends RuleTst {    private static final String TEST1 =    "import java.util.*;" + PMD.EOL +    "public class CouplingBetweenObjects1 {" + PMD.EOL +    " public List foo() {return null;}" + PMD.EOL +    " public ArrayList foo() {return null;}" + PMD.EOL +    " public Vector foo() {return null;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class CouplingBetweenObjects2 {" + PMD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new CouplingBetweenObjectsRule();        rule.addProperty("threshold", "2");    }    public void testSimpleBad() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void testSimpleOK() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryReturnTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "UnnecessaryReturn");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok since method is not void", 0, rule),           new TestDescriptor(TEST3, "ok since return is in sub block", 0, rule),           new TestDescriptor(TEST4, "interface methods don't have return statements", 0, rule),           new TestDescriptor(TEST5, "abstract methods don't have return statements", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int y = 3;" + PMD.EOL +    "  return;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " int bar() {" + PMD.EOL +    "  return 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (false) return;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo {" + PMD.EOL +    " void bar();" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " abstract void bar();" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousHashcodeMethodNameRuleTest  extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "SuspiciousHashcodeMethodName");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "hashcode", 1, rule),           new TestDescriptor(TEST3, "HashCode", 1, rule),           new TestDescriptor(TEST4, "Hashcode", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public int hashCode() {return 42;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public int hashcode() {return 42;}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public int HashCode() {return 42;}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public int Hashcode() {return 42;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ShortMethodNameRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/naming.xml", "ShortMethodNameRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "bad", 1, rule),           new TestDescriptor(TEST3, "2 violations", 2, rule),           new TestDescriptor(TEST4, "2 methods, 1 violation", 1, rule),       });    }    private static final String TEST1 =    "public class ShortMethodName0 {" + PMD.EOL +    "    public int abcd( int i ) {" + PMD.EOL +    "       // Should not violate." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class ShortMethodName1 {" + PMD.EOL +    "    public int a( int i ) {" + PMD.EOL +    "       // Should violate." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class ShortMethodName2 {" + PMD.EOL +    "    public int a( int i ) {" + PMD.EOL +    "       // Should violate" + PMD.EOL +    "    }" + PMD.EOL +    "" + PMD.EOL +    "    public int b( int i ) {" + PMD.EOL +    "       // Should violate" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class ShortMethodName3 {" + PMD.EOL +    "    public int a( int i ) {" + PMD.EOL +    "       // Should violate" + PMD.EOL +    "    }" + PMD.EOL +    "" + PMD.EOL +    "    public int bcde( int i ) {" + PMD.EOL +    "       // Should not violate" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedModifierRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/controversial.xml", "UnusedModifier");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "wasted 'public' in interface method", 1, rule),           new TestDescriptor(TEST2, "class, no problem", 0, rule),           new TestDescriptor(TEST3, "wasted 'abstract' in interface method", 1, rule),           new TestDescriptor(TEST4, "all is well in interface method", 0, rule),           new TestDescriptor(TEST5, "wasted 'public' in interface field", 1, rule),           new TestDescriptor(TEST6, "wasted 'static' in interface field", 1, rule),           new TestDescriptor(TEST7, "wasted 'final' in interface field", 1, rule),           new TestDescriptor(TEST8, "wasted 'public static final' in interface field", 1, rule),           new TestDescriptor(TEST9, "OK in interface field", 0, rule),           new TestDescriptor(TEST10, "wasted 'public' in class nested in interface", 1, rule),           new TestDescriptor(TEST11, "wasted 'static' in class nested in interface", 1, rule),           new TestDescriptor(TEST12, "OK in class nested in interface", 0, rule),           new TestDescriptor(TEST13, "wasted 'public' in interface nested in interface", 1, rule),           new TestDescriptor(TEST14, "wasted 'static' in interface nested in interface", 1, rule),           new TestDescriptor(TEST15, "OK in interface nested in interface", 0, rule),           new TestDescriptor(TEST16, "wasted 'static' in interface nested in class", 1, rule),           new TestDescriptor(TEST17, "OK in interface nested in class", 0, rule),           new TestDescriptor(TEST18, "wasted 'public static final' in interface field inside another interface", 2, rule),           new TestDescriptor(TEST19, "OK in interface field inside another interface", 0, rule),           new TestDescriptor(TEST20, "Don't check methods in nested classes", 0, rule),           new TestDescriptor(TEST21, "Don't check fields in nested classes", 0, rule),       });    }    private static final String TEST1 =    "public interface Foo {" + PMD.EOL +    " public void bar();" + PMD.EOL +    "}";    private static final String TEST2 =    "public abstract class Foo {" + PMD.EOL +    " public abstract void bar();" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " abstract void bar();" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo {" + PMD.EOL +    " void bar();" + PMD.EOL +    "}";    private static final String TEST5 =    "public interface Foo {" + PMD.EOL +    " public int X = 0;" + PMD.EOL +    "}";    private static final String TEST6 =    "public interface Foo {" + PMD.EOL +    " static int X = 0;" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    " final int X = 0;" + PMD.EOL +    "}";    private static final String TEST8 =    "public interface Foo {" + PMD.EOL +    " public static final int X = 0;" + PMD.EOL +    "}";    private static final String TEST9 =    "public interface Foo {" + PMD.EOL +    " int X = 0;" + PMD.EOL +    "}";    private static final String TEST10 =    "public interface Foo {" + PMD.EOL +    " public class Bar {}" + PMD.EOL +    "}";    private static final String TEST11 =    "public interface Foo {" + PMD.EOL +    " static class Bar {}" + PMD.EOL +    "}";    private static final String TEST12 =    "public interface Foo {" + PMD.EOL +    " class Bar {}" + PMD.EOL +    "}";    private static final String TEST13 =    "public interface Foo {" + PMD.EOL +    " public interface Baz {}" + PMD.EOL +    "}";    private static final String TEST14 =    "public interface Foo {" + PMD.EOL +    " static interface Baz {}" + PMD.EOL +    "}";    private static final String TEST15 =    "public interface Foo {" + PMD.EOL +    " interface Baz {}" + PMD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + PMD.EOL +    " public static interface Bar {}" + PMD.EOL +    "}";    private static final String TEST17 =    "public class Foo {" + PMD.EOL +    " public interface Bar {}" + PMD.EOL +    "}";    private static final String TEST18 =    "public interface Foo {" + PMD.EOL +    " public interface Bar {" + PMD.EOL +    "  public static final int X = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST19 =    "interface Foo {" + PMD.EOL +    " interface Bar {" + PMD.EOL +    "  int X = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST20 =    "interface Foo {" + PMD.EOL +    " class Bar {" + PMD.EOL +    "  public void foo() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST21 =    "interface Foo {" + PMD.EOL +    " class Bar {" + PMD.EOL +    "  public int buz;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyCatchBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyCatchBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "no catch with nested catch in finally", 1, rule),           new TestDescriptor(TEST4, "multiple catch blocks", 2, rule),           new TestDescriptor(TEST5, "empty try with finally", 0, rule),           new TestDescriptor(TEST6, "InterruptedException is OK", 0, rule),           new TestDescriptor(TEST7, "CloneNotSupportedException is OK", 0, rule),       });    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (RuntimeException e) {e.getMessage();}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} finally { " + PMD.EOL +    "   try {" + PMD.EOL +    "    int x =2;" + PMD.EOL +    "   } catch (Exception e) {}" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  } catch (Throwable t) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   ;" + PMD.EOL +    "  } finally {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (InterruptedException e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (CloneNotSupportedException e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NonStaticInitializerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "NonStaticInitializer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "static initializers are OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " static {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.IdempotentOperationsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class IdempotentOperationsRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "assignment of a variable (local or field) to itself", 1, new IdempotentOperationsRule()),           new TestDescriptor(TEST2, "assignment of one array element to another", 0, new IdempotentOperationsRule()),           new TestDescriptor(TEST3, "qualified names causing NPE troubleshooting", 0, new IdempotentOperationsRule()),           new TestDescriptor(TEST4, "check for method calls", 0, new IdempotentOperationsRule()),           new TestDescriptor(TEST5, "compound assignments are OK", 0, new IdempotentOperationsRule())       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private void bar() { " + PMD.EOL +    "  x = x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void bar() { " + PMD.EOL +    "  int[] x = {2,3};" + PMD.EOL +    "  x = x[1];" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "  void bar() {this.x = foo;}" + PMD.EOL +    "  void buz() {foo = this.x;}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "  void bar() {x = x();}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "  void bar() {x += x;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.ExcessiveImportsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExcessiveImportsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new ExcessiveImportsRule();        rule.addProperty("minimum", "3");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "import java.util.Vector;" + PMD.EOL +    "import java.util.Vector;" + PMD.EOL +    "import java.util.Vector;" + PMD.EOL +    "import java.util.Vector;" + PMD.EOL +    "public class Foo{}";    private static final String TEST2 =    "import java.util.Vector;" + PMD.EOL +    "public class Foo{}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.ClassNamingConventionsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ClassNamingConventionsRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "class names should not start with lowercase character", 1, new ClassNamingConventionsRule()),           new TestDescriptor(TEST2, "all is well", 0, new ClassNamingConventionsRule()),       });    }    private static final String TEST1 =    "public class foo {};";    private static final String TEST2 =    "public class FooBar {};";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SwitchStmtsShouldHaveDefaultRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "SwitchStmtsShouldHaveDefault");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "simple ok case", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "   default: int j=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryConstructorRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/controversial.xml", "UnnecessaryConstructorRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "private constructor", 0, rule),           new TestDescriptor(TEST3, "constructor with arguments", 0, rule),           new TestDescriptor(TEST4, "constructor with contents", 0, rule),           new TestDescriptor(TEST5, "constructor throws exception", 0, rule),           new TestDescriptor(TEST6, "two constructors", 0, rule),           new TestDescriptor(TEST7, "inner class with unnecessary constructor", 1, rule),           new TestDescriptor(TEST8, "inner and outer both have unnecessary constructors", 2, rule),           new TestDescriptor(TEST9, "inner and outer, both ok", 0, rule),           new TestDescriptor(TEST10, "inner ok, outer bad", 1, rule),           new TestDescriptor(TEST11, "inner ok due to nonpublic constructor", 0, rule),           new TestDescriptor(TEST12, "constructor calls super", 0, rule),           new TestDescriptor(TEST13, "constructor calls super, no args", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private Foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Foo(int x) {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public Foo() {  " + PMD.EOL +    "  int x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public Foo() throws IOException {  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    " }" + PMD.EOL +    " public Foo(String foo) {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    "  public Inner() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    "  public Inner() {}" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    "  private Inner() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    "  public Foo() {super(7);}" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    "  public Foo() {super();}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyWhileStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyWhileStmt");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public void bar() {" + PMD.EOL +    "       while (true == true) {" + PMD.EOL +    "       }" + PMD.EOL +    "       while (true == true) {" + PMD.EOL +    "               String x = \"\";" + PMD.EOL +    "       }" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.VariableNamingConventionsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class VariableNamingConventionsRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "final statics should be all caps", 1, new VariableNamingConventionsRule()),           new TestDescriptor(TEST2, "non-finals shouldn't have underscores", 1, new VariableNamingConventionsRule()),           new TestDescriptor(TEST3, "variables names should start with lowercase character", 1, new VariableNamingConventionsRule()),           new TestDescriptor(TEST4, "all is well", 0, new VariableNamingConventionsRule()),           new TestDescriptor(TEST5, "local finals are ok", 0, new VariableNamingConventionsRule()),           new TestDescriptor(TEST6, "serialVersionUID is OK", 0, new VariableNamingConventionsRule()),           new TestDescriptor(TEST7, "interface fields are tested", 1, new VariableNamingConventionsRule()),           new TestDescriptor(TEST8, "final non-statics need not be all caps", 0, new VariableNamingConventionsRule()),       });    }    public void testPrefixStripping() throws Throwable {        Rule r =  new VariableNamingConventionsRule();        r.addProperty("staticPrefix", "s_");        runTestFromString(TEST9, 0, r);    }    public void testSuffixStripping() throws Throwable {        Rule r =  new VariableNamingConventionsRule();        r.addProperty("staticSuffix", "_s");        runTestFromString(TEST10, 0, r);    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private static final int foo = 2;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private int foo_bar = 2;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private int Ubar = 2;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private int bar = 2;" + PMD.EOL +    " private static final int FOO_BAR = 2;" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "  final int STATE_READING = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    "  static final long serialVersionUID = 423343L;" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    "  int foo = 42;" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    "  final int foo = 42;" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    "  static int s_foo = 42;" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    "  static int foo_s = 42;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnconditionalIfStatementRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "UnconditionalIfStatement");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "if (true)", 1, rule),           new TestDescriptor(TEST2, "if (false)", 1, rule),           new TestDescriptor(TEST3, "no constant folding", 0, rule),           new TestDescriptor(TEST4, "short circuit operator", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (true) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (false) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private static final boolean DEBUG = \"false\";" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (DEBUG) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar(Object x, boolean y) {" + PMD.EOL +    "  if (y == true) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyIfStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyIfStmt");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "one empty, one not empty", 1, rule),       });    }    private static final String TEST1 =    "public class EmptyIfStmtRule {" + PMD.EOL +    "    public EmptyIfStmtRule() {" + PMD.EOL +    "       if (null == null) {" + PMD.EOL +    "       }" + PMD.EOL +    "       if (null != null) {" + PMD.EOL +    "               this.toString();" + PMD.EOL +    "       }" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.UnusedImportsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedImportsRuleTest extends SimpleAggregatorTst {    private UnusedImportsRule rule;    public void setUp() {        rule = new UnusedImportsRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple unused single type import", 1, rule),           new TestDescriptor(TEST2, "one used single type import", 0, rule),           new TestDescriptor(TEST3, "2 unused single-type imports", 2, rule),           new TestDescriptor(TEST4, "1 used single type import", 0, rule),           new TestDescriptor(TEST5, "1 import stmt, used only in throws clause", 0, rule)       });    }    private static final String TEST1 =    "import java.io.File;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import java.io.File;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " private File file;" + PMD.EOL +    "}";    private static final String TEST3 =    "import java.io.File;" + PMD.EOL +    "import java.util.List;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}";    private static final String TEST4 =    "import java.security.AccessController;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  AccessController.doPrivileged(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "import java.rmi.RemoteException;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo() throws RemoteException {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.MethodNamingConventionsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MethodNamingConventionsRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "method names should start with lowercase character", 1, new MethodNamingConventionsRule()),           new TestDescriptor(TEST2, "method names should not contain underscores", 1, new MethodNamingConventionsRule()),           new TestDescriptor(TEST3, "all is well", 0, new MethodNamingConventionsRule()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void Bar() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar_foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class BadComparisonRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "BadComparisonRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "comparison to Double.NaN", 1, rule),           new TestDescriptor(TEST2, "ok equality comparison", 0, rule),           new TestDescriptor(TEST3, "comparison to Float.NaN", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " boolean x = (y == Double.NaN);" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " boolean x = (y == z);" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " boolean x = (y == Float.NaN);" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.SuspiciousOctalEscapeRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousOctalEscapeRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok use of octal", 0, new SuspiciousOctalEscapeRule()),           new TestDescriptor(TEST2, "should be flagged", 1, new SuspiciousOctalEscapeRule()),       });    }   private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = \128;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  System.out.println(\"foo = \\128\");" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimplifyBooleanExpressionsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "SimplifyBooleanExpressions");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "in field assignment", 1, rule),           new TestDescriptor(TEST2, "in method body", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),           new TestDescriptor(TEST4, "two cases in an && expression", 2, rule),           new TestDescriptor(TEST5, "simple use of BooleanLiteral, should not be flagged", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private boolean foo = (isFoo() == true);" + PMD.EOL +    " boolean isFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  boolean bar = (new String().length() >2) == false;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " boolean bar = true;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (getFoo() == false && isBar() == true) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (true) {}" + PMD.EOL +    "  if (false) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyFinallyBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptyFinallyBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "", 1, rule),           new TestDescriptor(TEST2, "", 1, rule),           new TestDescriptor(TEST3, "", 0, rule),           new TestDescriptor(TEST4, "multiple catch blocks with finally", 1, rule),       });    }    private static final String TEST1 =    "public class EmptyFinallyBlock1 {" + PMD.EOL +    "    public void foo() {" + PMD.EOL +    "       try {" + PMD.EOL +    "       } catch (Exception e) {} finally {}" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class EmptyFinallyBlock2 {" + PMD.EOL +    "    public void foo() {" + PMD.EOL +    "       try {" + PMD.EOL +    "       } finally {}" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class EmptyFinallyBlock3 {" + PMD.EOL +    "    public void foo() {" + PMD.EOL +    "       try {" + PMD.EOL +    "       } finally {int x =2;}" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class EmptyFinallyBlock4 {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (IOException e ){" + PMD.EOL +    "  } catch (Exception e ) {" + PMD.EOL +    "  } catch (Throwable t ) {" + PMD.EOL +    "  } finally{" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class AvoidDeeplyNestedIfStmtsRuleTest extends RuleTst {    public static final String TEST1 =    "public class AvoidDeeplyNestedIfStmtsRule1 {" + PMD.EOL +    " public void bar() { " + PMD.EOL +    "  int x=2; " + PMD.EOL +    "  int y=3; " + PMD.EOL +    "  int z=4; " + PMD.EOL +    "  if (x>y) { " + PMD.EOL +    "   if (y>z) { " + PMD.EOL +    "    if (z==x) { " + PMD.EOL +    "     // this is officially out of control now " + PMD.EOL +    "    } " + PMD.EOL +    "   } " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class AvoidDeeplyNestedIfStmtsRule2 {" + PMD.EOL +    " public void bar() { " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "  } else if (true) {" + PMD.EOL +    "  } else if (true) {" + PMD.EOL +    "  } else {" + PMD.EOL +    "    // this ain't good code, but it shouldn't trigger this rule" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new AvoidDeeplyNestedIfStmtsRule();        rule.addProperty("problemDepth", "3");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptySwitchStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "EmptySwitchStatements");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class EmptySwitchStmt1 {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class EmptySwitchStmt2 {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=4;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.ImportFromSamePackageRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ImportFromSamePackageRuleTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, new ImportFromSamePackageRule()),           new TestDescriptor(TEST2, "class in default package importing from sub package", 0, new ImportFromSamePackageRule()),           new TestDescriptor(TEST3, "class in default package importing from other package", 0, new ImportFromSamePackageRule()),           new TestDescriptor(TEST4, "class not in default package importing from default package", 0, new ImportFromSamePackageRule()),           new TestDescriptor(TEST5, "class in default package importing from default package", 1, new ImportFromSamePackageRule()),           new TestDescriptor(TEST6, "importing from some package", 0, new ImportFromSamePackageRule()),       });    }    private static final String TEST1 =    "package foo;" + PMD.EOL +    "import foo.Bar;" + PMD.EOL +    "public class Baz{}";    private static final String TEST2 =    "package foo;" + PMD.EOL +    "import foo.buz.Bar;" + PMD.EOL +    "public class Baz{}";    private static final String TEST3 =    "import java.util.*;" + PMD.EOL +    "public class Baz{}";    private static final String TEST4 =    "package bar;" + PMD.EOL +    "import Foo;" + PMD.EOL +    "public class Baz{}";    private static final String TEST5 =    "import Foo;" + PMD.EOL +    "public class Baz{}";    private static final String TEST6 =    "package foo.bar;" + PMD.EOL +    "import foo.bar.baz.*;" + PMD.EOL +    "public class Baz{}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DontImportJavaLangRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/imports.xml", "DontImportJavaLang");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "import java.lang.String", 1, rule),           new TestDescriptor(TEST2, "import java.lang.*", 1, rule),           new TestDescriptor(TEST3, "import java.lang.ref.* and reflect.*", 0, rule),       });    }    private static final String TEST1 =    "import java.lang.String;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import java.lang.*;" + PMD.EOL +    "public class Foo {}";    private static final String TEST3 =    "import java.lang.ref.*;" + PMD.EOL +    "import java.lang.reflect.*;" + PMD.EOL +    "public class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.rules.CyclomaticComplexityRule;import test.net.sourceforge.pmd.testframework.RuleTst;import java.util.Iterator;public class CyclomaticComplexityRuleTest extends RuleTst {    private CyclomaticComplexityRule rule = new CyclomaticComplexityRule();    public void setUp() {        rule.setMessage("The {0} ''{1}'' has a Cyclomatic Complexity of {2}.");    }    public void testOneMethod() throws Throwable {        rule.addProperty("reportLevel", "1");        Report report = new Report();        runTestFromString(TEST1, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);    }    public void testNastyComplicatedMethod() throws Throwable {        rule.addProperty("reportLevel", "10");        Report report = new Report();        runTestFromString(TEST2, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 12") != -1);    }    public void testConstructor() throws Throwable {        rule.addProperty("reportLevel", "1");        Report report = new Report();        runTestFromString(TEST3, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);    }    public void testLessComplicatedThanReportLevel() throws Throwable {        rule.addProperty("reportLevel", "10");        Report report = new Report();        runTestFromString(TEST1, rule, report);        assertEquals(0, report.size());    }    private static final String TEST1 =    "public class CyclomaticComplexity1 {" + PMD.EOL +    " public void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class CyclomaticComplexity2 {" + PMD.EOL +    " public void example() {" + PMD.EOL +    "  int x = 0;" + PMD.EOL +    "  int a = 0;" + PMD.EOL +    "  int b = 0;" + PMD.EOL +    "  int c = 0;" + PMD.EOL +    "  int d = 0;" + PMD.EOL +    "  int a1 = 0;" + PMD.EOL +    "  int a2 = 0;" + PMD.EOL +    "  int b1 = 0;" + PMD.EOL +    "  int b2 = 0;" + PMD.EOL +    "  int z = 0;" + PMD.EOL +    "  int h = 0;" + PMD.EOL +    "  int e = 0;" + PMD.EOL +    "  int f = 0;" + PMD.EOL +    "" + PMD.EOL +    "  if (a == b) {" + PMD.EOL +    "   if (a1 == b1) {" + PMD.EOL +    "     x=2;" + PMD.EOL +    "   } else if (a2 == b2) {" + PMD.EOL +    "     x=2;" + PMD.EOL +    "   }" + PMD.EOL +    "            else" + PMD.EOL +    "            {" + PMD.EOL +    "                x=2;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "       else if (c == d)" + PMD.EOL +    "        {" + PMD.EOL +    "           while (c == d)" + PMD.EOL +    "            {" + PMD.EOL +    "                x=2;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "       else if (e == f)" + PMD.EOL +    "        {" + PMD.EOL +    "           for (int n = 0; n < h; n++)" + PMD.EOL +    "            {" + PMD.EOL +    "                x=2;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "        else" + PMD.EOL +    "        {" + PMD.EOL +    "            switch (z)" + PMD.EOL +    "            {" + PMD.EOL +    "               case 1:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "" + PMD.EOL +    "              case 2:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "" + PMD.EOL +    "              case 3:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "" + PMD.EOL +    "              default:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class CyclomaticComplexity3 {" + PMD.EOL +    " public CyclomaticComplexity3() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AtLeastOneConstructorRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/controversial.xml", "AtLeastOneConstructor");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0,rule),           new TestDescriptor(TEST2, "simple failure case", 1, rule),           new TestDescriptor(TEST3, "inner bad, outer ok", 1, rule),           new TestDescriptor(TEST4, "inner ok, outer bad", 1, rule),           new TestDescriptor(TEST5, "inner and outer both bad", 2, rule),           new TestDescriptor(TEST6, "inner and outer both ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public class Bar {}" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public class Bar { " + PMD.EOL +    "  public Bar() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public class Bar {} " + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public class Bar { " + PMD.EOL +    "  public Bar() {}" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyFinalizerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/finalizers.xml", "EmptyFinalizer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void finalize() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void finalize() { int x = 2;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.BeanMembersShouldSerializeRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class BeanMembersShouldSerializeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new BeanMembersShouldSerializeRule();        rule.setMessage("Don't {0} !");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "private String, no accessor", 1, rule),           new TestDescriptor(TEST2, "private static String", 0, rule),           new TestDescriptor(TEST3, "private transient String", 0, rule),           new TestDescriptor(TEST4, "getter, no setter", 1, rule),           new TestDescriptor(TEST5, "setter, no getter", 1, rule),           new TestDescriptor(TEST6, "both accessors, yay!", 0, rule),           new TestDescriptor(TEST7, "setFoo and isFoo is OK for booleans", 0, rule),           new TestDescriptor(TEST8, "setFoo and isFoo is not OK for Strings", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private static String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private transient String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    " public String getFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    " public void setFoo(Foo foo) {this.foo = foo;}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    " public void setFoo(Foo foo) {this.foo = foo;}" + PMD.EOL +    " public String getFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " private boolean foo;" + PMD.EOL +    " public void setFoo(boolean foo) {this.foo = foo;}" + PMD.EOL +    " public boolean isFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " public void setFoo(String foo) {this.foo = foo;}" + PMD.EOL +    " public String isFoo() {return foo;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.AvoidDuplicateLiteralsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;import java.util.Set;public class AvoidDuplicateLiteralsRuleTest extends SimpleAggregatorTst {    private AvoidDuplicateLiteralsRule rule;    public void setUp() {        rule = new AvoidDuplicateLiteralsRule();        rule.setMessage("avoid ''{0}'' and ''{1}'' and ''{2}''");        rule.addProperty("threshold", "2");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "duplicate literals in argument list", 1, rule),           new TestDescriptor(TEST2, "literal int argument, ok for now", 0, rule),           new TestDescriptor(TEST3, "duplicate literals in field decl", 1, rule),       });    }    public void testStringParserEmptyString() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("");        assertTrue(res.isEmpty());    }    public void testStringParserSimple() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("a,b,c");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("c"));    }    public void testStringParserEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("a,b,\\,");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains(","));    }    public void testStringParserEscapedEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("a,b,\\\\");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("\\"));    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "    buz(2);" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " String[] FOO = {\"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\"};" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class OptimizableToArrayCallRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "OptimizableToArrayCallRule");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "Array dimensioner uses method call, ok", 0, rule),           new TestDescriptor(TEST3, "Array dimensioner uses variable, ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " {x.toArray(new Foo[0]);}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " {x.toArray(new Foo[x.size()]);}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " {x.toArray(new Foo[y]);}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NonCaseLabelInSwitchStatementRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/design.xml", "NonCaseLabelInSwitchStatement");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "label inside switch", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "    break;" + PMD.EOL +    "   somelabel: " + PMD.EOL +    "    break;" + PMD.EOL +    "   default: " + PMD.EOL +    "    int j=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "    break;" + PMD.EOL +    "   default: " + PMD.EOL +    "    int j=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.AccessorClassGenerationRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class AccessorClassGenerationRuleTest extends RuleTst {    public void testInnerClassHasPrivateConstructor() throws Throwable {        runTestFromString(TEST1, 1, new AccessorClassGenerationRule());    }    public void testInnerClassHasPublicConstructor() throws Throwable {        runTestFromString(TEST2, 0, new AccessorClassGenerationRule());    }    public void testOuterClassHasPrivateConstructor() throws Throwable {        runTestFromString(TEST3, 1, new AccessorClassGenerationRule());    }    public void testFinalInnerClass() throws Throwable {        runTestFromString(TEST4, 0, new AccessorClassGenerationRule());    }    private static final String TEST1 =    "public class Foo1 {" + PMD.EOL +    " public class InnerClass {" + PMD.EOL +    "   private InnerClass(){" + PMD.EOL +    "   }" + PMD.EOL +    " }" + PMD.EOL +    " void method(){" + PMD.EOL +    "   new InnerClass();//Causes generation of accessor" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo2 {" + PMD.EOL +    " public class InnerClass {" + PMD.EOL +    "   public InnerClass(){" + PMD.EOL +    "   }" + PMD.EOL +    " }" + PMD.EOL +    " void method(){" + PMD.EOL +    "   new InnerClass(); //OK, due to public constructor" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo3 {" + PMD.EOL +    "    public class InnerClass {" + PMD.EOL +    "      void method(){" + PMD.EOL +    "        new Foo3();//Causes generation of accessor" + PMD.EOL +    "      }" + PMD.EOL +    "    }" + PMD.EOL +    "    private Foo3() {" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void method() {" + PMD.EOL +    "   final class Inner {}; " + PMD.EOL +    "   Inner i = new Inner();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPPLanguage;import net.sourceforge.pmd.cpd.JavaLanguage;import net.sourceforge.pmd.cpd.LanguageFactory;import net.sourceforge.pmd.cpd.PHPLanguage;public class LanguageFactoryTest extends TestCase {    public void testSimple() {        LanguageFactory f = new LanguageFactory();        assertTrue(f.createLanguage(LanguageFactory.JAVA_KEY) instanceof JavaLanguage);        assertTrue(f.createLanguage(LanguageFactory.CPP_KEY) instanceof CPPLanguage);        assertTrue(f.createLanguage(LanguageFactory.PHP_KEY) instanceof PHPLanguage);        try {            f.createLanguage("fiddlesticks");            throw new RuntimeException("Should have thrown an exception!");        } catch (RuntimeException e) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.TokenEntry;import java.util.Iterator;public class MatchTest extends TestCase  {    public void testSimple() {        TokenEntry mark1 = new TokenEntry("public", "/var/Foo.java", 1);TokenEntry mark2 = new TokenEntry("class", "/var/Foo.java", 1);        Match match = new Match(1, mark1, mark2);        match.setSourceCodeSlice("public class Foo {}");        assertEquals("public class Foo {}", match.getSourceCodeSlice());        match.setLineCount(10);        assertEquals(10, match.getLineCount());        assertEquals(1, match.getTokenCount());        Iterator i = match.iterator();        assertEquals(mark1, i.next());        assertEquals(mark2, i.next());        assertFalse(i.hasNext());    }    public void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1), new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;import java.io.StringReader;public class SourceCodeTest extends TestCase {    public void testSimple() throws Throwable {        String code = MatchAlgorithmTest.getSampleCode();        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("Foo.java");        assertEquals("Foo.java", sourceCode.getFileName());sourceCode.readSource(new StringReader(code));        tokenizer.tokenize(sourceCode, new Tokens());        assertEquals(MatchAlgorithmTest.LINE_1, sourceCode.getSlice(1,1));        assertEquals(MatchAlgorithmTest.LINE_2, sourceCode.getSlice(2,2));        assertEquals(MatchAlgorithmTest.LINE_1 + PMD.EOL + MatchAlgorithmTest.LINE_2, sourceCode.getSlice(1,2));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;import java.io.StringReader;public class JavaTokensTokenizerTest extends TestCase {    public void test1() throws Throwable {        Tokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "public class Foo {}";        Tokens tokens = new Tokens();        sourceCode.readSource(new StringReader(data));        tokenizer.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());        assertEquals("public class Foo {}", sourceCode.getSlice(1, 1));    }    public void test2() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "public class Foo {" + PMD.EOL + "public void bar() {}" + PMD.EOL + "public void buz() {}" + PMD.EOL + "}";        Tokens tokens = new Tokens();sourceCode.readSource(new StringReader(data));        t.tokenize(sourceCode, tokens);        assertEquals("public class Foo {" + PMD.EOL + "public void bar() {}", sourceCode.getSlice(1,2));    }    public void testDiscardSemicolons() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "public class Foo {private int x;}";        Tokens tokens = new Tokens();sourceCode.readSource(new StringReader(data));        t.tokenize(sourceCode, tokens);        assertEquals(9, tokens.size());    }    public void testDiscardImports() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "import java.io.File;" + PMD.EOL + "public class Foo {}";        Tokens tokens = new Tokens();sourceCode.readSource(new StringReader(data));        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    public void testDiscardPkgStmts() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("1");        String data = "package foo.bar.baz;" + PMD.EOL + "public class Foo {}";        Tokens tokens = new Tokens();sourceCode.readSource(new StringReader(data));        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.FileReporter;import net.sourceforge.pmd.cpd.ReportException;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;/** * @author  Philippe T'Seyen */public class FileReporterTest extends TestCase{  public void testCreation() {    try {      new FileReporter(null);      fail("expected NullPointerException");    } catch (NullPointerException npe) {    }  }  public void testEmptyReport() throws ReportException {    File reportFile = new File("report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    fileReporter.report("");    assertTrue(reportFile.exists());    assertEquals(0, reportFile.length());    assertTrue(reportFile.delete());  }  public void testReport() throws ReportException, IOException {    String testString = "first line\nsecond line";    File reportFile = new File("report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    fileReporter.report(testString);    assertEquals(testString, readFile(reportFile));    assertTrue(reportFile.delete());  }  public void testInvalidFile() {    File reportFile = new File("/invalid_folder/report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    try {      fileReporter.report("");      fail("expected ReportException");    } catch (ReportException re) {    }  }  private String readFile(File file) throws IOException {    BufferedReader reader = null;    try {      reader = new BufferedReader(new FileReader(file));      StringBuffer buffer = new StringBuffer();      String line = reader.readLine();      while (line != null) {        buffer.append(line);        line = reader.readLine();        if (line != null) {          buffer.append("\n");        }      }      return buffer.toString();    } finally {      if (reader != null) reader.close();    }  }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.MatchAlgorithm;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokens;import java.io.StringReader;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class MatchAlgorithmTest extends TestCase {    public static final String LINE_1 = "public class Foo { ";    public static final String LINE_2 = " public void bar() {";    public static final String LINE_3 = "  System.out.println(\"hello\");";    public static final String LINE_4 = "  System.out.println(\"hello\");";    public static final String LINE_5 = " }";    public static final String LINE_6 = "}";    public static String getSampleCode() {        return            LINE_1 + PMD.EOL +            LINE_2 + PMD.EOL +            LINE_3 + PMD.EOL +            LINE_4 + PMD.EOL +            LINE_5 + PMD.EOL +            LINE_6;    }    public void testSimple() throws Throwable {        String code = getSampleCode();        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode("Foo.java");        Tokens tokens = new Tokens();        TokenEntry.clearImages();        sourceCode.readSource(new StringReader(code));        tokenizer.tokenize(sourceCode, tokens);        assertEquals(29, tokens.size());        Map codeMap = new HashMap();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator matches = matchAlgorithm.matches();        Match match = (Match)matches.next();        assertFalse(matches.hasNext());        Iterator marks = match.iterator();        TokenEntry mark1 = (TokenEntry)marks.next();        TokenEntry mark2 = (TokenEntry)marks.next();        assertTrue(!marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals(4, mark2.getBeginLine());        assertTrue("Foo.java" == mark1.getTokenSrcID() && "Foo.java" == mark2.getTokenSrcID());        assertEquals(LINE_3, match.getSourceCodeSlice());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenEntry;public class TokenEntryTest extends TestCase {    public void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.Renderer;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.XMLRenderer;import java.util.ArrayList;import java.util.List;/** * @author  Philippe T'Seyen */public class XMLRendererTest extends TestCase{  public void testRender_NoMatches()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd></pmd-cpd>", report);  }  public void testRender_Match()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    Match match = new Match(75, new TokenEntry("public", "/var/Foo.java", 48), new TokenEntry("stuff", "/var/Foo.java", 73));    match.setLineCount(6);    match.setSourceCodeSlice("code fragment");    list.add(match);    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd><duplication lines=\"6\" tokens=\"75\"><file line=\"48\" path=\"/var/Foo.java\"/><file line=\"73\" path=\"/var/Foo.java\"/><codefragment><![CDATA[" + PMD.EOL + "code fragment" + PMD.EOL + "]]></codefragment></duplication></pmd-cpd>", report);  }  public void testRender_MultipleMatch()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    Match match1 = new Match(75, new TokenEntry("public", "/var/Foo.java", 48), new TokenEntry("void", "/var/Foo.java", 73));    match1.setLineCount(6);    match1.setSourceCodeSlice("code fragment");    Match match2 = new Match(76, new TokenEntry("void", "/var/Foo2.java", 49), new TokenEntry("stuff", "/var/Foo2.java", 74));    match2.setLineCount(7);    match2.setSourceCodeSlice("code fragment 2");    list.add(match1);    list.add(match2);    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd><duplication lines=\"6\" tokens=\"75\"><file line=\"48\" path=\"/var/Foo.java\"/><file line=\"73\" path=\"/var/Foo.java\"/><codefragment><![CDATA[" + PMD.EOL + "code fragment" + PMD.EOL + "]]></codefragment></duplication><duplication lines=\"7\" tokens=\"76\"><file line=\"49\" path=\"/var/Foo2.java\"/><file line=\"74\" path=\"/var/Foo2.java\"/><codefragment><![CDATA[" + PMD.EOL + "code fragment 2" + PMD.EOL + "]]></codefragment></duplication></pmd-cpd>", report);  }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.ant.PMDTask;import org.apache.tools.ant.BuildException;public class PMDTaskTest extends TestCase {    public void testNoFormattersValidation() {        PMDTask task = new PMDTask();        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no Formatters");        } catch (BuildException be) {            // cool        }    }    public void testFormatterWithNoToFileAttribute() {        PMDTask task = new PMDTask();        task.addFormatter(new Formatter());        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - a Formatter was missing a toFile attribute");        } catch (BuildException be) {            // cool        }    }    public void testNoRuleSets() {        PMDTask task = new PMDTask();        task.setPrintToConsole(true);        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no rulesets");        } catch (BuildException be) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;import org.apache.tools.ant.BuildException;import java.io.File;public class FormatterTest extends TestCase {    public void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.getRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.getRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.getRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.getRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            throw new RuntimeException("Should have failed!");        } catch (BuildException be) {            // cool        }    }    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isToFileNull());        f.setToFile(new File("foo"));        assertFalse("Formatter toFile should not be null!", f.isToFileNull());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.jaxen.Attribute;import net.sourceforge.pmd.jaxen.AttributeAxisIterator;import java.util.HashSet;import java.util.Set;public class AttributeAxisIteratorTest extends TestCase {    public void testBasicAttributes() {        Set names = new HashSet();        names.add("BeginLine");        names.add("EndLine");        names.add("BeginColumn");        names.add("EndColumn");        names.add("Discardable");        SimpleNode n = new SimpleNode(0);        n.testingOnly__setBeginColumn(1);        n.testingOnly__setBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        try {            Attribute a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));            a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));            a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));            a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));        } catch (UnsupportedOperationException e) {            // cool        }    }    public void testRemove() {        SimpleNode n = new SimpleNode(0);        n.testingOnly__setBeginColumn(1);        n.testingOnly__setBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        try {            iter.remove();            fail("Should have thrown an exception!");        } catch (UnsupportedOperationException e) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.jaxen.Attribute;public class AttributeTest extends TestCase {    public void testConstructor() {        Attribute a = new Attribute(null, "name", "value");        assertEquals("name", a.getName());        assertEquals("value", a.getValue());        assertNull(a.getParent());    }    public void testAccessors() {        Attribute a = new Attribute(null, null, null);        a.setName("name");        a.setValue("value");        a.setParent(null);        assertEquals("name", a.getName());        assertEquals("value", a.getValue());        assertNull(a.getParent());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.jaxen;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTStatement;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.jaxen.DocumentNavigator;import org.jaxen.BaseXPath;import org.jaxen.JaxenException;import org.jaxen.UnsupportedAxisException;import test.net.sourceforge.pmd.testframework.RuleTst;import java.util.Iterator;import java.util.List;public class DocumentNavigatorTest extends RuleTst {       private TestRule rule;    private class TestRule extends AbstractRule {        private Node compilationUnit;        private Node importDeclaration;        private Node statement;        private Node primaryPrefix;        private Node primaryExpression;        /**         * @see net.sourceforge.pmd.ast.JavaParserVisitor#visit(ASTCompilationUnit, Object)         */        public Object visit(ASTCompilationUnit node, Object data) {            this.compilationUnit = node;            return super.visit(node, data);        }        public Object visit(ASTImportDeclaration node, Object data) {            this.importDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTStatement node, Object data) {            this.statement = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryPrefix node, Object data) {            this.primaryPrefix = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryExpression node, Object data) {            this.primaryExpression = node;            return super.visit(node, data);        }    }    public void setUp() throws Exception {        try{            rule = new TestRule();            runTestFromString(TEST, rule, new Report());        } catch (Throwable xx) {            xx.printStackTrace();            fail();        }    }        public void testChildAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getChildAxisIterator(rule.compilationUnit);        assertSame(rule.compilationUnit.jjtGetChild(0), iter.next());        assertSame(rule.compilationUnit.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testParentAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getParentAxisIterator(rule.importDeclaration);        assertSame(rule.importDeclaration.jjtGetParent(), iter.next());        assertFalse(iter.hasNext());    }        public void testParentAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getParentAxisIterator(rule.compilationUnit);        assertFalse(iter.hasNext());    }    public void testDescendantAxisIterator() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();Iterator iter = nav.getDescendantAxisIterator(rule.statement);Node statementExpression = rule.statement.jjtGetChild(0);assertSame(statementExpression, iter.next());Node primaryExpression = statementExpression.jjtGetChild(0);        assertSame(primaryExpression, iter.next());        Node primaryPrefix = primaryExpression.jjtGetChild(0);        assertSame(primaryPrefix, iter.next());        Node primarySuffix = primaryExpression.jjtGetChild(1);        assertSame(primarySuffix, iter.next());        Node name = primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        Node arguments = primarySuffix.jjtGetChild(0);        assertSame(arguments, iter.next());        assertFalse(iter.hasNext());    }        public void testDescendantAxisIterator2() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getDescendantAxisIterator(rule.primaryPrefix);        Node name = rule.primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        assertFalse(iter.hasNext());    }        public void testFollowingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertSame(rule.primaryExpression.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testFollowingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertSame(rule.primaryExpression.jjtGetChild(0), iter.next());        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertFalse(iter.hasNext());    }    public void testXPath() throws JaxenException {BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());List matches = xPath.selectNodes(rule.statement);assertEquals(6, matches.size());    }    public void testXPath2() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.importDeclaration);        assertEquals(1, matches.size());            }      public static final String TEST =      "import java.io.*;" + PMD.EOL +      "public class Foo {" + PMD.EOL +      " public Foo() {" + PMD.EOL +      "  try {" + PMD.EOL +      "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL +      "  } catch (Exception e) {}" + PMD.EOL +      "  try {" + PMD.EOL +      "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL +      "  } catch (Exception e) {" + PMD.EOL +      "   e.printStackTrace();" + PMD.EOL +      "   // this shouldn't show up on the report" + PMD.EOL +      "  }" + PMD.EOL +      " }" + PMD.EOL +      "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.renderers;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.TextPadRenderer;import test.net.sourceforge.pmd.testframework.MockRule;public class TextPadRendererTest extends TestCase  {    public void testNullPassedIn() {        try  {            (new TextPadRenderer()).render(null);            fail("Providing a render(null) should throw an npx");        }  catch(NullPointerException npx)  {            // cool        }    }    public void testRenderer()  {        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("Foo.java");        Report rep = new Report();        rep.addRuleViolation(new RuleViolation(new MockRule("DontImportJavaLang", "Avoid importing anything from the package 'java.lang'", "Avoid importing anything from the package 'java.lang'", "rulesetname"), 3,ctx, "package", "class"));        String actual = (new TextPadRenderer()).render(rep);        String expected = PMD.EOL + "Foo.java(3,  DontImportJavaLang):  Avoid importing anything from the package 'java.lang'" ;        assertEquals(expected, actual);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.renderers;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.XMLRenderer;import test.net.sourceforge.pmd.testframework.MockRule;import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class XMLRendererTest extends TestCase {    private MockRule RULE1 = new MockRule("RULE1", "RULE1", "msg", "rulesetname");    private MockRule RULE2 = new MockRule("RULE2", "RULE2", "msg", "rulesetname");    private RuleContext ctx = new RuleContext();    public XMLRendererTest(String name) {        super(name);    }    public void testEmptyReport() throws Throwable {        XMLRenderer renderer = new XMLRenderer();        String rendered = renderer.render(new Report());        assertTrue("Expected empty PMD tag.", rendered.indexOf("violation") < 0);    }    public void testErrorReport() throws Throwable {        Report r = new Report();        r.addError(new Report.ProcessingError("test_msg", "test_filename"));        XMLRenderer renderer = new XMLRenderer();        assertTrue(renderer.render(r).indexOf("msg=\"test_msg\"/>") != -1);    }    public void testSingleReport() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testSingleReport");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        XMLRenderer renderer = new XMLRenderer();        String rendered = renderer.render(report);        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testSingleReport\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        verifyPositions(rendered, expectedStrings);    }    public void testDoubleReport() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testDoubleReport");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        report.addRuleViolation(new RuleViolation(RULE2, 2, "Rule2", ctx));        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testDoubleReport\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("<violation line=\"2\" rule=\"RULE2\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule2");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        XMLRenderer renderer = new XMLRenderer();        verifyPositions(renderer.render(report), expectedStrings);    }    public void testTwoFiles() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_1");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testTwoFiles_0\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("<file name=\"testTwoFiles_1\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        XMLRenderer renderer = new XMLRenderer();        verifyPositions(renderer.render(report), expectedStrings);    }    public void testUnorderedFiles() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_1");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE2, 2, "Rule2", ctx));        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testTwoFiles_0\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("<violation line=\"2\" rule=\"RULE2\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule2");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("<file name=\"testTwoFiles_1\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("Rule1");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        XMLRenderer renderer = new XMLRenderer();        verifyPositions(renderer.render(report), expectedStrings);    }    /**     * Verify correct escaping in generated XML.     */    public void testEscaping() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testEscaping: Less than: < Greater than: > Ampersand: & Quote: \" 'e' acute: \u00E9");        report.addRuleViolation(new RuleViolation(RULE1, 1, "[RULE] Less than: < Greater than: > Ampersand: & Quote: \" 'e' acute: \u00E9", ctx));        // <?xml version="1.0"?>        // <pmd>        //   <file name="testEscaping: Less than: &lt; Greater than: &gt; Ampersand: &amp; Quote: &quot; 'e' acute: &#233;">        //     <violation line="1" rule="RULE1">        // [RULE] Less than: &lt; Greater than: &gt; Ampersand: &amp; Quote: &quot; 'e' acute: &#233;        //     </violation>        //   </file>        // </pmd>        List expectedStrings = new ArrayList();        expectedStrings.add("<pmd>");        expectedStrings.add("<file name=\"testEscaping: Less than: ");        expectedStrings.add("&lt;");        expectedStrings.add(" Greater than: ");        expectedStrings.add("&gt;");        expectedStrings.add(" Ampersand: ");        expectedStrings.add("&amp;");        expectedStrings.add(" Quote: ");        expectedStrings.add("&quot;");        expectedStrings.add(" 'e' acute: ");        expectedStrings.add("&#233;");        expectedStrings.add("\">");        expectedStrings.add("<violation line=\"1\" rule=\"RULE1\" ruleset=\"rulesetname\">");        expectedStrings.add("[RULE] Less than: ");        expectedStrings.add("&lt;");        expectedStrings.add(" Greater than: ");        expectedStrings.add("&gt;");        expectedStrings.add(" Ampersand: ");        expectedStrings.add("&amp;");        expectedStrings.add(" Quote: ");        expectedStrings.add("&quot;");        expectedStrings.add(" 'e' acute: ");        expectedStrings.add("&#233;");        expectedStrings.add("</violation>");        expectedStrings.add("</file>");        expectedStrings.add("</pmd>");        XMLRenderer renderer = new XMLRenderer();        verifyPositions(renderer.render(report), expectedStrings);    }    public void verifyPositions(String rendered, List strings) {        Iterator i = strings.iterator();        int currPos = 0;        String lastString = "<?xml version=\"1.0\"?>";        while (i.hasNext()) {            String str = (String) i.next();            int strPos = rendered.indexOf(str, currPos);            assertTrue("Expecting: " + str + " after " + lastString, strPos > currPos);            currPos = strPos;            lastString = str;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.symboltable.TypeSet;import java.io.File;import java.util.HashSet;import java.util.Set;public class TypeSetTest extends TestCase {    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    public void testFindClassImplicitImport() throws Throwable {        TypeSet t = new TypeSet();        Class clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    public void testFindClassSamePackage() throws Throwable {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd.");        Class clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    public void testFindClassExplicitImport() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassImportOnDemand() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassPrimitive() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    public void testFindClassVoid() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    public void testFindFullyQualified() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    public void testPrimitiveTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    public void testVoidTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    public void testExplicitImportResolver() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(imports);        assertEquals(File.class, r.resolve("File"));    }    public void testImplicitImportResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        assertEquals(String.class, r.resolve("String"));    }    public void testImplicitImportResolverPassFail() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        try {            r.resolve("PMD");            throw new RuntimeException("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }    }    public void testCurrentPackageResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver("net.sourceforge.pmd.");        assertEquals(PMD.class, r.resolve("PMD"));    }    public void testImportOnDemandResolverPass() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    public void testImportOnDemandResolverFail() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        try {            r.resolve("foo");            throw new RuntimeException("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }        try {            r.resolve("String");            throw new RuntimeException("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import net.sourceforge.pmd.symboltable.VariableUsageFinderFunction;import net.sourceforge.pmd.util.Applier;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class VariableUsageFinderFunctionTest extends TestCase {    public void testLookingForUsed() {        ASTVariableDeclaratorId variableDeclarationIdNode = new ASTVariableDeclaratorId(1);        variableDeclarationIdNode.setImage("x");        NameDeclaration nameDeclaration = new VariableNameDeclaration(variableDeclarationIdNode);        List nameOccurrences = new ArrayList();        nameOccurrences.add(new NameOccurrence(new SimpleNode(2), "x"));        Map declarations = new HashMap();        declarations.put(nameDeclaration, nameOccurrences);        List vars = new ArrayList();        vars.add(nameDeclaration);        VariableUsageFinderFunction f = new VariableUsageFinderFunction(declarations);        Applier.apply(f, vars.iterator());        Map p = f.getUsed();        System.out.println("p = " + p.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.Scope;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;public class VariableNameDeclarationTest extends STBBaseTst  {    public void testConstructor() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        Scope s = ((ASTVariableDeclaratorId)nodes.get(0)).getScope();        VariableNameDeclaration decl = (VariableNameDeclaration)s.getVariableDeclarations().keySet().iterator().next();        assertEquals("bar", decl.getImage());        assertEquals(3, decl.getLine());    }    public void testExceptionBlkParam() {        ASTVariableDeclaratorId id = new ASTVariableDeclaratorId(3);        id.testingOnly__setBeginLine(10);        id.setImage("foo");        ASTFormalParameter param = new ASTFormalParameter(2);        id.jjtSetParent(param);        param.jjtSetParent(new ASTTryStatement(1));        VariableNameDeclaration decl = new VariableNameDeclaration(id);        assertTrue(decl.isExceptionBlockParameter());    }    public void testMethodParam() {        parseCode(TEST3);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId id = (ASTVariableDeclaratorId)nodes.get(0);        nodes = acu.findChildrenOfType(ASTName.class);        assertEquals((ASTName)nodes.get(0), id.getTypeNameNode());    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int bar = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch(Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo(String bar) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTClassBodyDeclaration;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTIfStatement;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.BasicScopeCreationVisitor;import net.sourceforge.pmd.symboltable.BasicScopeFactory;import net.sourceforge.pmd.symboltable.GlobalScope;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.ScopeFactory;import java.util.Stack;public class ScopeCreationVisitorTest extends TestCase {    private class MyCB extends ASTClassBodyDeclaration {        public MyCB() {            super(1);        }        public boolean isAnonymousInnerClass() {            return true;        }    }    private class MySF implements ScopeFactory {        public boolean gotCalled;        public void openScope(Stack scopes, SimpleNode node) {            this.gotCalled = true;            scopes.add(new Object());        }    }    public void testScopesAreCreated() {        BasicScopeCreationVisitor sc = new BasicScopeCreationVisitor(new BasicScopeFactory());        ASTCompilationUnit acu = new ASTCompilationUnit(1);        acu.setScope(new GlobalScope());        ASTTryStatement tryNode = new ASTTryStatement(2);        tryNode.setScope(new LocalScope());        tryNode.jjtSetParent(acu);        ASTIfStatement ifNode = new ASTIfStatement(3);        ifNode.jjtSetParent(tryNode);        sc.visit(acu, null);        assertTrue(ifNode.getScope() instanceof LocalScope);    }    public void testAnonymousInnerClassIsCreated() {        MySF sf = new MySF();        BasicScopeCreationVisitor sc = new BasicScopeCreationVisitor(sf);        ASTClassBodyDeclaration cb = new MyCB();        sc.visit(cb, null);        assertTrue(sf.gotCalled);    }    public void testAnonymousInnerClassIsNotCreated() {        MySF sf = new MySF();        new BasicScopeCreationVisitor(sf).visit(new ASTClassBodyDeclaration(1), null);        assertFalse(sf.gotCalled);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;public class ClassScopeTest extends TestCase {    public void testContains() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testCantContainsSuperToString() {        ClassScope s = new ClassScope("Foo");        SimpleNode node = new SimpleNode(1);        node.setImage("super.toString");        assertTrue(!s.contains(new NameOccurrence(node, node.getImage())));    }    public void testContainsStaticVariablePrefixedWithClassName() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("X");        s.addDeclaration(new VariableNameDeclaration(node));        SimpleNode node2 = new SimpleNode(2);        node2.setImage("Foo.X");        assertTrue(s.contains(new NameOccurrence(node2, node2.getImage())));    }    public void testClassName() {        ClassScope s = new ClassScope("Foo");        assertEquals("Foo", s.getClassName());    }    // FIXME - these will break when this goes from Anonymous$1 to Foo$1    public void testAnonymousInnerClassName() {        ClassScope s = new ClassScope();        assertEquals("Anonymous$1", s.getClassName());        s = new ClassScope();        assertEquals("Anonymous$2", s.getClassName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;import java.util.Map;public class LocalScopeTest extends STBBaseTst {    private class MyASTVariableDeclaratorId extends ASTVariableDeclaratorId {        public MyASTVariableDeclaratorId(int x) {            super(x);        }        public boolean isExceptionBlockParameter() {            return true;        }    }    public void testNameWithThisOrSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertTrue(!scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testNameWithSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertTrue(!scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testExceptionParamNameIsDiscarded() {        ASTVariableDeclaratorId node = new MyASTVariableDeclaratorId(1);        VariableNameDeclaration decl = new VariableNameDeclaration(node);        LocalScope scope = new LocalScope();        scope.addDeclaration(decl);        assertTrue(!scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testLocalVariableDeclarationFound() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId)nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        assertEquals(1, vars.size());        NameDeclaration decl = (NameDeclaration)vars.keySet().iterator().next();        assertEquals("b", decl.getImage());    }    public void testQualifiedNameOccurrence() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId)nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        NameDeclaration decl = (NameDeclaration)vars.keySet().iterator().next();        NameOccurrence occ = (NameOccurrence)((List)vars.get(decl)).get(0);        System.out.println("occ = " + occ);    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  Bar b = new Bar();" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  Bar b = new Bar();" + PMD.EOL +    "  b.buz = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;import java.util.Map;public class MethodScopeTest extends STBBaseTst {    public void testMethodParameterOccurrenceRecorded() {        parseCode(TEST1);        Map m = ((ASTMethodDeclaration)(acu.findChildrenOfType(ASTMethodDeclaration.class)).get(0)).getScope().getVariableDeclarations();        VariableNameDeclaration vnd = (VariableNameDeclaration)m.keySet().iterator().next();        assertEquals("bar", vnd.getImage());        List occs = (List)m.get(vnd);        NameOccurrence occ = (NameOccurrence)occs.get(0);        assertEquals(3, occ.getBeginLine());    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo(int bar) {" + PMD.EOL +    "  bar = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTClassBodyDeclaration;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.ast.ASTForStatement;import net.sourceforge.pmd.ast.ASTIfStatement;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTUnmodifiedClassDeclaration;import net.sourceforge.pmd.ast.ASTUnmodifiedInterfaceDeclaration;import net.sourceforge.pmd.symboltable.BasicScopeFactory;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.GlobalScope;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.MethodScope;import net.sourceforge.pmd.symboltable.ScopeFactory;import java.util.Stack;public class BasicScopeFactoryTest extends TestCase {    public void testGlobalScope() {        ScopeFactory sf = new BasicScopeFactory();        Stack s = new Stack();        sf.openScope(s, new ASTCompilationUnit(1));        assertEquals(1, s.size());        assertTrue(s.get(0) instanceof GlobalScope);    }    public void testClassScope() {        ScopeFactory sf = new BasicScopeFactory();        Stack s = new Stack();        sf.openScope(s, new ASTCompilationUnit(1));        sf.openScope(s, new ASTUnmodifiedClassDeclaration(2));        assertTrue(s.get(1) instanceof ClassScope);        sf.openScope(s, new ASTUnmodifiedInterfaceDeclaration(1));        assertTrue(s.get(2) instanceof ClassScope);        sf.openScope(s, new ASTClassBodyDeclaration(1));        assertTrue(s.get(3) instanceof ClassScope);    }    public void testMethodScope() {        ScopeFactory sf = new BasicScopeFactory();        Stack s = new Stack();        sf.openScope(s, new ASTCompilationUnit(1));        sf.openScope(s, new ASTMethodDeclaration(2));        assertTrue(s.get(1) instanceof MethodScope);        sf.openScope(s, new ASTConstructorDeclaration(1));        assertTrue(s.get(2) instanceof MethodScope);    }    public void testLocalScope() {        ScopeFactory sf = new BasicScopeFactory();        Stack s = new Stack();        sf.openScope(s, new ASTCompilationUnit(1));        sf.openScope(s, new ASTBlock(2));        assertTrue(s.get(1) instanceof LocalScope);        sf.openScope(s, new ASTTryStatement(1));        assertTrue(s.get(2) instanceof LocalScope);        sf.openScope(s, new ASTForStatement(1));        assertTrue(s.get(3) instanceof LocalScope);        sf.openScope(s, new ASTIfStatement(1));        assertTrue(s.get(4) instanceof LocalScope);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.NameOccurrences;import java.util.List;public class NameOccurrencesTest extends STBBaseTst {    public void testSuper() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameOccurrences occs = new NameOccurrences((ASTPrimaryExpression)nodes.get(0));        assertEquals("super", ((NameOccurrence)occs.getNames().get(0)).getImage());    }    public void testThis() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameOccurrences occs = new NameOccurrences((ASTPrimaryExpression)nodes.get(0));        assertEquals("this", ((NameOccurrence)occs.getNames().get(0)).getImage());        assertEquals("x", ((NameOccurrence)occs.getNames().get(1)).getImage());    }    public void testNameLinkage() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameOccurrences occs = new NameOccurrences((ASTPrimaryExpression)nodes.get(0));        NameOccurrence thisNameOccurrence = (NameOccurrence)occs.getNames().get(0);        assertEquals(thisNameOccurrence.getNameForWhichThisIsAQualifier(), (NameOccurrence)occs.getNames().get(1));    }    public void testSimpleVariableOccurrence() {        parseCode(TEST3);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameOccurrences occs = new NameOccurrences((ASTPrimaryExpression)nodes.get(0));        assertEquals("x", ((NameOccurrence)occs.getNames().get(0)).getImage());        assertFalse(((NameOccurrence)occs.getNames().get(0)).isThisOrSuper());        assertFalse(((NameOccurrence)occs.getNames().get(0)).isMethodOrConstructorInvocation());        assertTrue(((NameOccurrence)occs.getNames().get(0)).isOnLeftHandSide());    }    public void testQualifiedOccurrence() {        parseCode(TEST4);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameOccurrences occs = new NameOccurrences((ASTPrimaryExpression)nodes.get(0));        assertEquals("b", ((NameOccurrence)occs.getNames().get(0)).getImage());        assertEquals("x", ((NameOccurrence)occs.getNames().get(1)).getImage());    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  super.x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  this.x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  b.x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTClassDeclaration;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import java.util.Map;public class GlobalScopeTest extends STBBaseTst {    public void testClassDeclAppears() {        parseCode(TEST1);        Map m = ((ASTClassDeclaration)(acu.findChildrenOfType(ASTClassDeclaration.class)).get(0)).getScope().getClassDeclarations();        assertEquals(((ClassNameDeclaration)m.keySet().iterator().next()).getImage(), "Foo");    }    private static final String TEST1 =    "public class Foo {}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTInitializer;import net.sourceforge.pmd.ast.JavaParser;import net.sourceforge.pmd.symboltable.SymbolFacade;import java.io.StringReader;public class AcceptanceTest extends TestCase {    public void testClashingSymbols() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST1));        ASTCompilationUnit c = parser.CompilationUnit();        SymbolFacade stb = new SymbolFacade();        stb.initializeWith(c);    }    public void testInitializer() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST_NON_STATIC_INITIALIZER));        ASTCompilationUnit c = parser.CompilationUnit();        ASTInitializer a = (ASTInitializer)(c.findChildrenOfType(ASTInitializer.class)).get(0);        assertFalse(a.isStatic());    }    public void testStaticInitializer() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST_STATIC_INITIALIZER));        ASTCompilationUnit c = parser.CompilationUnit();        ASTInitializer a = (ASTInitializer)(c.findChildrenOfType(ASTInitializer.class)).get(0);        assertTrue(a.isStatic());    }    private static final String TEST1 =    "import java.io.*;" + PMD.EOL +    "public class Foo  {" + PMD.EOL +    " void buz( ) {" + PMD.EOL +    "  Object o = new Serializable() { int x; };" + PMD.EOL +    "  Object o1 = new Serializable() { int x; };" + PMD.EOL +    " }" + PMD.EOL  +    "}" + PMD.EOL;    private static final String TEST_NON_STATIC_INITIALIZER =    "public class Foo  {" + PMD.EOL +    " {} " + PMD.EOL +    "}" + PMD.EOL;    private static final String TEST_STATIC_INITIALIZER =    "public class Foo  {" + PMD.EOL +    " static {} " + PMD.EOL +    "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.ast.ASTVariableDeclarator;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.DeclarationFinder;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.NameOccurrence;public class DeclarationFinderTest extends TestCase {    public void testDeclarationsAreFound() {        DeclarationFinder df = new DeclarationFinder();        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        ASTVariableDeclarator parent = new ASTVariableDeclarator(2);        node.jjtSetParent(parent);        ASTLocalVariableDeclaration gparent = new ASTLocalVariableDeclaration(3);        parent.jjtSetParent(gparent);        LocalScope scope = new LocalScope();        node.setScope(scope);        df.visit(node, null);        assertTrue(scope.contains(new NameOccurrence(new SimpleNode(4), "foo")));    }    public void test1() {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.ImageFinderFunction;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.ArrayList;import java.util.List;public class ImageFinderFunctionTest extends TestCase {    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    public void testSeveralImages() {        List imgs = new ArrayList();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTPrimarySuffix;import java.util.Set;public class ASTPrimarySuffixTest extends ParserTst {    public void testArrayDereference() throws Throwable {        Set ops = getNodes(ASTPrimarySuffix.class, TEST1);        assertTrue(((ASTPrimarySuffix)(ops.iterator().next())).isArrayDeference());    }    public void testArguments() throws Throwable {        Set ops = getNodes(ASTPrimarySuffix.class, TEST2);        assertTrue(((ASTPrimarySuffix)(ops.iterator().next())).isArguments());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "  {x[0] = 2;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "  {foo(a);}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTEqualityExpression;import net.sourceforge.pmd.ast.ASTInstanceOfExpression;import net.sourceforge.pmd.ast.ASTRelationalExpression;import net.sourceforge.pmd.ast.DiscardableNodeCleaner;public class DiscardableNodeCleanerTest extends TestCase {    public void testRemoveDiscardNodes() {        ASTCompilationUnit cu = new ASTCompilationUnit(1);        ASTEqualityExpression ee = new ASTEqualityExpression(2);        ee.jjtSetParent(cu);        cu.jjtAddChild(ee, 0);        ASTInstanceOfExpression io1 = new ASTInstanceOfExpression(3);        io1.setDiscardable();        io1.jjtSetParent(ee);        ASTRelationalExpression re = new ASTRelationalExpression(4);        re.jjtSetParent(ee);        ee.jjtAddChild(io1, 0);        io1.jjtAddChild(re, 0);        assertEquals(cu.findChildrenOfType(ASTInstanceOfExpression.class).size(), 1);        DiscardableNodeCleaner c = new DiscardableNodeCleaner();        c.clean(cu);        assertEquals(cu.findChildrenOfType(ASTInstanceOfExpression.class).size(), 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTClassDeclaration;import java.util.Iterator;import java.util.Set;public class ClassDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, false, false);    }    public void testAbstract() throws Throwable {        String access[] = {"abstract"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, true, false, false);    }    public void testFinal() throws Throwable {        String access[] = {"final"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, true, false);    }    public void testStrict() throws Throwable {        String access[] = {"strictfp"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, false, true);    }    public void testPublicFinal() throws Throwable {        String access[] = {"public", "final"};        ASTClassDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, true, false);    }    public void verifyFlags(ASTClassDeclaration acd, boolean bPublic, boolean bAbstract, boolean bFinal, boolean bStrict) {        assertEquals("Public: ", bPublic, acd.isPublic());        assertEquals("Abstract: ", bAbstract, acd.isAbstract());        assertEquals("Final: ", bFinal, acd.isFinal());        assertEquals("Strict: ", bStrict, acd.isStrict());    }    public ASTClassDeclaration getClassDecl(String access[]) throws Throwable {        String javaCode = "";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " class Test { } ";        Set classes = getNodes(ASTClassDeclaration.class, javaCode);        assertEquals("Wrong number of classes", 1, classes.size());        Iterator i = classes.iterator();        return (ASTClassDeclaration) i.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import java.util.Iterator;import java.util.Set;public class FieldDeclTest extends ParserTst {    public String makeAccessJavaCode(String access[]) {        String result = "public class Test { ";        for (int i = 0; i < access.length; i++) {            result += access[i] + " ";        }        return result + " int j;  }";    }    public ASTFieldDeclaration getFieldDecl(String access[]) throws Throwable {        Set fields = getNodes(ASTFieldDeclaration.class, makeAccessJavaCode(access));        assertEquals("Wrong number of fields", 1, fields.size());        Iterator i = fields.iterator();        return (ASTFieldDeclaration) i.next();    }    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be protected.", afd.isProtected());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testStatic() throws Throwable {        String access[] = {"private", "static"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be static.", afd.isStatic());        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be final.", afd.isFinal());        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testTransient() throws Throwable {        String access[] = {"private", "transient"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());        assertTrue("Expecting field to be transient.", afd.isTransient());    }    public void testVolatile() throws Throwable {        String access[] = {"private", "volatile"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be volatile.", afd.isVolatile());        assertTrue("Expecting field to be private.", afd.isPrivate());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import java.util.Iterator;import java.util.Set;public class MethodDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be protected.", amd.isProtected());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be final.", amd.isFinal());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testSynchronized() throws Throwable {        String access[] = {"public", "synchronized"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be synchronized.", amd.isSynchronized());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testAbstract() throws Throwable {        String access[] = {"public", "abstract"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be abstract.", amd.isAbstract());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testNative() throws Throwable {        String access[] = {"private", "native"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be native.", amd.isNative());        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testStrict() throws Throwable {        String access[] = {"public", "strictfp"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be strict.", amd.isStrict());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public ASTMethodDeclaration getMethodDecl(String access[]) throws Throwable {        String javaCode = "public class Test { ";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " void stuff() { } }";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        assertEquals("Wrong number of methods", 1, methods.size());        Iterator i = methods.iterator();        return (ASTMethodDeclaration) i.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ASTName;public class ASTImportDeclarationTest extends TestCase {    public void testBasic() {        ASTImportDeclaration i = new ASTImportDeclaration(1);        assertTrue(!i.isImportOnDemand());        i.setImportOnDemand();        assertTrue(i.isImportOnDemand());    }    public void testGetImportedNameNode() {        ASTImportDeclaration i = new ASTImportDeclaration(1);        ASTName name = new ASTName(2);        i.jjtAddChild(name, 0);        assertEquals(name, i.getImportedNameNode());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;public class ASTVariableDeclaratorIdTest extends TestCase {    public void testIsExceptionBlockParameter() {        ASTTryStatement tryNode = new ASTTryStatement(1);        ASTBlock block = new ASTBlock(2);        ASTVariableDeclaratorId v = new ASTVariableDeclaratorId(3);        v.jjtSetParent(block);        block.jjtSetParent(tryNode);        assertTrue(v.isExceptionBlockParameter());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.AccessNode;public class AccessNodeTest extends TestCase {    public void testStatic() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not static.", !node.isStatic());        node.setStatic();        assertTrue("Node set to static, not static.", node.isStatic());    }    public void testPublic() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not public.", !node.isPublic());        node.setPublic();        assertTrue("Node set to public, not public.", node.isPublic());    }    public void testProtected() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not protected.", !node.isProtected());        node.setProtected();        assertTrue("Node set to protected, not protected.", node.isProtected());    }    public void testPrivate() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not private.", !node.isPrivate());        node.setPrivate();        assertTrue("Node set to private, not private.", node.isPrivate());    }    public void testFinal() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not final.", !node.isFinal());        node.setFinal();        assertTrue("Node set to final, not final.", node.isFinal());    }    public void testSynchronized() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not synchronized.", !node.isSynchronized());        node.setSynchronized();        assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());    }    public void testVolatile() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not volatile.", !node.isVolatile());        node.setVolatile();        assertTrue("Node set to volatile, not volatile.", node.isVolatile());    }    public void testTransient() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not transient.", !node.isTransient());        node.setTransient();        assertTrue("Node set to transient, not transient.", node.isTransient());    }    public void testNative() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not native.", !node.isNative());        node.setNative();        assertTrue("Node set to native, not native.", node.isNative());    }    public void testInterface() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not interface.", !node.isInterface());        node.setInterface();        assertTrue("Node set to interface, not interface.", node.isInterface());    }    public void testAbstract() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not abstract.", !node.isAbstract());        node.setAbstract();        assertTrue("Node set to abstract, not abstract.", node.isAbstract());    }    public void testStrict() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not strict.", !node.isStrict());        node.setStrict();        assertTrue("Node set to strict, not strict.", node.isStrict());    }    public void testSuper() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not super.", !node.isSuper());        node.setSuper();        assertTrue("Node set to super, not super.", node.isSuper());    }    public void testPackagePrivate() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to package private.", node.isPackagePrivate());        node.setPrivate();        assertTrue("Node set to private, still package private.", !node.isPackagePrivate());        node = new AccessNode(1);        node.setPublic();        assertTrue("Node set to public, still package private.", !node.isPackagePrivate());        node = new AccessNode(1);        node.setProtected();        assertTrue("Node set to protected, still package private.", !node.isPackagePrivate());    }}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.ast.JavaParser;import java.io.StringReader;import java.util.List;public class EncodingTest extends TestCase {    public void testDecodingOfUTF8() throws Throwable {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST_UTF8));        ASTCompilationUnit acu = parser.CompilationUnit();        List kids = acu.findChildrenOfType(ASTMethodDeclarator.class);        assertEquals("", ((ASTMethodDeclarator)kids.get(0)).getImage());    }    private static final String TEST_UTF8 =    "class Foo {" + PMD.EOL +    " void () {}" + PMD.EOL +    " void fiddle() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTType;import net.sourceforge.pmd.ast.JavaParser;import java.io.StringReader;public class ASTTypeTest extends TestCase{    public void testIsArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST1));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTType node = (ASTType)cu.findChildrenOfType(ASTType.class).get(0);        assertTrue(node.isArray());    }    public void testOneDimensionArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST2));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTType node = (ASTType)cu.findChildrenOfType(ASTType.class).get(0);        assertEquals(1, node.getDimensions());    }    public void testMultiDimensionalArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST3));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTType node = (ASTType)cu.findChildrenOfType(ASTType.class).get(0);        assertEquals(3, node.getDimensions());    }    private static final String TEST1 =    "class Foo {" + PMD.EOL +    " String[] foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "class Foo {" + PMD.EOL +    " String[] foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "class Foo {" + PMD.EOL +    " String[][][] foo() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTBooleanLiteral;public class ASTBooleanLiteralTest extends TestCase {    public void testTrue() {        ASTBooleanLiteral b = new ASTBooleanLiteral(0);        assertFalse(b.isTrue());        b.setTrue();        assertTrue(b.isTrue());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTBlockStatement;import net.sourceforge.pmd.ast.ASTEqualityExpression;import net.sourceforge.pmd.ast.ASTExpression;import net.sourceforge.pmd.ast.ASTInstanceOfExpression;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTRelationalExpression;import net.sourceforge.pmd.ast.ASTReturnStatement;import net.sourceforge.pmd.ast.ASTUnmodifiedClassDeclaration;import net.sourceforge.pmd.ast.ASTVariableInitializer;import net.sourceforge.pmd.ast.SimpleNode;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set;public class SimpleNodeTest extends ParserTst {    public void testMethodDiffLines() throws Throwable {        Set methods = getNodes(ASTMethodDeclaration.class, METHOD_DIFF_LINES);        Iterator iter = methods.iterator();        verifyNode((SimpleNode) iter.next(), 2, 2, 4, 2);    }    public void testMethodSameLine() throws Throwable {        Set methods = getNodes(ASTMethodDeclaration.class, METHOD_SAME_LINE);        verifyNode((SimpleNode) methods.iterator().next(), 2, 2, 2, 21);    }    public void testNoLookahead() throws Throwable {        String code = NO_LOOKAHEAD; // 1, 8 -> 1, 20        Set uCD = getNodes(ASTUnmodifiedClassDeclaration.class, code);        verifyNode((SimpleNode) uCD.iterator().next(), 1, 8, 1, 20);    }    public void testHasExplicitExtends() throws Throwable {        String code = HAS_EXPLICIT_EXTENDS;        ASTUnmodifiedClassDeclaration ucd = (ASTUnmodifiedClassDeclaration)(getNodes(ASTUnmodifiedClassDeclaration.class, code).iterator().next());        assertTrue(ucd.hasExplicitExtends());    }    public void testNoExplicitExtends() throws Throwable {        String code = NO_EXPLICIT_EXTENDS;        ASTUnmodifiedClassDeclaration ucd = (ASTUnmodifiedClassDeclaration)(getNodes(ASTUnmodifiedClassDeclaration.class, code).iterator().next());        assertTrue(!ucd.hasExplicitExtends());    }    public void testHasExplicitImplements() throws Throwable {        String code = HAS_EXPLICIT_IMPLEMENTS;        ASTUnmodifiedClassDeclaration ucd = (ASTUnmodifiedClassDeclaration)(getNodes(ASTUnmodifiedClassDeclaration.class, code).iterator().next());        assertTrue(ucd.hasExplicitImplements());    }    public void testNoExplicitImplements() throws Throwable {        String code = NO_EXPLICIT_IMPLEMENTS;        ASTUnmodifiedClassDeclaration ucd = (ASTUnmodifiedClassDeclaration)(getNodes(ASTUnmodifiedClassDeclaration.class, code).iterator().next());        assertTrue(!ucd.hasExplicitImplements());    }    public void testColumnsOnQualifiedName() throws Throwable {        Set name = getNodes(ASTName.class, QUALIFIED_NAME);        Iterator i = name.iterator();        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 1, 19);            }        }    }    public void testLineNumbersForNameSplitOverTwoLines() throws Throwable {        Set name = getNodes(ASTName.class, BROKEN_LINE_IN_NAME);        Iterator i = name.iterator();        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 2, 4);            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 18);            }        }    }    public void testLineNumbersAreSetOnAllSiblings() throws Throwable {        Set blocks = getNodes(ASTBlock.class, LINE_NUMBERS_ON_SIBLINGS);        Iterator i = blocks.iterator();        while (i.hasNext()) {            ASTBlock b = (ASTBlock)i.next();            assertTrue(b.getBeginLine() > 0);        }        blocks = getNodes(ASTVariableInitializer.class, LINE_NUMBERS_ON_SIBLINGS);        i = blocks.iterator();        while (i.hasNext()) {            ASTVariableInitializer b = (ASTVariableInitializer)i.next();            assertTrue(b.getBeginLine() > 0);        }        blocks = getNodes(ASTExpression.class, LINE_NUMBERS_ON_SIBLINGS);        i = blocks.iterator();        while (i.hasNext()) {            ASTExpression b = (ASTExpression)i.next();            assertTrue(b.getBeginLine() > 0);        }    }    public void testFindChildrenOfType() {        ASTBlock block = new ASTBlock(2);        block.jjtAddChild(new ASTReturnStatement(1), 0);        assertEquals(1, block.findChildrenOfType(ASTReturnStatement.class).size());    }    public void testFindChildrenOfTypeMultiple() {        ASTBlock block = new ASTBlock(1);        block.jjtAddChild(new ASTBlockStatement(2), 0);        block.jjtAddChild(new ASTBlockStatement(3), 1);        List nodes = new ArrayList();        block.findChildrenOfType(ASTBlockStatement.class, nodes);        assertEquals(2, nodes.size());    }    public void testFindChildrenOfTypeRecurse() {        ASTBlock block = new ASTBlock(1);        ASTBlock childBlock = new ASTBlock(2);        block.jjtAddChild(childBlock, 0);        childBlock.jjtAddChild(new ASTMethodDeclaration(3), 0);        List nodes = new ArrayList();        block.findChildrenOfType(ASTMethodDeclaration.class, nodes);        assertEquals(1, nodes.size());    }    public void testReplaceChild() {        ASTEqualityExpression ee = new ASTEqualityExpression(1);        ASTInstanceOfExpression io1 = new ASTInstanceOfExpression(2);        ASTRelationalExpression re = new ASTRelationalExpression(3);        ASTInstanceOfExpression io2 = new ASTInstanceOfExpression(2);        ee.jjtAddChild(io1, 0);        ee.jjtAddChild(io2, 1);        io1.jjtAddChild(re, 0);        ee.jjtReplaceChild(io1, re);        assertEquals(ee.jjtGetChild(0), re);        assertEquals(ee.jjtGetChild(1), io2);    }    private void verifyNode(SimpleNode node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Wrong beginning line: ", beginLine, node.getBeginLine());        assertEquals("Wrong beginning column: ", beginCol, node.getBeginColumn());        assertEquals("Wrong ending line:", endLine, node.getEndLine());        assertEquals("Wrong ending column:", endCol, node.getEndColumn());    }    private static final String HAS_EXPLICIT_EXTENDS =    "public class Test extends Foo {}";    private static final String NO_EXPLICIT_EXTENDS =    "public class Test {}";    private static final String HAS_EXPLICIT_IMPLEMENTS =    "public class Test implements Foo {}";    private static final String NO_EXPLICIT_IMPLEMENTS =    "public class Test {}";    private static final String METHOD_DIFF_LINES =    "public class Test {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  int x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String METHOD_SAME_LINE =    "public class Test {" + PMD.EOL +    " public void foo() {}" + PMD.EOL +    "}";    private static final String QUALIFIED_NAME =    "import java.io.File;" + PMD.EOL +    "public class Foo{}";    private static final String BROKEN_LINE_IN_NAME =    "import java.io." + PMD.EOL +    "File;" + PMD.EOL +    "public class Foo{}";    private static final String LINE_NUMBERS_ON_SIBLINGS =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception1 e) {" + PMD.EOL +    "   int x =2;" + PMD.EOL +    "  }" + PMD.EOL +    " if (x != null) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String NO_LOOKAHEAD = "public class Foo { }";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_3;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.TargetJDKVersion;import net.sourceforge.pmd.ast.JavaParser;import net.sourceforge.pmd.ast.ParseException;import java.io.StringReader;public class JDKVersionTest extends TestCase  {    // enum keyword/identifier    public void testEnumAsKeywordShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_ENUM));            p.CompilationUnit();            throw new Error("JDK 1.4 parser should have failed to parse enum used as keyword");        } catch (ParseException e) {}    // cool    }    public void testEnumAsIdentifierShouldPassWith14() throws Throwable {        JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK14_ENUM));        p.CompilationUnit();    }    public void testEnumAsKeywordShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_ENUM));        p.CompilationUnit();    }    public void testEnumAsIdentifierShouldFailWith15() throws Throwable {        try {            TargetJDKVersion jdk = new TargetJDK1_5();            JavaParser p = jdk.createParser(new StringReader(JDK14_ENUM));            p.CompilationUnit();            throw new Error("JDK 1.5 parser should have failed to parse enum used as identifier");        } catch (ParseException e) {}    // cool    }    // enum keyword/identifier    // assert keyword/identifier    public void testAssertAsKeywordVariantsSucceedWith1_4() {        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST1)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST2)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST3)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST4)).CompilationUnit();    }    public void testAssertAsVariableDeclIdentifierFailsWith1_4() {        try {            (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST5)).CompilationUnit();            throw new RuntimeException("Usage of assert as identifier should have failed with 1.4");        } catch (ParseException pe) {            // cool        }    }    public void testAssertAsMethodNameIdentifierFailsWith1_4() {        try {            (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST7)).CompilationUnit();            throw new RuntimeException("Usage of assert as identifier should have failed with 1.4");        } catch (ParseException pe) {            // cool        }    }    public void testAssertAsIdentifierSucceedsWith1_3() {        JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST5));        jp.CompilationUnit();    }    public void testAssertAsKeywordFailsWith1_3() {        try {            JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST6));            jp.CompilationUnit();            throw new RuntimeException("Usage of assert as keyword should have failed with 1.3");        } catch (ParseException pe) {            // cool        }    }    // assert keyword/identifier    private static final String ASSERT_TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert x>2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert (x>2);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert x>2 : \"hi!\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert (x>2) : \"hi!\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST5 =    "public class Foo {" + PMD.EOL +    "  int assert = 2;" + PMD.EOL +    "}";    private static final String ASSERT_TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  assert (x>2) : \"hi!\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST7 =    "public class Foo {" + PMD.EOL +    " void assert() {}" + PMD.EOL +    "}";    private static final String JDK15_ENUM =    "public class Test {" + PMD.EOL +    " enum Season { winter, spring, summer, fall };" + PMD.EOL +    "}";    private static final String JDK14_ENUM =    "public class Test {" + PMD.EOL +    " int enum;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTAssignmentOperator;import java.util.Set;public class ASTAssignmentOperatorTest extends ParserTst {    public void testSimpleAssignmentRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST1);        assertTrue(!((ASTAssignmentOperator)(ops.iterator().next())).isCompound());    }    public void testCompoundAssignmentPlusRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST2);        assertTrue(((ASTAssignmentOperator)(ops.iterator().next())).isCompound());    }    public void testCompoundAssignmentMultRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST3);        assertTrue(((ASTAssignmentOperator)(ops.iterator().next())).isCompound());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x;" + PMD.EOL +    "  x=2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x;" + PMD.EOL +    "  x += 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x;" + PMD.EOL +    "  x *= 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.ExternalRuleID;public class ExternalRuleIDTest extends TestCase {    public void testSimpleRef() {        String xrefString = "rulesets/basic.xml/EmptyCatchBlock";        ExternalRuleID xref = new ExternalRuleID(xrefString);        assertEquals("Filename mismatch!", "rulesets/basic.xml", xref.getFilename());        assertEquals("Rule name mismatch!", "EmptyCatchBlock", xref.getRuleName());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.CommandLineOptions;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.EmacsRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.IDEAJRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.VBHTMLRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;import java.io.InputStreamReader;public class CommandLineOptionsTest extends TestCase {    public void testDebug() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-debug"});        assertTrue(opt.debugEnabled());    }    public void testTargetJDKVersion() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset"});        assertFalse(opt.jdk13());        opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-jdk13"});        assertTrue(opt.jdk13());    }    public void testShortNames() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-shortnames"});        assertTrue(opt.shortNamesEnabled());    }    public void testEncoding() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset"});        assertTrue(opt.getEncoding().equals((new InputStreamReader(System.in)).getEncoding()));        opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-encoding", "UTF-8"});        assertTrue(opt.getEncoding().equals("UTF-8"));    }    public void testInputFileName() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset"});        assertEquals("file", opt.getInputPath());    }    public void testReportFormat() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset"});        assertEquals("format", opt.getReportFormat());    }    public void testRulesets() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "ruleset"});        assertEquals("ruleset", opt.getRulesets());    }    public void testCommaSeparatedFiles() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file1,file2,file3", "format", "ruleset"});        assertTrue(opt.containsCommaSeparatedFileList());    }    public void testNotEnoughArgs() {        try {            new CommandLineOptions(new String[] {"file1", "format"});            fail("Should have thrown an exception when only array contained < 3 args");        } catch (RuntimeException re) {            // cool        }    }    public void testNullArgs() {        try {            new CommandLineOptions(null);            fail("Should have thrown an exception when null passed to constructor");        } catch (RuntimeException re) {            // cool        }    }    public void testRenderer() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "xml", "ruleset"});        assertTrue(opt.createRenderer() instanceof XMLRenderer);        opt = new CommandLineOptions(new String[] {"file", "html", "ruleset"});        assertTrue(opt.createRenderer() instanceof HTMLRenderer);        opt = new CommandLineOptions(new String[] {"file", "text", "ruleset"});        assertTrue(opt.createRenderer() instanceof TextRenderer);        opt = new CommandLineOptions(new String[] {"file", "emacs", "ruleset"});        assertTrue(opt.createRenderer() instanceof EmacsRenderer);        opt = new CommandLineOptions(new String[] {"file", "csv", "ruleset"});        assertTrue(opt.createRenderer() instanceof CSVRenderer);        opt = new CommandLineOptions(new String[] {"file", "vbhtml", "ruleset"});        assertTrue(opt.createRenderer() instanceof VBHTMLRenderer);        opt = new CommandLineOptions(new String[] {"file", "ideaj", "ruleset"});        assertTrue(opt.createRenderer() instanceof IDEAJRenderer);        try {            opt = new CommandLineOptions(new String[] {"file", "fiddlefaddle", "ruleset"});            opt.createRenderer();        } catch (IllegalArgumentException iae) {            // cool        }        try {            opt = new CommandLineOptions(new String[] {"file", "", "ruleset"});            opt.createRenderer();        } catch (IllegalArgumentException iae) {            // cool        }    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;public class AbstractRuleTest extends TestCase {    private static class MyRule extends AbstractRule {        public String getMessage() {            return "myrule";        }    }    public AbstractRuleTest(String name) {        super(name);    }    public void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation rv = r.createRuleViolation(ctx, 5);        assertEquals("Line number mismatch!", 5, rv.getLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "myrule", rv.getDescription());        assertEquals("RuleSet name mismatch!", "foo", rv.getRule().getRuleSetName());    }    public void testCreateRV2() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation rv = r.createRuleViolation(ctx, 5, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.JavaParser;import test.net.sourceforge.pmd.testframework.MockRule;import java.io.StringReader;import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;public class RuleSetTest extends TestCase {    private String javaCode = "public class Test { }";    public void testConstructor() {        new RuleSet();    }    public void testAccessors() {        RuleSet rs = new RuleSet();        rs.setName("foo");        assertEquals("name mismatch", "foo", rs.getName());        rs.setDescription("bar");        assertEquals("description mismatch", "bar", rs.getDescription());    }    public void testGetRuleByName() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    public void testRuleList() {        RuleSet IUT = new RuleSet();        assertEquals("Size of RuleSet isn't zero.", 0, IUT.size());        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        IUT.addRule(rule);        assertEquals("Size of RuleSet isn't one.", 1, IUT.size());        Set rules = IUT.getRules();        Iterator i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    public void testAddRuleSet() {        RuleSet set1 = new RuleSet();        set1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet set2 = new RuleSet();        set2.addRule(new MockRule("name2", "desc", "msg", "rulesetname"));        set1.addRuleSet(set2);        assertEquals("ruleset size wrong", 2, set1.size());    }    public void testApply0Rules() throws Throwable {        RuleSet IUT = new RuleSet();        verifyRuleSet(IUT, 0, new HashSet());    }    protected void verifyRuleSet(RuleSet IUT, int size, Set values) throws Throwable {        RuleContext context = new RuleContext();        Set reportedValues = new HashSet();        context.setReport(new Report());        IUT.apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().size());        Iterator violations = context.getReport().iterator();        while (violations.hasNext()) {            RuleViolation violation = (RuleViolation) violations.next();            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        Iterator expected = values.iterator();        while (expected.hasNext()) {            RuleViolation violation = (RuleViolation) expected.next();            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    protected List makeCompilationUnits() throws Throwable {        List RC = new ArrayList();        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(javaCode));        RC.add(parser.CompilationUnit());        return RC;    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.testframework.MockRule;import java.util.Iterator;import java.util.Map;public class ReportTest extends TestCase implements ReportListener {    private boolean violationSemaphore;    private boolean metricSemaphore;    public void testBasic() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 5, ctx, "package", "class"));        assertTrue(!r.isEmpty());    }    public void testMetric0() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());    }    public void testMetric1() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());        r.addMetric(new Metric("m1", 0, 0.0, 1.0, 2.0, 3.0, 4.0));        assertTrue("Expected metrics weren't there", r.hasMetrics());        Iterator ms = r.metrics();        assertTrue("Should have some metrics in there now", ms.hasNext());        Object o = ms.next();        assertTrue("Expected Metric, got " + o.getClass(), o instanceof Metric);        Metric m = (Metric) o;        assertEquals("metric name mismatch", "m1", m.getMetricName());        assertEquals("wrong low value", 1.0, m.getLowValue(), 0.05);        assertEquals("wrong high value", 2.0, m.getHighValue(), 0.05);        assertEquals("wrong avg value", 3.0, m.getAverage(), 0.05);        assertEquals("wrong std dev value", 4.0, m.getStandardDeviation(), 0.05);    }    // Files are grouped together now.    public void testSortedReport_File() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 10, ctx, "package", "class"));        ctx.setSourceCodeFilename("bar");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 20, ctx, "package", "class"));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    public void testSortedReport_Line() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        r.addRuleViolation(new RuleViolation(new MockRule("rule2", "rule2", "msg", "rulesetname"), 10, ctx, "package", "class"));        ctx.setSourceCodeFilename("foo2");        r.addRuleViolation(new RuleViolation(new MockRule("rule1", "rule1", "msg", "rulesetname"), 20, ctx, "package", "class"));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    public void testListener() {        Report rpt = new Report();        rpt.addListener(this);        violationSemaphore = false;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("file");        rpt.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 5, ctx, "package", "class"));        assertTrue(violationSemaphore);        metricSemaphore = false;        rpt.addMetric(new Metric("test", 0, 0.0, 0.0, 0.0, 0.0, 0.0));        assertTrue("no metric", metricSemaphore);    }    public void ruleViolationAdded(RuleViolation ruleViolation) {        violationSemaphore = true;    }    public void metricAdded(Metric metric) {        metricSemaphore = true;    }    public void testSummary() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        r.addRuleViolation(new RuleViolation(new MockRule("rule2", "rule2", "msg", "rulesetname"), 10, ctx, "package", "class"));        ctx.setSourceCodeFilename("foo2");        Rule mr = new MockRule("rule1", "rule1", "msg", "rulesetname");        r.addRuleViolation(new RuleViolation(mr, 20, ctx, "package", "class"));        r.addRuleViolation(new RuleViolation(mr, 30, ctx, "package", "class"));        Map summary = r.getSummary();        assertEquals(summary.keySet().size(), 2);        assertTrue(summary.values().contains(new Integer(1)));        assertTrue(summary.values().contains(new Integer(2)));    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import java.io.ByteArrayInputStream;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class RuleSetFactoryTest extends TestCase {    public void testSingleRuleWithPriority() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(SINGLE_RULE_SET_WITH_PRIORITY.getBytes()));        Rule r = (Rule)rs.getRules().iterator().next();        assertEquals(3, r.getPriority());    }    public void testRuleSetNotFound() {        RuleSetFactory rsf = new RuleSetFactory();        try {            rsf.createRuleSet("fooooo");            throw new RuntimeException("Should have thrown a RuleSetNotFoundException");        } catch (RuleSetNotFoundException rsnfe) {            // cool        }    }    public void testCreateEmptyRuleSet() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(EMPTY_RULE_SET.getBytes()));        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    public void testSingleRule() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(SINGLE_RULE_SET.getBytes()));        assertEquals(1, rs.size());        Rule r = (Rule)rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("avoid the mock rule", r.getMessage());    }    public void testMultipleRules() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(MULTIPLE_RULE_SET.getBytes()));        assertEquals(2, rs.size());        Set expected = new HashSet();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Iterator i = rs.getRules().iterator(); i.hasNext();) {            assertTrue(expected.contains(((Rule) i.next()).getName()));        }    }    public void testProps() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(RULE_WITH_PROPERTIES.getBytes()));        Rule r = (Rule) rs.getRules().iterator().next();        assertTrue(r.hasProperty("foo"));        assertEquals("bar", r.getStringProperty("foo"));        assertEquals(2, r.getIntProperty("fooint"));        assertTrue(r.hasProperty("fooBoolean"));        assertTrue(r.getBooleanProperty("fooBoolean"));        assertTrue(r.hasProperty("fooDouble"));        assertEquals(1.0, r.getDoubleProperty("fooDouble"), 0.05);        assertTrue(!r.hasProperty("BuggleFish"));        assertTrue(r.getDescription().indexOf("testdesc2") != -1);    }    public void testXPathPluginnameProperty() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(RULE_WITH_XPATH_AND_PLUGINNAME.getBytes()));        Rule r = (Rule) rs.getRules().iterator().next();        assertTrue(r.hasProperty("pluginname"));    }    public void testXPath() {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(RULE_WITH_XPATH.getBytes()));        Rule r = (Rule) rs.getRules().iterator().next();        assertTrue(r.hasProperty("xpath"));        assertTrue(r.getStringProperty("xpath").indexOf(" //Block ") != -1);    }    private static final String EMPTY_RULE_SET =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "</ruleset>";    private static final String SINGLE_RULE_SET =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "</rule></ruleset>";    private static final String MULTIPLE_RULE_SET =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule name=\"MockRuleName1\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "</rule>" + PMD.EOL +            "<rule name=\"MockRuleName2\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "</rule></ruleset>";    private static final String RULE_WITH_PROPERTIES =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"fooBoolean\" value=\"true\"/>" + PMD.EOL +            "<property name=\"fooDouble\" value=\"1.0\" />" + PMD.EOL +            "<property name=\"foo\" value=\"bar\"/>" + PMD.EOL +            "<property name=\"fooint\" value=\"2\"/>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String RULE_WITH_XPATH =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<priority>3</priority>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"xpath\">" + PMD.EOL +            "<value>" + PMD.EOL +            "<![CDATA[ //Block ]]>" + PMD.EOL +            "</value>" + PMD.EOL +            "</property>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String RULE_WITH_XPATH_AND_PLUGINNAME =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<priority>3</priority>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"xpath\" pluginname=\"true\">" + PMD.EOL +            "<value>" + PMD.EOL +            "<![CDATA[ //Block ]]>" + PMD.EOL +            "</value>" + PMD.EOL +            "</property>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String SINGLE_RULE_SET_WITH_PRIORITY =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "<priority>3</priority>" + PMD.EOL +            "</rule></ruleset>";    /*        public void testExternalReferences() {            RuleSetFactory rsf = new RuleSetFactory();            RuleSet rs = rsf.createRuleSet(new ByteArrayInputStream(EXTERNAL_REFERENCE_RULE_SET.getBytes()));            assertEquals(1, rs.size());        }        private static final String EXTERNAL_REFERENCE_RULE_SET = "<?xml version=\"1.0\"?>" +                             "<ruleset name=\"test\">\r\n<description>testdesc</description><rule ref=\"rulesets/basic.xml/EmptyCatchBlock\"/></ruleset>";        private static final String SINGLE_RULE_NO_PROPS = "<?xml version=\"1.0\"?>" +                             "<ruleset name=\"test\">\r\n<description>testdesc</description>" +                             "<rule name=\"MockRuleName\" message=\"avoid the mock rule\" class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +                             "<properties></properties>" +                             "</rule></ruleset>";    */}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;public class RuleContextTest extends TestCase {    public void testReport() {        RuleContext ctx = new RuleContext();        assertNull("Report should be null", ctx.getReport());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    public void testFilename() {        RuleContext ctx = new RuleContext();        assertNull("filename should be null", ctx.getSourceCodeFilename());        ctx.setSourceCodeFilename("foo");        assertEquals("filename mismatch", "foo", ctx.getSourceCodeFilename());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import test.net.sourceforge.pmd.testframework.MockRule;public class RuleViolationTest extends TestCase {    public void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r = new RuleViolation(rule, 2, ctx, "package", "class");        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getLine());        assertEquals("filename is wrong", "filename", r.getFilename());    }    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r = new RuleViolation(rule, 2, "description", ctx);        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename1");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        ctx.setSourceCodeFilename("filename2");        RuleViolation r2 = new RuleViolation(rule, 20, "description", ctx);        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        RuleViolation r2 = new RuleViolation(rule, 20, "description", ctx);        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        RuleViolation r2 = new RuleViolation(rule, 10, "description", ctx);        assertEquals(1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }}
/* * Created on 18.08.2004 */package net.sourceforge.pmd.dfa.test;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.IDataFlowNode;import java.util.List;/** * @author raik *         <p/> *         Test rule to verify special data flows. */public class TestRule extends AbstractRule {    FlowTest ft = new FlowTest();    public Object visit(ASTMethodDeclarator node, Object data) {        super.visit(node, data);        String methodName = node.getImage();        IDataFlowNode inode = node.getDataFlowNode();        if (inode == null) return data;        List flow = inode.getFlow();        if (flow == null) return data;        ft.run(methodName, flow);        return data;    }}
/* * Created on 18.08.2004 */package net.sourceforge.pmd.dfa.test;/** * @author raik *         <p/> *         Contains methods which will be checked. */public class TestClass {//----------------------------------------------------------------------------    public void test_1() {        int x = 0;        if (x == 0) {            x++;            x = 0;        }    }//----------------------------------------------------------------------------    public void test_2() {        for (int i = 0; i < 1; i++) {            i++;            i = 8;        }    }//----------------------------------------------------------------------------    public void test_3() {        for (int i = 0; i < 1; i++) {        }    }//----------------------------------------------------------------------------    public void test_4() {        for (; ;) {        }    }//----------------------------------------------------------------------------    public void test_6() {        for (int i = 0; ;) {        }    }//----------------------------------------------------------------------------    public void test_7() {        for (int i = 0; i < 0;) {        }    }//----------------------------------------------------------------------------    public void test_8() {        for (int i = 0; ; i++) {        }    }//----------------------------------------------------------------------------    public void test_9() {        int i = 0;        for (; i < 0;) {        }    }//----------------------------------------------------------------------------    public void test_10() {        int i = 0;        for (; i < 0; i++) {        }    }//----------------------------------------------------------------------------    public void test_11() {        int i = 0;        for (; ; i++) {        }    }//----------------------------------------------------------------------------    public void test_12() {        for (; ;) {            int i = 0;        }    }//----------------------------------------------------------------------------    public void test_13() {        for (int i = 0; i < 0; i++) {            i = 9;            if (i < 8) {                i = 7;            }            i = 6;        }    }//----------------------------------------------------------------------------    public void test_14() {        for (int i = 0; i < 0; i++) {            i = 9;            if (i < 8) {                i = 7;            }        }    }//----------------------------------------------------------------------------    public void test_15() {        for (int i = 0; i < 0; i++) {            if (i < 8) {                i = 7;            }        }    }//----------------------------------------------------------------------------    public void test_16() {        for (int i = 0; i < 0; i++) {            if (i < 8) {                i = 7;            } else {                i = 6;            }        }    }//----------------------------------------------------------------------------    public void test_17() {        for (int i = 0; i < 0; i++) {            if (i < 6) {                i = 7;            } else if (i > 8) {                i = 9;            } else {                i = 10;            }        }    }//----------------------------------------------------------------------------    public void test_18() {        for (int i = 0; i < 0; i++) {            for (int j = 0; j < 0; j++) {                j++;            }        }    }//----------------------------------------------------------------------------    public void test_19() {        int i = 0;        if (i == 1) {            i = 2;        } else if (i == 3) {            i = 4;        } else if (i == 5) {            i = 6;        } else {            i = 7;        }    }//----------------------------------------------------------------------------    public void test_20() {        int i = 0;        if (i == 1) {            if (i == 2) {                i = 3;            }        } else {            i = 7;        }    }//----------------------------------------------------------------------------    public void test_21() {        int i = 0;        if (i == 1) {            for (i = 3; i < 4; i++) {                i = 5;            }            i++;        } else if (i < 6) {            i = 7;        }    }//----------------------------------------------------------------------------    public void test_22() {        int i = 0;        if (i == 1) {            for (i = 3; i < 4; i++) {                i = 5;            }        } else {            i = 7;        }    }//----------------------------------------------------------------------------    public void test_23() {        int i = 0;        if (i == 1) {            for (i = 3; i < 4; i++) {                i = 5;            }        } else if (i < 6) {            i = 7;        }    }//----------------------------------------------------------------------------    public void test_24() {        int x = 0;        if (x > 2) {            for (int i = 0; i < 1; i++) {                if (x > 3) {                    x++;                }            }        } else if (x > 4) {            x++;        }    }//----------------------------------------------------------------------------    public void test_25() {        int x = 0;        switch (x) {            default:                x = 9;        }    }//----------------------------------------------------------------------------    public void test_26() {        int x = 0;        do {            if (x > 0) {                x++;            }            x++;        } while (x < 9);        x++;    }  //----------------------------------------------------------------------------    public void test_27() {        for (int i = 0; i < 36; i++) {            int x = 0;            do {                x++;            } while (x < 9);        }    }    private void test_28() {        for (int i = 0; i < 36; i++) {            int x = 0;            do {                if (x > 0) {                    x++;                    switch (i) {                        case 0:                            x = 0;                            break;                    }                }                x++;            } while (x < 9);        }    }}
/* * Created on 18.08.2004 */package net.sourceforge.pmd.dfa.test;import net.sourceforge.pmd.dfa.IDataFlowNode;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.List;/** * @author raik *         <p/> *         Contains methods which represent a data flow. The methods contains an 2d *         array. The first dimension represent the index of a node. The second *         dimension represent the indices of the children. */public class FlowTest {    String methodName = "";    List flow = null;    int number = 0;    public boolean run(String methodName, List flow) {        if (methodName == null || flow == null) return false;        this.methodName = methodName;        this.flow = flow;        Method method;        Object returnValue = null;        System.out.print("test class " + methodName + " ");        try {            method = this.getClass().getMethod(methodName, null);            returnValue = method.invoke(this, null);        } catch (SecurityException e) {            //e.printStackTrace();            System.err.println("SecurityException");        } catch (NoSuchMethodException e) {            //e.printStackTrace();            System.err.println("NoSuchMethodException");        } catch (IllegalArgumentException e) {            //e.printStackTrace();            System.err.println("IllegalArgumentException");        } catch (IllegalAccessException e) {            //e.printStackTrace();            System.err.println("IllegalAccessException");        } catch (InvocationTargetException e) {            //e.printStackTrace();            System.err.println("InvocationTargetException");        }        System.out.println(" -  result: " + returnValue);        return true;    }    private boolean test(int array[][]) {        for (int i = 0; i < this.flow.size(); i++) {            IDataFlowNode inode = (IDataFlowNode) flow.get(i);            for (int j = 0; j < inode.getChildren().size(); j++) {                IDataFlowNode child = (IDataFlowNode) inode.getChildren().get(j);                if (array[i][j] != child.getIndex()) {                    return false;                }            }        }        return true;    }    public boolean test_1() {        int array[][] = {            {1},            {2},            {3},            {4, 6},            {5},            {6},            {}        };        return this.test(array);    }    public boolean test_2() {        int array[][] = {            {1},            {2},            {3},            {5, 7},            {3},            {6},            {4},            {}        };        return this.test(array);    }    public boolean test_3() {        int array[][] = {            {1},            {2},            {3},            {4, 5},            {3},            {}        };        return this.test(array);    }    public boolean test_4() {        int array[][] = {            {1},            {2},            {3},            {}        };        return this.test(array);    }    public boolean test_5() {        int array[][] = {            {1},            {2},            {3},            {4},            {}        };        return this.test(array);    }    public boolean test_6() {        return test_5();    }    public boolean test_7() {        return test_5();    }    public boolean test_8() {        int array[][] = {            {1},            {2},            {3},            {4, 5},            {3},            {}        };        return this.test(array);    }    public boolean test_9() {        return test_5();    }    public boolean test_10() {        return test_8();    }    public boolean test_11() {        return test_8();    }    public boolean test_12() {        int array[][] = {            {1},            {2},            {3, 4},            {2},            {}        };        return this.test(array);    }    public boolean test_13() {        int array[][] = {            {1},            {2},            {3},            {5, 9},            {3},            {6},            {7, 8},            {8},            {4},            {}        };        return this.test(array);    }    public boolean test_14() {        int array[][] = {            {1},            {2},            {3},            {5, 8},            {3},            {6},            {7, 4},            {4},            {}        };        return this.test(array);    }    public boolean test_15() {        int array[][] = {            {1},            {2},            {3},            {5, 7},            {3},            {6, 4},            {4},            {}        };        return this.test(array);    }    public boolean test_16() {        int array[][] = {            {1},            {2},            {3},            {5, 8},            {3},            {6, 7},            {4},            {4},            {}        };        return this.test(array);    }    public boolean test_17() {        int array[][] = {            {1},            {2},            {3},            {5, 10},            {3},            {6, 7},            {4},            {8, 9},            {4},            {4},            {}        };        return this.test(array);    }    public boolean test_18() {        int array[][] = {            {1},            {2},            {3},            {5, 9},            {3},            {6},            {8, 4},            {6},            {7},            {}        };        return this.test(array);    }    public boolean test_19() {        int array[][] = {            {1},            {2},            {3},            {4, 5},            {10},            {6, 7},            {10},            {8, 9},            {10},            {10},            {}        };        return this.test(array);    }    public boolean test_20() {        int array[][] = {            {1},            {2},            {3},            {4, 6},            {5, 7},            {7},            {7},            {}        };        return this.test(array);    }    public boolean test_21() {        int array[][] = {            {1},            {2},            {3},            {4, 9},            {5},            {7, 8},            {5},            {6},            {11},            {10, 11},            {11},            {}        };        return this.test(array);    }    public boolean test_22() {        int array[][] = {            {1},            {2},            {3},            {4, 8},            {5},            {7, 9},            {5},            {6},            {9},            {}        };        return this.test(array);    }    public boolean test_23() {        int array[][] = {            {1},            {2},            {3},            {4, 8},            {5},            {7, 10},            {5},            {6},            {9, 10},            {10},            {}        };        return this.test(array);    }    public boolean test_24() {        int array[][] = {            {1},            {2},            {3},            {4, 9},            {5},            {7, 11},            {5},            {8, 6},            {6},            {10, 11},            {11},            {}        };        return this.test(array);    }    public boolean test_25() {        int array[][] = {            {1},            {2},            {3},            {4},            {5},            {}        };        return this.test(array);    }    public boolean test_26() {        int array[][] = {            {1},            {2},            {3},            {4},            {5, 6},            {6},            {7},            {8, 3},            {9},            {}        };        return this.test(array);    }    public boolean test_27() {        int array[][] = {            {1},            {2},            {3},            {5, 9},            {3},            {6},            {7},            {8},            {6, 4},            {}        };        return this.test(array);    }    public boolean test_28() {        int array[][] = {            {1},            {2},            {3},            {5, 14},            {3},            {6},            {7},            {8, 12},            {9},            {10, 12},            {11},            {12},            {13},            {6, 4},            {}        };        return this.test(array);    }}
package test.net.sourceforge.pmd.rx.rules;import java.util.Set;import java.util.Iterator;import net.sourceforge.pmd.rx.facts.*;import net.sourceforge.pmd.rx.rules.*;import test.net.sourceforge.pmd.rx.*;public class DuplicateImportTest    extends DroolsRuleTst{    private String testName = null;    private String JAVA_NO_DUPE ="import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_DEMAND ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_NO_DEMAND ="import java.util.List;" +"import java.util.List;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_NO_DEMAND ="import java.util.*;" +"import java.util.List;" +"public class HelloWorld { }";    public DuplicateImportTest(String name) {super( name );this.testName = name;    }    public void testNoDupes() throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_NO_DUPE );Iterator rvs = results.iterator();while (rvs.hasNext()) {    RuleViolationFact rvFact = (RuleViolationFact) rvs.next();    ImportFact impFact = (ImportFact) rvFact.getFact();    System.err.println("DuplicateImport: " + impFact.getACU() + "/" +       impFact.getImportPackage() + "/" +       Integer.toString( impFact.getLineNumber() ));}assertEquals("Expecting no violations",     0, results.size() );    }    public void testDupeOnDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeOnNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }}
package test.net.sourceforge.pmd.rx;import java.util.Set;import java.util.HashSet;import java.util.Iterator;import java.io.StringReader;import org.drools.*;import org.drools.spi.*;import org.drools.semantic.java.*;import net.sourceforge.pmd.*;import net.sourceforge.pmd.rx.*;import net.sourceforge.pmd.ast.*;import net.sourceforge.pmd.rx.facts.*;import junit.framework.TestCase;public class DroolsVisitorTest    extends TestCase{    private String testName = null;    private static String JAVA_TEST_PACKAGE ="package test;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_1 ="import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_2 ="import java.util.*;" +"import java.lang.ref.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_SINGLE ="import java.util.Map;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_DUP ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_CLASS ="class TestClass { }";    private static String JAVA_TEST_CLASS_PUBLIC ="public class TestClass { }";    private static String JAVA_TEST_CLASS_ABSTRACT ="abstract class TestClass { }";    private static String JAVA_TEST_CLASS_INNER ="class Outer { class Inner { } }";    private static String JAVA_TEST_CLASS_ANON ="class Named { " +"  void foo() { Named.bar( new Runnable() { } ); } " +        "}";    private ASTCompilationUnit current = null;    public DroolsVisitorTest(String name) {super( name );this.testName = name;    }    public void testPackage() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.PackageFact.class,  JAVA_TEST_PACKAGE );assertEq("Expected one result.", 1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT( "Expected PackageFact.", fact instanceof PackageFact );PackageFact pkgFact = (PackageFact) fact;assertEq("Expecting package name of 'test'", "test", pkgFact.getPackageName() );    }    public void testImport1() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_1 );assertEq("Expected one result.", 1, results.size() );Iterator imports = results.iterator();Object fact = imports.next();assertT("Expected type of ImportFact",fact instanceof ImportFact);ImportFact impFact = (ImportFact) fact;assertEq("Expecting 'java.util' in Imports.", "java.util", impFact.getImportPackage() );    }    public void testImport2() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_2 );assertEq("Expected two results.", 2, results.size() );boolean sawUtil = false;boolean sawRef = false;ACUFact acu = null;Iterator imports = results.iterator();while (imports.hasNext()) {    Object fact = imports.next();    assertT("Expected type of ImportFact",    fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );    sawUtil = sawUtil |impFact.getImportPackage().equals("java.util");    sawRef = sawRef |impFact.getImportPackage().equals("java.lang.ref");}assertT("Expecting one import of 'java.util'", sawUtil);assertT("Expecting one import of 'java.lang.ref'", sawRef);    }    public void testImportDup() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_DUP );assertEq("Expected two results.", 2, results.size() );ACUFact acu = null;Iterator dups = results.iterator();while (dups.hasNext()) {    Object fact = dups.next();        assertT( "Expected fact to be of ImportFact type.",     fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );        assertT( "Should be On Demand.",     impFact.isOnDemand() );    assertEq("Expected java.util.Map to be imported.",     "java.util", impFact.getImportPackage() );}    }    public void testImportSingle() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_SINGLE );assertEq("Expected one result.", 1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ImportFact type.", fact instanceof ImportFact );ImportFact impFact = (ImportFact) fact;assertT( "Should not be listed as On Demand.", !impFact.isOnDemand() );assertEq("Expected java.util.Map to be imported.", "java.util.Map", impFact.getImportPackage() );    }    public void testClass() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS );assertEq( "Expected one result.",  1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT("Expected fact to be of ClassFact type.",fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass", classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, false, false, false );    }    public void testClassPublic() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_PUBLIC );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, true, false, false, false );    }    public void testClassAbstract() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_ABSTRACT );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, true, false, false );    }        public void testClassInner() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_INNER );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact outer = null;  ClassFact inner = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;          if (classFact.getClassName().equals("Outer")) {  outer = classFact;      }          if (classFact.getClassName().equals("Inner")) {  inner = classFact;      }}    }    public void testClassAnon() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_ANON );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact named = null;  ClassFact anon = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;      if (classFact.getOuterClass() == null) {  named = classFact;      } else {  anon = classFact;      }  }  assertNotNull( "Expected to find Named class.", named );  assertNotNull( "Expected to find Anon class.", anon );  assertEq( "Expected both classes to have same ACU.",    named.getACU(), anon.getACU() );  assertEq( "Expected Outer Class of Anon to be Named.",    named, anon.getOuterClass() );    }        public void assertEq( String message,  Object expected,  Object result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }        public void assertEq( String message,  boolean expected,  boolean result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertEq( String message,  int expected,  int result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertT( String message, boolean cond ) throws Throwable    {try {    assertTrue( message, cond );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public Set collectFacts( Class clazz,     String javaCode )throws Throwable    {RuleBase rules = new RuleBase();FactCollector collector = new FactCollector( clazz );rules.addRule( collector );JavaParser parser =    new JavaParser( new StringReader( javaCode ));ASTCompilationUnit acu =    parser.CompilationUnit();current = acu;WorkingMemory memory = rules.createWorkingMemory();DroolsVisitor IUT = new DroolsVisitor( memory );IUT.visit( acu, null );return collector.getFacts();    }    public void verifyClassFlags( ClassFact classFact,  boolean bPublic,  boolean bAbstract,  boolean bFinal,  boolean bStrict ) throws Throwable    {assertEq("Public: ", bPublic, classFact.isPublic() );assertEq("Abstract: ", bAbstract, classFact.isAbstract() );assertEq("Final: ", bFinal, classFact.isFinal() );assertEq("Strict: ", bStrict, classFact.isStrict() );    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 12:06:26 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.cpd.Tile;import net.sourceforge.pmd.dcpd.*;import java.util.ArrayList;import java.util.List;import java.util.Iterator;public class TileHarvesterTest extends TestCase {    public TileHarvesterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        // do the expansion from 1 to 2 tokens and write those expansions        // back to the mock space so TileHarvester can read them        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    TileExpanderTest.marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        space.setTileWrappers(space.getWrittenEntries());        // now the test        TileHarvester tileGatherer = new TileHarvester(space, job);        Occurrences newOcc = tileGatherer.harvest(occ.size());        assertEquals(2, newOcc.size());*/    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 11:04:26 AM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.jini.space.JavaSpace;import net.jini.core.lease.Lease;import net.sourceforge.pmd.dcpd.*;import net.sourceforge.pmd.cpd.*;import java.io.StringReader;import java.util.Iterator;import java.util.List;import java.util.ArrayList;import java.util.Stack;public class TileExpanderTest extends TestCase {    public TileExpanderTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        List writtenEntries = space.getWrittenEntries();        assertEquals(7, writtenEntries.size());*/    }   public static List marshal(Iterator i) {        List list = new ArrayList();        while (i.hasNext()) {            list.add(i.next());        }        return list;    }    public static TokenSets createTokenSets() throws Throwable {        TokenSets tokenSets = new TokenSets();        TokenList tokenList1 = new TokenList("list1");        JavaTokensTokenizer tokenizer = new JavaTokensTokenizer();        tokenizer.tokenize(tokenList1, new StringReader("public class Foo {}"));        tokenSets.add(tokenList1);        TokenList tokenList2 = new TokenList("list2");        tokenizer.tokenize(tokenList2, new StringReader("public class Bar {}"));        tokenSets.add(tokenList2);        return tokenSets;    }}
/* * User: tom * Date: Sep 6, 2002 * Time: 4:15:46 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.dcpd.Job;import net.sourceforge.pmd.dcpd.TilePlanter;public class TilePlanterTest extends TestCase {    public TilePlanterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        TilePlanter scatterer = new TilePlanter(space, job);        scatterer.plant(occ);        assertEquals(6, space.getWrittenEntries().size());*/    }}