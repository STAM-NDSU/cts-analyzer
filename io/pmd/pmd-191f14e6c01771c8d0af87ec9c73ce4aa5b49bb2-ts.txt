/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class GroovyTokenizerTest extends CpdTextComparisonTest {    GroovyTokenizerTest() {        super(".groovy");    }    @Override    protected String getResourcePrefix() {        return "../lang/groovy/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new GroovyTokenizer();    }    @Test    void testSample() {        doTest("sample");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyForeachStmtTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveTemplateLengthTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoInlineJavaScriptTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoInlineStylesTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedMacroParameterTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.vm.ast.VmParsingHelper;/** * Unit test for VM parsing. */class VmParserTest {    private static final String VM_SRC = "<HTML><BODY>Hello $customer.Name <table> "        + "#foreach($mud in $mudsOnSpecial)" + "  #if ( $customer.hasPurchased($mud) )" + "     <tr>" + "      <td>"        + "       $flogger.getPromo( $mud )" + "    </td>" + "  </tr>" + " #elseif ($customer.broke) do stuff #end"        + "\n " + "#end " + "</table>";    private static final String SRC2 = "#macro(tablerows $color $values ) " + "#foreach( $value in $values ) "        + "<tr><td bgcolor=$color>$value</td></tr> " + "#end " + "#end "        + "#set( $greatlakes = [\"Superior\",\"Michigan\",\"Huron\",\"Erie\",\"Ontario\"] ) "        + "#set( $color = \"blue\" ) " + "<table> " + " #tablerows( $color $greatlakes ) " + "</table>";    private static final String SRC3 = "#if ( $c1 ) #if ( $c2)#end #end";    // private static final String VM_SRC = "#if( $mud == 1 ) blah #if ($dirt ==    // 2) stuff #end #end";    @Test    void testParser() {        VmParsingHelper.DEFAULT.parse(VM_SRC);    }    @Test    void testParser2() {        VmParsingHelper.DEFAULT.parse(SRC2);    }    @Test    void testParser3() {        VmParsingHelper.DEFAULT.parse(SRC3);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vm.VmLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VmLanguageModule.NAME, VmLanguageModule.TERSE_NAME, "",            getLanguage(VmLanguageModule.NAME).getDefaultVersion(), }, });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test velocity's rulesets. */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.perl.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.PerlLanguage;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * */class PerlTokenizerTest extends CpdTextComparisonTest {    PerlTokenizerTest() {        super(".pl");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PerlLanguage().getTokenizer();    }    @Test    void testSample() {        doTest("sample");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static com.github.stefanbirkner.systemlambda.SystemLambda.restoreSystemProperties;import java.io.File;import java.io.PrintStream;import java.io.StringWriter;import java.nio.charset.Charset;import org.apache.tools.ant.BuildEvent;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.BuildListener;import org.apache.tools.ant.Project;import org.apache.tools.ant.ProjectHelper;import org.junit.jupiter.api.AfterAll;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;import net.sourceforge.pmd.util.IOUtil;class AbstractAntTest {    protected Project project;    protected StringBuilder log;    protected StringWriter out;    protected StringWriter err;    protected void configureProject(String filename) {        project = new Project();        project.init();        project.addBuildListener(new AntBuildListener(Project.MSG_INFO));        File antFile = new File(filename);        ProjectHelper.configureProject(project, antFile);    }    @AfterAll    static void resetLogging() {        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    protected void executeTarget(String targetName) {        // restoring system properties: PMDTask might change logging properties        // See Slf4jSimpleConfigurationForAnt and resetLogging        try {            restoreSystemProperties(() -> {                executeTargetImpl(targetName);            });        } catch (BuildException e) {            throw e;        } catch (Exception e) {            throw new RuntimeException(e);        }    }    private void executeTargetImpl(String targetName) {        log = new StringBuilder();        out = new StringWriter();        err = new StringWriter();        PrintStream outStream = new PrintStream(IOUtil.fromWriter(out, Charset.defaultCharset().name()));        PrintStream errStream = new PrintStream(IOUtil.fromWriter(err, Charset.defaultCharset().name()));        synchronized (System.out) {            PrintStream originalOut = System.out;            PrintStream originalErr = System.err;            originalOut.flush();            originalErr.flush();            try {                System.setOut(outStream);                System.setErr(errStream);                project.executeTarget(targetName);            } finally {                System.setOut(originalOut);                System.setErr(originalErr);            }        }    }    private class AntBuildListener implements BuildListener {        private final int logLevel;        private AntBuildListener(int logLevel) {            this.logLevel = logLevel;        }        @Override        public void buildStarted(BuildEvent event) {        }        @Override        public void buildFinished(BuildEvent event) {        }        @Override        public void targetStarted(BuildEvent event) {        }        @Override        public void targetFinished(BuildEvent event) {        }        @Override        public void taskStarted(BuildEvent event) {        }        @Override        public void taskFinished(BuildEvent event) {        }        @Override        public void messageLogged(BuildEvent event) {            if (event.getPriority() > logLevel) {                return;            }            log.append(event.getMessage());        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.fail;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;import org.apache.tools.ant.BuildException;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.util.IOUtil;class PMDTaskTest extends AbstractAntTest {    @BeforeEach    void setUp() {        configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/pmdtasktest.xml");    }    @Test    void testFormatterWithNoToFileAttribute() {        try {            executeTarget("testFormatterWithNoToFileAttribute");            fail("This should throw an exception");        } catch (BuildException ex) {            assertEquals("toFile or toConsole needs to be specified in Formatter", ex.getMessage());        }    }    @Test    void testNoRuleSets() {        try {            executeTarget("testNoRuleSets");            fail("This should throw an exception");        } catch (BuildException ex) {            assertEquals("No rulesets specified", ex.getMessage());        }    }    @Test    void testBasic() {        executeTarget("testBasic");    }    @Test    void testInvalidLanguageVersion() {        try {            executeTarget("testInvalidLanguageVersion");            assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    log.toString());            fail("This should throw an exception");        } catch (BuildException ex) {            assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    ex.getMessage());        }    }    @Test    void testWithShortFilenames() throws IOException {        executeTarget("testWithShortFilenames");        try (InputStream in = Files.newInputStream(Paths.get("target/pmd-ant-test.txt"))) {            String actual = IOUtil.readToString(in, StandardCharsets.UTF_8);            // remove any trailing newline            actual = actual.trim();            assertThat(actual, containsString("sample.dummy:1:\tSampleXPathRule:\tTest Rule 2"));        }    }    @Test    void testXmlFormatter() throws IOException {        executeTarget("testXmlFormatter");        try (InputStream in = Files.newInputStream(Paths.get("target/pmd-ant-xml.xml"));             InputStream expectedStream = PMDTaskTest.class.getResourceAsStream("xml/expected-pmd-ant-xml.xml")) {            String actual = IOUtil.readToString(in, StandardCharsets.UTF_8);            actual = actual.replaceFirst("timestamp=\"[^\"]+\"", "timestamp=\"\"");            actual = actual.replaceFirst("\\.xsd\" version=\"[^\"]+\"", ".xsd\" version=\"\"");            String expected = IOUtil.readToString(expectedStream, StandardCharsets.UTF_8);            expected = expected.replaceFirst("timestamp=\"[^\"]+\"", "timestamp=\"\"");            expected = expected.replaceFirst("\\.xsd\" version=\"[^\"]+\"", ".xsd\" version=\"\"");            assertEquals(expected, actual);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.fail;import java.io.File;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;class FormatterTest {    @Test    void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.createRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.createRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.createRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.createRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            f.createRenderer();            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException be) {            assertTrue(be.getMessage().startsWith("Can't find the custom format FAIL"));        }    }    @Test    void testNull() {        Formatter f = new Formatter();        assertTrue(f.isNoOutputSupplied(), "Formatter toFile should start off null!");        f.setToFile(new File("foo"));        assertFalse(f.isNoOutputSupplied(), "Formatter toFile should not be null!");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;/** * * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */class CPDTaskTest extends AbstractAntTest {    @BeforeEach    void setUp() {        configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/cpdtasktest.xml");    }    @Test    void testBasic() {        executeTarget("testBasic");        // FIXME: This clearly needs to be improved - but I don't like to write        // test, so feel free to contribute :)        assertTrue(new File("target/cpd.ant.tests").exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;class ToDateToCharTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATE_TO_CHAR");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;class ToDateWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATEWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;class ToTimestampWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_TIMESTAMPWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NcssObjectCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessivePackageSpecificationLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveTypeLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessivePackageBodyLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NPathComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveObjectLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class CodeFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LineLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidTabCharacterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForLoopNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class MisplacedPragmaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class TomKytesDespairTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class InsertIntoClauseTest extends AbstractPLSQLParserTst {    @Test    void parseInsertInto() {        plsql.parseResource("InsertIntoClause.pls");    }    @Test    void parseInsertIntoReturning() {        plsql.parseResource("InsertIntoClauseReturning.pls");    }    @Test    void parseInsertIntoWithRecord() {        plsql.parseResource("InsertIntoClauseRecord.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class XMLElementTest extends AbstractPLSQLParserTst {    @Test    void testParseXMLElement() {        ASTInput input = plsql.parseResource("XMLElement.pls");        List<ASTXMLElement> xmlelements = input.findDescendantsOfType(ASTXMLElement.class);        assertEquals(10, xmlelements.size());        assertEquals("\"Emp\"", xmlelements.get(0).getFirstChildOfType(ASTID.class).getImage());        assertTrue(xmlelements.get(3).getChild(1) instanceof ASTXMLAttributesClause);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class CursorForLoopTest extends AbstractPLSQLParserTst {    @Test    void parseCursorForLoopSimple() {        ASTInput input = plsql.parseResource("CursorForLoopSimple.pls");        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        assertNotNull(forindex);        assertEquals("someone", forindex.getImage());    }    @Test    void parseCursorForLoopNested() {        ASTInput input = plsql.parseResource("CursorForLoopNested.pls");        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        assertNotNull(forindex);        assertEquals("c_cmp", forindex.getImage());        ASTCursorForLoopStatement forloop2 = forloop.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex2 = forloop2.getFirstChildOfType(ASTForIndex.class);        assertEquals("c_con", forindex2.getImage());        ASTCursorForLoopStatement forloop3 = forloop2.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex3 = forloop3.getFirstChildOfType(ASTForIndex.class);        assertEquals("c_pa", forindex3.getImage());    }    @Test    void parseCursorForLoop1047a() {        ASTInput input = plsql.parseResource("CursorForLoop1047a.pls");        assertNotNull(input);    }    @Test    void parseCursorForLoop1047b() {        ASTInput input = plsql.parseResource("CursorForLoop1047b.pls");        assertNotNull(input);    }    @Test    void parseCursorForLoop681() {        ASTInput input = plsql.parseResource("CursorForLoop681.pls");        assertNotNull(input);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class MultipleDDLStatementsTest extends AbstractPLSQLParserTst {    @Test    void parseDDLCommands() throws Exception {        ASTInput input = plsql.parseResource("DDLCommands.sql");        List<ASTDDLCommand> ddlcommands = input.findDescendantsOfType(ASTDDLCommand.class);        assertEquals(6, ddlcommands.size());        List<ASTComment> comments = input.findDescendantsOfType(ASTComment.class);        assertEquals(5, comments.size());        assertEquals("'abbreviated job title'", comments.get(0).getFirstChildOfType(ASTStringLiteral.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class JoinClauseTest extends AbstractPLSQLParserTst {    @Test    void testInnerCrossJoin() {        ASTInput input = plsql.parseResource("InnerCrossJoin.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        assertEquals(1, joins.size());        assertTrue(joins.get(0).isCross());        assertFalse(joins.get(0).isNatural());    }    @Test    void testInnerNaturalJoin() {        ASTInput input = plsql.parseResource("InnerNaturalJoin.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        assertEquals(2, joins.size());        assertFalse(joins.get(0).isCross());        assertTrue(joins.get(0).isNatural());    }    @Test    void testInnerJoinUsing() {        ASTInput input = plsql.parseResource("InnerJoinUsing.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        assertEquals(3, joins.size());        assertFalse(joins.get(0).isCross());        assertFalse(joins.get(0).isNatural());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        assertEquals(1, columns.size());        assertEquals("department_id", columns.get(0).getImage());    }    @Test    void testOuterJoinUsing() {        ASTInput input = plsql.parseResource("OuterJoinUsing.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        assertEquals(ASTOuterJoinType.Type.FULL, type.getType());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        assertEquals(1, columns.size());        assertEquals("department_id", columns.get(0).getImage());    }    @Test    void testRightOuterJoin() {        ASTInput input = plsql.parseResource("RightOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());    }    @Test    void testLeftOuterJoin() {        ASTInput input = plsql.parseResource("LeftOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        assertEquals(ASTOuterJoinType.Type.LEFT, type.getType());        List<ASTSelectStatement> selects = input.findDescendantsOfType(ASTSelectStatement.class);        assertEquals(2, selects.size());        assertTrue(selects.get(0).getFromClause().getChild(0) instanceof ASTJoinClause);        assertTrue(selects.get(1).getFromClause().getChild(0) instanceof ASTJoinClause);    }    @Test    void testNaturalRightOuterJoin() {        ASTInput input = plsql.parseResource("NaturalRightOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        assertTrue(joins.get(0).isNatural());    }    @Test    void testOuterJoinPartitioned() {        ASTInput input = plsql.parseResource("OuterJoinPartitioned.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        assertNotNull(joins.get(0).getFirstChildOfType(ASTQueryPartitionClause.class));    }    @Test    void testFullOuterJoin() {        plsql.parseResource("FullOuterJoin.pls");    }    @Test    void testInnerJoinSubquery() {        plsql.parseResource("InnerJoinSubquery.pls");    }    @Test    void testJoinOperator() {        ASTInput input = plsql.parseResource("JoinOperator.pls");        List<ASTOuterJoinExpression> expressions = input.findDescendantsOfType(ASTOuterJoinExpression.class);        assertEquals(4, expressions.size());        assertEquals("h.opp_id", expressions.get(3).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class CursorAttributesTest extends AbstractPLSQLParserTst {    @Test    void parseCursorWithAttribute() {        ASTInput input = plsql.parseResource("CursorAttributes.pls");        ASTExpression exp = input.getFirstDescendantOfType(ASTIfStatement.class).getFirstChildOfType(ASTExpression.class);        assertEquals("TestSearch%notfound", exp.getImage());    }    @Test    void parseImplicitCursorAttributeBulkExceptions() {        plsql.parseResource("CursorAttributesBulkExceptions.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class ASTFetchStatementTest extends AbstractPLSQLParserTst {    @Test    void testBulkCollectLimit() {        ASTInput input = plsql.parseResource("FetchStatementBulkCollectLimit.pls");        List<ASTFetchStatement> fetchStatements = input.findDescendantsOfType(ASTFetchStatement.class);        assertEquals(1, fetchStatements.size());        ASTFetchStatement fetch = fetchStatements.get(0);        assertTrue(fetch.isBulkCollect());        assertTrue(fetch.isLimit());    }    @Test    void testFetch() {        ASTInput input = plsql.parseResource("FetchStatement.pls");        List<ASTFetchStatement> fetchStatements = input.findDescendantsOfType(ASTFetchStatement.class);        assertEquals(1, fetchStatements.size());        ASTFetchStatement fetch = fetchStatements.get(0);        assertFalse(fetch.isBulkCollect());        assertFalse(fetch.isLimit());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class DeleteStatementTest extends AbstractPLSQLParserTst {    @Test    void parseDeleteStatementExample() {        ASTInput input = plsql.parseResource("DeleteStatementExample.pls");        List<ASTDeleteStatement> deleteStatements = input.findDescendantsOfType(ASTDeleteStatement.class);        assertEquals(3, deleteStatements.size());        assertEquals("product_descriptions", deleteStatements.get(0).getChild(0)                                                                    .getFirstChildOfType(ASTTableName.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SelectUnionTest extends AbstractPLSQLParserTst {    @Test    void parseSelectUnion() {        plsql.parseResource("SelectUnion.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SelectIntoWithGroupByTest extends AbstractPLSQLParserTst {    @Test    void testExample1() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy1.pls");        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        assertNotNull(groupByClause);    }    @Test    void testExample2() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy2.pls");        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        assertNotNull(groupByClause);    }    @Test    void testExample3WithCube() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy3.pls");        ASTRollupCubeClause cubeClause = input.getFirstDescendantOfType(ASTRollupCubeClause.class);        assertNotNull(cubeClause);        assertEquals("CUBE", cubeClause.getImage());    }    @Test    void testExample4WithGroupingSets() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy4.pls");        ASTGroupingSetsClause groupingSetsClause = input.getFirstDescendantOfType(ASTGroupingSetsClause.class);        assertNotNull(groupingSetsClause);        List<ASTFromClause> fromClauses = input.findDescendantsOfType(ASTFromClause.class);        assertEquals(1, fromClauses.size());        assertEquals(5, fromClauses.get(0).getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SelectForUpdateTest extends AbstractPLSQLParserTst {    @Test    void parseSelectForUpdateWait() {        ASTInput input = plsql.parseResource("SelectForUpdateWait.pls");        assertNotNull(input);        assertEquals(5, input.findDescendantsOfType(ASTForUpdateClause.class).size());    }    @Test    void parseSelectForUpdate() {        ASTInput input = plsql.parseResource("SelectForUpdate.pls");        assertNotNull(input);        List<ASTForUpdateClause> forUpdateClauses = input.findDescendantsOfType(ASTForUpdateClause.class);        assertEquals(2, forUpdateClauses.size());        assertEquals(2, forUpdateClauses.get(1).getNumChildren());        assertEquals("e", forUpdateClauses.get(1).getChild(0).getImage());        assertEquals("salary", forUpdateClauses.get(1).getChild(1).getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertTimeout;import java.time.Duration;import java.time.temporal.ChronoUnit;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class PLSQLParserTest extends AbstractPLSQLParserTst {    @Test    void testExceptions() {        plsql.parse("CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                       + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                       + "        doSomethingElse;" + "END;");    }    /**     * See https://sourceforge.net/p/pmd/bugs/1167/     */    @Test    void testBOM() {        plsql.parse("\ufeff" + "CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                       + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                       + "        doSomethingElse;" + "END;");    }    @Test    void testBug1531() {        assertTimeout(Duration.of(5, ChronoUnit.SECONDS), () ->            plsql.parse("create or replace force view oxa.o_xa_function_role_types as\n"                           + "select \"CFT_ID\",\"CFR_ID\",\"CFT_NAME\",\"TCN\",\"LOG_MODULE\",\"LOG_USER\",\"LOG_DATE\",\"LOG_TIME\" from crm_function_role_types\n"                           + "/"));    }    @Test    void testBug1527() {        plsql.parseResource("InlinePragmaProcError.pls");    }    @Test    void testBug1520IsOfType() {        plsql.parseResource("IsOfType.pls");    }    @Test    void testBug1520Using() {        plsql.parseResource("Using.pls");    }    @Test    void testSingleLineSelect() {        plsql.parseResource("SingleLineSelect.pls");    }    @Test    void testMultiLineSelect() {        plsql.parseResource("MultiLineSelect.pls");    }    @Test    void testIsNull() {        plsql.parseResource("IsNull.pls");    }    @Test    void testCodingStyleExample() {        plsql.parseResource("CodingStyleExample.pls");    }    @Test    void testCaseIssue1454() {        plsql.parseResource("CaseIssue1454.pls");    }    @Test    void testRelationalOperators() {        // https://github.com/pmd/pmd/issues/3746        plsql.parseResource("RelationalOperators.pls");    }    @Test    void testExecuteImmediateIssue3106() {        plsql.parseResource("ExecuteImmediateIssue3106.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class InOutNoCopyTest extends AbstractPLSQLParserTst {    @Test    void parseInOutNoCopy() {        ASTInput input = plsql.parseResource("InOutNoCopy.pls");        assertNotNull(input);        List<ASTFormalParameter> params = input.findDescendantsOfType(ASTFormalParameter.class);        assertEquals(18, params.size());        //detailed check of first 6 test cases        assertFalse(params.get(0).isIn());        assertFalse(params.get(0).isOut());        assertFalse(params.get(0).isNoCopy());        assertTrue(params.get(1).isIn());        assertFalse(params.get(1).isOut());        assertFalse(params.get(1).isNoCopy());        assertFalse(params.get(2).isIn());        assertTrue(params.get(2).isOut());        assertFalse(params.get(2).isNoCopy());        assertTrue(params.get(3).isIn());        assertTrue(params.get(3).isOut());        assertFalse(params.get(3).isNoCopy());        assertTrue(params.get(4).isIn());        assertTrue(params.get(4).isOut());        assertTrue(params.get(4).isNoCopy());        assertFalse(params.get(5).isIn());        assertTrue(params.get(5).isOut());        assertTrue(params.get(5).isNoCopy());        //piecemeal test of other test cases        assertFalse(params.get(11).isIn());        assertTrue(params.get(11).isOut());        assertTrue(params.get(11).isNoCopy());        assertTrue(params.get(16).isIn());        assertTrue(params.get(16).isOut());        assertTrue(params.get(16).isNoCopy());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SelectExpressionsTest extends AbstractPLSQLParserTst {    @Test    void parseSelectExpression() {        plsql.parseResource("SelectExpressions.pls");    }    @Test    void parseSelectSimpleExpression() {        ASTInput input = plsql.parseResource("SelectSimpleExpression.pls");        assertNotNull(input);        List<ASTSimpleExpression> simpleExpressions = input.findDescendantsOfType(ASTSimpleExpression.class);        assertEquals(1, simpleExpressions.size());        ASTSimpleExpression exp = simpleExpressions.get(0);        assertEquals("e.first_name", exp.getImage());        assertEquals(2, exp.getNumChildren());        assertEquals(ASTTableName.class, exp.getChild(0).getClass());        assertEquals(ASTColumn.class, exp.getChild(1).getClass());    }    @Test    void parseSelectCount() {        plsql.parseResource("SelectCount.pls");    }    @Test    void parseSelectSubqueryExpression() {        plsql.parseResource("SelectSubqueryExpressions.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class CreateTableTest extends AbstractPLSQLParserTst {    @Test    void parseCreateTable() {        ASTInput input = plsql.parseResource("CreateTable.pls");        // 5th column of first table statement has a inline constraint of type check        ASTTableColumn columnStatus = input.findChildrenOfType(ASTTable.class).get(0).findChildrenOfType(ASTTableColumn.class).get(4);        assertEquals("status", columnStatus.getFirstChildOfType(ASTID.class).getImage());        assertEquals(ConstraintType.CHECK, columnStatus.getFirstChildOfType(ASTInlineConstraint.class).getType());    }    @Test    void parseCreateOrganizedTable() {        plsql.parseResource("CreateOrganizedTable.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class TrimWithRecordTypeTest extends AbstractPLSQLParserTst {    @Test    void parseTrimWithRecordType() {        plsql.parseResource("TrimWithRecordType.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class WhereClauseTest extends AbstractPLSQLParserTst {    @Test    void testFunctionCall() {        ASTInput input = plsql.parseResource("WhereClauseFunctionCall.pls");        List<ASTSelectIntoStatement> selectStatements = input.findDescendantsOfType(ASTSelectIntoStatement.class);        assertEquals(4, selectStatements.size());        ASTFunctionCall functionCall = selectStatements.get(0).getFirstDescendantOfType(ASTFunctionCall.class);        assertEquals("UPPER", functionCall.getImage());        ASTFunctionCall functionCall2 = selectStatements.get(2).getFirstDescendantOfType(ASTFunctionCall.class);        assertEquals("utils.get_colname", functionCall2.getImage());    }    @Test    void testLikeCondition() {        plsql.parseResource("WhereClauseLike.pls");    }    @Test    void testNullCondition() {        plsql.parseResource("WhereClauseIsNull.pls");    }    @Test    void testBetweenCondition() {        plsql.parseResource("WhereClauseBetween.pls");    }    @Test    void testInCondition() {        plsql.parseResource("WhereClauseIn.pls");    }    @Test    void testIsOfTypeCondition() {        plsql.parseResource("WhereClauseIsOfType.pls");    }    @Test    void testConcatenationOperator() {        plsql.parseResource("WhereClauseConcatenation.pls");    }    @Test    void testExistsCondition() {        plsql.parseResource("WhereClauseExists.pls");    }    @Test    void testMultisetCondition() {        plsql.parseResource("WhereClauseMultiset.pls");    }    @Test    void testRegexpLikeCondition() {        ASTInput input = plsql.parseResource("WhereClauseRegexpLike.pls");        List<ASTRegexpLikeCondition> regexps = input.findDescendantsOfType(ASTRegexpLikeCondition.class);        assertEquals(3, regexps.size());        assertEquals("last_name", regexps.get(1).getSourceChar().getImage());        assertEquals("'([aeiou])\\1'", regexps.get(1).getPattern().getImage());        assertEquals("'i'", regexps.get(1).getMatchParam());    }    @Test    void testSubqueries() {        plsql.parseResource("WhereClauseSubqueries.pls");    }    @Test    void testParentheses() {        plsql.parseResource("WhereClauseParens.pls");    }    @Test    void testCurrentOf() {        plsql.parseResource("WhereCurrentOf.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class AnonymousBlockTest extends AbstractPLSQLParserTst {    @Test    void parseCursorInsideProcAnonymousBlock() {        plsql.parseResource("AnonymousBlock1.sql");    }    @Test    void parseCursorInsideAnonymousBlock() {        plsql.parseResource("AnonymousBlock2.sql");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class TriggerTest extends AbstractPLSQLParserTst {    /**     * Parsing a trigger should not result in a NPE.     *     * @see <a href="https://github.com/pmd/pmd/issues/2325">#2325 [plsql] NullPointerException while running parsing test for CREATE TRIGGER</a>     */    @Test    void parseCreateTrigger() {        ASTInput input = plsql.parseResource("TriggerUnit.pls");        PLSQLNode trigger = input.getChild(0);        assertEquals(ASTTriggerUnit.class, trigger.getClass());        assertNotNull(trigger.getScope());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class CursorWithWithTest extends AbstractPLSQLParserTst {    @Test    void parseCursorWithWith() {        ASTInput input = plsql.parseResource("CursorWithWith.pls");        ASTCursorUnit cursor = input.getFirstDescendantOfType(ASTCursorUnit.class);        ASTSelectStatement select = (ASTSelectStatement) cursor.getChild(1);        ASTWithClause with = (ASTWithClause) select.getChild(0);        ASTName queryName = (ASTName) with.getChild(0);        assertEquals("risk_set", queryName.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.plsql.PlsqlParsingHelper;class ParenthesisGroupTest extends BaseTreeDumpTest {    ParenthesisGroupTest() {        super(new RelevantAttributePrinter(), ".pls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return PlsqlParsingHelper.DEFAULT.withResourceContext(getClass());    }    @Test    void parseParenthesisGroup0() {        doTest("ParenthesisGroup0");    }    @Test    void parseParenthesisGroup1() {        doTest("ParenthesisGroup1");    }    @Test    void parseParenthesisGroup2() {        doTest("ParenthesisGroup2");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SlashAsDivisionTest extends AbstractPLSQLParserTst {    @Test    void parseSlashAsDivision() {        plsql.parseResource("SlashAsDivision.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SelectHierarchicalTest extends AbstractPLSQLParserTst {    @Test    void parseSelectHierarchicalQueries() {        plsql.parseResource("SelectHierarchical.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.plsql.PlsqlParsingHelper;class PlsqlTreeDumpTest extends BaseTreeDumpTest {    PlsqlTreeDumpTest() {        super(new RelevantAttributePrinter(), ".pls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return PlsqlParsingHelper.DEFAULT.withResourceContext(getClass());    }    @Test    void sqlPlusLexicalVariables() {        doTest("SqlPlusLexicalVariablesIssue195");    }    @Test    void parseParsingExclusion() {        doTest("ParsingExclusion");    }    @Test    void parseOpenForStatement() {        doTest("OpenForStatement");    }    @Test    void parseSelectIntoAssociativeArrayType() {        doTest("SelectIntoArray");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class XMLTableTest extends AbstractPLSQLParserTst {    @Test    void testParseXMLTable() {        ASTInput node = plsql.parseResource("XMLTable.pls");        List<ASTFunctionCall> functions = node.findDescendantsOfType(ASTFunctionCall.class);        ASTFunctionCall xmlforest = functions.get(functions.size() - 1);        assertEquals("XMLFOREST", xmlforest.getImage());        assertEquals("e.employee_id", xmlforest.getChild(1).getImage());        assertEquals("foo", xmlforest.getChild(2).getImage());        assertTrue(xmlforest.getChild(2) instanceof ASTID);        assertEquals("e.last_name", xmlforest.getChild(3).getImage());        assertEquals("last_name", xmlforest.getChild(4).getImage());        assertTrue(xmlforest.getChild(4) instanceof ASTID);        assertEquals("e.salary", xmlforest.getChild(5).getImage());        assertEquals(6, xmlforest.getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class ViewTest extends AbstractPLSQLParserTst {    @Test    void parseCreateViewIssue981() {        plsql.parseResource("ViewIssue981.pls");    }    @Test    void parseCreateView() {        plsql.parseResource("CreateViewWithSubquery.pls");    }    @Test    void parseCreateViewWithoutSemicolon() {        plsql.parseResource("QueryWithoutSemicolon.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class RecordTypeTest extends AbstractPLSQLParserTst {    @Test    void parseRecordType() {        plsql.parseResource("RecordType.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class FunctionsTest extends AbstractPLSQLParserTst {    @Test    void parseTrimCall() {        plsql.parseResource("TrimFunction.pls");    }    @Test    void parseSelectExtractExpression() {        plsql.parseResource("ExtractExpressions.pls");    }    @Test    void parseXMLExpression() {        plsql.parseResource("XMLFunctions.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class SelectIntoStatementTest extends AbstractPLSQLParserTst {    @Test    void testParsingComplex() {        plsql.parseResource("SelectIntoStatement.pls");    }    @Test    void testParsingExample1() {        plsql.parseResource("SelectIntoStatementExample1.pls");    }    @Test    void testParsingExample2() {        plsql.parseResource("SelectIntoStatementExample2.pls");    }    @Test    void testParsingExample3() {        plsql.parseResource("SelectIntoStatementExample3.pls");    }    @Test    void testParsingExample4() {        plsql.parseResource("SelectIntoStatementExample4.pls");    }    @Test    void testParsingExample5() {        plsql.parseResource("SelectIntoStatementExample5.pls");    }    @Test    void testParsingExample6Invalid() {        assertThrows(ParseException.class, () -> plsql.parseResource("SelectIntoStatementExample6Invalid.pls"));    }    @Test    void testParsingWithFunctionCall() {        plsql.parseResource("SelectIntoStatementFunctionCall.pls");    }    @Test    void testParsingIntoRecordField() {        plsql.parseResource("SelectIntoStatementRecordField.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertNotNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class IfStatementTest extends AbstractPLSQLParserTst {    @Test    void parseIfWithElseIf() throws Exception {        String code = "BEGIN\nIF 1 = 1 THEN null;\nELSIF (2 = 2) THEN null;\nELSE null;\nEND IF;\nEND;\n/\n";        ASTInput input = plsql.parse(code);        assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class ExecuteImmediateTest extends AbstractPLSQLParserTst {    @Test    void parseExecuteImmediate1047a() {        plsql.parseResource("ExecuteImmediate1047a.pls");    }    @Test    void parseExecuteImmediate1047b() {        plsql.parseResource("ExecuteImmediate1047b.pls");    }    @Test    void parseExecuteImmediateString() {        plsql.parseResource("ExecuteImmediateString.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class ASTSqlStatementTest extends AbstractPLSQLParserTst {    @Test    void testCommit() {        ASTInput input = plsql.parseResource("CommitStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        assertEquals(1, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.COMMIT);    }    @Test    void testRollback() {        ASTInput input = plsql.parseResource("RollbackStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        assertEquals(1, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.ROLLBACK);    }    @Test    void testSavepoint() {        ASTInput input = plsql.parseResource("SavepointStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        assertEquals(2, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.SAVEPOINT);        assertType(sqlStatements, 1, ASTSqlStatement.Type.ROLLBACK);    }    @Test    void testSetTransaction() {        ASTInput input = plsql.parseResource("SetTransactionStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        assertEquals(3, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.COMMIT);        assertType(sqlStatements, 1, ASTSqlStatement.Type.SET_TRANSACTION);        assertType(sqlStatements, 2, ASTSqlStatement.Type.COMMIT);    }    private void assertType(List<ASTSqlStatement> sqlStatements, int index, ASTSqlStatement.Type expectedType) {        assertEquals(expectedType, sqlStatements.get(index).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class UpdateStatementTest extends AbstractPLSQLParserTst {    @Test    void parseUpdateStatementExample() {        ASTInput input = plsql.parseResource("UpdateStatementExample.pls");        List<ASTUpdateStatement> updateStatements = input.findDescendantsOfType(ASTUpdateStatement.class);        assertEquals(2, updateStatements.size());        assertEquals(2, updateStatements.get(1).getFirstChildOfType(ASTUpdateSetClause.class)                .findChildrenOfType(ASTColumn.class).size());    }    @Test    void parseUpdateStatementExample2() {        ASTInput input = plsql.parseResource("UpdateStatementExample2.pls");        assertNotNull(input);    }    @Test    void parseUpdateStatementRef() {        ASTInput input = plsql.parseResource("UpdateStatementRef.pls");        assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class ASTCompoundConditionTest extends AbstractPLSQLParserTst {    @Test    void testParseType() {        ASTInput input = plsql.parse("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1 AnD user_id = 2; END;");        List<ASTCompoundCondition> compoundConditions = input.findDescendantsOfType(ASTCompoundCondition.class);        assertFalse(compoundConditions.isEmpty());        assertEquals("AND", compoundConditions.get(0).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.platform.suite.api.SelectClasses;import org.junit.platform.suite.api.Suite;@Suite@SelectClasses({    PlsqlTreeDumpTest.class,    ParenthesisGroupTest.class,    ExecuteImmediateBulkCollectTest.class})class AllPlsqlAstTreeDumpTest {}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTExtractExpressionTest extends AbstractPLSQLParserTst {    @Test    void testXml() {        ASTInput unit = plsql.parse("SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks', "                + "'xmlns:a=\"http://warehouse/1\" xmlns:b=\"http://warehouse/2\"') \"Number of Docks\" "                + " FROM warehouses WHERE warehouse_spec IS NOT NULL;");        ASTExtractExpression extract = unit.getFirstDescendantOfType(ASTExtractExpression.class);        assertTrue(extract.isXml());        assertEquals("/Warehouse/Docks", extract.getXPath());        assertEquals("xmlns:a=\"http://warehouse/1\" xmlns:b=\"http://warehouse/2\"", extract.getNamespace());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class OrderByExpressionsTest extends AbstractPLSQLParserTst {    @Test    void parseOrderByExpression() {        plsql.parseResource("OrderByExpression.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.plsql.PlsqlParsingHelper;class ExecuteImmediateBulkCollectTest extends BaseTreeDumpTest {    ExecuteImmediateBulkCollectTest() {        super(new RelevantAttributePrinter(), ".pls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return PlsqlParsingHelper.DEFAULT.withResourceContext(getClass());    }    @Test    void testExecuteImmediateBulkCollect1() {        doTest("ExecuteImmediateBulkCollect1");    }    @Test    void testExecuteImmediateBulkCollect2() {        doTest("ExecuteImmediateBulkCollect2");    }    @Test    void testExecuteImmediateBulkCollect3() {        doTest("ExecuteImmediateBulkCollect3");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class ASTComparisonConditionTest extends AbstractPLSQLParserTst {    @Test    void testOperator() {        ASTInput input = plsql.parse("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1; END;");        List<ASTComparisonCondition> conditions = input.findDescendantsOfType(ASTComparisonCondition.class);        assertEquals(1, conditions.size());        assertEquals("=", conditions.get(0).getOperator());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class LexicalParametersTest extends AbstractPLSQLParserTst {    @Test    void parseLexicalParameters() {        plsql.parseResource("LexicalParameters.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class TableCollectionExpressionTest extends AbstractPLSQLParserTst {    @Test    void testExamples() {        plsql.parseResource("TableCollectionExpressionExamples.pls");    }    @Test    void testIssue1526() {        plsql.parseResource("TableCollectionExpressionIssue1526.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class StringLiteralsTest extends AbstractPLSQLParserTst {    @Test    void parseStringLiterals() throws Exception {        ASTInput input = plsql.parseResource("StringLiterals.pls");        List<ASTStringLiteral> strings = input.findDescendantsOfType(ASTStringLiteral.class);        assertEquals(20, strings.size());        assertString("'Hello'", "Hello", 0, strings);        assertString("N'nchar literal'", "nchar literal", 4, strings);        assertString("nQ'[ab']cd]'", "ab']cd", 11, strings);        assertString("Q'{SELECT * FROM employees WHERE last_name = 'Smith';}'",                "SELECT * FROM employees WHERE last_name = 'Smith';", 13, strings);        assertString("q'{\n" + "    also multiple\n" + "    lines\n" + "  }'",                "\n" + "    also multiple\n" + "    lines\n" + "  ", 15, strings);    }    @Test    void parseMultilineVarchar() throws Exception {        ASTInput input = plsql.parseResource("MultilineVarchar.pls");        List<ASTStringLiteral> strings = input.findDescendantsOfType(ASTStringLiteral.class);        assertEquals(1, strings.size());        assertTrue(normalizeEol(strings.get(0).getString()).startsWith("\ncreate or replace and"));    }    private static void assertString(String quoted, String plain, int index, List<ASTStringLiteral> strings) {        assertEquals(quoted, normalizeEol(strings.get(index).getImage()));        assertEquals(plain, normalizeEol(strings.get(index).getString()));    }    private static String normalizeEol(String s) {        return s.replaceAll("\r\n|\n\r|\n|\r", "\n");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;/** * Tests to use XPath rules with PLSQL. */class PLSQLXPathRuleTest extends AbstractPLSQLParserTst {    private static final String SOURCE =        "create or replace\n" + "package pkg_xpath_problem\n" + "AS\n" + "    PROCEDURE pkg_minimal\n" + "    IS\n"            + "        a_variable VARCHAR2(1);\n" + "    BEGIN \n" + "        --PRAGMA INLINE(output,'YES');\n"            + "        a_variable := 'Y' ;\n" + "    END ;\n" + "end pkg_xpath_problem;\n" + "/\n";    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    void testXPathRule1() {        testOnVersion(XPathVersion.XPATH_1_0);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    void testXPathRule1Compatibility() {        testOnVersion(XPathVersion.XPATH_1_0_COMPATIBILITY);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    void testXPathRule2() {        testOnVersion(XPathVersion.XPATH_2_0);    }    private void testOnVersion(XPathVersion xpath10) {        XPathRule rule = plsql.newXpathRule("//PrimaryPrefix", xpath10);        Report report = plsql.executeRule(rule, SOURCE);        assertEquals(2, report.getViolations().size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class PLSQLTokenizerTest extends CpdTextComparisonTest {    PLSQLTokenizerTest() {        super(".sql");    }    @Override    protected String getResourcePrefix() {        return "../lang/plsql/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PLSQLTokenizer();    }        @Test    void testSimple() {        doTest("sample-plsql");    }    @Test    void testSpecialComments() {        doTest("specialComments");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.File;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;class LanguageVersionDiscovererTest extends AbstractPLSQLParserTst {    /**     * Test on PLSQL file with default version     */    @Test    void testPlsql() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(LanguageRegistry.PMD);        File plsqlFile = new File("/path/to/MY_PACKAGE.sql");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(plsqlFile);        assertEquals(plsql.getLanguage().getDefaultVersion(), languageVersion,                "LanguageVersion must be PLSQL!");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { PLSQLLanguageModule.NAME, PLSQLLanguageModule.TERSE_NAME, "",            getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test plsql's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForceCastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForceTryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnavailableFunctionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ProhibitedInterfaceBuilderTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.ast;import org.checkerframework.checker.nullness.qual.NonNull;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.NodePrintersKt;/** * */public class BaseSwiftTreeDumpTest extends BaseTreeDumpTest {    public BaseSwiftTreeDumpTest() {        super(NodePrintersKt.getSimpleNodePrinter(), ".swift");    }    @NonNull    @Override    public SwiftParsingHelper getParser() {        return SwiftParsingHelper.DEFAULT.withResourceContext(getClass(), "testdata");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class SwiftTokenizerTest extends CpdTextComparisonTest {    SwiftTokenizerTest() {        super(".swift");    }    @Override    protected String getResourcePrefix() {        return "../lang/swift/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new SwiftTokenizer();    }    @Test    void testSwift42() {        doTest("Swift4.2");    }    @Test    void testSwift50() {        doTest("Swift5.0");    }    @Test    void testSwift51() {        doTest("Swift5.1");    }    @Test    void testSwift52() {        doTest("Swift5.2");    }    @Test    void testStackoverflowOnLongLiteral() {        doTest("Issue628");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli.commands.internal;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import java.nio.file.Path;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.util.CollectionUtil;class PmdCommandTest extends BaseCommandTest<PmdCommand> {    @Test    void testVersionGiven() throws Exception {        final PmdCommand cmd = setupAndParse("--use-version", "dummy-1.2", "-d", "a", "-R", "x.xml");        final LanguageVersion dummyLatest = cmd.toConfiguration().getLanguageVersionOfFile("foo.dummy");                // LanguageVersion do not implement equals, but we can check their string representations        assertEquals(DummyLanguageModule.getInstance().getVersion("1.2").toString(), dummyLatest.toString());    }    @Test    void testMultipleDirsAndRuleSets() {        final PmdCommand cmd = setupAndParse(            "-d", "a", "b", "-R", "x.xml", "y.xml"        );        assertMultipleDirsAndRulesets(cmd);    }    @Test    void testMultipleDirsAndRuleSetsWithCommas() {        final PmdCommand cmd = setupAndParse(            "-d", "a,b", "-R", "x.xml,y.xml"        );        assertMultipleDirsAndRulesets(cmd);    }    @Test    void testMultipleDirsAndRuleSetsWithRepeatedOption() {        final PmdCommand cmd = setupAndParse(            "-d", "a", "-d", "b", "-R", "x.xml", "-R", "y.xml"        );        assertMultipleDirsAndRulesets(cmd);    }    @Test    void testNoPositionalParametersAllowed() {        final PmdCommand cmd = setupAndParse(            "-R", "x.xml", "-R", "y.xml", "-d", "a", "--", "b"        );        assertMultipleDirsAndRulesets(cmd);    }    @Test    void testEmptyDirOption() {        assertError("-d", "-R", "y.xml");    }    @Test    void testEmptyRulesetOption() {        assertError("-R", "-d", "something");    }    private void assertMultipleDirsAndRulesets(final PmdCommand result) {        final PMDConfiguration config = result.toConfiguration();        assertEquals(listOf("a", "b"), CollectionUtil.map(config.getInputPathList(), Path::toString));        assertEquals(listOf("x.xml", "y.xml"), config.getRuleSetPaths());    }    @Override    protected PmdCommand createCommand() {        return new PmdCommand();    }    @Override    protected void addStandardParams(final List<String> argList) {        // If no language provided, set dummy latest        if (!argList.contains("--use-version")) {            argList.add(0, "--use-version");            argList.add(1, "dummy-1.0");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli.commands.internal;import static org.hamcrest.MatcherAssert.assertThat;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.hamcrest.Matchers;import picocli.CommandLine;import picocli.CommandLine.ParseResult;abstract class BaseCommandTest<T> {    protected abstract T createCommand();        protected abstract void addStandardParams(List<String> argList);        protected void assertError(final String... params) {        final T cmd = createCommand();        final ParseResult parseResult = parseCommand(cmd, params);        assertThat(parseResult.errors(), Matchers.not(Matchers.empty()));    }    protected T setupAndParse(final String... params) {        final T cmd = createCommand();        final ParseResult parseResult = parseCommand(cmd, params);        assertThat(parseResult.errors(), Matchers.empty());        return cmd;    }        private ParseResult parseCommand(final Object cmd, final String... params) {        final List<String> argList = new ArrayList<>();        argList.addAll(Arrays.asList(params));        addStandardParams(argList);        final CommandLine commandLine = new CommandLine(cmd)            .setCaseInsensitiveEnumValuesAllowed(true);                // Collect errors instead of simply throwing during parsing        commandLine.getCommandSpec().parser().collectErrors(true);                return commandLine.parseArgs(argList.toArray(new String[0]));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli.commands.internal;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.File;import java.util.List;import java.util.stream.Collectors;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.CPDConfiguration;class CpdCommandTest extends BaseCommandTest<CpdCommand> {    @Test    void testMultipleDirs() {        final CpdCommand cmd = setupAndParse(            "-d", "a", "b"        );        assertMultipleDirs(cmd);    }    @Test    void testMultipleDirsWithCommas() {        final CpdCommand cmd = setupAndParse(            "-d", "a,b"        );        assertMultipleDirs(cmd);    }    @Test    void testMultipleDirsWithRepeatedOption() {        final CpdCommand cmd = setupAndParse(            "-d", "a", "-d", "b"        );        assertMultipleDirs(cmd);    }    @Test    void testNoPositionalParametersAllowed() {        final CpdCommand cmd = setupAndParse(            "-d", "a", "--", "b"        );        assertMultipleDirs(cmd);    }    @Test    void testEmptyDirOption() {        assertError("-d", "-f", "text");    }    private void assertMultipleDirs(final CpdCommand result) {        final CPDConfiguration config = result.toConfiguration();        assertEquals(listOf("a", "b"), config.getFiles().stream().map(File::toString).collect(Collectors.toList()));    }    @Override    protected CpdCommand createCommand() {        return new CpdCommand();    }    @Override    protected void addStandardParams(final List<String> argList) {        // If no minimum tokens provided, set default value        if (!argList.contains("--minimum-tokens")) {            argList.add(0, "--minimum-tokens");            argList.add(1, "100");        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.hamcrest.Matchers.containsStringIgnoringCase;import static org.hamcrest.Matchers.not;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.charset.StandardCharsets;import java.nio.file.FileSystems;import java.nio.file.Files;import java.nio.file.Path;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.cli.internal.ExecutionResult;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;import com.github.stefanbirkner.systemlambda.SystemLambda;class PmdCliTest extends BaseCliTest {    @TempDir    private Path tempDir;    private static final String DUMMY_RULESET = "net/sourceforge/pmd/cli/FakeRuleset.xml";    private static final String STRING_TO_REPLACE = "__should_be_replaced__";    private Path srcDir;    @AfterAll    static void resetLogging() {        // reset logging in case "--debug" changed the logging properties        // See also Slf4jSimpleConfigurationForAnt        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    @BeforeEach    void setup() throws IOException {        // set current directory to wd        Path root = tempRoot();        System.setProperty("user.dir", root.toString());        // create a few files        srcDir = Files.createDirectories(root.resolve("src"));        writeString(srcDir.resolve("someSource.dummy"), "dummy text");    }    @Test    void testPreExistingReportFile() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        // now we create the file        Files.createDirectories(reportFile.getParent());        writeString(reportFile, STRING_TO_REPLACE);        assertTrue(Files.exists(reportFile), "Report file should exist");        runCliSuccessfully("-d", srcDir.toString(), "-R", DUMMY_RULESET, "-r", reportFile.toString());        assertNotEquals(readString(reportFile), STRING_TO_REPLACE);    }    @Test    void testPreExistingReportFileLongOption() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        // now we create the file        Files.createDirectories(reportFile.getParent());        writeString(reportFile, STRING_TO_REPLACE);        assertTrue(Files.exists(reportFile), "Report file should exist");        runCliSuccessfully("--dir", srcDir.toString(), "--rulesets", DUMMY_RULESET, "--report-file", reportFile.toString());        assertNotEquals(readString(reportFile), STRING_TO_REPLACE, "Report file should have been overwritten");    }    @Test    void testNonExistentReportFile() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        assertFalse(Files.exists(reportFile), "Report file should not exist");        try {            runCliSuccessfully("-d", srcDir.toString(), "-R", DUMMY_RULESET, "-r", reportFile.toString());            assertTrue(Files.exists(reportFile), "Report file should have been created");        } finally {            Files.deleteIfExists(reportFile);        }    }    @Test    void testNonExistentReportFileLongOption() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        assertFalse(Files.exists(reportFile), "Report file should not exist");        runCliSuccessfully("--dir", srcDir.toString(), "--rulesets", DUMMY_RULESET, "--report-file", reportFile.toString());        assertTrue(Files.exists(reportFile), "Report file should have been created");    }    @Test    void testFileCollectionWithUnknownFiles() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        Files.createFile(srcDir.resolve("foo.not_analysable"));        assertFalse(Files.exists(reportFile), "Report file should not exist");        // restoring system properties: --debug might change logging properties        SystemLambda.restoreSystemProperties(() -> {            runCliSuccessfully("--dir", srcDir.toString(), "--rulesets", DUMMY_RULESET, "--report-file", reportFile.toString(), "--debug");        });        assertTrue(Files.exists(reportFile), "Report file should have been created");        String reportText = readString(reportFile);        assertThat(reportText, not(containsStringIgnoringCase("error")));    }    /**     * This tests to create the report file in the current working directory.     *     * <p>Note: We can't change the cwd in the running VM, so the file will not be created     * in the temporary folder, but really in the cwd. The test fails if a file already exists     * and makes sure to cleanup the file afterwards.     */    @Test    void testRelativeReportFile() throws Exception {        String reportFile = "reportFile.txt";        Path absoluteReportFile = FileSystems.getDefault().getPath(reportFile).toAbsolutePath();        // verify the file doesn't exist yet - we will delete the file at the end!        assertFalse(Files.exists(absoluteReportFile), "Report file must not exist yet! " + absoluteReportFile);        try {            runCliSuccessfully("-d", srcDir.toString(), "-R", DUMMY_RULESET, "-r", reportFile.toString());            assertTrue(Files.exists(absoluteReportFile), "Report file should have been created");        } finally {            Files.deleteIfExists(absoluteReportFile);        }    }    @Test    void testRelativeReportFileLongOption() throws Exception {        String reportFile = "reportFile.txt";        Path absoluteReportFile = FileSystems.getDefault().getPath(reportFile).toAbsolutePath();        // verify the file doesn't exist yet - we will delete the file at the end!        assertFalse(Files.exists(absoluteReportFile), "Report file must not exist yet!");        try {            runCliSuccessfully("--dir", srcDir.toString(), "--rulesets", DUMMY_RULESET, "--report-file", reportFile.toString());            assertTrue(Files.exists(absoluteReportFile), "Report file should have been created");        } finally {            Files.deleteIfExists(absoluteReportFile);        }    }    @Test    void debugLogging() throws Exception {        // restoring system properties: --debug might change logging properties        SystemLambda.restoreSystemProperties(() -> {            String log = runCliSuccessfully("--debug", "--dir", srcDir.toString(), "--rulesets", DUMMY_RULESET);            assertThat(log, containsString("[main] INFO net.sourceforge.pmd.cli.commands.internal.AbstractPmdSubcommand - Log level is at TRACE"));        });    }    @Test    void defaultLogging() throws Exception {        String log = runCliSuccessfully("--dir", srcDir.toString(), "--rulesets", DUMMY_RULESET);        assertThat(log, containsString("[main] INFO net.sourceforge.pmd.cli.commands.internal.AbstractPmdSubcommand - Log level is at INFO"));    }    @Test    void testDeprecatedRulesetSyntaxOnCommandLine() throws Exception {        String log = runCli(ExecutionResult.VIOLATIONS_FOUND, "--dir", srcDir.toString(), "--rulesets", "dummy-basic");        assertThat(log, containsString("Ruleset reference 'dummy-basic' uses a deprecated form, use 'rulesets/dummy/basic.xml' instead"));    }    @Test    void testMissingRuleset() throws Exception {        final String log = runCli(ExecutionResult.USAGE_ERROR);        assertThat(log, containsString("Missing required option: '--rulesets=<rulesets>'"));    }        @Test    void testMissingSource() throws Exception {        final String log = runCli(ExecutionResult.USAGE_ERROR, "--rulesets", DUMMY_RULESET);        assertThat(log, containsString("Please provide a parameter for source root directory"));    }        @Test    void testWrongCliOptionsDoPrintUsage() throws Exception {        final String log = runCli(ExecutionResult.USAGE_ERROR, "--invalid", "--rulesets", DUMMY_RULESET, "-d", srcDir.toString());        assertThat(log, containsString("Unknown option: '--invalid'"));        assertThat(log, containsString("Usage: pmd check"));    }    // utilities    private Path tempRoot() {        return tempDir;    }    // available in Files on java 11+    private static void writeString(Path path, String text) throws IOException {        ByteBuffer encoded = StandardCharsets.UTF_8.encode(text);        Files.write(path, encoded.array());    }    // available in Files on java 11+    private static String readString(Path path) throws IOException {        byte[] bytes = Files.readAllBytes(path);        ByteBuffer buf = ByteBuffer.wrap(bytes);        return StandardCharsets.UTF_8.decode(buf).toString();    }        @Override    protected List<String> cliStandardArgs() {        final List<String> argList = new ArrayList<>();                // Always run against dummy language without logging not cache to remove all logging noise        argList.add("check");        argList.add("--use-version");        argList.add("dummy-1.0");        argList.add("--no-cache");        argList.add("--no-progress");                return argList;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.BeforeAll;import net.sourceforge.pmd.cli.internal.ExecutionResult;import com.github.stefanbirkner.systemlambda.SystemLambda;abstract class BaseCliTest {    @BeforeAll    static void disablePicocliAnsi() {        System.setProperty("picocli.ansi", "false");    }        @AfterAll    static void resetPicocliAnsi() {        System.clearProperty("picocli.ansi");    }        protected String runCliSuccessfully(String... args) throws Exception {        return runCli(ExecutionResult.OK, args);    }    protected String runCli(ExecutionResult expectedExitCode, String... args) throws Exception {        final List<String> argList = new ArrayList<>();        argList.addAll(cliStandardArgs());        argList.addAll(Arrays.asList(args));                return SystemLambda.tapSystemErrAndOut(() -> {            final int actualExitCode = SystemLambda.catchSystemExit(() -> {                PmdCli.main(argList.toArray(new String[0]));            });            assertEquals(expectedExitCode.getExitCode(), actualExitCode, "Exit code");        });    }    protected abstract List<String> cliStandardArgs();}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.jupiter.api.Assertions.assertEquals;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.cli.internal.ExecutionResult;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;import com.github.stefanbirkner.systemlambda.SystemLambda;class CpdCliTest extends BaseCliTest {    private static final String SRC_DIR = "src/test/resources/net/sourceforge/pmd/cpd/files/";    @TempDir    private Path tempDir;    @AfterAll    static void resetLogging() {        // reset logging in case "--debug" changed the logging properties        // See also Slf4jSimpleConfigurationForAnt        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    @Test    void debugLogging() throws Exception {        // restoring system properties: --debug might change logging properties        SystemLambda.restoreSystemProperties(() -> {            String log = runCliSuccessfully("--debug", "--minimum-tokens", "340", "--dir", SRC_DIR);            assertThat(log, containsString("[main] INFO net.sourceforge.pmd.cli.commands.internal.AbstractPmdSubcommand - Log level is at TRACE"));        });    }    @Test    void defaultLogging() throws Exception {        String log = runCliSuccessfully("--minimum-tokens", "340", "--dir", SRC_DIR);        assertThat(log, containsString("[main] INFO net.sourceforge.pmd.cli.commands.internal.AbstractPmdSubcommand - Log level is at INFO"));    }        @Test    void testMissingminimumTokens() throws Exception {        final String log = runCli(ExecutionResult.USAGE_ERROR);        assertThat(log, containsString("Missing required option: '--minimum-tokens=<minimumTokens>'"));    }        @Test    void testMissingSource() throws Exception {        final String log = runCli(ExecutionResult.USAGE_ERROR, "--minimum-tokens", "340");        assertThat(log, containsString("Please provide a parameter for source root directory"));    }        @Test    void testWrongCliOptionsDoPrintUsage() throws Exception {        final String log = runCli(ExecutionResult.USAGE_ERROR, "--invalid", "--minimum-tokens", "340", "-d", SRC_DIR);        assertThat(log, containsString("Unknown option: '--invalid'"));        assertThat(log, containsString("Usage: pmd cpd"));    }        @Test    void testNoDuplicatesResultRendering() throws Exception {        final String stdout = SystemLambda.tapSystemOut(() -> {            SystemLambda.tapSystemErr(() -> {                final int statusCode = SystemLambda.catchSystemExit(() -> {                    PmdCli.main(new String[] {                        "cpd", "--minimum-tokens", "340", "--language", "java", "--dir",                        SRC_DIR, "--format", "xml",                    });                });                assertEquals(ExecutionResult.OK.getExitCode(), statusCode);            });        });        final Path absoluteSrcDir = Paths.get(SRC_DIR).toAbsolutePath();        assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                + "<pmd-cpd>\n"                + "   <file path=\"" + absoluteSrcDir.resolve("dup1.java").toString() + "\"\n"                + "         totalNumberOfTokens=\"89\"/>\n"                + "   <file path=\"" + absoluteSrcDir.resolve("dup2.java").toString() + "\"\n"                + "         totalNumberOfTokens=\"89\"/>\n"                + "   <file path=\"" + absoluteSrcDir.resolve("file_with_ISO-8859-1_encoding.java").toString() + "\"\n"                + "         totalNumberOfTokens=\"8\"/>\n"                + "   <file path=\"" + absoluteSrcDir.resolve("file_with_utf8_bom.java").toString() + "\"\n"                + "         totalNumberOfTokens=\"9\"/>\n"                + "</pmd-cpd>", stdout.trim());    }    @Override    protected List<String> cliStandardArgs() {        final List<String> argList = new ArrayList<>();                argList.add("cpd");                return argList;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import java.io.BufferedWriter;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import com.github.stefanbirkner.systemlambda.SystemLambda;class TreeExportCliTest extends BaseCliTest {    @TempDir    private Path tmp;    @Test    void testReadStandardInput() throws Exception {        SystemLambda.withTextFromSystemIn("(a(b))").execute(() -> {            final String output = runCliSuccessfully("-i", "-f", "xml", "-PlineSeparator=LF");                        assertThat(output, containsString("<?xml version='1.0' encoding='UTF-8' ?>\n"                                                + "<dummyRootNode Image=''>\n"                                                + "    <dummyNode Image='a'>\n"                                                + "        <dummyNode Image='b' />\n"                                                + "    </dummyNode>\n"                                                + "</dummyRootNode>"));        });    }    @Test    void testReadFile() throws Exception {        File file = newFileWithContents("(a(b))");        final String output = runCliSuccessfully("--file", file.getAbsolutePath(), "-f", "xml", "-PlineSeparator=LF");        assertThat(output, containsString("<?xml version='1.0' encoding='UTF-8' ?>\n"                                            + "<dummyRootNode Image=''>\n"                                            + "    <dummyNode Image='a'>\n"                                            + "        <dummyNode Image='b' />\n"                                            + "    </dummyNode>\n"                                            + "</dummyRootNode>"));    }    private File newFileWithContents(String data) throws IOException {        File file = Files.createTempFile(tmp, "TreeExportCliTest", "data").toFile();        try (BufferedWriter br = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {            br.write(data);        }        return file;    }    @Override    protected List<String> cliStandardArgs() {        final List<String> argList = new ArrayList<>();                // Set program name and set dummy language        argList.add("ast-dump");        argList.add("-l");        argList.add("dummy");                return argList;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class ObjectiveCTokenizerTest extends CpdTextComparisonTest {    ObjectiveCTokenizerTest() {        super(".m");    }    @Override    protected String getResourcePrefix() {        return "../lang/objc/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new ObjectiveCTokenizer();    }    @Test    void testLongSample() {        doTest("big_sample");    }    @Test    void testUnicodeEscape() {        doTest("unicodeEscapeInString");    }    @Test    void testUnicodeCharInIdent() {        doTest("unicodeCharInIdent");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.scala.ast.BaseScalaTest;class XPathRuleTest extends BaseScalaTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    void testPrintHelloWorld() {        Report report = evaluate(SCALA_TEST, "//TermApply/TermName[@Image=\"println\"]");        RuleViolation rv = report.getViolations().get(0);        assertEquals(2, rv.getBeginLine());    }    private Report evaluate(String testSource, String xpath) {        XPathRule rule = scala.newXpathRule(xpath);        return scala.executeRuleOnResource(rule, testSource);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.concurrent.atomic.AtomicInteger;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.scala.ast.ASTSource;import net.sourceforge.pmd.lang.scala.ast.ASTTermApply;import net.sourceforge.pmd.lang.scala.ast.ASTTermName;import net.sourceforge.pmd.lang.scala.ast.BaseScalaTest;import net.sourceforge.pmd.lang.scala.ast.ScalaNode;class ScalaRuleTest extends BaseScalaTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    void testRuleVisits() {        final AtomicInteger visited = new AtomicInteger();        ScalaRule rule = new ScalaRule() {            @Override            public RuleContext visit(ScalaNode<?> node, RuleContext data) {                visited.incrementAndGet();                return super.visit(node, data);            }        };        ASTSource root = scala.parseResource(SCALA_TEST);        rule.apply(root, null);        assertEquals(12, visited.get());    }    @Test    void testDummyRule() {        ScalaRule rule = new ScalaRule() {            @Override            public String getMessage() {                return "a message";            }            @Override            public RuleContext visit(ASTTermApply node, RuleContext data) {                ASTTermName child = node.getFirstChildOfType(ASTTermName.class);                if (child != null && child.hasImageEqualTo("println")) {                    addViolation(data, node);                }                return data;            }        };        Report report = scala.executeRuleOnResource(rule, SCALA_TEST);        assertEquals(1, report.getViolations().size());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.ast;/** * @author Clément Fournier */public abstract class BaseScalaTest {    protected final ScalaParsingHelper scala = ScalaParsingHelper.DEFAULT.withResourceContext(getClass());}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.ast.TokenMgrError;class ScalaTokenizerTest extends CpdTextComparisonTest {    ScalaTokenizerTest() {        super(".scala");    }    @Override    protected String getResourcePrefix() {        return "../lang/scala/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new ScalaTokenizer();    }    @Test    void testSample() {        doTest("sample-LiftActor");    }    @Test    void testSuppressionComments() {        doTest("special_comments");    }    @Test    void tokenizeFailTest() {        assertThrows(TokenMgrError.class, () -> doTest("unlexable_sample"));    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.13",                getLanguage(ScalaLanguageModule.NAME).getVersion("2.13"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.12",                getLanguage(ScalaLanguageModule.NAME).getVersion("2.12"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.11",                getLanguage(ScalaLanguageModule.NAME).getVersion("2.11"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.10",                getLanguage(ScalaLanguageModule.NAME).getVersion("2.10"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test scala rulesets */public class RulesetFactoryTest extends AbstractRuleSetFactoryTest {    // no rulesets yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidTrailingCommaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class InnaccurateNumericLiteralTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EqualComparisonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryParenthesesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoElseReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnreachableCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ScopeForInVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConsistentReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class GlobalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidWithStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseBaseWithParseIntTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class ASTForInLoopTest extends EcmascriptParserTestBase {    /**     * Note: for each loops are deprecated.     *     * @see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in">for each...in</a>     */    @Test    void testForEachLoop() {        ASTAstRoot node = js.parse("for each (var item in items) {}");        ASTForInLoop loop = (ASTForInLoop) node.getChild(0);        assertFalse(loop.isForOf());        assertTrue(loop.isForEach());    }    @Test    void testForOfLoop() {        ASTAstRoot node = js.parse("for (var item of items) {}");        ASTForInLoop loop = (ASTForInLoop) node.getChild(0);        assertTrue(loop.isForOf());        assertFalse(loop.isForEach());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import org.mozilla.javascript.ast.AstRoot;/** * See the following bugs: #1141 ECMAScript: getFinallyBlock() is buggy. #1142 * ECMAScript: getCatchClause() is buggy */class ASTTryStatementTest extends EcmascriptParserTestBase {    private ASTTryStatement getTryStmt(String js) {        EcmascriptNode<AstRoot> node = this.js.parse(js);        List<ASTTryStatement> trys = node.findDescendantsOfType(ASTTryStatement.class);        assertEquals(1, trys.size());        ASTTryStatement tryStmt = trys.get(0);        return tryStmt;    }    @Test    void testFinallyBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } finally { } }");        assertNull(tryStmt.getCatchClause(0));        assertFalse(tryStmt.hasCatch());        assertEquals(0, tryStmt.getNumCatchClause());        assertNotNull(tryStmt.getFinallyBlock());        assertTrue(tryStmt.hasFinally());    }    @Test    void testCatchBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } }");        assertNotNull(tryStmt.getCatchClause(0));        assertTrue(tryStmt.hasCatch());        assertEquals(1, tryStmt.getNumCatchClause());        assertNull(tryStmt.getFinallyBlock());        assertFalse(tryStmt.hasFinally());    }    @Test    void testCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } finally { } }");        assertNotNull(tryStmt.getCatchClause(0));        assertTrue(tryStmt.hasCatch());        assertEquals(1, tryStmt.getNumCatchClause());        assertNotNull(tryStmt.getFinallyBlock());        assertTrue(tryStmt.hasFinally());    }    @Test    void testMultipleCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt(                "function() { " + "try { } " + "catch (error if error instanceof BadError) { } "                        + "catch (error2 if error2 instanceof OtherError) { } " + "finally { } }");        assertNotNull(tryStmt.getCatchClause(0));        assertNotNull(tryStmt.getCatchClause(1));        assertTrue(tryStmt.hasCatch());        assertEquals(2, tryStmt.getNumCatchClause());        assertNotNull(tryStmt.getFinallyBlock());        assertTrue(tryStmt.hasFinally());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Locale;import org.junit.jupiter.api.Test;class TrailingCommaTest extends EcmascriptParserTestBase {    @Test    void testTrailingCommaDefaultLocale() {        testTrailingComma();    }    @Test    void testTrailingCommaFrFr() {        runWithLocale(Locale.FRANCE, () -> testTrailingComma());    }    @Test    void testTrailingCommaRootLocale() {        runWithLocale(Locale.ROOT, () -> testTrailingComma());    }    private void testTrailingComma() {        ASTAstRoot node = js.parse("x = {a : 1, };\n");        ASTObjectLiteral fn = node.getFirstDescendantOfType(ASTObjectLiteral.class);        assertTrue(fn.isTrailingComma());    }    private void runWithLocale(Locale locale, Runnable runnable) {        Locale prev = Locale.getDefault();        try {            Locale.setDefault(locale);            runnable.run();        } finally {            Locale.setDefault(prev);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.Timeout;import org.mozilla.javascript.ast.AstRoot;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;class EcmascriptParserTest extends EcmascriptParserTestBase {    /**     * https://sourceforge.net/p/pmd/bugs/1043/     */    @Test    void testLineNumbers() {        final String SOURCE_CODE = "function a() {" + PMD.EOL + "  alert('hello');" + PMD.EOL + "}" + PMD.EOL;        EcmascriptNode<AstRoot> node = js.parse(SOURCE_CODE);        assertEquals(1, node.getBeginLine());        assertEquals(1, node.getBeginColumn());        assertEquals(3, node.getEndLine());        assertEquals(2, node.getEndColumn());        Node child = node.getFirstChildOfType(ASTFunctionNode.class);        assertEquals(1, child.getBeginLine());        assertEquals(1, child.getBeginColumn());        assertEquals(3, child.getEndLine());        assertEquals(2, child.getEndColumn());        child = node.getFirstDescendantOfType(ASTFunctionCall.class);        assertEquals(2, child.getBeginLine());        assertEquals(3, child.getBeginColumn());        assertEquals(2, child.getEndLine());        assertEquals(17, child.getEndColumn());    }    /**     * https://sourceforge.net/p/pmd/bugs/1149/     */    @Test    void testLineNumbersWithinEcmascriptRules() {        String source =            "function f(x){\n"                + "   if (x) {\n"                + "       return 1;\n"                + "   } else {\n"                + "       return 0;\n" + "   }\n"                + "}";        class MyEcmascriptRule extends AbstractEcmascriptRule {            public Object visit(ASTScope node, Object data) {                addViolationWithMessage(data, node, "Scope from " + node.getBeginLine() + " to " + node.getEndLine());                return super.visit(node, data);            }        }        MyEcmascriptRule rule = new MyEcmascriptRule();        rule.setLanguage(js.getLanguage());        Report report = js.executeRule(rule, source);        assertEquals(2, report.getViolations().size(), "Expecting 2 violations");        assertEquals("Scope from 2 to 4", report.getViolations().get(0).getDescription());        assertEquals("Scope from 4 to 6", report.getViolations().get(1).getDescription());    }    /**     * Test bug https://sourceforge.net/p/pmd/bugs/1118/     */    @Test    void testArrayAccess() {        EcmascriptNode<AstRoot> node = js.parse("function a() { b['a'] = 1; c[1] = 2; }");        List<ASTElementGet> arrays = node.findDescendantsOfType(ASTElementGet.class);        assertEquals("b", arrays.get(0).getTarget().getImage());        assertEquals("a", arrays.get(0).getElement().getImage());        assertEquals("c", arrays.get(1).getTarget().getImage());        assertEquals("1", arrays.get(1).getElement().getImage());    }    /**     * Test for bug #1136 ECAMScript: NullPointerException in getLeft() and     * getRight()     */    @Test    void testArrayMethod() {        EcmascriptNode<AstRoot> rootNode = js.parse(            "function test(){\n" + "  a();      // OK\n" + "  b.c();    // OK\n" + "  d[0]();   // OK\n"                + "  e[0].f(); // OK\n" + "  y.z[0](); // FAIL ==> java.lang.NullPointerException\n" + "}");        List<ASTFunctionCall> calls = rootNode.findDescendantsOfType(ASTFunctionCall.class);        List<String> results = new ArrayList<>();        for (ASTFunctionCall f : calls) {            Node node = f.getTarget();            results.add(getName(node));        }        assertEquals("[a, b.c, d[], e[].f, y.z[]]", results.toString());    }    private String getName(Node node) {        if (node instanceof ASTName) {            return ((ASTName) node).getIdentifier();        }        if (node instanceof ASTPropertyGet) {            final ASTPropertyGet pgNode = (ASTPropertyGet) node;            final String leftName = getName(pgNode.getLeft());            final String rightName = getName(pgNode.getRight());            return leftName + "." + rightName;        }        if (node instanceof ASTElementGet) {            return getName(((ASTElementGet) node).getTarget()) + "[]";        }        return "????";    }    /**     * https://sourceforge.net/p/pmd/bugs/1150/ #1150 "EmptyExpression" for     * valid statements!     */    @Test    void testCaseAsIdentifier() {        ASTAstRoot rootNode = js.parse("function f(a){\n" + "    a.case.flag = 1;\n" + "    return;\n" + "}");        ASTBlock block = rootNode.getFirstDescendantOfType(ASTBlock.class);        assertFalse(block.getChild(0) instanceof ASTEmptyExpression);        assertTrue(block.getChild(0) instanceof ASTExpressionStatement);        assertTrue(block.getChild(0).getChild(0) instanceof ASTAssignment);    }    /**     * https://sourceforge.net/p/pmd/bugs/1045/ #1045 //NOPMD not working (or     * not implemented) with ECMAscript     */    @Test    void testSuppressionComment() {        ASTAstRoot root = js.parse("function(x) {\n"                                       + "x = x; //NOPMD I know what I'm doing\n"                                       + "}\n");        assertEquals(" I know what I'm doing", root.getAstInfo().getSuppressionComments().get(2));        assertEquals(1, root.getAstInfo().getSuppressionComments().size());        root = js.withSuppressMarker("FOOOO")                 .parse("function(x) {\n" + "y = y; //NOPMD xyz\n" + "x = x; //FOOOO I know what I'm doing\n" + "}\n");        assertEquals(" I know what I'm doing", root.getAstInfo().getSuppressionComments().get(3));        assertEquals(1, root.getAstInfo().getSuppressionComments().size());    }    /**     * #1191 Ecmascript fails to parse "void(0)"     */    @Test    void testVoidKeyword() {        ASTAstRoot rootNode = js.parse("function f(matchFn, fieldval, n){\n"                                           + "    return (matchFn)?(matcharray = eval(matchFn+\"('\"+fieldval+\"','\"+n.id+\"')\")):void(0);\n"                                           + "}\n");        ASTUnaryExpression unary = rootNode.getFirstDescendantOfType(ASTUnaryExpression.class);        assertEquals("void", unary.getImage());    }    /**     * #1192 Ecmascript fails to parse this operator " ^= "     */    @Test    void testXorAssignment() {        ASTAstRoot rootNode = js.parse("function f() { var x = 2; x ^= 2; x &= 2; x |= 2; "                                           + "x &&= true; x ||= false; x *= 2; x /= 2; x %= 2; x += 2; x -= 2; "                                           + "x <<= 2; x >>= 2; x >>>= 2; }");        ASTAssignment infix = rootNode.getFirstDescendantOfType(ASTAssignment.class);        assertEquals("^=", infix.getImage());    }    @Test    void testUnicodeCjk() {        // the first is u+4F60        js.parse("import { Test } from 'test2'\n"                 + "define('element', class extends Test {\n"                 + "    <button onClick={this.clickHandler}>你好</button>\n"                 + "  }\n"                 + "})");    }    /**     * [javascript] Failing with OutOfMemoryError parsing a Javascript file #2081     */    @Test    @Timeout(5)    void shouldNotFailWithOutOfMemory() {        ASTAstRoot rootNode = js.parse("(``\n);");        assertNotNull(rootNode);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class ASTVariableDeclarationTest extends EcmascriptParserTestBase {    @Test    void testLet() {        ASTAstRoot node = js.parse("let x = 1;");        ASTVariableDeclaration varDecl = (ASTVariableDeclaration) node.getChild(0);        assertTrue(varDecl.isLet());        ASTVariableInitializer varInit = (ASTVariableInitializer) varDecl.getChild(0);        ASTName name = (ASTName) varInit.getChild(0);        assertEquals("x", name.getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.NodePrintersKt;class JsTreeDumpTest extends BaseTreeDumpTest {    JsTreeDumpTest() {        super(NodePrintersKt.getSimpleNodePrinter(), ".js");    }    @Override    public BaseParsingHelper<JsParsingHelper, ASTAstRoot> getParser() {        return JsParsingHelper.DEFAULT.withResourceContext(JsTreeDumpTest.class, "testdata");    }    @Test    void simpleJavascriptFile() {        doTest("SimpleJavascriptFile");    }    @Test    void jquerySelector() {        doTest("jquery-selector");    }    @Test    void decorators() {        doTest("decorators");    }    @Test    void templateStrings() {        doTest("templateStrings");    }    @Test    void issue3948() {        // https://github.com/pmd/pmd/issues/3948        doTest("issue3948");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class ASTFunctionNodeTest extends EcmascriptParserTestBase {    @Test    public void testGetBody() {        ASTAstRoot node = js.parse("function foo() { var a = 'a'; }");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        assertFalse(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        assertTrue(body instanceof ASTBlock);    }    @Test    void testGetBodyFunctionClosureExpression() {        ASTAstRoot node = js.parse("(function(x) x*x)");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        assertTrue(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        assertTrue(body instanceof ASTBlock);        assertTrue(body.getChild(0) instanceof ASTReturnStatement);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.emptyString;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    @Test    public void shouldFindDuplicatesWithDifferentFileExtensions() {        String out = runTest(CPD.StatusCode.DUPLICATE_CODE_FOUND, "--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File1.ts",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File2.ts");        assertThat(out, containsString("Found a 9 line (32 tokens) duplication in the following files"));    }    @Test    public void shouldFindNoDuplicatesWithDifferentFileExtensions() {        String out = runTest(CPD.StatusCode.OK, "--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/");        assertThat(out.trim(), emptyString());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class EcmascriptTokenizerTest extends CpdTextComparisonTest {    EcmascriptTokenizerTest() {        super(".js");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new EcmascriptTokenizer();    }    @Override    protected String getResourcePrefix() {        return "../lang/ecmascript/cpd/testdata";    }    @Test    void testSimple() {        doTest("simple");    }    @Test    void testSimplewithSemis() {        doTest("simpleWithSemis");    }    @Test    void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1239/     */    @Test    void parseStringNotAsMultiline() {        doTest("lineContinuations");    }    @Test    void testIgnoreSingleLineComments() {        doTest("singleLineCommentIgnore");    }    @Test    void testIgnoreMultiLineComments() {        doTest("multilineCommentIgnore");    }    @Test    void testTemplateStrings() {        doTest("templateStrings");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * */class AnyTokenizerForTypescriptTest extends CpdTextComparisonTest {    AnyTokenizerForTypescriptTest() {        super(".ts");    }    @Override    protected String getResourcePrefix() {        return "testdata/ts";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new AnyTokenizer();    }    @Test    void testFile1() {        doTest("SampleTypeScript");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testEcmascript() {        executeTarget("testEcmascript");        assertOutputContaining("A 'return', 'break', 'continue', or 'throw' statement should be the last in a block.");        assertOutputContaining("Avoid using global variables");        assertOutputContaining("Use ===/!== to compare with true/false or Numbers");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.Test;import net.sourceforge.pmd.PMD.StatusCode;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CLITest extends BaseCLITest {    @Test    public void useEcmaScript() {        String log = runTest(StatusCode.VIOLATIONS_FOUND,                             "-d",                             SOURCE_FOLDER,                             "-f",                             "xml",                             "-R",                             "rulesets/testing/js-rset1.xml",                             "--no-progress",                             "--debug");        assertThat(log, containsPattern("Adding file .*\\.js \\(lang: ecmascript ES6\\)"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ecmascript.EcmascriptLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { EcmascriptLanguageModule.NAME, EcmascriptLanguageModule.TERSE_NAME,                "ES6",                getLanguage(EcmascriptLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ecmascript.ast.ASTFunctionNode;import net.sourceforge.pmd.lang.ecmascript.ast.EcmascriptParserTestBase;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;class ReportTest extends EcmascriptParserTestBase {    @Test    void testExclusionsInReportWithNOPMDEcmascript() {        Rule rule = new AbstractEcmascriptRule() {            @Override            public Object visit(ASTFunctionNode node, Object data) {                addViolationWithMessage(data, node, "Test");                return data;            }        };        rule.setLanguage(js.getDefaultVersion().getLanguage());        Report rpt = js.executeRule(rule, "function(x) // NOPMD test suppress\n{ x = 1; }");        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test javascript's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.VfTokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class VfTokenizerTest extends CpdTextComparisonTest {    VfTokenizerTest() {        super(".page");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        VfTokenizer tokenizer = new VfTokenizer();        return tokenizer;    }    @Test    void testTokenize() {        doTest("SampleUnescapeElWithTab");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class VfHtmlStyleTagXssTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import static org.junit.jupiter.api.Assertions.assertEquals;import java.nio.file.Path;import java.nio.file.Paths;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.ast.VfParsingHelper;import net.sourceforge.pmd.testframework.PmdRuleTst;class VfUnescapeElTest extends PmdRuleTst {    private static final String EXPECTED_RULE_MESSAGE = "Avoid unescaped user controlled content in EL";    /**     * Verify that CustomFields stored in sfdx project format are correctly parsed     */    @Test    void testSfdxCustomFields() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("StandardAccount.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals(20, ruleViolations.size(), "Number of violations");        int firstLineWithErrors = 14;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            int expectedLineNumber = firstLineWithErrors + i;            if (ruleViolations.size() + firstLineWithErrors - 1 == expectedLineNumber) {                // The last line has two errors on the same page                expectedLineNumber = expectedLineNumber - 1;            }            assertEquals(expectedLineNumber, ruleViolation.getBeginLine(), "Line Number");        }    }    /**     * Verify that CustomFields stored in mdapi format are correctly parsed     */    @Test    void testMdapiCustomFields() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Vf).resolve("StandardAccount.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals(6, ruleViolations.size(), "Number of violations");        int firstLineWithErrors = 8;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals(firstLineWithErrors + i, ruleViolation.getBeginLine(), "Line Number");        }    }    /**     * Tests a page with a single Apex controller     */    @Test    void testApexController() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("ApexController.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals(2, ruleViolations.size(), "Number of violations");        int firstLineWithErrors = 9;        for (int i = 0; i < ruleViolations.size(); i++) {            // There should start at line 9            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals(firstLineWithErrors + i, ruleViolation.getBeginLine(), "Line Number");        }    }    /**     * Tests a page with a standard controller and two Apex extensions     */    @Test    void testExtensions() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve(Paths.get("StandardAccountWithExtensions.page"));        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals(8, ruleViolations.size());        int firstLineWithErrors = 9;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals(firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Runs a rule against a Visualforce page on the file system.     */    private Report runRule(Path vfPagePath) {        Rule rule = findRule("category/vf/security.xml", "VfUnescapeEl");        return VfParsingHelper.DEFAULT.executeRuleOnFile(rule, vfPagePath);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class VfCsrfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;/*** * Unit tests to focus on regex pattern used to identify URL methods within style tags */class VfHtmlXssStyleTagUrlPatternMatchingTest {    @Test    void testUrlMethodPatternMatchForPositive() {        final String sampleString = "div {  background: url(blah";        assertTrue(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should be considered as starting a URL method: " + sampleString);    }    @Test    void testUrlMethodPatternMatchForCaseInsensitive() {        final String sampleString = "div {  background: uRl(";        assertTrue(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should be considered as starting a URL method: " + sampleString);    }    @Test    void testUrlMethodPatternMatchForWhitespaceAfterUrl() {        final String sampleString = "div {  background: url (";        assertTrue(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should be considered as starting a URL method: " + sampleString);    }    @Test    void testUrlMethodPatternMatchForClosedUrl() {        final String sampleString = "div {  background: url('myUrl')";        assertFalse(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should not be considered as starting a URL method: " + sampleString);    }    @Test    void testUrlMethodPatternMatchForClosedUrlWithNoContent() {        final String sampleString = "div {  background: url() ";        assertFalse(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should not be considered as starting a URL method: " + sampleString);    }    @Test    void testUrlMethodPatternMatchForUrlNoBracket() {        final String sampleString = "div {  background: url";        assertFalse(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should not be considered as starting a URL method: " + sampleString);    }    @Test    void testUrlMethodPatternMatchForNoUrl() {        final String sampleString = "div {  background: myStyle('";        assertFalse(VfHtmlStyleTagXssRule.isWithinUrlMethod(sampleString), "Sample should not be considered as starting a URL method: " + sampleString);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.vf.DataType;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfHandler;class ObjectFieldTypesTest {    private static final Map<String, DataType> EXPECTED_SFDX_DATA_TYPES;    private static final Map<String, DataType> EXPECTED_MDAPI_DATA_TYPES;    static {        EXPECTED_SFDX_DATA_TYPES = new HashMap<>();        EXPECTED_SFDX_DATA_TYPES.put("Account.Checkbox__c", DataType.Checkbox);        EXPECTED_SFDX_DATA_TYPES.put("Account.DateTime__c", DataType.DateTime);        EXPECTED_SFDX_DATA_TYPES.put("Account.LongTextArea__c", DataType.LongTextArea);        EXPECTED_SFDX_DATA_TYPES.put("Account.Picklist__c", DataType.Picklist);        EXPECTED_SFDX_DATA_TYPES.put("Account.Text__c", DataType.Text);        EXPECTED_SFDX_DATA_TYPES.put("Account.TextArea__c", DataType.TextArea);        // Edge Cases        // Invalid property should return null        EXPECTED_SFDX_DATA_TYPES.put("Account.DoesNotExist__c", null);        EXPECTED_MDAPI_DATA_TYPES = new HashMap<>();        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDCheckbox__c", DataType.Checkbox);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDDateTime__c", DataType.DateTime);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDLongTextArea__c", DataType.LongTextArea);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDPicklist__c", DataType.Picklist);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDText__c", DataType.Text);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDTextArea__c", DataType.TextArea);        // Edge Cases        // Invalid property should return null        EXPECTED_MDAPI_DATA_TYPES.put("Account.DoesNotExist__c", null);    }    /**     * Verify that CustomFields stored in sfdx project format are correctly parsed     */    @Test    void testSfdxAccountIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, VfHandler.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue());    }    /**     * Verify that CustomFields stored in mdapi format are correctly parsed     */    @Test    void testMdapiAccountIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        validateMDAPIAccount(objectFieldTypes, vfPagePath, VfHandler.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue());    }    /**     * Verify that fields are found across multiple directories     */    @Test    void testFieldsAreFoundInMultipleDirectories() {        ObjectFieldTypes objectFieldTypes;        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)            .resolve("SomePage.page");        List<String> paths = Arrays.asList(VfHandler.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue().get(0),                VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Objects).toString());        objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, paths);        validateMDAPIAccount(objectFieldTypes, vfPagePath, paths);        Collections.reverse(paths);        objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, paths);        validateMDAPIAccount(objectFieldTypes, vfPagePath, paths);    }    @Test    void testInvalidDirectoryDoesNotCauseAnException() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        String vfFileName = vfPagePath.toString();        List<String> paths = Arrays.asList(Paths.get("..", "objects-does-not-exist").toString());        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        assertNull(objectFieldTypes.getDataType("Account.DoesNotExist__c", vfFileName, paths));    }    /**     * Validate the expected results when the Account Fields are stored in decomposed sfdx format     */    private void validateSfdxAccount(ObjectFieldTypes objectFieldTypes, Path vfPagePath, List<String> paths) {        validateDataTypes(EXPECTED_SFDX_DATA_TYPES, objectFieldTypes, vfPagePath, paths);    }    /**     * Validate the expected results when the Account Fields are stored in a single file MDAPI format     */    private void validateMDAPIAccount(ObjectFieldTypes objectFieldTypes, Path vfPagePath, List<String> paths) {        validateDataTypes(EXPECTED_MDAPI_DATA_TYPES, objectFieldTypes, vfPagePath, paths);    }    /**     * Verify that return values of {@link SalesforceFieldTypes#getDataType(String, String, List)} using the keys of     * {@code expectedDataTypes} matches the values of {@code expectedDataTypes}     */    static void validateDataTypes(Map<String, DataType> expectedDataTypes, SalesforceFieldTypes fieldTypes,                                         Path vfPagePath, List<String> paths) {        String vfFileName = vfPagePath.toString();        for (Map.Entry<String, DataType> entry : expectedDataTypes.entrySet()) {            assertEquals(entry.getValue(), fieldTypes.getDataType(entry.getKey(), vfFileName, paths), entry.getKey());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.fail;import java.io.IOException;import java.util.List;import java.util.Map;import java.util.stream.Collectors;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer;class ASTExpressionTest {    /**     * Slightly different scenarios which cause different AST, but should return the same results.     */    private static final String[] SNIPPET_TEMPLATES = new String[] {        "{!%s}",        "<apex:outputText value=\"{!%s}\" escape=\"false\"/>",        "<script>function someFunc() {var foo = \"{!%s}\";}</script>"};    @Test    void testExpressionWithApexGetter() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyValue"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(1, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(1, identifiers.size(), template);            Map<String, Node> map = invertMap(identifiers);            assertTrue(map.containsKey("MyValue"), template);            assertTrue(map.get("MyValue") instanceof ASTIdentifier, template);        }    }    @Test    void testExpressionWithStandardController() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c.Text__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(1, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(1, identifiers.size(), template);            Map<String, Node> map = invertMap(identifiers);            assertTrue(map.containsKey("MyObject__c.Text__c"), template);            assertTrue(map.get("MyObject__c.Text__c") instanceof ASTIdentifier, template);        }    }    @Test    void testSelectOptions() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "userOptions.0"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(1, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(1, identifiers.size(), template);            Map<String, Node> map = invertMap(identifiers);            assertTrue(map.containsKey("userOptions.0"), template);            assertTrue(map.get("userOptions.0") instanceof ASTLiteral, template);        }    }    @Test    void testMultipleIdentifiers() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c.Text__c + ' this is a string' + MyObject__c.Text2__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(1, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(2, identifiers.size(), template);            Map<String, Node> map = invertMap(identifiers);            assertEquals(2, map.size(), template);            assertTrue(map.containsKey("MyObject__c.Text__c"), template);            assertTrue(map.get("MyObject__c.Text__c") instanceof ASTIdentifier, template);            assertTrue(map.containsKey("MyObject__c.Text2__c"), template);            assertTrue(map.get("MyObject__c.Text2__c") instanceof ASTIdentifier, template);        }    }    @Test    void testIdentifierWithRelation() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c.MyObject2__r.Text__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(1, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(1, identifiers.size(), template);            Map<String, Node> map = invertMap(identifiers);            assertEquals(1, map.size(), template);            assertTrue(map.containsKey("MyObject1__c.MyObject2__r.Text__c"), template);            assertTrue(map.get("MyObject1__c.MyObject2__r.Text__c") instanceof ASTIdentifier, template);        }    }    @Test    void testMultipleIdentifiersWithRelation() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c.MyObject2__r.Text__c + ' this is a string' + MyObject1__c.MyObject2__r.Text2__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(1, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(2, identifiers.size(), template);            Map<String, Node> map = invertMap(identifiers);            assertEquals(2, map.size(), template);            assertTrue(map.containsKey("MyObject1__c.MyObject2__r.Text__c"), template);            assertTrue(map.get("MyObject1__c.MyObject2__r.Text__c") instanceof ASTIdentifier, template);            assertTrue(map.containsKey("MyObject1__c.MyObject2__r.Text2__c"), template);            assertTrue(map.get("MyObject1__c.MyObject2__r.Text2__c") instanceof ASTIdentifier, template);        }    }    /**     * The current implementation does not support expressing statements using array notation. This notation introduces     * complexities that may be addressed in a future release.     */    @Test    void testExpressionWithArrayIndexingNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c['Name']"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(2, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    @Test    void testIdentifierWithRelationIndexedAsArrayNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c['MyObject2__r'].Text__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(2, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    @Test    void testIdentifierWithComplexIndexedArrayNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "theLineItems[item.Id].UnitPrice"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(2, nodes.size(), template);            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    private static List<Node> getExpressions(ASTCompilationUnit compilationUnit) {        return compilationUnit.descendants(ASTExpression.class).toList(it -> it);    }    /**     * Invert the map to make it easier to unit test.     */    private Map<String, Node> invertMap(Map<VfTypedNode, String> map) {        Map<String, Node> result = map.entrySet().stream()                                      .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));        // Ensure no values have been lost        assertEquals(map.size(), result.size());        return result;    }    private ASTCompilationUnit compile(String snippet) {        return compile(snippet, false);    }    private ASTCompilationUnit compile(String snippet, boolean renderAST) {        ASTCompilationUnit node = VfParsingHelper.DEFAULT.parse(            "<apex:page>"                + snippet                + "</apex:page>"        );        if (renderAST) {            try {                new XmlTreeRenderer().renderSubtree(node, System.out);            } catch (IOException e) {                throw new RuntimeException(e);            }        }        return node;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.IOException;import java.nio.file.Path;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;import net.sourceforge.pmd.lang.vf.DataType;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer;class VfExpressionTypeVisitorTest {    private static final Map<String, DataType> EXPECTED_CUSTOM_FIELD_DATA_TYPES;    private static final Map<String, DataType> EXPECTED_APEX_DATA_TYPES;    static {        EXPECTED_CUSTOM_FIELD_DATA_TYPES = new HashMap<>();        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("CreatedDate", DataType.DateTime);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("DateTime__c", DataType.DateTime);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Checkbox__c", DataType.Checkbox);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Name", DataType.Text);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Text__c", DataType.Text);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("TextArea__c", DataType.TextArea);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("LongTextArea__c", DataType.LongTextArea);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Picklist__c", DataType.Picklist);        EXPECTED_APEX_DATA_TYPES = new HashMap<>();        EXPECTED_APEX_DATA_TYPES.put("AccountIdProp", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("AccountId", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountId", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountIdProp", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("AccountName", DataType.Text);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountName", DataType.Text);        EXPECTED_APEX_DATA_TYPES.put("ConflictingProp", DataType.Unknown);    }    /**     * Strings that use dot notation(Account.CreatedDate) result in ASTIdentifier nodes     */    @Test    void testXpathQueryForCustomFieldIdentifiers() {        Node rootNode = compile("StandardAccount.page");        for (Map.Entry<String, DataType> entry : EXPECTED_CUSTOM_FIELD_DATA_TYPES.entrySet()) {            List<ASTIdentifier> nodes = getIdentifiers(rootNode, entry);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(2, nodes.size(), entry.getKey());            for (Node node : nodes) {                assertEquals(entry.getKey(), node.getImage());                assertTrue(node instanceof ASTIdentifier, node.getClass().getSimpleName());                ASTIdentifier identifier = (ASTIdentifier) node;                assertEquals(entry.getValue(), identifier.getDataType(), entry.getKey());            }        }    }    /**     * Strings that use array notation, Account['CreatedDate') don't have a DataType added. This type of notation     * creates ambiguous situations with Apex methods that return Maps. This may be addressed in a future release.     */    @Test    void testXpathQueryForCustomFieldLiteralsHaveNullDataType() {        Node rootNode = compile("StandardAccount.page");        for (Map.Entry<String, DataType> entry : EXPECTED_CUSTOM_FIELD_DATA_TYPES.entrySet()) {            List<ASTLiteral> nodes = rootNode.descendants(ASTLiteral.class)                                             // Literals are surrounded by apostrophes                                             .filterMatching(ASTLiteral::getImage, "'" + entry.getKey() + "'")                                             .filterMatching(ASTLiteral::getDataType, null)                                             .toList();            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(2, nodes.size(), entry.getKey());            for (Node node : nodes) {                assertEquals(String.format("'%s'", entry.getKey()), node.getImage());                assertTrue(node instanceof ASTLiteral, node.getClass().getSimpleName());                ASTLiteral literal = (ASTLiteral) node;                assertNull(literal.getDataType(), entry.getKey());            }        }    }    /**     * Nodes where the DataType can't be determined should have a null DataType     */    @Test    void testDataTypeForCustomFieldsNotFound() {        Node rootNode = compile("StandardAccount.page");        checkNodes(rootNode.descendants(ASTIdentifier.class)                           .filterMatching(ASTIdentifier::getImage, "NotFoundField__c"));        checkNodes(rootNode.descendants(ASTLiteral.class)                           .filterMatching(ASTLiteral::getImage, "'NotFoundField__c'"));    }    private void checkNodes(NodeStream<? extends VfTypedNode> nodeStream) {        // Each string appears twice, it is set on a "value" attribute and inline        List<? extends VfTypedNode> nodes = nodeStream.toList();        assertEquals(2, nodes.size());        for (VfTypedNode node : nodes) {            assertNull(node.getDataType());        }    }    /**     * Apex properties result in ASTIdentifier nodes     */    @Test    void testXpathQueryForProperties() {        Node rootNode = compile("ApexController.page");        for (Map.Entry<String, DataType> entry : EXPECTED_APEX_DATA_TYPES.entrySet()) {            List<ASTIdentifier> nodes = getIdentifiers(rootNode, entry);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(2, nodes.size(), entry.getKey());            for (Node node : nodes) {                assertEquals(entry.getKey(), node.getImage());                assertTrue(node instanceof ASTIdentifier, node.getClass().getSimpleName());                ASTIdentifier identifier = (ASTIdentifier) node;                assertEquals(entry.getValue(), identifier.getDataType(), entry.getKey());            }        }    }    private List<ASTIdentifier> getIdentifiers(Node rootNode, Entry<String, DataType> entry) {        return rootNode.descendants(ASTIdentifier.class)                       .filterMatching(ASTIdentifier::getImage, entry.getKey())                       .filterMatching(ASTIdentifier::getDataType, entry.getValue())                       .toList();    }    /**     * Nodes where the DataType can't be determined should have a null DataType     */    @Test    void testDataTypeForApexPropertiesNotFound() {        Node rootNode = compile("ApexController.page");        // Each string appears twice, it is set on a "value" attribute and inline        checkNodes(rootNode.descendants(ASTIdentifier.class)                           .filterMatching(ASTIdentifier::getImage, "NotFoundProp"));    }    private Node compile(String pageName) {        return compile(pageName, false);    }    private Node compile(String pageName, boolean renderAST) {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve(pageName);        return compile(vfPagePath, renderAST);    }    private Node compile(Path vfPagePath, boolean renderAST) {        Node node = VfParsingHelper.DEFAULT.parseFile(vfPagePath);        assertNotNull(node);        if (renderAST) {            try {                new XmlTreeRenderer().renderSubtree(node, System.out);            } catch (IOException e) {                throw new RuntimeException(e);            }        }        return node;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;/** * @author sergey.gorbaty */class VfParserTest extends AbstractVfTest {    @Test    void testSingleDoubleQuoteAndEL() {        vf.parse("<span escape='false' attrib=\"{!call}\">${!'yes'}</span>");    }    @Test    void testSingleDoubleQuoteAndELFunction() {        vf.parse("<span escape='false' attrib=\"{!call}\">${!method}</span>");    }    @Test    void testSingleDoubleQuote() {        vf.parse("<span escape='false' attrib=\"{!call}\">${\"yes\"}</span>");    }    @Test    void testAttributeNameWithDot() {        vf.parse("<table-row keep-together.within-page=\"always\" >");    }    @Test    void testAttributeNameWithUnderscore() {        vf.parse("<table-row test_attribute=\"always\" >");    }    @Test    void testAttributeNameWithColon() {        vf.parse("<table-row test:attribute=\"always\" >");    }    @Test    void testAttributeNameWithInvalidSymbol() {        assertThrows(ParseException.class, () -> vf.parse("<table-row test&attribute=\"always\" >"));    }    @Test    void testAttributeNameWithInvalidDot() {        assertThrows(ParseException.class, () -> vf.parse("<table-row .class=\"always\" >"));    }    @Test    void testAttributeNameWithInvalidDotV2() {        assertThrows(ParseException.class, () -> vf.parse("<table-row test..attribute=\"always\" >"));    }    @Test    void testAttributeNameWithInvalidDotV3() {        assertThrows(ParseException.class, () -> vf.parse("<table-row test.attribute.=\"always\" >"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;class VfPageStyleTest extends AbstractVfTest {    /**     * Test parsing of a EL expression.     */    @Test    void testElExpression() {        List<ASTElExpression> expressions = vf.getNodes(ASTElExpression.class, VF_EL_EXPRESSION);        assertEquals(1, expressions.size(), "One expression expected!");        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("myBean", id.getImage(), "Correct expression content expected!");        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("get", dotid.getImage(), "Correct expression content expected!");        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("\"{! World }\"", literal.getImage(), "Correct expression content expected!");    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    void testElExpressionInAttribute() {        List<ASTElExpression> expressions = vf.getNodes(ASTElExpression.class, VF_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals(1, expressions.size(), "One expression expected!");        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("myValidator", id.getImage(), "Correct expression content expected!");        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("find", dotid.getImage(), "Correct expression content expected!");        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("\"'vf'\"", literal.getImage(), "Correct expression content expected!");    }    private static final String VF_EL_EXPRESSION = "<html><title>Hello {!myBean.get(\"{! World }\") } .vf</title></html>";    private static final String VF_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').{!myValidator.find(\"'vf'\")}\" /> </html>";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertNull;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.vf.DataType;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfHandler;class ApexClassPropertyTypesTest {    private static final Map<String, DataType> EXPECTED_DATA_TYPES;    static {        // Intentionally use the wrong case for property names to ensure that they can be found. The Apex class name        // must have the correct case since it is used to lookup the file. The Apex class name is guaranteed to be correct        // in the Visualforce page, but the property names are not        EXPECTED_DATA_TYPES = new HashMap<>();        EXPECTED_DATA_TYPES.put("ApexController.accOuntIdProp", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.AcCountId", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.AcCountname", DataType.Text);        // InnerController        // The class should be parsed to Unknown. It's not a valid expression on its own.        EXPECTED_DATA_TYPES.put("ApexController.innErController", DataType.Unknown);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountIdProp", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountid", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountnAme", DataType.Text);        // Edge cases        // Invalid class should return null        EXPECTED_DATA_TYPES.put("unknownclass.invalidProperty", null);        // Invalid class property should return null        EXPECTED_DATA_TYPES.put("ApexController.invalidProperty", null);        /*         * It is possible to have a property and method with different types that resolve to the same Visualforce         * expression. An example is an Apex class with a property "public String Foo {get; set;}" and a method of         * "Integer getFoo() { return 1; }". These properties should map to {@link DataType#Unknown}.         */        EXPECTED_DATA_TYPES.put("ApexController.ConflictingProp", DataType.Unknown);    }    @Test    void testApexClassIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                                     .resolve("SomePage.page");        ApexClassPropertyTypes apexClassPropertyTypes = new ApexClassPropertyTypes();        ObjectFieldTypesTest.validateDataTypes(EXPECTED_DATA_TYPES, apexClassPropertyTypes, vfPagePath,                                               VfHandler.APEX_DIRECTORIES_DESCRIPTOR.defaultValue());    }    @Test    void testInvalidDirectoryDoesNotCauseAnException() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("SomePage.page");        String vfFileName = vfPagePath.toString();        List<String> paths = Arrays.asList(Paths.get("..", "classes-does-not-exist").toString());        ApexClassPropertyTypes apexClassPropertyTypes = new ApexClassPropertyTypes();        assertNull(apexClassPropertyTypes.getDataType("ApexController.accOuntIdProp", vfFileName, paths));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import org.junit.jupiter.api.Test;/** * Test parsing of a VF in document style, by checking the generated AST. * Original @author pieter_van_raemdonck - Application Engineers NV/SA - * www.ae.be * * @author sergey.gorbaty - VF adaptation * */class VfDocStyleTest extends AbstractVfTest {    /**     * Smoke test for VF parser.     */    @Test    void testSimplestVf() {        List<ASTElement> nodes = vf.getNodes(ASTElement.class, TEST_SIMPLEST_HTML);        assertEquals(1, nodes.size(), "Exactly " + 1 + " element(s) expected");    }    /**     * Test the information on a Element and Attribute.     */    @Test    void testElementAttributeAndNamespace() {        ASTCompilationUnit root = vf.parse(TEST_ELEMENT_AND_NAMESPACE);        List<ASTElement> elementNodes = root.findDescendantsOfType(ASTElement.class);        assertEquals(1, elementNodes.size(), "One element node expected!");        ASTElement element = elementNodes.iterator().next();        assertEquals("h:html", element.getName(), "Correct name expected!");        assertTrue(element.isHasNamespacePrefix(), "Has namespace prefix!");        assertTrue(element.isEmpty(), "Element is empty!");        assertEquals("h", element.getNamespacePrefix(), "Correct namespace prefix of element expected!");        assertEquals("html", element.getLocalName(), "Correct local name of element expected!");        List<ASTAttribute> attributeNodes = root.findDescendantsOfType(ASTAttribute.class);        assertEquals(1, attributeNodes.size(), "One attribute node expected!");        ASTAttribute attribute = attributeNodes.iterator().next();        assertEquals("MyNsPrefix:MyAttr", attribute.getName(), "Correct name expected!");        assertTrue(attribute.isHasNamespacePrefix(), "Has namespace prefix!");        assertEquals("MyNsPrefix", attribute.getNamespacePrefix(), "Correct namespace prefix of element expected!");        assertEquals("MyAttr", attribute.getLocalName(), "Correct local name of element expected!");    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    void testAttributeValueContainingHash() {        List<ASTAttribute> attributes = vf.getNodes(ASTAttribute.class, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        assertEquals(3, attributes.size(), "Three attributes expected!");        ASTAttribute attr = attributes.get(0);        assertEquals("something", attr.getName(), "Correct attribute name expected!");        assertEquals("#yes#", attr.getFirstDescendantOfType(ASTText.class).getImage(),                "Correct attribute value expected!");        attr = attributes.get(1);        assertEquals("foo", attr.getName(), "Correct attribute name expected!");        assertEquals("CREATE", attr.getFirstDescendantOfType(ASTText.class).getImage(),                "Correct attribute value expected!");        attr = attributes.get(2);        assertEquals("href", attr.getName(), "Correct attribute name expected!");        assertEquals("#", attr.getFirstDescendantOfType(ASTText.class).getImage(), "Correct attribute value expected!");    }    /**     * Test correct parsing of CDATA.     */    @Test    void testCData() {        List<ASTCData> cdataNodes = vf.getNodes(ASTCData.class, TEST_CDATA);        assertEquals(1, cdataNodes.size(), "One CDATA node expected!");        ASTCData cdata = cdataNodes.iterator().next();        assertEquals(" some <cdata> ]] ]> ", cdata.getImage(), "Content incorrectly parsed!");    }    /**     * Test parsing of Doctype declaration.     */    @Test    void testDoctype() {        ASTCompilationUnit root = vf.parse(TEST_DOCTYPE);        List<ASTDoctypeDeclaration> docTypeDeclarations = root.findDescendantsOfType(ASTDoctypeDeclaration.class);        assertEquals(1, docTypeDeclarations.size(), "One doctype declaration expected!");        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("html", docTypeDecl.getName(), "Correct doctype-name expected!");        List<ASTDoctypeExternalId> externalIds = root.findDescendantsOfType(ASTDoctypeExternalId.class);        assertEquals(1, externalIds.size(), "One doctype external id expected!");        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId(), "Correct external public id expected!");        assertEquals("http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd", externalId.getUri(),                "Correct external uri expected!");    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void testHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Script!", text.getImage(), "Correct script content expected!");    }    /**     * Test parsing of EL in attribute of an element.     */    @Test    void testELInTagValue() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE);        assertEquals(1, elements.size(), "One element expected!");        ASTElement element = elements.iterator().next();        ASTAttributeValue attribute = element.getFirstDescendantOfType(ASTAttributeValue.class);        ASTIdentifier id = attribute.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("foo", id.getImage(), "Correct identifier expected");    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    void testELInTagValueWithCommentDQ() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT);        assertEquals(1, elements.size(), "One element expected!");        ASTElement element = elements.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("init", id.getImage(), "Correct identifier expected");    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    void testELInTagValueWithCommentSQ() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ);        assertEquals(1, elements.size(), "One element expected!");        ASTElement element = elements.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("init", id.getImage(), "Correct identifier expected");    }    /**     * Test parsing of EL in HTML &lt;script&gt; element.     */    @Test    void testELInHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("vartext=", text.getImage(), "Correct script content expected!");        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("elInScript", id.getImage(), "Correct EL content expected!");    }    /**     * Test parsing of inline comment in EL.     */    @Test    void testInlineCommentInEL() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("vartext=", text.getImage(), "Correct script content expected!");        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("elInScript", id.getImage(), "Correct EL content expected!");    }    /**     * Test parsing of quoted EL in HTML &lt;script&gt; element.     */    @Test    void testQuotedELInHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_QUOTED_EL_IN_HTML_SCRIPT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("vartext='textHere", text.getImage(), "Correct script content expected!");        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("elInScript", id.getImage(), "Correct EL content expected!");    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be     * valid html but it is likely to appear in .page files.     */    @Test    void testImportHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttribute> attr = script.findDescendantsOfType(ASTAttribute.class);        assertEquals(1, attr.size(), "One script expected!");        ASTAttribute att = attr.iterator().next();        ASTAttributeValue val = att.getFirstChildOfType(ASTAttributeValue.class);        ASTText text = val.getFirstChildOfType(ASTText.class);        assertEquals("filename.js", text.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void testHtmlScriptWithAttribute() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Script!", text.getImage(), "Correct script content expected!");        List<ASTText> attrs = script.findDescendantsOfType(ASTText.class);        assertEquals("text/javascript", attrs.get(0).getImage());    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    void testComplexHtmlScript() {        List<ASTHtmlScript> script = vf.getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals(1, script.size(), "One script expected!");        ASTHtmlScript next = script.iterator().next();        ASTText text = next.getFirstChildOfType(ASTText.class);        assertTrue(text.getImage().contains("<!--"));    }    /**     * Test parsing of HTML &lt;style&gt; element.     */    @Test    void testInlineCss() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals(3, elements.size(), "Two elements expected!");    }    /**     * Test parsing of HTML text within element.     */    @Test    void testTextInTag() {        List<ASTText> scripts = vf.getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals(1, scripts.size(), "One text chunk expected!");        ASTText script = scripts.iterator().next();        assertEquals(" some text ", script.getImage(), "Correct content expected!");    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    void noSpacesBetweenTags() {        List<ASTElement> scripts = vf.getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals(2, scripts.size(), "Two tags expected!");        Iterator<ASTElement> iterator = scripts.iterator();        ASTElement script = iterator.next();        assertEquals("a", script.getName(), "Correct content expected!");        script = iterator.next();        assertEquals("b", script.getName(), "Correct content expected!");    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    void unclosedTagsWithDollar() {        List<ASTText> scripts = vf.getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals(2, scripts.size(), "Two text chunks expected!");        ASTText script = scripts.iterator().next();        assertEquals(" $ ", script.getImage(), "Correct content expected!");    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    void unclosedTagsWithELWithin() {        List<ASTElement> element = vf.getNodes(ASTElement.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals(1, element.size(), "One element expected!");        for (ASTElement elem : element) {            ASTContent content = elem.getFirstChildOfType(ASTContent.class);            List<ASTElExpression> els = content.findChildrenOfType(ASTElExpression.class);            assertEquals(2, els.size(), "Two EL expressions expected!");            ASTElExpression node = (ASTElExpression) content.getChild(0);            ASTIdentifier id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("expr1", id.getImage(), "Correct content expected!");            node = (ASTElExpression) content.getChild(1);            id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("expr2", id.getImage(), "Correct content expected!");        }    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void textAfterOpenAndClosedTag() {        List<ASTElement> nodes = vf.getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals(2, nodes.size(), "Two elements expected!");        assertEquals("a", nodes.get(0).getName(), "First element should be a");        assertFalse(nodes.get(0).isUnclosed(), "first element should be closed");        assertEquals("b", nodes.get(1).getName(), "Second element should be b");        assertTrue(nodes.get(1).isUnclosed(), "Second element should not be closed");        List<ASTText> text = vf.getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals(2, text.size(), "Two text chunks expected!");    }    @Test    void quoteEL() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        List<ASTElExpression> els = attr.findChildrenOfType(ASTElExpression.class);        assertEquals(1, els.size(), "Must be 1!");        ASTExpression expr = els.get(0).getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = expr.getFirstChildOfType(ASTIdentifier.class);        assertEquals("something", id.getImage(), "Expected to detect proper value for attribute!");    }    /**     * smoke test for a non-quoted attribute value     */    @Test    void quoteAttrValue() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("yes|", text.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    void noQuoteAttrEmpty() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_EMPTY_ATTR);        assertEquals(2, attributes.size(), "two attributes expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertNull(attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    void singleQuoteAttrTab() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_TAB_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("\t", text.getImage(), "Expected to detect proper value for attribute!");    }    @Test    void unclosedTag() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        assertEquals(2, elements.size(), "2 tags expected");        assertEquals("tag:someTag", elements.get(0).getName(), "Second element should be tag:someTag");        assertEquals("tag:if", elements.get(1).getName(), "First element should be sorted tag:if");        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());    }    @Test    void unclosedTagAndNoQuotesForAttribute() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_ATTR);        assertEquals(2, elements.size(), "2 tags expected");        assertEquals("tag:someTag", elements.get(0).getName(), "Second element should be tag:someTag");        assertEquals("tag:if", elements.get(1).getName(), "First element should be sorted tag:if");        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());    }    @Test    void unclosedTagMultipleLevels() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals(3, elements.size(), "3 tags expected");        assertEquals("tag:someTag", sortedElmnts.get(0).getName(), "First element should be sorted tag:someTag");        assertEquals("tag:someTag", sortedElmnts.get(1).getName(), "Second element should be tag:someTag");        assertEquals("tag:x", sortedElmnts.get(2).getName(), "Third element should be tag:x");        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        assertFalse(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    void nestedEmptyTags() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals(4, elements.size(), "4 tags expected");        assertEquals("a1", sortedElmnts.get(0).getName(), "First element should a1");        assertEquals("a2", sortedElmnts.get(1).getName(), "Second element should be a2");        assertEquals("b", sortedElmnts.get(2).getName(), "Third element should be b");        assertEquals("html", sortedElmnts.get(3).getName(), "Third element should be html");        // a1        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2        assertTrue(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());        // html        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt;     * &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    void nestedMultipleTags() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals(6, elements.size(), "4 tags expected");        assertEquals("a1", sortedElmnts.get(0).getName(), "First element should a1");        assertEquals("a2", sortedElmnts.get(1).getName(), "Second element should be a2");        assertEquals("a3", sortedElmnts.get(2).getName(), "Third element should be a3");        assertEquals("a4", sortedElmnts.get(3).getName(), "Forth element should be a4");        assertEquals("b", sortedElmnts.get(4).getName(), "Fifth element should be b");        assertEquals("html", sortedElmnts.get(5).getName(), "Sixth element should be html");        // a1 not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2 not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // a3 empty and not closed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // a4 empty but closed        assertTrue(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());        // b empty but closed        assertTrue(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());        // html not empty and closed        assertFalse(sortedElmnts.get(5).isEmpty());        assertFalse(sortedElmnts.get(5).isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt;     * &lt;/x&gt; . Here x is the first tag to be closed thus rendering the next     * close of a (&lt;/a&gt;) to be disregarded.     */    @Test    void unclosedParentTagClosedBeforeChild() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals(4, elements.size(), "4 tags expected");        assertEquals("a", sortedElmnts.get(0).getName(), "First element should be 'a'");        assertEquals("b", sortedElmnts.get(1).getName(), "Second element should be b");        assertEquals("b", sortedElmnts.get(2).getName(), "Third element should be b");        assertEquals("x", sortedElmnts.get(3).getName(), "Forth element should be x");        // a        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This should     * be disregarded and structure of children and parents should not be     * influenced. in other words &lt;/a&gt; should close the first &lt;a&gt;     * tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    void unmatchedTagDoesNotInfluenceStructure() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals(4, elements.size(), "4 tags expected");        assertEquals("a", sortedElmnts.get(0).getName(), "First element should be 'a'");        assertEquals("b", sortedElmnts.get(1).getName(), "Second element should be b");        assertEquals("b", sortedElmnts.get(2).getName(), "Third element should be b");        assertEquals("x", sortedElmnts.get(3).getName(), "Forth element should be x");        // a is not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt; An unmatched closing of 'z' appears randomly in the document.     * This should be disregarded and structure of children and parents should     * not be influenced. Also un unclosed &lt;a&gt; tag appears at the start of     * the document     */    @Test    void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals(5, elements.size(), "5 tags expected");        assertEquals("a", sortedElmnts.get(0).getName(), "First element should be 'a'");        assertEquals("a", sortedElmnts.get(1).getName(), "Second element should be a");        assertEquals("b", sortedElmnts.get(2).getName(), "Third element should be b");        assertEquals("b", sortedElmnts.get(3).getName(), "Forth element should be b");        assertEquals("x", sortedElmnts.get(4).getName(), "Fifth element should be x");        // first a is empty and unclosed        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // second a not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(3).isEmpty());        assertTrue(sortedElmnts.get(3).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());    }    /**     * will sort the AST element in list in alphabetical order and if tag name     * is the same it will sort against o1.getBeginColumn() +""+     * o1.getBeginLine(). so first criteria is the name, then the second is the     * column +""+line string.     *     * @param elements     * @return     */    private List<ASTElement> sortNodesByName(List<ASTElement> elements) {        Collections.sort(elements, new Comparator<ASTElement>() {            @Override            public int compare(ASTElement o1, ASTElement o2) {                if (o1.getName() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getName() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getName().equals(o2.getName())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getName().compareTo(o2.getName());            }        });        return elements;    }    @Test    void noQuoteAttrWithJspEL() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals(1, attributes.size(), "One attribute expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTIdentifier id = attr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("something", id.getImage(), "Expected to detect proper value for EL in attribute!");    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE = "<apex:page action=\"{!foo}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT = "<apex:page action=\"{!/*comment here*/init}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ = "<apex:page action='{!/*comment here*/init}'>text</apex:page>";    private static final String TEST_EL_IN_HTML_SCRIPT = "<html><head><script>var text={!elInScript};</script></head></html>";    private static final String TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT = "<html><head><script>var text={!/*junk1*/elInScript/*junk2*/};</script></head></html>";    private static final String TEST_QUOTED_EL_IN_HTML_SCRIPT = "<html><head><script>var text='textHere{!elInScript}';</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" /></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>{!expr1}{!expr2}</a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"{!something}\" > </tag:if>";    private static final String TEST_ATTR = "<tag:if something=\"yes|\" > </tag:if>";    private static final String TEST_EMPTY_ATTR = "<tag:if something= >  <a href=\"http://someHost:/some_URL\" >foo</a> </tag:if>";    private static final String TEST_TAB_ATTR = "<tag:if something='\t' >   </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if something=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag something=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_ATTR = "<tag:someTag> <tag:if something='x' > </tag:someTag>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<apex:someTag something={!something} > foo </apex:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;public abstract class AbstractVfTest {    protected final VfParsingHelper vf =        VfParsingHelper.DEFAULT            .withResourceContext(getClass());}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.nio.file.Path;import java.util.Hashtable;import java.util.List;import java.util.Map;import org.apache.commons.lang3.tuple.Pair;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.vf.VFTestUtils;class ApexClassPropertyTypesVisitorTest {    @Test    @SuppressWarnings("PMD.CloseResource")    void testApexClassIsProperlyParsed() {        Path apexPath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Apex)                                   .resolve("ApexController.cls")                                   .toAbsolutePath();        ApexClassPropertyTypesVisitor visitor = new ApexClassPropertyTypesVisitor();        ApexClassPropertyTypes.parseApex(apexPath).acceptVisitor(visitor, null);        List<Pair<String, String>> variables = visitor.getVariables();        assertEquals(7, variables.size());        Map<String, String> variableNameToVariableType = new Hashtable<>();        for (Pair<String, String> variable : variables) {            // Map the values and ensure there were no duplicates            String previous = variableNameToVariableType.put(variable.getKey(), variable.getValue());            assertNull(previous, variable.getKey());        }        assertTrue("ID".equalsIgnoreCase(variableNameToVariableType.get("ApexController.AccountIdProp")));        assertTrue("ID".equalsIgnoreCase(variableNameToVariableType.get("ApexController.AccountId")));        assertTrue("String".equalsIgnoreCase(variableNameToVariableType.get("ApexController.AccountName")));        assertTrue("ApexController.InnerController".equalsIgnoreCase(variableNameToVariableType.get("ApexController.InnerController")));        assertTrue("ID".equalsIgnoreCase(variableNameToVariableType.get("ApexController.InnerController.InnerAccountIdProp")));        assertTrue("ID".equalsIgnoreCase(variableNameToVariableType.get("ApexController.InnerController.InnerAccountId")));        assertTrue("String".equalsIgnoreCase(variableNameToVariableType.get("ApexController.InnerController.InnerAccountName")));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @BeforeEach    void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *     */    @Test    void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt;     */    @Test    void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    public RuleSetFactoryTest() {        super(ApexLanguageModule.TERSE_NAME);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import apex.jorje.semantic.symbol.type.BasicType;class DataTypeTest {    @Test    void testFromString() {        assertEquals(DataType.AutoNumber, DataType.fromString("AutoNumber"));        assertEquals(DataType.AutoNumber, DataType.fromString("autonumber"));        assertEquals(DataType.Unknown, DataType.fromString(""));        assertEquals(DataType.Unknown, DataType.fromString(null));    }    @Test    void testFromTypeName() {        assertEquals(DataType.Checkbox, DataType.fromTypeName("Boolean"));        assertEquals(DataType.Currency, DataType.fromTypeName("Currency"));        assertEquals(DataType.DateTime, DataType.fromTypeName("Datetime"));        assertEquals(DataType.Number, DataType.fromTypeName("DECIMAL"));        assertEquals(DataType.Number, DataType.fromTypeName("double"));        assertEquals(DataType.Text, DataType.fromTypeName("string"));        assertEquals(DataType.Unknown, DataType.fromTypeName("Object"));        assertEquals(DataType.Unknown, DataType.fromTypeName(null));    }    @Test    void testDeprecatedFromBasicType() {        assertEquals(DataType.Checkbox, DataType.fromBasicType(BasicType.BOOLEAN));        assertEquals(DataType.Number, DataType.fromBasicType(BasicType.DECIMAL));        assertEquals(DataType.Number, DataType.fromBasicType(BasicType.DOUBLE));        assertEquals(DataType.Unknown, DataType.fromBasicType(BasicType.APEX_OBJECT));        assertEquals(DataType.Unknown, DataType.fromBasicType(null));    }    @Test    void testRequiresEncoding() {        assertFalse(DataType.AutoNumber.requiresEscaping);        assertTrue(DataType.Text.requiresEscaping);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static java.util.Collections.singleton;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.File;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.vf.ast.AbstractVfTest;/** * @author sergey.gorbaty * */class LanguageVersionDiscovererTest extends AbstractVfTest {    /**     * Test on VF file.     */    @Test    void testVFFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(LanguageRegistry.PMD);        File vfFile = new File("/path/to/MyPage.page");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals(vf.getLanguage().getDefaultVersion(), languageVersion, "LanguageVersion must be VF!");    }    @Test    void testComponentFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(new LanguageRegistry(singleton(vf.getLanguage())));        File vfFile = new File("/path/to/MyPage.component");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals(vf.getLanguage().getDefaultVersion(), languageVersion, "LanguageVersion must be VF!");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vf.VfLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VfLanguageModule.NAME, VfLanguageModule.TERSE_NAME, "",            getLanguage(VfLanguageModule.NAME).getDefaultVersion(), }, });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class DartTokenizerTest extends CpdTextComparisonTest {    DartTokenizerTest() {        super(".dart");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new DartTokenizer();    }    @Test    void testComment() {        doTest("comment");    }    @Test    void testEscapeSequences() {        doTest("escape_sequences");    }    @Test    void testEscapedBackslash() {        doTest("escaped_backslash");    }    @Test    void testEscapedString() {        doTest("escaped_string");    }    @Test    void testIncrement() {        doTest("increment");    }    @Test    void testImports() {        doTest("imports");    }    @Test    void testStringInterpolation() {        doTest("string_interpolation");    }    @Test    void testEscapedDollar() {        doTest("escaped_dollar");    }    @Test    void testRegex() {        doTest("regex");    }    @Test    void testRegex2() {        doTest("regex2");    }    @Test    void testRegex3() {        doTest("regex3");    }    @Test    void testStringWithBackslashes() {        doTest("string_with_backslashes");    }    @Test    void testMultiline() {        doTest("string_multiline");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class PythonTokenizerTest extends CpdTextComparisonTest {    PythonTokenizerTest() {        super(".py");    }    @Override    protected String getResourcePrefix() {        return "../lang/python/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PythonTokenizer();    }            @Test    void sampleTest() {        doTest("sample_python");    }    @Test    void specialComments() {        doTest("special_comments");    }    @Test    void testBackticks() {        doTest("backticks");    }    @Test    void testUnicode() {        doTest("sample_unicode");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }    @Test    void testVarWithDollar() {        doTest("var_with_dollar");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.xml.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class XmlCPDTokenizerTest extends CpdTextComparisonTest {    XmlCPDTokenizerTest() {        super(".xml");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new XmlTokenizer();    }    @Test    void tokenizeTest() {        doTest("simple");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MistypedCDATASectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.xml.XmlParsingHelper;class XmlXPathRuleTest {    private static final String A_URI = "http://soap.sforce.com/2006/04/metadata";    private static final String FXML_IMPORTS = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                                               + "\n"                                               + "<!--suppress JavaFxDefaultTag -->\n"                                               + "\n"                                               + "<?import javafx.scene.layout.AnchorPane?>\n"                                               + "<?import javafx.scene.layout.BorderPane?>\n"                                               + "<?import javafx.scene.control.Tooltip?>\n"                                               + "<?import javafx.scene.control.Label?>\n"                                               + "<?import org.kordamp.ikonli.javafx.FontIcon?>\n"                                               + "<AnchorPane prefHeight=\"750.0\" prefWidth=\"1200.0\" stylesheets=\"@../css/designer.css\" xmlns=\"http://javafx.com/javafx/8\" xmlns:fx=\"http://javafx.com/fxml/1\">\n"                                               + "</AnchorPane>";    final XmlParsingHelper xml = XmlParsingHelper.XML;    private Rule makeXPath(String expression) {        return makeXPath(expression, "");    }    private Rule makeXPath(String expression, String nsUri) {        DomXPathRule rule = new DomXPathRule(expression, nsUri);        rule.setLanguage(xml.getLanguage());        rule.setMessage("XPath Rule Failed");        return rule;    }    @Test    void testFileNameInXpath() {        Report report = xml.executeRule(makeXPath("//b[pmd:fileName() = 'Foo.xml']"),                                        "<a><b></b></a>",                                        "src/Foo.xml");        assertSize(report, 1);    }    @Test    void testTextFunctionInXpath() {        // https://github.com/pmd/pmd/issues/915        Report report = xml.executeRule(makeXPath("//app[text()[1]='app2']"),                                        "<a><app>app2</app></a>");        assertSize(report, 1);    }    @Test    void testRootNodeWildcardUri() {        // https://github.com/pmd/pmd/issues/3413#issuecomment-1072614398        Report report = xml.executeRule(makeXPath("/*:Flow"),                                        "<Flow xmlns=\"http://soap.sforce.com/2006/04/metadata\">\n"                                        + "</Flow>");        assertSize(report, 1);    }    @Test    void testNoNamespaceRoot() {        Report report = xml.executeRule(makeXPath("/Flow"),                                        "<Flow>\n"                                        + "</Flow>");        assertSize(report, 1);    }    @Test    void testNamespaceDescendantWrongDefaultUri() {        Report report = xml.executeRule(makeXPath("//a"),                                        "<Flow xmlns='" + A_URI + "'><a/></Flow>");        assertSize(report, 0);    }    @Test    void testNamespaceDescendantOkUri() {        Report report = xml.executeRule(makeXPath("//a", A_URI),                                        "<Flow xmlns='" + A_URI + "'><a/></Flow>");        assertSize(report, 1);        report = xml.executeRule(makeXPath("//*:a"),                                 "<Flow xmlns='" + A_URI + "'><a/></Flow>");        assertSize(report, 1);    }    @Test    void testNamespaceDescendantWildcardUri() {        Report report = xml.executeRule(makeXPath("//*:a"),                                        "<Flow xmlns='" + A_URI + "'><a/></Flow>");        assertSize(report, 1);    }    @Test    void testNamespacePrefixDescendantWildcardUri() {        Report report = xml.executeRule(makeXPath("//*:Flow"),                                        "<my:Flow xmlns:my='" + A_URI + "'><a/></my:Flow>");        assertSize(report, 1);    }    @Test    void testNamespacePrefixDescendantOkUri() {        Report report = xml.executeRule(makeXPath("//Flow", A_URI),                                        "<my:Flow xmlns:my='" + A_URI + "'><a/></my:Flow>");        assertSize(report, 1);    }    @Test    void testNamespacePrefixDescendantWrongUri() {        Report report = xml.executeRule(makeXPath("//Flow", "wrongURI"),                                        "<my:Flow xmlns:my='" + A_URI + "'><a/></my:Flow>");        assertSize(report, 0);    }    @Test    void testRootExpr() {        Report report = xml.executeRule(makeXPath("/"),                                        "<Flow><a/></Flow>");        assertSize(report, 1);    }    @Test    void testProcessingInstructions() {        Report report = xml.executeRule(makeXPath("/child::processing-instruction()", "http://javafx.com/javafx/8"),                                        FXML_IMPORTS);        assertSize(report, 5);    }    @Test    void testProcessingInstructionsNamed() {        Report report = xml.executeRule(makeXPath("/child::processing-instruction('import')"),                                        FXML_IMPORTS);        assertSize(report, 5);    }    @Test    void testProcessingInstructionXML() {        // <?xml ?> does not create a PI        Report report = xml.executeRule(makeXPath("/child::processing-instruction('xml')", "http://javafx.com/javafx/8"),                                        FXML_IMPORTS);        assertSize(report, 0);    }    @Test    void testComments() {        Report report = xml.executeRule(makeXPath("/child::comment()[fn:starts-with(fn:string(.), 'suppress')]"),                                        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                                        + "<!--suppress JavaFxDefaultTag -->\n"                                        + "<AnchorPane prefHeight=\"750.0\" prefWidth=\"1200.0\" stylesheets=\"@../css/designer.css\" xmlns=\"http://javafx.com/javafx/8\" xmlns:fx=\"http://javafx.com/fxml/1\">\n"                                        + "</AnchorPane>");        assertSize(report, 1);    }    @Test    void testXmlNsFunctions() {        // https://github.com/pmd/pmd/issues/2766        Report report = xml.executeRule(            makeXPath("/manifest[namespace-uri-for-prefix('android', .) = 'http://schemas.android.com/apk/res/android']"),            "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"            + "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n"            + "         package=\"com.a.b\">\n"            + "\n"            + "        <application\n"            + "             android:allowBackup=\"true\"\n"            + "             android:icon=\"@mipmap/ic_launcher\"\n"            + "             android:label=\"@string/app_name\"\n"            + "             android:roundIcon=\"@mipmap/ic_launcher_round\"\n"            + "             android:supportsRtl=\"true\"\n"            + "             android:theme=\"@style/AppTheme\">\n"            + "         <activity android:name=\".MainActivity\">\n"            + "             <intent-filter>\n"            + "                 <action android:name=\"android.intent.action.MAIN\" />\n"            + "\n"            + "                 <category android:name=\"android.intent.category.LAUNCHER\" />\n"            + "             </intent-filter>\n"            + "         </activity>\n"            + "     </application>\n"            + "\n"            + "</manifest>");        assertSize(report, 1);    }    @Test    void testLocationFuns() {        Rule rule = makeXPath("//Flow[pmd:startLine(.) != pmd:endLine(.)]");        Report report = xml.executeRule(rule, "<Flow><a/></Flow>");        assertSize(report, 0);        report = xml.executeRule(rule, "<Flow>\n<a/>\n</Flow>");        assertSize(report, 1);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.ast;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.CoordinatesPrinter;import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;import net.sourceforge.pmd.lang.xml.XmlParsingHelper;class XmlCoordinatesTest extends BaseTreeDumpTest {    XmlCoordinatesTest() {        super(CoordinatesPrinter.INSTANCE, ".xml");    }    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return XmlParsingHelper.XML.withResourceContext(getClass(), "testdata");    }    /**     * See bug #1054: XML Rules ever report a line -1 and not the line/column     * where the error occurs     */    @Test    void testLineNumbers() {        doTest("xmlCoords");    }    @Test    void testAutoclosingElementLength() {        final String xml = "<elementName att1='foo' att2='bar' att3='other' />";        TestUtilsKt.assertPosition(XmlParsingHelper.XML.parse(xml), 1, 1, 1, xml.length());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.ast;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.xml.XmlParsingHelper;class XmlParserTest extends BaseTreeDumpTest {    XmlParserTest() {        super(new RelevantAttributePrinter(), ".xml");    }    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return XmlParsingHelper.XML.withResourceContext(getClass(), "testdata");    }    /**     * Verifies the default parsing behavior of the XML parser.     */    @Test    void testDefaultParsing() {        doTest("sampleXml");    }    @Test    void testNamespaces() {        doTest("sampleNs");    }    @Test    void testBug1518() {        doTest("bug1518");    }    @Test    void dtdIsNotLookedUp() {        // no exception should be thrown        XmlParsingHelper.XML.parse(            "<!DOCTYPE struts-config PUBLIC "                + " \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN \" "                + " \"http://jakarta.inexistinghost.org/struts/dtds/struts-config_1_1.dtd\" >"                + "<struts-config/>");    }    @Test    void xsdIsNotLookedUp() {        // no exception should be thrown        XmlParsingHelper.XML.parse(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?> "                + "<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" "                + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "                + "xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.inexisting.com/xml/ns/javaee/web-app_2_5.xsd\" "                + "version=\"2.5\">"                + "</web-app>");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD.StatusCode;import net.sourceforge.pmd.cli.BaseCLITest;public class XmlCliTest extends BaseCLITest {    private static final String BASE_DIR = "src/test/resources/net/sourceforge/pmd/lang/xml/cli-tests/sampleproject";    private static final String RULE_MESSAGE = "A tags are not allowed";    private String[] createArgs(String directory, String... args) {        List<String> arguments = new ArrayList<>(listOf(            "-f",            "text",            "--no-cache",            "--no-progress",            "-R",            BASE_DIR + "/ruleset.xml",            "-d",            BASE_DIR + directory        ));        arguments.addAll(Arrays.asList(args));        return arguments.toArray(new String[0]);    }    @Test    public void analyzeSingleXmlWithoutForceLanguage() {        String log = runTest(StatusCode.OK, createArgs("/src/file1.ext"));        assertRuleMessage(0, log);    }    @Test    public void analyzeSingleXmlWithForceLanguage() {        String log = runTest(StatusCode.VIOLATIONS_FOUND, createArgs("/src/file1.ext", "-force-language", "xml"));        assertRuleMessage(1, log);    }    @Test    public void analyzeDirectoryWithForceLanguage() {        String log = runTest(StatusCode.VIOLATIONS_FOUND, createArgs("/src/", "-force-language", "xml"));        assertRuleMessage(3, log);    }    private void assertRuleMessage(int expectedCount, String log) {        Assert.assertEquals(expectedCount, StringUtils.countMatches(log, RULE_MESSAGE));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ProjectVersionAsDependencyVersionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class InvalidDependencyTypesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidAxisNavigationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseConcatOnceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testXML() {        executeTarget("testXML");        assertOutputContaining("Potentially mistyped CDATA section with extra [ at beginning or ] at the end.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.pom.PomLanguageModule;import net.sourceforge.pmd.lang.wsdl.WsdlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xsl.XslLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { XmlLanguageModule.NAME, XmlLanguageModule.TERSE_NAME, "",                getLanguage(XmlLanguageModule.NAME).getDefaultVersion(), },            { XslLanguageModule.NAME, XslLanguageModule.TERSE_NAME, "",                getLanguage(XslLanguageModule.NAME).getDefaultVersion(), },            { WsdlLanguageModule.NAME, WsdlLanguageModule.TERSE_NAME, "",                getLanguage(WsdlLanguageModule.NAME).getDefaultVersion(), },            { PomLanguageModule.NAME, PomLanguageModule.TERSE_NAME, "",                getLanguage(PomLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test xml's and xslt's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class GoTokenizerTest extends CpdTextComparisonTest {    GoTokenizerTest() {        super(".go");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new GoTokenizer();    }    @Override    protected String getResourcePrefix() {        return "../lang/go/cpd/testdata";    }    @Test    void simpleTest() {        doTest("hello");    }    @Test    void bigFileTest() {        doTest("btrfs");    }    @Test    void testIssue1751() {        doTest("issue-1751");    }    @Test    void testUnicode() {        // https://github.com/pmd/pmd/issues/2752        doTest("sample_unicode");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.gherkin.cpd.GherkinTokenizer;class GherkinTokenizerTest extends CpdTextComparisonTest {    GherkinTokenizerTest() {        super(".feature");    }    @Override    protected String getResourcePrefix() {        return "../lang/gherkin/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        GherkinTokenizer tok = new GherkinTokenizer();        return tok;    }    @Test    void testAnnotatedSource() {        doTest("annotatedSource");    }    @Test    void testDocstring() {        doTest("docstring");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.ast.TokenMgrError;class CsTokenizerTest extends CpdTextComparisonTest {    CsTokenizerTest() {        super(".cs");    }    @Override    protected String getResourcePrefix() {        return "../lang/cs/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        CsTokenizer tok = new CsTokenizer();        tok.setProperties(properties);        return tok;    }    @Test    void testSimpleClass() {        doTest("simpleClass");    }    @Test    void testSimpleClassMethodMultipleLines() {        doTest("simpleClassMethodMultipleLines");    }    @Test    void testStrings() {        doTest("strings");    }    @Test    void testOpenString() {        assertThrows(TokenMgrError.class, () -> doTest("unlexable_string"));    }    @Test    void testCommentsIgnored1() {        doTest("comments");    }    @Test    void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    void testOperators() {        doTest("operatorsAndStuff");    }    @Test    void testLineNumberAfterMultilineString() {        doTest("strings");    }    @Test    void testDoNotIgnoreUsingDirectives() {        doTest("usingDirectives");    }    @Test    void testIgnoreUsingDirectives() {        doTest("usingDirectives", "_ignored", ignoreUsings());    }    @Test    void testTabWidth() {        doTest("tabWidth");    }    @Test    void testLongListsOfNumbersAreNotIgnored() {        doTest("listOfNumbers");    }    @Test    void testLongListsOfNumbersAreIgnored() {        doTest("listOfNumbers", "_ignored", skipLiteralSequences());    }    @Test    void testCSharp7And8Additions() {        doTest("csharp7And8Additions");    }    @Test    void testAttributesAreNotIgnored() {        doTest("attributes");    }    @Test    void testAttributesAreIgnored() {        doTest("attributes", "_ignored", skipAttributes());    }    private Properties ignoreUsings() {        return properties(true, false, false);    }    private Properties skipLiteralSequences() {        return properties(false, true, false);    }    private Properties skipAttributes() {        return properties(false, false, true);    }    private Properties properties(boolean ignoreUsings, boolean ignoreLiteralSequences, boolean ignoreAttributes) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.IGNORE_USINGS, Boolean.toString(ignoreUsings));        properties.setProperty(Tokenizer.OPTION_IGNORE_LITERAL_SEQUENCES, Boolean.toString(ignoreLiteralSequences));        properties.setProperty(Tokenizer.IGNORE_ANNOTATIONS, Boolean.toString(ignoreAttributes));        return properties;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import java.net.URI;import java.util.ArrayList;import java.util.List;import java.util.Properties;import org.junit.Ignore;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.test.schema.RuleTestDescriptor;/** * Stores the information required to run a complete test. * * @deprecated Use {@link RuleTestDescriptor} instead */@Ignore("this is not a unit test")@Deprecatedpublic class TestDescriptor {    private Rule rule;    private Properties properties;    private String description;    private int numberOfProblemsExpected;    private List<String> expectedMessages = new ArrayList<>();    private List<Integer> expectedLineNumbers = new ArrayList<>();    private String code;    private LanguageVersion languageVersion;    // default, avoids unintentional mixing of state between test cases    private boolean reinitializeRule = true;    private boolean isRegressionTest = true;    private boolean useAuxClasspath = true;    private int numberInDocument = -1;    private URI testSourceUri;    public TestDescriptor() {        // Empty default descriptor added to please mvn surefire plugin    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this(code, description, numberOfProblemsExpected, rule, rule.getLanguage().getDefaultVersion());    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule,                          LanguageVersion languageVersion) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;        this.languageVersion = languageVersion;    }    // for compatibility    TestDescriptor(RuleTestDescriptor td, String absoluteUriToTestXmlFile) {        this.rule = td.getRule();        this.code = td.getCode();        this.description = td.getDescription();        this.numberOfProblemsExpected = td.getExpectedProblems();        this.expectedLineNumbers = td.getExpectedLineNumbers();        this.expectedMessages = td.getExpectedMessages();        this.isRegressionTest = !td.isDisabled();        this.numberInDocument = td.getIndex();        this.properties = td.getProperties();        this.languageVersion = td.getLanguageVersion();        this.numberInDocument = td.getIndex();        this.setTestSourceUri(absoluteUriToTestXmlFile, td.getLineNumber());    }    public int getNumberInDocument() {        return numberInDocument;    }    public void setNumberInDocument(int numberInDocument) {        this.numberInDocument = numberInDocument;    }    public void setExpectedMessages(List<String> messages) {        expectedMessages.clear();        expectedMessages.addAll(messages);    }    public List<String> getExpectedMessages() {        return expectedMessages;    }    public void setExpectedLineNumbers(List<Integer> expectedLineNumbers) {        this.expectedLineNumbers.clear();        this.expectedLineNumbers.addAll(expectedLineNumbers);    }    public List<Integer> getExpectedLineNumbers() {        return expectedLineNumbers;    }    public void setProperties(Properties properties) {        this.properties = properties;    }    public Properties getProperties() {        return properties;    }    public String getCode() {        return code;    }    public LanguageVersion getLanguageVersion() {        return languageVersion;    }    public String getDescription() {        return description;    }    public int getNumberOfProblemsExpected() {        return numberOfProblemsExpected;    }    public Rule getRule() {        return rule;    }    public boolean getReinitializeRule() {        return reinitializeRule;    }    public void setReinitializeRule(boolean reinitializeRule) {        this.reinitializeRule = reinitializeRule;    }    /**     * Checks whether we are testing for regression problems only. Return value     * is based on the system property "pmd.regress".     *     * @return <code>false</code> if system property "pmd.regress" is set to     *         <code>false</code>, <code>true</code> otherwise     */    public static boolean inRegressionTestMode() {        boolean inRegressionMode = true; // default        try {            // get the "pmd.regress" System property            String property = System.getProperty("pmd.regress");            if (property != null) {                inRegressionMode = Boolean.parseBoolean(property);            }        } catch (IllegalArgumentException e) {            throw new RuntimeException("Invalid system property 'pmd.regress'", e);        }        return inRegressionMode;    }    public boolean isRegressionTest() {        return isRegressionTest;    }    public void setRegressionTest(boolean isRegressionTest) {        this.isRegressionTest = isRegressionTest;    }    public void setUseAuxClasspath(boolean useAuxClasspath) {        this.useAuxClasspath = useAuxClasspath;    }    public boolean isUseAuxClasspath() {        return useAuxClasspath;    }    @Override    public String toString() {        return description + "\n\n" + code;    }    public String getTestMethodName() {        return getRule().getName() + "_"                + getNumberInDocument()                + "_"                + getDescription()                .replaceAll("\n|\r", "_")                .replaceAll("[^\\w\\d_$]", "_")                .replaceAll("\\s+", "_");    }    public void setTestSourceUri(String absoluteUri, int line) {        this.testSourceUri = URI.create(absoluteUri + "?line=" + line);    }    public URI getTestSourceUri() {        return testSourceUri;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.util.List;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;/** * @author Romain PELISSE, belaran@gmail.com * * @deprecated Use CpdTextComparisonTest in module pmd-lang-test */@Deprecatedpublic abstract class AbstractTokenizerTest {    protected int expectedTokenCount;    protected Tokenizer tokenizer;    protected SourceCode sourceCode;    public abstract void buildTokenizer() throws IOException;    public abstract String getSampleCode() throws IOException;    protected void tokenizeTest() throws IOException {        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        List<TokenEntry> entries = tokens.getTokens();        assertEquals(expectedTokenCount, entries.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.nio.file.Files;import java.util.regex.Pattern;import org.apache.tools.ant.util.TeeOutputStream;import org.hamcrest.BaseMatcher;import org.hamcrest.Description;import org.hamcrest.Matcher;import org.junit.BeforeClass;import org.junit.Rule;import org.junit.contrib.java.lang.system.SystemErrRule;import org.junit.contrib.java.lang.system.SystemOutRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMD.StatusCode;import net.sourceforge.pmd.internal.util.AssertionUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * * @deprecated Only pmd-cli module should use / test the CLI. */@Deprecatedpublic abstract class BaseCLITest {    protected static final String TEST_OUPUT_DIRECTORY = "target/cli-tests/";    // Points toward a folder with not many source files, to avoid actually PMD    // and slowing down tests    protected static final String SOURCE_FOLDER = "src/test/resources/net/sourceforge/pmd/cli";    @Rule    public SystemErrRule systemErrRule = new SystemErrRule().muteForSuccessfulTests();    @Rule    public SystemOutRule systemOutRule = new SystemOutRule().muteForSuccessfulTests();    /**     * @throws java.lang.Exception     */    @BeforeClass    public static void setUp() throws Exception {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        File testOuputDir = new File(TEST_OUPUT_DIRECTORY);        if (!testOuputDir.exists()) {            assertTrue("failed to create output directory for test:" + testOuputDir.getAbsolutePath(),                    testOuputDir.mkdirs());        }    }    protected void createTestOutputFile(String filename) {        try {            @SuppressWarnings("PMD.CloseResource")            PrintStream out = new PrintStream(Files.newOutputStream(new File(filename).toPath()));            System.setOut(out);            System.setErr(out);        } catch (IOException e) {            fail("Can't create file " + filename + " for test.");        }    }    /**     * @deprecated Use {@link #runTest(String...)}, note that     *     it returns the log while this returns the name of a file containing the log.     */    @Deprecated    protected String runTest(String[] args, String testname) {        return runTest(args, testname, 0);    }    /**     * @deprecated Use {@link #runTest(StatusCode, String...)}, note that     *     it returns the log while this returns the name of a file containing the log.     */    @Deprecated    protected String runTest(String[] args, String testname, int expectedExitCode) {        String filename = TEST_OUPUT_DIRECTORY + testname + ".txt";        long start = System.currentTimeMillis();        createTestOutputFile(filename);        System.out.println("Start running test " + testname);        StatusCode statusCode = PMD.runPmd(args);        assertEquals(expectedExitCode, statusCode.toInt());        System.out.println("Test finished successfully after " + (System.currentTimeMillis() - start) + "ms.");        return filename;    }    /**     * Returns the log output.     */    protected String runTest(String... args) {        return runTest(StatusCode.OK, args);    }    /**     * Returns the log output.     *     * @deprecated Use {@link #runTest(StatusCode, String...)}     */    @Deprecated    protected String runTest(int expectedExitCode, String... args) {        switch (expectedExitCode) {        case 0:            return runTest(StatusCode.OK, args);        case 1:            return runTest(StatusCode.ERROR, args);        case 4:            return runTest(StatusCode.VIOLATIONS_FOUND, args);        default:            throw AssertionUtil.shouldNotReachHere("unknown status code " + expectedExitCode);        }    }    protected String runTest(StatusCode expectedExitCode, String... args) {        ByteArrayOutputStream console = new ByteArrayOutputStream();        PrintStream out = new PrintStream(new TeeOutputStream(console, System.out));        PrintStream err = new PrintStream(new TeeOutputStream(console, System.err));        System.setOut(out);        System.setErr(err);        StatusCode statusCode = PMD.runPmd(args);        assertEquals(expectedExitCode, statusCode);        return console.toString();    }    /**     * @deprecated Use {@link #runTest(StatusCode, String...)}     */    @Deprecated    protected void runPMDWith(String[] args) {        PMD.main(args);    }    /**     * @deprecated Use {@link #runTest(StatusCode, String...)} instead of checking the return code manually     */    @Deprecated    protected void checkStatusCode(int expectedExitCode) {        int statusCode = getStatusCode();        if (statusCode != expectedExitCode) {            fail("PMD failed with status code: " + statusCode);        }    }    /**     * @deprecated Use {@link #runTest(StatusCode, String...)} instead     * of checking the return code manually     */    @Deprecated    protected int getStatusCode() {        return Integer.parseInt(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY));    }    public static Matcher<String> containsPattern(final String regex) {        return new BaseMatcher<String>() {            final Pattern pattern = Pattern.compile(regex);            @Override            public void describeTo(Description description) {                description.appendText("a string containing the pattern '" + this.pattern + "'");            }            @Override            public boolean matches(Object o) {                return o instanceof String && pattern.matcher((String) o).find();            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.UnsupportedEncodingException;import org.junit.After;import org.junit.Assert;import org.junit.Before;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.cpd.CPDCommandLineInterface;public abstract class BaseCPDCLITest {    private ByteArrayOutputStream bufferStdout;    private ByteArrayOutputStream bufferStderr;    private PrintStream originalStdout;    private PrintStream originalStderr;    @Before    public void setup() throws UnsupportedEncodingException {        originalStdout = System.out;        originalStderr = System.err;        bufferStdout = new ByteArrayOutputStream();        System.setOut(new PrintStream(bufferStdout, false, "UTF-8"));        bufferStderr = new ByteArrayOutputStream();        System.setErr(new PrintStream(bufferStderr, false, "UTF-8"));    }    @After    public void teardown() {        System.setOut(originalStdout);        System.setErr(originalStderr);    }    /**     * @deprecated Use {@link #runTest(CPD.StatusCode, String...)} which returns the output.     */    @Deprecated    public final String getOutput() {        try {            return bufferStdout.toString("UTF-8");        } catch (UnsupportedEncodingException e) {            throw new RuntimeException(e);        }    }    /**     * @deprecated Use {@link #runTest(CPD.StatusCode, String...)}     */    @Deprecated    protected void runCPD(String... args) {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPD.main(args);    }    protected String getStderr() {        try {            return bufferStderr.toString("UTF-8");        } catch (UnsupportedEncodingException e) {            throw new RuntimeException(e);        }    }    protected String runTest(CPD.StatusCode expectedStatusCode, String... args) {        CPD.StatusCode statusCode = CPD.runCpd(args);        Assert.assertEquals("Unexpected status code", expectedStatusCode, statusCode);        return getOutput();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Properties;import java.util.Set;import java.util.StringTokenizer;import java.util.regex.Pattern;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.junit.BeforeClass;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import org.xml.sax.helpers.DefaultHandler;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.IOUtil;/** * Base test class to verify the language's rulesets. This class should be * subclassed for each language. */public abstract class AbstractRuleSetFactoryTest {    @org.junit.Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    private static ValidateDefaultHandler validateDefaultHandler;    private static SAXParser saxParser;    protected Set<String> validXPathClassNames = new HashSet<>();    private final Set<String> languagesToSkip = new HashSet<>();    public AbstractRuleSetFactoryTest() {        this(new String[0]);    }    /**     * Constructor used when a module that depends on another module wants to filter out the dependee's rulesets.     *     * @param languagesToSkip {@link Language}s terse names that appear in the classpath via a dependency, but should be     * skipped because they aren't the primary language which the concrete instance of this class is testing.     */    public AbstractRuleSetFactoryTest(String... languagesToSkip) {        this.languagesToSkip.addAll(Arrays.asList(languagesToSkip));        validXPathClassNames.add(XPathRule.class.getName());    }    /**     * Setups the XML parser with validation.     *     * @throws Exception     *             any error     */    @BeforeClass    public static void init() throws Exception {        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();        saxParserFactory.setValidating(true);        saxParserFactory.setNamespaceAware(true);        // Hope we're using Xerces, or this may not work!        // Note: Features are listed here        // http://xerces.apache.org/xerces2-j/features.html        saxParserFactory.setFeature("http://xml.org/sax/features/validation", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema-full-checking", true);        validateDefaultHandler = new ValidateDefaultHandler();        saxParser = saxParserFactory.newSAXParser();    }    /**     * Checks all rulesets of all languages on the classpath and verifies that     * all required attributes for all rules are specified.     *     * @throws Exception     *             any error     */    @Test    public void testAllPMDBuiltInRulesMeetConventions() throws Exception {        int invalidSinceAttributes = 0;        int invalidExternalInfoURL = 0;        int invalidClassName = 0;        int invalidRegexSuppress = 0;        int invalidXPathSuppress = 0;        StringBuilder messages = new StringBuilder();        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            RuleSet ruleSet = loadRuleSetByFileName(fileName);            for (Rule rule : ruleSet.getRules()) {                // Skip references                if (rule instanceof RuleReference) {                    continue;                }                Language language = rule.getLanguage();                String group = fileName.substring(fileName.lastIndexOf('/') + 1);                group = group.substring(0, group.indexOf(".xml"));                if (group.indexOf('-') >= 0) {                    group = group.substring(0, group.indexOf('-'));                }                // Is since missing ?                if (rule.getSince() == null) {                    invalidSinceAttributes++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" is missing 'since' attribute")                            .append(PMD.EOL);                }                // Is URL valid ?                if (rule.getExternalInfoUrl() == null || "".equalsIgnoreCase(rule.getExternalInfoUrl())) {                    invalidExternalInfoURL++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" is missing 'externalInfoURL' attribute")                            .append(PMD.EOL);                } else {                    String expectedExternalInfoURL = "https?://pmd.(sourceforge.net|github.io)/.+/pmd_rules_"                            + language.getTerseName() + "_"                            + IOUtil.getFilenameBase(fileName)                            + ".html#"                            + rule.getName().toLowerCase(Locale.ROOT);                    if (rule.getExternalInfoUrl() == null                            || !rule.getExternalInfoUrl().matches(expectedExternalInfoURL)) {                        invalidExternalInfoURL++;                        messages.append("Rule ")                                .append(fileName)                                .append("/")                                .append(rule.getName())                                .append(" seems to have an invalid 'externalInfoURL' value (")                                .append(rule.getExternalInfoUrl())                                .append("), it should be:")                                .append(expectedExternalInfoURL)                                .append(PMD.EOL);                    }                }                // Proper class name/packaging?                String expectedClassName = "net.sourceforge.pmd.lang." + language.getTerseName() + ".rule." + group                        + "." + rule.getName() + "Rule";                if (!rule.getRuleClass().equals(expectedClassName)                        && !validXPathClassNames.contains(rule.getRuleClass())) {                    invalidClassName++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" seems to have an invalid 'class' value (")                            .append(rule.getRuleClass())                            .append("), it should be:")                            .append(expectedClassName)                            .append(PMD.EOL);                }                // Should not have violation suppress regex property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR) != null) {                    invalidRegexSuppress++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" should not have '")                            .append(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name())                            .append("', this is intended for end user customization only.")                            .append(PMD.EOL);                }                // Should not have violation suppress xpath property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) != null) {                    invalidXPathSuppress++;                    messages.append("Rule ").append(fileName).append("/").append(rule.getName()).append(" should not have '").append(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name()).append("', this is intended for end user customization only.").append(PMD.EOL);                }            }        }        // We do this at the end to ensure we test ALL the rules before failing        // the test        if (invalidSinceAttributes > 0 || invalidExternalInfoURL > 0 || invalidClassName > 0 || invalidRegexSuppress > 0                || invalidXPathSuppress > 0) {            fail("All built-in PMD rules need 'since' attribute (" + invalidSinceAttributes                    + " are missing), a proper ExternalURLInfo (" + invalidExternalInfoURL                    + " are invalid), a class name meeting conventions (" + invalidClassName + " are invalid), no '"                    + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name() + "' property (" + invalidRegexSuppress                    + " are invalid), and no '" + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name() + "' property ("                    + invalidXPathSuppress + " are invalid)" + PMD.EOL + messages);        }    }    /**     * Verifies that all rulesets are valid XML according to the xsd schema.     *     * @throws Exception     *             any error     */    @Test    public void testXmlSchema() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstSchema(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Verifies that all rulesets are valid XML according to the DTD.     *     * @throws Exception     *             any error     */    @Test    public void testDtd() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstDtd(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Reads and writes the rulesets to make sure, that no data is lost if the     * rulests are processed.     *     * @throws Exception     *             any error     */    @Test    public void testReadWriteRoundTrip() throws Exception {        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            testRuleSet(fileName);        }    }    // Gets all test PMD Ruleset XML files    private List<String> getRuleSetFileNames() throws IOException {        List<String> result = new ArrayList<>();        for (Language language : LanguageRegistry.PMD.getLanguages()) {            if (this.languagesToSkip.contains(language.getTerseName())) {                continue;            }            result.addAll(getRuleSetFileNames(language.getTerseName()));        }        return result;    }    private List<String> getRuleSetFileNames(String language) throws IOException {        List<String> ruleSetFileNames = new ArrayList<>();        ruleSetFileNames.addAll(getRuleSetFileNames(language, "rulesets/" + language + "/rulesets.properties"));        ruleSetFileNames.addAll(getRuleSetFileNames(language, "category/" + language + "/categories.properties"));        return ruleSetFileNames;    }    private List<String> getRuleSetFileNames(String language, String propertiesPath) throws IOException {        List<String> ruleSetFileNames = new ArrayList<>();        Properties properties = new Properties();        @SuppressWarnings("PMD.CloseResource")        InputStream input = getClass().getResourceAsStream(propertiesPath);        if (input == null) {            // this might happen if a language is only support by CPD, but not            // by PMD            System.err.println("No ruleset found for language " + language);            return Collections.emptyList();        }        try (InputStream is = input) {            properties.load(is);        }        String fileNames = properties.getProperty("rulesets.filenames");        StringTokenizer st = new StringTokenizer(fileNames, ",");        while (st.hasMoreTokens()) {            ruleSetFileNames.add(st.nextToken());        }        return ruleSetFileNames;    }    private RuleSet loadRuleSetByFileName(String ruleSetFileName) {        return new RuleSetLoader().loadFromResource(ruleSetFileName);    }    private boolean validateAgainstSchema(String fileName) throws IOException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstSchema(inputStream);            if (!valid) {                System.err.println("Validation against XML Schema failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstSchema(InputStream inputStream) throws IOException, SAXException {        saxParser.parse(inputStream, validateDefaultHandler.resetValid());        inputStream.close();        return validateDefaultHandler.isValid();    }    private boolean validateAgainstDtd(String fileName) throws IOException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstDtd(inputStream);            if (!valid) {                System.err.println("Validation against DTD failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstDtd(InputStream inputStream) throws IOException, SAXException {        // Read file into memory        String file = readFullyToString(inputStream);        inputStream.close();        String rulesetNamespace = RuleSetWriter.RULESET_2_0_0_NS_URI;        // Remove XML Schema stuff, replace with DTD        file = file.replaceAll("<\\?xml [ a-zA-Z0-9=\".-]*\\?>", "");        file = file.replaceAll("xmlns=\"" + rulesetNamespace + "\"", "");        file = file.replaceAll("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "");        file = file.replaceAll("xsi:schemaLocation=\"" + rulesetNamespace                + " https://pmd.sourceforge.io/ruleset_\\d_0_0.xsd\"", "");        if (RuleSetWriter.RULESET_2_0_0_NS_URI.equals(rulesetNamespace)) {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset SYSTEM "                    + "\"https://pmd.sourceforge.io/ruleset_2_0_0.dtd\">" + PMD.EOL + file;        } else {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset>" + PMD.EOL + file;        }        try (InputStream modifiedStream = new ByteArrayInputStream(file.getBytes())) {            saxParser.parse(modifiedStream, validateDefaultHandler.resetValid());        }        return validateDefaultHandler.isValid();    }    private String readFullyToString(InputStream inputStream) throws IOException {        StringBuilder buf = new StringBuilder(64 * 1024);        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {            String line;            while ((line = reader.readLine()) != null) {                buf.append(line);                buf.append(PMD.EOL);            }            return buf.toString();        }    }    private InputStream loadResourceAsStream(String resource) {        return getClass().getResourceAsStream(resource);    }    private void testRuleSet(String fileName) throws IOException, SAXException {        // Load original XML        // String xml1 =        // readFullyToString(ResourceLoader.loadResourceAsStream(fileName));        // System.out.println("xml1: " + xml1);        // Load the original RuleSet        RuleSet ruleSet1 = loadRuleSetByFileName(fileName);        // Write to XML, first time        ByteArrayOutputStream outputStream1 = new ByteArrayOutputStream();        RuleSetWriter writer1 = new RuleSetWriter(outputStream1);        writer1.write(ruleSet1);        writer1.close();        String xml2 = new String(outputStream1.toByteArray());        // System.out.println("xml2: " + xml2);        // Read RuleSet from XML, first time        RuleSetLoader loader = new RuleSetLoader();        RuleSet ruleSet2 = loader.loadFromString("", xml2);        // Do write/read a 2nd time, just to be sure        // Write to XML, second time        ByteArrayOutputStream outputStream2 = new ByteArrayOutputStream();        RuleSetWriter writer2 = new RuleSetWriter(outputStream2);        writer2.write(ruleSet2);        writer2.close();        String xml3 = new String(outputStream2.toByteArray());        // System.out.println("xml3: " + xml3);        // Read RuleSet from XML, second time        RuleSet ruleSet3 = loader.loadFromString("", xml3);        // The 2 written XMLs should all be valid w.r.t Schema/DTD        assertTrue("1st roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml3.getBytes())));        assertTrue("1st roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml3.getBytes())));        // All 3 versions of the RuleSet should be the same        assertEqualsRuleSet("Original RuleSet and 1st roundtrip Ruleset not the same (filename: " + fileName + ")",                ruleSet1, ruleSet2);        assertEqualsRuleSet("1st roundtrip Ruleset and 2nd roundtrip RuleSet not the same (filename: " + fileName + ")",                ruleSet2, ruleSet3);        // It's hard to compare the XML DOMs. At least the roundtrip ones should        // textually be the same.        assertEquals("1st roundtrip RuleSet XML and 2nd roundtrip RuleSet XML (filename: " + fileName + ")", xml2,                xml3);    }    private void assertEqualsRuleSet(String message, RuleSet ruleSet1, RuleSet ruleSet2) {        assertEquals(message + ", RuleSet name", ruleSet1.getName(), ruleSet2.getName());        assertEquals(message + ", RuleSet description", ruleSet1.getDescription(), ruleSet2.getDescription());        assertEquals(message + ", RuleSet exclude patterns", ruleSet1.getFileExclusions(),                ruleSet2.getFileExclusions());        assertEquals(message + ", RuleSet include patterns", ruleSet1.getFileInclusions(),                ruleSet2.getFileInclusions());        assertEquals(message + ", RuleSet rule count", ruleSet1.getRules().size(), ruleSet2.getRules().size());        for (int i = 0; i < ruleSet1.getRules().size(); i++) {            Rule rule1 = ((List<Rule>) ruleSet1.getRules()).get(i);            Rule rule2 = ((List<Rule>) ruleSet2.getRules()).get(i);            assertFalse(message + ", Different RuleReference",                        rule1 instanceof RuleReference != rule2 instanceof RuleReference);            if (rule1 instanceof RuleReference) {                RuleReference ruleReference1 = (RuleReference) rule1;                RuleReference ruleReference2 = (RuleReference) rule2;                assertEquals(message + ", RuleReference overridden minimum language version",                        ruleReference1.getOverriddenMinimumLanguageVersion(),                        ruleReference2.getOverriddenMinimumLanguageVersion());                assertEquals(message + ", RuleReference overridden maximum language version",                        ruleReference1.getOverriddenMaximumLanguageVersion(),                        ruleReference2.getOverriddenMaximumLanguageVersion());                assertEquals(message + ", RuleReference overridden deprecated", ruleReference1.isOverriddenDeprecated(),                        ruleReference2.isOverriddenDeprecated());                assertEquals(message + ", RuleReference overridden name", ruleReference1.getOverriddenName(),                        ruleReference2.getOverriddenName());                assertEquals(message + ", RuleReference overridden description",                        ruleReference1.getOverriddenDescription(), ruleReference2.getOverriddenDescription());                assertEquals(message + ", RuleReference overridden message", ruleReference1.getOverriddenMessage(),                        ruleReference2.getOverriddenMessage());                assertEquals(message + ", RuleReference overridden external info url",                        ruleReference1.getOverriddenExternalInfoUrl(), ruleReference2.getOverriddenExternalInfoUrl());                assertEquals(message + ", RuleReference overridden priority", ruleReference1.getOverriddenPriority(),                        ruleReference2.getOverriddenPriority());                assertEquals(message + ", RuleReference overridden examples", ruleReference1.getOverriddenExamples(),                        ruleReference2.getOverriddenExamples());            }            assertEquals(message + ", Rule name", rule1.getName(), rule2.getName());            assertEquals(message + ", Rule class", rule1.getRuleClass(), rule2.getRuleClass());            assertEquals(message + ", Rule description " + rule1.getName(), rule1.getDescription(),                    rule2.getDescription());            assertEquals(message + ", Rule message", rule1.getMessage(), rule2.getMessage());            assertEquals(message + ", Rule external info url", rule1.getExternalInfoUrl(), rule2.getExternalInfoUrl());            assertEquals(message + ", Rule priority", rule1.getPriority(), rule2.getPriority());            assertEquals(message + ", Rule examples", rule1.getExamples(), rule2.getExamples());            List<PropertyDescriptor<?>> propertyDescriptors1 = rule1.getPropertyDescriptors();            List<PropertyDescriptor<?>> propertyDescriptors2 = rule2.getPropertyDescriptors();            assertEquals(message + ", Rule property descriptor ", propertyDescriptors1, propertyDescriptors2);            for (int j = 0; j < propertyDescriptors1.size(); j++) {                Object value1 = rule1.getProperty(propertyDescriptors1.get(j));                Object value2 = rule2.getProperty(propertyDescriptors2.get(j));                // special case for Pattern, there is no equals method                if (propertyDescriptors1.get(j).type() == Pattern.class) {                    value1 = ((Pattern) value1).pattern();                    value2 = ((Pattern) value2).pattern();                }                assertEquals(message + ", Rule property value " + j, value1, value2);            }            assertEquals(message + ", Rule property descriptor count", propertyDescriptors1.size(),                    propertyDescriptors2.size());        }    }    /**     * Validator for the SAX parser     */    private static class ValidateDefaultHandler extends DefaultHandler {        private boolean valid = true;        private final Map<String, String> schemaMapping;        ValidateDefaultHandler() {            schemaMapping = new HashMap<>();            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.xsd", "ruleset_2_0_0.xsd");            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.dtd", "ruleset_2_0_0.dtd");        }        public ValidateDefaultHandler resetValid() {            valid = true;            return this;        }        public boolean isValid() {            return valid;        }        @Override        public void error(SAXParseException e) {            log("Error", e);        }        @Override        public void fatalError(SAXParseException e) {            log("FatalError", e);        }        @Override        public void warning(SAXParseException e) {            log("Warning", e);        }        private void log(String prefix, SAXParseException e) {            String message = prefix + " at (" + e.getLineNumber() + ", " + e.getColumnNumber() + "): " + e.getMessage();            System.err.println(message);            valid = false;        }        @Override        public InputSource resolveEntity(String publicId, String systemId) throws IOException {            String resource = schemaMapping.get(systemId);            if (resource != null) {                InputStream inputStream = getClass().getResourceAsStream(resource);                if (inputStream == null) {                    throw new FileNotFoundException(resource);                }                return new InputSource(inputStream);            }            throw new IllegalArgumentException(                    "No clue how to handle: publicId=" + publicId + ", systemId=" + systemId);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.ant.SourceLanguage;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;/** * Base test class for {@link LanguageVersion} implementations. <br> * Each language implementation should subclass this and provide a data method. * * <pre> * &#64;Parameters *     public static Collection&lt;Object[]&gt; data() { *       return Arrays.asList(new Object[][] { *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.1", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.1") }, *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.2", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.2") }, * *            // doesn't exist *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.3", *              null } *       }); * </pre> * * <p>For the parameters, see the constructor * {@link #AbstractLanguageVersionTest(String, String, String, LanguageVersion)}.</p> */@RunWith(Parameterized.class)public class AbstractLanguageVersionTest {    private String name;    private String version;    private String simpleTerseName;    private LanguageVersion expected;    /**     * Creates a new {@link AbstractLanguageVersionTest}     *     * @param name     *            the name under which the language module is registered     * @param terseName     *            the terse name under which the language module is registered     * @param version     *            the specific version of the language version     * @param expected     *            the expected {@link LanguageVersion} instance     */    public AbstractLanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        this.name = name;        this.version = version;        this.simpleTerseName = terseName;        this.expected = expected;    }    protected static Language getLanguage(String name) {        return LanguageRegistry.PMD.getLanguageByFullName(name);    }    /**     * Checks that the expected {@link LanguageVersion} can be found via     * {@link #name} and {@link #version}.     */    @Test    public void testFindVersionsForLanguageNameAndVersion() {        SourceLanguage sourceLanguage = new SourceLanguage();        sourceLanguage.setName(name);        sourceLanguage.setVersion(version);        Language language = getLanguage(sourceLanguage.getName());        LanguageVersion languageVersion = null;        if (language != null) {            languageVersion = language.getVersion(sourceLanguage.getVersion());        }        assertEquals(expected, languageVersion);    }    /**     * Makes sure, that for each language a "categories.properties" file exists.     *     * @throws Exception     *             any error     */    @Test    public void testRegisteredRulesets() throws Exception {        if (expected == null) {            return;        }        Properties props = new Properties();        String rulesetsProperties = "/category/" + simpleTerseName + "/categories.properties";        try (InputStream inputStream = getClass().getResourceAsStream(rulesetsProperties)) {            if (inputStream == null) {                throw new IOException();            }            props.load(inputStream);        }        assertRulesetsAndCategoriesProperties(props);    }    /**     * If a rulesets.properties file still exists, test it as well.     *     * @throws Exception     *             any error     */    @Test    public void testOldRegisteredRulesets() throws Exception {        // only check for languages, that support rules        if (expected == null) {            return;        }        Properties props = new Properties();        String rulesetsProperties = "/rulesets/" + simpleTerseName + "/rulesets.properties";        InputStream inputStream = getClass().getResourceAsStream(rulesetsProperties);        if (inputStream != null) {            // rulesets.properties file exists            try (InputStream in = inputStream) {                props.load(in);            }            assertRulesetsAndCategoriesProperties(props);        }    }    @Test    public void testVersionsAreDistinct() {        if (expected == null) {            return;        }        Language lang = expected.getLanguage();        int count = 0;        for (LanguageVersion lv : lang.getVersions()) {            if (lv.equals(expected)) {                count++;            }        }        assertEquals("Expected exactly one occurrence of " + expected                         + " in the language versions of its language", 1, count);    }    private void assertRulesetsAndCategoriesProperties(Properties props) throws IOException {        String rulesetFilenames = props.getProperty("rulesets.filenames");        assertNotNull(rulesetFilenames);        RuleSetLoader rulesetLoader = new RuleSetLoader();        if (rulesetFilenames.trim().isEmpty()) {            return;        }        String[] rulesets = rulesetFilenames.split(",");        for (String r : rulesets) {            RuleSet ruleset = rulesetLoader.loadFromResource(r);            assertNotNull(ruleset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.atLeastOnce;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import java.util.Arrays;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.document.TextRegion;import net.sourceforge.pmd.lang.rule.RuleTargetSelector;import net.sourceforge.pmd.test.lang.DummyLanguageModule;import net.sourceforge.pmd.test.lang.DummyLanguageModule.DummyRootNode;public class RuleTstTest {    private LanguageVersion dummyLanguage = DummyLanguageModule.getInstance().getDefaultVersion();    private Rule rule = mock(Rule.class);    private RuleTst ruleTester = new RuleTst() {        @Override        public Rule findRule(String ruleSet, String ruleName) {            return rule;        }    };    @Test    public void shouldCallStartAndEnd() {        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        when(rule.getTargetSelector()).thenReturn(RuleTargetSelector.forRootOnly());        when(rule.deepCopy()).thenReturn(rule);        ruleTester.runTestFromString("the code", rule, dummyLanguage, false);        verify(rule).start(any(RuleContext.class));        verify(rule).end(any(RuleContext.class));        verify(rule, atLeastOnce()).getLanguage();        verify(rule, atLeastOnce()).getTargetSelector();        verify(rule).getMinimumLanguageVersion();        verify(rule).getMaximumLanguageVersion();        verify(rule).apply(any(Node.class), any(RuleContext.class));        verify(rule, atLeastOnce()).getName();        verify(rule).getPropertiesByPropertyDescriptor();    }    @Test    public void shouldAssertLinenumbersSorted() {        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        when(rule.getMessage()).thenReturn("test rule");        when(rule.getTargetSelector()).thenReturn(RuleTargetSelector.forRootOnly());        when(rule.deepCopy()).thenReturn(rule);        final String code = "the\ncode";        Mockito.doAnswer(invocation -> {            RuleContext context = invocation.getArgument(1, RuleContext.class);            DummyRootNode node = invocation.getArgument(0, DummyRootNode.class);            // the violations are reported out of order            // line 2            context.addViolation(node.newChild().withCoords(TextRegion.fromOffsetLength("the\n".length(), "code".length())));            // line 1            context.addViolation(node.newChild().withCoords(TextRegion.fromOffsetLength(0, "the".length())));            return null;        }).when(rule).apply(any(Node.class), Mockito.any(RuleContext.class));        TestDescriptor testDescriptor = new TestDescriptor(code, "sample test", 2, rule, dummyLanguage);        testDescriptor.setReinitializeRule(false);        testDescriptor.setExpectedLineNumbers(Arrays.asList(1, 2));        ruleTester.runTest(testDescriptor);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.PlainTextLanguage;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;public class TestDescriptorTest {    @Test    public void testMethodName() {        Assertions.assertEquals("MockRule_1_Name", create("Name"));        Assertions.assertEquals("MockRule_1_Tests_xyz", create("Tests xyz"));        Assertions.assertEquals("MockRule_1_Tests_xyz__false_positive_", create("Tests xyz (false positive)"));        Assertions.assertEquals("MockRule_1_Tests_xyz__123", create("Tests xyz #123"));    }    private String create(String description) {        TestDescriptor descriptor = new TestDescriptor("foo", description, 0,                new MockRule());        descriptor.setNumberInDocument(1);        return descriptor.getTestMethodName();    }    private static final class MockRule extends AbstractRule {        @Override        public Language getLanguage() {            return PlainTextLanguage.getInstance();        }        @Override        public String getName() {            return "MockRule";        }        @Override        public void apply(Node target, RuleContext ctx) {        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.kotlin.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.kotlin.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class FunctionNameTooShortTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.kotlin.ast;import org.checkerframework.checker.nullness.qual.NonNull;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.NodePrintersKt;/** * */public class BaseKotlinTreeDumpTest extends BaseTreeDumpTest {    public BaseKotlinTreeDumpTest() {        super(NodePrintersKt.getSimpleNodePrinter(), ".kt");    }    @NonNull    @Override    public KotlinParsingHelper getParser() {        return KotlinParsingHelper.DEFAULT.withResourceContext(getClass(), "testdata");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.kotlin;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class KotlinTokenizerTest extends CpdTextComparisonTest {    KotlinTokenizerTest() {        super(".kt");    }    @Override    protected String getResourcePrefix() {        return "../lang/kotlin/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new KotlinTokenizer();    }    @Test    void testComments() {        doTest("comment");    }    @Test    void testIncrement() {        doTest("increment");    }    @Test    void testImportsIgnored() {        doTest("imports");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.internal;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import java.util.Set;import net.sourceforge.pmd.lang.java.ast.ASTAnnotation;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.AccessNode.Visibility;import net.sourceforge.pmd.lang.java.ast.JModifier;import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;import net.sourceforge.pmd.lang.java.types.JTypeMirror;import net.sourceforge.pmd.lang.java.types.TypeTestUtil;/** * Utilities for rules related to test frameworks (Junit, TestNG, etc). */public final class TestFrameworksUtil {    private static final String JUNIT3_CLASS_NAME = "junit.framework.TestCase";    private static final String JUNIT4_TEST_ANNOT = "org.junit.Test";    private static final String TESTNG_TEST_ANNOT = "org.testng.annotations.Test";    private static final Set<String> JUNIT5_ALL_TEST_ANNOTS =        setOf("org.junit.jupiter.api.Test",              "org.junit.jupiter.api.RepeatedTest",              "org.junit.jupiter.api.TestFactory",              "org.junit.jupiter.api.TestTemplate",              "org.junit.jupiter.params.ParameterizedTest"        );    private static final String JUNIT5_NESTED = "org.junit.jupiter.api.Nested";    private static final Set<String> ASSERT_CONTAINERS = setOf("org.junit.Assert",                                                               "org.junit.jupiter.api.Assertions",                                                               "org.hamcrest.MatcherAssert",                                                               "org.testng.Assert",                                                               "junit.framework.Assert",                                                               "junit.framework.TestCase");    private TestFrameworksUtil() {        // utility class    }    /**     * True if this is a junit @Test method (or a junit 3 method).     */    public static boolean isJUnitMethod(ASTMethodDeclaration method) {        if (method.hasModifiers(JModifier.STATIC) || method.getBody() == null) {            return false; // skip various inapplicable method variations        }        boolean result = isJUnit5Method(method);        result = result || isJUnit4Method(method);        result = result || isJUnit3Method(method);        return result;    }    /**     * Returns true if this is either a JUnit test or a TestNG test.     */    public static boolean isTestMethod(ASTMethodDeclaration method) {        return isJUnitMethod(method) || isTestNgMethod(method);    }    /**     * Returns true if this is a Before/setUp method or After/tearDown.     */    public static boolean isTestConfigurationMethod(ASTMethodDeclaration method) {        return method.isAnnotationPresent("org.junit.Before")                || method.isAnnotationPresent("org.junit.BeforeClass")                || method.isAnnotationPresent("org.junit.After")                || method.isAnnotationPresent("org.junit.AfterClass")                || isJUnit3Class(method.getEnclosingType())                        && ("setUp".equals(method.getName())                            || "tearDown".equals(method.getName()));    }    private static boolean isTestNgMethod(ASTMethodDeclaration method) {        return method.isAnnotationPresent(TESTNG_TEST_ANNOT);    }    public static boolean isJUnit4Method(ASTMethodDeclaration method) {        return method.isAnnotationPresent(JUNIT4_TEST_ANNOT)                && method.getVisibility() == Visibility.V_PUBLIC;    }    public static boolean isJUnit5Method(ASTMethodDeclaration method) {        return method.getDeclaredAnnotations().any(            it -> {                String canonicalName = it.getTypeMirror().getSymbol().getCanonicalName();                return JUNIT5_ALL_TEST_ANNOTS.contains(canonicalName);            }        );    }    public static boolean isJUnit3Method(ASTMethodDeclaration method) {        return isJUnit3Class(method.getEnclosingType())            && isJunit3MethodSignature(method);    }    public static boolean isJunit4TestAnnotation(ASTAnnotation annot) {        return TypeTestUtil.isA(JUNIT4_TEST_ANNOT, annot);    }    /**     * Does not check the class (use {@link #isJUnit3Class(ASTAnyTypeDeclaration)}).     */    public static boolean isJunit3MethodSignature(ASTMethodDeclaration method) {        return method.isVoid()            && method.getVisibility() == Visibility.V_PUBLIC            && method.getName().startsWith("test");    }    /**     * True if this is a {@code TestCase} class for Junit 3.     */    public static boolean isJUnit3Class(ASTAnyTypeDeclaration node) {        return node.isRegularClass()            && !node.isNested()            && !node.isAbstract()            && TypeTestUtil.isA(JUNIT3_CLASS_NAME, node);    }    public static boolean isTestClass(ASTAnyTypeDeclaration node) {        return node.isRegularClass() && !node.isAbstract() && !node.isNested()            && (isJUnit3Class(node)            || node.getDeclarations(ASTMethodDeclaration.class)                   .any(TestFrameworksUtil::isTestMethod));    }    public static boolean isJUnit5NestedClass(ASTAnyTypeDeclaration innerClassDecl) {        return innerClassDecl.isAnnotationPresent(JUNIT5_NESTED);    }    public static boolean isExpectExceptionCall(ASTMethodCall call) {        return "expect".equals(call.getMethodName())            && TypeTestUtil.isA("org.junit.rules.ExpectedException", call.getQualifier());    }    public static boolean isCallOnAssertionContainer(ASTMethodCall call) {        JTypeMirror declaring = call.getMethodType().getDeclaringType();        JTypeDeclSymbol sym = declaring.getSymbol();        return sym instanceof JClassSymbol                && (ASSERT_CONTAINERS.contains(((JClassSymbol) sym).getBinaryName())                        || TypeTestUtil.isA("junit.framework.Assert", declaring));    }    public static boolean isProbableAssertCall(ASTMethodCall call) {        String name = call.getMethodName();        return name.startsWith("assert") && !isSoftAssert(call)            || name.startsWith("check")            || name.startsWith("verify")            || "fail".equals(name)            || "failWith".equals(name)            || isExpectExceptionCall(call);    }    private static boolean isSoftAssert(ASTMethodCall call) {        return TypeTestUtil.isA("org.assertj.core.api.AbstractSoftAssertions", call.getMethodType().getDeclaringType())            && !"assertAll".equals(call.getMethodName());    }    /**     * Tells if the node contains a @Test annotation with an expected exception.     */    public static boolean isExpectAnnotated(ASTMethodDeclaration method) {        return method.getDeclaredAnnotations()                     .filter(TestFrameworksUtil::isJunit4TestAnnotation)                     .flatMap(ASTAnnotation::getMembers)                     .any(it -> "expected".equals(it.getName()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import static net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil.isJUnit3Class;import static net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil.isJUnit5NestedClass;import java.util.regex.Pattern;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;import net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;public class TestClassWithoutTestCasesRule extends AbstractJavaRulechainRule {    private static final PropertyDescriptor<Pattern> TEST_CLASS_PATTERN = PropertyFactory.regexProperty("testClassPattern")            .defaultValue("^(?:.*\\.)?Test[^\\.]*$|^(?:.*\\.)?.*Tests?$|^(?:.*\\.)?.*TestCase$")            .desc("Test class name pattern to identify test classes by their fully qualified name. "                    + "An empty pattern disables test class detection by name. Since PMD 6.51.0.")            .build();    public TestClassWithoutTestCasesRule() {        super(ASTClassOrInterfaceDeclaration.class);        definePropertyDescriptor(TEST_CLASS_PATTERN);    }    @Override    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {        if (isJUnit3Class(node) || isJUnit5NestedClass(node) || isTestClassByPattern(node)) {            boolean hasTests =                node.getDeclarations(ASTMethodDeclaration.class)                    .any(TestFrameworksUtil::isTestMethod);            boolean hasNestedTestClasses = node.getDeclarations(ASTAnyTypeDeclaration.class)                    .any(TestFrameworksUtil::isJUnit5NestedClass);            if (!hasTests && !hasNestedTestClasses) {                asCtx(data).addViolation(node, node.getSimpleName());            }        }        return null;    }    private boolean isTestClassByPattern(ASTClassOrInterfaceDeclaration node) {        Pattern testClassPattern = getProperty(TEST_CLASS_PATTERN);        if (testClassPattern.pattern().isEmpty()) {            // detection by pattern is disabled            return false;        }        if (node.isAbstract() || node.isInterface()) {            return false;        }        String fullName = node.getCanonicalName();        return fullName != null && testClassPattern.matcher(fullName).find();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package javasymbols.testdata;public class TestCase1 {    String foo;    SomeClassA a;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.coverage;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.fail;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import java.util.List;import org.apache.commons.lang3.ArrayUtils;import org.apache.commons.lang3.StringUtils;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.util.IOUtil;import com.github.stefanbirkner.systemlambda.SystemLambda;// TODO enable test@Disabled("Test is failing and was excluded on PMD 7 branch")class PMDCoverageTest {    @TempDir    private Path tempFolder;    @Test    void testPmdOptions() {        runPmd("-d src/main/java/net/sourceforge/pmd/lang/java/rule/design -f text -R rulesets/internal/all-java.xml -stress -benchmark");    }    @Test    void runAllJavaPmdOnSourceTree() {        runPmd("-d src/main/java -f text -R rulesets/internal/all-java.xml");    }    @Test    void runAllJavaPmdOnTestResourcesWithLatestJavaVersion() {        List<LanguageVersion> versions = JavaLanguageModule.getInstance().getVersions();        LanguageVersion latest = versions.get(versions.size() - 1);        runPmd("-d src/test/resources -f text -R rulesets/internal/all-java.xml -language java -version " + latest.getVersion());    }    /**     * Run the PMD command line tool, i.e. call PMD.main().     *     * @param commandLine     */    private void runPmd(String commandLine) {        StringBuilder report = new StringBuilder("missing report");        try {            Path f = Files.createTempFile(tempFolder, PMDCoverageTest.class.getSimpleName(), null);            String[] args = ArrayUtils.addAll(                commandLine.split("\\s"),                "-reportfile",                f.toAbsolutePath().toString(),                "-threads",                String.valueOf(Runtime.getRuntime().availableProcessors())            );            System.err.println("Running PMD with: " + Arrays.toString(args));            String output = SystemLambda.tapSystemOut(() -> {                String errorOutput = SystemLambda.tapSystemErr(() -> {                    PMD.runPmd(args);                    report.setLength(0);                    report.append(IOUtil.readFileToString(f.toFile(), StandardCharsets.UTF_8));                });                assertEquals(0, StringUtils.countMatches(errorOutput, "Exception applying rule"), "No exceptions expected");                assertFalse(errorOutput.contains("Ruleset not found"), "Wrong configuration? Ruleset not found");                assertEquals(0, StringUtils.countMatches(errorOutput, "Use of deprecated attribute"), "No usage of deprecated XPath attributes expected");            });            assertEquals(0, output.length(), "Nothing should be output to stdout");            assertEquals(0, StringUtils.countMatches(report, "Error while processing"), "No processing errors expected");            // we might have explicit examples of parsing errors, so these are maybe false positives            assertEquals(0, StringUtils.countMatches(report, "Error while parsing"), "No parsing error expected");        } catch (IOException ioe) {            fail("Problem creating temporary file: " + ioe.getLocalizedMessage());        } catch (AssertionError ae) {            System.out.println("\nReport:\n");            System.out.println(report);            throw ae;        } catch (Exception e) {            throw new RuntimeException(e);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics.impl;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.internal.PrettyPrintingUtil;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clément Fournier */class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/java/metrics_test.xml";    @Override    public void setUp() {        addRule(RULESET, "CognitiveComplexityTest");        addRule(RULESET, "CycloTest");        addRule(RULESET, "NcssTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "LocTest");        addRule(RULESET, "NPathTest");        addRule(RULESET, "NopaTest");        addRule(RULESET, "NoamTest");        addRule(RULESET, "WocTest");        addRule(RULESET, "TccTest");        addRule(RULESET, "AtfdTest");        addRule(RULESET, "CfoTest");    }    static String formatJavaMessage(Node node, Object result, String defaultMessage) {        String qname = null;        if (node instanceof ASTAnyTypeDeclaration) {            qname = ((ASTAnyTypeDeclaration) node).getBinaryName();        } else if (node instanceof ASTMethodOrConstructorDeclaration) {            String enclosing = ((ASTMethodOrConstructorDeclaration) node).getEnclosingType().getBinaryName();            qname = enclosing + "#" + PrettyPrintingUtil.displaySignature((ASTMethodOrConstructorDeclaration) node);        }        if (qname != null) {            return "''" + qname + "'' has value " + result + ".";        }        return defaultMessage;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaVisitorBase;import net.sourceforge.pmd.lang.java.metrics.testdata.MetricsVisitorTestData;import net.sourceforge.pmd.lang.metrics.Metric;import net.sourceforge.pmd.lang.metrics.MetricOptions;import net.sourceforge.pmd.lang.metrics.MetricsUtil;/** * @author Clément Fournier */class MetricsMemoizationTest extends BaseParserTest {    private final Metric<Node, Integer> randomMetric = randomMetric();    private static Metric<Node, Integer> randomMetric() {        Random capturedRandom = new Random();        return Metric.of((t, opts) -> capturedRandom.nextInt(), t -> t, "randomMetric");    }    @Test    void memoizationTest() {        ASTCompilationUnit acu = java.parseClass(MetricsVisitorTestData.class);        List<Integer> expected = visitWith(acu, true);        List<Integer> real = visitWith(acu, false);        assertEquals(expected, real);    }    @Test    void forceMemoizationTest() {        ASTCompilationUnit acu = java.parseClass(MetricsVisitorTestData.class);        List<Integer> reference = visitWith(acu, true);        List<Integer> real = visitWith(acu, true);        assertEquals(reference.size(), real.size());        // we force recomputation so each result should be different        for (int i = 0; i < reference.size(); i++) {            assertNotEquals(reference.get(i), real.get(i));        }    }    private List<Integer> visitWith(ASTCompilationUnit acu, final boolean force) {        final List<Integer> result = new ArrayList<>();        acu.acceptVisitor(new JavaVisitorBase<Object, Object>() {            @Override            public Object visitMethodOrCtor(ASTMethodOrConstructorDeclaration node, Object data) {                Integer value = MetricsUtil.computeMetric(randomMetric, node, MetricOptions.emptyOptions(), force);                if (value != null) {                    result.add(value);                }                return super.visitMethodOrCtor(node, data);            }            @Override            public Object visitTypeDecl(ASTAnyTypeDeclaration node, Object data) {                Integer value = MetricsUtil.computeMetric(randomMetric, node, MetricOptions.emptyOptions(), force);                if (value != null) {                    result.add(value);                }                return super.visitTypeDecl(node, data);            }        }, null);        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import java.util.Map;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.metrics.LanguageMetricsProvider;import net.sourceforge.pmd.lang.metrics.Metric;/** * @author Clément Fournier */class JavaMetricsProviderTest {    private final JavaParsingHelper java8 = JavaParsingHelper.DEFAULT.withDefaultVersion("1.8");    @Test    void testComputeAllMetrics() {        LanguageMetricsProvider provider = java8.getHandler("1.8").getLanguageMetricsProvider();        ASTCompilationUnit acu = java8.parse("class Foo { void bar() { System.out.println(1); } }");        ASTAnyTypeDeclaration type = acu.getTypeDeclarations().firstOrThrow();        Map<Metric<?, ?>, Number> results = provider.computeAllMetricsFor(type);        assertEquals(9, results.size());    }    @Test    void testThereIsNoMemoisation() {        LanguageMetricsProvider provider = java8.getHandler("1.8").getLanguageMetricsProvider();        ASTAnyTypeDeclaration tdecl1 = java8.parse("class Foo { void bar() { System.out.println(1); } }")                                            .getTypeDeclarations().firstOrThrow();        Map<Metric<?, ?>, Number> reference = provider.computeAllMetricsFor(tdecl1);        // same name, different characteristics        ASTAnyTypeDeclaration tdecl2 = java8.parse("class Foo { void bar(){} \npublic void hey() { System.out.println(1); } }")                                            .getTypeDeclarations().firstOrThrow();        Map<Metric<?, ?>, Number> secondTest = provider.computeAllMetricsFor(tdecl2);        assertNotEquals(reference, secondTest);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symbols;import static net.sourceforge.pmd.util.OptionalBool.NO;import static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;import static net.sourceforge.pmd.util.OptionalBool.YES;import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.util.Arrays;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.symbols.SymbolicValue.SymAnnot;import net.sourceforge.pmd.lang.java.symbols.SymbolicValue.SymArray;import net.sourceforge.pmd.lang.java.symbols.SymbolicValue.SymEnum;import net.sourceforge.pmd.lang.java.symbols.internal.asm.AsmSymbolResolver;import net.sourceforge.pmd.lang.java.symbols.testdata.AnnotWithDefaults;import net.sourceforge.pmd.lang.java.symbols.testdata.AnnotWithDefaults.MyEnum;import net.sourceforge.pmd.lang.java.symbols.testdata.SomeClass;import net.sourceforge.pmd.lang.java.types.Substitution;import net.sourceforge.pmd.lang.java.types.TypeSystem;/** * */public class SymbolReflectionTest {    private final TypeSystem ts = JavaParsingHelper.TEST_TYPE_SYSTEM;    private final AsmSymbolResolver loader = (AsmSymbolResolver) ts.bootstrapResolver();    private SymbolicValue symValueOf(Object o) {        return SymbolicValue.of(ts, o);    }    @Test    public void testReflectionOfParamNames() {        // note that this asserts, that the param names are unavailable        JClassSymbol sym = loader.resolveClassFromBinaryName(SomeClass.class.getName());        Assert.assertNotNull(sym);        List<JMethodSymbol> ms = sym.getDeclaredMethods();        Assert.assertEquals(2, ms.size());        JMethodSymbol m1 = ms.stream().filter(it -> it.getSimpleName().equals("m1")).findFirst().orElseThrow(AssertionError::new);        Assert.assertEquals(2, m1.getArity());        List<JFormalParamSymbol> m1Formals = m1.getFormalParameters();        Assert.assertEquals(2, m1Formals.size());        JFormalParamSymbol p = m1Formals.get(0);        Assert.assertEquals("", p.getSimpleName());        Assert.assertFalse(p.isFinal());        Assert.assertEquals(ts.INT, p.getTypeMirror(Substitution.EMPTY));        p = m1Formals.get(1);        Assert.assertEquals("", p.getSimpleName());        Assert.assertFalse(p.isFinal());        Assert.assertEquals(ts.getClassSymbol(String.class), p.getTypeMirror(Substitution.EMPTY).getSymbol());    }    @Test    public void testReflectionOfAnnotDefault() {        // note that this asserts, that the param names are unavailable        JClassSymbol sym = loadAnnotation(AnnotWithDefaults.class);        JMethodSymbol m;        m = getMethod(sym, "valueWithDefault");        Assert.assertEquals(symValueOf("ddd"), m.getDefaultAnnotationValue());        m = getMethod(sym, "valueNoDefault");        Assert.assertNull(m.getDefaultAnnotationValue());        m = getMethod(sym, "stringArrayDefault");        Assert.assertNotNull(m.getDefaultAnnotationValue());        Assert.assertEquals(symValueOf(new String[] {"ddd"}), m.getDefaultAnnotationValue());        m = getMethod(sym, "stringArrayEmptyDefault");        Assert.assertNotNull(m.getDefaultAnnotationValue());        Assert.assertEquals(ofArray(), m.getDefaultAnnotationValue());        m = getMethod(sym, "classAttr");        Assert.assertNotNull(m.getDefaultAnnotationValue());        Assert.assertEquals(symValueOf(String.class), m.getDefaultAnnotationValue());    }    @Test    public void testReflectionOfEnumDefault() {        // note that this asserts, that the param names are unavailable        JClassSymbol sym = loadAnnotation(AnnotWithDefaults.class);        JMethodSymbol m;        m = getMethod(sym, "enumArr");        Assert.assertEquals(ofArray(SymEnum.fromEnum(ts, MyEnum.AA), SymEnum.fromEnum(ts, MyEnum.BB)),                            m.getDefaultAnnotationValue());        m = getMethod(sym, "enumSimple");        Assert.assertEquals(SymEnum.fromEnum(ts, MyEnum.AA), m.getDefaultAnnotationValue());    }    @Test    public void testAnnotOnClass() {        // note that this asserts, that the param names are unavailable        JClassSymbol sym = loadClass(AnnotWithDefaults.class);        Assert.assertTrue(sym.isAnnotationPresent(Target.class));        SymAnnot target = sym.getDeclaredAnnotation(Target.class);        Assert.assertTrue(target.isOfType(Target.class));        Assert.assertTrue(target.isOfType(Target.class.getName()));        Assert.assertEquals(YES, target.attributeMatches("value", new ElementType[] {ElementType.TYPE, ElementType.PARAMETER, ElementType.FIELD, ElementType.METHOD}));    }    @Test    public void testAnnotThatHasDefaults() {        // note that this asserts, that the param names are unavailable        /*            @AnnotWithDefaults(valueNoDefault = "ohio",                       stringArrayDefault = {})         */        JClassSymbol sym = loadClass(SomeClass.class);        Assert.assertTrue(sym.isAnnotationPresent(AnnotWithDefaults.class));        SymAnnot target = sym.getDeclaredAnnotation(AnnotWithDefaults.class);        Assert.assertEquals(YES, target.attributeMatches("valueNoDefault", "ohio"));        Assert.assertEquals(YES, target.attributeMatches("stringArrayDefault", new String[] {}));        Assert.assertEquals(NO, target.attributeMatches("stringArrayDefault", "0"));        Assert.assertEquals(UNKNOWN, target.attributeMatches("stringArrayEmptyDefault", new String[] {}));    }    @Test    public void testAnnotOnMethod() {        // note that this asserts, that the param names are unavailable        /*            @AnnotWithDefaults(valueNoDefault = "ohio",                       stringArrayDefault = {})         */        JClassSymbol sym = loadClass(SomeClass.class);        Assert.assertTrue(sym.isAnnotationPresent(AnnotWithDefaults.class));        SymAnnot target = sym.getDeclaredAnnotation(AnnotWithDefaults.class);        Assert.assertEquals(YES, target.attributeMatches("valueNoDefault", "ohio"));        Assert.assertEquals(YES, target.attributeMatches("stringArrayDefault", new String[] {}));        Assert.assertEquals(NO, target.attributeMatches("stringArrayDefault", "0"));        Assert.assertEquals(UNKNOWN, target.attributeMatches("stringArrayEmptyDefault", new String[] {}));    }    @Test    public void testSymValueEquality() {        Assert.assertEquals("Array of strings",                            symValueOf(new String[] {"ddd", "eee"}),                            ofArray(symValueOf("ddd"), symValueOf("eee")));        Assert.assertEquals("Array of booleans",                            symValueOf(new boolean[] {true}),                            symValueOf(new boolean[] {true}));        Assert.assertNotEquals("Array of booleans",                               symValueOf(new boolean[] {true}),                               symValueOf(new boolean[] {false}));        Assert.assertTrue("valueEquals for int[]",                          symValueOf(new int[] {10, 11}).valueEquals(new int[] {10, 11}));        Assert.assertTrue("valueEquals for boolean[]",                          symValueOf(new boolean[] {false}).valueEquals(new boolean[] {false}));        Assert.assertFalse("valueEquals for int[]",                           symValueOf(new int[] {10, 11}).valueEquals(new int[] {10}));        Assert.assertFalse("valueEquals for double[] 2",                           symValueOf(new int[] {10, 11}).valueEquals(new double[] {10, 11}));        Assert.assertFalse("valueEquals for empty arrays",                           symValueOf(new int[] {}).valueEquals(new double[] {}));        Assert.assertTrue("valueEquals for empty arrays",                          symValueOf(new double[] {}).valueEquals(new double[] {}));    }    private static JMethodSymbol getMethod(JClassSymbol sym, String name) {        return sym.getDeclaredMethods().stream().filter(it -> it.getSimpleName().equals(name))                  .findFirst()                  .orElseThrow(AssertionError::new);    }    private @NonNull JClassSymbol loadAnnotation(Class<?> klass) {        JClassSymbol sym = loadClass(klass);        Assert.assertTrue(sym.isAbstract());        Assert.assertTrue(sym.isAnnotation());        Assert.assertTrue(sym.isInterface());        return sym;    }    private @NonNull JClassSymbol loadClass(Class<?> klass) {        JClassSymbol sym = loader.resolveClassFromBinaryName(klass.getName());        Assert.assertNotNull(sym);        return sym;    }    // test only    static SymbolicValue ofArray(SymbolicValue... values) {        return SymArray.forElements(Arrays.asList(values.clone()));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types.internal.infer;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.checkerframework.checker.nullness.qual.NonNull;import org.hamcrest.BaseMatcher;import org.hamcrest.Description;import org.hamcrest.Matcher;import org.hamcrest.Matchers;import org.hamcrest.SelfDescribing;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;import net.sourceforge.pmd.lang.java.types.JClassType;import net.sourceforge.pmd.lang.java.types.JIntersectionType;import net.sourceforge.pmd.lang.java.types.JTypeMirror;import net.sourceforge.pmd.lang.java.types.JTypeVar;import net.sourceforge.pmd.lang.java.types.JWildcardType;import net.sourceforge.pmd.lang.java.types.TypeSystem;import net.sourceforge.pmd.lang.java.types.internal.infer.InferenceVar.BoundKind;/** * */class BaseTypeInferenceUnitTest {    protected final TypeSystem ts = JavaParsingHelper.TEST_TYPE_SYSTEM;    protected final JClassSymbol listSym = ts.getClassSymbol(List.class);    protected InferenceContext emptyCtx() {        return emptyCtx(TypeInferenceLogger.noop());    }    protected InferenceContext emptyCtx(TypeInferenceLogger log) {        return new InferenceContext(ts, new SupertypeCheckCache(), Collections.emptyList(), log);    }    protected InferenceVar newIvar(InferenceContext ctx) {        return newIvar(ctx, ts.OBJECT);    }    protected InferenceVar newIvar(InferenceContext ctx, JTypeMirror upperBound) {        JTypeVar mock = mock(JTypeVar.class);        when(mock.getTypeSystem()).thenReturn(ts);        when(mock.getLowerBound()).thenReturn(ts.NULL_TYPE);        when(mock.getUpperBound()).thenReturn(upperBound);        return ctx.addVar(mock);    }    /**     * Note: we systematically incorporate because the order in which     * constraints are added should not be overly specified by tests.     * Eg whether {@code a.isConvertibleTo(b)} creates {@code 'a <: 'b} or     * {@code 'b >: 'a} is irrelevant, provided the incorporation phase     * properly propagates either.     */    protected void addSubtypeConstraint(InferenceContext ctx, JTypeMirror t, JTypeMirror s) {        t.isConvertibleTo(s); // nota: this captures t        ctx.incorporate();    }    protected void subtypeConstraintShouldFail(InferenceContext ctx, JTypeMirror t, JTypeMirror s) {        t.isConvertibleTo(s); // nota: this captures t        assertThrows(ResolutionFailedException.class, ctx::incorporate);    }    @NonNull JTypeMirror listType(JTypeMirror t) {        return ts.parameterise(listSym, listOf(t));    }    @NonNull JWildcardType extendsWild(JTypeMirror t) {        return ts.wildcard(true, t);    }    @NonNull JWildcardType superWild(JTypeMirror t) {        return ts.wildcard(false, t);    }    @NonNull JIntersectionType intersect(JTypeMirror... types) {        JTypeMirror glb = ts.glb(Arrays.asList(types));        assertThat(glb, Matchers.isA(JIntersectionType.class));        return (JIntersectionType) glb;    }    static Matcher<InferenceVar> hasBound(BoundKind kind, JTypeMirror t) {        return new BaseMatcher<InferenceVar>() {            @Override            public void describeTo(Description description) {            }            @Override            public boolean matches(Object actual) {                if (!(actual instanceof InferenceVar)) {                    return false;                }                return ((InferenceVar) actual).getBounds(kind).contains(t);            }        };    }    /**     * Exactly, modulo the upper(OBJECT), which can be omitted.     */    static Matcher<InferenceVar> hasBoundsExactly(Bound... bounds) {        return new BaseMatcher<InferenceVar>() {            @Override            public void describeTo(Description description) {                description.appendText("'_ ");                Bound.describeList(description, Arrays.asList(bounds));            }            @Override            public void describeMismatch(Object item, Description description) {                if (!(item instanceof InferenceVar)) {                    description.appendText("Not an ivar: ").appendValue(item);                    return;                }                InferenceVar ivar = (InferenceVar) item;                description.appendText("was ");                description.appendText(ivar.getName());                description.appendText(" ");                Bound.describeList(description, getBoundsObj(ivar));            }            @Override            public boolean matches(Object actual) {                if (!(actual instanceof InferenceVar)) {                    return false;                }                InferenceVar ivar = (InferenceVar) actual;                JClassType top = ivar.getTypeSystem().OBJECT;                // note: don't use ivar.getBounds(ALL) as this would merge 'a >: T and 'a <: T                Map<BoundKind, Set<JTypeMirror>> actualBounds = getBounds(ivar);                // note: don't use sets/ maps to put Bound instances in,                // as captureMatchers don't support hashing. Also don't                // use Set::contains                // caller may omit OBJECT for conciseness                boolean expectTop = Arrays.stream(bounds).anyMatch(it -> it.kind == BoundKind.UPPER && it.t == top);                // may not have top if it has a different default bound                boolean hasTop = actualBounds.get(BoundKind.UPPER).contains(top);                int numToTest = actualBounds.values().stream().mapToInt(Set::size).sum();                if (!expectTop && hasTop) {                    numToTest--;                }                if (numToTest != bounds.length) {                    return false;                }                b:                for (Bound bound : bounds) {                    for (JTypeMirror t : actualBounds.getOrDefault(bound.kind, Collections.emptySet())) {                        if (t.equals(bound.t)) {                            numToTest--;                            continue b;                        }                    }                }                return numToTest == 0;            }        };    }    static @NonNull Map<BoundKind, Set<JTypeMirror>> getBounds(InferenceVar actual) {        Map<BoundKind, Set<JTypeMirror>> actualBounds = new HashMap<>();        for (BoundKind kind : BoundKind.values()) {            Set<JTypeMirror> bounds = actual.getBounds(kind);            actualBounds.put(kind, bounds);            if (!bounds.isEmpty()) {            }        }        return actualBounds;    }    static @NonNull Set<Bound> getBoundsObj(InferenceVar actual) {        Set<Bound> bounds = new LinkedHashSet<>();        for (BoundKind kind : BoundKind.values()) {            for (JTypeMirror t : actual.getBounds(kind)) {                bounds.add(new Bound(kind, t));            }        }        return bounds;    }    static class Bound implements SelfDescribing {        final BoundKind kind;        final JTypeMirror t;        Bound(BoundKind kind, JTypeMirror t) {            this.kind = kind;            this.t = t;        }        @Override        public void describeTo(Description description) {            description.appendText(toString());        }        public static Bound lower(JTypeMirror t) {            return new Bound(BoundKind.LOWER, t);        }        public static Bound eqBound(JTypeMirror t) {            return new Bound(BoundKind.EQ, t);        }        public static Bound upper(JTypeMirror t) {            return new Bound(BoundKind.UPPER, t);        }        public static Description describeList(Description description, Collection<Bound> bounds) {            return description.appendList("{", ", ", "}", bounds);        }        @Override        public String toString() {            return "_" + kind.getSym() + t;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.function.Supplier;import org.checkerframework.checker.nullness.qual.Nullable;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;import net.sourceforge.pmd.lang.java.types.testdata.GenericMethodReference;class GenericMethodReferenceTest {    @Test    void typeResolveVariable() {        ASTCompilationUnit root = JavaParsingHelper.DEFAULT.parseClass(GenericMethodReference.class);        root.descendants(ASTVariableDeclaratorId.class).forEach(variable -> {            assertTrue(variable.getName().startsWith("supplier"));            @Nullable            JTypeDeclSymbol symbol = variable.getInitializer().getTypeMirror().getSymbol();            assertEquals(Supplier.class.getSimpleName(), symbol.getSimpleName());        });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.InvocationNode;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.rule.xpath.Attribute;/** * */class TypesTreeDumpTest extends BaseTreeDumpTest {    TypesTreeDumpTest() {        super(new JavaTypeAttrPrinter(), ".java");    }    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return JavaParsingHelper.DEFAULT.withResourceContext(getClass());    }    @Test    void testIteratorUtilCopy() {        doTest("IteratorUtilCopy");    }    @Override    protected @NonNull String normalize(@NonNull String str) {        return super.normalize(str)                    // capture IDs are unstable from run to run                    .replaceAll("capture#-?\\d+", "capture#...");    }    /**     * Only prints the type of type nodes     */    private static class JavaTypeAttrPrinter extends RelevantAttributePrinter {        @Override        protected void fillAttributes(@NonNull Node node, @NonNull List<AttributeInfo> result) {            if (node instanceof TypeNode) {                result.add(new AttributeInfo("TypeMirror", ((TypeNode) node).getTypeMirror().toString()));            }            if (node instanceof InvocationNode) {                InvocationNode invoc = (InvocationNode) node;                result.add(new AttributeInfo("MethodName", invoc.getMethodName()));                result.add(new AttributeInfo("VarargsCall", invoc.getOverloadSelectionInfo().isVarargsCall()));                result.add(new AttributeInfo("Unchecked", invoc.getOverloadSelectionInfo().needsUncheckedConversion()));                result.add(new AttributeInfo("Failed", invoc.getOverloadSelectionInfo().isFailed()));                result.add(new AttributeInfo("Function", TypePrettyPrint.prettyPrint(invoc.getMethodType())));            }            if (node instanceof ASTNamedReferenceExpr) {                result.add(new AttributeInfo("Name", ((ASTNamedReferenceExpr) node).getName()));            }            if (node instanceof ASTVariableDeclaratorId) {                result.add(new AttributeInfo("Name", ((ASTVariableDeclaratorId) node).getName()));            }        }        @Override        protected boolean ignoreAttribute(@NonNull Node node, @NonNull Attribute attribute) {            return true;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ObjectStreamField;import java.io.Serializable;import java.lang.annotation.Annotation;import java.util.concurrent.Callable;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.ASTAnnotation;import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTType;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;class TypeTestUtilTest extends BaseParserTest {    @Test    void testIsAFallback() {        ASTClassOrInterfaceDeclaration klass =            java.parse("package org; import java.io.Serializable; "                           + "class FooBar implements Serializable {}")                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        assertNull(klass.getType());        assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertTrue(TypeTestUtil.isA("java.io.Serializable", klass));        assertTrue(TypeTestUtil.isA(Serializable.class, klass));    }    @Test    void testIsAFallbackWithUnresolvedClassReference() { // != declaration        ASTAnnotation annot =            java.parse("import a.b.Test;"                           + "class FooBar { @Test void bar() {} }")                .getFirstDescendantOfType(ASTAnnotation.class);        assertTrue(TypeTestUtil.isA("a.b.Test", annot));        assertTrue(TypeOps.isUnresolved(annot.getTypeMirror()));        assertFalse(TypeTestUtil.isA(org.junit.Test.class, annot));        assertFalse(TypeTestUtil.isA("org.junit.Test", annot));        assertFalse(TypeTestUtil.isA(Override.class, annot));        assertFalse(TypeTestUtil.isA("java.lang.Override", annot));    }    @Test    void testIsAFallbackEnum() {        ASTEnumDeclaration klass =            java.parse("package org; "                           + "enum FooBar implements Iterable {}")                .getFirstDescendantOfType(ASTEnumDeclaration.class);        assertNull(klass.getType());        assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertIsStrictSubtype(klass, Iterable.class);        assertIsStrictSubtype(klass, Enum.class);        assertIsStrictSubtype(klass, Serializable.class);        assertIsStrictSubtype(klass, Object.class);    }    @Test    void testIsAnArrayClass() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final ObjectStreamField[] serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, ObjectStreamField[].class);        assertIsStrictSubtype(arrayT, Object[].class);        assertIsStrictSubtype(arrayT, Serializable.class);        assertIsNot(arrayT, Serializable[].class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    void testIsAnAnnotationClass() {        ASTType arrayT =            java.parse("class Foo { org.junit.Test field; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, org.junit.Test.class);        assertIsStrictSubtype(arrayT, Annotation.class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    void testIsAPrimitiveArrayClass() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final int[] serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, int[].class);        assertIsNot(arrayT, long[].class);        assertIsNot(arrayT, Object[].class);        assertIsStrictSubtype(arrayT, Serializable.class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    void testIsAPrimitiveSubtype() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final int serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, int.class);        assertIsNot(arrayT, long.class);        assertIsNot(arrayT, double.class);        assertIsNot(arrayT, float.class);        assertIsNot(arrayT, Object.class);    }    @Test    void testIsAFallbackAnnotation() {        ASTAnnotationTypeDeclaration klass =            java.parse("package org; import foo.Stuff;"                           + "public @interface FooBar {}")                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);        assertNull(klass.getType());        assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertIsA(klass, Annotation.class);        assertIsA(klass, Object.class);    }    @Test    void testIsATypeVarWithUnresolvedBound() {        // a type var with an unresolved bound should not be considered        // a subtype of everything        ASTType field =            java.parse("class Foo<T extends Unresolved> {\n"                           + "\tT field;\n"                           + "}")                .descendants(ASTFieldDeclaration.class)                .firstOrThrow().getTypeNode();        assertIsA(field, Object.class);        assertIsNot(field, String.class);    }    @Test    void testIsAStringWithTypeArguments() {        ASTAnyTypeDeclaration klass =            java.parse("package org;"                           + "public class FooBar {}")                .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        assertThrows(IllegalArgumentException.class,                () -> TypeTestUtil.isA("java.util.List<java.lang.String>", klass));    }    @Test    void testIsAStringWithTypeArgumentsAnnotation() {        ASTAnyTypeDeclaration klass =            java.parse("package org;"                           + "public @interface FooBar {}")                .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        assertThrows(IllegalArgumentException.class, () ->            TypeTestUtil.isA("java.util.List<java.lang.String>", klass));    }    @Test    void testAnonClassTypeNPE() {        // #2756        ASTAnonymousClassDeclaration anon =            java.parseClass(SomeClassWithAnon.class)                .getFirstDescendantOfType(ASTAnonymousClassDeclaration.class);        assertTrue(anon.getSymbol().isAnonymousClass(), "Anon class");        assertTrue(TypeTestUtil.isA(Runnable.class, anon), "Should be a Runnable");        // This is not a canonical name, so we give up early        assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + "$1", anon));        assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + "$1", anon));        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null        assertFalse(TypeTestUtil.isA(Callable.class, anon));        assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));        assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));        assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));    }    /**     * If we don't have the annotation on the classpath,     * we should resolve the full name via the import, if possible     * and compare then. Only after that, we should compare the     * simple names.     */    @Test    void testIsAFallbackAnnotationSimpleNameImport() {        ASTAnnotation annotation = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                                       .getFirstDescendantOfType(ASTAnnotation.class);        assertNull(annotation.getType());        assertTrue(TypeTestUtil.isA("foo.Stuff", annotation));        assertFalse(TypeTestUtil.isA("other.Stuff", annotation));        // we know it's not Stuff, it's foo.Stuff        assertFalse(TypeTestUtil.isA("Stuff", annotation));    }    @Test    void testNullNode() {        assertFalse(TypeTestUtil.isA(String.class, (TypeNode) null));        assertFalse(TypeTestUtil.isA("java.lang.String", (JTypeMirror) null));        assertFalse(TypeTestUtil.isA("java.lang.String", (TypeNode) null));        assertFalse(TypeTestUtil.isExactlyA(String.class, (TypeNode) null));        assertFalse(TypeTestUtil.isExactlyA("java.lang.String", null));    }    @Test    void testNullClass() {        final ASTAnnotation node = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                                       .getFirstDescendantOfType(ASTAnnotation.class);        assertNotNull(node);        assertThrows(NullPointerException.class, () -> TypeTestUtil.isA((String) null, node));        assertThrows(NullPointerException.class, () -> TypeTestUtil.isA((Class<?>) null, node));        assertThrows(NullPointerException.class, () -> TypeTestUtil.isExactlyA((Class<?>) null, node));        assertThrows(NullPointerException.class, () -> TypeTestUtil.isExactlyA((String) null, node));    }    private void assertIsA(TypeNode node, Class<?> type) {        assertIsA(node, type, false, true);    }    private void assertIsExactlyA(TypeNode node, Class<?> type) {        assertIsA(node, type, true, true);        assertIsA(node, type, false, true);    }    private void assertIsNot(TypeNode node, Class<?> type) {        assertIsA(node, type, true, false);        assertIsA(node, type, false, false);    }    private void assertIsNotExactly(TypeNode node, Class<?> type) {        assertIsA(node, type, true, false);    }    private void assertIsStrictSubtype(TypeNode node, Class<?> type) {        assertIsNotExactly(node, type);        assertIsA(node, type);    }    private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {        assertEquals(expectTrue,                     exactly ? TypeTestUtil.isExactlyA(type, node)                             : TypeTestUtil.isA(type, node),                "TypeTestUtil::isA with class arg: " + type.getCanonicalName());        assertEquals(expectTrue,                     exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)                             : TypeTestUtil.isA(type.getCanonicalName(), node),                "TypeTestUtil::isA with string arg: " + type.getCanonicalName());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import static net.sourceforge.pmd.lang.java.types.InvocationMatcher.parse;import static org.hamcrest.Matchers.equalTo;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.hamcrest.MatcherAssert;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;import net.sourceforge.pmd.lang.java.ast.InvocationNode;class InvocationMatcherTest extends BaseParserTest {    @Test    void testSimpleMatcher() {        ASTMethodCall call =            java.parse("class Foo {{ Integer.valueOf('c'); }}")                .descendants(ASTMethodCall.class).firstOrThrow();        assertMatch(call, "_#valueOf(int)");        assertMatch(call, "java.lang.Integer#valueOf(int)");        assertMatch(call, "java.lang.Integer#_(int)");        assertMatch(call, "java.lang.Integer#_(_*)");        assertNoMatch(call, "java.lang.Integer#valueOf(char)");        assertNoMatch(call, "java.lang.Integer#valueOf2(_*)");        assertNoMatch(call, "java.lang.Object#valueOf(_*)");    }    @Test    void testCtorMatchers() {        ASTConstructorCall call =            java.parse("class Foo {{ new java.util.ArrayList('c'); }}")                .descendants(ASTConstructorCall.class).firstOrThrow();        assertMatch(call, "_#new(int)");        assertMatch(call, "java.util.ArrayList#new(int)");        assertMatch(call, "java.util.ArrayList#_(int)");        assertMatch(call, "java.util.ArrayList#_(_*)");        assertNoMatch(call, "java.util.ArrayList#new()");        assertNoMatch(call, "java.util.ArrayList#_()");        assertNoMatch(call, "java.util.List#new(_*)");        assertNoMatch(call, "java.util.List#_(_*)");        assertNoMatch(call, "java.lang.Object#new(int)");    }    @Test    void testArray() {        ASTMethodCall call =            java.parse("class Foo {{ new int[0].toString(); }}")                .descendants(ASTMethodCall.class).firstOrThrow();        assertMatch(call, "int[]#toString()");        assertMatch(call, "_#toString()");        assertMatch(call, "int[]#_()");        assertMatch(call, "int[]#_(_*)");        assertMatch(call, "_#_(_*)");        assertNoMatch(call, "_#new(int)");        assertNoMatch(call, "_[][]#_(_*)");        // maybe we should support this one later        assertNoMatch(call, "_[]#toString()");    }    @Test    void testWhitespaceErrorMessage() {        parse("_#_(int,int)"); // does not fail        IllegalArgumentException e = assertThrows(IllegalArgumentException.class, () -> parse("_#_(int, int)"));        MatcherAssert.assertThat(e.getMessage(), equalTo("Expected type at index 8:\n"                                                             + "    \"_#_(int, int)\"\n"                                                             + "             ^\n"));    }    private void assertMatch(InvocationNode call, String sig) {        assertTrue(parse(sig).matchesCall(call), sig + " should match " + call);    }    private void assertNoMatch(InvocationNode call, String s) {        assertFalse(parse(s).matchesCall(call), s + " should not match " + call);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.internal;import static net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil.containsCamelCaseWord;import static net.sourceforge.pmd.lang.java.rule.internal.JavaRuleUtil.startsWithCamelCaseWord;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class JavaRuleUtilTest extends BaseParserTest {    @Test    void testCamelCaseWords() {        assertFalse(startsWithCamelCaseWord("getter", "get"), "no word boundary");        assertFalse(startsWithCamelCaseWord("get", "get"), "no following word");        assertTrue(startsWithCamelCaseWord("getX", "get"), "ok prefix");        assertFalse(startsWithCamelCaseWord("ge", "get"), "shorter word");        assertThrows(NullPointerException.class, () -> startsWithCamelCaseWord(null, "get"));        assertThrows(NullPointerException.class, () -> startsWithCamelCaseWord("fnei", null));    }    @Test    void testContainsCamelCaseWords() {        assertFalse(containsCamelCaseWord("isABoolean", "Bool"), "no word boundary");        assertTrue(containsCamelCaseWord("isABoolean", "A"), "ok word in the middle");        assertTrue(containsCamelCaseWord("isABoolean", "Boolean"), "ok word at the end");        assertThrows(NullPointerException.class, () -> containsCamelCaseWord(null, "A"));        assertThrows(NullPointerException.class, () -> containsCamelCaseWord("fnei", null));        assertThrows(AssertionError.class, () -> containsCamelCaseWord("fnei", ""), "empty string");        assertThrows(AssertionError.class, () -> containsCamelCaseWord("fnei", "a"), "not capitalized");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class HardCodedCryptoKeyTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class InsecureCryptoIvTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MissingSerialVersionUIDTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryCaseChangeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidLiteralsInIfConditionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryConversionTemporaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class FinalizeShouldBeProtectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidCallingFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CallSuperFirstTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MisplacedNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class StringBufferInstantiationWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CloneMethodMustBePublicTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptySwitchStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseLocaleWithCaseConversionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseEqualsToCompareStringsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DontImportSunTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class FinalizeOnlyCallsSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidCatchingThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ComparisonWithNaNTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotTerminateVMTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CloneMethodMustImplementCloneableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class TestClassWithoutTestCasesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class JumbledIncrementerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotHardCodeSDCardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ImplicitSwitchFallThroughTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AssignmentToNonFinalStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnitStaticSuiteTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseCorrectExceptionLoggingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnitSpellingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class FinalizeOverloadedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MoreThanOneLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class StaticEJBFieldShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DetachedTestCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class SuspiciousEqualsMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseProperClassLoaderTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotCallGarbageCollectionExplicitlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EqualsNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotExtendJavaLangThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class NonStaticInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class BrokenNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ClassCastExceptionWithToArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class SimpleDateFormatNeedsLocaleTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidEnumAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class InvalidLogMessageFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class FinalizeDoesNotCallSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ReturnFromFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ProperCloneImplementationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CloseResourceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDuplicateLiteralsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ReturnEmptyCollectionRatherThanNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CallSuperLastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CloneMethodReturnTypeMustMatchClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyFinalizerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidAssertAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class IdempotentOperationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyTryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CompareObjectsWithEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotThrowExceptionInFinallyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class SingleMethodSingletonTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidAccessibilityAlterationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnconditionalIfStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class NonCaseLabelInSwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ProperLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidLosingExceptionInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MissingStaticMethodInNonInstantiatableClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidInstanceofChecksInCatchClauseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class NullAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidBranchingStatementAsLastInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidMultipleUnaryOperatorsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDecimalLiteralsInBigDecimalConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidFieldNameMatchingMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedNullCheckInEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class DontUseFloatTypeForLoopIndicesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptySynchronizedBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class CheckSkipResultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidUsingOctalValuesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class InstantiationToGetClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidFieldNameMatchingTypeNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyStatementNotInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UselessOperationOnImmutableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidCatchingNPETest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class SuspiciousOctalEscapeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class SingletonClassReturningNewInstanceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class SuspiciousHashcodeMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class NonSerializableClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConstructorCallsOverridableMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SignatureDeclareThrowsExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidThrowingNullPointerExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AbstractClassWithoutAnyMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseObjectForClearerAPITest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExceptionAsFlowControlTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SwitchDensityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidUncheckedExceptionsInSignaturesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class UselessOverridingMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SimplifiedTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ClassWithOnlyPrivateConstructorsShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class GodClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotExtendJavaLangErrorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CouplingBetweenObjectsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseUtilityClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidRethrowingExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ImmutableFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidThrowingRawExceptionTypesTest extends PmdRuleTst {    public static class Throwable extends java.lang.Throwable {        private static final long serialVersionUID = 1798165250043760600L;    }    public static class Exception extends java.lang.Throwable {        private static final long serialVersionUID = -2518308549741147689L;    }    public static class RuntimeException extends java.lang.Throwable {        private static final long serialVersionUID = 6341520923058239682L;    }    public static class Error extends java.lang.Throwable {        private static final long serialVersionUID = -6965602141393320558L;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class DataClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SimplifyConditionalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class FinalFieldCouldBeStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NPathComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SingularFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SimplifyBooleanReturnsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class MutableStaticStateTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidCatchingGenericExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class LawOfDemeterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class LogicInversionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class SimplifyBooleanExpressionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NcssCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CognitiveComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidThrowingNewInstanceOfSameExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InvalidJavaBeanTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class LoosePackageCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AppendCharacterWithCharTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseIOStreamsWithApacheCommonsFileItemTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class OptimizableToArrayCallTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseArrayListInsteadOfVectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidFileStreamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class BigIntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConsecutiveAppendsShouldReuseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidCalendarDateCreationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidArrayLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AddEmptyStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidInstantiatingObjectsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UselessStringValueOfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConsecutiveLiteralAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class StringToStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class RedundantFieldInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseArraysAsListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class InefficientStringBufferingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class InefficientEmptyStringCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooFewBranchesForASwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseIndexOfCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class InsufficientStringBufferDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class StringInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseStringBufferLengthTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseStringBufferForStringAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.testframework.PmdRuleTst;class CommentRequiredTest extends PmdRuleTst {    @Test    void allCommentTypesIgnored() {        CommentRequiredRule rule = new CommentRequiredRule();        assertNull(rule.dysfunctionReason(), "By default, the rule should be functional");        List<PropertyDescriptor<?>> propertyDescriptors = getProperties(rule);        // remove  deprecated properties        propertyDescriptors.removeIf(property -> property.description().startsWith("Deprecated!"));        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Ignored");        }        assertNotNull(rule.dysfunctionReason(), "All properties are ignored, rule should be dysfunctional");        // now, try out combinations: only one of the properties is required.        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Required");            assertNull(rule.dysfunctionReason(),                    "The property " + property.name() + " is set to required, the rule should be functional.");            setPropertyValue(rule, property, "Ignored");        }    }    private static List<PropertyDescriptor<?>> getProperties(Rule rule) {        List<PropertyDescriptor<?>> result = new ArrayList<>();        for (PropertyDescriptor<?> property : rule.getPropertyDescriptors()) {            if (property != Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR                    && property != Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) {                result.add(property);            }        }        return result;    }    private static <T> void setPropertyValue(Rule rule, PropertyDescriptor<T> property, String value) {        rule.setProperty(property, property.valueFrom(value));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;class CommentSizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;class CommentContentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;class UncommentedEmptyMethodBodyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;class UncommentedEmptyConstructorTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryfullyqualifiedname;@org.junit.Ignore("Rule has not been updated yet")public class TestClass {    protected class SomeInnerClass {        public void alsoDoSomething() {            System.out.println("alsoDoSomething");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class MDBAndSessionBeanNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LocalHomeNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ControlStatementBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooManyStaticImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class CommentDefaultAccessModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class OnlyOneReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDollarSignsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class PrematureDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidUsingNativeCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ShortMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExtendsObjectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class CallSuperInConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForLoopShouldBeWhileLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseDiamondOperatorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryFullyQualifiedNameTest extends PmdRuleTst {    // Do not delete these two enums - it is needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1436 UnnecessaryFullyQualifiedName false positive on clashing static    // imports with enums    public enum ENUM1 {        A, B;    }    public enum ENUM2 {        C, D;    }    // Do not delete these classes - it is needed for a test case    // see: /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1546 part 1 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    // #1546 part 2 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    public static class PhonyMockito {        public static final int TWO = 2;        public static <T> T mock(Class<T> clazz) {            return null;        }    }    static class Container {        public static class PhonyMockito {            public static <T> T mock(Class<T> clazz) {                return null;            }        }    }    public static class MockitoInherited extends PhonyMockito {        // static method PhonyMockito::mock is static imported        // if MockitoInherited is imported on demand    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FieldDeclarationsShouldBeAtStartOfClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryAnnotationValueElementTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryImportTest extends PmdRuleTst {    // these 2 methods are used for a test case, do not delete    public static void assertTrue(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }    public static void assertSomething(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ShortClassNameTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryBoxingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseShortArrayInitializerTest extends PmdRuleTst {  // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class RemoteInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UselessQualifiedThisTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class IdenticalCatchBranchesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import static org.junit.jupiter.api.Assertions.assertAll;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.function.Executable;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.rule.codestyle.UselessParenthesesRule.Necessity;import net.sourceforge.pmd.testframework.PmdRuleTst;class UselessParenthesesTest extends PmdRuleTst {    Executable testImpl(String expression, Necessity necessity) {        return () -> {            String file = "class Foo {{ int a,b,c,d; float f1, f2, f3; String s; Object e = " + expression + ";}}";            ASTCompilationUnit acu = JavaParsingHelper.DEFAULT.parse(file);            ASTExpression paren = acu.descendants(ASTExpression.class).crossFindBoundaries().first(ASTExpression::isParenthesized);            assertNotNull(paren, "No parenthesized expression in " + expression);            UselessParenthesesRule.Necessity result = UselessParenthesesRule.needsParentheses(paren, paren.getParent());            assertEquals(necessity, result, "In " + expression);        };    }    Executable clarifying(String expression) {        return testImpl(expression, Necessity.CLARIFYING);    }    Executable balancing(String expression) {        return testImpl(expression, Necessity.BALANCING);    }    Executable necessary(String expression) {        return testImpl(expression, Necessity.ALWAYS);    }    Executable unnecessary(String expression) {        return testImpl(expression, Necessity.NEVER);    }    @Test    void testOuterLambdas() {        assertAll(            unnecessary("() -> (a + b)"),            unnecessary("() -> (() -> b)"),            unnecessary("() -> (a ? b : c)"), // clarifying?            necessary("a ? () -> (a ? b : c) : d")        );    }    @Test    void testInnerLambda() {        assertAll(            necessary("(() -> 1) + 2"),            unnecessary("((() -> 1)) + 2"),            necessary("(() -> 1) * 2"),            // necessary("(() -> 1) = 2"), (impossible)            unnecessary("a = (() -> 1)")        );    }    @Test    void testAssignments() {        //  (a = b) = c          (impossible)        assertAll(            necessary("a * (b = c)"),            unnecessary("a * ((b = c))"),            necessary("a ? (b = c) : d"),            unnecessary("a = (b = c)")        );    }    @Test    void testConditionals() {        assertAll(            unnecessary("a ? b : (c ? d : e)"),            necessary("a ? (b ? c : d) : e"),            unnecessary("a ? ((b ? c : d)) : e"),            necessary("(a ? b : c) ? d : e"),            clarifying("(a == b) ? c : d"),            unnecessary("(s.toString()) ? c : d")        );    }    @Test    void testAdditiveMul() {        // remember, a,b,c,d are ints        // fp1,2,3 are floats        assertAll(            unnecessary("a + (b + c)"),            unnecessary("a + (b - c)"),            clarifying("a + (b * c)"),            unnecessary("(a + b) + c"),            unnecessary("(f1 + f1) + f2"),            unnecessary("(a + b) - c"),            necessary("(a + b) * c"),            necessary("(a + b) / c"),            necessary("x / (a + d)"),            // those mix floating-point operations            necessary("a + (f1 + b)"),            necessary("a + (f1 - b)"),            necessary("a + (b + f1)"),            necessary("a + (b - f1)"),            necessary("f1 + (f1 + b)"),            necessary("f1 + (f1 - b)"),            necessary("f1 + (b + f1)"),            necessary("f1 + (b - f1)")        );    }    @Test    void testMultiplicative() {        assertAll(            unnecessary("(a * b) * c"),            unnecessary("a * (b * c)"),            necessary("a * (b / c)"),            necessary("a * (b % c)"),            necessary("a / (b * c)"),            necessary("a / (b / c)"),            necessary("a / (b % c)"),            necessary("a % (b * c)"),            necessary("a % (b / c)"),            necessary("a % (b % c)")        );    }    @Test    void testConcatenation() {        assertAll(            necessary("\"\" + (1 + 4)"),            unnecessary("\"\" + (\"\" + 4)"),            unnecessary("\"\" + (4 + \"\")"),            clarifying("(1 + 4) + \"\"")        );    }    @Test    void testEquality() {        assertAll(            necessary("a == null == (b == null)"),            unnecessary("a == null == ((b == null))"),            balancing("(a == null) == (b == null)"),            unnecessary("(a == true) == b == true"),            // the same with some !=            necessary("a == null != (b == null)"),            unnecessary("a == null != ((b == null))"),            balancing("(a == null) == (b != null)"),            unnecessary("(a != true) == b == true")        );    }    @Test    void testRelational() {        assertAll(            clarifying("a <= b == (b <= c)"),            clarifying("(a <= b) == (b <= c)"),            necessary("(a == b) >= 0"),            clarifying("(a + b) >= 0")        );    }    @Test    void testUnaries() {        assertAll(            unnecessary("(String) ((String) c)"),            unnecessary("(String) (+1)"),            unnecessary("a + +((char) 1)"),            unnecessary("a + ~((char) 1)"),            clarifying("a + ((char) 1)"),            clarifying("a * ((char) 1)"),            clarifying("((char) 1) * a"),            unnecessary("-(-1)"),            unnecessary("-(+1)")        );    }    @Test    void testSwitches() {        assertAll(            unnecessary(" a + (switch (1) { })"),            unnecessary("(switch (1) { }) + 1")        );    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidProtectedFieldInFinalClassTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryCastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidProtectedMethodInFinalClassNotExtendingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyMethodInAbstractClassShouldBeAbstractTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class GenericsNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LongVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LocalVariableCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class PackageCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class AtLeastOneConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseUnderscoresInNumericLiteralsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FinalParameterInAbstractMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LocalInterfaceSessionNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class RemoteSessionInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LinguisticNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryLocalBeforeReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConfusingTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessarySemicolonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class BooleanGetMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyControlStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ShortVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class MethodArgumentCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoubleBraceInitializationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AbstractClassWithoutAbstractMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseVarargsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnitUseExpectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForLoopCanBeForeachTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnit4TestShouldUseAfterAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class MissingOverrideTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedPrivateMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ReplaceVectorWithListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class DefaultLabelNotLastInSwitchStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidReassigningCatchVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidMessageDigestFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForLoopVariableCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedFormalParameterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnitAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AccessorMethodGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class CheckResultSetTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConstantsInInterfaceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ReplaceEnumerationWithIteratorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class PrimitiveWrapperInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnit4TestShouldUseTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidStringBufferFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ReplaceHashtableWithMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidReassigningLoopVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseTryWithResourcesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class LooseCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class PreserveStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class WhileLoopWithLiteralBooleanTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class SystemPrintlnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class LiteralsFirstInComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedPrivateFieldTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidUsingHardCodedIPTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ArrayIsStoredDirectlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnit5TestShouldBePackagePrivateTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseStandardCharsetsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnitTestsShouldIncludeAssertTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseCollectionIsEmptyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnitTestContainsTooManyAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnit4SuitesShouldUseSuiteAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class GuardLogStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class JUnit4TestShouldUseBeforeAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class SimplifiableTestAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AccessorClassGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidPrintStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class MethodReturnsInternalArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class SwitchStmtsShouldHaveDefaultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseConcurrentHashMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnsynchronizedStaticFormatterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class NonThreadSafeSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidUsingVolatileTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class DontCallThreadRunTest extends PmdRuleTst {    // Used by DontCallThreadRun test cases    public static class TestThread extends Thread {        @Override        public void run() {            System.out.println("test");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoubleCheckedLockingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidSynchronizedAtMethodLevelTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidThreadGroupTest extends PmdRuleTst {    // Used by AvoidThreadGroup test cases    public static class ThreadGroup {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseNotifyAllInsteadOfNotifyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;class DoNotUseThreadsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException.Phase;/** * @author Clément Fournier * @since 7.0.0 */class MatchesSignatureXPathTest extends BaseXPathFunctionTest {    @Test    void testMatchSig1() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('_#equals(java.lang.Object)')]");        assertFinds(rule, 1, "class O { { this.equals(\"\"); } }");        assertFinds(rule, 0, "class O { { this.equals(\"\", 2); }  void equals(String i, int a) {}}");    }    @Test    void testMatchSigWithReceiver() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('java.lang.Enum#equals(java.lang.Object)')]");        assertFinds(rule, 1, "enum O {; { this.equals(\"\"); } }");        assertFinds(rule, 0, "enum O {; { \"\".equals(\"\"); } }");    }    @Test    void testMatchSigUnresolved() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('java.lang.String#foobar()')]");        assertFinds(rule, 0, "enum O {; { \"\".foobar(); } }");    }    @Test    void testMatchSigNoName() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('_#_(int,int)')]");        assertFinds(rule, 2, "enum O {; { \"\".substring(1, 2); this.foo(1, 'c');} void foo(int a, int b) {} }");    }    @Test    void testMatchSigWrongTypeReturnsFalse() {        Rule rule = makeXpathRuleFromXPath("//EnumDeclaration[pmd-java:matchesSig('_#_(int,int)')]");        assertFinds(rule, 0, "enum O {; { \"\".substring(1, 2); this.foo(1, 'c');} void foo(int a, int b) {} }");    }    @Test    void testMatchInvalidSig() {        Rule rule = makeXpathRuleFromXPath("//*[pmd-java:matchesSig('_#')]");        PmdXPathException e = assertThrows(PmdXPathException.class, rule::getTargetSelector);        assertEquals(Phase.INITIALIZATION, e.getPhase());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;/** * @author Clément Fournier * @since 6.0.0 */class XPathMetricFunctionTest extends BaseXPathFunctionTest {    @Test    void testWellFormedClassMetricRule() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:metric('NCSS') > 0]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    void testWellFormedOperationMetricRule() {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[pmd-java:metric('CYCLO') > 1]");        String code = "class Goo { Goo() {if(true){}} }";        assertFinds(rule, 1, code);    }    @Test    void testBadCase() {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[pmd-java:metric('cYclo') > 1]");        String code = "class Hoo { Hoo() {if(true){}} }";        assertFinds(rule, 1, code);    }    @Test    void testNonexistentMetric() {        testWithExpectedException(            "//ConstructorDeclaration[pmd-java:metric('FOOBAR') > 1]",            "class Joo { Joo() {if(true){}} }",            e -> assertThat(e.getMessage(), containsString(MetricFunction.badMetricKeyMessage("FOOBAR"))));    }    @Test    void testIfStmt() {        Rule rule = makeXpathRuleFromXPath("//IfStatement[pmd-java:metric('NCSS') = 1]");        String code = "class Hoo { Hoo() {if(true){}} }";        assertFinds(rule, 1, code);    }    @Test    void testWrongNodeTypeMeansEmptySequence() {        Rule rule = makeXpathRuleFromXPath("//EnumDeclaration[not(pmd-java:metric('NPATH'))]");        String code = "enum Loo { FOO; }";        assertFinds(rule, 1, code);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;/** * @author Clément Fournier * @since 7.0.0 */class TypeIsFunctionTest extends BaseXPathFunctionTest {    @Test    void testHasAnnotation() {        Rule rule = makeXpathRuleFromXPath("//Annotation[pmd-java:typeIs('java.lang.Override')]");        assertFinds(rule, 1, "interface O { @Override void foo(); }");    }    @Test    void testHasAnnotationNonQual() {        Rule rule = makeXpathRuleFromXPath("//Annotation[pmd-java:typeIs('Override')]");        //does not match        assertFinds(rule, 0, "interface O { @Override void foo(); }");    }    @Test    void testTypeIsArray() {        Rule rule = makeXpathRuleFromXPath("//*[pmd-java:typeIs('int[]')]");        // ArrayType + VariableDeclaratorId        assertFinds(rule, 2, "class K { int[] i; }");    }    @Test    void testWrongTypeReturnsFalse() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceBody[pmd-java:typeIs('java.lang.Override')]");        assertFinds(rule, 0, "interface O { @Override void foo(); }");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;/** * @author Clément Fournier * @since 7.0.0 */class HasAnnotationXPathTest extends BaseXPathFunctionTest {    @Test    void testHasAnnotation() {        Rule rule = makeXpathRuleFromXPath("//MethodDeclaration[pmd-java:hasAnnotation('java.lang.Override')]");        String code = "interface O { @Override void foo(); }";        assertFinds(rule, 1, code);    }    @Test    void testHasAnnotationNonQual() {        Rule rule = makeXpathRuleFromXPath("//MethodDeclaration[pmd-java:hasAnnotation('Override')]");        String code = "interface O { @Override void foo(); }";        //does not match        assertFinds(rule, 0, code);    }    @Test    void testWrongTypeReturnsFalse() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceBody[pmd-java:hasAnnotation('java.lang.Override')]");        String code = "interface O { @Override void foo(); }";        assertFinds(rule, 0, code);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException.Phase;/** * @author Clément Fournier * @since 7.0.0 */class GetModifiersFunctionsTest extends BaseXPathFunctionTest {    @Test    void testEffectiveModifiers() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:modifiers() = ('public', 'abstract')]");        String code = "interface O { class Foo { } }";        assertFinds(rule, 2, code);    }    @Test    void testExplicitModifiers() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:explicitModifiers() = ('public', 'abstract')]");        String code = "interface O { class Foo { } }";        assertFinds(rule, 0, code);    }    @Test    void testNotAccessNodeReturnsEmptySequence() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceBody[pmd-java:modifiers()]");        String code = "interface O { class Foo { } }";        assertFinds(rule, 0, code);    }    @Test    void testStaticTypeError() {        testWithExpectedException(            "//MethodDeclaration[(., .) is pmd-java:modifiers()]",            "class Moo { void foo() {if(true){}} }",            e -> {                assertThat(e.getMessage(), containsString("Type error"));                assertThat(e.getPhase(), equalTo(Phase.INITIALIZATION));            });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.CoreMatchers.instanceOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.function.Consumer;import org.checkerframework.checker.nullness.qual.NonNull;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.ast.FileAnalysisException;import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;/** * @author Clément Fournier * @since 7.0.0 */class BaseXPathFunctionTest extends BaseParserTest {    private static final String VIOLATION_MESSAGE = "violation";    private static final String RULE_NAME_PLACEHOLDER = "$rule_name";    private @NonNull Report executeRule(Rule rule, String code) {        return java.executeRule(rule, code);    }    protected Rule makeXpathRuleFromXPath(String xpath) {        XPathRule rule = new XPathRule(XPathVersion.DEFAULT, xpath);        rule.setName("$rule_name");        rule.setMessage(VIOLATION_MESSAGE);        rule.setLanguage(JavaLanguageModule.getInstance());        return rule;    }    protected void assertFinds(Rule rule, int numViolations, String code) {        Report report = executeRule(rule, code);        TestUtilsKt.assertSize(report, numViolations);    }    protected void testWithExpectedException(String xpath,                                             String code,                                             Consumer<? super PmdXPathException> exceptionSpec) {        Rule rule = makeXpathRuleFromXPath(xpath);        FileAnalysisException thrown = assertThrows(FileAnalysisException.class, () -> executeRule(rule, code));        assertThat(thrown.getCause(), instanceOf(PmdXPathException.class));        PmdXPathException cause = (PmdXPathException) thrown.getCause();        exceptionSpec.accept(cause);        assertThat(cause.getRuleName(), equalTo(RULE_NAME_PLACEHOLDER));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException.Phase;/** * @author Clément Fournier * @since 7.0.0 */class NodeIsFunctionTest extends BaseXPathFunctionTest {    @Test    void testWellFormedNodeName() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:nodeIs('ClassOrInterfaceDeclaration')]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    void testNodeNameStaticallyUnknown() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:nodeIs(name())]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    void testWellFormedNodeNameForSupertype() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:nodeIs('AnyTypeDeclaration')]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    void testNonExistentNodeName() {        // note that this would fail with a type error (boolean > integer)        // if nodeIs fails to fail        testWithExpectedException(            "//MethodDeclaration[pmd-java:nodeIs('ohio') > 1]",            "class Moo { void foo() {if(true){}} }",            e -> {                assertThat(e.getMessage(), containsString("ASTohio"));                assertThat(e.getPhase(), equalTo(Phase.INITIALIZATION));            });    }    @Test    void testNonExistentNodeNameStaticallyUnknown() {        testWithExpectedException(            "//MethodDeclaration[pmd-java:nodeIs(name() || 'qqq')]",            "class Moo { void foo() {if(true){}} }",            e -> {                assertThat(e.getMessage(), containsString("MethodDeclarationqqq"));                assertThat(e.getPhase(), equalTo(Phase.EVALUATION));            });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.HashMap;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.JavaNode;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.lang.rule.xpath.impl.XPathHandler;import net.sourceforge.pmd.lang.rule.xpath.internal.DeprecatedAttrLogger;import net.sourceforge.pmd.lang.rule.xpath.internal.SaxonXPathRuleQuery;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;/** * @author daniels */class XPathRuleTest {    private XPathRule makeXPath(String expression) {        return JavaParsingHelper.DEFAULT.newXpathRule(expression);    }    @Test    void testPluginname() {        XPathRule rule = makeXPath("//VariableDeclaratorId[string-length(@Name) < 3]");        rule.setMessage("{0}");        Report report = getReportForTestString(rule, TEST1);        RuleViolation rv = report.getViolations().get(0);        assertEquals("a", rv.getDescription());    }    @Test    void testXPathMultiProperty() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[@Name=$forbiddenNames]");        rule.setMessage("Avoid vars");        PropertyDescriptor<List<String>> varDescriptor            = PropertyFactory.stringListProperty("forbiddenNames")                             .desc("Forbidden names")                             .defaultValues("forbid1", "forbid2")                             .delim('$')                             .build();        rule.definePropertyDescriptor(varDescriptor);        Report report = getReportForTestString(rule, TEST3);        assertEquals(2, report.getViolations().size());    }    @Test    void testVariables() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[@Name=$var]");        rule.setMessage("Avoid vars");        PropertyDescriptor<String> varDescriptor =            PropertyFactory.stringProperty("var").desc("Test var").defaultValue("").build();        rule.definePropertyDescriptor(varDescriptor);        rule.setProperty(varDescriptor, "fiddle");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.getViolations().get(0);        assertEquals(3, rv.getBeginLine());    }    @Test    void testFnPrefixOnSaxon() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[fn:matches(@Name, 'fiddle')]");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.getViolations().get(0);        assertEquals(3, rv.getBeginLine());    }    @Test    void testNoFnPrefixOnSaxon() {        XPathRule rule = makeXPath("//VariableDeclaratorId[matches(@Name, 'fiddle')]");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.getViolations().get(0);        assertEquals(3, rv.getBeginLine());    }    @Test    void testSimpleQueryIsRuleChain() {        // ((/)/descendant::element(Q{}VariableDeclaratorId))[matches(convertUntyped(data(@Name)), "fiddle", "")]        assertIsRuleChain("//VariableDeclaratorId[matches(@Name, 'fiddle')]");    }    @Test    void testSimpleQueryIsRuleChain2() {        // docOrder(((/)/descendant-or-self::node())/(child::element(ClassOrInterfaceType)[typeIs("java.util.Vector")]))        assertIsRuleChain("//ClassOrInterfaceType[pmd-java:typeIs('java.util.Vector')]");    }    private void assertIsRuleChain(String xpath) {        XPathRule rule = makeXPath(xpath);        assertTrue(rule.getTargetSelector().isRuleChain(), "Not recognized as a rulechain query: " + xpath);    }    /**     * Following sibling check: See https://sourceforge.net/p/pmd/bugs/1209/     *     * @throws Exception any error     */    @Test    void testFollowingSibling() throws Exception {        final String source = "public interface dummy extends Foo, Bar, Baz {}";        ASTCompilationUnit cu = JavaParsingHelper.DEFAULT.parse(source);        String xpath = "//ExtendsList/ClassOrInterfaceType/following-sibling::ClassOrInterfaceType";        SaxonXPathRuleQuery xpathRuleQuery = new SaxonXPathRuleQuery(xpath,                                                                     XPathVersion.DEFAULT,                                                                     new HashMap<>(),                                                                     XPathHandler.noFunctionDefinitions(),                                                                     DeprecatedAttrLogger.noop());        List<Node> nodes = xpathRuleQuery.evaluate(cu);        assertEquals(2, nodes.size());        assertEquals("Bar", ((JavaNode) nodes.get(0)).getText().toString());        assertEquals("Baz", ((JavaNode) nodes.get(1)).getText().toString());    }    private static Report getReportForTestString(Rule r, String test) {        return JavaParsingHelper.DEFAULT.executeRule(r, test);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " int a;" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " int faddle;" + PMD.EOL + " int fiddle;"            + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " int forbid1; int forbid2; int forbid1$forbid2;" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaNode;/** * @author Philip Graf */class JavaRuleViolationTest {    // TODO there are no tests for anon or local classes    /**     * Verifies that {@link JavaRuleViolation} sets the variable name for an     * {@link ASTFormalParameter} node.     */    @Test    void testASTFormalParameterVariableName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        final ASTFormalParameter node = ast.getFirstDescendantOfType(ASTFormalParameter.class);        final RuleViolation violation = violationAt(node);        assertEquals("x", violation.getVariableName());    }    private ASTCompilationUnit parse(final String code) {        return JavaParsingHelper.DEFAULT.parse(code);    }    /**     * Tests that the method name is taken correctly from the given node.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1250/">#1250</a>     */    @Test    void testMethodName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        assertEquals("bar", violationAt(md).getMethodName());    }    @NonNull    RuleViolation violationAt(JavaNode md) {        return new JavaRuleViolation(new FooRule(), md, md.getReportLocation(), "");    }    /**     * Tests that the enum name is taken correctly from the given node.     */    @Test    void testEnumName() {        ASTCompilationUnit ast = parse("enum Foo {FOO; void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        assertEquals("Foo", violationAt(md).getClassName());    }    /**     * Tests that the class name is taken correctly, even if the node is outside     * of a class scope, e.g. a import declaration.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1529/">#1529</a>     */    @Test    void testPackageAndClassNameForImport() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    void testPackageAndClassNameForField() {        ASTCompilationUnit ast = parse("package pkg; public class Foo { int a; }");        ASTClassOrInterfaceDeclaration classDeclaration = ast.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        ASTFieldDeclaration field = ast.getFirstDescendantOfType(ASTFieldDeclaration.class);        RuleViolation violation = violationAt(classDeclaration);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());        violation = violationAt(field);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    void testPackageAndEnumName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public enum FooE { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("FooE", violation.getClassName());    }    @Test    void testDefaultPackageAndClassName() {        ASTCompilationUnit ast = parse("import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    void testPackageAndMultipleClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { } public class Bar { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("Bar", violation.getClassName());    }    @Test    void testPackageAndPackagePrivateClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    /**     * Test that the name of the inner class is taken correctly.     * Also check fields.     */    @Test    void testInnerClass() {        ASTCompilationUnit ast = parse("class Foo { int a; class Bar { int a; } }");        List<ASTClassOrInterfaceDeclaration> classes = ast.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(2, classes.size());        RuleViolation fooViolation = violationAt(classes.get(0));        assertEquals("Foo", fooViolation.getClassName());        RuleViolation barViolation = violationAt(classes.get(1));        assertEquals("Foo$Bar", barViolation.getClassName());        List<ASTFieldDeclaration> fields = ast.findDescendantsOfType(ASTFieldDeclaration.class, true);        assertEquals(2, fields.size());        RuleViolation fieldViolation = violationAt(fields.get(0));        assertEquals("Foo", fieldViolation.getClassName());        RuleViolation innerFieldViolation = violationAt(fields.get(1));        assertEquals("Foo$Bar", innerFieldViolation.getClassName());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast.internal;import static net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils.flattenOperands;import static net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils.isStringConcatExpr;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.ast.ASTInfixExpression;import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;class JavaAstUtilTest extends BaseParserTest {    @Test    void testFlattenConcatOperands() {        ASTExpression e = parseExpr("s1+s2+s3");        assertTrue(isStringConcatExpr(e));        assertEquals(e.descendants(ASTVariableAccess.class).toList(),                     flattenOperands(e).toList());    }    @Test    void testFlattenConcatOperandsRespectsTyping() {        ASTInfixExpression e = (ASTInfixExpression) parseExpr("i+j+s2+s3");        assertTrue(isStringConcatExpr(e));        ASTInfixExpression left = (ASTInfixExpression) e.getLeftOperand();        assertTrue(isStringConcatExpr(left));        //                      This is (i+j)        //                  vvvvvvvvvvvvvvvvvvvvv        assertEquals(listOf(left.getLeftOperand(), left.getRightOperand(), e.getRightOperand()),                     flattenOperands(e).toList());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast.internal;import static net.sourceforge.pmd.lang.java.ast.internal.PrettyPrintingUtil.displaySignature;import static net.sourceforge.pmd.lang.java.ast.internal.PrettyPrintingUtil.prettyPrint;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.hamcrest.BaseMatcher;import org.hamcrest.Description;import org.hamcrest.Matcher;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.util.StringUtil;class PrettyPrintingUtilTest extends BaseParserTest {    @Test    void displaySignatureTestWithExtraDimensions() {        ASTCompilationUnit root = java.parse("class A { public void foo(String[] a[]) {} }");        ASTMethodDeclaration m = root.descendants(ASTMethodDeclaration.class).firstOrThrow();        assertEquals("foo(String[][])", displaySignature(m));    }    @Test    void ppMethodCall() {        ASTCompilationUnit root = java.parse("class A { { foo(1); this.foo(1); A.this.foo(); } }");        List<ASTMethodCall> m = root.descendants(ASTMethodCall.class).toList();        assertThat(prettyPrint(m.get(0)), contentEquals("foo(1)"));        assertThat(prettyPrint(m.get(1)), contentEquals("this.foo(1)"));        assertThat(prettyPrint(m.get(2)), contentEquals("A.this.foo()"));    }    @Test    void ppMethodCallArgsTooBig() {        ASTCompilationUnit root = java.parse("class A { { this.foo(\"a long string\", 12, 12, 12, 12, 12); } }");        @NonNull ASTMethodCall m = root.descendants(ASTMethodCall.class).firstOrThrow();        assertThat(prettyPrint(m), contentEquals("this.foo(\"a long string\", 12...)"));    }    @Test    void ppMethodCallOnCast() {        ASTCompilationUnit root = java.parse("class A { { ((Object) this).foo(12); } }");        @NonNull ASTMethodCall m = root.descendants(ASTMethodCall.class).firstOrThrow();        assertThat(prettyPrint(m), contentEquals("((Object) this).foo(12)"));    }    private static Matcher<CharSequence> contentEquals(String str) {        return new BaseMatcher<CharSequence>() {            @Override            public boolean matches(Object o) {                return o instanceof CharSequence && str.contentEquals((CharSequence) o);            }            @Override            public void describeTo(Description description) {                description.appendText("a char sequence with content \"" + StringUtil.escapeJava(str) + "\"");            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class Java9TreeDumpTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java9 = JavaParsingHelper.DEFAULT        .withDefaultVersion("9")        .withResourceContext(Java9TreeDumpTest.class, "jdkversiontests/java9");    @Test    void testModule() {        doTest("jdk9_module_info");    }    @Test    void testAnnotatedModule() {        doTest("jdk9_module_info_with_annot");    }    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return java9;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.types.TestUtilitiesForTypesKt.hasType;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.empty;import static org.hamcrest.Matchers.not;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.NodeStream;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.symbols.JElementSymbol;import net.sourceforge.pmd.lang.java.types.JPrimitiveType;class Java16TreeDumpTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java16 =            JavaParsingHelper.DEFAULT.withDefaultVersion("16")                                     .withResourceContext(Java16TreeDumpTest.class, "jdkversiontests/java16/");    private final JavaParsingHelper java15 = java16.withDefaultVersion("15");    @Override    public BaseParsingHelper<?, ?> getParser() {        return java16;    }    @Test    void patternMatchingInstanceof() {        doTest("PatternMatchingInstanceof");        // extended tests for type resolution etc.        ASTCompilationUnit ast = java16.parseResource("PatternMatchingInstanceof.java");        NodeStream<ASTTypePattern> patterns = ast.descendants(ASTTypePattern.class);        assertThat(patterns.toList(), not(empty()));        for (ASTTypePattern expr : patterns) {            assertThat(expr.getVarId(), hasType(String.class));        }    }    @Test    void patternMatchingInstanceofBeforeJava16ShouldFail() {        assertThrows(ParseException.class, () -> java15.parseResource("PatternMatchingInstanceof.java"));    }    @Test    void localClassAndInterfaceDeclarations() {        doTest("LocalClassAndInterfaceDeclarations");    }    @Test    void localClassAndInterfaceDeclarationsBeforeJava16ShouldFail() {        assertThrows(ParseException.class, () -> java15.parseResource("LocalClassAndInterfaceDeclarations.java"));    }    @Test    void localAnnotationsAreNotAllowed() {        assertThrows(ParseException.class, () -> java16.parse("public class Foo { { @interface MyLocalAnnotation {} } }"));    }    @Test    void localRecords() {        doTest("LocalRecords");    }    @Test    void recordPoint() {        doTest("Point");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java16.parseResource("Point.java");        ASTRecordDeclaration recordDecl = compilationUnit.descendants(ASTRecordDeclaration.class).first();        List<ASTRecordComponent> components = recordDecl.descendants(ASTRecordComponentList.class)                .children(ASTRecordComponent.class).toList();        ASTVariableDeclaratorId varId = components.get(0).getVarId();        JElementSymbol symbol = varId.getSymbol();        assertEquals("x", symbol.getSimpleName());        assertTrue(varId.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT));    }    @Test    void recordPointBeforeJava16ShouldFail() {        assertThrows(ParseException.class, () -> java15.parseResource("Point.java"));    }    @Test    void recordCtorWithThrowsShouldFail() {        assertThrows(ParseException.class, () -> java16.parse("  record R {"                + "   R throws IOException {}"                + "  }"));    }    @Test    void recordMustNotExtend() {        assertThrows(ParseException.class, () -> java16.parse("record RecordEx(int x) extends Number { }"));    }    @Test    void innerRecords() {        doTest("Records");    }    @Test    void recordIsARestrictedIdentifier() {        assertThrows(ParseException.class, () -> java16.parse("public class record {}"));    }    @Test    void sealedAndNonSealedIdentifiers() {        doTest("NonSealedIdentifier");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * Tests new java14 standard features. */class Java14TreeDumpTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java14 =        JavaParsingHelper.DEFAULT.withDefaultVersion("14")                                 .withResourceContext(Java14TreeDumpTest.class, "jdkversiontests/java14/");    private final JavaParsingHelper java13 = java14.withDefaultVersion("13");    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return java14;    }    /**     * Tests switch expressions with yield.     */    @Test    void switchExpressions() {        doTest("SwitchExpressions");    }    /**     * In java13, switch expressions are only available with preview.     */    @Test    void switchExpressions13ShouldFail() {        assertThrows(ParseException.class, () -> java13.parseResource("SwitchExpressions.java"));    }    @Test    void checkYieldConditionalBehaviour() {        doTest("YieldStatements");    }    @Test    void multipleCaseLabels() {        doTest("MultipleCaseLabels");    }    @Test    void switchRules() {        doTest("SwitchRules");    }    @Test    void simpleSwitchExpressions() {        doTest("SimpleSwitchExpressions");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class Java17TreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java17 =            JavaParsingHelper.DEFAULT.withDefaultVersion("17")                                     .withResourceContext(Java17TreeDumpTest.class, "jdkversiontests/java17/");    private final JavaParsingHelper java16 = java17.withDefaultVersion("16");    Java17TreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java17;    }    @Test    void sealedClassBeforeJava17() {        ParseException thrown = assertThrows(ParseException.class, () -> java16.parseResource("geometry/Shape.java"));        assertTrue(thrown.getMessage().contains("Sealed classes are a feature of Java 17, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void sealedClass() {        doTest("geometry/Shape");    }    @Test    void nonSealedClass() {        doTest("geometry/Square");    }    @Test    void sealedQualifiedPermitClass() {        doTest("SealedInnerClasses");    }    @Test    void sealedInterfaceBeforeJava17() {        ParseException thrown = assertThrows(ParseException.class, () -> java16.parseResource("expression/Expr.java"));        assertTrue(thrown.getMessage().contains("Sealed classes are a feature of Java 17, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void sealedInterface() {        doTest("expression/Expr");    }    @Test    void localVars() {        doTest("LocalVars");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.BaseParserTest;class ASTImportDeclarationTest extends BaseParserTest {    @Test    void testImportOnDemand() {        List<ASTImportDeclaration> ops = java.getNodes(ASTImportDeclaration.class, TEST1);        assertTrue(ops.get(0).isImportOnDemand());    }    @Test    void testGetImportedNameNode() {        ASTImportDeclaration i = java.getNodes(ASTImportDeclaration.class, TEST2).get(0);        assertEquals("foo.bar.Baz", i.getImportedName());    }    @Test    void testStaticImport() {        List<ASTImportDeclaration> ops = java.getNodes(ASTImportDeclaration.class, TEST3);        ASTImportDeclaration i = ops.get(0);        assertTrue(i.isStatic());    }    @Test    void testStaticImportFailsWithJDK14() {        assertThrows(ParseException.class, () -> java.parse(TEST3, "1.4"));    }    private static final String TEST1 = "import foo.bar.*;\npublic class Foo {}";    private static final String TEST2 = "import foo.bar.Baz;\npublic class Foo {}";    private static final String TEST3 = "import static foo.bar.Baz;\npublic class Foo {}";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class Java19PreviewTreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java19p =            JavaParsingHelper.DEFAULT.withDefaultVersion("19-preview")                    .withResourceContext(Java19PreviewTreeDumpTest.class, "jdkversiontests/java19p/");    private final JavaParsingHelper java19 = java19p.withDefaultVersion("19");    Java19PreviewTreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java19p;    }    @Test    void dealingWithNullBeforeJava19Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java19.parseResource("DealingWithNull.java"));        assertTrue(thrown.getMessage().contains("Null case labels is a preview feature of JDK 19, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void dealingWithNull() {        doTest("DealingWithNull");    }    @Test    void enhancedTypeCheckingSwitch() {        doTest("EnhancedTypeCheckingSwitch");    }    @Test    void exhaustiveSwitch() {        doTest("ExhaustiveSwitch");    }    @Test    void guardedAndParenthesizedPatternsBeforeJava19Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java19.parseResource("GuardedAndParenthesizedPatterns.java"));        assertTrue(thrown.getMessage().contains("Pattern matching for switch is a preview feature of JDK 19, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void guardedAndParenthesizedPatterns() {        doTest("GuardedAndParenthesizedPatterns");    }    @Test    void patternsInSwitchLabelsBeforeJava19Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java19.parseResource("PatternsInSwitchLabels.java"));        assertTrue(thrown.getMessage().contains("Pattern matching for switch is a preview feature of JDK 19, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void patternsInSwitchLabels() {        doTest("PatternsInSwitchLabels");    }    @Test    void refiningPatternsInSwitch() {        doTest("RefiningPatternsInSwitch");    }    @Test    void scopeOfPatternVariableDeclarations() {        doTest("ScopeOfPatternVariableDeclarations");    }    @Test    void recordPatterns() {        doTest("RecordPatterns");    }    @Test    void recordPatternsBeforeJava19Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java19.parseResource("RecordPatterns.java"));        assertTrue(thrown.getMessage().contains("Record patterns is a preview feature of JDK 19, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.internal.PrettyPrintingUtil;class ASTVariableDeclaratorIdTest extends BaseParserTest {    @Test    void testIsExceptionBlockParameter() {        ASTCompilationUnit acu = java.parse(EXCEPTION_PARAMETER);        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(id.isExceptionBlockParameter());    }    @Test    void testTypeNameNode() {        ASTCompilationUnit acu = java.parse(TYPE_NAME_NODE);        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode();        assertEquals("String", name.getSimpleName());    }    @Test    void testAnnotations() {        ASTCompilationUnit acu = java.parse(TEST_ANNOTATIONS);        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNode();        assertEquals("String", name.getSimpleName());    }    @Test    void testLambdaWithType() throws Exception {        ASTCompilationUnit acu = java8.parse(TEST_LAMBDA_WITH_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertEquals("File", PrettyPrintingUtil.prettyPrintType(f.getTypeNode()));    }    @Test    void testLambdaWithoutType() throws Exception {        ASTCompilationUnit acu = java8.parse(TEST_LAMBDA_WITHOUT_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertNull(f.getTypeNode());    }    private static final String TYPE_NAME_NODE = "public class Test {\n  private String bar;\n}";    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    private static final String TEST_ANNOTATIONS = "public class Foo {\n    public void bar(@A1 @A2 String s) {}\n}";    private static final String TEST_LAMBDA_WITH_TYPE =        "public class Foo {\n    public void bar() {\n        FileFilter java = (File f) -> f.getName().endsWith(\".java\");\n    }\n}\n";    private static final String TEST_LAMBDA_WITHOUT_TYPE =        "public class Foo {\n    public void bar() {\n        FileFilter java2 = f -> f.getName().endsWith(\".java\");\n    }\n}\n";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class Java18PreviewTreeDumpTest extends BaseTreeDumpTest {    private final JavaParsingHelper java18p =            JavaParsingHelper.DEFAULT.withDefaultVersion("18-preview")                                     .withResourceContext(Java18PreviewTreeDumpTest.class, "jdkversiontests/java18p/");    private final JavaParsingHelper java18 = java18p.withDefaultVersion("18");    Java18PreviewTreeDumpTest() {        super(new RelevantAttributePrinter(), ".java");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return java18p;    }    @Test    void dealingWithNullBeforeJava18Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java18.parseResource("DealingWithNull.java"));        assertTrue(thrown.getMessage().contains("Null case labels is a preview feature of JDK 18, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void dealingWithNull() {        doTest("DealingWithNull");    }    @Test    void enhancedTypeCheckingSwitch() {        doTest("EnhancedTypeCheckingSwitch");    }    @Test    void exhaustiveSwitch() {        doTest("ExhaustiveSwitch");    }    @Test    void guardedAndParenthesizedPatternsBeforeJava18Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java18.parseResource("GuardedAndParenthesizedPatterns.java"));        assertThat(thrown.getMessage(), containsString("Pattern matching for switch is a preview feature of JDK 18, you should select your language version accordingly"));    }    @Test    void guardedAndParenthesizedPatterns() {        doTest("GuardedAndParenthesizedPatterns");    }    @Test    void patternsInSwitchLabelsBeforeJava18Preview() {        ParseException thrown = assertThrows(ParseException.class, () -> java18.parseResource("PatternsInSwitchLabels.java"));        assertTrue(thrown.getMessage().contains("Pattern matching for switch is a preview feature of JDK 18, you should select your language version accordingly"),                "Unexpected message: " + thrown.getMessage());    }    @Test    void patternsInSwitchLabels() {        doTest("PatternsInSwitchLabels");    }    @Test    void refiningPatternsInSwitch() {        doTest("RefiningPatternsInSwitch");    }    @Test    void scopeOfPatternVariableDeclarations() {        doTest("ScopeOfPatternVariableDeclarations");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.hasSize;import static org.hamcrest.Matchers.instanceOf;import static org.hamcrest.Matchers.startsWith;import static org.hamcrest.collection.IsEmptyCollection.empty;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.concurrent.TimeUnit;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.Timeout;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.impl.javacc.MalformedSourceException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;import net.sourceforge.pmd.lang.java.types.AstTestUtil;class ParserCornersTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java = JavaParsingHelper.DEFAULT.withResourceContext(getClass());    private final JavaParsingHelper java4 = java.withDefaultVersion("1.4");    private final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    private final JavaParsingHelper java7 = java.withDefaultVersion("1.7");    private final JavaParsingHelper java8 = java.withDefaultVersion("1.8");    private final JavaParsingHelper java9 = java.withDefaultVersion("9");    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return java4;    }    @Test    void testInvalidUnicodeEscape() {        MalformedSourceException thrown = assertThrows(MalformedSourceException.class, // previously Error                () -> java.parse("\\u00k0", null, "x/filename.java"));        assertThat(thrown.getMessage(), startsWith("Source format error in file 'x/filename.java' at line 1, column 1: Invalid unicode escape"));    }    /**     * #1107 PMD 5.0.4 couldn't parse call of parent outer java class method     * from inner class.     */    @Test    void testInnerOuterClass() {        java7.parse("/**\n" + " * @author azagorulko\n" + " *\n" + " */\n"                        + "public class TestInnerClassCallsOuterParent {\n" + "\n" + "    public void test() {\n"                        + "        new Runnable() {\n" + "            @Override\n" + "            public void run() {\n"                        + "                TestInnerClassCallsOuterParent.super.toString();\n" + "            }\n"                        + "        };\n" + "    }\n" + "}\n");    }    /**     * #888 PMD 6.0.0 can't parse valid <> under 1.8.     */    @Test    void testDiamondUsageJava8() {        java8.parse("public class PMDExceptionTest {\n"                        + "  private Component makeUI() {\n"                        + "    String[] model = {\"123456\", \"7890\"};\n"                        + "    JComboBox<String> comboBox = new JComboBox<>(model);\n"                        + "    comboBox.setEditable(true);\n"                        + "    comboBox.setEditor(new BasicComboBoxEditor() {\n"                        + "      private Component editorComponent;\n"                        + "      @Override public Component getEditorComponent() {\n"                        + "        if (editorComponent == null) {\n"                        + "          JTextField tc = (JTextField) super.getEditorComponent();\n"                        + "          editorComponent = new JLayer<>(tc, new ValidationLayerUI<>());\n"                        + "        }\n"                        + "        return editorComponent;\n"                        + "      }\n"                        + "    });\n"                        + "    JPanel p = new JPanel();\n"                        + "    p.add(comboBox);\n"                        + "    return p;\n"                        + "  }\n"                        + "}");    }    @Test    void testUnicodeEscapes() {        // todo i'd like to test the coordinates of the literals, but this has to wait for java-grammar to be merged        java8.parse("public class Foo { String[] s = { \"Ven\\u00E4j\\u00E4\" }; }");    }    @Test    void testUnicodeEscapes2() {        java.parse("\n"                       + "public final class TimeZoneNames_zh_TW extends TimeZoneNamesBundle {\n"                       + "\n"                       + "        String ACT[] = new String[] {\"Acre \\u6642\\u9593\", \"ACT\",\n"                       + "                                     \"Acre \\u590f\\u4ee4\\u6642\\u9593\", \"ACST\",\n"                       + "                                     \"Acre \\u6642\\u9593\", \"ACT\"};"                       + "}");    }    @Test    void testUnicodeEscapesInComment() {        java.parse("class Foo {"                       + "\n"                       + "    /**\n"                       + "     * The constant value of this field is the smallest value of type\n"                       + "     * {@code char}, {@code '\\u005Cu0000'}.\n"                       + "     *\n"                       + "     * @since   1.0.2\n"                       + "     */\n"                       + "    public static final char MIN_VALUE = '\\u0000';\n"                       + "\n"                       + "    /**\n"                       + "     * The constant value of this field is the largest value of type\n"                       + "     * {@code char}, {@code '\\u005C\\uFFFF'}.\n"                       + "     *\n"                       + "     * @since   1.0.2\n"                       + "     */\n"                       + "    public static final char MAX_VALUE = '\\uFFFF';"                       + "}");    }    @Test    final void testGetFirstASTNameImageNull() {        java4.parse("public class Test {\n"            + "  void bar() {\n"            + "   abstract class X { public abstract void f(); }\n"            + "   class Y extends X { public void f() { new Y().f(); } }\n"            + "  }\n"            + "}");    }    @Test    void testCastLookaheadProblem() {        java4.parse("public class BadClass {\n  public Class foo() {\n    return (byte[].class);\n  }\n}");    }    @Test    void testTryWithResourcesConcise() {        // https://github.com/pmd/pmd/issues/3697        java9.parse("import java.io.InputStream;\n"                        + "public class Foo {\n"                        + "    public InputStream in;\n"                        + "    public void bar() {\n"                        + "        Foo f = this;\n"                        + "        try (f.in) {\n"                        + "        }\n"                        + "    }\n"                        + "}");    }    @Test    void testTryWithResourcesThis() {        // https://github.com/pmd/pmd/issues/3697        java9.parse("import java.io.InputStream;\n"                        + "public class Foo {\n"                        + "    public InputStream in;\n"                        + "    public void bar() {\n"                        + "        try (this.in) {\n"                        + "        }\n"                        + "    }\n"                        + "}");    }    /**     * Tests a specific generic notation for calling methods. See:     * https://jira.codehaus.org/browse/MPMD-139     */    @Test    void testGenericsProblem() {        String code = "public class Test {\n"            + " public void test() {\n"            + "   String o = super.<String> doStuff(\"\");\n"            + " }\n"            + "}";        java5.parse(code);        java7.parse(code);    }    @Test    void testUnicodeIndent() {        // https://github.com/pmd/pmd/issues/3423        java7.parseResource("UnicodeIdentifier.java");    }    @Test    void testParsersCases15() {        doTest("ParserCornerCases", java5);    }    @Test    void testParsersCases17() {        doTest("ParserCornerCases17", java7);    }    @Test    void testParsersCases18() {        doTest("ParserCornerCases18", java8);    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1333/     */    @Test    void testLambdaBug1333() {        doTest("LambdaBug1333", java8);    }    @Test    void testLambdaBug1470() {        doTest("LambdaBug1470", java8);    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1355/     */    @Test    void emptyFileJustComment() {        getParser().parse("// just a comment");    }    @Test    void testBug1429ParseError() {        doTest("Bug1429", java8);    }    @Test    void testBug1530ParseError() {        doTest("Bug1530", java8);    }    @Test    void testGitHubBug207() {        doTest("GitHubBug207", java8);    }    @Test    void testLambda2783() {        java8.parseResource("LambdaBug2783.java");    }    @Test    void testGitHubBug2767() {        // PMD fails to parse an initializer block.        // PMD 6.26.0 parses this code just fine.        java.withDefaultVersion("16")            .parse("class Foo {\n"                       + "    {final int I;}\n"                       + "}\n");    }    @Test    void testBug206() {        doTest("LambdaBug206", java8);    }    @Test    void testGitHubBug208ParseError() {        doTest("GitHubBug208", java5);    }    @Test    void testGitHubBug309() {        doTest("GitHubBug309", java8);    }    @Test    @Timeout(value = 30, unit = TimeUnit.SECONDS)    void testInfiniteLoopInLookahead() {        assertThrows(ParseException.class, () ->            // https://github.com/pmd/pmd/issues/3117            java8.parseResource("InfiniteLoopInLookahead.java"));    }    @Test    void stringConcatentationShouldNotBeCast() {        // https://github.com/pmd/pmd/issues/1484        String code = "public class Test {\n" + "    public static void main(String[] args) {\n"            + "        System.out.println(\"X\" + (args) + \"Y\");\n" + "    }\n" + "}";        assertEquals(0, java8.parse(code).descendants(ASTCastExpression.class).count());    }    /**     * Empty statements should be allowed.     *     * @see <a href="https://github.com/pmd/pmd/issues/378">github issue 378</a>     */    @Test    void testEmptyStatements1() {        doTest("EmptyStmts1");    }    @Test    void testEmptyStatements2() {        doTest("EmptyStmts2");    }    @Test    void testEmptyStatements3() {        doTest("EmptyStmts3");    }    @Test    void testMethodReferenceConfused() {        ASTCompilationUnit ast = java.parseResource("MethodReferenceConfused.java", "10");        ASTVariableDeclaratorId varWithMethodName = AstTestUtil.varId(ast, "method");        ASTVariableDeclaratorId someObject = AstTestUtil.varId(ast, "someObject");        assertThat(varWithMethodName.getLocalUsages(), empty());        assertThat(someObject.getLocalUsages(), hasSize(1));        ASTNamedReferenceExpr usage = someObject.getLocalUsages().get(0);        assertThat(usage.getParent(), instanceOf(ASTCastExpression.class));    }    @Test    void testSwitchWithFallthrough() {        doTest("SwitchWithFallthrough");    }    @Test    void testSwitchStatements() {        doTest("SwitchStatements");    }    @Test    void testSynchronizedStatements() {        doTest("SynchronizedStmts");    }    @Test    void testGithubBug3101UnresolvedTypeParams() {        java.parseResource("GitHubBug3101.java");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class ASTSwitchStatementTest extends BaseParserTest {    @Test    void exhaustiveEnumSwitchWithDefault() {        ASTSwitchStatement switchStatement = java.parse(                "import java.nio.file.AccessMode; class Foo { void bar(AccessMode m) {"                + "switch (m) { case READ: break; default: break; } } }")                .descendants(ASTSwitchStatement.class).firstOrThrow();        assertFalse(switchStatement.isExhaustiveEnumSwitch()); // this should not throw a NPE...        assertTrue(switchStatement.hasDefaultCase());        assertTrue(switchStatement.isFallthroughSwitch());    }    @Test    void defaultCaseWithArrowBlock() {        ASTSwitchStatement switchStatement =            java.parse("class Foo { void bar(int x) {switch (x) { default -> { } } } }")                .descendants(ASTSwitchStatement.class).firstOrThrow();        assertFalse(switchStatement.isExhaustiveEnumSwitch());        assertTrue(switchStatement.iterator().hasNext());        assertTrue(switchStatement.hasDefaultCase());        assertFalse(switchStatement.isFallthroughSwitch());    }    @Test    void emptySwitch() {        ASTSwitchStatement switchStatement =            java.parse("class Foo { void bar(int x) {switch (x) { } } }")                .descendants(ASTSwitchStatement.class).firstOrThrow();        assertFalse(switchStatement.isExhaustiveEnumSwitch());        assertFalse(switchStatement.iterator().hasNext());        assertFalse(switchStatement.hasDefaultCase());        assertFalse(switchStatement.isFallthroughSwitch());    }    @Test    void defaultCaseWithArrowExprs() {        ASTSwitchStatement switchStatement =            java.parse(                    "import net.sourceforge.pmd.lang.java.rule.bestpractices.switchstmtsshouldhavedefault.SimpleEnum;\n"                        + "\n"                        + "            public class Foo {\n"                        + "                void bar(SimpleEnum x) {\n"                        + "                    switch (x) {\n"                        + "                    case FOO -> System.out.println(\"it is on\");\n"                        + "                    case BAR -> System.out.println(\"it is off\");\n"                        + "                    default -> System.out.println(\"it is neither on nor off - should not happen? maybe null?\");\n"                        + "                    }\n"                        + "                }\n"                        + "            }")                .descendants(ASTSwitchStatement.class).firstOrThrow();        assertFalse(switchStatement.isExhaustiveEnumSwitch());        assertTrue(switchStatement.iterator().hasNext());        assertFalse(switchStatement.isFallthroughSwitch());        assertTrue(switchStatement.hasDefaultCase());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class ASTInitializerTest extends BaseParserTest {    @Test    void testDontCrashOnBlockStatement() {        java.parse("public class Foo { { x = 5; } }");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.instanceOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class CommentAssignmentTest extends BaseParserTest {    /**     * Blank lines in comments should not raise an exception. See bug #1048.     */    @Test    void testFilteredCommentIn() {        ASTCompilationUnit node = java.parse("public class Foo {\n"                                                 + "     /* multi line comment with blank lines\n\n\n */\n"                                                 + "        /** a formal comment with blank lines\n\n\n */"                                                 + "}");        Comment comment = node.getComments().get(0);        assertThat(comment, instanceOf(MultiLineComment.class));        assertEquals("multi line comment with blank lines", comment.getFilteredComment());        comment = node.getComments().get(1);        assertThat(comment, instanceOf(FormalComment.class));        assertEquals("a formal comment with blank lines", comment.getFilteredComment());    }    @Test    void testCommentAssignments() {        ASTCompilationUnit node = java.parse("public class Foo {\n"                                                 + "     /** Comment 1 */\n"                                                 + "        public void method1() {}\n"                                                 + "    \n"                                                 + "        /** Comment 2 */\n"                                                 + "    \n"                                                 + "        /** Comment 3 */\n"                                                 + "        public void method2() {}" + "}");        List<ASTMethodDeclaration> methods = node.findDescendantsOfType(ASTMethodDeclaration.class);        assertCommentEquals(methods.get(0), "/** Comment 1 */");        assertCommentEquals(methods.get(1), "/** Comment 3 */");    }    @Test    void testCommentAssignmentsWithAnnotation() {        ASTCompilationUnit node = java.parse("public class Foo {\n"                                                 + "     /** Comment 1 */\n"                                                 + "        @Oha public void method1() {}\n"                                                 + "    \n"                                                 + "        /** Comment 2 */\n"                                                 + "    @Oha\n"                                                 // note that since this is the first token, the prev comment gets selected                                                 + "        /** Comment 3 */\n"                                                 + "        public void method2() {}" + "}");        List<ASTMethodDeclaration> methods = node.descendants(ASTMethodDeclaration.class).toList();        assertCommentEquals(methods.get(0), "/** Comment 1 */");        assertCommentEquals(methods.get(1), "/** Comment 2 */");    }    @Test    void testCommentAssignmentOnPackage() {        ASTCompilationUnit node = java.parse("/** Comment 1 */\n"                                                 + "package bar;\n");        assertCommentEquals(node.descendants(ASTPackageDeclaration.class).firstOrThrow(),                            "/** Comment 1 */");    }    @Test    void testCommentAssignmentOnClass() {        ASTCompilationUnit node = java.parse("/** outer */\n"                                                 + "class Foo { "                                                 + " /** inner */ class Nested { } "                                                 + " { /** local */ class Local {}} "                                                 + " /** enum */enum NestedEnum {}"                                                 + "}");        List<ASTAnyTypeDeclaration> types = node.descendants(ASTAnyTypeDeclaration.class).crossFindBoundaries().toList();        assertCommentEquals(types.get(0), "/** outer */");        assertCommentEquals(types.get(1), "/** inner */");        assertCommentEquals(types.get(2), "/** local */");        assertCommentEquals(types.get(3), "/** enum */");    }    @Test    void testCommentAssignmentOnEnum() {        ASTCompilationUnit node = java.parse("enum Foo { "                                                 + " /** A */ A,"                                                 + " /** B */ @Oha B,"                                                 + " C,"                                                 + " /* not javadoc */ D,"                                                 + "}");        List<ASTEnumConstant> constants = node.descendants(ASTEnumConstant.class).toList();        assertCommentEquals(constants.get(0), "/** A */");        assertCommentEquals(constants.get(1), "/** B */");        assertHasNoComment(constants.get(2));        assertHasNoComment(constants.get(3));    }    private void assertCommentEquals(JavadocCommentOwner pack, String expected) {        assertNotNull(pack.getJavadocComment(), "null comment on " + pack);        assertEquals(expected, pack.getJavadocComment().getText().toString());    }    private void assertHasNoComment(JavadocCommentOwner pack) {        assertNull(pack.getJavadocComment(), "Expected null comment on " + pack);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class Java8Test {    private final JavaParsingHelper java8 =            JavaParsingHelper.DEFAULT.withDefaultVersion("8")                                     .withResourceContext(Java8Test.class);    @Test    void interfaceMethodShouldBeParseable() {        java8.parse("interface WithStaticAndDefaultMethod {\n"                        + "        static void performOn() {\n"                        + "        }\n"                        + "\n"                        + "        default void myToString() {\n"                        + "        }\n"                        + "    }\n");    }    @Test    void repeatableAnnotationsMethodShouldBeParseable() {        java8.parse("@Multitude(\"1\")\n"                        + "@Multitude(\"2\")\n"                        + "@Multitude(\"3\")\n"                        + "@Multitude(\"4\")\n"                        + "public class UsesRepeatableAnnotations {\n"                        + "\n"                        + "    @Repeatable(Multitudes.class)\n"                        + "    @Retention(RetentionPolicy.RUNTIME)\n"                        + "    @interface Multitude {\n"                        + "        String value();\n"                        + "    }\n"                        + "\n"                        + "    @Retention(RetentionPolicy.RUNTIME)\n"                        + "    @interface Multitudes {\n"                        + "        Multitude[] value();\n"                        + "    }\n"                        + "\n"                        + "}");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class ASTPackageDeclarationTest extends BaseParserTest {    private static final String PACKAGE_INFO_ANNOTATED = "@Deprecated\npackage net.sourceforge.pmd.foobar;\n";    /**     * Regression test for bug 3524607.     */    @Test    void testPackageName() {        ASTCompilationUnit nodes = java.parse(PACKAGE_INFO_ANNOTATED);        assertEquals("net.sourceforge.pmd.foobar", nodes.getPackageDeclaration().getName());        assertEquals("net.sourceforge.pmd.foobar", nodes.getPackageName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class EncodingTest extends BaseParserTest {    @Test    void testDecodingOfUTF8() {        ASTCompilationUnit acu = java.parse("class Foo { void é() {} }");        String methodName = acu.descendants(ASTMethodDeclaration.class).firstOrThrow().getName();        assertEquals("é", methodName);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.FileInputStream;import java.util.ArrayList;import java.util.List;import java.util.stream.Stream;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.types.JClassType;import net.sourceforge.pmd.lang.java.types.TypeSystem;import net.sourceforge.pmd.lang.java.types.TypeTestUtil;class Java10Test {    private final JavaParsingHelper java10 =        JavaParsingHelper.DEFAULT.withDefaultVersion("10")                                 .withResourceContext(Java10Test.class, "jdkversiontests/java10/");    private final JavaParsingHelper java9 = java10.withDefaultVersion("9");    @Test    void testLocalVarInferenceBeforeJava10() {        // note, it can be parsed, but we'll have a ReferenceType of "var"        List<ASTLocalVariableDeclaration> localVars = java9.parseResource("LocalVariableTypeInference.java")                                                           .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        ASTVariableDeclaratorId varId = localVars.get(0).getVarIds().firstOrThrow();        // first: var list = new ArrayList<String>();        assertTrue(varId.getTypeNode() instanceof ASTClassOrInterfaceType);        // in that case, we don't have a class named "var", so the type will be null        assertTrue(varId.getTypeMirror().getSymbol().isUnresolved());        // check the type of the variable initializer's expression        ASTExpression initExpression = varId.getInitializer();        assertTrue(TypeTestUtil.isA(ArrayList.class, initExpression), "type should be ArrayList");    }    @Test    void testLocalVarInferenceCanBeParsedJava10() {        ASTCompilationUnit compilationUnit = java10.parseResource("LocalVariableTypeInference.java");        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        TypeSystem ts = compilationUnit.getTypeSystem();        JClassType stringT = (JClassType) ts.typeOf(ts.getClassSymbol(String.class), false);        // first: var list = new ArrayList<String>();        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();        assertEquals(ts.parameterise(ts.getClassSymbol(ArrayList.class), listOf(stringT)), varDecl.getTypeMirror(), "type should be ArrayList<String>");        // second: var stream = list.stream();        assertNull(localVars.get(1).getTypeNode());        ASTVariableDeclaratorId varDecl2 = localVars.get(1).getVarIds().firstOrThrow();        assertEquals(ts.parameterise(ts.getClassSymbol(Stream.class), listOf(stringT)),                varDecl2.getTypeMirror(),                "type should be Stream<String>");        // third: var s = "Java 10";        assertNull(localVars.get(2).getTypeNode());        ASTVariableDeclaratorId varDecl3 = localVars.get(2).getVarIds().firstOrThrow();        assertEquals(stringT, varDecl3.getTypeMirror(), "type should be String");    }    @Test    void testForLoopWithVar() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoop.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();        assertSame(varDecl.getTypeSystem().INT, varDecl.getTypeMirror(), "type should be int");    }    @Test    void testForLoopEnhancedWithVar() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoopEnhanced.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();        assertTrue(TypeTestUtil.isA(String.class, varDecl), "type should be String");    }    @Test    void testForLoopEnhancedWithVar2() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoopEnhanced2.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(4, localVars.size());        assertNull(localVars.get(1).getTypeNode());        @NonNull ASTVariableDeclaratorId varDecl2 = localVars.get(1).getVarIds().firstOrThrow();        assertTrue(TypeTestUtil.isA(String.class, varDecl2), "type should be String");        assertNull(localVars.get(3).getTypeNode());        ASTVariableDeclaratorId varDecl4 = localVars.get(3).getVarIds().firstOrThrow();        assertSame(varDecl2.getTypeSystem().INT, varDecl4.getTypeMirror(), "type should be int");    }    @Test    void testTryWithResourcesWithVar() {        List<ASTResource> resources = java10.parseResource("LocalVariableTypeInferenceTryWithResources.java")                                            .findDescendantsOfType(ASTResource.class);        assertEquals(1, resources.size());        assertNull(resources.get(0).asLocalVariableDeclaration().getTypeNode());        ASTVariableDeclaratorId varId = resources.get(0).asLocalVariableDeclaration().getVarIds().firstOrThrow();        assertTrue(TypeTestUtil.isA(FileInputStream.class, varId), "type should be FileInputStream");    }    @Test    void testTypeResNullPointer() {        java10.parseResource("LocalVariableTypeInference_typeres.java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.apache.commons.lang3.StringUtils;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.BaseParserTest;class CommentTest extends BaseParserTest {    @Test    void testMultiLinesInSingleLine() {        String comment = "/* single line. */";        String filtered = filter(comment);        assertEquals(1, lineCount(filtered));        assertEquals("single line.", filtered);    }    @Test    void testMultiLinesInSingleLineSimple() {        String comment = "// single line.";        String filtered = filter(comment);        assertEquals(1, lineCount(filtered));        assertEquals("single line.", filtered);    }    @Test    void testMultiLinesInSingleLineFormal() {        String comment = "/** single line. */";        String filtered = filter(comment);        assertEquals(1, lineCount(filtered));        assertEquals("single line.", filtered);    }    @Test    void testMultiLinesInMultiLine() {        String comment =                  "/*\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        assertEquals(2, lineCount(filtered));        assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    void testMultiLinesInMultiLineCrLf() {        String comment =                  "/*\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        assertEquals(2, lineCount(filtered));        assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    void testMultiLinesInMultiLineFormal() {        String comment =                  "/**\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        assertEquals(2, lineCount(filtered));        assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    void testMultiLinesInMultiLineFormalCrLf() {        String comment =                  "/**\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        assertEquals(2, lineCount(filtered));        assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    void testMultiLinesInMultiLineNoAsteriskEmpty() {        String comment =                  "/**\n"                + " * line 1\n"                + "line 2\n"                + "\n"                + " */\n";        String filtered = filter(comment);        assertEquals(2, lineCount(filtered));        assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    private String filter(String comment) {        return java.parse(comment).getComments().get(0).getFilteredComment();    }    private int lineCount(String filtered) {        return StringUtils.countMatches(filtered, PMD.EOL) + 1;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;class ASTBooleanLiteralTest extends BaseParserTest {    @Test    void testTrue() {        List<ASTBooleanLiteral> ops = java.getNodes(ASTBooleanLiteral.class, TEST1);        ASTBooleanLiteral b = ops.get(0);        assertTrue(b.isTrue());    }    @Test    void testFalse() {        List<ASTBooleanLiteral> ops = java.getNodes(ASTBooleanLiteral.class, TEST2);        ASTBooleanLiteral b = ops.get(0);        assertFalse(b.isTrue());    }    private static final String TEST1 = "class Foo { \n boolean bar = true; \n} ";    private static final String TEST2 = "class Foo { \n boolean bar = false; \n} ";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;import net.sourceforge.pmd.lang.java.BaseParserTest;class FormalCommentTest extends BaseParserTest {    @Test    void testJavadocTagsAsChildren() {        ASTCompilationUnit acu = java.parse(            "interface Metric {"                + "   /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "}");        ASTType booleanT = acu.descendants(ASTType.class).firstOrThrow();        JavaccToken firstToken = booleanT.getFirstToken();        assertEquals(JavaTokenKinds.BOOLEAN, firstToken.kind, "Boolean");        JavaccToken comment = firstToken.getPreviousComment();        assertEquals(JavaccToken.IMPLICIT_TOKEN, comment.kind, "Implicit modifier list");        comment = comment.getPreviousComment();        assertEquals(JavaTokenKinds.WHITESPACE, comment.kind, "Whitespace");        assertEquals("\n    ", comment.getImage());        comment = comment.getPreviousComment();        assertEquals(JavaTokenKinds.FORMAL_COMMENT, comment.kind, "Formal comment");        List<JavadocElement> javadocs = new FormalComment(comment).getChildren();        assertEquals(2, javadocs.size());        JavadocElement paramTag = javadocs.get(0);        assertEquals("param", paramTag.tag().label);        JavadocElement returnTag = javadocs.get(1);        assertEquals("return", returnTag.tag().label);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.platform.suite.api.SelectClasses;import org.junit.platform.suite.api.Suite;@Suite@SelectClasses({    ParserCornersTest.class,    Java14TreeDumpTest.class,    Java15TreeDumpTest.class,    Java16TreeDumpTest.class,    Java17TreeDumpTest.class,    Java18PreviewTreeDumpTest.class,    Java19PreviewTreeDumpTest.class})class AllJavaAstTreeDumpTest {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.BaseParserTest;class ASTSwitchLabelTest extends BaseParserTest {    private final JavaParsingHelper java = JavaParsingHelper.DEFAULT.withDefaultVersion("15-preview");    @Test    void testDefaultOff() {        List<ASTSwitchLabel> ops = java.getNodes(ASTSwitchLabel.class, "public class Foo {\n void bar() {\n  switch (x) {\n   case 1: y = 2;\n  }\n }\n}");        assertFalse(ops.get(0).isDefault());    }    @Test    void testDefaultSet() {        @NonNull ASTSwitchStatement switchStmt = java.parse(SWITCH_WITH_DEFAULT).descendants(ASTSwitchStatement.class).firstOrThrow();        assertTrue(switchStmt.hasDefaultCase());        assertFalse(switchStmt.isExhaustiveEnumSwitch());        assertTrue(switchStmt.getBranches().firstOrThrow().getLabel().isDefault());        assertFalse(switchStmt.getBranches().get(1).getLabel().isDefault());    }    @Test    void testExhaustiveEnum() {        @NonNull ASTSwitchStatement switchStmt = java.parse(EXHAUSTIVE_ENUM).descendants(ASTSwitchStatement.class).firstOrThrow();        assertFalse(switchStmt.hasDefaultCase());        assertTrue(switchStmt.isExhaustiveEnumSwitch());    }    @Test    void testNotExhaustiveEnum() {        @NonNull ASTSwitchStatement switchStmt = java.parse(NOT_EXHAUSTIVE_ENUM).descendants(ASTSwitchStatement.class).firstOrThrow();        assertFalse(switchStmt.hasDefaultCase());        assertFalse(switchStmt.isExhaustiveEnumSwitch());    }    @Test    void testEnumWithDefault() {        @NonNull ASTSwitchStatement switchStmt = java.parse(ENUM_SWITCH_WITH_DEFAULT).descendants(ASTSwitchStatement.class).firstOrThrow();        assertTrue(switchStmt.hasDefaultCase());        assertFalse(switchStmt.isExhaustiveEnumSwitch());    }    private static final String TEST1 = "public class Foo {\n" +        " void bar() {\n" +        "  switch (x) {\n" +        "   case 1: y = 2;\n" +        "  }\n" +        " }\n" +        "}";    private static final String SWITCH_WITH_DEFAULT =        "public class Foo {\n" +            " void bar() {\n" +            "  switch (x) {\n" +            "   default: y = 2;\n" +            "   case 4: break;\n" +            "  }\n" +            " }\n" +            "}";    private static final String EXHAUSTIVE_ENUM =        "public class Foo {\n" +            " void bar() {\n" +            "  enum LocalEnum { A, B, C } " +            "  var v = LocalEnum.A; " +            "  switch (v) {\n" +            "   case A: break;\n" +            "   case B: break;\n" +            "   case C: break;\n" +            "  }\n" +            " }\n" +            "}";    private static final String NOT_EXHAUSTIVE_ENUM =        "public class Foo {\n" +            " void bar() {\n" +            "  enum LocalEnum { A, B, C } " +            "  var v = LocalEnum.A; " +            "  switch (v) {\n" +            "   case A: break;\n" +            " //  case B: break;\n" +            "   case C: break;\n" +            "  }\n" +            " }\n" +            "}";    private static final String ENUM_SWITCH_WITH_DEFAULT =        "public class Foo {\n" +            " void bar() {\n" +            "  enum LocalEnum { A, B, C } " +            "  var v = LocalEnum.A; " +            "  switch (v) {\n" +            "   case A: break;\n" +            "   case C: break;\n" +            "   default: break;\n" +            "  }\n" +            " }\n" +            "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ast.ASTStringLiteral.determineTextBlockContent;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.document.Chars;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.util.StringUtil;class TextBlockEscapeTest extends BaseParserTest {    @Test    void testStringEscapes() {        testStringEscape("abcd", "abcd");        testStringEscape("abcd\\f", "abcd\f");        testStringEscape("abcd\\n", "abcd\n");        testStringEscape("abcd\\t", "abcd\t");        testStringEscape("abcd\\bx", "abcd\bx");        testStringEscape("abcd\\'x", "abcd\'x");        // note that this one is actually invalid syntax        testStringEscape("abcd\\", "abcd\\");        testStringEscape("abcd\\\\", "abcd\\");    }    @Test    void testStringOctalEscapes() {        testStringEscape("\\0123", "\0123");        testStringEscape("\\01ab", "\01ab");        testStringEscape("\\0", "\0");    }    @Test    void testStringUnknownEscape() {        testStringEscape("\\x", "\\x");    }    // note the argument order    private void testStringEscape(String actual, String expected) {        actual = StringUtil.inDoubleQuotes(actual);        assertEquals(expected,                     ASTStringLiteral.determineStringContent(Chars.wrap(actual)));    }    @Test    void testTextBlockContent() {        assertEquals("winter", determineTextBlockContent("\"\"\"\n                winter\"\"\""),                "single line text block");        assertEquals("winter\n", determineTextBlockContent("\"\"\"\n"                                                   + "   winter\n"                                                   + "   \"\"\""),                "single line text block with LF");        assertEquals(" winter\n", determineTextBlockContent("\"\"\"\n"                                                   + "   winter\n"                                                   + "  \"\"\""),                "single line text block with LF, some indent preserved");    }    @Test    void emptyTextBlock() {        assertEquals("",                     determineTextBlockContent("\"\"\"\n                       \"\"\""),                "empty text block");    }    @Test    void testEscapeBlockDelimiter() {        assertEquals("String text = \"\"\"\n"                         + "    A text block inside a text block\n"                         + "\"\"\";\n",                     determineTextBlockContent("\"\"\"\n"                                                   + "  String text = \\\"\"\"\n"                                                   + "      A text block inside a text block\n"                                                   + "  \\\"\"\";\n"                                                   + "  \"\"\""),                "escaped text block in inside text block");    }    @Test    void testCrEscape() {        assertEquals("<html>\r\n"                         + "    <body>\r\n"                         + "        <p>Hello, world</p>\r\n"                         + "    </body>\r\n"                         + "</html>\r\n",                     determineTextBlockContent("\"\"\"\n"                                                   + "                      <html>\\r\n"                                                   + "                          <body>\\r\n"                                                   + "                              <p>Hello, world</p>\\r\n"                                                   + "                          </body>\\r\n"                                                   + "                      </html>\\r\n"                                                   + "                      \"\"\""),                "text block with escapes");    }    @Test    void testBasicHtmlBlock() {        assertEquals("<html>\n"                         + "    <body>\n"                         + "        <p>Hello, world</p>\n"                         + "    </body>\n"                         + "</html>\n",                     determineTextBlockContent("\"\"\"\n"                                                   + "                      <html>   \n"                                                   + "                          <body>\n"                                                   + "                              <p>Hello, world</p>    \n"                                                   + "                          </body> \n"                                                   + "                      </html>   \n"                                                   + "                      \"\"\""),                "basic text block example with html");    }    @Test    void testLineContinuation() {        assertEquals("Lorem ipsum dolor sit amet, consectetur adipiscing "                         + "elit, sed do eiusmod tempor incididunt ut labore "                         + "et dolore magna aliqua.",                     determineTextBlockContent("\"\"\"\n"                                                   + "  Lorem ipsum dolor sit amet, consectetur adipiscing \\\n"                                                   + "  elit, sed do eiusmod tempor incididunt ut labore \\\n"                                                   + "  et dolore magna aliqua.\\\n"                                                   + "  \"\"\""),                "new escape: line continuation");    }    @Test    void testEscapeSpace() {        assertEquals("red   \n"                         + "green \n"                         + "blue  \n",                     determineTextBlockContent("\"\"\"\n"                                                   + "                        red  \\s\n"                                                   + "                        green\\s\n"                                                   + "                        blue \\s\n"                                                   + "                        \"\"\""),                "new escape: space escape");    }    @Test    void testLineEndingNormalization() {        assertEquals("<html>\n"                         + "    <body>\n"                         + "        <p>Hello, world</p>\n"                         + "    </body>\n"                         + "</html>\n",                     determineTextBlockContent("\"\"\"\r\n"                                                   + "                      <html>   \r\n"                                                   + "                          <body>\r\n"                                                   + "                              <p>Hello, world</p>    \r\n"                                                   + "                          </body> \r\n"                                                   + "                      </html>   \r\n"                                                   + "                      \"\"\""),                "with crlf line endings");        assertEquals("<html>\n"                         + "    <body>\n"                         + "        <p>Hello, world</p>\n"                         + "    </body>\n"                         + "</html>\n",                     determineTextBlockContent("\"\"\"\r"                                                   + "                      <html>   \r"                                                   + "                          <body>\r"                                                   + "                              <p>Hello, world</p>    \r"                                                   + "                          </body> \r"                                                   + "                      </html>   \r"                                                   + "                      \"\"\""),                "with cr line endings");    }    @Test    void testEmptyLines() {        assertEquals("\ntest\n", determineTextBlockContent("\"\"\"\n"                                                               + "    \n"                                                               + "    test\n"                                                               + "    \"\"\""),                "empty line directly after opening");        assertEquals("\ntest\n", determineTextBlockContent("\"\"\"\r\n"                                                               + "    \r\n"                                                               + "    test\r\n"                                                               + "    \"\"\""),                "empty crlf line directly after opening");        assertEquals("\ntest\n", determineTextBlockContent("\"\"\"\n"                                                               + "\n"                                                               + "test\n"                                                               + "\"\"\""),                "empty line directly after opening without indentation");        assertEquals("\ntest\n", determineTextBlockContent("\"\"\"\r\n"                                                               + "\r\n"                                                               + "test\r\n"                                                               + "\"\"\""),                "empty crlf line directly after opening without indentation");    }    @Test    void testTextBlockWithBackslashEscape() {        assertEquals("\\test\n",                     determineTextBlockContent("\"\"\"\n                \\\\test\n                \"\"\""),                "text block with backslash escape");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class Java15TreeDumpTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java15 =            JavaParsingHelper.DEFAULT.withDefaultVersion("15")                                     .withResourceContext(Java15TreeDumpTest.class, "jdkversiontests/java15/");    private final JavaParsingHelper java14 = java15.withDefaultVersion("14");    @Override    public BaseParsingHelper<?, ?> getParser() {        return java15;    }    @Test    void textBlocks() {        doTest("TextBlocks");    }    @Test    void textBlocksBeforeJava15ShouldFail() {        assertThrows(ParseException.class, () -> java14.parseResource("TextBlocks.java"));    }    @Test    void stringEscapeSequenceShouldFail() {        assertThrows(ParseException.class, () -> java14.parse("class Foo { String s =\"a\\sb\"; }"));    }    @Test    void sealedAndNonSealedIdentifiers() {        doTest("NonSealedIdentifier");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class JDKVersionTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java3 = JavaParsingHelper.DEFAULT        .withDefaultVersion("1.3")        .withResourceContext(JDKVersionTest.class, "jdkversiontests/");    private final JavaParsingHelper java4 = java3.withDefaultVersion("1.4");    private final JavaParsingHelper java5 = java3.withDefaultVersion("1.5");    private final JavaParsingHelper java7 = java3.withDefaultVersion("1.7");    private final JavaParsingHelper java8 = java3.withDefaultVersion("1.8");    private final JavaParsingHelper java9 = java3.withDefaultVersion("9");    // enum keyword/identifier    @Test    public void testEnumAsKeywordShouldFailWith14() {        assertThrows(ParseException.class, () -> java5.parseResource("jdk14_enum.java"));    }    @Test    void testEnumAsIdentifierShouldPassWith14() {        java4.parseResource("jdk14_enum.java");    }    @Test    void testEnumAsKeywordShouldPassWith15() {        java5.parseResource("jdk15_enum.java");    }    @Test    void testEnumAsIdentifierShouldFailWith15() {        assertThrows(ParseException.class, () -> java5.parseResource("jdk14_enum.java"));    }    // enum keyword/identifier    // assert keyword/identifier    @Test    void testAssertAsKeywordVariantsSucceedWith14() {        java4.parseResource("assert_test1.java");        java4.parseResource("assert_test2.java");        java4.parseResource("assert_test3.java");        java4.parseResource("assert_test4.java");    }    @Test    void testAssertAsVariableDeclIdentifierFailsWith14() {        assertThrows(ParseException.class, () -> java4.parseResource("assert_test5.java"));    }    @Test    void testAssertAsMethodNameIdentifierFailsWith14() {        assertThrows(ParseException.class, () -> java4.parseResource("assert_test7.java"));    }    @Test    void testAssertAsIdentifierSucceedsWith13() {        java3.parseResource("assert_test5.java");    }    @Test    void testAssertAsKeywordFailsWith13() {        assertThrows(ParseException.class, () -> java3.parseResource("assert_test6.java"));    }    // assert keyword/identifier    @Test    void testVarargsShouldPassWith15() {        java5.parseResource("jdk15_varargs.java");    }    @Test    public void testGenericCtorCalls() {        java5.parseResource("java5/generic_ctors.java");    }    @Test    public void testGenericSuperCtorCalls() {        java5.parseResource("java5/generic_super_ctor.java");    }    @Test    public void testAnnotArrayInitializer() {        java5.parseResource("java5/annotation_array_init.java");    }    @Test    void testVarargsShouldFailWith14() {        assertThrows(ParseException.class, () -> java4.parseResource("jdk15_varargs.java"));    }    @Test    void testJDK15ForLoopSyntaxShouldPassWith15() {        java5.parseResource("jdk15_forloop.java");    }    @Test    void testJDK15ForLoopSyntaxWithModifiers() {        java5.parseResource("jdk15_forloop_with_modifier.java");    }    @Test    void testJDK15ForLoopShouldFailWith14() {        assertThrows(ParseException.class, () -> java4.parseResource("jdk15_forloop.java"));    }    @Test    void testJDK15GenericsSyntaxShouldPassWith15() {        java5.parseResource("jdk15_generics.java");    }    @Test    void testVariousParserBugs() {        java5.parseResource("fields_bug.java");        java5.parseResource("gt_bug.java");        java5.parseResource("annotations_bug.java");        java5.parseResource("constant_field_in_annotation_bug.java");        java5.parseResource("generic_in_field.java");    }    @Test    void testNestedClassInMethodBug() {        java5.parseResource("inner_bug.java");        java5.parseResource("inner_bug2.java");    }    @Test    void testGenericsInMethodCall() {        java5.parseResource("generic_in_method_call.java");    }    @Test    void testGenericINAnnotation() {        java5.parseResource("generic_in_annotation.java");    }    @Test    void testGenericReturnType() {        java5.parseResource("generic_return_type.java");    }    @Test    void testMultipleGenerics() {        // See java/lang/concurrent/CopyOnWriteArraySet        java5.parseResource("funky_generics.java");        // See java/lang/concurrent/ConcurrentHashMap        java5.parseResource("multiple_generics.java");    }    @Test    void testAnnotatedParams() {        java5.parseResource("annotated_params.java");    }    @Test    void testAnnotatedLocals() {        java5.parseResource("annotated_locals.java");    }    @Test    void testAssertAsIdentifierSucceedsWith13Test2() {        java3.parseResource("assert_test5_a.java");    }    @Test    void testBinaryAndUnderscoresInNumericalLiterals() {        java7.parseResource("jdk17_numerical_literals.java");    }    @Test    void testStringInSwitch() {        java7.parseResource("jdk17_string_in_switch.java");    }    @Test    void testGenericDiamond() {        java7.parseResource("jdk17_generic_diamond.java");    }    @Test    void testTryWithResources() {        java7.parseResource("jdk17_try_with_resources.java");    }    @Test    void testTryWithResourcesSemi() {        java7.parseResource("jdk17_try_with_resources_semi.java");    }    @Test    void testTryWithResourcesMulti() {        java7.parseResource("jdk17_try_with_resources_multi.java");    }    @Test    void testTryWithResourcesWithAnnotations() {        java7.parseResource("jdk17_try_with_resources_with_annotations.java");    }    @Test    void testMulticatch() {        java7.parseResource("jdk17_multicatch.java");    }    @Test    void testMulticatchWithAnnotations() {        java7.parseResource("jdk17_multicatch_with_annotations.java");    }    @Test    void jdk9PrivateInterfaceMethodsInJava18() {        assertThrows(ParseException.class, () -> java8.parseResource("java9/jdk9_private_interface_methods.java"));    }    @Test    void testPrivateMethods() {        java8.parse("public class Foo { private void bar() { } }");    }    @Test    public final void testTypeAnnotations() {        java8.parseResource("java8/type_annotations.java");    }    @Test    void testNestedPrivateMethods() {        java8.parse("public interface Baz { public static class Foo { private void bar() { } } }");    }    @Test    void jdk9PrivateInterfaceMethods() {        java9.parseResource("java9/jdk9_private_interface_methods.java");    }    @Test    void jdk9InvalidIdentifierInJava18() {        java8.parseResource("java9/jdk9_invalid_identifier.java");    }    @Test    void jdk9InvalidIdentifier() {        assertThrows(ParseException.class, () -> java9.parseResource("java9/jdk9_invalid_identifier.java"));    }    @Test    void jdk9AnonymousDiamondInJava8() {        assertThrows(ParseException.class, () -> java8.parseResource("java9/jdk9_anonymous_diamond.java"));    }    @Test    void jdk9AnonymousDiamond() {        java9.parseResource("java9/jdk9_anonymous_diamond.java");    }    @Test    void jdk9ModuleInfoInJava8() {        assertThrows(ParseException.class, () -> java8.parseResource("java9/jdk9_module_info.java"));    }    @Test    void jdk9ModuleInfo() {        java9.parseResource("java9/jdk9_module_info.java");    }    @Test    void testAnnotatedModule() {        java9.parseResource("java9/jdk9_module_info_with_annot.java");    }    @Test    void jdk9TryWithResourcesInJava8() {        assertThrows(ParseException.class, () -> java8.parseResource("java9/jdk9_try_with_resources.java"));    }    @Test    void jdk9TryWithResources() {        java9.parseResource("java9/jdk9_try_with_resources.java");    }    @Test    void jdk7PrivateMethodInnerClassInterface1() {        ASTCompilationUnit acu = java7.parseResource("private_method_in_inner_class_interface1.java");        List<ASTMethodDeclaration> methods = acu.findDescendantsOfType(ASTMethodDeclaration.class, true);        assertEquals(3, methods.size());        for (ASTMethodDeclaration method : methods) {            assertFalse(method.getEnclosingType().isInterface());        }    }    @Test    void jdk7PrivateMethodInnerClassInterface2() {        ParseException thrown = assertThrows(ParseException.class, () -> java7.parseResource("private_method_in_inner_class_interface2.java"));        assertTrue(thrown.getMessage().contains("line 19"));    }    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return java9;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * @author Clément Fournier */class JavaQualifiedNameTest {    private <T extends Node> List<T> getNodes(Class<T> target, String code) {        return JavaParsingHelper.DEFAULT.withDefaultVersion("15").getNodes(target, code);    }    @Test    void testEmptyPackage() {        final String TEST = "class Foo {}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            assertEquals("Foo", coid.getBinaryName());            assertEquals("", coid.getPackageName());        }    }    @Test    void testPackage() {        final String TEST = "package foo.bar; class Bzaz{}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            assertEquals("foo.bar.Bzaz", coid.getBinaryName());        }    }    @Test    void testNestedClass() {        final String TEST = "package foo.bar; class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            if ("Foo".equals(coid.getImage())) {                assertEquals("foo.bar.Bzaz$Bor$Foo", coid.getBinaryName());            }        }    }    @Test    void testNestedEnum() {        final String TEST = "package foo.bar; class Foo { enum Bzaz{HOO;}}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            assertEquals("foo.bar.Foo$Bzaz", coid.getBinaryName());            assertEquals("Bzaz", coid.getSimpleName());            assertEquals("foo.bar", coid.getPackageName());        }    }    @Test    void testEnum() {        final String TEST = "package foo.bar; enum Bzaz{HOO;}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            assertEquals("foo.bar.Bzaz", coid.getBinaryName());            assertEquals("Bzaz", coid.getSimpleName());            assertEquals("foo.bar", coid.getPackageName());        }    }    @Test    void testNestedEmptyPackage() {        final String TEST = "class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            if ("Foo".equals(coid.getSimpleName())) {                assertEquals("Bzaz$Bor$Foo", coid.getBinaryName());                assertEquals("", coid.getPackageName());            }        }    }    @Test    void testSimpleLocalClass() {        final String TEST = "package bar; class Boron { public void foo(String j) { class Local {} } }";        List<ASTClassOrInterfaceDeclaration> classes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertEquals("bar.Boron$1Local", classes.get(1).getBinaryName());    }    @Test    void testLocalClassNameClash() {        final String TEST = "package bar; class Bzaz{ void foo() { class Local {} } {// initializer\n class Local {}}}";        List<ASTClassOrInterfaceDeclaration> classes            = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertEquals("bar.Bzaz$1Local", classes.get(1).getBinaryName());        assertEquals("bar.Bzaz$2Local", classes.get(2).getBinaryName());    }    @Test    void testLocalClassDeepNesting() {        final String TEST            = "class Bzaz{ void foo() { "            + "  class Local { "            + "    class Nested {"            + "      {"            + "        class InnerLocal{}"            + "      }"            + "    }"            + "  }"            + "}}";        List<ASTClassOrInterfaceDeclaration> classes            = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertEquals("Bzaz$1Local", classes.get(1).getBinaryName());        assertEquals("Local", classes.get(1).getSimpleName());        assertTrue(classes.get(1).isLocal());        assertFalse(classes.get(1).isNested());        assertEquals("Bzaz$1Local$Nested", classes.get(2).getBinaryName());        assertFalse(classes.get(2).isLocal());        assertTrue(classes.get(2).isNested());        assertEquals("Bzaz$1Local$Nested$1InnerLocal", classes.get(3).getBinaryName());        assertTrue(classes.get(3).isLocal());        assertFalse(classes.get(3).isNested());    }    @Test    void testAnonymousClass() {        final String TEST            = "class Bzaz{ void foo() { "            + "  new Runnable() {"            + "      public void run() {}"            + "  };"            + "}}";        List<ASTAnonymousClassDeclaration> classes = getNodes(ASTAnonymousClassDeclaration.class, TEST);        assertEquals(("Bzaz$1"), classes.get(0).getBinaryName());        assertFalse(classes.get(0).isLocal());        assertTrue(classes.get(0).isAnonymous());        assertEquals("", classes.get(0).getSimpleName());    }    @Test    void testMultipleAnonymousClasses() {        final String TEST            = "class Bzaz{ void foo() { "            + "  new Runnable() {"            + "      public void run() {}"            + "  };"            + "  new Runnable() {"            + "      public void run() {}"            + "  };"            + "}}";        List<ASTAnonymousClassDeclaration> classes = getNodes(ASTAnonymousClassDeclaration.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals("Bzaz$1", classes.get(0).getBinaryName());        assertEquals("Bzaz$2", classes.get(1).getBinaryName());    }    @Test    void testNestedAnonymousClass() {        final String TEST            = "class Bzaz{ void foo() {"            + "  new Runnable() {"            + "    public void run() {"            + "      new Runnable() {"            + "        public void run() {}"            + "      };"            + "    }"            + "  };"            + "}}";        List<ASTAnonymousClassDeclaration> classes = getNodes(ASTAnonymousClassDeclaration.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals("Bzaz$1", classes.get(0).getBinaryName());        assertEquals("Bzaz$1$1", classes.get(1).getBinaryName());    }    @Test    void testLocalInAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() {"                + "  new Runnable() {"                + "    public void run() {"                + "      class FooRunnable {}"                + "    }"                + "  };"                + "}}";        List<ASTClassOrInterfaceDeclaration> classes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertTrue(classes.get(1).isLocal());        assertEquals("Bzaz$1$1FooRunnable", classes.get(1).getBinaryName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;class PMD5RulesetTest {    @Test    public void loadRuleset() {        RuleSet ruleset = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/lang/java/pmd5ruleset.xml");        assertNotNull(ruleset);        assertNull(ruleset.getRuleByName("GuardLogStatementJavaUtil"));        assertNull(ruleset.getRuleByName("GuardLogStatement"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;import com.github.stefanbirkner.systemlambda.SystemLambda;class QuickstartRulesetTest {    @Test    void noDeprecations() throws Exception {        RuleSetLoader ruleSetLoader = new RuleSetLoader().enableCompatibility(false);        String errorOutput = SystemLambda.tapSystemErr(() -> {            RuleSet quickstart = ruleSetLoader.loadFromResource("rulesets/java/quickstart.xml");            assertFalse(quickstart.getRules().isEmpty());        });        assertTrue(errorOutput.isEmpty());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;/** * Special tweak to remove deprecated attributes of AccessNode */public abstract class BaseJavaTreeDumpTest extends BaseTreeDumpTest {    protected BaseJavaTreeDumpTest() {        super(new JavaAttributesPrinter(), ".java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;class SuppressWarningsTest {    private final JavaParsingHelper java = JavaParsingHelper.DEFAULT;    private static class BarRule extends AbstractJavaRule {        @Override        public String getMessage() {            return "a message";        }        @Override        public Object visit(ASTCompilationUnit cu, Object ctx) {            // Convoluted rule to make sure the violation is reported for the            // ASTCompilationUnit node            for (ASTClassOrInterfaceDeclaration c : cu.descendants(ASTClassOrInterfaceDeclaration.class)) {                if ("bar".equalsIgnoreCase(c.getSimpleName())) {                    addViolation(ctx, cu);                }            }            return super.visit(cu, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    void testClassLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST1);        assertSize(rpt, 0);        rpt = java.executeRule(new FooRule(), TEST2);        assertSize(rpt, 0);    }    @Test    void testInheritedSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST3);        assertSize(rpt, 0);    }    @Test    void testMethodLevelSuppression() {        Report rpt;        rpt = java.executeRule(new FooRule(), TEST4);        assertSize(rpt, 1);    }    @Test    void testConstructorLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST5);        assertSize(rpt, 0);    }    @Test    void testFieldLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST6);        assertSize(rpt, 1);    }    @Test    void testParameterLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST7);        assertSize(rpt, 1);    }    @Test    void testLocalVariableLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST8);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST9);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppressionValue1() {        Report rpt = java.executeRule(new FooRule(), TEST9_VALUE1);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppressionValue2() {        Report rpt = java.executeRule(new FooRule(), TEST9_VALUE2);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppressionValue3() {        Report rpt = java.executeRule(new FooRule(), TEST9_VALUE3);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppressionMulitpleValues1() {        Report rpt = java.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES_1);        assertSize(rpt, 0);    }    @Test    void testSpecificSuppressionMulitpleValues2() {        Report rpt = java.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES_2);        assertSize(rpt, 0);    }    @Test    void testNoSuppressionBlank() {        Report rpt = java.executeRule(new FooRule(), TEST10);        assertSize(rpt, 2);    }    @Test    void testNoSuppressionSomethingElseS() {        Report rpt = java.executeRule(new FooRule(), TEST11);        assertSize(rpt, 2);    }    @Test    void testSuppressAll() {        Report rpt = java.executeRule(new FooRule(), TEST12);        assertSize(rpt, 0);    }    @Test    void testSpecificSuppressionAtTopLevel() {        Report rpt = java.executeRule(new BarRule(), TEST13);        assertSize(rpt, 0);    }    @Test    void testConstExpr() {        testAboutConstExpr(true, 0); // with the annotation, we should get no violation        testAboutConstExpr(false, 1); // without the annotation, we should get a violation    }    private void testAboutConstExpr(boolean hasAnnotation, int numExpectedViolations) {        Report rpt = java.executeRule(new FooRule(), constExprTest(hasAnnotation));        assertSize(rpt, numExpectedViolations);    }    private static final String TEST1 = "@SuppressWarnings(\"PMD\")\npublic class Foo {}";    private static final String TEST2 = "@SuppressWarnings(\"PMD\")\npublic class Foo {\n void bar() {\n  int foo;\n }\n}";    private static final String TEST3 = "public class Baz {\n @SuppressWarnings(\"PMD\")\n public class Bar {\n  void bar() {\n   int foo;\n  }\n }\n}";    private static final String TEST4 = "public class Foo {\n @SuppressWarnings(\"PMD\")\n void bar() {\n  int foo;\n }\n}";    private static final String TEST5 = "public class Bar {\n @SuppressWarnings(\"PMD\")\n public Bar() {\n  int foo;\n }\n}";    private static final String TEST6 = "public class Bar {\n @SuppressWarnings(\"PMD\")\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST7 = "public class Bar {\n int foo;\n void bar(@SuppressWarnings(\"PMD\") int foo) {}\n}";    private static final String TEST8 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"PMD\") int foo;\n }\n}";    private static final String TEST9 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"PMD.NoFoo\") int foo;\n }\n}";    private static final String TEST9_VALUE1 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(value = \"PMD.NoFoo\") int foo;\n }\n}";    private static final String TEST9_VALUE2 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings({\"PMD.NoFoo\"}) int foo;\n }\n}";    private static final String TEST9_VALUE3 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(value = {\"PMD.NoFoo\"}) int foo;\n }\n}";    private static final String TEST9_MULTIPLE_VALUES_1 = "@SuppressWarnings({\"PMD.NoFoo\", \"PMD.NoBar\"})\npublic class Bar {\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST9_MULTIPLE_VALUES_2 = "@SuppressWarnings(value = {\"PMD.NoFoo\", \"PMD.NoBar\"})\npublic class Bar {\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST10 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"\") int foo;\n }\n}";    private static final String TEST11 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"SomethingElse\") int foo;\n }\n}";    private static final String TEST12 = "public class Bar {\n @SuppressWarnings(\"all\") int foo;\n}";    private static final String TEST13 = "@SuppressWarnings(\"PMD.NoBar\")\npublic class Bar {\n}";    private static @NonNull String constExprTest(boolean withAnnot) {        return "public class NewClass {\n"            + "    private final static String SUPPRESS_PMD = \"PMD.\";\n"            + "\n"            + (withAnnot ? "    @SuppressWarnings(SUPPRESS_PMD + \"NoFoo\")\n" : "")            + "    public void someMethod1(Object Foo) {\n"            + "        System.out.println(\"someMethod1\");\n"            + "    }\n"            + "}";    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.LanguageVersion;class JavaLanguageModuleTest {    @Test    void java9IsSmallerThanJava10() {        LanguageVersion java9 = JavaLanguageModule.getInstance().getVersion("9");        LanguageVersion java10 = JavaLanguageModule.getInstance().getVersion("10");        assertTrue(java9.compareTo(java10) < 0, "java9 should be smaller than java10");    }    @Test    void previewVersionShouldBeGreaterThanNonPreview() {        LanguageVersion java18 = JavaLanguageModule.getInstance().getVersion("18");        LanguageVersion java18p = JavaLanguageModule.getInstance().getVersion("18-preview");        assertTrue(java18p.compareTo(java18) > 0, "java18-preview should be greater than java18");    }    @Test    void testCompareToVersion() {        LanguageVersion java9 = JavaLanguageModule.getInstance().getVersion("9");        assertTrue(java9.compareToVersion("10") < 0, "java9 should be smaller than java10");    }    @Test    void allVersions() {        List<LanguageVersion> versions = JavaLanguageModule.getInstance().getVersions();        for (int i = 1; i < versions.size(); i++) {            LanguageVersion previous = versions.get(i - 1);            LanguageVersion current = versions.get(i);            assertTrue(previous.compareTo(current) < 0,                    "Version " + previous + " should be smaller than " + current);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTExpression;/** * Base class for tests that usually need processing stages to run when * parsing code. */public abstract class BaseParserTest {    protected final JavaParsingHelper java = JavaParsingHelper.DEFAULT.withResourceContext(getClass());    protected final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    protected final JavaParsingHelper java8 = java.withDefaultVersion("1.8");    protected final JavaParsingHelper java9 = java.withDefaultVersion("9");    protected ASTCompilationUnit parseCode(final String code) {        return java.parse(code);    }    /**     * Parse and return an expression. Some variables are predeclared.     */    protected ASTExpression parseExpr(String expr) {        ASTCompilationUnit ast = java.parse("class Foo {{ "                                                + "String s1,s2,s3; "                                                + "int i,j,k; "                                                + "Object o = (" + expr + "); }}");        return ast.descendants(ASTExpression.class).crossFindBoundaries().firstOrThrow();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;// TODO - enable test@Disabled("Needs to be enabled after java-grammar changes are finalized")class JavaTokenizerTest extends CpdTextComparisonTest {    JavaTokenizerTest() {        super(".java");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        JavaTokenizer javaTokenizer = new JavaTokenizer();        javaTokenizer.setProperties(properties);        return javaTokenizer;    }    @Override    protected String getResourcePrefix() {        return "../lang/java/cpd/testdata";    }    @Test    void testCommentsIgnored() {        doTest("simpleClassWithComments");    }    @Test    void testDiscardedElements() {        doTest("discardedElements", "_ignore_annots", ignoreAnnotations());    }    @Test    void testDiscardedElementsExceptAnnots() {        doTest("discardedElements", "_no_ignore_annots");    }    @Test    void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    void testIgnoreBetweenSpecialAnnotation() {        doTest("ignoreSpecialAnnotations");    }    @Test    void testIgnoreBetweenSpecialAnnotationAndIgnoreAnnotations() {        doTest("ignoreSpecialAnnotations", "_ignore_annots", ignoreAnnotations());    }    @Test    void testIgnoreIdentifiersDontAffectConstructors() {        doTest("ignoreIdentsPreservesCtor", "", ignoreIdents());    }    @Test    void testIgnoreIdentifiersHandlesEnums() {        doTest("ignoreIdentsPreservesEnum", "", ignoreIdents());    }    @Test    void testIgnoreIdentifiersWithClassKeyword() {        doTest("ignoreIdentsPreservesClassLiteral", "", ignoreIdents());    }    @Test    void testIgnoreLiterals() {        doTest("ignoreLiterals", "", ignoreLiterals());    }    @Test    void testNoIgnoreLiterals() {        doTest("ignoreLiterals", "_noignore");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }    private static Properties ignoreAnnotations() {        return properties(true, false, false);    }    private static Properties ignoreIdents() {        return properties(false, false, true);    }    private static Properties ignoreLiterals() {        return properties(false, true, false);    }    @Override    public Properties defaultProperties() {        return properties(false, false, false);    }    private static Properties properties(boolean ignoreAnnotations,                                         boolean ignoreLiterals,                                         boolean ignoreIdents) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.IGNORE_ANNOTATIONS, Boolean.toString(ignoreAnnotations));        properties.setProperty(Tokenizer.IGNORE_IDENTIFIERS, Boolean.toString(ignoreIdents));        properties.setProperty(Tokenizer.IGNORE_LITERALS, Boolean.toString(ignoreLiterals));        return properties;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static net.sourceforge.pmd.cli.BaseCLITest.containsPattern;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.CoreMatchers.not;import static org.hamcrest.CoreMatchers.startsWith;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;/** * Unit test for {@link CPDCommandLineInterface}. * */public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    /**     * Test ignore identifiers argument.     */    @Test    public void testIgnoreIdentifiers() {        String out = runTest(CPD.StatusCode.DUPLICATE_CODE_FOUND, "--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers");        assertThat(out, containsString("Found a 7 line (36 tokens) duplication"));    }    /**     * Test ignore identifiers argument with failOnViolation=false     */    @Test    public void testIgnoreIdentifiersFailOnViolationFalse() {        String out = runTest(CPD.StatusCode.OK, "--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--failOnViolation",                "false");        assertThat(out, containsString("Found a 7 line (36 tokens) duplication"));    }    /**     * Test ignore identifiers argument with failOnViolation=false with changed long options     */    @Test    public void testIgnoreIdentifiersFailOnViolationFalseLongOption() {        String out = runTest(CPD.StatusCode.OK, "--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--fail-on-violation",                "false");        assertThat(out, containsString("Found a 7 line (36 tokens) duplication"));    }    /**     * Test excludes option.     */    @Test    public void testExcludes() {        String out = runTest(CPD.StatusCode.OK, "--minimum-tokens", "34", "--language", "java", "--ignore-identifiers", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--exclude",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/File2.java");        assertThat(out, not(containsString("Found a 7 line (34 tokens) duplication")));    }    /**     * #1144 CPD encoding argument has no effect     */    @Test    public void testEncodingOption() {        String origEncoding = System.getProperty("file.encoding");        // set the default encoding under Windows        System.setProperty("file.encoding", "Cp1252");        String out = runTest(CPD.StatusCode.DUPLICATE_CODE_FOUND, "--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--format", "xml",                // request UTF-8 for CPD                "--encoding", "UTF-8");        // reset default encoding        System.setProperty("file.encoding", origEncoding);        assertThat(out, startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));        assertThat(out, containsPattern("System\\.out\\.println\\([ij] \\+ \"ä\"\\);"));    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1178/     *     */    @Test    public void testBrokenAndValidFile() {        String out = runTest(CPD.StatusCode.DUPLICATE_CODE_FOUND, "--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/badandgood/", "--format", "text", "--skip-lexical-errors");        String stderr = getStderr();        assertThat(stderr, containsPattern("Skipping .*?BadFile\\.java\\. Reason: Lexical error in file"));        assertThat(out, containsString("Found a 5 line (13 tokens) duplication"));    }    @Test    public void testFormatXmlWithoutEncoding() {        String out = runTest(CPD.StatusCode.DUPLICATE_CODE_FOUND, "--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--format", "xml");        assertThat(out, containsString("<duplication lines=\"3\" tokens=\"10\">"));    }    @Test    public void testCSVFormat() {        String out = runTest(CPD.StatusCode.OK, "--minimum-tokens", "100", "--files", "src/test/resources/net/sourceforge/pmd/cpd/badandgood/",                "--language", "c", "--format", "csv");        assertThat(out, not(containsString("Couldn't instantiate renderer")));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import java.io.IOException;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.junit.jupiter.api.Test;class MatchAlgorithmTest {    private static final String LINE_1 = "public class Foo { ";    private static final String LINE_2 = " public void bar() {";    private static final String LINE_3 = "  System.out.println(\"hello\");";    private static final String LINE_4 = "  System.out.println(\"hello\");";    private static final String LINE_5 = "  int i = 5";    private static final String LINE_6 = "  System.out.print(\"hello\");";    private static final String LINE_7 = " }";    private static final String LINE_8 = "}";    private static String getSampleCode() {        return LINE_1 + "\n" + LINE_2 + "\n" + LINE_3 + "\n" + LINE_4 + "\n" + LINE_5 + "\n" + LINE_6                + "\n" + LINE_7 + "\n" + LINE_8;    }    @Test    void testSimple() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(41, tokens.size());        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        Mark mark1 = marks.next();        Mark mark2 = marks.next();        assertFalse(marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals("Foo.java", mark1.getFilename());        assertEquals(LINE_3, mark1.getSourceCodeSlice());        assertEquals(4, mark2.getBeginLine());        assertEquals("Foo.java", mark2.getFilename());        assertEquals(LINE_4, mark2.getSourceCodeSlice());    }    @Test    void testIgnore() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        tokenizer.setIgnoreLiterals(true);        tokenizer.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        marks.next();        marks.next();        marks.next();        assertFalse(marks.hasNext());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.util.Locale;import org.junit.AfterClass;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.ExternalResource;import org.junit.rules.TestRule;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;import net.sourceforge.pmd.util.IOUtil;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testNoFormattersValidation() {        executeTarget("testNoFormattersValidation");        assertOutputContaining("Violation from test-rset-1.xml");    }    @Test    public void testNestedRuleset() {        executeTarget("testNestedRuleset");        assertOutputContaining("Violation from test-rset-1.xml");        assertOutputContaining("Violation from test-rset-2.xml");    }    @Test    public void testFormatterWithProperties() {        executeTarget("testFormatterWithProperties");        assertOutputContaining("Violation from test-rset-1.xml");        assertOutputContaining("link_prefix");        assertOutputContaining("line_prefix");    }    @Test    public void testAbstractNames() {        executeTarget("testAbstractNames");        assertOutputContaining("Violation from test-rset-1.xml");        assertOutputContaining("Violation from test-rset-2.xml");    }    @Test    public void testAbstractNamesInNestedRuleset() {        executeTarget("testAbstractNamesInNestedRuleset");        assertOutputContaining("Violation from test-rset-1.xml");        assertOutputContaining("Violation from test-rset-2.xml");    }    @Test    public void testCommaInRulesetfiles() {        executeTarget("testCommaInRulesetfiles");        assertOutputContaining("Violation from test-rset-1.xml");        assertOutputContaining("Violation from test-rset-2.xml");    }    @Test    public void testRelativeRulesets() {        executeTarget("testRelativeRulesets");        assertOutputContaining("Violation from test-rset-1.xml");    }    @Test    public void testRelativeRulesetsInRulesetfiles() {        executeTarget("testRelativeRulesetsInRulesetfiles");        assertOutputContaining("Violation from test-rset-1.xml");    }    @Test    public void testExplicitRuleInRuleSet() {        executeTarget("testExplicitRuleInRuleSet");        assertOutputContaining("Violation from test-rset-1.xml");    }    @Test    public void testClasspath() {        executeTarget("testClasspath");    }    // restoring system properties: PMDTask might change logging properties    // See Slf4jSimpleConfigurationForAnt and resetLogging    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @AfterClass    public static void resetLogging() {        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    @Rule    public final TestRule restoreLocale = new ExternalResource() {        private Locale originalLocale;        @Override        protected void before() throws Throwable {            originalLocale = Locale.getDefault();        }        @Override        protected void after() {            Locale.setDefault(originalLocale);        }    };    private static void setDefaultCharset(String charsetName) {        System.setProperty("file.encoding", charsetName);    }    @Rule    public final TestRule restoreDefaultCharset = new ExternalResource() {        private Charset defaultCharset;        @Override        protected void before() throws Throwable {            defaultCharset = Charset.defaultCharset();        }        @Override        protected void after() {            setDefaultCharset(defaultCharset.name());        }    };    @Test    public void testFormatterEncodingWithXML() throws Exception {        Locale.setDefault(Locale.FRENCH);        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXML");        String report = IOUtil.readFileToString(currentTempFile(), StandardCharsets.UTF_8);        assertTrue(report.contains("someVariableWithÜmlaut"));    }    private static String convert(String report) {        // reinterpret output as cp1252 - ant BuildFileRule can only unicode        StringBuilder sb = new StringBuilder(report.length());        for (int i = 0; i < report.length(); i++) {            char c = report.charAt(i);            if (c > 0x7f) {                sb.append((char) (c & 0xff));            } else {                sb.append(c);            }        }        return sb.toString();    }    @Test    public void testFormatterEncodingWithXMLConsole() throws UnsupportedEncodingException {        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXMLConsole");        String report = convert(buildRule.getOutput());        assertTrue(report.startsWith("<?xml version=\"1.0\" encoding=\"windows-1252\"?>"));        assertTrue(report.contains("someVariableWithÜmlaut"));    }    @Test    public void testMissingCacheLocation() {        executeTarget("testMissingCacheLocation");        assertOutputContaining("Violation from test-rset-1.xml");        assertContains(buildRule.getLog(), "This analysis could be faster");    }    @Test    public void testAnalysisCache() {        executeTarget("testAnalysisCache");        assertOutputContaining("Violation from test-rset-1.xml");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertTrue(currentTempFile().exists());    }    @Test    public void testDisableIncrementalAnalysis() {        executeTarget("testDisableIncrementalAnalysis");        assertOutputContaining("Violation from test-rset-1.xml");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertFalse(currentTempFile().exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import org.junit.AfterClass;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TestRule;import net.sourceforge.pmd.PMD.StatusCode;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; */public class CLITest extends BaseCLITest {    // note that the progress bar sometimes messes up the log so it is    // disabled here in most tests.    // restoring system properties: -debug might change logging properties    // See Slf4jSimpleConfigurationForAnt and resetLogging    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @AfterClass    public static void resetLogging() {        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    @Before    public void setupLogging() {        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    private static final String RSET_NO_VIOLATION = "rulesets/testing/rset-without-violations.xml";    private static final String RSET_WITH_VIOLATION = "rulesets/testing/test-rset-1.xml";    @Test    public void minimalArgs() {        runTest("-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_NO_VIOLATION);    }    @Test    public void minimumPriority() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_WITH_VIOLATION, "-min", "1", };        runTest(args);    }    @Test    public void usingDebug() {        runTest("-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_NO_VIOLATION, "-debug");    }    @Test    public void usingDebugLongOption() {        runTest("-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_NO_VIOLATION, "--debug");    }    @Test    public void changeJavaVersion() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_NO_VIOLATION, "-version", "1.5", "-language", "java", "--debug", "--no-progress", };        String log = runTest(args);        assertThat(log, containsPattern("Adding file .*\\.java \\(lang: java 1\\.5\\)"));    }    @Test    public void exitStatusNoViolations() {        runTest("-d", SOURCE_FOLDER, "-f", "text", "-R", "rulesets/testing/rset-without-violations.xml");    }    @Test    public void exitStatusWithViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_WITH_VIOLATION, "--no-progress", };        String log = runTest(StatusCode.VIOLATIONS_FOUND, args);        assertThat(log, containsString("Violation from test-rset-1.xml"));    }    @Test    public void exitStatusWithViolationsAndWithoutFailOnViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_WITH_VIOLATION, "-failOnViolation", "false", "--no-progress", };        String log = runTest(StatusCode.OK, args);        assertThat(log, containsString("Violation from test-rset-1.xml"));    }    @Test    public void exitStatusWithViolationsAndWithoutFailOnViolationsLongOption() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_WITH_VIOLATION, "--fail-on-violation", "false", "--no-progress", };        String log = runTest(StatusCode.OK, args);        assertThat(log, containsString("Violation from test-rset-1.xml"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRuleset() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml", };        String log = runTest(StatusCode.ERROR, args);        assertThat(log, containsString("Cannot resolve rule/ruleset reference "                                       + "'category/java/designn.xml'"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulesetWithRulename() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml/UseCollectionIsEmpty", };        String log = runTest(StatusCode.ERROR, args);        assertThat(log, containsString("Cannot resolve rule/ruleset reference"                                       + " 'category/java/designn.xml/UseCollectionIsEmpty'"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulename() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", RSET_WITH_VIOLATION + "/ThisRuleDoesNotExist", };        String log = runTest(StatusCode.OK, args);        assertThat(log, containsString("No rules found. Maybe you misspelled a rule name?"                                       + " (" + RSET_WITH_VIOLATION + "/ThisRuleDoesNotExist)"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.File;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.java.JavaLanguageModule;class LanguageVersionDiscovererTest {    /**     * Test on Java file with default options.     * Always the latest non-preview version will be the default version.     */    @Test    void testJavaFileUsingDefaults() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(LanguageRegistry.PMD);        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion latest = determineLatestNonPreviewVersion();        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals(latest, languageVersion, "Latest language version must be default");    }    private LanguageVersion determineLatestNonPreviewVersion() {        LanguageVersion latest = null;        for (LanguageVersion lv : JavaLanguageModule.getInstance().getVersions()) {            if (!lv.getName().endsWith("preview")) {                latest = lv;            }        }        return latest;    }    /**     * Test on Java file with Java version set to 1.4.     */    @Test    void testJavaFileUsing14() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(LanguageRegistry.PMD);        Language java = JavaLanguageModule.getInstance();        discoverer.setDefaultLanguageVersion(java.getVersion("1.4"));        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals(java.getVersion("1.4"), languageVersion);    }    @Test    void testLanguageVersionDiscoverer() {        PMDConfiguration configuration = new PMDConfiguration();        LanguageVersionDiscoverer languageVersionDiscoverer = configuration.getLanguageVersionDiscoverer();        Language java = JavaLanguageModule.getInstance();        assertEquals(determineLatestNonPreviewVersion(),                     languageVersionDiscoverer.getDefaultLanguageVersion(java),                     "Default Java version");        configuration                .setDefaultLanguageVersion(java.getVersion("1.5"));        assertEquals(java.getVersion("1.5"),                     languageVersionDiscoverer.getDefaultLanguageVersion(java),                     "Modified Java version");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        Language java = getLanguage(JavaLanguageModule.NAME);        return Arrays.asList(new Object[][] {            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.3",              java.getVersion("1.3"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.4",              java.getVersion("1.4"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.5",              java.getVersion("1.5"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.6",              java.getVersion("1.6"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.7",              java.getVersion("1.7"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.8",              java.getVersion("1.8"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "9",              java.getVersion("9"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "10",              java.getVersion("10"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "11",              java.getVersion("11"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12",              java.getVersion("12"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13",              java.getVersion("13"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "14",              java.getVersion("14"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "15",              java.getVersion("15"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "16",              java.getVersion("16"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "16-preview",              java.getVersion("16-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "17",              java.getVersion("17"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "17-preview",              java.getVersion("17-preview"), },            // this one won't be found: case sensitive!            { "JAVA", "JAVA", "1.7", null, },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import static org.junit.jupiter.api.Assertions.assertFalse;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;class ReportTest {    private final JavaParsingHelper java = JavaParsingHelper.DEFAULT;    @Test    void testBasic() {        Report r = java.executeRule(new FooRule(), TEST1);        assertFalse(r.getViolations().isEmpty());    }    @Test    void testExclusionsInReportWithRuleViolationSuppressRegex() {        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR, ".*No Foo.*");        Report rpt = java.executeRule(rule, TEST1);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    void testExclusionsInReportWithRuleViolationSuppressXPath() {        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR, ".[@SimpleName = 'Foo']");        Report rpt = java.executeRule(rule, TEST1);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    void testExclusionsInReportWithAnnotations() {        Report rpt =            java.executeRule(new FooRule(), TEST2);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    void testExclusionsInReportWithAnnotationsFullName() {        Report rpt = java.executeRule(new FooRule(), TEST2_FULL);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    void testExclusionsInReportWithNOPMD() {        Report rpt = java.executeRule(new FooRule(), TEST3);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "@SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST2_FULL = "@java.lang.SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST3 = "public class Foo {} // NOPMD";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertNull;import org.junit.Test;/** * Test java's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    @Test    public void testExclusionOfUselessParantheses() {        RuleSet ruleset = new RuleSetLoader().loadFromString("",                                                             "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"category/java/codestyle.xml\">\n"                        + "    <exclude name=\"UselessParentheses\"/>\n" + "  </rule>\n" + "</ruleset>\n");        Rule rule = ruleset.getRuleByName("UselessParentheses");        assertNull(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.java.BaseParserTest;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;class ExcludeLinesTest extends BaseParserTest {    @Test    void testAcceptance() {        assertSize(java.executeRule(getRule(), TEST1), 0);        assertSize(java.executeRule(getRule(), TEST2), 1);    }    Rule getRule() {        return new AbstractJavaRule() {            {                setMessage("!");            }            @Override            public Object visit(ASTVariableDeclaratorId node, Object data) {                addViolation(data, node);                return data;            }        };    }    @Test    void testAlternateMarker() {        Report rpt = java.withSuppressMarker("FOOBAR").executeRule(getRule(), TEST3);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    private static final String TEST1 = "public class Foo {\n"                                        + " void foo() {\n"                                        + "  int x; //NOPMD \n"                                        + " } \n"                                        + "}";    private static final String TEST2 = "public class Foo {\n"                                        + " void foo() {\n"                                        + "  int x;\n"                                        + " } \n"                                        + "}";    private static final String TEST3 = "public class Foo {\n"                                        + " void foo() {\n"                                        + "  int x; // FOOBAR\n"                                        + " } \n"                                        + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoUnsanitizedJSPExpressionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class IframeMissingSrcAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class JspEncodingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoScriptletsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoInlineStyleInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoLongScriptsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoInlineScriptTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class DuplicateJspImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class DontNestJsfInJstlIterationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoHtmlCommentsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoJspForwardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class NoClassAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Iterator;import java.util.List;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;/** * Test parsing of a JSP in document style, by checking the generated AST. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be * */class JspDocStyleTest extends AbstractJspNodesTst {    /**     * Smoke test for JSP parser.     */    @Test    void testSimplestJsp() {        List<ASTElement> nodes = jsp.getNodes(ASTElement.class, TEST_SIMPLEST_HTML);        assertEquals(1, nodes.size(), "Exactly " + 1 + " element(s) expected");    }    /**     * Test the information on a Element and Attribute.     */    @Test    void testElementAttributeAndNamespace() {        ASTCompilationUnit root = jsp.parse(TEST_ELEMENT_AND_NAMESPACE);        List<ASTElement> elementNodes = root.findDescendantsOfType(ASTElement.class);        assertEquals(1, elementNodes.size(), "One element node expected!");        ASTElement element = elementNodes.get(0);        assertEquals("h:html", element.getName(), "Correct name expected!");        assertTrue(element.isHasNamespacePrefix(), "Has namespace prefix!");        assertTrue(element.isEmpty(), "Element is empty!");        assertEquals("h", element.getNamespacePrefix(), "Correct namespace prefix of element expected!");        assertEquals("html", element.getLocalName(), "Correct local name of element expected!");        List<ASTAttribute> attributeNodes = root.findDescendantsOfType(ASTAttribute.class);        assertEquals(1, attributeNodes.size(), "One attribute node expected!");        ASTAttribute attribute = attributeNodes.get(0);        assertEquals("MyNsPrefix:MyAttr", attribute.getName(), "Correct name expected!");        assertTrue(attribute.isHasNamespacePrefix(), "Has namespace prefix!");        assertEquals("MyNsPrefix", attribute.getNamespacePrefix(), "Correct namespace prefix of element expected!");        assertEquals("MyAttr", attribute.getLocalName(), "Correct local name of element expected!");    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    void testAttributeValueContainingHash() {        ASTCompilationUnit root = jsp.parse(TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        List<ASTAttribute> attrsList = root.findDescendantsOfType(ASTAttribute.class);        assertEquals(3, attrsList.size(), "Three attributes expected!");        ASTAttribute attr = attrsList.get(0);        assertEquals("something", attr.getName(), "Correct attribute name expected!");        assertEquals("#yes#", attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage(), "Correct attribute value expected!");        attr = attrsList.get(1);        assertEquals("foo", attr.getName(), "Correct attribute name expected!");        assertEquals("CREATE", attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage(), "Correct attribute value expected!");        attr = attrsList.get(2);        assertEquals("href", attr.getName(), "Correct attribute name expected!");        assertEquals("#", attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage(), "Correct attribute value expected!");    }    /**     * Test correct parsing of CDATA.     */    @Test    void testCData() {        List<ASTCData> cdataNodes = jsp.getNodes(ASTCData.class, TEST_CDATA);        assertEquals(1, cdataNodes.size(), "One CDATA node expected!");        ASTCData cdata = cdataNodes.get(0);        assertEquals(" some <cdata> ]] ]> ", cdata.getImage(), "Content incorrectly parsed!");    }    /**     * Test parsing of Doctype declaration.     */    @Test    void testDoctype() {        ASTCompilationUnit root = jsp.parse(TEST_DOCTYPE);        List<ASTDoctypeDeclaration> docTypeDeclarations = root.findDescendantsOfType(ASTDoctypeDeclaration.class);        assertEquals(1, docTypeDeclarations.size(), "One doctype declaration expected!");        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("html", docTypeDecl.getName(), "Correct doctype-name expected!");        List<ASTDoctypeExternalId> externalIds = root.findDescendantsOfType(ASTDoctypeExternalId.class);        assertEquals(1, externalIds.size(), "One doctype external id expected!");        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId(), "Correct external public id expected!");        assertEquals("http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd", externalId.getUri(), "Correct external uri expected!");    }    /**     * Test parsing of a XML comment.     *     */    @Test    void testComment() {        List<ASTCommentTag> comments = jsp.getNodes(ASTCommentTag.class, TEST_COMMENT);        assertEquals(1, comments.size(), "One comment expected!");        ASTCommentTag comment = comments.iterator().next();        assertEquals("comment", comment.getImage(), "Correct comment content expected!");    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void testHtmlScript() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Script!", script.getImage(), "Correct script content expected!");    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be valid     * html but it is likely to appear in .JSP files.     */    @Test    void testImportHtmlScript() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttributeValue> value = script.findDescendantsOfType(ASTAttributeValue.class);        assertEquals("filename.js", value.get(0).getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void testHtmlScriptWithAttribute() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals(1, scripts.size(), "One script expected!");        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Script!", script.getImage(), "Correct script content expected!");        List<ASTAttributeValue> attrs = script.findDescendantsOfType(ASTAttributeValue.class);        assertEquals("text/javascript", attrs.get(0).getImage());    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    void testComplexHtmlScript() {        List<ASTHtmlScript> script = jsp.getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals(1, script.size(), "One script expected!");        ASTHtmlScript next = script.iterator().next();        assertThat(next.getImage(), containsString("<!--"));        List<ASTCommentTag> comments = jsp.getNodes(ASTCommentTag.class, TEST_COMPLEX_SCRIPT);        assertEquals(1, comments.size(), "One comment expected!");    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void testInlineCss() {        List<ASTElement> scripts = jsp.getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals(3, scripts.size(), "Three elements expected!");    }    /**     * Test parsing of HTML text within element.     */    @Test    void testTextInTag() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals(1, scripts.size(), "One text chunk expected!");        ASTText script = scripts.iterator().next();        assertEquals(" some text ", script.getImage(), "Correct content expected!");    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    void noSpacesBetweenTags() {        List<ASTElement> elmts = jsp.getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals(2, elmts.size(), "Two tags expected!");        assertEquals("a", elmts.get(0).getName(), "Correct content expected!");        assertEquals("b", elmts.get(1).getName(), "Correct content expected!");    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    void unclosedTagsWithDollar() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals(2, scripts.size(), "Two text chunks expected!");        ASTText script = scripts.iterator().next();        assertEquals(" $ ", script.getImage(), "Correct content expected!");    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    void unclosedTagsWithELWithin() {        List<ASTElExpression> scripts = jsp.getNodes(ASTElExpression.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals(2, scripts.size(), "Two EL expressions expected!");        assertEquals("expr1", scripts.get(0).getImage(), "Correct content expected!");        assertEquals("expr2", scripts.get(1).getImage(), "Correct content expected!");    }    /**     * Make sure mixed expressions don't confuse the parser     */    @Test    void mixedExpressions() {        List<ASTJspExpression> exprs = jsp.getNodes(ASTJspExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals(1, exprs.size(), "One JSP expression expected!");        assertEquals("expr", exprs.iterator().next().getImage(), "Image of expression should be \"expr\"");        List<ASTElExpression> els = jsp.getNodes(ASTElExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals(2, els.size(), "Two EL expression expected!");        assertEquals("expr", els.iterator().next().getImage(), "Image of el should be \"expr\"");        List<ASTUnparsedText> unparsedtexts = jsp.getNodes(ASTUnparsedText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals(2, unparsedtexts.size(), "Two unparsed texts expected!");        assertEquals(" aaa ", unparsedtexts.get(0).getImage(), "Image of text should be \" aaa \"");        assertEquals(" \\${expr} ", unparsedtexts.get(1).getImage(), "Image of text should be \"\\${expr}\"");        // ASTText should contain the text between two tags.        List<ASTText> texts = jsp.getNodes(ASTText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals(2, texts.size(), "Two regular texts expected!");        assertEquals(" \\${expr} ", texts.get(1).getImage(), "Image of text should be \"\\${expr}\"");        assertEquals(" aaa ${expr}#{expr}", texts.get(0).getImage(), "Image of text should be all text between two nodes"                + " \"  aaa ${expr}#{expr} \"");    }    /**     * Make sure JSP expressions are properly detected when they are next to     * unclosed tags.     */    @Test    void unclosedTagsWithJspExpressionWithin() {        List<ASTJspExpression> scripts = jsp.getNodes(ASTJspExpression.class, TEST_TAGS_WITH_EXPRESSION_WITHIN);        assertEquals(2, scripts.size(), "Two JSP expressions expected!");        ASTJspExpression script = scripts.iterator().next();        assertEquals("expr", script.getImage(), "Correct content expected!");    }    /**     * A dangling unopened ( just &lt;/closed&gt; ) tag should not influence the     * parsing.     */    @Test    @Disabled // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    void textBetweenUnopenedTag() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TEXT_WITH_UNOPENED_TAG);        assertEquals(2, scripts.size(), "Two text chunks expected!");        ASTText script = scripts.iterator().next();        assertEquals("$", script.getImage(), "Correct content expected!");    }    /**     * Parser should be able to handle documents which start or end with     * unparsed text     */    @Test    @Disabled // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    void textMultipleClosingTags() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_MULTIPLE_CLOSING_TAGS);        assertEquals(4, scripts.size(), "Four text chunks expected!");        ASTText script = scripts.iterator().next();        assertEquals(" some text ", script.getImage(), "Correct content expected!");    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    void textAfterOpenAndClosedTag() {        List<ASTElement> nodes = jsp.getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals(2, nodes.size(), "Two elements expected!");        assertEquals("a", nodes.get(0).getName(), "First element should be a");        assertFalse(nodes.get(0).isUnclosed(), "first element should be closed");        assertEquals("b", nodes.get(1).getName(), "Second element should be b");        assertTrue(nodes.get(1).isUnclosed(), "Second element should not be closed");        List<ASTText> text = jsp.getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals(2, text.size(), "Two text chunks expected!");    }    @Test    void quoteEL() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("${something}", attr.getImage(), "Expected to detect proper value for attribute!");    }    @Test    void quoteExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_EXPRESSION);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<%=something%>", attr.getImage(), "Expected to detect proper value for attribute!");    }    @Test    @Disabled // tags contain quotes and break attribute parsing    void quoteTagInAttribute() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_TAG_IN_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<bean:write name=\"x\" property=\"z\">",                attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * smoke test for a non-quoted attribute value     */    @Test    void noQuoteAttrValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("yes|", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether JSP el is properly detected as attribute value     */    @Test    void noQuoteAttrWithJspEL() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals(2, attributes.size(), "two attributes expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr2 = iterator.next();        if ("url".equals(attr2.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr2 = iterator.next();        }        assertEquals("${something}", attr2.getImage(), "Expected to detect proper value for EL in attribute!");    }    /**     * tests whether parse correctly detects presence of JSP expression &lt;%= %&gt;     * within an non-quoted attribute value     */    @Test    void noQuoteAttrWithJspExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EXPRESSION);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<%=something%>", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    void noQuoteAttrEmpty() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_EMPTY_ATTR);        assertEquals(2, attributes.size(), "two attributes expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether parse correctly interprets an cr lf instead of an attribute     */    @Test    void noQuoteAttrCrLf() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_CR_LF_ATTR);        assertEquals(2, attributes.size(), "One attribute expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("\n", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    void noQuoteAttrTab() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAB_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        assertEquals("\t", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * tests whether parse does not fail in the presence of unclosed JSP     * expression &lt;%= within an non-quoted attribute value     */    @Test    void noQuoteAttrWithMalformedJspExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<%=something", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * test a no quote attribute value which contains a scriptlet &lt;% %&gt; within     * its value     */    @Test    @Disabled // nice test for future development    void noQuoteAttrWithScriptletInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<% String a = \"1\";%>", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * test a no quote attribute value can contain a tag (e.g.     * attr=&lt;bean:write property="value" /&gt;)     *     */    @Test    @Disabled // nice test for future development    void noQuoteAttrWithBeanWriteTagAsValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<% String a = \"1\";%>", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * test a quote attribute value can contain a tag (e.g.     * attr="&lt;bean:write property="value" /&gt;" ) Not sure if it's legal JSP code     * but most JSP engine accept and properly treat this value at runtime     */    @Test    @Disabled // nice test for future development    void quoteAttrWithBeanWriteTagAsValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("<% String a = \"1\";%>", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * test a no quote attribute value which contains the EL dollar sign $     * within its value     */    @Test    @Disabled // nice test for future development    void noQuoteAttrWithDollarSignInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_DOLLAR);        assertEquals(2, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("${something", attr.getImage(), "Expected to detect proper value for attribute!");    }    /**     * test a no quote attribute value which contains the EL sharp sign # within     * its value     */    @Test    @Disabled // nice test for future development    void noQuoteAttrWithSharpSymbolInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_HASH);        assertEquals(1, attributes.size(), "One attribute expected!");        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("#{something", attr.getImage(), "Expected to detect proper value for attribute!");    }    @Test    void unclosedTag() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        assertEquals(2, elements.size(), "2 tags expected");        assertEquals("tag:someTag", elements.get(0).getName(), "First element should be tag:someTag");        assertEquals("tag:if", elements.get(1).getName(), "Second element should be sorted tag:if");        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());    }    @Test    void unclosedTagAndNoQuotesForAttribute() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_NO_QUOTE_ATTR);        assertEquals(2, elements.size(), "2 tags expected");        ASTElement ifTag = elements.get(1);        ASTElement someTag = elements.get(0);        assertEquals("tag:if", ifTag.getName());        assertEquals("tag:someTag", someTag.getName());        assertTrue(ifTag.isEmpty());        assertTrue(ifTag.isUnclosed());        assertFalse(someTag.isEmpty());        assertFalse(someTag.isUnclosed());    }    @Test    void unclosedTagMultipleLevels() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        assertEquals(3, elements.size(), "3 tags expected");        ASTElement xtag = elements.get(0);        ASTElement outerTag = elements.get(1);        ASTElement innerTag = elements.get(2);        assertEquals("tag:someTag", innerTag.getName());        assertEquals("tag:someTag", outerTag.getName());        assertEquals("tag:x", xtag.getName());        assertFalse(innerTag.isEmpty());        assertFalse(innerTag.isUnclosed());        assertTrue(outerTag.isEmpty());        assertTrue(outerTag.isUnclosed());        assertFalse(xtag.isEmpty());        assertFalse(xtag.isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    void nestedEmptyTags() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        assertEquals(4, elements.size(), "4 tags expected");        ASTElement a1Tag = elements.get(1);        ASTElement a2Tag = elements.get(2);        ASTElement bTag = elements.get(3);        ASTElement htmlTag = elements.get(0);        assertEquals("a1", a1Tag.getName());        assertEquals("a2", a2Tag.getName());        assertEquals("b", bTag.getName());        assertEquals("html", htmlTag.getName());        // a1        assertFalse(a1Tag.isEmpty());        assertFalse(a1Tag.isUnclosed());        // a2        assertTrue(a2Tag.isEmpty());        assertFalse(a2Tag.isUnclosed());        // b        assertTrue(bTag.isEmpty());        assertFalse(bTag.isUnclosed());        // html        assertFalse(htmlTag.isEmpty());        assertFalse(htmlTag.isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt; &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    void nestedMultipleTags() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        ASTElement html = elements.get(0);        ASTElement a1 = elements.get(1);        ASTElement a2 = elements.get(2);        ASTElement a3 = elements.get(3);        ASTElement b = elements.get(4);        ASTElement a4 = elements.get(5);        assertEquals(6, elements.size(), "6 tags expected");        assertEquals("a1", a1.getName());        assertEquals("a2", a2.getName());        assertEquals("a3", a3.getName());        assertEquals("a4", a4.getName());        assertEquals("b", b.getName());        assertEquals("html", html.getName());        // a1 not empty and closed        assertFalse(a1.isEmpty());        assertFalse(a1.isUnclosed());        // a2 not empty and closed        assertFalse(a2.isEmpty());        assertFalse(a2.isUnclosed());        // a3 empty and not closed        assertTrue(a3.isEmpty());        assertTrue(a3.isUnclosed());        // a4 empty but closed        assertTrue(a4.isEmpty());        assertFalse(a4.isUnclosed());        // b empty but closed        assertTrue(b.isEmpty());        assertFalse(b.isUnclosed());        // html not empty and closed        assertFalse(html.isEmpty());        assertFalse(html.isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt; .     * Here x is the first tag to be closed thus rendering the next close of a (&lt;/a&gt;)     * to be disregarded.     */    @Test    void unclosedParentTagClosedBeforeChild() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        assertEquals(4, elements.size(), "4 tags expected");        ASTElement x = elements.get(0);        ASTElement a = elements.get(1);        ASTElement b = elements.get(2);        ASTElement b2 = elements.get(3);        assertEquals("a", a.getName());        assertEquals("b", b.getName());        assertEquals("b", b2.getName());        assertEquals("x", x.getName());        // a        assertTrue(a.isEmpty());        assertTrue(a.isUnclosed());        // b        assertTrue(b.isEmpty());        assertTrue(b.isUnclosed());        // b        assertTrue(b2.isEmpty());        assertTrue(b2.isUnclosed());        // x        assertFalse(x.isEmpty());        assertFalse(x.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt; An unmatched closing of 'z' appears     * randomly in the document. This should be disregarded and structure of     * children and parents should not be influenced. in other words &lt;/a&gt; should     * close the first &lt;a&gt; tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    void unmatchedTagDoesNotInfluenceStructure() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        assertEquals(4, elements.size(), "4 tags expected");        ASTElement x = elements.get(0);        ASTElement a = elements.get(1);        ASTElement b1 = elements.get(2);        ASTElement b2 = elements.get(3);        assertEquals("a", a.getName());        assertEquals("b", b1.getName());        assertEquals("b", b2.getName());        assertEquals("x", x.getName());        // a is not empty and closed        assertFalse(a.isEmpty());        assertFalse(a.isUnclosed());        // b empty and unclosed        assertTrue(b1.isEmpty());        assertTrue(b1.isUnclosed());        // b empty and unclosed        assertTrue(b2.isEmpty());        assertTrue(b2.isUnclosed());        // x not empty and closed        assertFalse(x.isEmpty());        assertFalse(x.isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This     * should be disregarded and structure of children and parents should not be influenced.     * Also un unclosed &lt;a&gt; tag appears at the start of the document     */    @Test    void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        assertEquals(5, elements.size(), "5 tags expected");        ASTElement a1 = elements.get(0);        ASTElement x = elements.get(1);        ASTElement a2 = elements.get(2);        ASTElement b1 = elements.get(3);        ASTElement b2 = elements.get(4);        assertEquals("a", a1.getName());        assertEquals("a", a2.getName());        assertEquals("b", b1.getName());        assertEquals("b", b2.getName());        assertEquals("x", x.getName());        // first a is empty and unclosed        assertTrue(a1.isEmpty());        assertTrue(a1.isUnclosed());        // second a not empty and closed        assertFalse(a2.isEmpty());        assertFalse(a2.isUnclosed());        // b empty and unclosed        assertTrue(b1.isEmpty());        assertTrue(b1.isUnclosed());        // b empty and unclosed        assertTrue(b2.isEmpty());        assertTrue(b2.isUnclosed());        // x not empty and closed        assertFalse(x.isEmpty());        assertFalse(x.isUnclosed());    }    /**     * {@link #TEST_UNCLOSED_END_OF_DOC}     * &lt;tag:x&gt; &lt;tag:y&gt;     * Tests whether parser breaks on no closed tags at all     */    @Test    // This is yet to be improved. If a closing tag does not    // exist no tags will be marked as empty :(    @Disabled    void unclosedEndOfDoc() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_END_OF_DOC);        assertEquals(2, elements.size(), "2 tags expected");        ASTElement x = elements.get(0);        ASTElement y = elements.get(1);        assertEquals("tag:x", x.getName());        assertEquals("tag:y", y.getName());        // b        // assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(x.isUnclosed());        // b        assertTrue(y.isEmpty());        assertTrue(y.isUnclosed());    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_COMMENT = "<html><!-- comment --></html>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" type=\"text/javascript\"/></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>#{expr1}<b>${expr2}</a>";    private static final String TEST_TAGS_WITH_MIXED_EXPRESSIONS = "<a> aaa ${expr} #{expr} <%=expr%> <b> \\${expr} </a>";    private static final String TEST_TAGS_WITH_EXPRESSION_WITHIN = "<a> <%=expr%> <b> <%=expr%> </a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_TEXT_WITH_UNOPENED_TAG = "<a> some text </b> some text </a>";    private static final String TEST_MULTIPLE_CLOSING_TAGS = "<a> some text </b> </b> </b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"${something}\" > </tag:if>";    private static final String TEST_QUOTE_EXPRESSION = "<tag:if something=\"<%=something%>\" >  </tag:if>";    private static final String TEST_QUOTE_TAG_IN_ATTR = "<tag:if something=\"<bean:write name=\"x\" property=\"z\">\" >  "            + "<a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR = "<tag:if something=yes| > </tag:if>";    private static final String TEST_NO_QUOTE_EMPTY_ATTR = "<tag:if something= >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAG_IN_ATTR = "<tag:if something=<bean:write name=\"x\" property=\"z\"> >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_CR_LF_ATTR = "<tag:if something=\r\n >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAB_ATTR = "<tag:if something=\t >   </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<tag:if something=${something} >  <a href=url >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EXPRESSION = "<tag:if something=<%=something%> >  </tag:if>";    /**     * same as {@link #TEST_NO_QUOTE_ATTR_WITH_EXPRESSION} only expression is     * not properly closed     */    private static final String TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR = "<tag:if something=<%=something >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET = "<tag:if something=<% String a = \"1\";%>x >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_DOLLAR = "<tag:if something=${something >  <a href=${ >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_HASH = "<tag:if something=#{something >  <a href=#{url} >foo</a> </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if something=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag something=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_END_OF_DOC = "<tag:x> <tag:y>";    private static final String TEST_UNCLOSED_NO_QUOTE_ATTR = "<tag:someTag> <tag:if something=x > </tag:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;class JspPageStyleTest extends AbstractJspNodesTst {    /**     * Test parsing of a JSP comment.     */    @Test    void testComment() {        List<ASTJspComment> comments = jsp.getNodes(ASTJspComment.class, JSP_COMMENT);        assertEquals(1, comments.size(), "One comment expected!");        ASTJspComment comment = comments.iterator().next();        assertEquals("some comment", comment.getImage(), "Correct comment content expected!");    }    /**     * Test parsing a JSP directive.     */    @Test    void testDirective() {        ASTCompilationUnit root = jsp.parse(JSP_DIRECTIVE);        List<ASTJspDirective> directives = root.findDescendantsOfType(ASTJspDirective.class);        assertEquals(1, directives.size(), "One directive expected!");        ASTJspDirective directive = directives.iterator().next();        assertEquals("page", directive.getName(), "Correct directive name expected!");        List<ASTJspDirectiveAttribute> directiveAttrs = root.findDescendantsOfType(ASTJspDirectiveAttribute.class);        assertEquals(2, directiveAttrs.size(), "Two directive attributes expected!");        ASTJspDirectiveAttribute attr = directiveAttrs.get(0);        assertEquals("language", attr.getName(), "Correct directive attribute name expected!");        assertEquals("java", attr.getValue(), "Correct directive attribute value expected!");        attr = directiveAttrs.get(1);        assertEquals("session", attr.getName(), "Correct directive attribute name expected!");        assertEquals("true", attr.getValue(), "Correct directive attribute value expected!");    }    /**     * Test parsing of a JSP declaration.     */    @Test    void testDeclaration() {        List<ASTJspDeclaration> declarations = jsp.getNodes(ASTJspDeclaration.class, JSP_DECLARATION);        assertEquals(1, declarations.size(), "One declaration expected!");        ASTJspDeclaration declaration = declarations.iterator().next();        assertEquals("String someString = \"s\";", declaration.getImage(), "Correct declaration content expected!");    }    /**     * Test parsing of a JSP scriptlet.     */    @Test    void testScriptlet() {        List<ASTJspScriptlet> scriptlets = jsp.getNodes(ASTJspScriptlet.class, JSP_SCRIPTLET);        assertEquals(1, scriptlets.size(), "One scriptlet expected!");        ASTJspScriptlet scriptlet = scriptlets.iterator().next();        assertEquals("someString = someString + \"suffix\";",                scriptlet.getImage(), "Correct scriptlet content expected!");    }    /**     * Test parsing of a JSP expression.     */    @Test    void testExpression() {        List<ASTJspExpression> expressions = jsp.getNodes(ASTJspExpression.class, JSP_EXPRESSION);        assertEquals(1, expressions.size(), "One expression expected!");        ASTJspExpression expression = expressions.iterator().next();        assertEquals("someString", expression.getImage(), "Correct expression content expected!");    }    /**     * Test parsing of a JSP expression in an attribute.     */    @Test    void testExpressionInAttribute() {        List<ASTJspExpressionInAttribute> expressions = jsp.getNodes(ASTJspExpressionInAttribute.class, JSP_EXPRESSION_IN_ATTRIBUTE);        assertEquals(1, expressions.size(), "One expression expected!");        ASTJspExpressionInAttribute expression = expressions.iterator().next();        assertEquals("style.getClass()", expression.getImage(), "Correct expression content expected!");    }    /**     * Test parsing of a EL expression.     */    @Test    void testElExpression() {        List<ASTElExpression> expressions = jsp.getNodes(ASTElExpression.class, JSP_EL_EXPRESSION);        assertEquals(1, expressions.size(), "One expression expected!");        ASTElExpression expression = expressions.iterator().next();        assertEquals("myBean.get(\"${ World }\")", expression.getImage(), "Correct expression content expected!");    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    void testElExpressionInAttribute() {        List<ASTElExpression> expressions = jsp.getNodes(ASTElExpression.class, JSP_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals(1, expressions.size(), "One expression expected!");        ASTElExpression expression = expressions.iterator().next();        assertEquals("myValidator.find(\"'jsp'\")", expression.getImage(), "Correct expression content expected!");    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    void testJsfValueBinding() {        List<ASTValueBinding> valueBindings = jsp.getNodes(ASTValueBinding.class, JSF_VALUE_BINDING);        assertEquals(1, valueBindings.size(), "One value binding expected!");        ASTValueBinding valueBinding = valueBindings.iterator().next();        assertEquals("myValidator.find(\"'jsf'\")", valueBinding.getImage(), "Correct expression content expected!");    }    private static final String JSP_COMMENT = "<html> <%-- some comment --%> </html>";    private static final String JSP_DIRECTIVE = "<html> <%@ page language=\"java\" session='true'%> </html>";    private static final String JSP_DECLARATION = "<html><%! String someString = \"s\"; %></html>";    private static final String JSP_SCRIPTLET = "<html> <% someString = someString + \"suffix\"; %> </html>";    private static final String JSP_EXPRESSION = "<html><head><title> <%= someString %> </title></head></html>";    private static final String JSP_EXPRESSION_IN_ATTRIBUTE = "<html> <body> <p class='<%= style.getClass() %>'> Hello </p> </body> </html>";    private static final String JSP_EL_EXPRESSION = "<html><title>Hello ${myBean.get(\"${ World }\") } .jsp</title></html>";    private static final String JSP_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').${myValidator.find(\"'jsp'\")}\" /> </html>";    private static final String JSF_VALUE_BINDING = "<html> <body> <p class='#{myValidator.find(\"'jsf'\")}'> Hello </p> </body> </html>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;class XPathJspRuleTest extends AbstractJspNodesTst {    /**     * Test matching a XPath expression against a JSP source.     */    @Test    void testExpressionMatching() {        Rule rule = jsp.newXpathRule("//Element [@Name='hr']");        Report report = jsp.executeRule(rule, "<html><hr/></html>");        assertEquals(1, report.getViolations().size(), "One violation expected!");        RuleViolation rv = report.getViolations().get(0);        assertEquals(1, rv.getBeginLine());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @BeforeEach    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *     */    @Test    void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.jsp.ast.AbstractJspNodesTst;/** * Unit test for JSP parsing. * */class JspParserTest extends AbstractJspNodesTst {    /**     * Verifies bug #939 Jsp parser fails on $     */    @Test    void testParseDollar() {        jsp.parse("<span class=\"CostUnit\">$</span><span class=\"CostMain\">129</span><span class=\"CostFrac\">.00</span>");    }    @Test    void testParseELAttribute() {        jsp.parse("<div ${something ? 'class=\"red\"' : ''}> Div content here.</div>");    }    @Test    void testParseELAttributeValue() {        jsp.parse("<div class=\"${something == 0 ? 'zero_something' : something == 1 ? 'one_something' : 'other_something'}\">Div content here.</div>");    }    /**     * Verifies bug #311 Jsp parser fails on boolean attribute     */    @Test    void testParseBooleanAttribute() {        jsp.parse("<label><input type='checkbox' checked name=cheese disabled=''> Cheese</label>");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class JSPTokenizerTest extends CpdTextComparisonTest {    JSPTokenizerTest() {        super(".jsp");    }    @Override    protected String getResourcePrefix() {        return "../lang/jsp/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new JSPTokenizer();    }    @Test    void scriptletWithString() {        doTest("scriptletWithString");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import java.nio.file.Path;import java.nio.file.Paths;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.jsp.ast.AbstractJspNodesTst;class LanguageVersionDiscovererTest extends AbstractJspNodesTst {    @Test    void testParseJsp() {        testLanguageIsJsp("sample.jsp");        testLanguageIsJsp("sample.jspx");    }    @Test    void testTag() {        testLanguageIsJsp("sample.tag");    }    private void testLanguageIsJsp(String first) {        assertEquals(jsp.getLanguage().getDefaultVersion(),                                getLanguageVersion(Paths.get(first)));    }    @Test    void testParseWrong() {        assertNotEquals(jsp.getLanguage().getDefaultVersion(),                                getLanguageVersion(Paths.get("sample.xxx")));    }    private LanguageVersion getLanguageVersion(Path jspFile) {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(LanguageRegistry.PMD);        return discoverer.getDefaultLanguageVersionForFile(jspFile.toFile());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { JspLanguageModule.NAME, JspLanguageModule.TERSE_NAME, "",            getLanguage(JspLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test jsp's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * @author rpelisse * */class FortranTokenizerTest extends CpdTextComparisonTest {    FortranTokenizerTest() {        super(".for");    }    @Override    protected String getResourcePrefix() {        return "../lang/fortran/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new FortranLanguage().getTokenizer();    }    @Test    void testSample() {        doTest("sample");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.FileSystems;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.TreeMap;import org.apache.commons.lang3.SystemUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.yaml.snakeyaml.DumperOptions;import org.yaml.snakeyaml.DumperOptions.FlowStyle;import org.yaml.snakeyaml.DumperOptions.LineBreak;import org.yaml.snakeyaml.Yaml;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.util.IOUtil;class SidebarGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    @BeforeEach    void setup() {        writer.reset();    }    @Test    void testSidebar() throws IOException {        Map<Language, List<RuleSet>> rulesets = new TreeMap<>();        RuleSet ruleSet1 = RuleSet.create("test", "test", "bestpractices.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        RuleSet ruleSet2 = RuleSet.create("test2", "test", "codestyle.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        rulesets.put(LanguageRegistry.PMD.getLanguageById("java"), Arrays.asList(ruleSet1, ruleSet2));        rulesets.put(LanguageRegistry.PMD.getLanguageById("ecmascript"), Arrays.asList(ruleSet1));        rulesets.put(LanguageRegistry.PMD.getLanguageById("scala"), Collections.emptyList());        SidebarGenerator generator = new SidebarGenerator(writer, FileSystems.getDefault().getPath(".."));        List<Map<String, Object>> result = generator.generateRuleReferenceSection(rulesets);        DumperOptions options = new DumperOptions();        options.setDefaultFlowStyle(FlowStyle.BLOCK);        if (SystemUtils.IS_OS_WINDOWS) {            options.setLineBreak(LineBreak.WIN);        }        String yaml = new Yaml(options).dump(result);        String expected = MockedFileWriter.normalizeLineSeparators(                IOUtil.readToString(SidebarGeneratorTest.class.getResourceAsStream("sidebar.yml"), StandardCharsets.UTF_8));        assertEquals(expected, yaml);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.List;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.docs.MockedFileWriter.FileEntry;import net.sourceforge.pmd.util.IOUtil;class RuleDocGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    private Path root;    @TempDir    public Path folder;    @BeforeEach    void setup() throws IOException {        writer.reset();        root = Files.createTempDirectory(folder, null);        Files.createDirectories(root.resolve("docs/_data/sidebars"));        List<String> mockedSidebar = Arrays.asList(                "entries:",                "- title: sidebar",                "  folders:",                "  - title: 1",                "  - title: 2",                "  - title: 3",                "  - title: Rules");        Files.write(root.resolve("docs/_data/sidebars/pmd_sidebar.yml"), mockedSidebar);    }    private static String loadResource(String name) throws IOException {        return MockedFileWriter.normalizeLineSeparators(                IOUtil.readToString(RuleDocGeneratorTest.class.getResourceAsStream(name), StandardCharsets.UTF_8));    }    @Test    void testSingleRuleset() throws IOException {        RuleDocGenerator generator = new RuleDocGenerator(writer, root);        RuleSetLoader rsl = new RuleSetLoader().includeDeprecatedRuleReferences(true);        RuleSet ruleset = rsl.loadFromResource("rulesets/ruledoctest/sample.xml");        generator.generate(Arrays.asList(ruleset),                Arrays.asList(                        "rulesets/ruledoctest/sample-deprecated.xml",                        "rulesets/ruledoctest/other-ruleset.xml"));        assertEquals(3, writer.getData().size());        FileEntry languageIndex = writer.getData().get(0);        assertTrue(IOUtil.normalizePath(languageIndex.getFilename()).endsWith(Paths.get("docs", "pages", "pmd", "rules", "java.md").toString()));        assertEquals(loadResource("/expected/java.md"), languageIndex.getContent());        FileEntry ruleSetIndex = writer.getData().get(1);        assertTrue(IOUtil.normalizePath(ruleSetIndex.getFilename()).endsWith(Paths.get("docs", "pages", "pmd", "rules", "java", "sample.md").toString()));        assertEquals(loadResource("/expected/sample.md"), ruleSetIndex.getContent());        FileEntry sidebar = writer.getData().get(2);        assertTrue(IOUtil.normalizePath(sidebar.getFilename()).endsWith(Paths.get("docs", "_data", "sidebars", "pmd_sidebar.yml").toString()));        assertEquals(loadResource("/expected/pmd_sidebar.yml"), sidebar.getContent());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.nio.file.FileSystems;import java.nio.file.Path;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.util.IOUtil;class RuleSetResolverTest {    private static final List<String> EXCLUDED_RULESETS = listOf(            IOUtil.normalizePath("pmd-test/src/main/resources/rulesets/dummy/basic.xml")    );    @Test    void resolveAllRulesets() {        Path basePath = FileSystems.getDefault().getPath(".").resolve("..").toAbsolutePath().normalize();        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);        filterRuleSets(additionalRulesets);        assertFalse(additionalRulesets.isEmpty());        for (String filename : additionalRulesets) {            new RuleSetLoader().warnDeprecated(false).loadFromResource(filename); // will throw if invalid        }    }    @Test    void testAdditionalRulesetPattern() {        String filePath = IOUtil.normalizePath("/home/foo/pmd/pmd-java/src/main/resources/rulesets/java/quickstart.xml");        assertTrue(GenerateRuleDocsCmd.ADDITIONAL_RULESET_PATTERN.matcher(filePath).matches());    }    private void filterRuleSets(List<String> additionalRulesets) {        additionalRulesets.removeIf(this::isExcluded);    }    private boolean isExcluded(String fileName) {        return EXCLUDED_RULESETS.stream().anyMatch(fileName::endsWith);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.jupiter.api.Assertions.assertEquals;import java.nio.file.FileSystems;import java.util.List;import org.junit.jupiter.api.Test;class RuleTagCheckerTest {    @Test    void testAllChecks() throws Exception {        RuleTagChecker checker = new RuleTagChecker(FileSystems.getDefault().getPath("src/test/resources/ruletagchecker"));        List<String> issues = checker.check();        assertEquals(7, issues.size());        assertEquals("ruletag-examples.md: 9: Rule tag for \"java/bestpractices/AvoidPrintStackTrace\" is not closed properly",                issues.get(0));        assertEquals("ruletag-examples.md:12: Rule \"java/notexistingcategory/AvoidPrintStackTrace\" is not found",                issues.get(1));        assertEquals("ruletag-examples.md:14: Rule \"java/bestpractices/NotExistingRule\" is not found",                issues.get(2));        assertEquals("ruletag-examples.md:16: Rule tag for \"java/bestpractices/OtherRule has a missing quote",                issues.get(3));        assertEquals("ruletag-examples.md:17: Rule tag for java/bestpractices/OtherRule\" has a missing quote",                issues.get(4));        assertEquals("ruletag-examples.md:21: Rule tag for \"OtherRule has a missing quote", issues.get(5));        assertEquals("ruletag-examples.md:22: Rule tag for OtherRule\" has a missing quote", issues.get(6));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.Arrays;import java.util.List;import org.junit.jupiter.api.Test;class EscapeUtilsTest {    @Test    void testEscapeMarkdown() {        assertEquals("This is a \\\\backslash", EscapeUtils.escapeMarkdown("This is a \\backslash"));        assertEquals("This \"\\*\" is not a emphasis", EscapeUtils.escapeMarkdown("This \"*\" is not a emphasis"));        assertEquals("This \"\\*\\*\" is not a strong style", EscapeUtils.escapeMarkdown("This \"**\" is not a strong style"));        assertEquals("This \"\\[foo\\]\" does not start a link", EscapeUtils.escapeMarkdown("This \"[foo]\" does not start a link"));        assertEquals("This \"\\~bar\\~\" is not a strike-through", EscapeUtils.escapeMarkdown("This \"~bar~\" is not a strike-through"));        assertEquals("That's \"\\|\" just a bar", EscapeUtils.escapeMarkdown("That's \"|\" just a bar"));        assertEquals("This \"\\_\" is just a underscore", EscapeUtils.escapeMarkdown("This \"_\" is just a underscore"));    }    @Test    void testEscapeHtmlWithinMarkdownSingleLine() {        assertEquals("a &lt;script&gt; tag outside of `<script>` backticks should be escaped",                EscapeUtils.escapeSingleLine("a <script> tag outside of `<script>` backticks should be escaped"));        assertEquals("a &lt;script&gt; &quot;tag&quot; outside of `<script>` backticks should be escaped &lt;multiple&gt; times `<strong>`.",                EscapeUtils.escapeSingleLine("a <script> \"tag\" outside of `<script>` backticks should be escaped <multiple> times `<strong>`."));        assertEquals("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links",                EscapeUtils.escapeSingleLine("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links"));        assertEquals("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links",                EscapeUtils.escapeSingleLine("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links"));        assertEquals("URL: <http://www.google.com> is a url without ssl",                EscapeUtils.escapeSingleLine("URL: <http://www.google.com> is a url without ssl"));        assertEquals("> this is a quote line",                EscapeUtils.escapeSingleLine("> this is a quote line"));        assertEquals("combination of URLs and backticks: <https://pmd.github.io> but `<script>` &lt;strong&gt;escaped&lt;/strong&gt;",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: <https://pmd.github.io> but `<script>` <strong>escaped</strong>"));        assertEquals("combination of URLs and backticks: `<script>` &lt;strong&gt;escaped&lt;/strong&gt; but <https://pmd.github.io>",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: `<script>` <strong>escaped</strong> but <https://pmd.github.io>"));    }    @Test    void testEscapeHtmlWithinMarkdownBlocks() {        String text = "paragraph\n\n> quote <script>\n> quote line \"2\"\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        String expected = "paragraph\n\n> quote &lt;script&gt;\n> quote line &quot;2&quot;\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        List<String> escaped = EscapeUtils.escapeLines(Arrays.asList(text.split("\n")));        assertEquals(Arrays.asList(expected.split("\n")), escaped);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.jupiter.api.Assertions.assertEquals;import javax.xml.transform.Source;import org.junit.jupiter.api.Test;/** * * @author sturton */class ResourceResolverTest {    /**     * Test of resolve method, of class ResourceResolver.     */    @Test    void testResolve() throws Exception {        System.out.println("resolve");        String href = "";        String base = "";        ResourceResolver instance = new ResourceResolver();        Source expResult = null;        Source result = instance.resolve(href, base);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.File;import java.io.FileOutputStream;import java.io.PrintStream;import java.nio.file.Path;import java.util.Map.Entry;import java.util.Properties;import java.util.ResourceBundle;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;/** * * @author sturton */class DBTypeTest {    private File absoluteFile;    private Properties testProperties;    private Properties includeProperties;    @TempDir    private Path folder;    @BeforeEach    void setUp() throws Exception {        testProperties = new Properties();        testProperties.put("prop1", "value1");        testProperties.put("prop2", "value2");        testProperties.put("prop3", "value3");        includeProperties = new Properties();        includeProperties.putAll(testProperties);        includeProperties.put("prop3", "include3");        absoluteFile = folder.resolve("dbtypetest.properties").toFile();        try (FileOutputStream fileOutputStream = new FileOutputStream(absoluteFile);             PrintStream printStream = new PrintStream(fileOutputStream)) {            for (Entry<?, ?> entry : testProperties.entrySet()) {                printStream.printf("%s=%s\n", entry.getKey(), entry.getValue());            }        }    }    @AfterEach    void tearDown() throws Exception {        testProperties = null;    }    /**     * Test of getProperties method, of class DBType.     */    @Test    void testGetPropertiesFromFile() throws Exception {        System.out.println("getPropertiesFromFile");        DBType instance = new DBType(absoluteFile.getAbsolutePath());        Properties expResult = testProperties;        Properties result = instance.getProperties();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    void testGetProperties() throws Exception {        System.out.println("testGetProperties");        DBType instance = new DBType("test");        Properties expResult = testProperties;        System.out.println("testGetProperties: expected results " + testProperties);        Properties result = instance.getProperties();        System.out.println("testGetProperties: actual results " + result);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    void testGetIncludeProperties() throws Exception {        System.out.println("testGetIncludeProperties");        DBType instance = new DBType("include");        Properties expResult = includeProperties;        System.out.println("testGetIncludeProperties: expected results " + includeProperties);        Properties result = instance.getProperties();        System.out.println("testGetIncludeProperties: actual results " + result);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getResourceBundleAsProperties method, of class DBType.     */    @Test    void testAsProperties() {        System.out.println("asProperties");        ResourceBundle bundle = ResourceBundle.getBundle(DBType.class.getPackage().getName() + ".test");        Properties expResult = testProperties;        Properties result = DBType.getResourceBundleAsProperties(bundle);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.io.InputStream;import org.junit.jupiter.api.Test;/** * * @author sturton */class ResourceLoaderTest {    /**     * Test of getResourceStream method, of class ResourceLoader.     */    @Test    void testGetResourceStream() throws Exception {        System.out.println("getResourceStream");        String path = "";        ResourceLoader instance = new ResourceLoader();        InputStream expResult = null;        InputStream result = instance.getResourceStream(path);        assertNotNull(result);        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.jupiter.api.Assertions.assertEquals;import java.net.URI;import java.net.URISyntaxException;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.jupiter.api.Test;/** * * @author sturton */class DBURITest {    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    /*     * Expected values from testdefaults.properties     */    static final String C_DEFAULT_USER = "scott";    static final String C_DEFAULT_PASSWORD = "tiger";    static final String C_DEFAULT_LANGUAGES = "java,plsql";    static final String C_DEFAULT_SCHEMAS = "scott,system";    static final String C_DEFAULT_SOURCE_CODE_TYPES = "table,view";    static final String C_DEFAULT_SOURCE_CODE_NAMES = "emp,dept";    static final String C_DEFAULT_CHARACTERSET = "utf8";    /**     * Fully specified URI, overriding defaults in testdefaults.properties     */    static final String C_TEST_EXPLICIT = "jdbc:oracle:testdefault:system/oracle@//192.168.100.21:1521/ORCL?characterset=us7ascii&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    /*     * Expected values from testdefaults.properties, with values overridden by     * URI query parameters     */    static final String C_EXPLICIT_USER = "system";    static final String C_EXPLICIT_PASSWORD = "oracle";    static final String C_EXPLICIT_LANGUAGES = "plsql,java";    static final String C_EXPLICIT_SCHEMAS = "scott,hr,sh,system";    static final String C_EXPLICIT_SOURCE_CODE_TYPES = "procedures,functions,triggers,package,types";    static final String C_EXPLICIT_SOURCE_CODE_NAMES = "PKG_%%,PRC_%%";    static final String C_EXPLICIT_CHARACTERSET = "us7ascii";    static final String C_TEST_URI = "test?param1=x%261&param2=&param3=";    static final String C_ORACLE_OCI_1 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_OCI_2 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_OCI_3 = "jdbc:oracle:oci:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_THIN_2 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_POSTGRES_1 = "jdbc:postgresql://host/database";    static final String C_HTTP = "http://localhost:80?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static void dump(String description, URI dburi) {        System.err.printf(                "Test %s\n: isOpaque=%s, isAbsolute=%s Scheme=%s,\n SchemeSpecificPart=%s,\n Host=%s,\n Port=%s,\n Path=%s,\n Fragment=%s,\n Query=%s\n",                description, dburi.isOpaque(), dburi.isAbsolute(), dburi.getScheme(), dburi.getSchemeSpecificPart(),                dburi.getHost(), dburi.getPort(), dburi.getPath(), dburi.getFragment(), dburi.getQuery());        String query = dburi.getQuery();        if (null != query && !"".equals(query)) {            String[] params = query.split("&");            Map<String, String> map = new HashMap<>();            for (String param : params) {                String[] splits = param.split("=");                String name = splits[0];                String value = null;                if (splits.length > 1) {                    value = splits[1];                }                map.put(name, value);                System.err.printf("name=%s,value=%s\n", name, value);            }        }        // return map;    }    /**     * Test of dump method, of class DBURI.     */    @Test    void testDump() throws URISyntaxException, Exception {        System.out.println("dump");        String description = "";        DBURI dburi = new DBURI(C_TEST_URI);        DBURI.dump(description, dburi.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getUri method, of class DBURI.     */    @Test    void testGetUri() throws URISyntaxException, Exception {        System.out.println("getUri");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        URI expResult = new URI(C_ORACLE_OCI_1);        URI result = instance.getUri();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setUri method, of class DBURI.     */    @Test    void testSetUri() throws URISyntaxException, Exception {        System.out.println("setUri");        URI uri = new URI(C_ORACLE_OCI_1);        DBURI instance = new DBURI(C_TEST_URI);        instance.setUri(uri);        assertEquals(uri, instance.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    void testGetDbType() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_POSTGRES_1);        DBType expResult = new DBType("postgresql");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    void testGetDbType2() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        DBType expResult = new DBType("oci");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDbType method, of class DBURI.     */    @Test    void testSetDbType() throws URISyntaxException, Exception {        System.out.println("setDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        DBType dbType = new DBType("postgresql");        instance.setDbType(dbType);        assertEquals(dbType, instance.getDbType());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSchemasList method, of class DBURI.     */    @Test    void testGetSchemasList() throws URISyntaxException, Exception {        System.out.println("getSchemasList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult;        expResult = Arrays.asList("scott,hr,sh,system".split(","));        List<String> result = instance.getSchemasList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSchemasList method, of class DBURI.     */    @Test    void testSetSchemasList() throws URISyntaxException, Exception {        System.out.println("setSchemasList");        List<String> schemasList = Arrays.asList("scott,hr,sh,system".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSchemasList(schemasList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeTypesList method, of class DBURI.     */    @Test    void testGetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeTypesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("procedures,functions,triggers,package,types".split(","));        List<String> result = instance.getSourceCodeTypesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeTypesList method, of class DBURI.     */    @Test    void testSetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeTypesList");        List<String> sourcecodetypesList = Arrays.asList("procedures,functions,triggers,package,types".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeTypesList(sourcecodetypesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeNamesList method, of class DBURI.     */    @Test    void testGetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeNamesList");        DBURI instance = new DBURI(C_ORACLE_OCI_3);        List<String> expResult = Arrays.asList("PKG_%%,PRC_%%".split(","));        List<String> result = instance.getSourceCodeNamesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeNamesList method, of class DBURI.     */    @Test    void testSetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeNamesList");        List<String> sourceCodeNamesList = Arrays.asList("PKG_%%,TRG_%%".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSourceCodeNamesList(sourceCodeNamesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getLanguagesList method, of class DBURI.     */    @Test    void testGetLanguagesList() throws URISyntaxException, Exception {        System.out.println("getLanguagesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("plsql,java".split(","));        List<String> result = instance.getLanguagesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setLanguagesList method, of class DBURI.     */    @Test    void testSetLanguagesList() throws URISyntaxException, Exception {        System.out.println("setLanguagesList");        List<String> languagesList = Arrays.asList("plsql,java".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setLanguagesList(languagesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    void testGetDriverClass() throws URISyntaxException, Exception {        System.out.println("getDriverClass");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetDriverClass: driverClass=" + result);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    void testGetThinDriverClass() throws URISyntaxException, Exception {        System.out.println("getThinDriverClass");        DBURI instance = new DBURI(C_ORACLE_THIN_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetThinDriverClass: driverClass=" + result);        System.out.println("testGetThinDriverClass: getDbType().getProperties() follows");        System.out                .println("testGetThinDriverClass: getDbType().getProperties()=" + instance.getDbType().getProperties());        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDriverClass method, of class DBURI.     */    @Test    void testSetDriverClass() throws URISyntaxException, Exception {        System.out.println("setDriverClass");        String driverClass = "oracle.jdbc.driver.OracleDriver";        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setDriverClass(driverClass);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getCharacterSet method, of class DBURI.     */    @Test    void testGetCharacterSet() throws URISyntaxException, Exception {        System.out.println("getCharacterSet");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "utf8";        String result = instance.getCharacterSet();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setCharacterSet method, of class DBURI.     */    @Test    void testSetCharacterSet() throws URISyntaxException, Exception {        System.out.println("setCharacterSet");        String characterSet = "utf8";        DBURI instance = new DBURI(C_POSTGRES_1);        instance.setCharacterSet(characterSet);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeType method, of class DBURI.     */    @Test    void testGetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("getSourceCodeType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        int expResult = 2005; // CLOB        int result = instance.getSourceCodeType();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeType method, of class DBURI.     */    @Test    void testSetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("setSourceCodeType");        int sourceCodeType = 5;        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeType(sourceCodeType);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubprotocol method, of class DBURI.     */    @Test    void testGetSubprotocol() throws URISyntaxException, Exception {        System.out.println("getSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oracle";        String result = instance.getSubprotocol();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubprotocol method, of class DBURI.     */    @Test    void testSetSubprotocol() throws URISyntaxException, Exception {        System.out.println("setSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String subprotocol = "oracle";        instance.setSubprotocol(subprotocol);        String result = instance.getSubprotocol();        assertEquals(subprotocol, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubnamePrefix method, of class DBURI.     */    @Test    void testGetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("getSubnamePrefix");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oci";        String result = instance.getSubnamePrefix();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubnamePrefix method, of class DBURI.     */    @Test    void testSetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("setSubnamePrefix");        String subnamePrefix = "oci8";        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSubnamePrefix(subnamePrefix);        String result = instance.getSubnamePrefix();        assertEquals(subnamePrefix, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getParameters method, of class DBURI.     */    @Test    void testGetParameters() throws URISyntaxException, Exception {        System.out.println("getParameters");        DBURI instance = new DBURI(C_TEST_URI);        Map<String, String> expResult = new HashMap<>();        expResult.put("param1", "x&1");        expResult.put("param2", null);        expResult.put("param3", null);        Map<String, String> result = instance.getParameters();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setParameters method, of class DBURI.     */    @Test    void testSetParameters() throws URISyntaxException, Exception {        System.out.println("setParameters");        Map<String, String> parameters = new HashMap<>();        parameters.put("param1", "x%FFF");        parameters.put("param2", "IAmParameter2");        parameters.put("param3", "IAmParameter3");        DBURI instance = new DBURI(C_TEST_URI);        instance.setParameters(parameters);        // TODO review the generated test code and remove the default call to        // fail.        assertEquals(parameters, instance.getParameters());    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    void testDefaultLanguagesList() throws URISyntaxException, Exception {        System.out.println("testDefaultLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_DEFAULT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default CharacterSet are returned if non are provided in the     * DBURI.     */    @Test    void testDefaultCharacterSet() throws URISyntaxException, Exception {        System.out.println("testDefaultCharacterSet");        DBURI instance = new DBURI(C_TEST_DEFAULTS);        String result = instance.getCharacterSet();        assertEquals(C_DEFAULT_CHARACTERSET, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    void testDefaultSchemasList() throws URISyntaxException, Exception {        System.out.println("testDefaultSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_DEFAULT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default Source Code Types are returned if non are provided in     * the DBURI.     */    @Test    void testDefaultSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    void testDefaultSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    void testExplicitLanguagesList() throws URISyntaxException, Exception {        System.out.println("testExplicitLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_EXPLICIT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that CharacterSet are returned if provided in the DBURI.     */    @Test    void testExplicitCharacterSet() throws URISyntaxException, Exception {        System.out.println("testExplicitCharacterSet");        DBURI instance = new DBURI(C_TEST_EXPLICIT);        String result = instance.getCharacterSet();        assertEquals(C_EXPLICIT_CHARACTERSET, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    void testExplicitSchemasList() throws URISyntaxException, Exception {        System.out.println("testExplicitSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_EXPLICIT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that Source Code Types are returned if provided in the DBURI.     */    @Test    void testExplicitSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    void testExplicitSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.io.IOException;import java.io.Reader;import java.net.URISyntaxException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.List;import java.util.Properties;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * * @author sturton */@Disabledclass DBMSMetadataTest {    private static final Logger LOG = LoggerFactory.getLogger(DBMSMetadataTest.class);    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:scott/tiger@//192.168.100.21:5521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:scott/oracle@//192.168.100.21:1521/orcl?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_4 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_5 = "jdbc:oracle:thin:@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25&amp;user=system&amp;password=oracle";    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    private DBURI dbURI;    private DBURI dbURI4;    private DBURI dbURI5;    private DBURI dbURIDefault;    DBMSMetadataTest() throws URISyntaxException, Exception {        dbURI = new DBURI(C_ORACLE_THIN_3);        dbURI4 = new DBURI(C_ORACLE_THIN_4);        dbURI5 = new DBURI(C_ORACLE_THIN_5);        dbURIDefault = new DBURI(C_TEST_DEFAULTS);    }    /**     * Convert Readers to Strings for eay output and comparison.     */    private static String getStringFromReader(Reader reader) throws IOException {        StringBuilder stringBuilder = new StringBuilder(1024);        char[] charArray = new char[1024];        int readChars;        while ((readChars = reader.read(charArray)) > 0) {            System.out.println("Reader.read(CharArray)==" + readChars);            stringBuilder.append(charArray, 0, readChars);        }        reader.close();        return stringBuilder.toString();    }    /**     * Dump ResultSet     */    private static void dumpResultSet(ResultSet resultSet, String description) {        try {            ResultSetMetaData metaData = resultSet.getMetaData();            int columnCount = metaData.getColumnCount();            System.out.format("ResultSet \"%s\" has %d columns and contains ...\n[", description, columnCount);            /*             * Walk through the column names, writing out a header line             */            for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                System.out.format("%s%s", ((columnNumber > 1) ? "," : ""), metaData.getColumnName(columnNumber));            }            System.out.format("\n");            // Output each row            while (resultSet.next()) {                /*                 * Walk through the columns of this row, writing out a row line                 */                for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                    System.out.format("%s%s", ((columnNumber > 0) ? "," : ""), resultSet.getString(columnNumber));                }                System.out.format("\n");            }        } catch (SQLException ex) {            LOG.error(ex.getMessage(), ex);        }        System.out.format("...\n]\n");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @Test    void testGetConnection() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(dbURI.getURL()).connect(dbURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI);        Connection result = instance.getConnection();        assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @Test    void testGetConnectionWithConnectionParameters() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI5.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI5.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI5.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.putAll(dbURI5.getParameters());        Connection expResult = DriverManager.getDriver(dbURI5.getURL()).connect(dbURI5.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI5);        Connection result = instance.getConnection();        assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCode method, of class DBMSMetadata.     */    @Test    void testGetSourceCode() throws Exception {        System.out.println("getSourceCode");        // String objectType = "PACKAGE";        // String name = "DBMS_REPCAT_AUTH";        // String schema = "SYSTEM";        String objectType = "TABLE";        String name = "EMP";        String schema = "SCOTT";        System.out.println("dbURI.driverClass==" + dbURI.getDriverClass());        System.out.println("dbURI.URL==" + dbURI.getURL());        System.out.println("dbURI.getDBType.getProperties()==" + dbURI.getDbType().getProperties());        System.out.println("dbURI.getDBType.getSourceCodeReturnType()==" + dbURI.getDbType().getSourceCodeReturnType());        System.out.println("dbURI.getDBType.getProperties()=="                + dbURI.getDbType().getProperties().getProperty("getSourceCodeStatement"));        DBMSMetadata instance = new DBMSMetadata(dbURI);        Reader expResult = null;        Reader result = instance.getSourceCode(objectType, name, schema);        /*         * StringBuilder stringBuilder = new StringBuilder(1024); char[]         * charArray = new char[1024]; int readChars = 0; while(( readChars =         * result.read(charArray)) > 0 ) {         * System.out.println("Reader.read(CharArray)=="+readChars);         * stringBuilder.append(charArray, 0, readChars); } result.close();         *         * System.out.println("getSourceCode()==\""+stringBuilder.toString()+         * "\"" );         *         * assertTrue(stringBuilder.toString().startsWith("\n  CREATE "));         */        String resultString = getStringFromReader(result);        System.out.println("getSourceCode()==\"" + resultString);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    void testGetSchemas() throws Exception {        System.out.println("getSchemas");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        assertNotNull(result);        ResultSet allSchemas = result.getMetaData().getSchemas();        dumpResultSet(allSchemas, "All Schemas");        ResultSet allCatalogues = result.getMetaData().getCatalogs();        dumpResultSet(allCatalogues, "All Catalogues");        String catalog = null;        String schemasPattern = "PHPDEMO";        String tablesPattern = null;        String proceduresPattern = null;        // Not until Java6 ResultSet matchedSchemas =        // result.getMetaData().getSchemas(catalog, schemasPattern) ;        // Not until Java6 dumpResultSet (matchedSchemas, "Matched Schemas") ;        ResultSet matchedTables = result.getMetaData().getTables(catalog, schemasPattern, tablesPattern, null);        dumpResultSet(matchedTables, "Matched Tables");        ResultSet matchedProcedures = result.getMetaData().getProcedures(catalog, schemasPattern, proceduresPattern);        dumpResultSet(matchedProcedures, "Matched Procedures");        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    void testGetSourceObjectList() throws Exception {        System.out.println("getConnection");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        assertNotNull(result);        List<SourceObject> sourceObjectList = instance.getSourceObjectList();        assertNotNull(sourceObjectList);        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());        System.out.print("sourceObjectList ...\n");        for (SourceObject sourceObject : sourceObjectList) {            System.out.printf("sourceObject=%s\n", sourceObject);            System.out.printf("sourceCode=[%s]\n", getStringFromReader(instance.getSourceCode(sourceObject)));        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.BufferedWriter;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.PrintStream;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import org.hamcrest.Matcher;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;/** * */class TreeExportCliTest {    @TempDir    private Path tmp;    @Test    void testReadStandardInput() {        IoSpy spy = IoSpy.withStdin("(a(b))");        int status = spy.runMain("-i", "-f", "xml", "-PlineSeparator=LF", "-l", "dummy");        assertEquals(0, status);        spy.assertThatStdout(containsString("<?xml version='1.0' encoding='UTF-8' ?>\n"                                            + "<dummyRootNode Image=''>\n"                                            + "    <dummyNode Image='a'>\n"                                            + "        <dummyNode Image='b' />\n"                                            + "    </dummyNode>\n"                                            + "</dummyRootNode>"));    }    @Test    void testReadFile() throws IOException {        File file = newFileWithContents("(a(b))");        IoSpy spy = new IoSpy();        int status = spy.runMain("--file", file.getAbsolutePath(), "-f", "xml", "-PlineSeparator=LF", "-l", "dummy");        assertEquals(0, status);        spy.assertThatStdout(containsString("<?xml version='1.0' encoding='UTF-8' ?>\n"                                            + "<dummyRootNode Image=''>\n"                                            + "    <dummyNode Image='a'>\n"                                            + "        <dummyNode Image='b' />\n"                                            + "    </dummyNode>\n"                                            + "</dummyRootNode>"));    }    private File newFileWithContents(String data) throws IOException {        File file = Files.createTempFile(tmp, "TreeExportCliTest", "data").toFile();        try (BufferedWriter br = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {            br.write(data);        }        return file;    }    private static InputStream stdinContaining(String input) {        return new ByteArrayInputStream(input.getBytes(StandardCharsets.UTF_8));    }    static class IoSpy {        final ByteArrayOutputStream out = new ByteArrayOutputStream();        final ByteArrayOutputStream err = new ByteArrayOutputStream();        final Io io;        IoSpy(InputStream stdin) {            io = new Io(new PrintStream(out), new PrintStream(err), stdin);        }        IoSpy() {            this(stdinContaining(""));        }        void assertThatStdout(Matcher<? super String> str) {            assertThat("stdout", out.toString(), str);        }        int runMain(String... args) {            return new TreeExportCli(io).runMain(args);        }        static IoSpy withStdin(String contents) {            return new IoSpy(stdinContaining(contents));        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsInAnyOrder;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.properties.PropertySource;/** * */class TreeRenderersTest {    @Test    void testStandardRenderersAreRegistered() {        assertEquals(TreeRenderers.XML, TreeRenderers.findById(TreeRenderers.XML.id()));    }    @Test    void testXmlPropertiesAvailable() {        PropertySource properties = TreeRenderers.XML.newPropertyBundle();        assertThat(properties.getPropertyDescriptors(),                          containsInAnyOrder(TreeRenderers.XML_LINE_SEPARATOR,                                                                             TreeRenderers.XML_RENDER_COMMON_ATTRIBUTES,                                                                             TreeRenderers.XML_RENDER_PROLOG,                                                                             TreeRenderers.XML_USE_SINGLE_QUOTES));    }    @Test    void testXmlDescriptorDump() throws IOException {        PropertySource bundle = TreeRenderers.XML.newPropertyBundle();        bundle.setProperty(TreeRenderers.XML_RENDER_PROLOG, false);        bundle.setProperty(TreeRenderers.XML_USE_SINGLE_QUOTES, false);        bundle.setProperty(TreeRenderers.XML_LINE_SEPARATOR, "\n");        TreeRenderer renderer = TreeRenderers.XML.produceRenderer(bundle);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummyTree1(), out);        assertEquals("<dummyNode foo=\"bar\" ohio=\"4\">\n"                                + "    <dummyNode o=\"ha\" />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    static DummyNode dummyTree1() {        DummyNode dummy = DummyLanguageModule.parse("(parent(child1)(child2))").getChild(0);        dummy.clearXPathAttributes();        dummy.setXPathAttribute("foo", "bar");        dummy.setXPathAttribute("ohio", "4");        DummyNode dummy1 = dummy.getChild(0);        dummy1.clearXPathAttributes();        dummy1.setXPathAttribute("o", "ha");        dummy.getChild(1).clearXPathAttributes();        return dummy;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.io.IOException;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer.XmlRenderingConfig;/** */class XmlTreeRendererTest {    @Test    void testRenderWithAttributes() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig();        strat.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    void testRenderWithCustomLineSep() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig();        strat.lineSeparator("\r\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\r\n"                                + "<dummyNode foo='bar' ohio='4'>\r\n"                                + "    <dummyNode o='ha' />\r\n"                                + "    <dummyNode />\r\n"                                + "</dummyNode>\r\n", out.toString());    }    @Test    void testRenderWithCustomIndent() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("").indentWith("");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>"                                + "<dummyNode foo='bar' ohio='4'>"                                + "<dummyNode o='ha' />"                                + "<dummyNode />"                                + "</dummyNode>", out.toString());    }    @Test    void testRenderWithNoAttributes() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig() {            @Override            public boolean takeAttribute(Node node, Attribute attribute) {                return false;            }        }.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode>\n"                                + "    <dummyNode />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    void testRenderFilterAttributes() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlRenderingConfig strategy = new XmlRenderingConfig() {            @Override            public boolean takeAttribute(Node node, Attribute attribute) {                return attribute.getName().equals("ohio");            }        }.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strategy);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode ohio='4'>\n"                                + "    <dummyNode />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    void testInvalidAttributeName() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        dummy.setXPathAttribute("&notAName", "foo");        XmlRenderingConfig config = new XmlRenderingConfig();        config.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(config);        StringBuilder out = new StringBuilder();        assertThrows(IllegalArgumentException.class, () -> renderer.renderSubtree(dummy, out));    }    @Test    void testEscapeAttributes() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        dummy.setXPathAttribute("eh", " 'a &> b\" ");        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode eh=' &apos;a &amp;> b\" ' foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    void testEscapeDoubleAttributes() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        dummy.setXPathAttribute("eh", " 'a &> b\" ");        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n").singleQuoteAttributes(false);        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"                                + "<dummyNode eh=\" 'a &amp;> b&quot; \" foo=\"bar\" ohio=\"4\">\n"                                + "    <dummyNode o=\"ha\" />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    void testNoProlog() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n").renderProlog(false);        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<dummyNode foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    void testDefaultLineSep() throws IOException {        DummyNode dummy = TreeRenderersTest.dummyTree1();        XmlTreeRenderer renderer = new XmlTreeRenderer();        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        assertEquals("<?xml version='1.0' encoding='UTF-8' ?>" + System.lineSeparator()                                + "<dummyNode foo='bar' ohio='4'>" + System.lineSeparator()                                + "    <dummyNode o='ha' />" + System.lineSeparator()                                + "    <dummyNode />" + System.lineSeparator()                                + "</dummyNode>" + System.lineSeparator(), out.toString());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.datasource;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.IOException;import java.nio.file.Path;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;class FileDataSourceTest {    @TempDir    private Path tempFolder;    private static final String SOMEFILE_DIR = "path/";    private static final String SOMEFILE_TXT = "somefile.txt";    private static final String SOMEFILE_TXT_FULL_PATH = SOMEFILE_DIR + SOMEFILE_TXT;    private FileDataSource ds;    private File someFile;    private File someFolder;    @BeforeEach    void setup() throws IOException {        someFolder = tempFolder.resolve(SOMEFILE_DIR).toFile();        assertTrue(someFolder.mkdir());        someFile = tempFolder.resolve(SOMEFILE_TXT_FULL_PATH).toFile();        ds = new FileDataSource(someFile);    }    @Test    void testShortNamesSingleFile() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFile.getAbsolutePath()));    }    @Test    void testShortNamesSingleDir() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFolder.getAbsolutePath()));    }    @Test    void testShortNamesNullBase() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, null));    }    @Test    void testShortNamesCommaSeparatedDirs() {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }    @Test    void testShortNamesCommaSeparatedFiles() {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }    @Test    void testShortNamesCommaSeparatedMixed() {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }    @Test    void testLongNamesSingleFile() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFile.getAbsolutePath()));    }    @Test    void testLongNamesSingleDir() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFolder.getAbsolutePath()));    }    @Test    void testLongNamesNullBase() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, null));    }    @Test    void testLongNamesCommaSeparatedDirs() throws IOException {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }    @Test    void testLongNamesCommaSeparatedFiles() throws IOException {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }    @Test    void testLongNamesCommaSeparatedMixed() throws IOException {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.fail;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.CharArrayReader;import java.io.FilterOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintStream;import java.io.Reader;import java.io.StringReader;import java.io.StringWriter;import java.io.Writer;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import org.apache.commons.lang3.SystemUtils;import org.junit.jupiter.api.Test;class IOUtilTest {    @Test    void testReadAllBytes() throws IOException {        byte[] data = "12345".getBytes(StandardCharsets.UTF_8);        try (InputStream stream = new ByteArrayInputStream(data)) {            byte[] bytes = IOUtil.toByteArray(stream);            assertEquals(5, bytes.length);            assertArrayEquals(data, bytes);        }    }    @Test    void testToByteArrayResize() throws IOException {        int size = 8192 + 8192 + 10;        byte[] data = new byte[size];        for (int i = 0; i < size; i++) {            data[i] = 'A';        }        try (InputStream stream = new ByteArrayInputStream(data)) {            byte[] bytes = IOUtil.toByteArray(stream);            assertEquals(size, bytes.length);            assertArrayEquals(data, bytes);        }    }    @Test    void testSkipFully() throws IOException {        byte[] data = "12345".getBytes(StandardCharsets.UTF_8);        try (InputStream stream = new ByteArrayInputStream(data)) {            assertThrows(IllegalArgumentException.class, () -> IOUtil.skipFully(stream, -1));            assertEquals(3, IOUtil.skipFully(stream, 3));            byte[] bytes = IOUtil.toByteArray(stream);            assertEquals(2, bytes.length);            assertArrayEquals("45".getBytes(StandardCharsets.UTF_8), bytes);        }    }    @Test    void testSkipFully2() throws IOException {        byte[] data = "12345".getBytes(StandardCharsets.UTF_8);        try (InputStream stream = new ByteArrayInputStream(data)) {            // skip more bytes than the stream contains            assertEquals(data.length, IOUtil.skipFully(stream, data.length + 1));            byte[] bytes = IOUtil.toByteArray(stream);            assertEquals(0, bytes.length);        }    }    @Test    void testNormalizePath() {        if (SystemUtils.IS_OS_UNIX) {            assertEquals("ab/cd.txt", IOUtil.normalizePath("ab/ef/../cd.txt"));            assertEquals("/a.txt", IOUtil.normalizePath("/x/../../a.txt"));            assertEquals("/foo", IOUtil.normalizePath("//../foo"));            assertEquals("/foo", IOUtil.normalizePath("/foo//"));            assertEquals("/foo", IOUtil.normalizePath("/foo/./"));            assertEquals("/bar", IOUtil.normalizePath("/foo/../bar"));            assertEquals("/bar", IOUtil.normalizePath("/foo/../bar/"));            assertEquals("/baz", IOUtil.normalizePath("/foo/../bar/../baz"));            assertEquals("/foo/bar", IOUtil.normalizePath("//foo//./bar"));            assertEquals("foo", IOUtil.normalizePath("foo/bar/.."));            assertEquals("bar", IOUtil.normalizePath("foo/../bar"));            assertEquals("/foo/baz", IOUtil.normalizePath("//foo/bar/../baz"));            assertEquals("~/bar", IOUtil.normalizePath("~/foo/../bar/"));            assertEquals("/", IOUtil.normalizePath("/../"));            assertEquals("bar", IOUtil.normalizePath("~/../bar"));            assertEquals("bar", IOUtil.normalizePath("./bar"));            assertNull(IOUtil.normalizePath("../foo"));            assertNull(IOUtil.normalizePath("foo/../../bar"));            assertNull(IOUtil.normalizePath("."));            assertTrue(IOUtil.equalsNormalizedPaths("foo/../bar", "bar/./"));        }        if (SystemUtils.IS_OS_WINDOWS) {            assertEquals("ab\\cd.txt", IOUtil.normalizePath("ab\\ef\\..\\cd.txt"));            assertEquals("\\a.txt", IOUtil.normalizePath("\\x\\..\\..\\a.txt"));            assertEquals("\\foo", IOUtil.normalizePath("\\foo\\\\"));            assertEquals("\\foo", IOUtil.normalizePath("\\foo\\.\\"));            assertEquals("\\bar", IOUtil.normalizePath("\\foo\\..\\bar"));            assertEquals("\\bar", IOUtil.normalizePath("\\foo\\..\\bar\\"));            assertEquals("\\baz", IOUtil.normalizePath("\\foo\\..\\bar\\..\\baz"));            assertEquals("\\\\foo\\bar\\", IOUtil.normalizePath("\\\\foo\\bar"));            assertEquals("\\\\foo\\bar\\baz", IOUtil.normalizePath("\\\\foo\\bar\\..\\baz"));            assertEquals("foo", IOUtil.normalizePath("foo\\bar\\.."));            assertEquals("bar", IOUtil.normalizePath("foo\\..\\bar"));            assertEquals("\\foo\\baz", IOUtil.normalizePath("\\foo\\bar\\..\\baz"));            assertEquals("\\", IOUtil.normalizePath("\\..\\"));            assertEquals("bar", IOUtil.normalizePath(".\\bar"));            assertNull(IOUtil.normalizePath("\\\\..\\foo"));            assertNull(IOUtil.normalizePath("..\\foo"));            assertNull(IOUtil.normalizePath("foo\\..\\..\\bar"));            assertNull(IOUtil.normalizePath("."));            assertNull(IOUtil.normalizePath("\\\\foo\\\\.\\bar"));            assertNull(IOUtil.normalizePath("\\\\foo\\.\\bar"));            assertTrue(IOUtil.equalsNormalizedPaths("foo\\..\\bar", "bar\\.\\"));            assertEquals("C:\\bar", IOUtil.normalizePath("C:\\..\\bar"));            assertEquals("ab\\cd.txt", IOUtil.normalizePath("ab\\ef\\..\\cd.txt"));            assertEquals("C:\\ab\\cd.txt", IOUtil.normalizePath("C:\\ab\\ef\\..\\.\\cd.txt"));            assertNull(IOUtil.normalizePath("..\\foo"));            assertNull(IOUtil.normalizePath("foo\\..\\..\\bar"));        }    }    @Test    void testFilenameExtension() {        assertEquals("txt", IOUtil.getFilenameExtension("ab/cd.txt"));        assertEquals("txt", IOUtil.getFilenameExtension("ab.cd.txt"));        assertEquals("", IOUtil.getFilenameExtension("ab/cd"));        assertEquals("html", IOUtil.getFilenameExtension("cd.html"));    }    @Test    void testFilenameBase() {        assertEquals("cd", IOUtil.getFilenameBase("ab/cd.txt"));        assertEquals("ab.cd", IOUtil.getFilenameBase("ab.cd.txt"));        assertEquals("cd", IOUtil.getFilenameBase("ab/cd"));    }    @Test    void testBomAwareStream() throws IOException {        assertBomStream("No BOM".getBytes(StandardCharsets.UTF_8), "No BOM", null);        assertBomStream("\ufeffBOM".getBytes(StandardCharsets.UTF_8), "BOM", StandardCharsets.UTF_8.name());        assertBomStream("\ufeffBOM".getBytes(StandardCharsets.UTF_16LE), "BOM", StandardCharsets.UTF_16LE.name());        assertBomStream("\ufeffBOM".getBytes(StandardCharsets.UTF_16BE), "BOM", StandardCharsets.UTF_16BE.name());    }    private void assertBomStream(byte[] data, String expectedData, String expectedCharset) throws IOException {        try (IOUtil.BomAwareInputStream stream = new IOUtil.BomAwareInputStream(new ByteArrayInputStream(data))) {            if (expectedCharset != null) {                assertTrue(stream.hasBom());                assertEquals(expectedCharset, stream.getBomCharsetName());                assertEquals(expectedData, new String(IOUtil.toByteArray(stream), stream.getBomCharsetName()));            } else {                assertFalse(stream.hasBom());                assertNull(stream.getBomCharsetName());                assertEquals(expectedData, new String(IOUtil.toByteArray(stream), StandardCharsets.UTF_8));            }        }    }    @Test    void testOutputStreamFromWriter() throws IOException {        StringWriter writer = new StringWriter();        try (OutputStream outputStream = IOUtil.fromWriter(writer, "UTF-8")) {            outputStream.write("abc".getBytes(StandardCharsets.UTF_8));        }        assertEquals("abc", writer.toString());    }    @Test    void testInputStreamFromReader() throws IOException {        try (InputStream inputStream = IOUtil.fromReader(new StringReader("abc"))) {            byte[] bytes = IOUtil.toByteArray(inputStream);            assertEquals("abc", new String(bytes, StandardCharsets.UTF_8));        }    }    @Test    void testInputStreamFromReader2() throws IOException {        int size = 8192 + 8192 + 10;        char[] data = new char[size];        for (int i = 0; i < size; i++) {            data[i] = 'A';        }        data[8192] = 'ä'; // block size border - in UTF-8 these are two bytes. Decoding needs to take the bytes        // from previous block and new block        try (InputStream inputStream = IOUtil.fromReader(new StringReader(new String(data)))) {            byte[] bytes = IOUtil.toByteArray(inputStream);            assertEquals(new String(data), new String(bytes, StandardCharsets.UTF_8));        }    }    @Test    void testCopyStream() throws IOException {        int size = 8192 + 8192 + 10;        byte[] data = new byte[size];        for (int i = 0; i < size; i++) {            data[i] = 'A';        }        try (InputStream stream = new ByteArrayInputStream(data);             ByteArrayOutputStream out = new ByteArrayOutputStream()) {            IOUtil.copy(stream, out);            byte[] bytes = out.toByteArray();            assertEquals(size, bytes.length);            assertArrayEquals(data, bytes);        }    }    @Test    void testCopyReader() throws IOException {        int size = 8192 + 8192 + 10;        char[] data = new char[size];        for (int i = 0; i < size; i++) {            data[i] = 'A';        }        try (Reader reader = new CharArrayReader(data);             StringWriter writer = new StringWriter()) {            IOUtil.copy(reader, writer);            char[] chars = writer.toString().toCharArray();            assertEquals(size, chars.length);            assertArrayEquals(data, chars);        }    }    @Test    void testReadEmptyStream() throws IOException {        try (InputStream in = new ByteArrayInputStream(new byte[0])) {            byte[] bytes = IOUtil.toByteArray(in);            assertNotNull(bytes);            assertEquals(0, bytes.length);        }    }    @Test    void testCloseQuietly() {        class Stream extends InputStream {            private boolean closed = false;            @Override            public int read() throws IOException {                return 0;            }            @Override            public void close() throws IOException {                closed = true;                throw new IOException("test");            }            public boolean isClosed() {                return closed;            }        }        Stream stream = new Stream();        IOUtil.closeQuietly(stream);        assertTrue(stream.isClosed());    }    @Test    void testReadFileToString() throws IOException {        String testString = "Test ABC";        Path tempFile = Files.createTempFile("pmd", ".txt");        Files.write(tempFile, testString.getBytes(Charset.defaultCharset()));        assertEquals(testString, IOUtil.readFileToString(tempFile.toFile()));    }    @Test    void testReadToString() throws IOException {        String testString = "testReadToString";        Reader reader = new StringReader(testString);        assertEquals(testString, IOUtil.readToString(reader));    }    @Test    void testReadStreamToString() throws IOException {        String testString = "testReadStreamToString";        InputStream stream = new ByteArrayInputStream(testString.getBytes(StandardCharsets.UTF_8));        assertEquals(testString, IOUtil.readToString(stream, StandardCharsets.UTF_8));    }    @Test    void testCreateWriterStdout() throws IOException {        PrintStream originalOut = System.out;        ByteArrayOutputStream data = new ByteArrayOutputStream();        PrintStream out = new PrintStream(new FilterOutputStream(data) {            @Override            public void close() {                fail("Stream must not be closed");            }        });        try {            System.setOut(out);            Writer writer = IOUtil.createWriter();            writer.write("Test");            writer.close();            assertEquals("Test", data.toString());        } finally {            System.setOut(originalOut);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static net.sourceforge.pmd.util.OptionalBool.NO;import static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;import static net.sourceforge.pmd.util.OptionalBool.YES;import static net.sourceforge.pmd.util.OptionalBool.definitely;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class OptionalBoolTest {    @Test    void testDefinitely() {        assertEquals(YES, definitely(true));        assertEquals(NO, definitely(false));    }    @Test    void testIsKnown() {        assertTrue(YES.isKnown());        assertTrue(NO.isKnown());        assertFalse(UNKNOWN.isKnown());    }    @Test    void testIsTrue() {        assertTrue(YES.isTrue());        assertFalse(NO.isTrue());        assertFalse(UNKNOWN.isTrue());    }    @Test    void testComplement() {        assertEquals(YES, NO.complement());        assertEquals(NO, YES.complement());        assertEquals(UNKNOWN, UNKNOWN.complement());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.Collections;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.document.Chars;/** * @author Clément Fournier */class CollectionUtilTest {    @Test    void testJoinOn() {        testJoinOn(listOf("a", "b", "c"), ".",                   "a.b.c");        testJoinOn(Collections.emptyList(), ".",                   "");    }    private void testJoinOn(List<String> toJoin, String delimiter, String expected) {        String actual = CollectionUtil.joinCharsIntoStringBuilder(            CollectionUtil.map(toJoin, Chars::wrap),            delimiter        ).toString();        assertEquals(expected, actual);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.document.Chars;class StringUtilTest {    @Test    void testColumnNumber() {        assertEquals(-1, StringUtil.columnNumberAt("f\rah\nb", -1));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 0));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 1));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 2));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 3));        assertEquals(3, StringUtil.columnNumberAt("f\rah\nb", 4));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 5));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 6));        assertEquals(-1, StringUtil.columnNumberAt("f\rah\nb", 7));    }    @Test    void testColumnNumberCrLf() {        assertEquals(-1, StringUtil.columnNumberAt("f\r\nb", -1));        assertEquals(1, StringUtil.columnNumberAt("f\r\nb", 0));        assertEquals(2, StringUtil.columnNumberAt("f\r\nb", 1));        assertEquals(3, StringUtil.columnNumberAt("f\r\nb", 2));        assertEquals(1, StringUtil.columnNumberAt("f\r\nb", 3));        assertEquals(2, StringUtil.columnNumberAt("f\r\nb", 4));        assertEquals(-1, StringUtil.columnNumberAt("f\r\nb", 5));    }    @Test    void testColumnNumberTrailing() {        assertEquals(1, StringUtil.columnNumberAt("\n", 0));        assertEquals(2, StringUtil.columnNumberAt("\n", 1));        assertEquals(-1, StringUtil.columnNumberAt("\n", 2));    }    @Test    void testColumnNumberEmpty() {        assertEquals(1, StringUtil.columnNumberAt("", 0));        assertEquals(-1, StringUtil.columnNumberAt("", 1));    }    @Test    void testUTF8NotSupported() {        StringBuilder sb = new StringBuilder();        String test = "é";        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#xe9;", sb.toString());    }    @Test    void testUTF8NotSupportedSurrogates() {        // D8 34 DD 1E -> U+1D11E        StringBuilder sb = new StringBuilder();        String test = new String(new char[] {0xd834, 0xdd1e});        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#x1d11e;", sb.toString());    }    @Test    void testUTF8Supported() {        StringBuilder sb = new StringBuilder();        String test = "é";        StringUtil.appendXmlEscaped(sb, test, true);        assertEquals("é", sb.toString());    }    @Test    void testRemoveSurrounding() {        assertThat(StringUtil.removeSurrounding("", 'q'), equalTo(""));        assertThat(StringUtil.removeSurrounding("q", 'q'), equalTo("q"));        assertThat(StringUtil.removeSurrounding("qq", 'q'), equalTo(""));        assertThat(StringUtil.removeSurrounding("qqq", 'q'), equalTo("q"));    }    @Test    public void testTrimIndent() {        assertTrimIndent(" \n b \n c",                         "\nb\nc");        assertTrimIndent(" \nb \n c",                         "\nb\n c");        assertTrimIndent(" \n b \n c\n  ",                         "\nb\nc\n");        assertTrimIndent("", "");    }    private void assertTrimIndent(String input, String output) {        String actual = StringUtil.trimIndent(Chars.wrap(input)).toString();        assertThat(actual, equalTo(output));    }    @Test    void testElide() {        assertThat(StringUtil.elide("abc", 2, ""), equalTo("ab"));        assertThat(StringUtil.elide("abc", 2, "."), equalTo("a."));        assertThat(StringUtil.elide("abc", 2, ".."), equalTo(".."));        assertThat(StringUtil.elide("abc", 3, ".."), equalTo("abc"));    }    @Test    public void substringAfterLast() {        assertEquals("abc", StringUtil.substringAfterLast("a.abc", '.'));        assertEquals("abc", StringUtil.substringAfterLast("abc", '.'));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.internal.util;import static java.util.Collections.emptyIterator;import static java.util.Collections.emptyList;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.collection.IsIterableContainingInOrder.contains;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.NoSuchElementException;import java.util.Objects;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import org.junit.jupiter.api.Test;class IteratorUtilTest {    @Test    void testAnyMatchPos() {        Iterator<String> iter = iterOf("a", "b", "cd");        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    void testAnyMatchNeg() {        Iterator<String> iter = iterOf("a", "b", "");        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    void testAnyMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    void testAllMatchPos() {        Iterator<String> iter = iterOf("ap", "bcd", "cd");        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    void testAllMatchNeg() {        Iterator<String> iter = iterOf("a", "bcd", "");        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    void testAllMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    void testNoneMatchPos() {        Iterator<String> iter = iterOf("ap", "bcd", "cd");        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertTrue(match);    }    @Test    void testNoneMatchNeg() {        Iterator<String> iter = iterOf("a", "bcd", "");        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertFalse(match);    }    @Test    void testNoneMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertTrue(match);    }    @Test    void testFlatmap() {        Iterator<String> iter = iterOf("ab", "cd", "e", "", "f");        Function<String, Iterator<String>> fun = s -> s.chars().mapToObj(i -> (char) i).map(String::valueOf).iterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertThat(() -> mapped, contains("a", "b", "c", "d", "e", "f"));    }    @Test    void testFlatmapEmpty() {        Iterator<String> iter = emptyIterator();        Function<String, Iterator<String>> fun = s -> s.chars().mapToObj(i -> (char) i).map(String::valueOf).iterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    void testFlatmapEmpty2() {        Iterator<String> iter = iterOf("ab", "cd", "e", "", "f");        Function<String, Iterator<String>> fun = s -> emptyIterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    void testFlatmapIsLazy() {        Iterator<String> iter = iterOf("a", "b");        Function<String, Iterator<String>> fun = s -> {            if (s.equals("a")) {                return iterOf("a");            } else {                throw new AssertionError("This statement shouldn't be reached");            }        };        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertTrue(mapped.hasNext());        assertEquals("a", mapped.next());        assertThrows(AssertionError.class, () -> mapped.hasNext());    }    @Test    void testFlatmapWithSelf() {        Iterator<String> iter = iterOf("ab", "e", null, "f");        Function<String, Iterator<String>> fun = s -> s == null ? null // test null safety                                                                : iterOf(s + "1", s + "2");        Iterator<String> mapped = IteratorUtil.flatMapWithSelf(iter, fun);        assertThat(IteratorUtil.toList(mapped), contains("ab", "ab1", "ab2", "e", "e1", "e2", null, "f", "f1", "f2"));    }    @Test    void testMapNotNull() {        Iterator<String> iter = iterOf("ab", "cdde", "e", "", "f", "fe");        Function<String, Integer> fun = s -> s.length() < 2 ? null : s.length();        Iterator<Integer> mapped = IteratorUtil.mapNotNull(iter, fun);        assertThat(() -> mapped, contains(2, 4, 2));    }    @Test    void testMapNotNullEmpty() {        Iterator<String> iter = emptyIterator();        Function<String, Integer> fun = s -> s.length() < 2 ? null : s.length();        Iterator<Integer> mapped = IteratorUtil.mapNotNull(iter, fun);        assertExhausted(mapped);    }    @Test    void testMapNotNullEmpty2() {        Iterator<String> iter = iterOf("a", "b");        Function<String, Iterator<String>> fun = s -> null;        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    void testFilterNotNull() {        Iterator<String> iter = iterOf("ab", null, "e", null, "", "fe");        Iterator<String> mapped = IteratorUtil.filterNotNull(iter);        assertThat(() -> mapped, contains("ab", "e", "", "fe"));        assertExhausted(iter);    }    @Test    void testDistinct() {        Iterator<String> iter = iterOf("ab", null, "e", null, "fe", "ab", "c");        Iterator<String> mapped = IteratorUtil.distinct(iter);        assertThat(() -> mapped, contains("ab", null, "e", "fe", "c"));        assertExhausted(iter);    }    @Test    void testTakeWhile() {        Iterator<String> iter = iterOf("ab", "null", "e", null, "", "fe");        Predicate<String> predicate = Objects::nonNull;        Iterator<String> mapped = IteratorUtil.takeWhile(iter, predicate);        assertThat(() -> mapped, contains("ab", "null", "e"));        assertExhausted(mapped);    }    @Test    void testTakeWhileWithEmpty() {        Iterator<String> iter = iterOf();        Predicate<String> predicate = Objects::nonNull;        Iterator<String> mapped = IteratorUtil.takeWhile(iter, predicate);        assertExhausted(mapped);    }    @Test    void testPeek() {        Iterator<String> iter = iterOf("ab", null, "c");        List<String> seen = new ArrayList<>();        Consumer<String> action = seen::add;        Iterator<String> mapped = IteratorUtil.peek(iter, action);        assertEquals("ab", mapped.next());        assertThat(seen, contains("ab"));        assertNull(mapped.next());        assertThat(seen, contains("ab", null));        assertEquals("c", mapped.next());        assertThat(seen, contains("ab", null, "c"));        assertExhausted(mapped);    }    @Test    void testTakeNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        assertThrows(IllegalArgumentException.class, () -> IteratorUtil.take(iter, -5));    }    @Test    void testTake0() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 0);        assertExhausted(mapped);    }    @Test    void testTake() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 1);        assertThat(() -> mapped, contains("a"));        assertExhausted(mapped);    }    @Test    void testTakeOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 12);        assertThat(() -> mapped, contains("a", "b", "c"));        assertExhausted(mapped);    }    @Test    void testDropNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        assertThrows(IllegalArgumentException.class, () -> IteratorUtil.advance(iter, -5));    }    @Test    void testDrop0() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 0);        assertThat(() -> mapped, contains("a", "b", "c"));        assertExhausted(mapped);    }    @Test    void testDrop() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 1);        assertThat(() -> mapped, contains("b", "c"));        assertExhausted(mapped);    }    @Test    void testDropOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 12);        assertExhausted(mapped);    }    @Test    void testGetNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        assertThrows(IllegalArgumentException.class, () -> IteratorUtil.getNth(iter, -5));    }    @Test    void testGet0() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 0);        assertEquals("a", elt);    }    @Test    void testGetNth() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 1);        assertEquals("b", elt);    }    @Test    void testGetOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 12);        assertNull(elt);    }    @Test    void testLast() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.last(iter);        assertEquals("c", elt);        assertExhausted(iter);    }    @Test    void testLastEmpty() {        Iterator<String> iter = emptyIterator();        String elt = IteratorUtil.last(iter);        assertNull(elt);    }    @Test    void testCount() {        Iterator<String> iter = iterOf("a", "b", "c");        int size = IteratorUtil.count(iter);        assertEquals(size, 3);        assertExhausted(iter);    }    @Test    void testCountEmpty() {        Iterator<String> iter = emptyIterator();        int size = IteratorUtil.count(iter);        assertEquals(size, 0);    }    @Test    void testToList() {        Iterator<String> iter = iterOf("a", "b", "c");        List<String> lst = IteratorUtil.toList(iter);        assertEquals(lst, listOf("a", "b", "c"));        assertExhausted(iter);    }    @Test    void testAsReversed() {        List<String> iter = listOf("a", "b", "c");        Iterable<String> mapped = IteratorUtil.asReversed(iter);        assertThat(mapped, contains("c", "b", "a"));    }    @Test    void testAsReversedIsRepeatable() {        List<String> iter = listOf("a", "b", "c");        Iterable<String> mapped = IteratorUtil.asReversed(iter);        // doesn't exhaust iterator        assertThat(mapped, contains("c", "b", "a"));        assertThat(mapped, contains("c", "b", "a"));        assertThat(mapped, contains("c", "b", "a"));    }    @Test    void testDropLast() {        Iterator<String> iter = iterOf("ab", "cdde", "e", "", "f", "fe");        Iterator<String> dropped = IteratorUtil.dropLast(iter, 2);        assertEquals(listOf("ab", "cdde", "e", ""), IteratorUtil.toList(dropped));    }    @Test    void testDropLastOne() {        Iterator<String> iter = iterOf("ab", "cdde", "e", "", "f", "fe");        Iterator<String> dropped = IteratorUtil.dropLast(iter, 1);        assertEquals(listOf("ab", "cdde", "e", "", "f"), IteratorUtil.toList(dropped));    }    @Test    void testDropMoreThanSize() {        Iterator<String> iter = iterOf("ab", "c");        Iterator<String> dropped = IteratorUtil.dropLast(iter, 4);        assertEquals(emptyList(), IteratorUtil.toList(dropped));    }    @Test    void testDropLastZero() {        Iterator<String> iter = iterOf("ab", "c");        Iterator<String> dropped = IteratorUtil.dropLast(iter, 0);        assertEquals(listOf("ab", "c"), IteratorUtil.toList(dropped));    }    @Test    void testDropLastNegative() {        Iterator<String> iter = iterOf("ab", "c");        assertThrows(IllegalArgumentException.class, () -> IteratorUtil.dropLast(iter, -3));    }    private void assertExhausted(Iterator<?> mapped) {        assertFalse(mapped.hasNext());        assertThrows(NoSuchElementException.class, () -> mapped.next());    }    static <T> Iterator<T> iterOf(T... ts) {        return Arrays.asList(ts).iterator();    }    static <T> List<T> listOf(T... ts) {        return Arrays.asList(ts);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.processor;import static org.hamcrest.CoreMatchers.instanceOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.hasSize;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.Mockito.contains;import static org.mockito.Mockito.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.spy;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import java.util.List;import java.util.function.BiConsumer;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import org.slf4j.event.Level;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.GlobalReportBuilderListener;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.internal.SystemProps;import net.sourceforge.pmd.internal.util.ContextedAssertionError;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule.Handler;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.Parser;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.processor.MonoThreadProcessor.MonothreadRunnable;import net.sourceforge.pmd.util.log.MessageReporter;import com.github.stefanbirkner.systemlambda.SystemLambda;public class PmdRunnableTest {    public static final String TEST_MESSAGE_SEMANTIC_ERROR = "An error occurred!";    private static final String PARSER_REPORTS_SEMANTIC_ERROR = "1.9-semantic_error";    private static final String THROWS_SEMANTIC_ERROR = "1.9-throws_semantic_error";    private static final String THROWS_ASSERTION_ERROR = "1.9-throws";    private PMDConfiguration configuration;    private PmdRunnable pmdRunnable;    private MessageReporter reporter;    private Rule rule;    @BeforeEach    public void prepare() {        // reset data        rule = spy(new RuleThatThrows());        configuration = new PMDConfiguration();        reporter = mock(MessageReporter.class);        configuration.setReporter(reporter);        // will be populated by a call to process(LanguageVersion)        pmdRunnable = null;    }    private Report process(LanguageVersion lv) {        TextFile dataSource = TextFile.forCharSeq("test", "test.dummy", lv);        GlobalReportBuilderListener reportBuilder = new GlobalReportBuilderListener();        pmdRunnable = new MonothreadRunnable(new RuleSets(RuleSet.forSingleRule(rule)),                                             dataSource,                                             reportBuilder,                                             configuration);        pmdRunnable.run();        reportBuilder.close();        return reportBuilder.getResult();    }    @Test    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() throws Exception {        SystemLambda.restoreSystemProperties(() -> {            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, "");            Report report = process(versionWithParserThatThrowsAssertionError());            assertEquals(1, report.getProcessingErrors().size());        });    }    @Test    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() throws Exception {        SystemLambda.restoreSystemProperties(() -> {            System.setProperty(SystemProps.PMD_ERROR_RECOVERY, "");            Report report = process(DummyLanguageModule.getInstance().getDefaultVersion());            List<ProcessingError> errors = report.getProcessingErrors();            assertThat(errors, hasSize(1));            assertThat(errors.get(0).getError(), instanceOf(ContextedAssertionError.class));        });    }    @Test    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() throws Exception {        SystemLambda.restoreSystemProperties(() -> {            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);            assertThrows(AssertionError.class, () -> process(versionWithParserThatThrowsAssertionError()));        });    }    @Test    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() throws Exception {        SystemLambda.restoreSystemProperties(() -> {            System.clearProperty(SystemProps.PMD_ERROR_RECOVERY);            assertThrows(AssertionError.class, () -> process(DummyLanguageModule.getInstance().getDefaultVersion()));        });    }    @Test    public void semanticErrorShouldAbortTheRun() {        Report report = process(versionWithParserThatReportsSemanticError());        verify(reporter, times(1))            .log(eq(Level.ERROR), eq("at !debug only! test.dummy:1:1: " + TEST_MESSAGE_SEMANTIC_ERROR));        verify(rule, never()).apply(Mockito.any(), Mockito.any());        assertEquals(1, report.getProcessingErrors().size());    }    @Test    public void semanticErrorThrownShouldAbortTheRun() {        Report report = process(getVersionWithParserThatThrowsSemanticError());        verify(reporter, times(1)).log(eq(Level.ERROR), contains(TEST_MESSAGE_SEMANTIC_ERROR));        verify(rule, never()).apply(Mockito.any(), Mockito.any());        assertEquals(1, report.getProcessingErrors().size());    }    public static void registerCustomVersions(BiConsumer<String, Handler> addVersion) {        addVersion.accept(THROWS_ASSERTION_ERROR, new HandlerWithParserThatThrows());        addVersion.accept(PARSER_REPORTS_SEMANTIC_ERROR, new HandlerWithParserThatReportsSemanticError());        addVersion.accept(THROWS_SEMANTIC_ERROR, new HandlerWithParserThatThrowsSemanticError());    }    public static LanguageVersion versionWithParserThatThrowsAssertionError() {        return DummyLanguageModule.getInstance().getVersion(THROWS_ASSERTION_ERROR);    }    public static LanguageVersion getVersionWithParserThatThrowsSemanticError() {        return DummyLanguageModule.getInstance().getVersion(THROWS_SEMANTIC_ERROR);    }    public static LanguageVersion versionWithParserThatReportsSemanticError() {        return DummyLanguageModule.getInstance().getVersion(PARSER_REPORTS_SEMANTIC_ERROR);    }    private static class RuleThatThrows extends AbstractRule {        RuleThatThrows() {            Language dummyLanguage = DummyLanguageModule.getInstance();            setLanguage(dummyLanguage);        }        @Override        public void apply(Node target, RuleContext ctx) {            throw new AssertionError("test");        }    }    public static class HandlerWithParserThatThrowsSemanticError extends Handler {        @Override        public Parser getParser() {            return task -> {                RootNode root = super.getParser().parse(task);                throw task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);            };        }    }    public static class HandlerWithParserThatThrows extends Handler {        @Override        public Parser getParser() {            return task -> {                throw new AssertionError("test error while parsing");            };        }    }    public static class HandlerWithParserThatReportsSemanticError extends Handler {        @Override        public Parser getParser() {            return task -> {                RootNode root = super.getParser().parse(task);                task.getReporter().error(root, TEST_MESSAGE_SEMANTIC_ERROR);                return root;            };        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.processor;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.Report.GlobalReportBuilderListener;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.reporting.FileAnalysisListener;import net.sourceforge.pmd.reporting.GlobalAnalysisListener;class MultiThreadProcessorTest {    private GlobalAnalysisListener listener;    private List<TextFile> files;    private SimpleReportListener reportListener;    private PMDConfiguration configuration;    RuleSets setUpForTest(final String ruleset) {        configuration = new PMDConfiguration();        configuration.setThreads(2);        LanguageVersion lv = DummyLanguageModule.getInstance().getDefaultVersion();        files = listOf(            TextFile.forCharSeq("abc", "file1-violation.dummy", lv),            TextFile.forCharSeq("DEF", "file2-foo.dummy", lv)        );        reportListener = new SimpleReportListener();        listener = GlobalAnalysisListener.tee(listOf(            new GlobalReportBuilderListener(),            reportListener        ));        return new RuleSets(new RuleSetLoader().loadFromResource(ruleset));    }    // Dysfunctional rules are pruned upstream of the processor.    //    //    @Test    //    void testRulesDysnfunctionalLog() throws Exception {    //        RuleSets ruleSets = setUpForTest("rulesets/MultiThreadProcessorTest/dysfunctional.xml");    //        final SimpleRenderer renderer = new SimpleRenderer(null, null);    //        renderer.start();    //        processor.processFiles(ruleSets, files, listener);    //        renderer.end();    //    //        final Iterator<ConfigurationError> configErrors = renderer.getReport().getConfigurationErrors().iterator();    //        final ConfigurationError error = configErrors.next();    //    //        assertEquals("Dysfunctional rule message not present",    //                DysfunctionalRule.DYSFUNCTIONAL_RULE_REASON, error.issue());    //        assertEquals("Dysfunctional rule is wrong",    //                DysfunctionalRule.class, error.rule().getClass());    //        assertFalse("More configuration errors found than expected", configErrors.hasNext());    //    }    @Test    void testRulesThreadSafety() throws Exception {        RuleSets ruleSets = setUpForTest("rulesets/MultiThreadProcessorTest/basic.xml");        try (AbstractPMDProcessor processor = AbstractPMDProcessor.newFileProcessor(configuration)) {            processor.processFiles(ruleSets, files, listener);        }        listener.close();        // if the rule is not executed, then maybe a        // ConcurrentModificationException happened        assertEquals(2, NotThreadSafeRule.count.get(), "Test rule has not been executed");        // if the violation is not reported, then the rule instances have been        // shared between the threads        assertEquals(1, reportListener.violations.get(), "Missing violation");    }    public static class NotThreadSafeRule extends AbstractRule {        public static AtomicInteger count = new AtomicInteger(0);        private boolean hasViolation; // this variable will be overridden        // between the threads        @Override        public void apply(Node target, RuleContext ctx) {            count.incrementAndGet();            if (target.getTextDocument().getDisplayName().contains("violation")) {                hasViolation = true;            } else {                letTheOtherThreadRun(10);                hasViolation = false;            }            letTheOtherThreadRun(100);            if (hasViolation) {                addViolation(ctx, target);            }        }        private void letTheOtherThreadRun(int millis) {            try {                Thread.yield();                Thread.sleep(millis);            } catch (InterruptedException e) {                // ignored            }        }    }    public static class DysfunctionalRule extends AbstractRule {        public static final String DYSFUNCTIONAL_RULE_REASON = "dysfunctional rule is dysfunctional";        @Override        public void apply(Node target, RuleContext ctx) {            // noop        }        @Override        public String dysfunctionReason() {            return DYSFUNCTIONAL_RULE_REASON;        }    }    private static class SimpleReportListener implements GlobalAnalysisListener {        public AtomicInteger violations = new AtomicInteger(0);        @Override        public FileAnalysisListener startFileAnalysis(TextFile file) {            return new FileAnalysisListener() {                @Override                public void onRuleViolation(RuleViolation violation) {                    violations.incrementAndGet();                }            };        }        @Override        public void close() throws Exception {        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.processor;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.spy;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.PmdAnalysis;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.cache.AnalysisCache;import net.sourceforge.pmd.cache.NoopAnalysisCache;import net.sourceforge.pmd.lang.ast.FileAnalysisException;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.reporting.GlobalAnalysisListener;import net.sourceforge.pmd.reporting.GlobalAnalysisListener.ViolationCounterListener;class GlobalListenerTest {    static final int NUM_DATA_SOURCES = 3;    @Test    void testViolationCounter() throws Exception {        PMDConfiguration config = newConfig();        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();        MyFooRule mockrule = Mockito.spy(MyFooRule.class);        runPmd(config, listener, mockrule);        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());        assertEquals(2, (int) listener.getResult());    }    @Test    void testViolationCounterOnMulti() throws Exception {        PMDConfiguration config = newConfig();        config.setThreads(2);        ViolationCounterListener listener = new GlobalAnalysisListener.ViolationCounterListener();        MyFooRule mockrule = Mockito.spy(MyFooRule.class);        when(mockrule.deepCopy()).thenReturn(mockrule); // the spy cannot track the deep copies        runPmd(config, listener, mockrule);        Mockito.verify(mockrule, times(NUM_DATA_SOURCES)).apply(any(), any());        assertEquals(2, (int) listener.getResult());    }    @Test    void testAnalysisCache() throws Exception {        PMDConfiguration config = newConfig();        AnalysisCache mockCache = spy(NoopAnalysisCache.class);        config.setAnalysisCache(mockCache);        MyFooRule rule = new MyFooRule();        runPmd(config, GlobalAnalysisListener.noop(), rule);        verify(mockCache).checkValidity(any(), any());        verify(mockCache, times(1)).persist();        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());    }    @Test    void testCacheWithFailure() throws Exception {        PMDConfiguration config = newConfig();        AnalysisCache mockCache = spy(NoopAnalysisCache.class);        config.setAnalysisCache(mockCache);        BrokenRule rule = new BrokenRule();  // the broken rule throws        runPmd(config, GlobalAnalysisListener.noop(), rule);        // cache methods are called regardless        verify(mockCache).checkValidity(any(), any());        verify(mockCache, times(1)).persist();        verify(mockCache, times(NUM_DATA_SOURCES)).isUpToDate(any());    }    @Test    void testCacheWithPropagatedException() throws Exception {        PMDConfiguration config = newConfig();        AnalysisCache mockCache = spy(NoopAnalysisCache.class);        config.setAnalysisCache(mockCache);        BrokenRule rule = new BrokenRule();  // the broken rule throws        // now the exception should be propagated        GlobalAnalysisListener listener = GlobalAnalysisListener.exceptionThrower();        FileAnalysisException exception = assertThrows(FileAnalysisException.class, () -> {            runPmd(config, listener, rule);        });        assertEquals("fname1.dummy", exception.getFileName());        // cache methods are called regardless        verify(mockCache).checkValidity(any(), any());        verify(mockCache, times(1)).persist();        verify(mockCache, times(1)).isUpToDate(any());    }    @NonNull    private PMDConfiguration newConfig() {        PMDConfiguration config = new PMDConfiguration();        config.setAnalysisCache(new NoopAnalysisCache());        config.setIgnoreIncrementalAnalysis(true);        config.setThreads(1);        return config;    }    private void runPmd(PMDConfiguration config, GlobalAnalysisListener listener, Rule rule) {        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            pmd.addRuleSet(RuleSet.forSingleRule(rule));            pmd.files().addSourceFile("fname1.dummy", "abc");            pmd.files().addSourceFile("fname2.dummy", "abcd");            pmd.files().addSourceFile("fname21.dummy", "abcd");            pmd.addListener(listener);            pmd.performAnalysis();        }    }    public static class MyFooRule extends FooRule {        @Override        public void apply(Node node, RuleContext ctx) {            if (node.getTextDocument().getDisplayName().contains("1")) {                ctx.addViolation(node);            }        }    }    public static class BrokenRule extends FooRule {        @Override        public void apply(Node node, RuleContext ctx) {            throw new IllegalArgumentException("Something happened");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache.internal;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.util.zip.Adler32;import java.util.zip.Checksum;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import java.util.zip.ZipOutputStream;import org.junit.jupiter.api.Test;class ZipFileFingerprinterTest extends AbstractClasspathEntryFingerprinterTest {    @Test    void zipEntryMetadataDoesNotAffectFingerprint() throws IOException {        final File file = createValidNonEmptyFile();        final long baselineFingerprint = getBaseLineFingerprint(file);        final long originalFileSize = file.length();        // Change zip entry's metadata        try (ZipFile zip = new ZipFile(file)) {            final ZipEntry zipEntry = zip.entries().nextElement();            zipEntry.setComment("some comment");            zipEntry.setTime(System.currentTimeMillis() + 1000);            overwriteZipFileContents(file, zipEntry);        }        assertEquals(baselineFingerprint, updateFingerprint(file));        assertNotEquals(originalFileSize, file.length());    }    @Override    protected ClasspathEntryFingerprinter newFingerPrinter() {        return new ZipFileFingerprinter();    }    @Override    protected String[] getValidFileExtensions() {        return new String[] { "zip", "jar" };    }    @Override    protected String[] getInvalidFileExtensions() {        return new String[] { "xml" };    }    @Override    protected File createValidNonEmptyFile() throws IOException {        final File zipFile = tempDir.resolve("foo.jar").toFile();        overwriteZipFileContents(zipFile, new ZipEntry("lib/Foo.class"));        return zipFile;    }    private void overwriteZipFileContents(final File zipFile, final ZipEntry... zipEntries) throws IOException {        try (ZipOutputStream zipOS = new ZipOutputStream(Files.newOutputStream(zipFile.toPath()))) {            for (final ZipEntry zipEntry : zipEntries) {                zipOS.putNextEntry(zipEntry);                zipOS.write("content of zip entry".getBytes(StandardCharsets.UTF_8));                zipOS.closeEntry();            }        }    }    private long getBaseLineFingerprint(final File file) throws MalformedURLException, IOException {        final Checksum checksum = new Adler32();        fingerprinter.fingerprint(file.toURI().toURL(), checksum);        return checksum.getValue();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache.internal;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import com.google.common.io.Files;class RawFileFingerprinterTest extends AbstractClasspathEntryFingerprinterTest {    @Override    protected ClasspathEntryFingerprinter newFingerPrinter() {        return new RawFileFingerprinter();    }    @Override    protected String[] getValidFileExtensions() {        return new String[] { "class" };    }    @Override    protected String[] getInvalidFileExtensions() {        return new String[] { "xml" };    }    @Override    protected File createValidNonEmptyFile() throws IOException {        File file = tempDir.resolve("Foo.class").toFile();        Files.write("some content", file, StandardCharsets.UTF_8);        return file;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache.internal;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.nio.file.Path;import java.util.zip.Adler32;import java.util.zip.Checksum;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.TestInstance;import org.junit.jupiter.api.io.TempDir;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.MethodSource;@TestInstance(TestInstance.Lifecycle.PER_CLASS)abstract class AbstractClasspathEntryFingerprinterTest {    @TempDir    Path tempDir;    protected ClasspathEntryFingerprinter fingerprinter = newFingerPrinter();    protected Checksum checksum = new Adler32();    @BeforeEach    void setUp() {        checksum.reset();    }    protected abstract ClasspathEntryFingerprinter newFingerPrinter();    protected abstract String[] getValidFileExtensions();    protected abstract String[] getInvalidFileExtensions();    protected abstract File createValidNonEmptyFile() throws IOException;    @Test    void appliesToNullIsSafe() {        fingerprinter.appliesTo(null);    }    @ParameterizedTest    @MethodSource("getValidFileExtensions")    void appliesToValidFile(final String extension) {        assertTrue(fingerprinter.appliesTo(extension));    }    @ParameterizedTest    @MethodSource("getInvalidFileExtensions")    void doesNotApplyToInvalidFile(final String extension) {        assertFalse(fingerprinter.appliesTo(extension));    }    @Test    void fingerprintNonExistingFile() throws MalformedURLException, IOException {        final long prevValue = checksum.getValue();        fingerprinter.fingerprint(new File("non-existing").toURI().toURL(), checksum);        assertEquals(prevValue, checksum.getValue());    }    @Test    void fingerprintExistingValidFile() throws IOException {        final long prevValue = checksum.getValue();        final File file = createValidNonEmptyFile();        assertNotEquals(prevValue, updateFingerprint(file));    }    protected long updateFingerprint(final File file) throws MalformedURLException, IOException {        fingerprinter.fingerprint(file.toURI().toURL(), checksum);        return checksum.getValue();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache;import static com.github.stefanbirkner.systemlambda.SystemLambda.restoreSystemProperties;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.fail;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Collections;import java.util.List;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import org.mockito.Mockito;import net.sourceforge.pmd.PmdCoreTestUtils;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextDocument;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.document.TextFileContent;import net.sourceforge.pmd.lang.document.TextRange2d;class FileAnalysisCacheTest {    @TempDir    private Path tempFolder;    private File unexistingCacheFile;    private File newCacheFile;    private File emptyCacheFile;    private TextDocument sourceFile;    private TextFile sourceFileBackend;    private final LanguageVersion dummyVersion = PmdCoreTestUtils.dummyVersion();    @BeforeEach    public void setUp() throws IOException {        unexistingCacheFile = tempFolder.resolve("non-existing-file.cache").toFile();        newCacheFile = tempFolder.resolve("pmd-analysis.cache").toFile();        emptyCacheFile = Files.createTempFile(tempFolder, null, null).toFile();        Path sourceFile = tempFolder.resolve("Source.java");        Files.write(sourceFile, listOf("dummy text"));        this.sourceFileBackend = TextFile.forPath(sourceFile, Charset.defaultCharset(), dummyVersion);        this.sourceFile = TextDocument.create(sourceFileBackend);    }    @Test    void testLoadFromNonExistingFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        assertNotNull(cache, "Cache creation from non existing file failed.");    }    @Test    void testLoadFromEmptyFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        assertNotNull(cache, "Cache creation from empty file failed.");    }    @Test    void testLoadFromDirectoryShouldntThrow() throws IOException {        new FileAnalysisCache(tempFolder.toFile());    }    @Test    void testLoadFromUnreadableFileShouldntThrow() throws IOException {        emptyCacheFile.setReadable(false);        new FileAnalysisCache(emptyCacheFile);    }    @Test    void testStoreCreatesFile() throws Exception {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        cache.persist();        assertTrue(unexistingCacheFile.exists(), "Cache file doesn't exist after store");    }    @Test    void testStoreOnUnwritableFileShouldntThrow() throws IOException {        emptyCacheFile.setWritable(false);        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        cache.persist();    }    @Test    void testStorePersistsFilesWithViolations() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        cache.checkValidity(mock(RuleSets.class), mock(ClassLoader.class));        cache.isUpToDate(sourceFile);        final RuleViolation rv = mock(RuleViolation.class);        when(rv.getFilename()).thenReturn(sourceFile.getDisplayName());        when(rv.getLocation()).thenReturn(FileLocation.range(sourceFile.getDisplayName(), TextRange2d.range2d(1, 2, 3, 4)));        final net.sourceforge.pmd.Rule rule = mock(net.sourceforge.pmd.Rule.class, Mockito.RETURNS_SMART_NULLS);        when(rule.getLanguage()).thenReturn(mock(Language.class));        when(rv.getRule()).thenReturn(rule);        cache.startFileAnalysis(sourceFile).onRuleViolation(rv);        cache.persist();        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(mock(RuleSets.class), mock(ClassLoader.class));        assertTrue(reloadedCache.isUpToDate(sourceFile),                "Cache believes unmodified file with violations is not up to date");        final List<RuleViolation> cachedViolations = reloadedCache.getCachedViolations(sourceFile);        assertEquals(1, cachedViolations.size(), "Cached rule violations count mismatch");    }    @Test    void testCacheValidityWithNoChanges() throws IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertTrue(reloadedCache.isUpToDate(sourceFile),                "Cache believes unmodified file is not up to date without ruleset / classpath changes");    }    @Test    void testCacheValidityWithIrrelevantChanges() throws IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] {});        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final File classpathFile = Files.createTempFile(tempFolder, null, "foo.xml").toFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertTrue(reloadedCache.isUpToDate(sourceFile),                "Cache believes unmodified file is not up to date without ruleset / classpath changes");    }    @Test    void testRulesetChangeInvalidatesCache() throws IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(rs.getChecksum()).thenReturn(1L);        reloadedCache.checkValidity(rs, cl);        assertFalse(reloadedCache.isUpToDate(sourceFile),                "Cache believes unmodified file is up to date after ruleset changed");    }    @Test    void testAuxClasspathNonExistingAuxclasspathEntriesIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { tempFolder.resolve("non-existing-dir").toFile().toURI().toURL(), });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache analysisCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] {});        analysisCache.checkValidity(rs, cl);        assertTrue(analysisCache.isUpToDate(sourceFile),                "Cache believes unmodified file is not up to date after non-existing auxclasspath entry removed");    }    @Test    void testAuxClasspathChangeWithoutDFAorTypeResolutionDoesNotInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] { Files.createTempFile(tempFolder, null, null).toFile().toURI().toURL(), });        reloadedCache.checkValidity(rs, cl);        assertTrue(reloadedCache.isUpToDate(sourceFile),                "Cache believes unmodified file is not up to date after auxclasspath changed when no rule cares");    }    @Test    void testAuxClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        final File classpathFile = Files.createTempFile(tempFolder, null, "foo.class").toFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        // Make sure the auxclasspath file is not empty        Files.write(classpathFile.toPath(), "some text".getBytes());        final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        reloadedCache.checkValidity(rs, cl);        assertFalse(reloadedCache.isUpToDate(sourceFile),                "Cache believes unmodified file is up to date after auxclasspath changed");    }    @Test    void testAuxClasspathJarContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        final File classpathFile = Files.createTempFile(tempFolder, null, "foo.class").toFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Edit the auxclasspath referenced file        Files.write(classpathFile.toPath(), "some text".getBytes());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse(reloadedCache.isUpToDate(sourceFile),                "Cache believes cache is up to date when a auxclasspath file changed");    }    @Test    void testClasspathNonExistingEntryIsIgnored() throws Exception {        restoreSystemProperties(() -> {            final RuleSets rs = mock(RuleSets.class);            final ClassLoader cl = mock(ClassLoader.class);            System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator                    + tempFolder.toFile().getAbsolutePath() + File.separator + "non-existing-dir");            final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);            try {                reloadedCache.checkValidity(rs, cl);            } catch (final Exception e) {                fail("Validity check failed when classpath includes non-existing directories");            }        });    }    @Test    void testClasspathChangeInvalidatesCache() throws Exception {        restoreSystemProperties(() -> {            final RuleSets rs = mock(RuleSets.class);            final ClassLoader cl = mock(ClassLoader.class);            final File classpathFile = Files.createTempFile(tempFolder, null, "foo.class").toFile();            setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);            // Edit the classpath referenced file            Files.write(classpathFile.toPath(), "some text".getBytes());            System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());            final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);            reloadedCache.checkValidity(rs, cl);            assertFalse(reloadedCache.isUpToDate(sourceFile),                    "Cache believes cache is up to date when the classpath changed");        });    }    @Test    void testClasspathContentsChangeInvalidatesCache() throws Exception {        restoreSystemProperties(() -> {            final RuleSets rs = mock(RuleSets.class);            final ClassLoader cl = mock(ClassLoader.class);            final File classpathFile = Files.createTempFile(tempFolder, null, "foo.class").toFile();            // Add a file to classpath            Files.write(classpathFile.toPath(), "some text".getBytes());            System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());            setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);            // Change the file's contents            Files.write(classpathFile.toPath(), "some other text".getBytes());            final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);            reloadedCache.checkValidity(rs, cl);            assertFalse(reloadedCache.isUpToDate(sourceFile),                    "Cache believes cache is up to date when a classpath file changed");        });    }    @Test    void testWildcardClasspath() throws Exception {        restoreSystemProperties(() -> {            final RuleSets rs = mock(RuleSets.class);            final ClassLoader cl = mock(ClassLoader.class);            setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);            // Prepare two class files            createZipFile("mylib1.jar");            createZipFile("mylib2.jar");            System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.toFile().getAbsolutePath() + "/*");            final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);            assertFalse(reloadedCache.isUpToDate(sourceFile),                    "Cache believes cache is up to date when the classpath changed");        });    }    @Test    void testWildcardClasspathContentsChangeInvalidatesCache() throws Exception {        restoreSystemProperties(() -> {            final RuleSets rs = mock(RuleSets.class);            final ClassLoader cl = mock(ClassLoader.class);            // Prepare two jar files            final File classpathJar1 = createZipFile("mylib1.jar");            createZipFile("mylib2.jar");            System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.toFile().getAbsolutePath() + "/*");            setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);            // Change one file's contents (ie: adding more entries)            classpathJar1.delete();            createZipFile(classpathJar1.getName(), 2);            final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);            reloadedCache.checkValidity(rs, cl);            assertFalse(reloadedCache.isUpToDate(sourceFile),                    "Cache believes cache is up to date when the classpath changed");        });    }    @Test    void testUnknownFileIsNotUpToDate() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse(cache.isUpToDate(sourceFile),                "Cache believes an unknown file is up to date");    }    @Test    void testFileIsUpToDate() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        cache.checkValidity(mock(RuleSets.class), mock(ClassLoader.class));        assertTrue(cache.isUpToDate(sourceFile),                "Cache believes a known, unchanged file is not up to date");    }    @Test    void testFileIsNotUpToDateWhenEdited() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);        // Edit the file        TextFileContent text = TextFileContent.fromCharSeq("some text");        assertEquals(System.lineSeparator(), text.getLineTerminator());        sourceFileBackend.writeContents(text);        sourceFile = TextDocument.create(sourceFileBackend);        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse(cache.isUpToDate(sourceFile),                "Cache believes a known, changed file is up to date");    }    private void setupCacheWithFiles(final File cacheFile,                                     final RuleSets ruleSets,                                     final ClassLoader classLoader,                                     final TextDocument... files) throws IOException {        // Setup a cache file with an entry for an empty Source.java with no violations        final FileAnalysisCache cache = new FileAnalysisCache(cacheFile);        cache.checkValidity(ruleSets, classLoader);        for (final TextDocument f : files) {            cache.isUpToDate(f);        }        cache.persist();    }    private File createZipFile(String fileName) throws IOException {        return createZipFile(fileName, 1);    }    private File createZipFile(String fileName, int numEntries) throws IOException {        final File zipFile = Files.createTempFile(tempFolder, null, fileName).toFile();        try (ZipOutputStream zipOS = new ZipOutputStream(Files.newOutputStream(zipFile.toPath()))) {            for (int i = 0; i < numEntries; i++) {                zipOS.putNextEntry(new ZipEntry("lib/foo" + i + ".class"));                zipOS.write(("content of " + fileName + " entry " + i).getBytes(StandardCharsets.UTF_8));                zipOS.closeEntry();            }        }        return zipFile;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;/** * Unit test for {@link SourceCodePositioner}. */class SourceCodePositionerTest {    @Test    void testLineNumberFromOffset() {        final String source = "abcd\ndefghi\n\rjklmn\ropq";        SourceCodePositioner positioner = SourceCodePositioner.create(source);        int offset;        offset = source.indexOf('a');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(1, positioner.columnFromOffset(1, offset));        offset = source.indexOf('b');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(1, offset));        offset = source.indexOf('e');        assertEquals(2, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(2, offset));        offset = source.indexOf('q');        assertEquals(3, positioner.lineNumberFromOffset(offset));        assertEquals(10, positioner.columnFromOffset(3, offset));        offset = source.length();        assertEquals(3, positioner.lineNumberFromOffset(offset));        assertEquals(11, positioner.columnFromOffset(3, offset));        offset = source.length() + 1;        assertEquals(-1, positioner.lineNumberFromOffset(offset));        assertEquals(-1, positioner.columnFromOffset(3, offset));    }    @Test    void testOffsetFromLineColumn() {        final String source = "abcd\ndefghi\r\njklmn\nopq";        SourceCodePositioner positioner = SourceCodePositioner.create(source);        assertEquals(0, positioner.offsetFromLineColumn(1, 1));        assertEquals(2, positioner.offsetFromLineColumn(1, 3));        assertEquals("abcd\n".length(), positioner.offsetFromLineColumn(2, 1));        assertEquals("abcd\nd".length(), positioner.offsetFromLineColumn(2, 2));        assertEquals("abcd\nde".length(), positioner.offsetFromLineColumn(2, 3));        assertEquals("abcd\ndef".length(), positioner.offsetFromLineColumn(2, 4));        assertEquals("abcd\ndefghi\r\n".length(), positioner.offsetFromLineColumn(3, 1));        assertEquals(source.length(), positioner.offsetFromLineColumn(4, 4));        assertEquals(-1, positioner.offsetFromLineColumn(4, 5));        assertEquals(source.length(), positioner.offsetFromLineColumn(5, 1));        assertEquals(-1, positioner.offsetFromLineColumn(5, 2));    }    @Test    void testWrongOffsets() {        final String source = "abcd\ndefghi\r\njklmn\nopq";        SourceCodePositioner positioner = SourceCodePositioner.create(source);        assertEquals(0, positioner.offsetFromLineColumn(1, 1));        assertEquals(1, positioner.offsetFromLineColumn(1, 2));        assertEquals(2, positioner.offsetFromLineColumn(1, 3));        assertEquals(3, positioner.offsetFromLineColumn(1, 4));        assertEquals(4, positioner.offsetFromLineColumn(1, 5));        assertEquals(5, positioner.offsetFromLineColumn(1, 6)); // this is right after the '\n'        assertEquals(-1, positioner.offsetFromLineColumn(1, 7));    }    @Test    void testEmptyDocument() {        SourceCodePositioner positioner = SourceCodePositioner.create("");        assertEquals(0, positioner.offsetFromLineColumn(1, 1));        assertEquals(-1, positioner.offsetFromLineColumn(1, 2));        assertEquals(1, positioner.lineNumberFromOffset(0));        assertEquals(-1, positioner.lineNumberFromOffset(1));        assertEquals(1, positioner.columnFromOffset(1, 0));        assertEquals(-1, positioner.columnFromOffset(1, 1));    }    @Test    void testDocumentStartingWithNl() {        SourceCodePositioner positioner = SourceCodePositioner.create("\n");        assertEquals(0, positioner.offsetFromLineColumn(1, 1));        assertEquals(1, positioner.offsetFromLineColumn(1, 2));        assertEquals(-1, positioner.offsetFromLineColumn(1, 3));        assertEquals(1, positioner.lineNumberFromOffset(0));        assertEquals(2, positioner.lineNumberFromOffset(1));        assertEquals(-1, positioner.lineNumberFromOffset(2));    }    @Test    void lineToOffsetMappingWithLineFeedShouldSucceed() {        final String code = "public static int main(String[] args) {\n"            + "int var;\n"            + "}";        SourceCodePositioner positioner = SourceCodePositioner.create(code);        assertArrayEquals(new int[] { 0, 40, 49, 50 }, positioner.getLineOffsets());    }    @Test    void lineToOffsetMappingWithCarriageReturnFeedLineFeedShouldSucceed() {        final String code = "public static int main(String[] args) {\r\n"            + "int var;\r\n"            + "}";        SourceCodePositioner positioner = SourceCodePositioner.create(code);        assertArrayEquals(new int[] { 0, 41, 51, 52 }, positioner.getLineOffsets());    }    @Test    void lineToOffsetMappingWithMixedLineSeparatorsShouldSucceed() {        final String code = "public static int main(String[] args) {\r\n"            + "int var;\n"            + "}";        SourceCodePositioner positioner = SourceCodePositioner.create(code);        assertArrayEquals(new int[] { 0, 41, 50, 51 }, positioner.getLineOffsets());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyVersion;import static net.sourceforge.pmd.lang.document.TextPos2d.pos2d;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.io.IOException;import org.junit.jupiter.api.Test;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.MethodSource;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.util.IOUtil;class TextDocumentTest {    @Test    void testSingleLineRegion() {        TextDocument doc = TextDocument.readOnlyString("bonjour\ntristesse", dummyVersion());        TextRegion region = TextRegion.fromOffsetLength(0, "bonjour".length());        assertEquals(0, region.getStartOffset());        assertEquals("bonjour".length(), region.getLength());        assertEquals("bonjour".length(), region.getEndOffset());        FileLocation withLines = doc.toLocation(region);        assertEquals(1, withLines.getStartLine());        assertEquals(1, withLines.getEndLine());        assertEquals(1, withLines.getStartColumn());        assertEquals(1 + "bonjour".length(), withLines.getEndColumn());        assertEquals("bonjour".length(), withLines.getEndColumn() - withLines.getStartColumn());    }    @Test    void testRegionAtEol() {        TextDocument doc = TextDocument.readOnlyString("bonjour\ntristesse", dummyVersion());        TextRegion region = TextRegion.fromOffsetLength(0, "bonjour\n".length());        assertEquals("bonjour\n", doc.sliceOriginalText(region).toString());        FileLocation withLines = doc.toLocation(region);        assertEquals(1, withLines.getStartLine());        assertEquals(1, withLines.getEndLine());        assertEquals(1, withLines.getStartColumn());        assertEquals(1 + "bonjour\n".length(), withLines.getEndColumn());        assertEquals("bonjour\n".length(), withLines.getEndColumn() - withLines.getStartColumn());    }    @Test    void testEmptyRegionAtEol() {        TextDocument doc = TextDocument.readOnlyString("bonjour\ntristesse", dummyVersion());        //                                                             ^ The caret position right after the \n        //                                                               We consider it's part of the next line        TextRegion region = TextRegion.fromOffsetLength("bonjour\n".length(), 0);        assertEquals("", doc.sliceOriginalText(region).toString());        FileLocation withLines = doc.toLocation(region);        assertEquals(2, withLines.getStartLine());        assertEquals(2, withLines.getEndLine());        assertEquals(1, withLines.getStartColumn());        assertEquals(1, withLines.getEndColumn());    }    @Test    void testRegionForEol() {        TextDocument doc = TextDocument.readOnlyString("bonjour\ntristesse", dummyVersion());        //                                                           [ [ The region containing the \n        //                                                               We consider it ends on the same line, not the next one        TextRegion region = TextRegion.fromOffsetLength("bonjour".length(), 1);        assertEquals("\n", doc.sliceOriginalText(region).toString());        FileLocation withLines = doc.toLocation(region);        assertEquals(1, withLines.getStartLine());        assertEquals(1, withLines.getEndLine());        assertEquals(1 + "bonjour".length(), withLines.getStartColumn());        assertEquals(1 + "bonjour\n".length(), withLines.getEndColumn());    }    @Test    void testRegionAtEndOfFile() {        TextDocument doc = TextDocument.readOnlyString("flemme", dummyVersion());        TextRegion region = TextRegion.fromOffsetLength(0, doc.getLength());        assertEquals(doc.getText(), doc.sliceOriginalText(region));        FileLocation withLines = doc.toLocation(region);        assertEquals(1, withLines.getStartLine());        assertEquals(1, withLines.getEndLine());        assertEquals(1, withLines.getStartColumn());        assertEquals(1 + doc.getLength(), withLines.getEndColumn());    }    @Test    void testMultiLineRegion() {        TextDocument doc = TextDocument.readOnlyString("bonjour\noha\ntristesse", dummyVersion());        TextRegion region = TextRegion.fromOffsetLength("bonjou".length(), "r\noha\ntri".length());        assertEquals("bonjou".length(), region.getStartOffset());        assertEquals("r\noha\ntri".length(), region.getLength());        assertEquals("bonjour\noha\ntri".length(), region.getEndOffset());        FileLocation withLines = doc.toLocation(region);        assertEquals(1, withLines.getStartLine());        assertEquals(3, withLines.getEndLine());        assertEquals(1 + "bonjou".length(), withLines.getStartColumn());        assertEquals(1 + "tri".length(), withLines.getEndColumn());    }    @Test    void testLineColumnFromOffset() {        TextDocument doc = TextDocument.readOnlyString("ab\ncd\n", dummyVersion());        assertPos2dEqualsAt(doc, 0, "a", pos2d(1, 1), true);        assertPos2dEqualsAt(doc, 0, "a", pos2d(1, 1), false);        assertPos2dEqualsAt(doc, 1, "b", pos2d(1, 2), true);        assertPos2dEqualsAt(doc, 2, "\n", pos2d(1, 3), true);        assertPos2dEqualsAt(doc, 3, "c", pos2d(2, 1), true);        assertPos2dEqualsAt(doc, 3, "c", pos2d(1, 4), false);        assertPos2dEqualsAt(doc, 4, "d", pos2d(2, 2), true);        assertPos2dEqualsAt(doc, 5, "\n", pos2d(2, 3), true);        // EOF caret position        assertEquals(pos2d(3, 1), doc.lineColumnAtOffset(6));        assertThrows(IndexOutOfBoundsException.class, () -> doc.lineColumnAtOffset(7));    }    private void assertPos2dEqualsAt(TextDocument doc, int offset, String c, TextPos2d pos, boolean inclusive) {        Chars slicedChar = doc.sliceTranslatedText(TextRegion.fromOffsetLength(offset, 1));        assertEquals(c, slicedChar.toString());        assertEquals(pos, doc.lineColumnAtOffset(offset, inclusive));    }    @Test    void testEmptyRegion() {        TextDocument doc = TextDocument.readOnlyString("bonjour\noha\ntristesse", dummyVersion());        TextRegion region = TextRegion.fromOffsetLength("bonjour".length(), 0);        assertEquals("bonjour".length(), region.getStartOffset());        assertEquals(0, region.getLength());        assertEquals(region.getStartOffset(), region.getEndOffset());        FileLocation withLines = doc.toLocation(region);        assertEquals(1, withLines.getStartLine());        assertEquals(1, withLines.getEndLine());        assertEquals(1 + "bonjour".length(), withLines.getStartColumn());        assertEquals(1 + "bonjour".length(), withLines.getEndColumn());    }    @Test    void testLineRange() {        TextDocument doc = TextDocument.readOnlyString("bonjour\noha\ntristesse", dummyVersion());        assertEquals(Chars.wrap("bonjour\n"), doc.sliceTranslatedText(doc.createLineRange(1, 1)));        assertEquals(Chars.wrap("bonjour\noha\n"), doc.sliceTranslatedText(doc.createLineRange(1, 2)));        assertEquals(Chars.wrap("oha\n"), doc.sliceTranslatedText(doc.createLineRange(2, 2)));        assertEquals(Chars.wrap("oha\ntristesse"), doc.sliceTranslatedText(doc.createLineRange(2, 3)));        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(2, 1));        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(1, 5));        assertThrows(IndexOutOfBoundsException.class, () -> doc.createLineRange(0, 2));    }    @ParameterizedTest    @MethodSource("documentProvider")    void testEntireRegion(TextDocument doc) {        assertEquals(TextRegion.fromOffsetLength(0, doc.getLength()),                doc.getEntireRegion(),                "getEntireRegion should return something based on length");    }    @ParameterizedTest    @MethodSource("documentProvider")    void testReader(TextDocument doc) throws IOException {        assertEquals(doc.getText().toString(),                     IOUtil.readToString(doc.newReader()),                    "NewReader should read the text");    }    @Test    void testRegionOutOfBounds() {        TextDocument doc = TextDocument.readOnlyString("bonjour\noha\ntristesse", dummyVersion());        assertThrows(AssertionError.class, () -> TextRegion.isValidRegion(0, 40, doc));    }    @SuppressWarnings("resource")    static Object[] documentProvider() {        LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();        return new TextDocument[] {            TextDocument.readOnlyString("bonjour\noha\ntristesse", dummyVersion),            TextDocument.readOnlyString("bonjour\n", dummyVersion),            TextDocument.readOnlyString("\n", dummyVersion),            TextDocument.readOnlyString("", dummyVersion),            };    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import net.sourceforge.pmd.util.log.internal.SimpleMessageReporter;/** * @author Clément Fournier */public class TestMessageReporter extends SimpleMessageReporter {    private static final Logger LOG = LoggerFactory.getLogger(TestMessageReporter.class.getName());    public TestMessageReporter() {        super(LOG);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import org.junit.jupiter.api.Test;/** * @author Clément Fournier */class TextRange2dTest {    @Test    void testCtors() {        TextRange2d pos = TextRange2d.range2d(1, 2, 3, 4);        TextRange2d pos2 = TextRange2d.range2d(TextPos2d.pos2d(1, 2), TextPos2d.pos2d(3, 4));        assertEquals(pos, pos2);    }    @Test    void testEquals() {        TextRange2d pos = TextRange2d.range2d(1, 1, 1, 1);        TextRange2d pos2 = TextRange2d.range2d(1, 1, 1, 2);        assertNotEquals(pos, pos2);        assertEquals(pos, pos);        assertEquals(pos2, pos2);    }    @Test    void testCompareTo() {        TextRange2d pos = TextRange2d.range2d(1, 1, 1, 1);        TextRange2d pos2 = TextRange2d.range2d(1, 1, 1, 2);        assertEquals(-1, pos.compareTo(pos2));        assertEquals(1, pos2.compareTo(pos));        assertEquals(0, pos.compareTo(pos));    }    @Test    void testToString() {        TextRange2d range = TextRange2d.range2d(1, 2, 3, 4);        assertEquals(            "1:2-3:4",            range.toDisplayStringWithColon()        );        assertThat(range.toString(), containsString("!debug only!"));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyVersion;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertNotSame;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.BufferedWriter;import java.io.IOException;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.util.datasource.DataSource;import net.sourceforge.pmd.util.datasource.FileDataSource;class TextFilesTest {    @TempDir    Path tempDir;    @Test    void testNioFile() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content");        try (TextFile tf = TextFile.forPath(file, StandardCharsets.UTF_8, dummyVersion())) {            assertEquals(file.toAbsolutePath().toString(), tf.getPathId());            assertEquals(file.toString(), tf.getDisplayName());            assertEquals(dummyVersion(), tf.getLanguageVersion());            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());        }    }    @Test    void testEquals() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content").toAbsolutePath();        try (TextFile tf = TextFile.forPath(file, StandardCharsets.UTF_8, dummyVersion())) {            try (TextFile tfPrime = TextFile.forPath(file, StandardCharsets.UTF_8, dummyVersion())) {                try (TextFile stringTf = TextFile.forCharSeq("some content", file.toString(), dummyVersion())) {                    assertEquals(tf.getPathId(), stringTf.getPathId());                    // despite same path id, they are different implementations                    assertNotEquals(tf, stringTf);                    assertNotEquals(stringTf, tf);                    // identical, but string text files use identity                    assertNotEquals(stringTf, TextFile.forCharSeq("some content", file.toString(), dummyVersion()));                    // those are identical so are equals                    assertNotSame(tf, tfPrime);                    assertEquals(tf, tfPrime);                    assertEquals(tfPrime, tf);                    assertEquals(tf.hashCode(), tfPrime.hashCode());                }            }        }    }    @Test    void testStringDataSourceCompat() throws IOException {        DataSource ds = DataSource.forString("text", "filename.dummy");        PMDConfiguration config = new PMDConfiguration();        try (TextFile tf = TextFile.dataSourceCompat(ds, config)) {            assertEquals("filename.dummy", tf.getPathId());            assertEquals("filename.dummy", tf.getDisplayName());            assertEquals(DummyLanguageModule.getInstance().getDefaultVersion(), tf.getLanguageVersion());            assertEquals(Chars.wrap("text"), tf.readContents().getNormalizedText());        }    }    @Test    void testFileDataSourceCompat() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content");        DataSource ds = new FileDataSource(file.toFile());        PMDConfiguration config = new PMDConfiguration();        config.setForceLanguageVersion(DummyLanguageModule.getInstance().getDefaultVersion());        try (TextFile tf = TextFile.dataSourceCompat(ds, config)) {            assertEquals(ds.getNiceFileName(false, null), tf.getPathId());            assertEquals(ds.getNiceFileName(false, null), tf.getDisplayName());            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());        }    }    @Test    void testFileDataSourceCompatWithEncoding() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_16BE, "some content");        DataSource ds = new FileDataSource(file.toFile());        PMDConfiguration config = new PMDConfiguration();        config.setForceLanguageVersion(DummyLanguageModule.getInstance().getDefaultVersion());        config.setSourceEncoding(StandardCharsets.UTF_16BE.name());        try (TextFile tf = TextFile.dataSourceCompat(ds, config)) {            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());        }        // different encoding to produce garbage, to make sure encoding is used        config.setSourceEncoding(StandardCharsets.UTF_16LE.name());        try (TextFile tf = TextFile.dataSourceCompat(ds, config)) {            assertNotEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());        }    }    @Test    void testNioFileWrite() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content");        try (TextFile tf = TextFile.forPath(file, StandardCharsets.UTF_8, dummyVersion())) {            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());            assertFalse(tf.isReadOnly(), "readonly");            // write with CRLF            tf.writeContents(                TextFileContent.fromCharSeq("new content\r\n")            );            TextFileContent read = tf.readContents();            // is normalized to LF when rereading            assertEquals(Chars.wrap("new content\n"), read.getNormalizedText());            // but line terminator is detected as CRLF            assertEquals("\r\n", read.getLineTerminator());            tf.writeContents(                TextFileContent.fromCharSeq("new content\n")            );            assertEquals(Chars.wrap("new content\n"), tf.readContents().getNormalizedText());        }    }    @Test    void testNioFileExplicitReadOnly() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content");        try (TextFile tf = TextFile.builderForPath(file, StandardCharsets.UTF_8, dummyVersion())                                   .asReadOnly().build()) {            assertTrue(tf.isReadOnly(), "readonly");            assertThrows(ReadOnlyFileException.class, () -> tf.writeContents(                TextFileContent.fromCharSeq("new content")            ));        }    }    @Test    void testNioFileCanBeReadMultipleTimes() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content");        try (TextFile tf = TextFile.forPath(file, StandardCharsets.UTF_8, dummyVersion())) {            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());        }    }    @Test    void testNioFileBuilder() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some content");        try (TextFile tf = TextFile.builderForPath(file, StandardCharsets.UTF_8, dummyVersion())                                   .withDisplayName("aname")                                   .build()) {            assertEquals(file.toAbsolutePath().toString(), tf.getPathId());            assertEquals("aname", tf.getDisplayName());            assertEquals(dummyVersion(), tf.getLanguageVersion());            assertEquals(Chars.wrap("some content"), tf.readContents().getNormalizedText());        }    }    @Test    void testNioFileEscape() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some\r\ncontent");        try (TextFile tf = TextFile.forPath(file, StandardCharsets.UTF_8, dummyVersion())) {            assertEquals(Chars.wrap("some\ncontent"), tf.readContents().getNormalizedText());        }    }    @Test    void testReaderFile() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some\r\ncontent");        try (TextFile tf = TextFile.forReader(Files.newBufferedReader(file, StandardCharsets.UTF_8), "filename", dummyVersion())) {            assertEquals("filename", tf.getPathId());            assertEquals("filename", tf.getDisplayName());            assertEquals(dummyVersion(), tf.getLanguageVersion());            assertEquals(Chars.wrap("some\ncontent"), tf.readContents().getNormalizedText());        }    }    @Test    void testReaderFileIsReadOnly() throws IOException {        Path file = makeTmpFile(StandardCharsets.UTF_8, "some\r\ncontent");        try (TextFile tf = TextFile.forReader(Files.newBufferedReader(file, StandardCharsets.UTF_8), "filename", dummyVersion())) {            assertTrue(tf.isReadOnly(), "readonly");            assertThrows(ReadOnlyFileException.class, () -> tf.writeContents(                TextFileContent.fromCharSeq("new content")            ));        }    }    @Test    void testStringFileEscape() throws IOException {        try (TextFile tf = TextFile.forCharSeq("cont\r\nents", "filename", dummyVersion())) {            assertEquals("filename", tf.getPathId());            assertEquals("filename", tf.getDisplayName());            assertEquals(dummyVersion(), tf.getLanguageVersion());            assertEquals(Chars.wrap("cont\nents"), tf.readContents().getNormalizedText());            assertThrows(ReadOnlyFileException.class, () -> tf.writeContents(                TextFileContent.fromCharSeq("new content")            ));        }    }    @Test    void testStringFileCanBeReadMultipleTimes() throws IOException {        try (TextFile tf = TextFile.forCharSeq("contents", "filename", dummyVersion())) {            assertEquals(Chars.wrap("contents"), tf.readContents().getNormalizedText());            assertEquals(Chars.wrap("contents"), tf.readContents().getNormalizedText());            assertEquals(Chars.wrap("contents"), tf.readContents().getNormalizedText());        }    }    @Test    void testStringFileIsReadonly() throws IOException {        try (TextFile tf = TextFile.forCharSeq("contents", "filename", dummyVersion())) {            assertTrue(tf.isReadOnly(), "readonly");            assertThrows(ReadOnlyFileException.class, () -> tf.writeContents(                TextFileContent.fromCharSeq("new content")            ));        }    }    private @NonNull Path makeTmpFile(Charset charset, String content) throws IOException {        Path file = Files.createTempFile(tempDir, null, null);        try (BufferedWriter writer = Files.newBufferedWriter(file, charset)) {            writer.write(content);        }        return file;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.StringReader;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import org.junit.jupiter.api.Test;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.EnumSource;class TextFileContentTest {    // in real life it's System.lineSeparator()    // to make the class more testable (and avoid some test failures being hidden depending on the platform),    // we use this dummy value    private static final String LINESEP_SENTINEL = ":fallback:";    @ParameterizedTest    @EnumSource    void testMixedDelimiters(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("a\r\nb\n\rc");        assertEquals(Chars.wrap("a\nb\n\nc"), content.getNormalizedText());        assertEquals(LINESEP_SENTINEL, content.getLineTerminator());    }    @ParameterizedTest    @EnumSource    void testFormFeedIsNotNewline(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("a\f\nb\nc");        assertEquals(Chars.wrap("a\f\nb\nc"), content.getNormalizedText());        assertEquals("\n", content.getLineTerminator());    }    @Test    void testNormTextPreservation() {        Chars input = Chars.wrap("a\nb\nc");        TextFileContent content = TextFileContent.fromCharSeq(input);        assertSame(input, content.getNormalizedText());        assertEquals("\n", content.getLineTerminator());    }    @ParameterizedTest    @EnumSource    void testBomElimination(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("\ufeffabc");        Chars normalizedText = content.getNormalizedText();        assertEquals(Chars.wrap("abc"), normalizedText);        // This means the string underlying the Chars does not start with the bom marker.        // It's useful for performance to have `textDocument.getText().toString()` be O(1),        // and not create a new string.        assertTrue(normalizedText.isFullString(), "should be full string");        assertSame(normalizedText.toString(), normalizedText.toString());    }    @ParameterizedTest    @EnumSource    void testNoExplicitLineMarkers(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("a");        assertEquals(Chars.wrap("a"), content.getNormalizedText());        assertEquals(LINESEP_SENTINEL, content.getLineTerminator());    }    @ParameterizedTest    @EnumSource    void testEmptyFile(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("");        assertEquals(Chars.wrap(""), content.getNormalizedText());        assertEquals(LINESEP_SENTINEL, content.getLineTerminator());    }    @Test    void testCrlfSplitOnBuffer() throws IOException {        StringReader reader = new StringReader("a\r\nb");        // now the buffer is of size 2, so we read first [a\r] then [\nb]        // but there is a single line        TextFileContent content = TextFileContent.normalizingRead(reader, 2, System.lineSeparator());        assertEquals(Chars.wrap("a\nb"), content.getNormalizedText());        assertEquals("\r\n", content.getLineTerminator());    }    @Test    void testCrSplitOnBufferFp() throws IOException {        StringReader reader = new StringReader("a\rb\n");        // the buffer is of size 2, so we read first [a\r] then [b\n]        // the \r is a line terminator on its own        TextFileContent content = TextFileContent.normalizingRead(reader, 2, LINESEP_SENTINEL);        assertEquals(Chars.wrap("a\nb\n"), content.getNormalizedText());        assertEquals(LINESEP_SENTINEL, content.getLineTerminator());    }    @ParameterizedTest    @EnumSource    void testCrCr(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("a\r\rb");        assertEquals(Chars.wrap("a\n\nb"), content.getNormalizedText());        assertEquals("\r", content.getLineTerminator());    }    @ParameterizedTest    @EnumSource    void testCrIsEol(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("a\rb\rdede");        assertEquals(Chars.wrap("a\nb\ndede"), content.getNormalizedText());        assertEquals("\r", content.getLineTerminator());    }    @ParameterizedTest    @EnumSource    void testLfAtStartOfFile(TextContentOrigin origin) throws IOException {        TextFileContent content = origin.normalize("\nohio");        assertEquals(Chars.wrap("\nohio"), content.getNormalizedText());        assertEquals("\n", content.getLineTerminator());    }    @Test    void testCrCrSplitBuffer() throws IOException {        StringReader reader = new StringReader("a\r\r");        // the buffer is of size 2, so we read first [a\r] then [\ro]        // the \r is not a line terminator though        TextFileContent content = TextFileContent.normalizingRead(reader, 2, LINESEP_SENTINEL);        assertEquals(Chars.wrap("a\n\n"), content.getNormalizedText());        assertEquals("\r", content.getLineTerminator());    }    enum TextContentOrigin {        INPUT_STREAM {            @Override            TextFileContent normalize(String text) throws IOException {                Charset charset = StandardCharsets.UTF_8;                byte[] input = text.getBytes(charset);                TextFileContent content;                try (ByteArrayInputStream bar = new ByteArrayInputStream(input)) {                    content = TextFileContent.fromInputStream(bar, charset, LINESEP_SENTINEL);                }                return content;            }        },        READER {            @Override            TextFileContent normalize(String input) throws IOException {                return TextFileContent.normalizingRead(new StringReader(input), 4096, LINESEP_SENTINEL);            }        },        STRING {            @Override            TextFileContent normalize(String input) throws IOException {                return TextFileContent.normalizeCharSeq(input, LINESEP_SENTINEL);            }        };        abstract TextFileContent normalize(String input) throws IOException;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import org.junit.jupiter.api.Test;/** * @author Clément Fournier */class TextPos2dTest {    @Test    void testToString() {        TextPos2d pos = TextPos2d.pos2d(1, 2);        assertEquals(            "line 1, column 2",            pos.toDisplayStringInEnglish()        );        assertEquals(            "1:2",            pos.toDisplayStringWithColon()        );        assertEquals(            "(line=1, column=2)",            pos.toTupleString()        );        assertThat(pos.toString(), containsString("!debug only!"));    }    @Test    void testEquals() {        TextPos2d pos = TextPos2d.pos2d(1, 1);        TextPos2d pos2 = TextPos2d.pos2d(1, 2);        assertNotEquals(pos, pos2);        assertEquals(pos, TextPos2d.pos2d(1, 1));        assertEquals(pos2, pos2);    }    @Test    void testCompareTo() {        TextPos2d pos = TextPos2d.pos2d(1, 1);        TextPos2d pos2 = TextPos2d.pos2d(1, 2);        TextPos2d pos3 = TextPos2d.pos2d(2, 1);        assertEquals(-1, pos.compareTo(pos2));        assertEquals(-1, pos.compareTo(pos3));        assertEquals(-1, pos2.compareTo(pos3));        assertEquals(1, pos2.compareTo(pos));        assertEquals(0, pos.compareTo(pos));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;/** * @author Clément Fournier */class FileCollectorTest {    @TempDir    private Path tempFolder;    @Test    void testAddFile() throws IOException {        Path foo = newFile(tempFolder, "foo.dummy");        Path bar = newFile(tempFolder, "bar.unknown");        FileCollector collector = newCollector();        assertTrue(collector.addFile(foo), "should be dummy language");        assertFalse(collector.addFile(bar), "should be unknown language");        assertCollected(collector, listOf("foo.dummy"));    }    @Test    void testAddFileForceLanguage() throws IOException {        Path bar = newFile(tempFolder, "bar.unknown");        Language dummy = DummyLanguageModule.getInstance();        FileCollector collector = newCollector(dummy.getDefaultVersion());        assertTrue(collector.addFile(bar, dummy), "should be unknown language");        assertCollected(collector, listOf("bar.unknown"));        assertNoErrors(collector);    }    @Test    void testAddFileNotExists() {        FileCollector collector = newCollector();        assertFalse(collector.addFile(tempFolder.resolve("does_not_exist.dummy")));        assertEquals(1, collector.getReporter().numErrors());    }    @Test    void testAddFileNotAFile() throws IOException {        Path dir = tempFolder.resolve("src");        Files.createDirectories(dir);        FileCollector collector = newCollector();        assertFalse(collector.addFile(dir));        assertEquals(1, collector.getReporter().numErrors());    }    @Test    void testAddDirectory() throws IOException {        Path root = tempFolder;        newFile(root, "src/foo.dummy");        newFile(root, "src/bar.unknown");        newFile(root, "src/x/bar.dummy");        FileCollector collector = newCollector();        collector.addDirectory(root.resolve("src"));        assertCollected(collector, listOf("src/foo.dummy", "src/x/bar.dummy"));    }    @Test    void testRelativize() throws IOException {        String displayName = FileCollector.getDisplayName(Paths.get("a", "b", "c"), listOf(Paths.get("a").toString()));        assertEquals(displayName, Paths.get("b", "c").toString());    }    private Path newFile(Path root, String path) throws IOException {        Path resolved = root.resolve(path);        Files.createDirectories(resolved.getParent());        Files.createFile(resolved);        return resolved;    }    private void assertCollected(FileCollector collector, List<String> relPaths) {        Map<String, String> actual = new LinkedHashMap<>();        for (TextFile file : collector.getCollectedFiles()) {            actual.put(file.getDisplayName(), file.getLanguageVersion().getTerseName());        }        relPaths = new ArrayList<>(relPaths);        for (int i = 0; i < relPaths.size(); i++) {            // normalize, we want display names to be platform-specific            relPaths.set(i, relPaths.get(i).replace('/', File.separatorChar));        }        assertEquals(relPaths, new ArrayList<>(actual.keySet()));    }    private void assertNoErrors(FileCollector collector) {        assertEquals(0, collector.getReporter().numErrors(), "No errors expected");    }    private FileCollector newCollector() {        return newCollector(null);    }    private FileCollector newCollector(LanguageVersion forcedVersion) {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer(LanguageRegistry.PMD, forcedVersion);        FileCollector collector = FileCollector.newCollector(discoverer, new TestMessageReporter());        collector.relativizeWith(tempFolder.toAbsolutePath().toString());        return collector;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;/** * @author Clément Fournier */class FileLocationTest {    @Test    void testSimple() {        FileLocation loc = FileLocation.range("fname", TextRange2d.range2d(1, 1, 1, 2));        assertEquals("fname", loc.getFileName());        assertEquals(1, loc.getStartLine());        assertEquals(1, loc.getStartColumn());        assertEquals(1, loc.getEndLine());        assertEquals(2, loc.getEndColumn());    }    @Test    void testToRange() {        TextRange2d range2d = TextRange2d.range2d(1, 1, 1, 2);        FileLocation loc = FileLocation.range("fname", range2d);        assertEquals(range2d, loc.toRange2d());    }    @Test    void testToString() {        FileLocation loc = FileLocation.range("fname", TextRange2d.range2d(1, 1, 1, 2));        assertEquals(            "line 1, column 1",            loc.startPosToString()        );        assertEquals(            "fname:1:1",            loc.startPosToStringWithFile()        );        assertThat(loc.toString(), containsString("!debug only!"));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.IOException;import java.io.Reader;import java.io.StringWriter;import java.util.List;import java.util.stream.Collectors;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.util.CollectionUtil;/** * */class CharsTest {    @Test    void wrapStringRoundTrip() {        String s = "ooo";        assertSame(s, Chars.wrap(s).toString());    }    @Test    void wrapCharsRoundTrip() {        Chars s = Chars.wrap("ooo");        assertSame(s, Chars.wrap(s));    }    @Test    void appendChars() {        StringBuilder sb = new StringBuilder();        Chars bc = Chars.wrap("abcd").slice(1, 2);        assertEquals("bc", bc.toString());        bc.appendChars(sb);        assertEquals("bc", sb.toString());    }    @Test    void appendCharsWithOffsets() {        StringBuilder sb = new StringBuilder();        Chars bc = Chars.wrap("abcd").slice(1, 2);        assertEquals("bc", bc.toString());        bc.appendChars(sb, 0, 1);        assertEquals("b", sb.toString());    }    @Test    void toStringBuilder() {        Chars bc = Chars.wrap("abcd").slice(1, 2);        assertEquals("bc", bc.toString());        assertEquals("bc", bc.toStringBuilder().toString());    }    @Test    void write() throws IOException {        StringWriter writer = new StringWriter();        Chars bc = Chars.wrap("abcd").slice(1, 2);        assertEquals("bc", bc.toString());        bc.write(writer, 0, 1);        assertEquals("b", writer.toString());        writer = new StringWriter();        bc.writeFully(writer);        assertEquals("bc", writer.toString());    }    @Test    void getChars() {        char[] arr = new char[4];        Chars bc = Chars.wrap("abcd").slice(1, 2);        bc.getChars(0, arr, 1, 2);        assertArrayEquals(arr, new char[] { 0, 'b', 'c', 0 });        assertThrows(IndexOutOfBoundsException.class, () -> bc.getChars(2, arr, 0, 1));        assertThrows(IndexOutOfBoundsException.class, () -> bc.getChars(-1, arr, 0, 1));        assertThrows(IndexOutOfBoundsException.class, () -> bc.getChars(0, arr, 0, 3));        assertThrows(IndexOutOfBoundsException.class, () -> bc.getChars(0, arr, 4, 3));        assertThrows(NullPointerException.class, () -> bc.getChars(0, null, 0, 0));    }    @Test    void indexOf() {        Chars bc = Chars.wrap("aaaaabcdb").slice(5, 2);        //                          --        assertEquals(0, bc.indexOf('b', 0));        assertEquals(1, bc.indexOf('c', 0));        assertEquals(-1, bc.indexOf('b', 1));        assertEquals(-1, bc.indexOf('d', 0));        assertEquals(-1, bc.indexOf('x', 0));        assertEquals(-1, bc.indexOf('a', -1));    }    @Test    void indexOfString() {        Chars bc = Chars.wrap("aaaaabcdb").slice(5, 2);        //                          --        assertEquals(0, bc.indexOf("b", 0));        assertEquals(0, bc.indexOf("bc", 0));        assertEquals(1, bc.indexOf("c", 0));        assertEquals(-1, bc.indexOf("b", 1));        assertEquals(-1, bc.indexOf("bc", 1));        assertEquals(-1, bc.indexOf("d", 0));        assertEquals(-1, bc.indexOf("bcd", 0));        assertEquals(-1, bc.indexOf("x", 0));        assertEquals(-1, bc.indexOf("ab", -1));        bc = Chars.wrap("aaaaabcdbxdb").slice(5, 5);        //                    -----        assertEquals(3, bc.indexOf("bx", 0));        bc = Chars.wrap("aaaaabcbxdb").slice(5, 5);        //                    -----        assertEquals(2, bc.indexOf("bx", 0));    }    @Test    void lastIndexOf() {        Chars bc = Chars.wrap("aaaaabcdb").slice(5, 2);        //                          --        assertEquals(0, bc.lastIndexOf('b', 0));        assertEquals(0, bc.lastIndexOf('b', 1));        assertEquals(1, bc.lastIndexOf('c', 1));        assertEquals(-1, bc.lastIndexOf('c', 0));        assertEquals(-1, bc.lastIndexOf('d', 0));        assertEquals(-1, bc.lastIndexOf('x', 0));        assertEquals(-1, bc.lastIndexOf('a', -1));        assertEquals(-1, bc.lastIndexOf('a', 0));        assertEquals(-1, bc.lastIndexOf('a', 1));    }    @Test    void startsWith() {        Chars bc = Chars.wrap("abcdb").slice(1, 2);        assertTrue(bc.startsWith("bc"));        assertTrue(bc.startsWith("bc", 0));        assertTrue(bc.startsWith("c", 1));        assertTrue(bc.startsWith('c', 1)); //with a char        assertTrue(bc.startsWith("", 1));        assertTrue(bc.startsWith("", 0));        assertFalse(bc.startsWith("c", 0));        assertFalse(bc.startsWith('c', 0)); //with a char        assertFalse(bc.startsWith("bcd", 0));        assertFalse(bc.startsWith("xcd", 0));        assertFalse(bc.startsWith("b", -1));        assertFalse(bc.startsWith('b', -1)); //with a char        assertFalse(bc.startsWith("", -1));        assertFalse(bc.startsWith("", 5));    }    @Test    void removeSuffix() {        Chars bc = Chars.wrap("abcdb").slice(1, 2);        //                      --        assertEquals("bc", bc.toString());        assertEquals("b", bc.removeSuffix("c").toString());        assertEquals("", bc.removeSuffix("bc").toString());        bc = Chars.wrap("aaaaaaa").slice(2, 3);        //                 ---        assertEquals("", bc.removeSuffix("aaa").toString());        assertEquals("aaa", bc.removeSuffix("aaaa").toString());    }    @Test    void removePrefix() {        Chars bc = Chars.wrap("abcdb").slice(1, 2);        //                      --        assertEquals("bc", bc.toString());        assertEquals("bc", bc.removePrefix("c").toString());        assertEquals("", bc.removePrefix("bc").toString());        assertEquals("c", bc.removePrefix("b").toString());        bc = Chars.wrap("aaaaaaa").slice(2, 3);        //                 ---        assertEquals("aaa", bc.toString());        assertEquals("", bc.removePrefix("aaa").toString());        assertEquals("aaa", bc.removePrefix("aaaa").toString());    }    @Test    void trimNoop() {        Chars bc = Chars.wrap("abcdb").slice(1, 2);        assertEquals("bc", bc.toString());        assertEquals("bc", bc.trimStart().toString());        assertEquals("bc", bc.trimEnd().toString());        assertEquals("bc", bc.trim().toString());    }    @Test    void trimStartAndEnd() {        Chars bc = Chars.wrap("a   bc db").slice(1, 6);        //                      ------        assertEquals("   bc ", bc.toString());        assertEquals("bc ", bc.trimStart().toString());        assertEquals("   bc", bc.trimEnd().toString());        assertEquals("bc", bc.trim().toString());    }    @Test    void charAt() {        Chars bc = Chars.wrap("a   bc db").slice(1, 6);        //                      ------        assertEquals(' ', bc.charAt(0));        assertEquals('b', bc.charAt(3));        assertEquals('c', bc.charAt(4));        assertEquals(' ', bc.charAt(5));        assertThrows(IndexOutOfBoundsException.class, () -> bc.charAt(-1));        assertThrows(IndexOutOfBoundsException.class, () -> bc.charAt(7));    }    @Test    void linesTest() {        Chars bc = Chars.wrap("a \n  \r\nbc db").slice(1, 9);        //                      ------------        List<String> lines = CollectionUtil.map(bc.lines(), Chars::toString);        assertEquals(listOf(" ", "  ", "bc "), lines);    }    @Test    void linesTest2() {        Chars bc = Chars.wrap("aa\n");        List<String> lines = CollectionUtil.map(bc.lines(), Chars::toString);        assertEquals(listOf("aa"), lines);    }    @Test    void linesStreamTest() {        Chars bc = Chars.wrap("aa\nb\rded\r\nlff");        List<String> lines = bc.lineStream().map(Chars::toString).collect(Collectors.toList());        assertEquals(listOf("aa", "b", "ded", "lff"), lines);    }    @Test    void linesTest3WithCr() {        Chars bc = Chars.wrap("aa\rb");        List<String> lines = CollectionUtil.map(bc.lines(), Chars::toString);        assertEquals(listOf("aa", "b"), lines);    }    @Test    void testEqualsHashCode() {        Chars chars = Chars.wrap("a_a_b_c_s").slice(2, 5);        //                          -----        assertEquals(Chars.wrap("a_b_c"), chars);        assertNotEquals("a_b_c", chars);        assertEquals(Chars.wrap("a_b_c").hashCode(), chars.hashCode());        assertEquals(chars, chars);        assertEquals("a_b_c".hashCode(), Chars.wrap("a_b_c").hashCode());        assertEquals("a_b_c".hashCode(), chars.hashCode());    }    @Test    void testContentEquals() {        Chars chars = Chars.wrap("a_a_b_c_s").slice(2, 5);        //                          -----        assertTrue(chars.contentEquals("a_b_c"));        assertTrue(chars.contentEquals(Chars.wrap("a_b_c")));        assertFalse(chars.contentEquals("a_b_c_--"));        assertFalse(chars.contentEquals(Chars.wrap("a_b_c_")));        assertFalse(chars.contentEquals(Chars.wrap("a_b-c")));        assertTrue(chars.contentEquals(Chars.wrap("A_B_C"), true));    }    @Test    void testSlice() {        // slice is offset + length        Chars chars = Chars.wrap("a_a_b_c_s").slice(2, 5);        //                          -----        assertEquals(Chars.wrap("_b_"), chars.slice(1, 3));        assertThrows(IndexOutOfBoundsException.class, () -> chars.slice(0, -1));        assertThrows(IndexOutOfBoundsException.class, () -> chars.slice(0, 6));    }    @Test    void testSubsequence() {        // subsequence is start + end        Chars chars = Chars.wrap("a_a_b_c_s").slice(2, 5);        //                          -----        assertEquals(Chars.wrap("_b"), chars.subSequence(1, 3));        assertThrows(IndexOutOfBoundsException.class, () -> chars.slice(0, -1));        assertThrows(IndexOutOfBoundsException.class, () -> chars.slice(0, 6));    }    @Test    void testSubstring() {        // substring is start + end        Chars chars = Chars.wrap("a_a_b_c_s").slice(2, 5);        //                          -----        assertEquals("_b", chars.substring(1, 3));        assertThrows(IndexOutOfBoundsException.class, () -> chars.substring(0, -1));        assertThrows(IndexOutOfBoundsException.class, () -> chars.substring(0, 6));    }    @Test    void testTrimBlankLines() {        assertTrimBlankLinesEquals(" \n \n abc \n \n de \n \n ",                                   " abc \n \n de ");        assertTrimBlankLinesEquals("", "");    }    private void assertTrimBlankLinesEquals(String input, String expected) {        Chars actual = Chars.wrap(input).trimBlankLines();        assertEquals(Chars.wrap(expected), actual);    }    @Test    void testReaderSingleChars() throws IOException {        Chars bc = Chars.wrap("a \n  \r\nbc db").slice(1, 9);        //                      ------------        try (Reader reader = bc.newReader()) {            assertEquals(' ', reader.read());            assertEquals('\n', reader.read());            assertEquals(' ', reader.read());            assertEquals(' ', reader.read());            assertEquals('\r', reader.read());            assertEquals('\n', reader.read());            assertEquals('b', reader.read());            assertEquals('c', reader.read());            assertEquals(' ', reader.read());            assertEquals(-1, reader.read());        }    }    @Test    void testReaderBuffer() throws IOException {        Chars bc = Chars.wrap("a \n  \r\nbc db").slice(1, 9);        //                      ------------        char[] cbuf = new char[4];        try (Reader reader = bc.newReader()) {            assertEquals(4, reader.read(cbuf));            assertCharBufEquals(" \n  ", cbuf);            assertEquals(4, reader.read(cbuf));            assertCharBufEquals("\r\nbc", cbuf);            assertEquals(1, reader.read(cbuf));            assertCharBufEquals(" \nbc", cbuf);            assertEquals(-1, reader.read(cbuf));        }    }    @Test    void testReaderSlicedBuffer() throws IOException {        Chars bc = Chars.wrap("a \n  \r\nbc db").slice(1, 9);        //                      ------------        // use \0 as padding before and after        char[] cbuf = new char[6];        try (Reader reader = bc.newReader()) {            assertEquals(4, reader.read(cbuf, 1, 4));            assertCharBufEquals("\0 \n  \0", cbuf);            assertEquals(5, reader.read(cbuf, 1, 5));            assertCharBufEquals("\0\r\nbc ", cbuf);            assertEquals(-1, reader.read(cbuf));            assertEquals(-1, reader.read());            assertEquals(-1, reader.read(cbuf, 1, 4));        }    }    @Test    void testReadClosed() throws IOException {        Chars bc = Chars.wrap("a \n  \r\nbc db").slice(1, 9);        //                      ------------        Reader reader = bc.newReader();        reader.close();        assertThrows(IOException.class, reader::read);    }    @Test    void testReaderMark() throws IOException {        Chars bc = Chars.wrap("abcdefghijklmnop").slice(1, 9);        //                      ------------        try (Reader reader = bc.newReader()) {            assertTrue(reader.markSupported(), "markSupported");            assertEquals('b', reader.read());            assertEquals('c', reader.read());            assertEquals('d', reader.read());            assertEquals('e', reader.read());            reader.mark(10);            assertEquals('f', reader.read());            assertEquals('g', reader.read());            reader.reset();            assertEquals('f', reader.read());            assertEquals('g', reader.read());            reader.reset(); // reset doesn't clear the mark            assertEquals('f', reader.read());            assertEquals('g', reader.read());        }    }    @Test    void testReaderMissingMark() throws IOException {        Chars bc = Chars.wrap("abcdefghijklmnop").slice(1, 9);        //                      ------------        try (Reader reader = bc.newReader()) {            assertTrue(reader.markSupported(), "markSupported");            assertEquals('b', reader.read());            assertThrows(IOException.class, reader::reset);        }    }    @Test    void testReaderSkip() throws IOException {        Chars bc = Chars.wrap("abcdefghijklmnop").slice(1, 9);        //                      ------------        try (Reader reader = bc.newReader()) {            assertEquals('b', reader.read());            assertEquals('c', reader.read());            assertEquals('d', reader.read());            assertEquals('e', reader.read());            reader.mark(10);            assertEquals(2, reader.skip(2));            assertEquals('h', reader.read());            assertEquals('i', reader.read());            reader.reset();            assertEquals('f', reader.read());            assertEquals('g', reader.read());        }    }    @Test    void testReaderInvalidParams() throws IOException {        Chars bc = Chars.wrap("abcdefghijklmnop").slice(1, 9);        //                      ------------        char[] cbuf = new char[4];        try (Reader reader = bc.newReader()) {            assertTrue(reader.markSupported(), "markSupported");            assertEquals('b', reader.read());            assertThrows(NullPointerException.class, () -> reader.read(null, 0, 0));            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(cbuf, -1, 0));            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(cbuf, 1, 12));            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(cbuf, 1, -1));        }    }    private static void assertCharBufEquals(String expected, char[] cbuf) {        String actual = new String(cbuf);        assertEquals(expected, actual);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.document;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class TextRegionTest {    @Test    void testIsEmpty() {        TextRegion r = TextRegion.fromOffsetLength(0, 0);        assertTrue(r.isEmpty());    }    @Test    void testEmptyContains() {        TextRegion r1 = TextRegion.fromOffsetLength(0, 0);        assertFalse(r1.contains(0));    }    @Test    void testContains() {        TextRegion r1 = TextRegion.fromOffsetLength(1, 2);        assertFalse(r1.contains(0));        assertTrue(r1.contains(1));        assertTrue(r1.contains(2));        assertFalse(r1.contains(3));    }    @Test    void testIntersectZeroLen() {        // r1: [[-----        // r2: [ -----[        TextRegion r1 = TextRegion.fromOffsetLength(0, 0);        TextRegion r2 = TextRegion.fromOffsetLength(0, 5);        TextRegion inter = doIntersect(r1, r2);        assertEquals(r1, inter);    }    @Test    void testIntersectZeroLen2() {        // r1:  -----[[        // r2: [-----[        TextRegion r1 = TextRegion.fromOffsetLength(5, 0);        TextRegion r2 = TextRegion.fromOffsetLength(0, 5);        TextRegion inter = doIntersect(r1, r2);        assertEquals(r1, inter);    }    @Test    void testIntersectZeroLen3() {        // r1:  -- -[---[        // r2:  --[-[---        TextRegion r1 = TextRegion.fromOffsetLength(3, 3);        TextRegion r2 = TextRegion.fromOffsetLength(2, 1);        TextRegion inter = doIntersect(r1, r2);        assertRegionEquals(inter, 3, 0);        assertTrue(inter.isEmpty());    }    @Test    void testIntersectZeroLen4() {        TextRegion r1 = TextRegion.fromOffsetLength(0, 0);        TextRegion inter = doIntersect(r1, r1);        assertEquals(r1, inter);    }    @Test    void testNonEmptyIntersect() {        // r1:  ---[-- --[        // r2: [--- --[--        // i:   ---[--[--        TextRegion r1 = TextRegion.fromOffsetLength(3, 4);        TextRegion r2 = TextRegion.fromOffsetLength(0, 5);        TextRegion inter = doIntersect(r1, r2);        assertRegionEquals(inter, 3, 2);    }    @Test    void testIntersectContained() {        // r1:  --[- - ---[        // r2:  -- -[-[---        // i:   -- -[-[---        TextRegion r1 = TextRegion.fromOffsetLength(2, 5);        TextRegion r2 = TextRegion.fromOffsetLength(3, 1);        TextRegion inter = doIntersect(r1, r2);        assertRegionEquals(inter, 3, 1);    }    @Test    void testIntersectDisjoint() {        // r1:  -- -[---[        // r2:  --[-[---        TextRegion r1 = TextRegion.fromOffsetLength(4, 3);        TextRegion r2 = TextRegion.fromOffsetLength(2, 1);        noIntersect(r1, r2);    }    @Test    void testOverlapContained() {        // r1:  --[- - ---[        // r2:  -- -[-[---        // i:   -- -[-[---        TextRegion r1 = TextRegion.fromOffsetLength(2, 5);        TextRegion r2 = TextRegion.fromOffsetLength(3, 1);        assertOverlap(r1, r2);    }    @Test    void testOverlapDisjoint() {        // r1:  -- -[---[        // r2:  --[-[---        TextRegion r1 = TextRegion.fromOffsetLength(4, 3);        TextRegion r2 = TextRegion.fromOffsetLength(2, 1);        assertNoOverlap(r1, r2);    }    @Test    void testOverlapBoundary() {        // r1:  -- -[---[        // r2:  --[-[---        TextRegion r1 = TextRegion.fromOffsetLength(3, 3);        TextRegion r2 = TextRegion.fromOffsetLength(2, 1);        assertNoOverlap(r1, r2);    }    @Test    void testCompare() {        // r1:  --[-[---        // r2:  -- -[---[        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = TextRegion.fromOffsetLength(3, 3);        assertIsBefore(r1, r2);    }    @Test    void testCompareSameOffset() {        // r1:  [-[--        // r2:  [- --[        TextRegion r1 = TextRegion.fromOffsetLength(0, 1);        TextRegion r2 = TextRegion.fromOffsetLength(0, 3);        assertIsBefore(r1, r2);    }    @Test    void testUnion() {        // r1:  --[-[---        // r2:  -- -[---[        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = TextRegion.fromOffsetLength(3, 3);        TextRegion union = doUnion(r1, r2);        assertRegionEquals(union, 2, 4);    }    @Test    void testUnionDisjoint() {        // r1:  --[-[- ---        // r2:  -- ---[---[        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = TextRegion.fromOffsetLength(5, 3);        TextRegion union = doUnion(r1, r2);        assertRegionEquals(union, 2, 6);    }    @Test    void testGrowLeft() {        // r1:   --[-[-        // r2:  [-- -[-        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = r1.growLeft(+2);        assertRegionEquals(r2, 0, 3);    }    @Test    void testGrowLeftNegative() {        // r1:  --[- [-        // r2:  -- -[[-        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = r1.growLeft(-1);        assertRegionEquals(r2, 3, 0);    }    @Test    void testGrowLeftOutOfBounds() {        // r1:  --[-[-        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        assertThrows(AssertionError.class, () -> r1.growLeft(4));    }    @Test    void testGrowRight() {        // r1:  --[-[-        // r2:  --[- -[        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = r1.growRight(+1);        assertRegionEquals(r2, 2, 2);    }    @Test    void testGrowRightNegative() {        // r1:  --[ -[-        // r2:  --[[- -        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        TextRegion r2 = r1.growRight(-1);        assertRegionEquals(r2, 2, 0);    }    @Test    void testGrowRightOutOfBounds() {        // r1:  --[-[-        TextRegion r1 = TextRegion.fromOffsetLength(2, 1);        assertThrows(AssertionError.class, () -> r1.growRight(-2));    }    private static void assertRegionEquals(TextRegion region, int start, int len) {        assertEquals(start, region.getStartOffset(), "Start offset");        assertEquals(len, region.getLength(), "Length");    }    private static void assertIsBefore(TextRegion r1, TextRegion r2) {        assertTrue(r1.compareTo(r2) < 0, "Region " + r1 + " should be before " + r2);        assertTrue(r2.compareTo(r1) > 0, "Region " + r2 + " should be after " + r1);    }    private static void assertNoOverlap(TextRegion r1, TextRegion r2) {        assertFalse(r1.overlaps(r2), "Regions " + r1 + " and " + r2 + " should not overlap");    }    private static void assertOverlap(TextRegion r1, TextRegion r2) {        assertTrue(r1.overlaps(r2), "Regions " + r1 + " and " + r2 + " should overlap");    }    private TextRegion doIntersect(TextRegion r1, TextRegion r2) {        TextRegion inter = TextRegion.intersect(r1, r2);        assertNotNull(inter, "Intersection of " + r1 + " and " + r2 + " must exist");        TextRegion symmetric = TextRegion.intersect(r2, r1);        assertEquals(inter, symmetric, "Intersection of " + r1 + " and " + r2 + " must be symmetric");        return inter;    }    private TextRegion doUnion(TextRegion r1, TextRegion r2) {        TextRegion union = TextRegion.union(r1, r2);        assertTrue(union.contains(r1), "Union of " + r1 + " and " + r2 + " must contain first region");        assertTrue(union.contains(r2), "Union of " + r1 + " and " + r2 + " must contain second region");        TextRegion symmetric = TextRegion.union(r2, r1);        assertEquals(union, symmetric, "Union of " + r1 + " and " + r2 + " must be symmetric");        return union;    }    private void noIntersect(TextRegion r1, TextRegion r2) {        TextRegion inter = TextRegion.intersect(r1, r2);        assertNull(inter, "Intersection of " + r1 + " and " + r2 + " must not exist");        TextRegion symmetric = TextRegion.intersect(r2, r1);        assertEquals(inter, symmetric, "Intersection of " + r1 + " and " + r2 + " must be symmetric");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.metrics;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNotSame;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;class ParameterizedMetricKeyTest {    private static final MetricOptions DUMMY_VERSION_1 = MetricOptions.ofOptions(Options.DUMMY1, Options.DUMMY2);    private static final MetricOptions DUMMY_VERSION_2 = MetricOptions.ofOptions(Options.DUMMY2);    private static final Metric<Node, Double> DUMMY_METRIC = Metric.of((n, opts) -> 0., t -> t, "dummy");    @Test    void testIdentity() {        ParameterizedMetricKey<Node, ?> key1 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_1);        ParameterizedMetricKey<Node, ?> key2 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_1);        assertEquals(key1, key2);        assertSame(key1, key2);    }    @Test    void testVersioning() {        ParameterizedMetricKey<Node, ?> key1 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_1);        ParameterizedMetricKey<Node, ?> key2 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_2);        assertNotEquals(key1, key2);        assertNotSame(key1, key2);    }    @Test    void testToString() {        ParameterizedMetricKey<Node, ?> key1 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_1);        assertTrue(key1.toString().contains(key1.metric.displayName()));        assertTrue(key1.toString().contains(key1.options.toString()));    }    @Test    void testAdHocMetricKey() {        ParameterizedMetricKey<Node, ?> key1 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_1);        ParameterizedMetricKey<Node, ?> key2 = ParameterizedMetricKey.getInstance(DUMMY_METRIC, DUMMY_VERSION_1);        assertNotNull(key1);        assertNotNull(key2);        assertSame(key1, key2);        assertEquals(key1, key2);        assertTrue(key1.toString().contains(key1.metric.displayName()));        assertTrue(key1.toString().contains(key1.options.toString()));    }    private enum Options implements MetricOption {        DUMMY1,        DUMMY2;        @Override        public String valueName() {            return null;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.symboltable;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;import org.junit.jupiter.api.Test;class ApplierTest {    private static class MyFunction implements Predicate<Object> {        private int numCallbacks = 0;        private final int maxCallbacks;        MyFunction(int maxCallbacks) {            this.maxCallbacks = maxCallbacks;        }        @Override        public boolean test(Object o) {            this.numCallbacks++;            return numCallbacks < maxCallbacks;        }        public int getNumCallbacks() {            return this.numCallbacks;        }    }    @Test    void testSimple() {        MyFunction f = new MyFunction(Integer.MAX_VALUE);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(l.size(), f.getNumCallbacks());    }    @Test    void testLimit() {        MyFunction f = new MyFunction(2);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(2, f.getNumCallbacks());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.internal;import static java.util.Collections.emptyList;import static java.util.Collections.emptySet;import static java.util.Collections.singletonList;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.Arrays;import java.util.HashSet;import java.util.List;import java.util.Objects;import java.util.Set;import java.util.function.Predicate;import java.util.stream.Collectors;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import org.pcollections.HashTreePSet;import org.pcollections.PSet;import net.sourceforge.pmd.internal.util.PredicateUtil;class LatticeRelationTest {    @Test    void testCustomTopo() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(PredicateUtil.always());        lattice.put(setOf(1, 2, 3), "123");        lattice.put(setOf(4), "4");        lattice.put(setOf(4, 3), "43");        // http://bit.ly/39J3KOu        assertEquals(setOf("123"), lattice.get(setOf(1, 2, 3)));        assertEquals(setOf("4", "43"), lattice.get(setOf(4)));        assertEquals(setOf("43", "123"), lattice.get(setOf(3)));        assertEquals(setOf("43", "123", "4"), lattice.get(emptySet()));        assertEquals(emptySet(), lattice.get(setOf(5)));    }    @Test    void testClearing() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(PredicateUtil.always());        lattice.put(setOf(1, 2), "12");        lattice.put(setOf(1), "1");        lattice.put(setOf(3), "3");        assertEquals(setOf("12"), lattice.get(setOf(2)));        assertEquals(setOf("12", "1"), lattice.get(setOf(1)));        assertEquals(setOf("12"), lattice.get(setOf(1, 2)));        assertEquals(setOf("3"), lattice.get(setOf(3)));        assertEquals(emptySet(), lattice.get(setOf(5)));        assertEquals(setOf("1", "12", "3"), lattice.get(emptySet()));        lattice.clearValues();        assertEquals(emptySet(), lattice.get(setOf(2)));        assertEquals(emptySet(), lattice.get(setOf(1)));        assertEquals(emptySet(), lattice.get(setOf(1, 2)));        assertEquals(emptySet(), lattice.get(setOf(3)));        assertEquals(emptySet(), lattice.get(setOf(5)));        assertEquals(emptySet(), lattice.get(emptySet()));    }    @Test    void testTopoFilter() {        // filter out sets with size 2        // this cuts out one level of the graph        // goal of the test is to ensure, that their predecessors (sets with size > 2)        // are still connected to successors (size < 2)        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(it -> it.size() != 2);        lattice.put(setOf(1, 2, 3), "123");        lattice.put(setOf(4), "4");        lattice.put(setOf(4, 3), "43");        lattice.put(setOf(4, 3, 5), "435");        // before filter:        // http://bit.ly/38vRsce        // after filter:        // http://bit.ly/2SxejyC        assertEquals(setOf("123"), lattice.get(setOf(1, 2, 3)));        assertEquals(setOf("4", "43", "435"), lattice.get(setOf(4)));        assertEquals(setOf("123", "43", "435"), lattice.get(setOf(3)));        assertEquals(setOf("123", "4", "43", "435"), lattice.get(emptySet()));        lattice.put(setOf(4, 3, 6), "436");        assertEquals(setOf("4", "43", "435", "436"), lattice.get(setOf(4)));    }    @Test    void testInitialSetFilter() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice =            new LatticeRelation<>(                setTopoOrder(),                setOf(setOf(1, 2), setOf(1, 2, 3), setOf(2, 3), emptySet()),                Objects::toString,                Collectors.toSet()            );        lattice.put(setOf(1, 2, 3), "123");        lattice.put(setOf(1, 2), "12");        lattice.put(setOf(1), "1");        lattice.put(setOf(2, 3, 4), "234");        lattice.put(setOf(4, 3, 5, 6), "435");        assertEquals(setOf("123"), lattice.get(setOf(1, 2, 3)));        assertEquals(setOf("12", "123"), lattice.get(setOf(1, 2)));        assertEquals(setOf("123", "234"), lattice.get(setOf(2, 3)));        assertEquals(setOf("1", "12", "123", "234", "435"), lattice.get(emptySet()));        assertEquals(emptySet(), lattice.get(setOf(4))); // not in initial set        assertEquals(emptySet(), lattice.get(setOf(4, 5))); // not in initial set        assertEquals(emptySet(), lattice.get(setOf(2, 3, 4))); // not in initial set        lattice.put(setOf(2, 3, 4), "234*");        assertEquals(setOf("123", "234", "234*"), lattice.get(setOf(2, 3))); // value "43" has been pruned    }    @Test    void testDiamond() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(PredicateUtil.always());        lattice.put(setOf(1, 2), "12");        // We have        //    {1,2}        //    /   \        //  {1}   {2}        //    \   /        //     { }        // Goal is to assert, that when we ask first for the value of { },        // the value of every node is correctly computed, even if they're        // reachable from several paths        assertEquals(setOf("12"), lattice.get(emptySet()));        assertEquals(setOf("12"), lattice.get(setOf(1)));        assertEquals(setOf("12"), lattice.get(setOf(2)));        assertEquals(setOf("12"), lattice.get(setOf(1, 2)));    }    @Test    void testFilterOnChainSetup() {        // setup for the next test (difference here is no filter)        LatticeRelation<String, String, Set<String>> lattice = stringLattice(PredicateUtil.always());        lattice.put("abc", "val");        // We have "abc" <: "bc" <: "c" <: ""        assertEquals(setOf("val"), lattice.get(""));        assertEquals(setOf("val"), lattice.get("abc"));        assertEquals(setOf("val"), lattice.get("bc"));        assertEquals(setOf("val"), lattice.get("c"));        assertEquals(emptySet(), lattice.get("d"));    }    @Test    void testFilterOnChain() {        LatticeRelation<String, String, Set<String>> lattice = stringLattice(s -> s.length() != 2 && s.length() != 1);        lattice.put("abc", "val");        // We have "abc" <: "bc" <: "c" <: ""        // We filter out both "bc" and "c"        // "abc" should still be connected to ""        assertEquals(setOf("val"), lattice.get(""));        assertEquals(setOf("val"), lattice.get("abc"));        assertEquals(emptySet(), lattice.get("bc"));        assertEquals(emptySet(), lattice.get("c"));        assertEquals(emptySet(), lattice.get("d"));    }    @Test    void testTransitiveSucc() {        LatticeRelation<String, String, Set<String>> lattice =            stringLattice(s -> s.equals("c") || s.equals("bc"));        lattice.put("abc", "val");        lattice.put("bc", "v2");        // We have "abc" <: "bc" <: "c" <: ""        assertEquals(emptySet(), lattice.transitiveQuerySuccs(""));        assertEquals(emptySet(), lattice.get(""));        assertEquals(setOf("c", "bc"), lattice.transitiveQuerySuccs("abc"));        assertEquals(emptySet(), lattice.get("abc"));        assertEquals(setOf("c"), lattice.transitiveQuerySuccs("bc"));        assertEquals(setOf("val", "v2"), lattice.get("bc"));        assertEquals(emptySet(), lattice.transitiveQuerySuccs("c"));        assertEquals(setOf("val", "v2"), lattice.get("c"));        assertEquals(emptySet(), lattice.transitiveQuerySuccs("d"));        assertEquals(emptySet(), lattice.get("d"));    }    @Test    void testTransitiveSuccWithHoleInTheMiddle() {        LatticeRelation<String, String, Set<String>> lattice =            stringLattice(setOf("abc", "bbc", "c")::contains);        lattice.put("abc", "v1");        lattice.put("bbc", "v2");        // We have "abc" <: "bc" <: "c" <: ""        // We have "bbc" <: "bc" <: "c" <: ""        // Only "abc", "bbc" and "c" are query nodes        // When adding "abc" we add its successors and link "abc" to "c"        // When adding "bbc" it must be linked to "c" even if on its        // path to "c" there is "bc", which is not a QNode and was already added        assertEquals(emptySet(), lattice.transitiveQuerySuccs(""));        assertEquals(emptySet(), lattice.get(""));        assertEquals(setOf("c"), lattice.transitiveQuerySuccs("abc"));        assertEquals(setOf("v1"), lattice.get("abc"));        assertEquals(setOf("c"), lattice.transitiveQuerySuccs("bbc"));        assertEquals(setOf("v2"), lattice.get("bbc"));        assertEquals(emptySet(), lattice.get("bc"));        assertEquals(emptySet(), lattice.transitiveQuerySuccs("c"));        assertEquals(setOf("v1", "v2"), lattice.get("c"));    }    @Test    void testToString() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(set -> set.size() < 2);        lattice.put(setOf(1, 2), "12");        //    {1,2}        //    /   \        //  {1}   {2}        //    \   /        //     { }        // all {1}, {2}, and { } are query nodes, not {1,2}        assertEquals("strict digraph {\n"                         + "n0 [ shape=box, color=green, label=\"[]\" ];\n"                         + "n1 [ shape=box, color=green, label=\"[1]\" ];\n"                         + "n2 [ shape=box, color=green, label=\"[2]\" ];\n"                         + "n3 [ shape=box, color=black, label=\"[1, 2]\" ];\n"                         + "n1 -> n0;\n" // {1}   -> { }                         + "n2 -> n0;\n" // {2}   -> { }                         + "n3 -> n0;\n" // {1,2} -> { }                         + "n3 -> n1;\n" // {1,2} -> {1}                         + "n3 -> n2;\n" // {1,2} -> {2}                         + "}", lattice.toString());    }    @Test    void testCycleDetection() {        List<String> cycle = Arrays.asList("a", "b", "c", "d");        TopoOrder<String> cyclicOrder = str -> {            int i = cycle.indexOf(str);            return singletonList(cycle.get((i + 1) % cycle.size()));        };        LatticeRelation<String, String, Set<String>> lattice =            new LatticeRelation<>(cyclicOrder, PredicateUtil.always(), Objects::toString, Collectors.toSet());        IllegalStateException exception = assertThrows(IllegalStateException.class, () -> {            lattice.put("a", "1");        });        assertEquals("Cycle in graph: a -> b -> c -> d -> a", exception.getMessage());    }    @NonNull    private LatticeRelation<String, String, Set<String>> stringLattice(Predicate<String> filter) {        return new LatticeRelation<>(stringTopoOrder(), filter, Objects::toString, Collectors.toSet());    }    @NonNull    private LatticeRelation<Set<Integer>, String, Set<String>> setLattice(Predicate<Set<Integer>> filter) {        return new LatticeRelation<>(setTopoOrder(), filter, Objects::toString, Collectors.toSet());    }    /**     * Direct successors of a set are all the sets that have exactly     * one less element. For example:     * <pre>{@code     *     * {1, 2, 3} <: {1, 2}, {1, 3}, {2, 3}     * {2, 3} <: {2}, {3}     * {2} <: {}     * etc     *     * }</pre>     *     * See eg http://bit.ly/31Xve0v     */    private static <T> TopoOrder<Set<T>> setTopoOrder() {        return node -> {            Set<Set<T>> successors = new HashSet<>();            for (T s : node) {                PSet<T> minus = HashTreePSet.<T>empty().plusAll(node).minus(s);                successors.add(minus);            }            return successors;        };    }    /**     * Generates a linear topo order according to suffix order. This     * can never form diamonds, as any string has at most one successor.     * Eg     * <pre>{@code     * "abc" <: "bc" <: "c" <: ""     * }</pre>     */    private static TopoOrder<String> stringTopoOrder() {        return str -> str.isEmpty() ? emptyList()                                    : singletonList(str.substring(1));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.internal;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sf.saxon.Configuration;import net.sf.saxon.type.Type;class ElementNodeTest {    @Test    void testCompareOrder() {        DummyRootNode root = DummyLanguageModule.parse(            "(#foo)"                + "(#foo)"        );        DummyNode c0 = root.getChild(0);        DummyNode c1 = root.getChild(1);        Configuration configuration = Configuration.newConfiguration();        AstTreeInfo treeInfo = new AstTreeInfo(root, configuration);        assertSame(root, treeInfo.getRootNode().getUnderlyingNode());        assertEquals(Type.DOCUMENT, treeInfo.getRootNode().getNodeKind());        AstElementNode rootElt = treeInfo.getRootNode().getRootElement();        assertSame(root, rootElt.getUnderlyingNode());        assertEquals(Type.ELEMENT, rootElt.getNodeKind());        assertSame(rootElt, treeInfo.findWrapperFor(root));        AstElementNode elementFoo0 = rootElt.getChildren().get(0);        assertSame(c0, elementFoo0.getUnderlyingNode());        assertSame(elementFoo0, treeInfo.findWrapperFor(c0));        AstElementNode elementFoo1 = rootElt.getChildren().get(1);        assertSame(c1, elementFoo1.getUnderlyingNode());        assertSame(elementFoo1, treeInfo.findWrapperFor(c1));        assertFalse(elementFoo0.isSameNodeInfo(elementFoo1));        assertFalse(elementFoo1.isSameNodeInfo(elementFoo0));        assertTrue(elementFoo0.compareOrder(elementFoo1) < 0);        assertTrue(elementFoo1.compareOrder(elementFoo0) > 0);        assertEquals(0, elementFoo0.compareOrder(elementFoo0));        assertEquals(0, elementFoo1.compareOrder(elementFoo1));    }    @Test    void verifyTextNodeType() {        DummyRootNode root = DummyLanguageModule.parse("(foo)(#text)");        DummyNode c0 = root.getChild(0);        DummyNode c1 = root.getChild(1);        Configuration configuration = Configuration.newConfiguration();        AstTreeInfo treeInfo = new AstTreeInfo(root, configuration);        AstElementNode rootElt = treeInfo.getRootNode().getRootElement();        assertSame(root, rootElt.getUnderlyingNode());        assertEquals(Type.ELEMENT, rootElt.getNodeKind());        assertSame(rootElt, treeInfo.findWrapperFor(root));        AstElementNode elementFoo0 = rootElt.getChildren().get(0);        assertEquals(Type.ELEMENT, elementFoo0.getNodeKind());        assertSame(c0, elementFoo0.getUnderlyingNode());        assertSame(elementFoo0, treeInfo.findWrapperFor(c0));        AstElementNode elementText1 = rootElt.getChildren().get(1);        assertEquals(Type.TEXT, elementText1.getNodeKind());        assertSame(c1, elementText1.getUnderlyingNode());        assertSame(elementText1, treeInfo.findWrapperFor(c1));    }    @Test    void verifyCommentNodeType() {        DummyRootNode root = DummyLanguageModule.parse("(#comment)");        DummyNode c1 = root.getChild(0);        Configuration configuration = Configuration.newConfiguration();        AstTreeInfo treeInfo = new AstTreeInfo(root, configuration);        AstElementNode rootElt = treeInfo.getRootNode().getRootElement();        AstElementNode elementComment = rootElt.getChildren().get(0);        assertEquals("#comment", c1.getXPathNodeName());        assertEquals(Type.COMMENT, elementComment.getNodeKind());        assertSame(c1, elementComment.getUnderlyingNode());        assertSame(elementComment, treeInfo.findWrapperFor(c1));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.internal;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.followPath;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.nodeB;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.HashMap;import java.util.List;import java.util.Map;import org.checkerframework.checker.nullness.qual.NonNull;import org.hamcrest.CoreMatchers;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.ast.DummyNodeWithListAndEnum;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.lang.rule.xpath.impl.AbstractXPathFunctionDef;import net.sourceforge.pmd.lang.rule.xpath.impl.XPathHandler;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sf.saxon.expr.Expression;import net.sf.saxon.expr.XPathContext;import net.sf.saxon.lib.ExtensionFunctionCall;import net.sf.saxon.om.Sequence;import net.sf.saxon.trans.XPathException;import net.sf.saxon.value.BooleanValue;import net.sf.saxon.value.SequenceType;class SaxonXPathRuleQueryTest {    //    Unsupported: https://github.com/pmd/pmd/issues/2451    //    @Test    //    void testListAttribute() {    //        RootNode dummy = new DummyNodeWithListAndEnum();    //    //        assertQuery(1, "//dummyNode[@List = \"A\"]", dummy);    //        assertQuery(1, "//dummyNode[@List = \"B\"]", dummy);    //        assertQuery(0, "//dummyNode[@List = \"C\"]", dummy);    //        assertQuery(1, "//dummyNode[@Enum = \"FOO\"]", dummy);    //        assertQuery(0, "//dummyNode[@Enum = \"BAR\"]", dummy);    //        assertQuery(1, "//dummyNode[@EnumList = \"FOO\"]", dummy);    //        assertQuery(1, "//dummyNode[@EnumList = \"BAR\"]", dummy);    //        assertQuery(1, "//dummyNode[@EnumList = (\"FOO\", \"BAR\")]", dummy);    //        assertQuery(0, "//dummyNode[@EmptyList = (\"A\")]", dummy);    //    }    @Test    void testHigherOrderFuns() { // XPath 3.1        DummyRootNode tree = tree(() -> root(            node()        ));        tree.setImage("[oha]");        assertQuery(1, "//dummyRootNode["            + "(@Image => substring-after('[') => substring-before(']')) "            //                --------------------    ---------------------            //                       Those are higher order functions,            //                the arrow operator applies it to the left expression            + "! . = 'oha']", tree);        //     ^ This is the mapping operator, it applies a function on        //     the right to every element of the sequence on the left        // Together this says,        // for r in dummyRootNode:        //    tmp = atomize(r/@Image)        //    tmp = substring-after('[', tmp)        //    tmp = substring-before(']', tmp)        //    if tmp == 'oha':        //      yield r    }    @Test    void testListProperty() {        RootNode dummy = new DummyNodeWithListAndEnum();        PropertyDescriptor<List<String>> prop = PropertyFactory.stringListProperty("prop")                                                               .defaultValues("FOO", "BAR")                                                               .desc("description").build();        assertQuery(1, "//dummyRootNode[@Enum = $prop]", dummy, prop);    }    @Test    void testInvalidReturn() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum();        PmdXPathException exception = assertThrows(PmdXPathException.class, () -> {            createQuery("1+2").evaluate(dummy);        });        assertThat(exception.getMessage(), CoreMatchers.containsString("XPath rule expression returned a non-node"));        assertThat(exception.getMessage(), CoreMatchers.containsString("Int64Value"));    }    @Test    void testRootExpression() {        DummyRootNode dummy = new DummyRootNode();        List<Node> result = assertQuery(1, "/", dummy);        assertEquals(dummy, result.get(0));    }    @Test    void testRootExpressionIsADocumentNode() {        DummyRootNode dummy = new DummyRootNode();        List<Node> result = assertQuery(1, "(/)[self::document-node()]", dummy);        assertEquals(dummy, result.get(0));    }    @Test    void testRootExpressionWithName() {        DummyRootNode dummy = new DummyRootNode();        String xpathName = dummy.getXPathNodeName();        List<Node> result = assertQuery(1, "(/)[self::document-node(element(" + xpathName + "))]", dummy);        assertEquals(dummy, result.get(0));        assertQuery(0, "(/)[self::document-node(element(DummyNodeX))]", dummy);    }    @Test    void ruleChainVisits() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Image='baz']/foo | //bar[@Public = 'true'] | //dummyNode[@Public = false()] | //dummyNode");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(2, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertTrue(ruleChainVisits.contains("bar"));        assertEquals(3, query.nodeNameToXPaths.size());        assertExpression("(self::node()[(string(data(@Image))) eq \"baz\"])/child::element(foo)", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("self::node()[(boolean(data(@Public))) eq false()]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(1));        assertExpression("self::node()", query.getExpressionsForLocalNameOrDefault("dummyNode").get(2));        assertExpression("self::node()[(string(data(@Public))) eq \"true\"]", query.getExpressionsForLocalNameOrDefault("bar").get(0));        assertExpression("(((docOrder((((/)/descendant::element(dummyNode))[(string(data(@Image))) eq \"baz\"])/child::element(foo))) | (((/)/descendant::element(bar))[(string(data(@Public))) eq \"true\"])) | (((/)/descendant::element(dummyNode))[(boolean(data(@Public))) eq false()])) | ((/)/descendant::element(dummyNode))", query.getFallbackExpr());    }    @Test    void ruleChainVisitsMultipleFilters() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Test1 = false()][@Test2 = true()]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(self::node()[(boolean(data(@Test1))) eq false()])[(boolean(data(@Test2))) eq true()]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("(((/)/descendant::element(dummyNode))[(boolean(data(@Test1))) eq false()])[(boolean(data(@Test2))) eq true()]", query.getFallbackExpr());    }    @Test    void ruleChainVisitsCustomFunctions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[pmd-dummy:imageIs(@Image)]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("self::node()[Q{http://pmd.sourceforge.net/pmd-dummy}imageIs(exactly-one(convertUntyped(data(@Image))))]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("((/)/descendant::element(Q{}dummyNode))[Q{http://pmd.sourceforge.net/pmd-dummy}imageIs(exactly-one(convertUntyped(data(@Image))))]", query.getFallbackExpr());    }    /**     * If a query contains another unbounded path expression other than the first one, it must be     * excluded from rule chain execution. Saxon itself optimizes this quite good already.     */    @Test    void ruleChainVisitsUnboundedPathExpressions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[//ClassOrInterfaceType]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());        assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("let $Q{http://saxon.sf.net/generated-variable}v0 := (/)/descendant::element(Q{}ClassOrInterfaceType) return (((/)/descendant::element(Q{}dummyNode))[exists($Q{http://saxon.sf.net/generated-variable}v0)])", query.getFallbackExpr());        // second sample, more complex        query = createQuery("//dummyNode[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType]]");        ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());        assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("let $Q{http://saxon.sf.net/generated-variable}v0 := (/)/descendant::element(Q{}ClassOrInterfaceType) return (((/)/descendant::element(Q{}dummyNode))[exists(ancestor::element(Q{}ClassOrInterfaceDeclaration)[exists($Q{http://saxon.sf.net/generated-variable}v0)])])", query.getFallbackExpr());        // third example, with boolean expr        query = createQuery("//dummyNode[//ClassOrInterfaceType or //OtherNode]");        ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());        assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("let $Q{http://saxon.sf.net/generated-variable}v0 := (exists((/)/descendant::element(Q{}ClassOrInterfaceType))) or (exists((/)/descendant::element(Q{}OtherNode))) return (((/)/descendant::element(Q{}dummyNode))[$Q{http://saxon.sf.net/generated-variable}v0])", query.getFallbackExpr());    }    @Test    void ruleChainVisitsNested() {        SaxonXPathRuleQuery query = createQuery("//dummyNode/foo/*/bar[@Test = 'false']");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(((self::node()/child::element(foo))/child::element())/child::element(bar))[(string(data(@Test))) eq \"false\"]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("docOrder(((docOrder((((/)/descendant::element(dummyNode))/child::element(foo))/child::element()))/child::element(bar))[(string(data(@Test))) eq \"false\"])", query.getFallbackExpr());    }    @Test    void ruleChainVisitsNested2() {        SaxonXPathRuleQuery query = createQuery("//dummyNode/foo[@Baz = 'a']/*/bar[@Test = 'false']");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("((((self::node()/child::element(foo))[(string(data(@Baz))) eq \"a\"])/child::element())/child::element(bar))[(string(data(@Test))) eq \"false\"]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("docOrder(((docOrder(((((/)/descendant::element(dummyNode))/child::element(foo))[(string(data(@Baz))) eq \"a\"])/child::element()))/child::element(bar))[(string(data(@Test))) eq \"false\"])", query.getFallbackExpr());    }    @Test    void unionBeforeSlash() {        SaxonXPathRuleQuery query = createQuery("(//dummyNode | //dummyNodeB)/dummyNode[@Image = '10']");        DummyRootNode tree = tree(() -> root(            node(                node()            ),            nodeB(                node()            )        ));        tree.descendantsOrSelf().forEach(n -> {            List<Node> results = query.evaluate(n);            assertEquals(1, results.size());            assertEquals(followPath(tree, "10"), results.get(0));        });        assertExpression("docOrder((((/)/descendant::(element(dummyNode) | element(dummyNodeB)))/child::element(dummyNode))[(string(data(@Image))) eq \"10\"])", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));    }    @Test    void unionBeforeSlashWithFilter() {        SaxonXPathRuleQuery query = createQuery("(//dummyNode[@Image='0'] | //dummyNodeB[@Image='1'])/dummyNode[@Image = '10']");        DummyRootNode tree = tree(() -> root(            node(                node()            ),            nodeB(                node()            )        ));        assertEquals(0, query.getRuleChainVisits().size());        assertExpression("docOrder((((((/)/descendant::element(dummyNode))[(string(data(@Image))) eq \"0\"]) | (((/)/descendant::element(dummyNodeB))[(string(data(@Image))) eq \"1\"]))/child::element(dummyNode))[(string(data(@Image))) eq \"10\"])", query.getFallbackExpr());        tree.descendantsOrSelf().forEach(n -> {            List<Node> results = query.evaluate(n);            assertEquals(1, results.size());            assertEquals(followPath(tree, "10"), results.get(0));        });    }    @Test    void unionBeforeSlashDeeper() {        SaxonXPathRuleQuery query = createQuery("(//dummyNode | //dummyNodeB)/dummyNode/dummyNode");        DummyRootNode tree = tree(() -> root(            node(                node(                    node()                )            ),            nodeB(                node()            )        ));        assertEquals(0, query.getRuleChainVisits().size());        assertExpression("docOrder((((/)/descendant::(element(dummyNode) | element(dummyNodeB)))/child::element(dummyNode))/child::element(dummyNode))", query.getFallbackExpr());        tree.descendantsOrSelf().forEach(n -> {            List<Node> results = query.evaluate(n);            assertEquals(1, results.size());            assertEquals(followPath(tree, "000"), results.get(0));        });    }    @Test    void ruleChainVisitWithVariable() {        PropertyDescriptor<String> testClassPattern = PropertyFactory.stringProperty("testClassPattern").desc("test").defaultValue("a").build();        SaxonXPathRuleQuery query = createQuery("//dummyNode[matches(@SimpleName, $testClassPattern)]", testClassPattern);        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("self::node()[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("((/)/descendant::element(Q{}dummyNode))[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")]", query.getFallbackExpr());    }    @Test    void ruleChainVisitWithVariable2() {        PropertyDescriptor<String> testClassPattern = PropertyFactory.stringProperty("testClassPattern").desc("test").defaultValue("a").build();        SaxonXPathRuleQuery query = createQuery("//dummyNode[matches(@SimpleName, $testClassPattern)]/foo", testClassPattern);        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(self::node()[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")])/child::element(Q{}foo)", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("docOrder((((/)/descendant::element(Q{}dummyNode))[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")])/child::element(Q{}foo))", query.getFallbackExpr());    }    @Test    void ruleChainVisitWithTwoFunctions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[ends-with(@Image, 'foo')][pmd-dummy:imageIs('bar')]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("let $v0 := imageIs(\"bar\") return ((self::node()[ends-with(convertUntyped(data(@Image)), \"foo\")])[$v0])", query.nodeNameToXPaths.get("dummyNode").get(0));    }    @Test    void ruleChainWithUnions() {        SaxonXPathRuleQuery query = createQuery("(//ForStatement | //WhileStatement | //DoStatement)//AssignmentOperator");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());    }    @Test    void ruleChainWithUnionsAndFilter() {        SaxonXPathRuleQuery query = createQuery("(//ForStatement | //WhileStatement | //DoStatement)//AssignmentOperator[@Image='foo']");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());    }    @Test    void ruleChainWithUnionsCustomFunctionsVariant1() {        SaxonXPathRuleQuery query = createQuery("(//ForStatement | //WhileStatement | //DoStatement)//dummyNode[pmd-dummy:imageIs(@Image)]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());    }    @Test    void ruleChainWithUnionsCustomFunctionsVariant2() {        SaxonXPathRuleQuery query = createQuery("//(ForStatement | WhileStatement | DoStatement)//dummyNode[pmd-dummy:imageIs(@Image)]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());    }    @Test    void ruleChainWithUnionsCustomFunctionsVariant3() {        SaxonXPathRuleQuery query = createQuery("//ForStatement//dummyNode[pmd-dummy:imageIs(@Image)]"                                                    + " | //WhileStatement//dummyNode[pmd-dummy:imageIs(@Image)]"                                                    + " | //DoStatement//dummyNode[pmd-dummy:imageIs(@Image)]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(3, ruleChainVisits.size());        assertTrue(ruleChainVisits.contains("ForStatement"));        assertTrue(ruleChainVisits.contains("WhileStatement"));        assertTrue(ruleChainVisits.contains("DoStatement"));        final String expectedSubexpression = "(self::node()/descendant::element(dummyNode))[imageIs(exactly-one(convertUntyped(data(@Image))))]";        assertExpression(expectedSubexpression, query.nodeNameToXPaths.get("ForStatement").get(0));        assertExpression(expectedSubexpression, query.nodeNameToXPaths.get("WhileStatement").get(0));        assertExpression(expectedSubexpression, query.nodeNameToXPaths.get("DoStatement").get(0));    }    private static void assertExpression(String expected, Expression actual) {        assertEquals(normalizeExprDump(expected),                     normalizeExprDump(actual.toString()));    }    private static String normalizeExprDump(String dump) {        return dump.replaceAll("Q\\{[^}]*+}", "") // remove namespaces                   // generated variable ids                   .replaceAll("\\$qq:qq-?\\d+", "\\$qq:qq000")                   .replaceAll("\\$zz:zz-?\\d+", "\\$zz:zz000");    }    private static List<Node> assertQuery(int resultSize, String xpath, Node node, PropertyDescriptor<?>... descriptors) {        SaxonXPathRuleQuery query = createQuery(xpath, descriptors);        List<Node> result = query.evaluate(node);        assertEquals(resultSize, result.size(), "Wrong number of matched nodes");        return result;    }    private static SaxonXPathRuleQuery createQuery(String xpath, PropertyDescriptor<?>... descriptors) {        Map<PropertyDescriptor<?>, Object> props = new HashMap<>();        if (descriptors != null) {            for (PropertyDescriptor<?> prop : descriptors) {                props.put(prop, prop.defaultValue());            }        }        return new SaxonXPathRuleQuery(            xpath,            XPathVersion.DEFAULT,            props,            XPathHandler.getHandlerForFunctionDefs(imageIsFunction()),            DeprecatedAttrLogger.noop()        );    }    @NonNull    private static AbstractXPathFunctionDef imageIsFunction() {        return new AbstractXPathFunctionDef("imageIs", "dummy") {            @Override            public SequenceType[] getArgumentTypes() {                return new SequenceType[] {SequenceType.SINGLE_STRING};            }            @Override            public SequenceType getResultType(SequenceType[] suppliedArgumentTypes) {                return SequenceType.SINGLE_BOOLEAN;            }            @Override            public ExtensionFunctionCall makeCallExpression() {                return new ExtensionFunctionCall() {                    @Override                    public Sequence call(XPathContext context, Sequence[] arguments) throws XPathException {                        Node contextNode = ((AstElementNode) context.getContextItem()).getUnderlyingNode();                        return BooleanValue.get(arguments[0].head().getStringValue().equals(contextNode.getImage()));                    }                };            }        };    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.impl;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.util.CollectionUtil;/** * Unit test for {@link AttributeAxisIterator} */class AttributeAxisIteratorTest {    private static final Set<String> DEFAULT_ATTRS = setOf("BeginColumn", "BeginLine", "Image", "EndColumn", "EndLine");    /**     * Test hasNext and next.     */    @Test    void testAttributeAxisIterator() {        DummyNode dummyNode = new DummyNode();        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        assertEquals(DEFAULT_ATTRS, toMap(it).keySet());    }    @Test    void testAttributeAxisIteratorWithEnum() {        DummyNodeWithEnum dummyNode = new DummyNodeWithEnum();        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Set<String> expected = CollectionUtil.setUnion(DEFAULT_ATTRS, "Enum");        assertEquals(expected, toMap(it).keySet());    }    @Test    void testAttributeAxisIteratorWithList() {        // list attributes are not supported anymore        DummyNodeWithList dummyNode = new DummyNodeWithList();        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        assertEquals(DEFAULT_ATTRS, toMap(it).keySet());    }    private Map<String, Attribute> toMap(AttributeAxisIterator it) {        Map<String, Attribute> atts = new HashMap<>();        while (it.hasNext()) {            Attribute attribute = it.next();            atts.put(attribute.getName(), attribute);        }        return atts;    }    public static class DummyNodeWithEnum extends DummyNode {        public enum MyEnum {            FOO, BAR        }        public MyEnum getEnum() {            return MyEnum.FOO;        }    }    public static class DummyNodeWithList extends DummyNode {        public List<String> getList() {            return Arrays.asList("A", "B");        }        public List<Node> getNodeList() {            return Collections.emptyList();        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html *//* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Set;import java.util.stream.Collectors;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.internal.util.IteratorUtil;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.NoAttribute.NoAttrScope;/** * @author Clément Fournier */class NoAttributeTest {    @Test    void testNoAttrInherited() {        Node child = new NodeNoInherited();        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        assertTrue(attrNames.contains("SomeInt"));        assertTrue(attrNames.contains("Child"));        // from Node        assertTrue(attrNames.contains("BeginLine"));        assertFalse(attrNames.contains("SomeLong"));        assertFalse(attrNames.contains("Image"));        assertFalse(attrNames.contains("SomeName"));    }    @Test    void testNoAttrAll() {        assertTrue(0 < IteratorUtil.count(new NodeAllAttr(12).getXPathAttributesIterator()));        NodeNoAttrAll child = new NodeNoAttrAll();        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        // from Noded, so not suppressed        assertTrue(attrNames.contains("Image"));        assertFalse(attrNames.contains("MySuppressedAttr"));    }    @Test    void testNoAttrAllIsNotInherited() {        NodeNoAttrAllChild child = new NodeNoAttrAllChild();        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        // suppressed because the parent has NoAttribute(scope = ALL)        assertFalse(attrNames.contains("MySuppressedAttr"));        // not suppressed because defined in the class, which has no annotation        assertTrue(attrNames.contains("NotSuppressedAttr"));    }    private static class DummyNodeParent extends DummyNode {        DummyNodeParent() {            super();        }        public String getSomeName() {            return "Foo";        }        public int getSomeInt() {            return 42;        }        public long getSomeLong() {            return 42;        }        public long getSomeLong2() {            return 42;        }    }    @NoAttribute(scope = NoAttrScope.INHERITED)    private static class NodeNoInherited extends DummyNodeParent {        // getSomeName is inherited and filtered out by NoAttrScope.INHERITED        // getSomeInt is inherited but overridden here, so NoAttrScope.INHERITED has no effect        // getSomeLong is inherited and overridden here,        //      and even with scope INHERITED its @NoAttribute takes precedence        // isChild overrides nothing so with INHERITED it's not filtered out        @Override        public int getSomeInt() {            return 43;        }        @NoAttribute // Notice        @Override        public long getSomeLong() {            return 43;        }        @NoAttribute(scope = NoAttrScope.INHERITED)        @Override        public String getImage() {            return super.getImage();        }        public boolean isChild() {            return true;        }    }    private static class NodeAllAttr extends DummyNodeParent {        NodeAllAttr(int id) {            super();        }    }    @NoAttribute(scope = NoAttrScope.ALL)    private static class NodeNoAttrAll extends DummyNodeParent {        public int getMySuppressedAttr() {            return 12;        }    }    private static class NodeNoAttrAllChild extends NodeNoAttrAll {        public int getNotSuppressedAttr() {            return 12;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import static net.sourceforge.pmd.PmdCoreTestUtils.setDummyLanguage;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.hasSize;import static org.junit.jupiter.api.Assertions.assertEquals;import org.hamcrest.Matchers;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContextTest;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.ast.DummyNodeWithDeprecatedAttribute;import net.sourceforge.pmd.lang.document.TextRegion;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import com.github.stefanbirkner.systemlambda.SystemLambda;class XPathRuleTest {    @Test    void testAttributeDeprecation10() throws Exception {        testDeprecation(XPathVersion.XPATH_1_0);    }    @Test    void testAttributeDeprecation20() throws Exception {        testDeprecation(XPathVersion.XPATH_2_0);    }    void testDeprecation(XPathVersion version) throws Exception {        XPathRule xpr = makeRule(version, "SomeRule");        DummyNode firstNode = newNode();        String log = SystemLambda.tapSystemErrAndOut(() -> {            // with another rule forked from the same one (in multithreaded processor)            Report report = RuleContextTest.getReportForRuleApply(xpr, firstNode);            assertEquals(1, report.getViolations().size());        });        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Size' by XPath rule 'SomeRule'"));        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Name' by XPath rule 'SomeRule', please use @Image instead"));        log = SystemLambda.tapSystemErrAndOut(() -> {            // with another node            Report report = RuleContextTest.getReportForRuleApply(xpr, newNode());            assertEquals(1, report.getViolations().size());        });        assertEquals("", log); // no additional warnings        log = SystemLambda.tapSystemErrAndOut(() -> {            // with another rule forked from the same one (in multithreaded processor)            Report report = RuleContextTest.getReportForRuleApply(xpr.deepCopy(), newNode());            assertEquals(1, report.getViolations().size());        });        assertEquals("", log); // no additional warnings        // with another rule on the same node, new warnings        XPathRule otherRule = makeRule(version, "OtherRule");        otherRule.setRuleSetName("rset.xml");        log = SystemLambda.tapSystemErrAndOut(() -> {            Report report = RuleContextTest.getReportForRuleApply(otherRule, firstNode);            assertEquals(1, report.getViolations().size());        });        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Size' by XPath rule 'OtherRule' (in ruleset 'rset.xml')"));        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Name' by XPath rule 'OtherRule' (in ruleset 'rset.xml'), please use @Image instead"));    }    XPathRule makeRule(XPathVersion version, String name) {        XPathRule xpr = new XPathRule(version, "//dummyNode[@Size >= 2 and @Name='foo']");        xpr.setName(name);        setDummyLanguage(xpr);        xpr.setMessage("gotcha");        return xpr;    }    XPathRule makeXPath(String xpathExpr) {        XPathRule xpr = new XPathRule(XPathVersion.XPATH_2_0, xpathExpr);        setDummyLanguage(xpr);        xpr.setName("name");        xpr.setMessage("gotcha");        return xpr;    }    @Test    void testFileNameInXpath() {        Report report = executeRule(makeXPath("//*[pmd:fileName() = 'Foo.cls']"),                                    newRoot("src/Foo.cls"));        assertThat(report.getViolations(), hasSize(1));    }    @Test    void testBeginLine() {        Report report = executeRule(makeXPath("//*[pmd:startLine(.)=1]"),                                    newRoot("src/Foo.cls"));        assertThat(report.getViolations(), hasSize(1));    }    @Test    void testBeginCol() {        Report report = executeRule(makeXPath("//*[pmd:startColumn(.)=1]"),                                    newRoot("src/Foo.cls"));        assertThat(report.getViolations(), hasSize(1));    }    @Test    void testEndLine() {        Report report = executeRule(makeXPath("//*[pmd:endLine(.)=1]"),                                    newRoot("src/Foo.cls"));        assertThat(report.getViolations(), hasSize(1));    }    @Test    void testEndColumn() {        Report report = executeRule(makeXPath("//*[pmd:endColumn(.)>1]"),                                    newRoot("src/Foo.cls"));        assertThat(report.getViolations(), hasSize(1));    }    Report executeRule(net.sourceforge.pmd.Rule rule, DummyNode node) {        return RuleContextTest.getReportForRuleApply(rule, node);    }    DummyRootNode newNode() {        DummyRootNode root = new DummyRootNode();        DummyNode dummy = new DummyNodeWithDeprecatedAttribute();        root.addChild(dummy, 0);        dummy.setRegion(TextRegion.fromOffsetLength(0, 1));        return root;    }    public DummyRootNode newRoot(String fileName) {        return DummyLanguageModule.parse("dummy code", fileName);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.internal;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.nodeB;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assumptions.assumeTrue;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.function.Predicate;import java.util.stream.Collectors;import java.util.stream.Stream;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.MethodSource;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyNodeTypeB;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;/** * Asserts invariants independent of the NodeStream implementation. Error * messages are not great but coverage is. */class NodeStreamBlanketTest<T extends Node> {    private static final List<Node> ASTS = Arrays.asList(        tree(            () ->                root(                    node(                        node(),                        nodeB(                            node(                                nodeB()                            )                        ),                        node(),                        nodeB()                    ),                    node()                )        ),        tree(            () ->                root(                    node(),                    node(),                    nodeB(                        node()                    ),                    node()                )        )    );    @ParameterizedTest    @MethodSource("primeNumbers")    void testToListConsistency(NodeStream<T> stream) {        List<T> toList = stream.toList();        List<T> collected = stream.collect(Collectors.toList());        List<T> fromStream = stream.toStream().collect(Collectors.toList());        List<T> cached = stream.cached().toList();        assertEquals(toList, collected);        assertEquals(toList, fromStream);        assertEquals(toList, cached);    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testToListSize(NodeStream<T> stream) {        List<T> toList = stream.toList();        assertEquals(toList.size(), stream.count());    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testLast(NodeStream<T> stream) {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("last() == toList().last()", it -> it.last() == it.toList().get(it.count() - 1))        );    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testFirst(NodeStream<T> stream) {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("first() == toList().get(0)", it -> it.first() == it.toList().get(0))        );    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testDrop(NodeStream<T> stream) {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("drop(0) == this", it -> it.drop(0) == it),            prop("drop(1).count() == count() - 1", it -> it.drop(1).count() == it.count() - 1),            prop("drop(1).toList() == toList().tail()", it -> it.drop(1).toList().equals(tail(it.toList())))        );    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testDropLast(NodeStream<T> stream) {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("dropLast(0) == this", it -> it.dropLast(0) == it),            prop("dropLast(1).count() == count() - 1", it -> it.dropLast(1).count() == it.count() - 1),            prop("dropLast(1).toList() == toList().init()", it -> it.dropLast(1).toList().equals(init(it.toList())))        );    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testDropMoreThan1(NodeStream<T> stream) {        assertImplication(            stream,            prop("count() > 1", it -> it.count() > 1),            prop("drop(2).toList() == toList().tail().tail()", it -> it.drop(2).toList().equals(tail(tail(it.toList())))),            prop("drop(1).drop(1) == drop(2)", it -> it.drop(1).drop(1).toList().equals(it.drop(2).toList()))        );    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testTake(NodeStream<T> stream) {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("it.take(0).count() == 0", it -> it.take(0).count() == 0),            prop("it.take(1).count() == 1", it -> it.take(1).count() == 1),            prop("it.take(it.count()).count() == it.count()", it -> it.take(it.count()).count() == it.count())        );    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testGet(NodeStream<T> stream) {        for (int i = 0; i < 100; i++) {            assertSame(stream.get(i), stream.drop(i).first(), "stream.get(i) == stream.drop(i).first()");        }    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testGetNegative(NodeStream<T> stream) {        assertThrows(IllegalArgumentException.class, () -> stream.get(-1));    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testDropNegative(NodeStream<T> stream) {        assertThrows(IllegalArgumentException.class, () -> stream.drop(-1));    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testTakeNegative(NodeStream<T> stream) {        assertThrows(IllegalArgumentException.class, () -> stream.take(-1));    }    @ParameterizedTest    @MethodSource("primeNumbers")    void testEmpty(NodeStream<T> stream) {        assertEquivalence(            stream,            prop("isEmpty", NodeStream::isEmpty),            prop("!nonEmpty", it -> !it.nonEmpty()),            prop("last() == null", it -> it.last() == null),            prop("first() == null", it -> it.first() == null),            prop("first(_ -> true) == null", it -> it.first(i -> true) == null),            prop("first(Node.class) == null", it -> it.first(Node.class) == null),            prop("count() == 0", it -> it.count() == 0),            prop("any(_) == false", it -> !it.any(i -> true)),            prop("all(_) == true", it -> it.all(i -> false)),            prop("none(_) == true", it -> it.none(i -> true))        );    }    static Collection<?> primeNumbers() {        return ASTS.stream().flatMap(            root -> Stream.of(                root.asStream(),                root.children().first().asStream(),                NodeStream.empty()            )        ).flatMap(            // add some transformations on each of them            stream -> Stream.of(                stream,                stream.drop(1),                stream.take(2),                stream.filter(n -> !n.getImage().isEmpty()),                stream.firstChild(DummyNodeTypeB.class),                stream.children(DummyNodeTypeB.class),                stream.descendants(DummyNodeTypeB.class),                stream.ancestors(DummyNodeTypeB.class),                stream.descendants(),                stream.ancestors(),                stream.ancestorsOrSelf(),                stream.followingSiblings(),                stream.precedingSiblings(),                stream.descendantsOrSelf(),                stream.children(),                stream.children().filter(c -> c.getImage().equals("0")),                stream.children(DummyNode.class)            )        ).flatMap(            // add some transformations on each of them            stream -> Stream.of(                stream,                stream.filterIs(DummyNode.class),                stream.take(1),                stream.drop(1),                stream.filter(n -> !n.getImage().isEmpty()),                stream.cached()            )        ).collect(Collectors.toCollection(ArrayList::new));    }    @SafeVarargs    private static <T> void assertEquivalence(T input, Prop<? super T>... properties) {        for (Prop<? super T> prop1 : properties) {            for (Prop<? super T> prop2 : properties) {                boolean p1 = prop1.test(input);                assertEquals(                    p1, prop2.test(input),                    "Expected (" + prop1.description + ") === (" + prop2.description                            + "), but the LHS was " + p1 + " and the RHS was " + !p1                );            }        }    }    @SafeVarargs    private static <T> void assertImplication(T input, Prop<? super T> precond, Prop<? super T>... properties) {        assumeTrue(precond.test(input));        for (Prop<? super T> prop2 : properties) {            assertTrue(                prop2.test(input),                "Expected (" + precond.description + ") to entail (" + prop2.description                        + "), but the latter was false"            );        }    }    static <T> Prop<T> prop(String desc, Predicate<? super T> pred) {        return new Prop<>(pred, desc);    }    static <T> List<T> tail(List<T> ts) {        return ts.subList(1, ts.size());    }    static <T> List<T> init(List<T> ts) {        return ts.subList(0, ts.size() - 1);    }    static class Prop<T> {        final Predicate<? super T> property;        final String description;        Prop(Predicate<? super T> property, String description) {            this.property = property;            this.description = description;        }        boolean test(T t) {            return property.test(t);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.internal;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.followPath;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.nodeB;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.pathsOf;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.collection.IsIterableContainingInOrder.contains;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Arrays;import java.util.Optional;import org.apache.commons.lang3.mutable.MutableInt;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyNodeTypeB;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;import net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream;/** * @author Clément Fournier */class NodeStreamTest {    private final DummyNode tree1 = tree(        () ->            root(// ""                 nodeB(// 0                       node(), // 00                       nodeB(// 01                             node(), // 010                             node(// 011                                     node() // 0110                             ),                             node(), // 012                             node()  // 013                       )                 ),                 node() // 1            )    );    private final DummyNode tree2 = tree(        () ->            root(                node(),                node(),                node(                    node()                ),                node()            )    );    @Test    void testStreamConstructionIsNullSafe() {        assertTrue(NodeStream.of((Node) null).isEmpty());        assertThat(NodeStream.of(null, null, tree1).count(), equalTo(1));        assertThat(NodeStream.fromIterable(Arrays.asList(tree1, null, null)).count(), equalTo(1));        assertThat(NodeStream.ofOptional(Optional.empty()).count(), equalTo(0));    }    @Test    void testMapIsNullSafe() {        assertTrue(tree1.descendantsOrSelf().map(n -> null).isEmpty());    }    @Test    void testFlatMapIsNullSafe() {        assertTrue(tree1.descendantsOrSelf().flatMap(n -> null).isEmpty());    }    @Test    void testChildrenStream() {        assertThat(pathsOf(tree1.children()), contains("0", "1"));        assertThat(pathsOf(tree1.asStream().children()), contains("0", "1"));    }    @Test    void testChildrenEagerEvaluation() {        NodeStream<? extends Node> children = tree1.children();        assertEquals(AxisStream.ChildrenStream.class, children.getClass());        NodeStream<Node> children1 = children.children();        assertEquals(GreedyNStream.GreedyKnownNStream.class, children1.getClass());        assertEquals(SingletonNodeStream.class, children1.filter(it -> it.getImage().endsWith("1")).getClass());    }    @Test    void testDescendantStream() {        assertThat(pathsOf(tree1.descendants()), contains("0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(tree1.asStream().descendants()), contains("0", "00", "01", "010", "011", "0110", "012", "013", "1"));    }    @Test    void testSingletonStream() {        assertThat(pathsOf(tree1.asStream()), contains(""));        assertThat(pathsOf(NodeStream.of(tree1)), contains(""));    }    @Test    void testDescendantOrSelfStream() {        assertThat(pathsOf(tree1.descendantsOrSelf()), contains("", "0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(NodeStream.of(tree1).descendantsOrSelf()), contains("", "0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(followPath(tree1, "0110").descendantsOrSelf()), contains("0110")); // with a leaf node    }    @Test    void testAncestors() {        // 010        Node node = tree1.children().children().children().first();        assertEquals("010", node.getImage());        assertThat(pathsOf(node.ancestors()), contains("01", "0", ""));        assertThat(pathsOf(node.ancestorsOrSelf()), contains("010", "01", "0", ""));        assertEquals("01", node.getNthParent(1).getImage());        assertEquals("0", node.getNthParent(2).getImage());        assertEquals("", node.getNthParent(3).getImage());        assertNull(node.getNthParent(4));    }    @Test    void testAncestorsFiltered() {        // 0110        Node node = tree1.children().children().children().children().first();        assertEquals("0110", node.getImage());        assertThat(pathsOf(node.ancestors(DummyNodeTypeB.class)), contains("01", "0"));        assertThat(pathsOf(node.ancestorsOrSelf().filterIs(DummyNodeTypeB.class)), contains("01", "0"));    }    @Test    void testAncestorsFilteredDrop() {        // 0110        Node node = tree1.children().children().children().children().first();        assertEquals("0110", node.getImage());        assertThat(pathsOf(node.ancestors(DummyNodeTypeB.class).drop(1)), contains("0"));        assertThat(pathsOf(node.ancestorsOrSelf().filterIs(DummyNodeTypeB.class).drop(1)), contains("0"));    }    @Test    void testFollowingSiblings() {        assertThat(pathsOf(followPath(tree2, "2").asStream().followingSiblings()), contains("3"));        assertThat(pathsOf(followPath(tree2, "0").asStream().followingSiblings()), contains("1", "2", "3"));        assertTrue(pathsOf(followPath(tree2, "3").asStream().followingSiblings()).isEmpty());    }    @Test    void testPrecedingSiblings() {        assertThat(pathsOf(followPath(tree2, "2").asStream().precedingSiblings()), contains("0", "1"));        assertThat(pathsOf(followPath(tree2, "3").asStream().precedingSiblings()), contains("0", "1", "2"));        assertTrue(pathsOf(followPath(tree2, "0").asStream().precedingSiblings()).isEmpty());    }    @Test    void testRootSiblings() {        assertTrue(tree2.asStream().precedingSiblings().isEmpty());        assertTrue(tree2.asStream().followingSiblings().isEmpty());    }    @Test    void testAncestorStream() {        assertThat(pathsOf(followPath(tree1, "01").ancestors()), contains("0", ""));        assertThat(pathsOf(followPath(tree1, "01").asStream().ancestors()), contains("0", ""));    }    @Test    void testParentStream() {        assertThat(pathsOf(followPath(tree1, "01").asStream().parents()), contains("0"));    }    @Test    void testAncestorStreamUnion() {        assertThat(pathsOf(NodeStream.union(followPath(tree1, "01").ancestors(),                                            tree2.children().ancestors())), contains("0", "", "", "", "", ""));    }    @Test    void testDistinct() {        assertThat(pathsOf(NodeStream.union(followPath(tree1, "01").ancestors(),                                            tree2.children().ancestors()).distinct()), contains("0", "", "")); // roots of both trees    }    @Test    void testGet() {        // ("0", "00", "01", "010", "011", "0110", "012", "013", "1")        DescendantNodeStream<DummyNode> stream = tree1.descendants();        assertEquals("0", stream.get(0).getImage());        assertEquals("00", stream.get(1).getImage());        assertEquals("010", stream.get(3).getImage());        assertEquals("011", stream.get(4).getImage());        assertEquals("0110", stream.get(5).getImage());        assertNull(stream.get(9));    }    @Test    void testNodeStreamsCanBeIteratedSeveralTimes() {        DescendantNodeStream<DummyNode> stream = tree1.descendants();        assertThat(stream.count(), equalTo(9));        assertThat(stream.count(), equalTo(9));        assertThat(pathsOf(stream), contains("0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(stream.filter(n -> n.getNumChildren() == 0)),                   contains("00", "010", "0110", "012", "013", "1"));    }    @Test    void testNodeStreamPipelineIsLazy() {        MutableInt numEvals = new MutableInt();        tree1.descendants().filter(n -> {            numEvals.increment();            return true;        });        assertThat(numEvals.getValue(), equalTo(0));    }    @Test    void testForkJoinUpstreamPipelineIsExecutedAtMostOnce() {        MutableInt numEvals = new MutableInt();        NodeStream<Node> stream =            NodeStream                .forkJoin(                    hook(numEvals::increment, tree1.descendants()),                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo("0")),                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo("1"))                );        // assertThat(numEvals.getValue(), equalTo(0)); // not evaluated yet        assertThat(stream.count(), equalTo(2));        assertThat(numEvals.getValue(), equalTo(9)); // evaluated *once* every element of the upper stream        assertThat(stream.count(), equalTo(2));        assertThat(numEvals.getValue(), equalTo(9)); // not reevaluated    }    @Test    void testCachedStreamUpstreamPipelineIsExecutedAtMostOnce() {        MutableInt upstreamEvals = new MutableInt();        MutableInt downstreamEvals = new MutableInt();        NodeStream<DummyNode> stream =            tree1.descendants()                 .filter(n -> n.getImage().matches("0.*"))                 .take(4)                 .peek(n -> upstreamEvals.increment())                 .cached()                 .filter(n -> true)                 .peek(n -> downstreamEvals.increment());        // assertThat(upstreamEvals.getValue(), equalTo(0));   // not evaluated yet        assertThat(stream.count(), equalTo(4));        assertThat(upstreamEvals.getValue(), equalTo(4));   // evaluated once        assertThat(downstreamEvals.getValue(), equalTo(4)); // evaluated once        assertThat(stream.count(), equalTo(4));        assertThat(upstreamEvals.getValue(), equalTo(4));   // upstream was not reevaluated        assertThat(downstreamEvals.getValue(), equalTo(4)); // downstream was not reevaluated    }    @Test    void testUnionIsLazy() {        MutableInt tree1Evals = new MutableInt();        MutableInt tree2Evals = new MutableInt();        NodeStream<Node> unionStream = NodeStream.union(tree1.descendantsOrSelf().peek(n -> tree1Evals.increment()),                                                        tree2.descendantsOrSelf().peek(n -> tree2Evals.increment()));        assertThat(tree1Evals.getValue(), equalTo(0));   // not evaluated yet        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated yet        assertSame(unionStream.first(), tree1);        assertThat(tree1Evals.getValue(), equalTo(1));   // evaluated once        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated    }    @Test    void testSomeOperationsAreLazy() {        MutableInt tree1Evals = new MutableInt();        NodeStream<DummyNode> unionStream = tree1.descendantsOrSelf().peek(n -> tree1Evals.increment());        int i = 0;        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated yet        unionStream.first();        assertThat(tree1Evals.getValue(), equalTo(++i));    // evaluated once        unionStream.nonEmpty();        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation        unionStream.isEmpty();        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation        // those don't trigger any evaluation        unionStream.map(p -> p);        unionStream.filter(p -> true);        unionStream.append(tree2.descendantsOrSelf());        unionStream.prepend(tree2.descendantsOrSelf());        unionStream.flatMap(Node::descendantsOrSelf);        unionStream.iterator();        // unionStream.cached();        unionStream.descendants();        unionStream.ancestors();        unionStream.followingSiblings();        unionStream.precedingSiblings();        unionStream.children();        unionStream.distinct();        unionStream.take(4);        unionStream.drop(4);        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated    }    @Test    void testFollowingSiblingsNonEmpty() {        DummyNode node = followPath(tree1, "012");        NodeStream<Node> nodes = node.asStream().followingSiblings();        assertTrue(nodes instanceof SingletonNodeStream);        assertEquals("013", nodes.first().getImage());    }    @Test    void testPrecedingSiblingsNonEmpty() {        DummyNode node = followPath(tree1, "011");        NodeStream<Node> nodes = node.asStream().precedingSiblings();        assertTrue(nodes instanceof SingletonNodeStream);        assertEquals("010", nodes.first().getImage());    }    @Test    void testPrecedingSiblingsDrop() {        DummyNode node = followPath(tree1, "012");        NodeStream<Node> nodes = node.asStream().precedingSiblings().drop(1);        assertThat(pathsOf(nodes), contains("011"));    }    @Test    void testFollowingSiblingsDrop() {        DummyNode node = followPath(tree1, "011");        NodeStream<Node> nodes = node.asStream().followingSiblings().drop(1);        assertThat(pathsOf(nodes), contains("013"));    }    private static <T extends Node> NodeStream<T> hook(Runnable hook, NodeStream<T> stream) {        return stream.filter(t -> {            hook.run();            return true;        });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.impl.javacc;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.document.Chars;import net.sourceforge.pmd.lang.document.TextDocument;class JavaEscapeReaderTest {    TextDocument readString(String input) {        TextDocument intext = TextDocument.readOnlyString(Chars.wrap(input), DummyLanguageModule.getInstance().getDefaultVersion());        return new JavaEscapeTranslator(intext).translateDocument();    }    @Test    void testSimpleRead() throws IOException {        String input = "abcdede";        try (TextDocument r = readString(input)) {            assertEquals(Chars.wrap(input), r.getText());        }    }    @Test    void testNotAnEscape1Read() throws IOException {        String input = "abc\\dede";        try (TextDocument r = readString(input)) {            assertEquals(Chars.wrap(input), r.getText());        }    }    @Test    void testNotAnEscape1Read2() throws IOException {        String input = "abc\\\\\\dede";        try (TextDocument r = readString(input)) {            assertEquals(Chars.wrap(input), r.getText());        }    }    @Test    void testAnEscapeStopAtEnd() throws IOException {        String input = "abc\\\\\\u00a0dede";        try (TextDocument r = readString(input)) {            assertEquals(Chars.wrap("abc\u00a0dede"), r.getText());        }    }    @Test    void testSeveralEscapes() throws IOException {        String input = "abc\\\\\\u00a0d\\uu00a0ede";        try (TextDocument r = readString(input)) {            assertEquals(Chars.wrap("abc\u00a0d\u00a0ede"), r.getText());        }    }    @Test    void testAnEscapeInsideBlock() throws IOException {        String input = "abc\\\\\\u00a0dede\\u00a0";        try (TextDocument r = readString(input)) {            assertEquals(Chars.wrap("abc\u00a0dede\u00a0"), r.getText());        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.impl.javacc;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.io.EOFException;import java.io.IOException;import java.util.Collections;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.impl.javacc.JavaccTokenDocument.TokenDocumentBehavior;import net.sourceforge.pmd.lang.document.TextDocument;class CharStreamTest {    private LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();    @Test    void testReadZeroChars() throws IOException {        CharStream stream = simpleCharStream("");        assertThrows(EOFException.class, stream::readChar);        assertEquals(stream.getStartOffset(), 0);        assertEquals(stream.getEndOffset(), 0);    }    @Test    void testMultipleEofReads() throws IOException {        CharStream stream = simpleCharStream("");        for (int i = 0; i < 3; i++) {            assertThrows(EOFException.class, stream::readChar);        }    }    @Test    void testReadStuff() throws IOException {        CharStream stream = simpleCharStream("abcd");        assertEquals('a', stream.readChar());        assertEquals('b', stream.readChar());        assertEquals('c', stream.readChar());        assertEquals('d', stream.readChar());        assertThrows(EOFException.class, stream::readChar);    }    @Test    void testReadBacktrack() throws IOException {        CharStream stream = simpleCharStream("abcd");        assertEquals('a', stream.markTokenStart());        assertEquals('b', stream.readChar());        assertEquals('c', stream.readChar());        assertEquals('d', stream.readChar());        assertEquals("abcd", stream.getTokenImage());        stream.backup(2);        assertEquals('c', stream.readChar());        assertEquals('d', stream.readChar());        assertThrows(EOFException.class, stream::readChar);    }    @Test    void testReadBacktrackWithEscapes() throws IOException {        CharStream stream = javaCharStream("__\\u00a0_\\u00a0_");        assertEquals('_', stream.markTokenStart());        assertEquals('_', stream.readChar());        assertEquals('\u00a0', stream.readChar());        assertEquals('_', stream.readChar());        assertEquals("__\u00a0_", stream.getTokenImage());        stream.backup(2);        assertEquals('\u00a0', stream.readChar());        assertEquals('_', stream.readChar());        assertEquals('\u00a0', stream.readChar());        assertEquals("__\u00a0_\u00a0", stream.getTokenImage());        assertEquals('_', stream.readChar());        stream.backup(2);        assertEquals('\u00a0', stream.markTokenStart());        assertEquals('_', stream.readChar());        assertEquals("\u00a0_", stream.getTokenImage());        assertThrows(EOFException.class, stream::readChar);    }    @Test    void testBacktrackTooMuch() throws IOException {        CharStream stream = simpleCharStream("abcd");        assertEquals('a', stream.readChar());        assertEquals('b', stream.readChar());        assertEquals('c', stream.markTokenStart());        assertEquals('d', stream.readChar());        stream.backup(2); // ok        assertThrows(IllegalArgumentException.class, () -> stream.backup(1));    }    @Test    void testBacktrackTooMuch2() throws IOException {        CharStream stream = simpleCharStream("abcd");        assertEquals('a', stream.markTokenStart());        assertEquals('b', stream.readChar());        assertEquals('c', stream.readChar());        assertEquals('d', stream.readChar());        assertThrows(IllegalArgumentException.class, () -> stream.backup(10));    }    CharStream simpleCharStream(String abcd) {        return CharStream.create(TextDocument.readOnlyString(abcd, dummyVersion), TokenDocumentBehavior.DEFAULT);    }    CharStream javaCharStream(String abcd) {        return CharStream.create(            TextDocument.readOnlyString(abcd, dummyVersion),            new TokenDocumentBehavior(Collections.emptyList()) {                @Override                public TextDocument translate(TextDocument text) throws MalformedSourceException {                    return new JavaEscapeTranslator(text).translateDocument();                }            });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.impl;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.fail;import java.util.List;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.MethodSource;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for {@link AbstractNode}. */class AbstractNodeTest {    private static final int NUM_CHILDREN = 3;    private static final int NUM_GRAND_CHILDREN = 3;    // Note that in order to successfully run JUnitParams, we need to explicitly use `Integer` instead of `int`    static Integer[] childrenIndexes() {        return getIntRange(NUM_CHILDREN);    }    static Integer[] grandChildrenIndexes() {        return getIntRange(NUM_GRAND_CHILDREN);    }    private static Integer[] getIntRange(final int exclusiveLimit) {        final Integer[] childIndexes = new Integer[exclusiveLimit];        for (int i = 0; i < exclusiveLimit; i++) {            childIndexes[i] = i;        }        return childIndexes;    }    static Object childrenAndGrandChildrenIndexes() {        final Integer[] childrenIndexes = childrenIndexes();        final Integer[] grandChildrenIndexes = grandChildrenIndexes();        final Object[] indexes = new Object[childrenIndexes.length * grandChildrenIndexes.length];        int i = 0;        for (final int childIndex : childrenIndexes) {            for (final int grandChildIndex : grandChildrenIndexes) {                indexes[i++] = new Integer[] { childIndex, grandChildIndex };            }        }        return indexes;    }    private DummyRootNode rootNode;    @BeforeEach    void setUpSampleNodeTree() {        rootNode = tree(            () -> {                DummyRootNode root = root();                for (int i = 0; i < NUM_CHILDREN; i++) {                    final DummyNode child = node();                    for (int j = 0; j < NUM_GRAND_CHILDREN; j++) {                        child.addChild(node(), j);                    }                    root.addChild(child, i);                }                return root;            }        );    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method     */    @ParameterizedTest    @MethodSource("childrenIndexes")    void testRemoveChildOfRootNode(final int childIndex) {        final DummyNode child = rootNode.getChild(childIndex);        final List<? extends DummyNode> grandChildren = child.children().toList();        // Do the actual removal        child.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.getNumChildren());        assertNull(child.getParent());        // The child node is expected to still have all its children and vice versa        assertEquals(NUM_GRAND_CHILDREN, child.getNumChildren());        for (final Node grandChild : grandChildren) {            assertEquals(child, grandChild.getParent());        }    }    @Test    void testPrevNextSiblings() {        DummyRootNode root = tree(() -> root(node(), node()));        assertNull(root.getNextSibling());        assertNull(root.getPreviousSibling());        DummyNode c0 = root.getChild(0);        DummyNode c1 = root.getChild(1);        assertSame(c0, c1.getPreviousSibling());        assertSame(c1, c0.getNextSibling());        assertNull(c1.getNextSibling());        assertNull(c0.getPreviousSibling());    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * This is a border case as the root node does not have any parent.     */    @Test    void testRemoveRootNode() {        // Check that the root node has the expected properties        final List<? extends DummyNode> children = rootNode.children().toList();        // Do the actual removal        rootNode.remove();        // Check that conditions have been successfully changed, i.e.,        //  the root node is expected to still have all its children and vice versa        assertEquals(NUM_CHILDREN, rootNode.getNumChildren());        assertNull(rootNode.getParent());        for (final Node aChild : children) {            assertEquals(rootNode, aChild.getParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * These are border cases as grandchildren nodes do not have any child.     */    @ParameterizedTest    @MethodSource("childrenAndGrandChildrenIndexes")    void testRemoveGrandChildNode(final int childIndex, final int grandChildIndex) {        final DummyNode child = rootNode.getChild(childIndex);        final DummyNode grandChild = child.getChild(grandChildIndex);        // Do the actual removal        grandChild.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_GRAND_CHILDREN - 1, child.getNumChildren());        assertEquals(0, grandChild.getNumChildren());        assertNull(grandChild.getParent());    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     */    @ParameterizedTest    @MethodSource("childrenIndexes")    void testRemoveRootNodeChildAtIndex(final int childIndex) {        final List<? extends DummyNode> originalChildren = rootNode.children().toList();        // Do the actual removal        rootNode.removeChildAtIndex(childIndex);        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.getNumChildren());        int j = 0;        for (int i = 0; i < rootNode.getNumChildren(); i++) {            if (j == childIndex) { // Skip the removed child                j++;            }            // Check that the nodes have been rightly shifted            assertEquals(originalChildren.get(j), rootNode.getChild(i));            // Check that the child index has been updated            assertEquals(i, rootNode.getChild(i).getIndexInParent());            j++;        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * Test that invalid indexes cases are handled without exception.     */    @Test    void testRemoveChildAtIndexWithInvalidIndex() {        try {            rootNode.removeChildAtIndex(-1);            rootNode.removeChildAtIndex(rootNode.getNumChildren());        } catch (final Exception e) {            fail("No exception was expected.");        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * This is a border case as the method invocation should do nothing.     */    @ParameterizedTest    @MethodSource("grandChildrenIndexes")    void testRemoveChildAtIndexOnNodeWithNoChildren(final int grandChildIndex) {        // grandChild does not have any child        final DummyNode grandChild = rootNode.getChild(grandChildIndex).getChild(grandChildIndex);        // Do the actual removal        grandChild.removeChildAtIndex(0);        // If here, no exception has been thrown        // Check that this node still does not have any children        assertEquals(0, grandChild.getNumChildren());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.mockito.Mockito.contains;import static org.mockito.Mockito.eq;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.spy;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.verifyNoMoreInteractions;import static org.mockito.Mockito.when;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.slf4j.Logger;import org.slf4j.event.Level;import org.slf4j.helpers.NOPLogger;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.ast.Parser.ParserTask;import net.sourceforge.pmd.lang.document.TextDocument;import net.sourceforge.pmd.util.log.MessageReporter;/** * Reports errors that occur after parsing. This may be used to implement * semantic checks in a language specific way. */class SemanticErrorReporterTest {    private static final String MOCK_FILENAME = "dummy/file.txt";    MessageReporter mockReporter;    Logger mockLogger;    @BeforeEach    void setup() {        mockReporter = mock(MessageReporter.class);        when(mockReporter.isLoggable(Level.ERROR)).thenReturn(true);        mockLogger = spy(NOPLogger.class);    }    @Test    void testErrorLogging() {        SemanticErrorReporter reporter = SemanticErrorReporter.reportToLogger(mockReporter);        RootNode node = parseMockNode(reporter);        assertNull(reporter.getFirstError());        String message = "an error occurred";        reporter.error(node, message);        verify(mockReporter).log(eq(Level.ERROR), contains(message));        verifyNoMoreInteractions(mockLogger);        assertNotNull(reporter.getFirstError());    }    @Test    void testEscaping() {        SemanticErrorReporter reporter = SemanticErrorReporter.reportToLogger(mockReporter);        RootNode node = parseMockNode(reporter);        // this is a MessageFormat string        // what ends up being logged is just '        String message = "an apostrophe '' ";        reporter.error(node, message);        // The backend reporter will do its own formatting once again        verify(mockReporter).log(eq(Level.ERROR), contains("an apostrophe ''"));        verifyNoMoreInteractions(mockLogger);    }    private RootNode parseMockNode(SemanticErrorReporter reporter) {        Language language = DummyLanguageModule.getInstance();        Parser parser = language.getDefaultVersion().getLanguageVersionHandler().getParser();        TextDocument doc = TextDocument.readOnlyString("(mock (node))", MOCK_FILENAME, language.getDefaultVersion());        return parser.parse(new ParserTask(            doc,            reporter        ));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;/** * Unit test for {@link Node} tree traversal methods */class BoundaryTraversalTest {    private DummyNode rootNode;    private DummyNode newDummyNode(boolean boundary) {        return new DummyNode(boundary);    }    private DummyNode addChild(final DummyNode parent, final DummyNode child) {        parent.addChild(child, parent.getNumChildren()); // Append child at the end        return parent;    }    @BeforeEach    void setUpSampleNodeTree() {        rootNode = newDummyNode(false);    }    @Test    void testBoundaryIsHonored() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.descendants(DummyNode.class).toList();        assertEquals(1, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());    }    @Test    void testSearchFromBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.descendants(DummyNode.class).first().descendants(DummyNode.class).toList();        assertEquals(1, descendantsOfType.size());        assertFalse(descendantsOfType.get(0).isFindBoundary());    }    @Test    void testSearchFromBoundaryFromNonOptimisedStream() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.descendants(DummyNode.class).take(1).descendants(DummyNode.class).toList();        assertEquals(1, descendantsOfType.size());        assertFalse(descendantsOfType.get(0).isFindBoundary());    }    @Test    void testSearchIgnoringBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class, true);        assertEquals(2, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());        assertFalse(descendantsOfType.get(1).isFindBoundary());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNotSame;import static org.junit.jupiter.api.Assertions.assertSame;import org.junit.jupiter.api.Test;class LanguageRegistryTest {    private final LanguageRegistry languageRegistry = LanguageRegistry.PMD;    @Test    public void getDefaultVersionLanguageTest() {        Language dummy = languageRegistry.getLanguageById("dummy");        LanguageVersion dummy12 = dummy.getVersion("1.2");        assertNotNull(dummy12);        LanguageVersion dummyDefault = dummy.getDefaultVersion();        assertNotNull(dummyDefault);        assertNotSame(dummy12, dummyDefault);    }    @Test    public void getLanguageVersionByAliasTest() {        Language dummy = languageRegistry.getLanguageById("dummy");        LanguageVersion dummy17 = dummy.getVersion("1.7");        assertNotNull(dummy17);        assertEquals("1.7", dummy17.getVersion());        LanguageVersion dummy7 = dummy.getVersion("7");        assertNotNull(dummy7);        assertEquals("1.7", dummy17.getVersion());        assertSame(dummy17, dummy7);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cli.PMDCommandLineInterface;import net.sourceforge.pmd.cli.PMDParameters;class LanguageParameterTest {    /** Test that language parameters from the CLI are correctly passed through to the PMDConfiguration. Although this is a     * CLI test, it resides here to take advantage of {@link net.sourceforge.pmd.lang.DummyLanguageModule}     */    @Test    void testLanguageFromCliToConfiguration() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "ideaj", "-P", "sourcePath=/home/user/source/", "-R", "java-empty", "-force-language", "dummy"};        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertEquals(DummyLanguageModule.getInstance().getDefaultVersion().getName(), params.toConfiguration().getForceLanguageVersion().getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties.constraints;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class NumericConstraintsTest {    @Test    void testInRangeInteger() {        PropertyConstraint<Integer> constraint = NumericConstraints.inRange(1, 10);        assertTrue(constraint.test(1));        assertTrue(constraint.test(5));        assertTrue(constraint.test(10));        assertFalse(constraint.test(0));        assertFalse(constraint.test(-1));        assertFalse(constraint.test(11));        assertFalse(constraint.test(100));    }    @Test    void testInRangeDouble() {        PropertyConstraint<Double> constraint = NumericConstraints.inRange(1.0, 10.0);        assertTrue(constraint.test(1.0));        assertTrue(constraint.test(5.5));        assertTrue(constraint.test(10.0));        assertFalse(constraint.test(0.0));        assertFalse(constraint.test(-1.0));        assertFalse(constraint.test(11.1));        assertFalse(constraint.test(100.0));    }    @Test    void testPositive() {        PropertyConstraint<Number> constraint = NumericConstraints.positive();        assertTrue(constraint.test(1));        assertTrue(constraint.test(1.5f));        assertTrue(constraint.test(1.5d));        assertTrue(constraint.test(100));        assertFalse(constraint.test(0));        assertFalse(constraint.test(0.1f));        assertFalse(constraint.test(0.9d));        assertFalse(constraint.test(-1));        assertFalse(constraint.test(-100));        assertFalse(constraint.test(-0.1f));        assertFalse(constraint.test(-0.1d));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import java.util.regex.Pattern;/** * Since there's no RegexMultiProperty the base class is only partially implemented, * and some tests are overridden with no-op ones. * * @author Clément Fournier * @since 6.2.0 */@Deprecatedclass RegexPropertyTest extends AbstractPropertyDescriptorTester<Pattern> {    RegexPropertyTest() {        super("Regex");    }    @Override    protected Pattern createValue() {        return Pattern.compile("abc++");    }    @Override    protected Pattern createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Pattern> createProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa)+").desc("the description").build();    }    @Override    protected PropertyDescriptor<Pattern> createBadProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa").desc("the description").build();    }    // The following are deliberately unimplemented, since they are only relevant to the tests of the multiproperty    @Override    protected PropertyDescriptor<List<Pattern>> createMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    protected PropertyDescriptor<List<Pattern>> createBadMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    void testAddAttributesMulti() {    }    @Override    void testAsDelimitedString() {    }    @Override    void testErrorForBadMulti() {    }    @Override    void testErrorForCorrectMulti() {    }    @Override    void testFactoryMultiValueDefaultDelimiter() {    }    @Override    void testFactoryMultiValueCustomDelimiter() {    }    @Override    void testTypeMulti() {    }    @Override    void testIsMultiValueMulti() {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.jupiter.api.Test;/** * @author Brian Remedios */class BooleanPropertyTest extends AbstractPropertyDescriptorTester<Boolean> {    BooleanPropertyTest() {        super("Boolean");    }    @Override    protected Boolean createValue() {        return randomBool();    }    @Override    @Test    void testErrorForBadSingle() {        // override, cannot create a 'bad' boolean per se    }    @Override    @Test    void testErrorForBadMulti() {        // override, cannot create a 'bad' boolean per se    }    @Override    protected Boolean createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Boolean> createProperty() {        return new BooleanProperty("testBoolean", "Test boolean property", false, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createMultiProperty() {        return new BooleanMultiProperty("testBoolean", "Test boolean property",                                        new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createBadMultiProperty() {        return new BooleanMultiProperty("", "Test boolean property", new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<Boolean> createBadProperty() {        return new BooleanProperty("testBoolean", "", false, 1.0f);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the StringProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid strings per any * specified expressions, and serialize/deserialize groups of strings onto/from * a string buffer. * * @author Brian Remedios */class StringPropertyTest extends AbstractPropertyDescriptorTester<String> {    private static final int MAX_STRING_LENGTH = 52;    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    StringPropertyTest() {        super("String");    }    @Override    protected String createValue() {        return newString();    }    /**     * Method newString.     *     * @return String     */    private String newString() {        int strLength = randomInt(1, MAX_STRING_LENGTH);        char[] chars = new char[strLength];        for (int i = 0; i < chars.length; i++) {            chars[i] = randomCharIn(CHARSET);        }        return new String(chars);    }    /**     * Method randomCharIn.     *     * @param chars char[]     *     * @return char     */    private char randomCharIn(char[] chars) {        return randomChar(chars);    }    @Override    protected String createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<String> createProperty() {        return new StringProperty("testString", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world"}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<String> createBadProperty() {        return new StringProperty("", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createBadMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world", "a" + DELIMITER + "b"}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static java.util.Collections.emptyList;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.allOf;import static org.hamcrest.Matchers.containsString;import static org.hamcrest.Matchers.hasItem;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;import org.apache.commons.lang3.StringUtils;import org.hamcrest.Matcher;import org.hamcrest.Matchers;import org.hamcrest.core.SubstringMatcher;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.properties.constraints.PropertyConstraint;/** * Mostly TODO, I'd rather implement tests on the final version of the framework. * * @author Clément Fournier * @since 7.0.0 */class PropertyDescriptorTest {    @Test    void testConstraintViolationCausesDysfunctionalRule() {        PropertyDescriptor<Integer> intProperty = PropertyFactory.intProperty("fooProp")                                                                 .desc("hello")                                                                 .defaultValue(4)                                                                 .require(inRange(1, 10))                                                                 .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(intProperty);        rule.setProperty(intProperty, 1000);        RuleSet ruleSet = RuleSet.forSingleRule(rule);        List<Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    void testConstraintViolationCausesDysfunctionalRuleMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(descriptor);        rule.setProperty(descriptor, Collections.singletonList(1000d)); // not in range        RuleSet ruleSet = RuleSet.forSingleRule(rule);        List<Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    void testDefaultValueConstraintViolationCausesFailure() {        PropertyConstraint<Integer> constraint = inRange(1, 10);        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () ->            PropertyFactory.intProperty("fooProp")                           .desc("hello")                           .defaultValue(1000)                           .require(constraint)                           .build());        assertThat(thrown.getMessage(), allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                containsIgnoreCase(constraint.getConstraintDescription())));    }    @Test    void testDefaultValueConstraintViolationCausesFailureMulti() {        PropertyConstraint<Double> constraint = inRange(1d, 10d);        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () ->            PropertyFactory.doubleListProperty("fooProp")                           .desc("hello")                           .defaultValues(2., 11.) // 11. is out of range                           .requireEach(constraint)                           .build());        assertThat(thrown.getMessage(), allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                containsIgnoreCase(constraint.getConstraintDescription())));    }    @Test    void testNoConstraintViolationCausesIsOkMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertThat(descriptor.defaultValue(), Matchers.contains(2., 11.));    }    @Test    void testNoConstraintViolationCausesIsOk() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValue("bazooli")                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("bazooli", descriptor.defaultValue());    }    @Test    void testIntProperty() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        assertEquals("intProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Integer.valueOf(1), descriptor.defaultValue());        assertEquals(Integer.valueOf(5), descriptor.valueFrom("5"));        assertEquals(Integer.valueOf(5), descriptor.valueFrom(" 5 "));        PropertyDescriptor<List<Integer>> listDescriptor = PropertyFactory.intListProperty("intListProp")                .desc("hello")                .defaultValues(1, 2)                .build();        assertEquals("intListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1, 2), listDescriptor.defaultValue());        assertEquals(Arrays.asList(5, 7), listDescriptor.valueFrom("5,7"));        assertEquals(Arrays.asList(5, 7), listDescriptor.valueFrom(" 5 , 7 "));    }    @Test    void testIntPropertyInvalidValue() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        NumberFormatException thrown = assertThrows(NumberFormatException.class, () ->            descriptor.valueFrom("not a number"));        assertThat(thrown.getMessage(), containsString("not a number"));    }    @Test    void testDoubleProperty() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        assertEquals("doubleProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Double.valueOf(1.0), descriptor.defaultValue());        assertEquals(Double.valueOf(2.0), descriptor.valueFrom("2.0"));        assertEquals(Double.valueOf(2.0), descriptor.valueFrom("  2.0  "));        PropertyDescriptor<List<Double>> listDescriptor = PropertyFactory.doubleListProperty("doubleListProp")                .desc("hello")                .defaultValues(1.0, 2.0)                .build();        assertEquals("doubleListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1.0, 2.0), listDescriptor.defaultValue());        assertEquals(Arrays.asList(2.0, 3.0), listDescriptor.valueFrom("2.0,3.0"));        assertEquals(Arrays.asList(2.0, 3.0), listDescriptor.valueFrom(" 2.0 , 3.0 "));    }    @Test    void testDoublePropertyInvalidValue() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        NumberFormatException thrown = assertThrows(NumberFormatException.class, () ->            descriptor.valueFrom("this is not a number"));        assertThat(thrown.getMessage(), containsString("this is not a number"));    }    @Test    void testStringProperty() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("stringProp")                .desc("hello")                .defaultValue("default value")                .build();        assertEquals("stringProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("default value", descriptor.defaultValue());        assertEquals("foo", descriptor.valueFrom("foo"));        assertEquals("foo", descriptor.valueFrom("  foo   "));        PropertyDescriptor<List<String>> listDescriptor = PropertyFactory.stringListProperty("stringListProp")                .desc("hello")                .defaultValues("v1", "v2")                .build();        assertEquals("stringListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList("v1", "v2"), listDescriptor.defaultValue());        assertEquals(Arrays.asList("foo", "bar"), listDescriptor.valueFrom("foo|bar"));        assertEquals(Arrays.asList("foo", "bar"), listDescriptor.valueFrom("  foo |  bar  "));    }    private enum SampleEnum { A, B, C }    private static Map<String, SampleEnum> nameMap = new LinkedHashMap<>();    static {        nameMap.put("TEST_A", SampleEnum.A);        nameMap.put("TEST_B", SampleEnum.B);        nameMap.put("TEST_C", SampleEnum.C);    }    @Test    void testEnumProperty() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        assertEquals("enumProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(SampleEnum.B, descriptor.defaultValue());        assertEquals(SampleEnum.C, descriptor.valueFrom("TEST_C"));        PropertyDescriptor<List<SampleEnum>> listDescriptor = PropertyFactory.enumListProperty("enumListProp", nameMap)                .desc("hello")                .defaultValues(SampleEnum.A, SampleEnum.B)                .build();        assertEquals("enumListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(SampleEnum.A, SampleEnum.B), listDescriptor.defaultValue());        assertEquals(Arrays.asList(SampleEnum.B, SampleEnum.C), listDescriptor.valueFrom("TEST_B|TEST_C"));    }    @Test    void testEnumPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () ->            PropertyFactory.enumProperty("enumProp", map));        assertThat(thrown.getMessage(), containsIgnoreCase("null value"));    }    @Test    void testEnumListPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () ->            PropertyFactory.enumListProperty("enumProp", map));        assertThat(thrown.getMessage(), containsIgnoreCase("null value"));    }    @Test    void testEnumPropertyInvalidValue() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () ->            descriptor.valueFrom("InvalidEnumValue"));        assertThat(thrown.getMessage(), containsString("Value was not in the set [TEST_A, TEST_B, TEST_C]"));    }    @Test    void testRegexProperty() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        assertEquals("regexProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("^[A-Z].*$", descriptor.defaultValue().toString());        assertEquals("[0-9]+", descriptor.valueFrom("[0-9]+").toString());    }    @Test    void testRegexPropertyInvalidValue() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        PatternSyntaxException thrown = assertThrows(PatternSyntaxException.class, () ->            descriptor.valueFrom("[open class"));        assertThat(thrown.getMessage(), containsString("Unclosed character class"));    }    @Test    void testRegexPropertyInvalidDefaultValue() {        PatternSyntaxException thrown = assertThrows(PatternSyntaxException.class, () ->            PropertyFactory.regexProperty("regexProp")                    .desc("hello")                    .defaultValue("[open class")                    .build());        assertThat(thrown.getMessage(), containsString("Unclosed character class"));    }    private static List<String> parseEscaped(String s, char d) {        return ValueParserConstants.parseListWithEscapes(s, d, ValueParserConstants.STRING_PARSER);    }    @Test    void testStringParserEmptyString() {        assertEquals(emptyList(), parseEscaped("", ','));    }    @Test    void testStringParserSimple() {        assertEquals(listOf("a", "b", "c"),                     parseEscaped("a,b,c", ','));    }    @Test    void testStringParserEscapedChar() {        assertEquals(listOf("a", "b,c"),                     parseEscaped("a,b\\,c", ','));    }    @Test    void testStringParserEscapedEscapedChar() {        assertEquals(listOf("a", "b\\", "c"),                     parseEscaped("a,b\\\\,c", ','));    }    @Test    void testStringParserDelimIsBackslash() {        assertEquals(listOf("a,b", "", ",c"),                     parseEscaped("a,b\\\\,c", '\\'));    }    @Test    void testStringParserTrailingBackslash() {        assertEquals(listOf("a", "b\\"),                     parseEscaped("a,b\\", ','));    }    private static Matcher<String> containsIgnoreCase(final String substring) {        return new SubstringMatcher("containing (ignoring case)", true, substring) {            @Override            protected boolean evalSubstringOf(String string) {                return StringUtils.indexOfIgnoreCase(string, substring) != -1;            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.jupiter.api.Test;/** * Evaluates the functionality of the CharacterProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid characters, * and serialize/deserialize any default values. * * @author Brian Remedios */@Deprecatedclass CharacterPropertyTest extends AbstractPropertyDescriptorTester<Character> {    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    CharacterPropertyTest() {        super("Character");    }    @Override    @Test    void testErrorForBadSingle() {    } // not until char properties use illegal chars    @Override    @Test    void testErrorForBadMulti() {    } // not until char properties use illegal chars    @Override    protected Character createValue() {        return randomChar(CHARSET);    }    @Override    protected Character createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Character> createProperty() {        return new CharacterProperty("testCharacter", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<Character> createBadProperty() {        return new CharacterProperty("", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createBadMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the IntegerProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of integers onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedclass IntegerPropertyTest extends AbstractNumericPropertyDescriptorTester<Integer> {    private static final int MIN = 1;    private static final int MAX = 12;    private static final int SHIFT = 4;    IntegerPropertyTest() {        super("Integer");    }    @Override    protected Integer createValue() {        return randomInt(MIN, MAX);    }    @Override    protected Integer createBadValue() {        return randomBool() ? randomInt(MIN - SHIFT, MIN - 1) : randomInt(MAX + 1, MAX + SHIFT);    }    protected IntegerProperty.IntegerPBuilder singleBuilder() {        return IntegerProperty.named("test").desc("foo")                              .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected IntegerMultiProperty.IntegerMultiPBuilder multiBuilder() {        return IntegerMultiProperty.named("test").desc("foo")                                   .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Integer> createProperty() {        return new IntegerProperty("testInteger", "Test integer property", MIN, MAX, MAX - 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createMultiProperty() {        return new IntegerMultiProperty("testInteger", "Test integer property", MIN, MAX,                                        new Integer[] {MIN, MIN + 1, MAX - 1, MAX}, 1.0f);    }    @Override    protected PropertyDescriptor<Integer> createBadProperty() {        return new IntegerProperty("", "Test integer property", MIN, MAX, MAX + 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createBadMultiProperty() {        return new IntegerMultiProperty("testInteger", "", MIN, MAX, new Integer[] {MIN - 1, MAX}, 1.0f);    }    @Override    protected Integer min() {        return MIN;    }    @Override    protected Integer max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the FloatProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of float values onto/from a string * buffer. * * @author Brian Remedios */class FloatPropertyTest extends AbstractNumericPropertyDescriptorTester<Float> {    private static final float MIN = 1.0f;    private static final float MAX = 11.0f;    private static final float SHIFT = 3.0f;    FloatPropertyTest() {        super("Float");    }    @Override    protected Float createValue() {        return randomFloat(MIN, MAX);    }    @Override    protected Float createBadValue() {        return randomBool() ? randomFloat(MIN - SHIFT, MIN) : randomFloat(MAX + 1, MAX + SHIFT);    }    @Override    protected FloatProperty.FloatPBuilder singleBuilder() {        return FloatProperty.named("test").desc("foo")                            .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected FloatMultiProperty.FloatMultiPBuilder multiBuilder() {        return FloatMultiProperty.named("test").desc("foo")                                 .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Float> createProperty() {        return new FloatProperty("testFloat", "Test float property", MIN, MAX, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", MIN, MAX,            new Float[]{6f, 9f, 1f, 2f}, 1.0f);    }    @Override    protected PropertyDescriptor<Float> createBadProperty() {        return new FloatProperty("testFloat", "Test float property", 5f, 4f, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createBadMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", 0f, 5f,            new Float[]{-1f, 0f, 1f, 2f}, 1.0f);    }    @Override    protected Float min() {        return MIN;    }    @Override    protected Float max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the DoubleProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of double values onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedclass DoublePropertyTest extends AbstractNumericPropertyDescriptorTester<Double> {    private static final double MIN = -10.0;    private static final double MAX = 100.0;    private static final double SHIFT = 5.0;    DoublePropertyTest() {        super("Double");    }    @Override    protected Double createValue() {        return randomDouble(MIN, MAX);    }    @Override    protected Double createBadValue() {        return randomBool() ? randomDouble(MIN - SHIFT, MIN - 0.01) : randomDouble(MAX + 0.01, MAX + SHIFT);    }    protected DoubleProperty.DoublePBuilder singleBuilder() {        return DoubleProperty.named("test").desc("foo")                             .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected DoubleMultiProperty.DoubleMultiPBuilder multiBuilder() {        return DoubleMultiProperty.named("test").desc("foo")                                  .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Double> createProperty() {        return new DoubleProperty("testDouble", "Test double property", MIN, MAX, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {-1d, 0d, 1d, 2d}, 1.0f);    }    @Override    protected PropertyDescriptor<Double> createBadProperty() {        return new DoubleProperty("testDouble", "Test double property", MAX, MIN, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createBadMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {MIN - SHIFT, MIN, MIN + SHIFT, MAX + SHIFT}, 1.0f);    }    @Override    protected Double min() {        return MIN;    }    @Override    protected Double max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * @author Clément Fournier */@Deprecatedclass LongPropertyTest extends AbstractNumericPropertyDescriptorTester<Long> {    private static final long MIN = 10L;    private static final long MAX = 11000L;    private static final long SHIFT = 300L;    LongPropertyTest() {        super("Long");    }    @Override    protected Long createValue() {        return randomLong(MIN, MAX);    }    @Override    protected Long createBadValue() {        return randomBool() ? randomLong(MIN - SHIFT, MIN) : randomLong(MAX + 1, MAX + SHIFT);    }    @Override    protected LongProperty.LongPBuilder singleBuilder() {        return LongProperty.named("test").desc("foo")                           .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected LongMultiProperty.LongMultiPBuilder multiBuilder() {        return LongMultiProperty.named("test").desc("foo")                                .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Long> createProperty() {        return new LongProperty("testFloat", "Test float property", MIN, MAX, 90L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", MIN, MAX,            new Long[]{1000L, 10L, 100L, 20L}, 1.0f);    }    @Override    protected PropertyDescriptor<Long> createBadProperty() {        return new LongProperty("testFloat", "Test float property", 200L, -400L, 900L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createBadMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", 0L, 5L,            new Long[]{-1000L, 0L, 100L, 20L}, 1.0f);    }    @Override    protected Long min() {        return MIN;    }    @Override    protected Long max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.properties.SimpleEnumeratedPropertyTest.Foo;/** * Evaluates the functionality of the EnumeratedProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid selections, * and serialize/deserialize selection options. * * @author Brian Remedios */@Deprecatedclass SimpleEnumeratedPropertyTest extends AbstractPropertyDescriptorTester<Foo> {    private static final String[] KEYS = {"bar", "na", "bee", "coo"};    private static final Foo[] VALUES = {Foo.BAR, Foo.NA, Foo.BEE, Foo.COO};    private static final Map<String, Foo> MAPPINGS;    static {        Map<String, Foo> map = new HashMap<>();        map.put("bar", Foo.BAR);        map.put("na", Foo.NA);        map.put("bee", Foo.BEE);        map.put("coo", Foo.COO);        MAPPINGS = Collections.unmodifiableMap(map);    }    SimpleEnumeratedPropertyTest() {        super("Enum");    }    @Test    void testMappings() {        EnumeratedPropertyDescriptor<Foo, Foo> prop            = (EnumeratedPropertyDescriptor<Foo, Foo>) createProperty();        EnumeratedPropertyDescriptor<Foo, List<Foo>> multi            = (EnumeratedPropertyDescriptor<Foo, List<Foo>>) createMultiProperty();        assertEquals(MAPPINGS, prop.mappings());        assertEquals(MAPPINGS, multi.mappings());    }    @Override    protected PropertyDescriptor<Foo> createProperty() {        return new EnumeratedProperty<>("testEnumerations",                                        "Test enumerations with complex types",                                        KEYS,                                        VALUES, 0, Foo.class,                                        1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations",                                             "Test enumerations with complex types",                                             KEYS,                                             VALUES,                                             new int[] {0, 1}, Foo.class, 1.0f);    }    @Test    void testDefaultIndexOutOfBounds() {        assertThrows(IllegalArgumentException.class, () ->            new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                                    KEYS, VALUES, new int[] {99}, Foo.class, 1.0f));    }    @Test    void testNoMappingForDefault() {        assertThrows(IllegalArgumentException.class, () ->            new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                          MAPPINGS, Collections.singletonList(Foo.IGNORED), Foo.class, 1.0f));    }    @Test    void creationTest() {        PropertyDescriptor<Foo> prop = createProperty();        PropertyDescriptor<List<Foo>> multi = createMultiProperty();        for (Map.Entry<String, Foo> e : MAPPINGS.entrySet()) {            assertEquals(e.getValue(), prop.valueFrom(e.getKey()));            assertTrue(multi.valueFrom(e.getKey()).contains(e.getValue()));        }    }    @Override    protected Foo createValue() {        return randomChoice(VALUES);    }    @Override    protected Foo createBadValue() {        return Foo.IGNORED; // not in the set of values    }    @Override    protected PropertyDescriptor<Foo> createBadProperty() {        return new EnumeratedProperty<>("testEnumerations", "Test enumerations with simple type",                                        new String[0], VALUES, -1, Foo.class, 1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createBadMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                             KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Override    @Test    @Disabled("The EnumeratedProperty factory is not implemented yet")    void testFactorySingleValue() {    }    @Override    @Test    @Disabled("The EnumeratedProperty factory is not implemented yet")    void testFactoryMultiValueCustomDelimiter() {    }    @Override    @Test    @Disabled("The EnumeratedProperty factory is not implemented yet")    void testFactoryMultiValueDefaultDelimiter() {    }    enum Foo {        BAR, NA, BEE, COO, IGNORED    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd.token.internal;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Arrays;import java.util.Collections;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.TokenManager;import net.sourceforge.pmd.lang.ast.GenericToken;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.document.TextRegion;class BaseTokenFilterTest {    static class StringToken implements GenericToken<StringToken> {        private final String text;        StringToken(final String text) {            this.text = text;        }        @Override        public StringToken getNext() {            return null;        }        @Override        public StringToken getPreviousComment() {            return null;        }        @Override        public TextRegion getRegion() {            return TextRegion.fromBothOffsets(0, text.length());        }        @Override        public boolean isEof() {            return text == null;        }        @Override        public String getImageCs() {            return text;        }        @Override        public FileLocation getReportLocation() {            return FileLocation.range(TextFile.UNKNOWN_FILENAME, TextRange2d.range2d(1, 1, 1, 1));        }        @Override        public int compareTo(StringToken o) {            return text.compareTo(o.text);        }        @Override        public int getKind() {            return 0;        }    }    static class StringTokenManager implements TokenManager<StringToken> {        Iterator<String> iterator = Collections.unmodifiableList(Arrays.asList("a", "b", "c")).iterator();        @Override        public StringToken getNextToken() {            if (iterator.hasNext()) {                return new StringToken(iterator.next());            } else {                return null;            }        }    }    static class DummyTokenFilter<T extends GenericToken<T>> extends BaseTokenFilter<T> {        Iterable<T> remainingTokens;        DummyTokenFilter(final TokenManager<T> tokenManager) {            super(tokenManager);        }        @Override        protected boolean shouldStopProcessing(final T currentToken) {            return currentToken == null;        }        @Override        protected void analyzeTokens(final T currentToken, final Iterable<T> remainingTokens) {            this.remainingTokens = remainingTokens;        }        public Iterable<T> getRemainingTokens() {            return remainingTokens;        }    }    @Test    void testRemainingTokensFunctionality1() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final Iterator<StringToken> it2 = iterable.iterator();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValFirstIt = it1.next();        final StringToken firstValSecondIt = it2.next();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken secondValFirstIt = it1.next();        assertFalse(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken secondValSecondIt = it2.next();        assertFalse(it2.hasNext());        assertEquals("b", firstValFirstIt.getImage());        assertEquals("b", firstValSecondIt.getImage());        assertEquals("c", secondValFirstIt.getImage());        assertEquals("c", secondValSecondIt.getImage());    }    @Test    void testRemainingTokensFunctionality2() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final Iterator<StringToken> it2 = iterable.iterator();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValFirstIt = it1.next();        assertTrue(it1.hasNext());        final StringToken secondValFirstIt = it1.next();        assertFalse(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValSecondIt = it2.next();        assertTrue(it2.hasNext());        final StringToken secondValSecondIt = it2.next();        assertFalse(it2.hasNext());        assertEquals("b", firstValFirstIt.getImage());        assertEquals("b", firstValSecondIt.getImage());        assertEquals("c", secondValFirstIt.getImage());        assertEquals("c", secondValSecondIt.getImage());    }    @Test    void testRemainingTokensFunctionality3() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final Iterator<StringToken> it2 = iterable.iterator();        it1.next();        it1.next();        it2.next();        it2.next();        assertThrows(NoSuchElementException.class, () -> it1.next());    }    @Test    void testRemainingTokensFunctionality4() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final StringToken secondToken = tokenFilter.getNextToken();        assertEquals("b", secondToken.getImage());        assertThrows(ConcurrentModificationException.class, () -> it1.next());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class LanguageFactoryTest {    @Test    void testSimple() {        assertTrue(LanguageFactory.createLanguage("Cpddummy") instanceof CpddummyLanguage);        assertTrue(LanguageFactory.createLanguage("not_existing_language") instanceof AnyLanguage);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Iterator;import org.junit.jupiter.api.Test;class MatchTest {    @Test    void testSimple() {        int lineCount1 = 10;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount1, codeFragment1);        int lineCount2 = 20;        String codeFragment2 = "code fragment 2";        Mark mark2 = createMark("class", "/var/Foo.java", 1, lineCount2, codeFragment2);        Match match = new Match(1, mark1, mark2);        assertEquals(1, match.getTokenCount());        // Returns the line count of the first mark        assertEquals(lineCount1, match.getLineCount());        // Returns the source code of the first mark        assertEquals(codeFragment1, match.getSourceCodeSlice());        Iterator<Mark> i = match.iterator();        Mark occurrence1 = i.next();        Mark occurrence2 = i.next();        assertFalse(i.hasNext());        assertEquals(mark1, occurrence1);        assertEquals(lineCount1, occurrence1.getLineCount());        assertEquals(codeFragment1, occurrence1.getSourceCodeSlice());        assertEquals(mark2, occurrence2);        assertEquals(lineCount2, occurrence2.getLineCount());        assertEquals(codeFragment2, occurrence2.getSourceCodeSlice());    }    @Test    void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1),                new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.StringWriter;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import javax.xml.transform.ErrorListener;import javax.xml.transform.Templates;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerException;import javax.xml.transform.TransformerFactory;import javax.xml.transform.stream.StreamResult;import javax.xml.transform.stream.StreamSource;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.util.IOUtil;class CpdXsltTest {    /* Sample ant build.xml file. Run with "ant cpdxsl".<project>  <target name="cpdxslt">    <xslt in="src/test/resources/net/sourceforge/pmd/cpd/SampleCpdReport.xml" style="etc/xslt/cpdhtml.xslt" out="cpd.html" />  </target></project>     */    @Test    void cpdhtml() throws Exception {        XSLTErrorListener errorListener = new XSLTErrorListener();        // note: using the default JDK factory, otherwise we would use Saxon from PMD's classpath        // which supports more xslt features.        TransformerFactory factory = TransformerFactory                .newInstance("com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl", null);        factory.setErrorListener(errorListener);        StreamSource xslt = new StreamSource(new File("etc/xslt/cpdhtml.xslt"));        Templates template = factory.newTemplates(xslt);        StreamSource cpdReport = new StreamSource(CpdXsltTest.class.getResourceAsStream("SampleCpdReport.xml"));        StreamResult result = new StreamResult(new StringWriter());        Transformer transformer = template.newTransformer();        transformer.setErrorListener(errorListener);        transformer.transform(cpdReport, result);        String expected = IOUtil.readToString(CpdXsltTest.class.getResourceAsStream("ExpectedCpdHtmlReport.html"), StandardCharsets.UTF_8);        assertEquals(expected, result.getWriter().toString());        assertTrue(errorListener.hasNoErrors(), "XSLT errors occured: " + errorListener);    }    private static class XSLTErrorListener implements ErrorListener {        final List<TransformerException> errors = new ArrayList<>();        @Override        public void warning(TransformerException exception) throws TransformerException {            errors.add(exception);        }        @Override        public void fatalError(TransformerException exception) throws TransformerException {            errors.add(exception);        }        @Override        public void error(TransformerException exception) throws TransformerException {            errors.add(exception);        }        public boolean hasNoErrors() {            return errors.isEmpty();        }        @Override        public String toString() {            return errors.toString();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.File;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.SourceCode.FileCodeLoader;class SourceCodeTest {    private static final String BASE_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String SAMPLE_CODE = "Line 1\n" + "Line 2\n" + "Line 3\n" + "Line 4\n";    @Test    void testSlice() {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(SAMPLE_CODE, "Foo.java"));        assertEquals("Foo.java", sourceCode.getFileName());        assertEquals("Line 1", sourceCode.getSlice(1, 1));        assertEquals("Line 2", sourceCode.getSlice(2, 2));        assertEquals("Line 1\nLine 2", sourceCode.getSlice(1, 2));        sourceCode.getCodeBuffer(); // load into soft reference, must not change behavior        assertEquals("Line 1\nLine 2", sourceCode.getSlice(1, 2));    }    @Test    void testEncodingDetectionFromBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(new File(BASE_RESOURCE_PATH + "file_with_utf8_bom.java"),                "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("UTF-8", loader.getEncoding());    }    @Test    void testEncodingIsNotChangedWhenThereIsNoBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(                new File(BASE_RESOURCE_PATH + "file_with_ISO-8859-1_encoding.java"), "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("ISO-8859-1", loader.getEncoding());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.hamcrest.Matchers.not;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.Map;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;import com.github.stefanbirkner.systemlambda.SystemLambda;import com.google.common.collect.ImmutableMap;class CPDCommandLineInterfaceTest {    private static final String SRC_DIR = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final Map<String, Integer> NUMBER_OF_TOKENS = ImmutableMap.of(            new File(SRC_DIR, "dup1.java").getAbsolutePath(), 126,            new File(SRC_DIR, "dup2.java").getAbsolutePath(), 126,            new File(SRC_DIR, "file_with_ISO-8859-1_encoding.java").getAbsolutePath(), 32,            new File(SRC_DIR, "file_with_utf8_bom.java").getAbsolutePath(), 29    );    @TempDir    private Path tempDir;    @AfterEach    void resetLogging() {        // reset logging in case "--debug" changed the logging properties        // See also Slf4jSimpleConfigurationForAnt        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    @BeforeEach    void setup() {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");    }        @Test    void testEmptyResultRendering() throws Exception {        final String expectedFilesXml = getExpectedFileEntriesXml(NUMBER_OF_TOKENS.keySet());        String stdout = SystemLambda.tapSystemOut(() -> {            SystemLambda.tapSystemErr(() -> {                CPD.StatusCode statusCode = CPD.runCpd("--minimum-tokens", "340", "--language", "java", "--files",                        SRC_DIR, "--format", "xml");                assertEquals(CPD.StatusCode.OK, statusCode);            });        });        assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "\n" + "<pmd-cpd>\n" + expectedFilesXml + "</pmd-cpd>", stdout.trim());    }    private String getExpectedFileEntryXml(final String filename) {        final int numberOfTokens = NUMBER_OF_TOKENS.get(filename);        return String.format("   <file path=\"%s\"\n         totalNumberOfTokens=\"%d\"/>\n",                new File(filename).getAbsolutePath(),                numberOfTokens);    }    private String getExpectedFileEntriesXml(final Collection<String> filenames) {        final StringBuilder expectedFilesXmlBuilder = new StringBuilder();        for (final String filename : filenames) {            expectedFilesXmlBuilder.append(getExpectedFileEntryXml(filename));        }        return expectedFilesXmlBuilder.toString();    }    @Test    void testDeprecatedOptionsWarning() throws Exception {        final List<String> filepaths = Arrays.asList(                new File(SRC_DIR, "dup1.java").getAbsolutePath(),                new File(SRC_DIR, "dup2.java").getAbsolutePath());        Path filelist = tempDir.resolve("cpd-test-file-list.txt");        Files.write(filelist, filepaths, StandardCharsets.UTF_8);        final String expectedFilesXml = getExpectedFileEntriesXml(filepaths);        String stderr = SystemLambda.tapSystemErr(() -> {            String stdout = SystemLambda.tapSystemOut(() -> {                CPD.StatusCode statusCode = CPD.runCpd("--minimum-tokens", "340", "--language", "java", "--filelist",                        filelist.toAbsolutePath().toString(), "--format", "xml", "-failOnViolation", "true");                assertEquals(CPD.StatusCode.OK, statusCode);            });            assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "\n" + "<pmd-cpd>\n" + expectedFilesXml + "</pmd-cpd>", stdout.trim());        });        assertTrue(stderr.contains("Some deprecated options were used on the command-line, including -failOnViolation"));        assertTrue(stderr.contains("Consider replacing it with --fail-on-violation"));        // only one parameter is logged        assertFalse(stderr.contains("Some deprecated options were used on the command-line, including --filelist"));        assertFalse(stderr.contains("Consider replacing it with --file-list"));    }    @Test    void testDebugLogging() throws Exception {        // restoring system properties: --debug might change logging properties        SystemLambda.restoreSystemProperties(() -> {            String stderr = SystemLambda.tapSystemErr(() -> {                CPD.StatusCode statusCode = CPD.runCpd("--minimum-tokens", "340", "--language", "java", "--files",                        SRC_DIR, "--debug");                assertEquals(CPD.StatusCode.OK, statusCode);            });            assertThat(stderr, containsString("Tokenizing ")); // this is a debug logging        });    }    @Test    void testNormalLogging() throws Exception {        String stderr = SystemLambda.tapSystemErr(() -> {            CPD.StatusCode statusCode = CPD.runCpd("--minimum-tokens", "340", "--language", "java", "--files",                    SRC_DIR);            assertEquals(CPD.StatusCode.OK, statusCode);        });        assertThat(stderr, not(containsString("Tokenizing "))); // this is a debug logging    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertSame;import java.util.HashMap;import java.util.Map;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;class CPDConfigurationTest {    @Test    void testRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            Renderer r = CPDConfiguration.getRendererFromString(entry.getKey(), "UTF-8");            assertNotNull(r);            assertSame(entry.getValue(), r.getClass());        }    }    @Test    void testCPDRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            CPDRenderer r = CPDConfiguration.getCPDRendererFromString(entry.getKey(), "UTF-8");            assertNotNull(r);            assertSame(entry.getValue(), r.getClass());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.util.IOUtil;/** * @author Philippe T'Seyen */class FileReporterTest {    @Test    void testCreation() {        new FileReporter((String) null);        new FileReporter((File) null);    }    @Test    void testEmptyReport() throws ReportException {        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");        assertTrue(reportFile.exists());        assertEquals(0L, reportFile.length());        assertTrue(reportFile.delete());    }    @Test    void testReport() throws ReportException, IOException {        String testString = "first line\nsecond line";        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report(testString);        assertEquals(testString, readFile(reportFile));        assertTrue(reportFile.delete());    }    @Test    void testInvalidFile() throws ReportException {        File reportFile = new File("/invalid_folder/report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        assertThrows(ReportException.class, () -> fileReporter.report(""));    }    private String readFile(File file) throws IOException {        try (Reader reader = new FileReader(file)) {            String text = IOUtil.readToString(reader);            return text.replaceAll("\\R", "\n");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Test;class AnyTokenizerTest {    @Test    void testMultiLineMacros() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        compareResult(tokenizer, TEST1, EXPECTED);    }    @Test    void testStringEscape() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        compareResult(tokenizer, "a = \"oo\\n\"", listOf("a", "=", "\"oo\\n\"", "EOF"));    }    @Test    void testMultilineString() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        Tokens tokens = compareResult(tokenizer, "a = \"oo\n\";", listOf("a", "=", "\"oo\n\"", ";", "EOF"));        TokenEntry string = tokens.getTokens().get(2);        assertEquals("\"oo\n\"", getTokenImage(string));        assertEquals(1, string.getBeginLine());        assertEquals(5, string.getBeginColumn());        assertEquals(2, string.getEndColumn()); // ends on line 2        TokenEntry semi = tokens.getTokens().get(3);        assertEquals(";", getTokenImage(semi));        assertEquals(2, semi.getBeginLine());        assertEquals(2, semi.getBeginColumn());        assertEquals(3, semi.getEndColumn());    }    /**     * Tests that [core][cpd] AnyTokenizer doesn't count columns correctly #2760 is actually fixed.     */    @Test    void testTokenPosition() {        AnyTokenizer tokenizer = new AnyTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader("a;\nbbbb\n;"));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        TokenEntry bbbbToken = tokens.getTokens().get(2);        assertEquals(2, bbbbToken.getBeginLine());        assertEquals(1, bbbbToken.getBeginColumn());        assertEquals(5, bbbbToken.getEndColumn());    }    private Tokens compareResult(AnyTokenizer tokenizer, String source, List<String> expectedImages) {        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(source));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        List<String> tokenStrings = new ArrayList<>();        for (TokenEntry token : tokens.getTokens()) {            tokenStrings.add(getTokenImage(token));        }        assertEquals(expectedImages, tokenStrings);        return tokens;    }    private String getTokenImage(TokenEntry t) {        return t.toString();    }    private static final List<String> EXPECTED = listOf(        "using", "System", ";",        "namespace", "HelloNameSpace", "{",        "public", "class", "HelloWorld", "{", // note: comment is excluded        "static", "void", "Main", "(", "string", "[", "]", "args", ")", "{",        "Console", ".", "WriteLine", "(", "\"Hello World!\"", ")", ";",        "}", "}", "}", "EOF"    );    private static final String TEST1 =        "using System;\n"            + "namespace HelloNameSpace {\n"            + "\n"            + "    public class HelloWorld { // A comment\n"            + "        static void Main(string[] args) {\n"            + "\n"            + "            Console.WriteLine(\"Hello World!\");\n"            + "        }\n"            + "    }\n"            + "\n"            + "}\n";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;class CSVRendererTest {    @Test    void testLineCountPerFile() throws IOException {        CPDRenderer renderer = new CSVRenderer(true);        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "tokens,occurrences" + PMD.EOL + "75,2,48,10,/var/Foo.java,73,20,/var/Bar.java"                + PMD.EOL;        assertEquals(expectedReport, report);    }    @Test    void testFilenameEscapes() throws IOException {        CPDRenderer renderer = new CSVRenderer();        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var,with,commas/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var,with,commas/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "lines,tokens,occurrences" + PMD.EOL                + "10,75,2,48,\"/var,with,commas/Foo.java\",73,\"/var,with,commas/Bar.java\"" + PMD.EOL;        assertEquals(expectedReport, report);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader;class MarkTest {    @Test    void testSimple() {        String filename = "/var/Foo.java";        int beginLine = 1;        TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1);        Mark mark = new Mark(token);        int lineCount = 10;        mark.setLineCount(lineCount);        String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(-1, mark.getBeginColumn());        assertEquals(-1, mark.getEndColumn());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }    @Test    void testColumns() {        final String filename = "/var/Foo.java";        final int beginLine = 1;        final int beginColumn = 2;        final int endColumn = 3;        final TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1, beginColumn, beginColumn + "public".length());        final TokenEntry endToken = new TokenEntry("}", "/var/Foo.java", 5, endColumn - 1, endColumn);        final Mark mark = new Mark(token);        final int lineCount = 10;        mark.setLineCount(lineCount);        mark.setEndToken(endToken);        final String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(beginColumn, mark.getBeginColumn());        assertEquals(endColumn, mark.getEndColumn());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.nio.file.Paths;import java.util.HashSet;import java.util.List;import java.util.Set;import org.junit.jupiter.api.Test;class CPDFilelistTest {    @Test    void testFilelist() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);        List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(Paths.get(path).getFileName().toString());        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }    @Test    void testFilelistMultipleLines() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist2.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);        List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(Paths.get(path).getFileName().toString());        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;class TokenEntryTest {    @Test    void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());        assertEquals(-1, mark.getBeginColumn());        assertEquals(-1, mark.getEndColumn());    }    @Test    void testColumns() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1, 2, 3);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());        assertEquals(2, mark.getBeginColumn());        assertEquals(3, mark.getEndColumn());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import org.junit.jupiter.api.Test;import org.w3c.dom.Document;import org.w3c.dom.NamedNodeMap;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;import net.sourceforge.pmd.cpd.renderer.CPDReportRenderer;/** * @author Philippe T'Seyen * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */class XMLRendererTest {    private static final String ENCODING = (String) System.getProperties().get("file.encoding");    private static final String FORM_FEED = "\u000C"; // this character is invalid in XML 1.0 documents    private static final String FORM_FEED_ENTITY = "&#12;"; // this is also not allowed in XML 1.0 documents    @Test    void testWithNoDuplication() throws IOException, ParserConfigurationException, SAXException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));        NodeList nodes = doc.getChildNodes();        Node n = nodes.item(0);        assertEquals("pmd-cpd", n.getNodeName());        assertEquals(0, doc.getElementsByTagName("duplication").getLength());    }    @Test    void testWithOneDuplication() throws Exception {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));        NodeList dupes = doc.getElementsByTagName("duplication");        assertEquals(1, dupes.getLength());        Node file = dupes.item(0).getFirstChild();        while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {            file = file.getNextSibling();        }        if (file != null) {            assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());            assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());            assertEquals("6", file.getAttributes().getNamedItem("endline").getNodeValue());            assertEquals(null, file.getAttributes().getNamedItem("column"));            assertEquals(null, file.getAttributes().getNamedItem("endcolumn"));            file = file.getNextSibling();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }        }        if (file != null) {            assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());            assertEquals("78", file.getAttributes().getNamedItem("endline").getNodeValue());            assertEquals(null, file.getAttributes().getNamedItem("column"));            assertEquals(null, file.getAttributes().getNamedItem("endcolumn"));        }        assertEquals(1, doc.getElementsByTagName("codefragment").getLength());        assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());    }    @Test    void testRenderWithMultipleMatch() throws Exception {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount1 = 6;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, lineCount1, codeFragment1);        Mark mark2 = createMark("void", "/var/Foo.java", 73, lineCount1, codeFragment1);        Match match1 = new Match(75, mark1, mark2);        int lineCount2 = 7;        String codeFragment2 = "code fragment 2";        Mark mark3 = createMark("void", "/var/Foo2.java", 49, lineCount2, codeFragment2);        Mark mark4 = createMark("stuff", "/var/Foo2.java", 74, lineCount2, codeFragment2);        Match match2 = new Match(76, mark3, mark4);        list.add(match1);        list.add(match2);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));        assertEquals(2, doc.getElementsByTagName("duplication").getLength());        assertEquals(4, doc.getElementsByTagName("file").getLength());    }    @Test    void testWithOneDuplicationWithColumns() throws Exception {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment, 2, 3);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment, 4, 5);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));        NodeList dupes = doc.getElementsByTagName("duplication");        assertEquals(1, dupes.getLength());        Node file = dupes.item(0).getFirstChild();        while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {            file = file.getNextSibling();        }        if (file != null) {            assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());            assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());            assertEquals("6", file.getAttributes().getNamedItem("endline").getNodeValue());            assertEquals("2", file.getAttributes().getNamedItem("column").getNodeValue());            assertEquals("3", file.getAttributes().getNamedItem("endcolumn").getNodeValue());            file = file.getNextSibling();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }        }        if (file != null) {            assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());            assertEquals("78", file.getAttributes().getNamedItem("endline").getNodeValue());            assertEquals("4", file.getAttributes().getNamedItem("column").getNodeValue());            assertEquals("5", file.getAttributes().getNamedItem("endcolumn").getNodeValue());        }        assertEquals(1, doc.getElementsByTagName("codefragment").getLength());        assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());    }    @Test    void testRendererEncodedPath() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        final String espaceChar = "&lt;";        Mark mark1 = createMark("public", "/var/A<oo.java" + FORM_FEED, 48, 6, "code fragment");        Mark mark2 = createMark("void", "/var/B<oo.java", 73, 6, "code fragment");        Match match1 = new Match(75, mark1, mark2);        list.add(match1);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertTrue(report.contains(espaceChar));        assertFalse(report.contains(FORM_FEED));        assertFalse(report.contains(FORM_FEED_ENTITY));    }    @Test    void testFilesWithNumberOfTokens() throws IOException, ParserConfigurationException, SAXException {        final CPDReportRenderer renderer = new XMLRenderer();        final List<Match> matches = new ArrayList<>();        final String filename = "/var/Foo.java";        final int lineCount = 6;        final String codeFragment = "code\nfragment";        final Mark mark1 = createMark("public", filename, 1, lineCount, codeFragment, 2, 3);        final Mark mark2 = createMark("stuff", filename, 73, lineCount, codeFragment, 4, 5);        final Match match = new Match(75, mark1, mark2);        matches.add(match);        final Map<String, Integer> numberOfTokensPerFile = new HashMap<>();        numberOfTokensPerFile.put(filename, 888);        final CPDReport report = new CPDReport(matches, numberOfTokensPerFile);        final StringWriter writer = new StringWriter();        renderer.render(report, writer);        final String xmlOutput = writer.toString();        final Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new ByteArrayInputStream(xmlOutput.getBytes(ENCODING)));        final NodeList files = doc.getElementsByTagName("file");        final Node file = files.item(0);        final NamedNodeMap attributes = file.getAttributes();        assertEquals("/var/Foo.java", attributes.getNamedItem("path").getNodeValue());        assertEquals("888", attributes.getNamedItem("totalNumberOfTokens").getNodeValue());    }    @Test    public void testGetDuplicationStartEnd() throws IOException, ParserConfigurationException, SAXException {        TokenEntry.clearImages();        final CPDReportRenderer renderer = new XMLRenderer();        final List<Match> matches = new ArrayList<>();        final String filename = "/var/Foo.java";        final int lineCount = 6;        final String codeFragment = "code\nfragment";        final Mark mark1 = createMark("public", filename, 1, lineCount, codeFragment, 2, 3);        final Mark mark2 = createMark("stuff", filename, 73, lineCount, codeFragment, 4, 5);        final Match match = new Match(75, mark1, mark2);        matches.add(match);        final Map<String, Integer> numberOfTokensPerFile = new HashMap<>();        numberOfTokensPerFile.put(filename, 888);        final CPDReport report = new CPDReport(matches, numberOfTokensPerFile);        final StringWriter writer = new StringWriter();        renderer.render(report, writer);        final String xmlOutput = writer.toString();        final Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new ByteArrayInputStream(xmlOutput.getBytes(ENCODING)));        final NodeList files = doc.getElementsByTagName("file");        final Node dup_1 = files.item(1);        final NamedNodeMap attrs_1 = dup_1.getAttributes();        assertEquals("0", attrs_1.getNamedItem("begintoken").getNodeValue());        assertEquals("1", attrs_1.getNamedItem("endtoken").getNodeValue());        final Node dup_2 = files.item(2);        final NamedNodeMap attrs_2 = dup_2.getAttributes();        assertEquals("2", attrs_2.getNamedItem("begintoken").getNodeValue());        assertEquals("3", attrs_2.getNamedItem("endtoken").getNodeValue());    }    @Test    void testRendererXMLEscaping() throws IOException {        String codefragment = "code fragment" + FORM_FEED + "\nline2\nline3\nno & escaping necessary in CDATA\nx=\"]]>\";";        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        Mark mark1 = createMark("public", "file1", 1, 5, codefragment);        Mark mark2 = createMark("public", "file2", 5, 5, codefragment);        Match match1 = new Match(75, mark1, mark2);        list.add(match1);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertFalse(report.contains(FORM_FEED));        assertFalse(report.contains(FORM_FEED_ENTITY));        assertTrue(report.contains("no & escaping necessary in CDATA"));        assertFalse(report.contains("x=\"]]>\";")); // must be escaped        assertTrue(report.contains("x=\"]]]]><![CDATA[>\";"));    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code, int beginColumn, int endColumn) {        final TokenEntry beginToken = new TokenEntry(image, tokenSrcID, beginLine, beginColumn, beginColumn + 1);        final TokenEntry endToken = new TokenEntry(image, tokenSrcID, beginLine + lineCount, endColumn - 1, endColumn);        final Mark result = new Mark(beginToken);        result.setLineCount(lineCount);        result.setEndToken(endToken);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.fail;import static org.junit.jupiter.api.Assumptions.assumeTrue;import java.io.File;import java.util.Iterator;import org.apache.commons.lang3.SystemUtils;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;/** * Unit test for {@link CPD} */class CPDTest {    private static final String BASE_TEST_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String TARGET_TEST_RESOURCE_PATH = "target/classes/net/sourceforge/pmd/cpd/files/";    private CPD cpd;    // Symlinks are not well supported under Windows - so the tests are    // simply executed only on linux.    private boolean canTestSymLinks = SystemUtils.IS_OS_UNIX;    @BeforeEach    void setup() throws Exception {        CPDConfiguration theConfiguration = new CPDConfiguration();        theConfiguration.setLanguage(new AnyLanguage("any"));        theConfiguration.setMinimumTileSize(10);        theConfiguration.postContruct();        cpd = new CPD(theConfiguration);    }    /**     * As java doesn't support symlinks in zip files, maven does not, too. So,     * we are creating the symlinks manually here before the test.     *     * @throws Exception     *             any error     */    private void prepareSymLinks() throws Exception {        assumeTrue(canTestSymLinks, "Skipping unit tests with symlinks.");        Runtime runtime = Runtime.getRuntime();        if (!new File(TARGET_TEST_RESOURCE_PATH, "symlink-for-real-file.txt").exists()) {            runtime.exec(new String[] { "ln", "-s", BASE_TEST_RESOURCE_PATH + "real-file.txt",                TARGET_TEST_RESOURCE_PATH + "symlink-for-real-file.txt", }).waitFor();        }        if (!new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test").exists()) {            runtime.exec(new String[] { "ln", "-s", "broken-sym-link",                TARGET_TEST_RESOURCE_PATH + "this-is-a-broken-sym-link-for-test", }).waitFor();        }    }    /**     * A broken symlink (which is basically a not existing file), should be     * skipped.     *     * @throws Exception     *             any error     */    @Test    void testFileSectionWithBrokenSymlinks() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(0);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test"));        listener.verify();    }    /**     * A file should be added only once - even if it was found twice, because of     * a sym link.     *     * @throws Exception     *             any error     */    @Test    void testFileAddedAsSymlinkAndReal() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "real-file.txt"));        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "symlink-for-real-file.txt"));        listener.verify();    }    /**     * Add a file with a relative path - should still be added and not be     * detected as a sym link.     *     * @throws Exception     *             any error     */    @Test    void testFileAddedWithRelativePath() throws Exception {        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "real-file.txt"));        listener.verify();    }    /**     * The order of the duplicates is dependent on the order the files are added to CPD.     * See also https://github.com/pmd/pmd/issues/1196     * @throws Exception     */    @Test    void testFileOrderRelevance() throws Exception {        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup2.java"));        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup1.java"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        while (matches.hasNext()) {            Match match = matches.next();            // the file added first was dup2.            assertTrue(match.getFirstMark().getFilename().endsWith("dup2.java"));            assertTrue(match.getSecondMark().getFilename().endsWith("dup1.java"));        }    }    /**     * Simple listener that fails, if too many files were added and not skipped.     */    private static class NoFileAssertListener implements CPDListener {        private int expectedFilesCount;        private int files;        NoFileAssertListener(int expectedFilesCount) {            this.expectedFilesCount = expectedFilesCount;            this.files = 0;        }        @Override        public void addedFile(int fileCount, File file) {            files++;            if (files > expectedFilesCount) {                fail("File was added! - " + file);            }        }        @Override        public void phaseUpdate(int phase) {            // not needed for this test        }        public void verify() {            assertEquals(expectedFilesCount, files,                    "Expected " + expectedFilesCount + " files, but " + files + " have been added.");        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import java.nio.charset.StandardCharsets;import java.util.function.Consumer;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.reporting.FileAnalysisListener;import com.github.stefanbirkner.systemlambda.SystemLambda;import com.google.gson.Gson;import com.google.gson.JsonArray;import com.google.gson.JsonObject;class SarifRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new SarifRenderer();    }    @Test    void testRendererWithASCII() throws Exception {        SystemLambda.restoreSystemProperties(() -> {            System.setProperty("file.encoding", StandardCharsets.US_ASCII.name());            testRenderer(StandardCharsets.UTF_8);        });    }    @Override    String getExpected() {        return readFile("expected.sarif.json");    }    @Override    String getExpectedEmpty() {        return readFile("empty.sarif.json");    }    @Override    String getExpectedMultiple() {        return readFile("expected-multiple.sarif.json");    }    @Override    String getExpectedError(Report.ProcessingError error) {        String expected = readFile("expected-error.sarif.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    String getExpectedError(Report.ConfigurationError error) {        return readFile("expected-configerror.sarif.json");    }    @Override    String getExpectedErrorWithoutMessage(Report.ProcessingError error) {        String expected = readFile("expected-error-nomessage.sarif.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    String filter(String expected) {        return expected.replaceAll("\r\n", "\n") // make the test run on Windows, too                .replaceAll("\"version\": \".+\",", "\"version\": \"unknown\",");    }    /**     * Multiple occurrences of the same rule should be reported as individual results.     *      * @see <a href="https://github.com/pmd/pmd/issues/3768"> [core] SARIF formatter reports multiple locations     *      when it should report multiple results #3768</a>     */    @Test    void testRendererMultipleLocations() throws Exception {        String actual = renderReport(getRenderer(), reportThreeViolationsTwoRules());        Gson gson = new Gson();        JsonObject json = gson.fromJson(actual, JsonObject.class);        JsonArray results = json.getAsJsonArray("runs").get(0).getAsJsonObject().getAsJsonArray("results");        assertEquals(3, results.size());        assertEquals(filter(readFile("expected-multiple-locations.sarif.json")), filter(actual));    }    private Consumer<FileAnalysisListener> reportThreeViolationsTwoRules() {        Rule fooRule = createFooRule();        Rule booRule = createBooRule();        return reportBuilder -> {            reportBuilder.onRuleViolation(newRuleViolation(1, 1, 1, 10, fooRule));            reportBuilder.onRuleViolation(newRuleViolation(5, 1, 5, 11, fooRule));            reportBuilder.onRuleViolation(newRuleViolation(2, 2, 3, 1, booRule));        };    }    protected String readFile(String relativePath) {        return super.readFile("sarif/" + relativePath);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;class CodeClimateRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new CodeClimateRenderer();    }    @Override    String getExpected() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "Description with Unicode Character U+2013: – .\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    String getExpectedWithProperties() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "Description with Unicode Character U+2013: – .\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "stringProperty | the string value\\nsecond line with 'quotes' | simple string property\\n"                + "multiString | default1,default2 | multi string property\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "";    }    @Override    String getExpectedMultiple() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "Description with Unicode Character U+2013: – .\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL + "{\"type\":\"issue\",\"check_name\":\"Boo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Boo\\n\\nSince: PMD null\\n\\nPriority: High\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"blocker\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Test    void testXPathRule() throws Exception {        FileLocation node = createLocation(1, 1, 1, 1);        XPathRule theRule = new XPathRule(XPathVersion.XPATH_3_1, "//dummyNode");        // Setup as FooRule        theRule.setDescription("Description with Unicode Character U+2013: – .");        theRule.setName("Foo");        String rendered = renderReport(getRenderer(), it -> it.onRuleViolation(new ParametricRuleViolation(theRule, node, "blah")));        // Output should be the exact same as for non xpath rules        assertEquals(filter(getExpected()), filter(rendered));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;class HTMLRendererTest extends AbstractRendererTest {    @Override    protected String getSourceCodeFilename() {        return "someFilename<br>thatNeedsEscaping.ext";    }    private String getEscapedFilename() {        return "someFilename&lt;br&gt;thatNeedsEscaping.ext";    }    @Override    Renderer getRenderer() {        return new HTMLRenderer();    }    @Override    String getExpected() {        return getExpected(null, null);    }    private String getExpected(String linkPrefix, String lineAnchor) {        String filename = getEscapedFilename();        if (linkPrefix != null) {            filename = "<a href=\"" + linkPrefix + filename + "#" + lineAnchor + "\">"                    + filename + "</a>";        }        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + filename + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return getHeader()                + "</table></body></html>" + PMD.EOL;    }    @Override    String getExpectedMultiple() {        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "<tr> " + PMD.EOL                + "<td align=\"center\">2</td>" + PMD.EOL + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return getHeader()                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>file</td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    @Override    String getExpectedError(ConfigurationError error) {        return getHeader()                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    private String getHeader() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL;    }    @Test    void testLinkPrefix() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        final String linePrefix = "L";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        renderer.setProperty(HTMLRenderer.LINE_PREFIX, linePrefix);        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        String actual = renderReport(renderer, reportOneViolation());        assertEquals(filter(getExpected(linkPrefix, "L1")), filter(actual));    }    @Test    void testLinePrefixNotSet() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        // dont set line prefix renderer.setProperty(HTMLRenderer.LINE_PREFIX, linePrefix);        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        String actual = renderReport(renderer, reportOneViolation());        assertEquals(filter(getExpected(linkPrefix, "")), filter(actual));    }    @Test    void testEmptyLinePrefix() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        renderer.setProperty(HTMLRenderer.LINE_PREFIX, "");        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        String actual = renderReport(renderer, reportOneViolation());        assertEquals(filter(getExpected(linkPrefix, "1")), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.Path;import java.util.function.Consumer;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RulePriority;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.RuleWithProperties;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.reporting.FileAnalysisListener;import net.sourceforge.pmd.reporting.GlobalAnalysisListener;import net.sourceforge.pmd.util.IOUtil;abstract class AbstractRendererTest {    @TempDir    private Path tempDir;    abstract Renderer getRenderer();    abstract String getExpected();    String getExpectedWithProperties() {        return getExpected();    }    abstract String getExpectedEmpty();    abstract String getExpectedMultiple();    String getExpectedError(ProcessingError error) {        return "";    }    String getExpectedErrorWithoutMessage(ProcessingError error) {        return getExpectedError(error);    }    String getExpectedError(ConfigurationError error) {        return "";    }    String filter(String expected) {        return expected;    }    String getSourceCodeFilename() {        return "notAvailable.ext";    }    @Test    void testNullPassedIn() throws Exception {        assertThrows(NullPointerException.class, () ->            getRenderer().renderFileReport(null));    }    protected Consumer<FileAnalysisListener> reportOneViolation() {        return it -> it.onRuleViolation(newRuleViolation(1, 1, 1, 1, createFooRule()));    }    private Consumer<FileAnalysisListener> reportTwoViolations() {        return it -> {            RuleViolation informationalRuleViolation = newRuleViolation(1, 1, 1, 1, createFooRule());            it.onRuleViolation(informationalRuleViolation);            RuleViolation severeRuleViolation = newRuleViolation(1, 1, 1, 2, createBooRule());            it.onRuleViolation(severeRuleViolation);        };    }    protected FileLocation createLocation(int beginLine, int beginColumn, int endLine, int endColumn) {        TextRange2d range2d = TextRange2d.range2d(beginLine, beginColumn, endLine, endColumn);        return FileLocation.range(getSourceCodeFilename(), range2d);    }    protected RuleViolation newRuleViolation(int beginLine, int beginColumn, int endLine, int endColumn, Rule rule) {        FileLocation loc = createLocation(beginLine, beginColumn, endLine, endColumn);        return new ParametricRuleViolation(rule, loc, "blah");    }    /**     * Creates a new rule instance with name "Boo" and priority {@link RulePriority#HIGH}.     */    protected Rule createBooRule() {        Rule booRule = new FooRule();        booRule.setName("Boo");        booRule.setDescription("desc");        booRule.setPriority(RulePriority.HIGH);        return booRule;    }    /**     * Creates a new rule instance with name "Foo" and priority {@link RulePriority#LOW}.     */    protected Rule createFooRule() {        Rule fooRule = new FooRule();        fooRule.setName("Foo");        fooRule.setPriority(RulePriority.LOW);        return fooRule;    }    /**     * Read a resource file relative to this class's location.     */    protected String readFile(String relativePath) {        try (InputStream in = getClass().getResourceAsStream(relativePath)) {            return IOUtil.readToString(in, StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Test    void testRuleWithProperties() throws Exception {        RuleWithProperties theRule = new RuleWithProperties();        theRule.setProperty(RuleWithProperties.STRING_PROPERTY_DESCRIPTOR,                "the string value\nsecond line with \"quotes\"");        RuleViolation violation = newRuleViolation(1, 1, 1, 1, theRule);        String rendered = renderReport(getRenderer(), it -> it.onRuleViolation(violation));        assertEquals(filter(getExpectedWithProperties()), filter(rendered));    }    @Test    void testRenderer() throws Exception {        testRenderer(Charset.defaultCharset());    }    protected void testRenderer(Charset expectedCharset) throws Exception {        String actual = renderReport(getRenderer(), reportOneViolation(), expectedCharset);        assertEquals(filter(getExpected()), filter(actual));    }    @Test    void testRendererEmpty() throws Exception {        String actual = render(it -> {});        assertEquals(filter(getExpectedEmpty()), filter(actual));    }    @Test    void testRendererMultiple() throws Exception {        String actual = render(reportTwoViolations());        assertEquals(filter(getExpectedMultiple()), filter(actual));    }    @Test    void testError() throws Exception {        Report.ProcessingError err = new Report.ProcessingError(new RuntimeException("Error"), "file");        String actual = render(it -> it.onError(err));        assertEquals(filter(getExpectedError(err)), filter(actual));    }    @Test    void testErrorWithoutMessage() throws Exception {        Report.ProcessingError err = new Report.ProcessingError(new NullPointerException(), "file");        String actual = render(it -> it.onError(err));        assertEquals(filter(getExpectedErrorWithoutMessage(err)), filter(actual));    }    private String render(Consumer<FileAnalysisListener> listenerEffects) throws IOException {        return renderReport(getRenderer(), listenerEffects);    }    @Test    void testConfigError() throws Exception {        Report.ConfigurationError err = new Report.ConfigurationError(new FooRule(), "a configuration error");        String actual = renderGlobal(getRenderer(), it -> it.onConfigError(err));        assertEquals(filter(getExpectedError(err)), filter(actual));    }    protected String renderReport(Renderer renderer, Consumer<? super FileAnalysisListener> listenerEffects) throws IOException {        return renderReport(renderer, listenerEffects, Charset.defaultCharset());    }    protected String renderReport(Renderer renderer, Consumer<? super FileAnalysisListener> listenerEffects,                                  Charset expectedEncoding) throws IOException {        return renderGlobal(renderer, globalListener -> {            LanguageVersion version = DummyLanguageModule.getInstance().getDefaultVersion();            TextFile dummyFile = TextFile.forCharSeq("dummyText", "file", version);            try (FileAnalysisListener fal = globalListener.startFileAnalysis(dummyFile)) {                listenerEffects.accept(fal);            } catch (Exception e) {                throw new AssertionError(e);            }        }, expectedEncoding);    }    private String renderGlobal(Renderer renderer, Consumer<? super GlobalAnalysisListener> listenerEffects) throws IOException {        return renderGlobal(renderer, listenerEffects, Charset.defaultCharset());    }    private String renderGlobal(Renderer renderer, Consumer<? super GlobalAnalysisListener> listenerEffects,                                Charset expectedEncoding) throws IOException {        File file = tempDir.resolve("report.out").toFile();        renderer.setReportFile(file.getAbsolutePath());        try (GlobalAnalysisListener listener = renderer.newListener()) {            listenerEffects.accept(listener);        } catch (Exception e) {            throw new AssertionError(e);        }        return IOUtil.readFileToString(file, expectedEncoding);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;class IDEAJRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        Renderer result = new IDEAJRenderer();        result.setProperty(IDEAJRenderer.SOURCE_PATH, "");        result.setProperty(IDEAJRenderer.CLASS_AND_METHOD_NAME, "Foo <init>");        result.setProperty(IDEAJRenderer.FILE_NAME, "Foo.java");        return result;    }    @Override    String getExpected() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "";    }    @Override    String getExpectedMultiple() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL + "blah" + PMD.EOL                + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;class TextPadRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new TextPadRenderer();    }    @Override    String getExpected() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "";    }    @Override    String getExpectedMultiple() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL + getSourceCodeFilename() + "(1,  Boo):  blah" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.FileNotFoundException;import java.io.Reader;import java.io.StringReader;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;class PapariTextRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        TextColorRenderer result = new TextColorRenderer() {            @Override            protected Reader getReader(String sourceFile) throws FileNotFoundException {                return new StringReader("public class Foo {}");            }        };        result.setProperty(TextColorRenderer.COLOR, "false");        return result;    }    @Override    String getExpected() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL                + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 1" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    String getExpectedMultiple() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + "    src:  "                + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Boo" + PMD.EOL + "    msg:  blah" + PMD.EOL                + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL                + PMD.EOL + "* warnings: 2" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  RuntimeException: Error" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    String getExpectedErrorWithoutMessage(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  NullPointerException: null" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    String getExpectedError(ConfigurationError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* rule: Foo" + PMD.EOL                + "    err:  a configuration error" + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;class XSLTRendererTest {    @Test    void testDefaultStylesheet() throws Exception {        XSLTRenderer renderer = new XSLTRenderer();        FileLocation loc = FileLocation.range("file", TextRange2d.range2d(1, 1, 1, 2));        RuleViolation rv = new ParametricRuleViolation(new FooRule(), loc, "violation message");        String result = ReportTest.render(renderer, it -> it.onRuleViolation(rv));        assertTrue(result.contains("violation message"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;class EmacsRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new EmacsRenderer();    }    @Override    String getExpected() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "";    }    @Override    String getExpectedMultiple() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL + getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.Report.SuppressedViolation;import net.sourceforge.pmd.ViolationSuppressor;class JsonRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new JsonRenderer();    }    @Override    String getExpected() {        return readFile("expected.json");    }    @Override    String getExpectedEmpty() {        return readFile("empty.json");    }    @Override    String getExpectedMultiple() {        return readFile("expected-multiple.json");    }    @Override    String getExpectedError(ProcessingError error) {        String expected = readFile("expected-processingerror.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    String getExpectedError(ConfigurationError error) {        return readFile("expected-configurationerror.json");    }    @Override    String getExpectedErrorWithoutMessage(ProcessingError error) {        String expected = readFile("expected-processingerror-no-message.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    protected String readFile(String relativePath) {        return super.readFile("json/" + relativePath);    }    @Override    String filter(String expected) {        return expected                .replaceAll("\"timestamp\":\\s*\"[^\"]+\"", "\"timestamp\": \"--replaced--\"")                .replaceAll("\"pmdVersion\":\\s*\"[^\"]+\"", "\"pmdVersion\": \"unknown\"")                .replaceAll("\r\n", "\n"); // make the test run on Windows, too    }    @Test    void suppressedViolations() throws IOException {        SuppressedViolation suppressed = new SuppressedViolation(            newRuleViolation(1, 1, 1, 1, new FooRule()),            ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR,            "test"        );        String actual = renderReport(getRenderer(), it -> it.onSuppressedRuleViolation(suppressed));        String expected = readFile("expected-suppressed.json");        assertEquals(filter(expected), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;class VBHTMLRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new VBHTMLRenderer();    }    @Override    String getExpected() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL + "--></style><body><center><br></center></body></html>" + PMD.EOL;    }    @Override    String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL                + "<tr id=RowColor1><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.getFile() + "</font></td><td><font class=body><pre>" + error.getDetail() + "</pre></font></td></tr></table></center></body></html>" + PMD.EOL;    }    @Override    String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Configuration problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.rule().getName() + "</font></td><td><font class=body>" + error.issue() + "</font></td></tr></table></center></body></html>" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;class EmptyRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new EmptyRenderer();    }    @Override    void testNullPassedIn() throws Exception {        // Overriding test from the super class, this renderer doesn't care, so no NPE.        getRenderer().renderFileReport(null);    }    @Override    String getExpected() {        return "";    }    @Override    String getExpectedEmpty() {        return "";    }    @Override    String getExpectedMultiple() {        return "";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;class CSVRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new CSVRenderer();    }    @Override    String getExpected() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return getHeader();    }    @Override    String getExpectedMultiple() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL                + "\"2\",\"\",\"" + getSourceCodeFilename() + "\",\"1\",\"1\",\"blah\",\"RuleSet\",\"Boo\"" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return getHeader();    }    @Override    String getExpectedError(ConfigurationError error) {        return getHeader();    }    private String getHeader() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;class TextRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        return new TextRenderer();    }    @Override    String getExpected() {        return getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "";    }    @Override    String getExpectedMultiple() {        return getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL                + getSourceCodeFilename() + ":1:\tBoo:\tblah" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return "file\t-\tRuntimeException: Error" + PMD.EOL;    }    @Override    String getExpectedErrorWithoutMessage(ProcessingError error) {        return "file\t-\tNullPointerException: null" + PMD.EOL;    }    @Override    String getExpectedError(ConfigurationError error) {        return "Foo\t-\ta configuration error" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.StringReader;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import java.nio.file.Path;import javax.xml.parsers.DocumentBuilderFactory;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import org.w3c.dom.Document;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDVersion;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.util.IOUtil;import com.github.stefanbirkner.systemlambda.SystemLambda;class XMLRendererTest extends AbstractRendererTest {    @TempDir    private Path folder;    @Override    Renderer getRenderer() {        return new XMLRenderer();    }    @Override    String getExpected() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return getHeader() + "</pmd>" + PMD.EOL;    }    @Override    String getExpectedMultiple() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"2\" rule=\"Boo\" ruleset=\"RuleSet\" priority=\"1\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"RuntimeException: Error\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    String getExpectedErrorWithoutMessage(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"NullPointerException: null\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    String getExpectedError(ConfigurationError error) {        return getHeader() + "<configerror rule=\"Foo\" msg=\"a configuration error\"/>"                + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    String filter(String expected) {        return expected.replaceAll(" timestamp=\"[^\"]+\">", " timestamp=\"\">");    }    private RuleViolation createRuleViolation(String description) {        FileLocation loc = FileLocation.range(getSourceCodeFilename(), TextRange2d.range2d(1, 1, 1, 1));        return new ParametricRuleViolation(new FooRule(), loc, description);    }    private void verifyXmlEscaping(Renderer renderer, String shouldContain, Charset charset) throws Exception {        renderer.setProperty(XMLRenderer.ENCODING, charset.name());        String surrogatePair = "\ud801\udc1c";        String msg = "The String 'literal' \"TokénizĀr " + surrogatePair + "\" appears...";        Report report = Report.buildReport(it -> it.onRuleViolation(createRuleViolation(msg)));        String actual = renderTempFile(renderer, report, charset);        assertTrue(actual.contains(shouldContain));        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new InputSource(new StringReader(actual)));        NodeList violations = doc.getElementsByTagName("violation");        assertEquals(1, violations.getLength());        assertEquals(msg, violations.item(0).getTextContent().trim());    }    @Test    void testXMLEscapingWithUTF8() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "\ud801\udc1c", StandardCharsets.UTF_8);    }    @Test    void testXMLEscapingWithUTF16() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "&#x1041c;", StandardCharsets.UTF_16);    }    @Test    void testXMLEscapingWithoutUTF8() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "&#x1041c;", StandardCharsets.ISO_8859_1);    }    String getHeader() {        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + PMD.EOL                + "<pmd xmlns=\"http://pmd.sourceforge.net/report/2.0.0\""                + " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""                + " xsi:schemaLocation=\"http://pmd.sourceforge.net/report/2.0.0 http://pmd.sourceforge.net/report_2_0_0.xsd\""                + " version=\"" + PMDVersion.VERSION + "\" timestamp=\"2014-10-06T19:30:51.262\">" + PMD.EOL;    }    @Test    void testCorrectCharset() throws Exception {        SystemLambda.restoreSystemProperties(() -> {            System.setProperty("file.encoding", StandardCharsets.ISO_8859_1.name());            Renderer renderer = getRenderer();            String formFeed = "\u000C";            // é = U+00E9 : can be represented in ISO-8859-1 as is            // Ā = U+0100 : cannot be represented in ISO-8859-1 -> would be a unmappable character, needs to be escaped            String specialChars = "éĀ";            String originalChars = formFeed + specialChars; // u000C should be removed, é should be encoded correctly as UTF-8            String msg = "The String literal \"" + originalChars + "\" appears...";            Report report = Report.buildReport(it -> it.onRuleViolation(createRuleViolation(msg)));            String actual = renderTempFile(renderer, report, StandardCharsets.UTF_8);            assertTrue(actual.contains(specialChars));            assertFalse(actual.contains(formFeed));            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new InputSource(new StringReader(actual)));            NodeList violations = doc.getElementsByTagName("violation");            assertEquals(1, violations.getLength());            assertEquals(msg.replaceAll(formFeed, ""), violations.item(0).getTextContent().trim());        });    }    private String renderTempFile(Renderer renderer, Report report, Charset expectedCharset) throws IOException {        File reportFile = folder.resolve("report.out").toFile();        renderer.setReportFile(reportFile.getAbsolutePath());        renderer.start();        renderer.renderFileReport(report);        renderer.end();        renderer.flush();        try (FileInputStream input = new FileInputStream(reportFile)) {            return IOUtil.readToString(input, expectedCharset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.nio.file.Path;import java.util.Arrays;import java.util.regex.Pattern;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.util.IOUtil;class YAHTMLRendererTest extends AbstractRendererTest {    private File outputDir;    @TempDir    private Path folder;    @BeforeEach    void setUp() throws IOException {        outputDir = folder.resolve("pmdtest").toFile();        assertTrue(outputDir.mkdir());    }    private RuleViolation newRuleViolation(int beginLine, int beginColumn, int endLine, int endColumn, final String packageNameArg, final String classNameArg) {        FileLocation loc = createLocation(beginLine, beginColumn, endLine, endColumn);        return new ParametricRuleViolation(new FooRule(), loc, "blah") {            {                packageName = packageNameArg;                className = classNameArg;            }        };    }    @Override    protected RuleViolation newRuleViolation(int beginLine, int beginColumn, int endLine, int endColumn, Rule rule) {        return newRuleViolation(beginLine, beginColumn, endLine, endColumn, "net.sf.pmd.test", "YAHTMLSampleClass");    }    @Test    void testReportMultipleViolations() throws Exception {        String actual = renderReport(getRenderer(), it -> {            it.onRuleViolation(newRuleViolation(1, 1, 1, 1, "net.sf.pmd.test", "YAHTMLSampleClass1"));            it.onRuleViolation(newRuleViolation(1, 1, 1, 2, "net.sf.pmd.test", "YAHTMLSampleClass1"));            it.onRuleViolation(newRuleViolation(1, 1, 1, 1, "net.sf.pmd.other", "YAHTMLSampleClass2"));        });        assertEquals(filter(getExpected()), filter(actual));        String[] htmlFiles = outputDir.list();        assertEquals(3, htmlFiles.length);        Arrays.sort(htmlFiles);        assertEquals("YAHTMLSampleClass1.html", htmlFiles[0]);        assertEquals("YAHTMLSampleClass2.html", htmlFiles[1]);        assertEquals("index.html", htmlFiles[2]);        for (String file : htmlFiles) {            try (FileInputStream in = new FileInputStream(new File(outputDir, file));                    InputStream expectedIn = YAHTMLRendererTest.class.getResourceAsStream("yahtml/" + file)) {                String data = IOUtil.readToString(in, StandardCharsets.UTF_8);                String expected = normalizeLineSeparators(IOUtil.readToString(expectedIn, StandardCharsets.UTF_8));                assertEquals(expected, data, "File " + file + " is different");            }        }    }    private static String normalizeLineSeparators(String s) {        return s.replaceAll(Pattern.quote("\r\n"), "\n")                .replaceAll(Pattern.quote("\n"), PMD.EOL);    }    @Override    Renderer getRenderer() {        Renderer result = new YAHTMLRenderer();        result.setProperty(YAHTMLRenderer.OUTPUT_DIR, outputDir.getAbsolutePath());        return result;    }    @Override    String getExpected() {        return "<h3 align=\"center\">The HTML files are located in '" + outputDir + "'.</h3>" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return getExpected();    }    @Override    String getExpectedMultiple() {        return getExpected();    }    @Override    String getExpectedError(ProcessingError error) {        return getExpected();    }    @Override    String getExpectedError(ConfigurationError error) {        return getExpected();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.Collections;import java.util.function.Consumer;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.document.TextDocument;import net.sourceforge.pmd.reporting.FileAnalysisListener;class SummaryHTMLRendererTest extends AbstractRendererTest {    @Override    Renderer getRenderer() {        Renderer result = new SummaryHTMLRenderer();        result.setProperty(HTMLRenderer.LINK_PREFIX, "link_prefix");        result.setProperty(HTMLRenderer.LINE_PREFIX, "line_prefix");        result.setProperty(HTMLRenderer.HTML_EXTENSION, true);        return result;    }    @Override    protected String getSourceCodeFilename() {        return "notAvailable";    }    @Override    String getExpected() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>1</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Boo</td><td align=center>1</td></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>1</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "<tr> " + PMD.EOL + "<td align=\"center\">2</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td><a href=\"link_prefixfile.html#\">file</a></td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Test    void testShowSuppressions() throws Exception {        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(true);        String actual = renderReport(renderer, createEmptyReportWithSuppression());        assertEquals("<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>"                + PMD.EOL + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Suppressed warnings</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Line</th><th>Rule</th><th>NOPMD or Annotation</th><th>Reason</th></tr>"                         + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"left\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\">1</td>" + PMD.EOL + "<td align=\"center\">Foo</td>" + PMD.EOL                         + "<td align=\"center\">//NOPMD</td>" + PMD.EOL + "<td align=\"center\">test</td>" + PMD.EOL                         + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL, actual);    }    @Test    void testHideSuppressions() throws Exception {        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(false);        String actual = renderReport(renderer, createEmptyReportWithSuppression());        assertEquals(getExpectedEmpty(), actual);    }    private Consumer<FileAnalysisListener> createEmptyReportWithSuppression() {        return listener -> {            TextDocument doc = TextDocument.readOnlyString(                "dummy code",                getSourceCodeFilename(),                DummyLanguageModule.getInstance().getDefaultVersion()            );            DummyRootNode root = DummyLanguageModule.parse("dummy code", getSourceCodeFilename())                                                    .withNoPmdComments(Collections.singletonMap(1, "test"));            RuleContext ruleContext = RuleContext.create(listener, new FooRule());            ruleContext.addViolationWithPosition(root, 1, 1, "suppress test");        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.endsWith;import static org.hamcrest.Matchers.hasSize;import java.nio.file.Paths;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.internal.util.FileCollectionUtil;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.document.FileCollector;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.util.log.internal.NoopReporter;class PMDFilelistTest {    private @NonNull FileCollector newCollector() {        return FileCollector.newCollector(new LanguageVersionDiscoverer(LanguageRegistry.PMD), new NoopReporter());    }    private static void collectFileList(FileCollector collector, String x) {        FileCollectionUtil.collectFileList(collector, Paths.get(x));    }    @Test    void testGetApplicableFiles() {        FileCollector collector = newCollector();        collectFileList(collector, "src/test/resources/net/sourceforge/pmd/cli/filelist.txt");        List<TextFile> applicableFiles = collector.getCollectedFiles();        assertThat(applicableFiles, hasSize(2));        assertThat(applicableFiles.get(0).getPathId(), endsWith("anotherfile.dummy"));        assertThat(applicableFiles.get(1).getPathId(), endsWith("somefile.dummy"));    }    @Test    void testGetApplicableFilesMultipleLines() {        FileCollector collector = newCollector();        collectFileList(collector, "src/test/resources/net/sourceforge/pmd/cli/filelist2.txt");        List<TextFile> applicableFiles = collector.getCollectedFiles();        assertThat(applicableFiles, hasSize(3));        assertThat(applicableFiles.get(0).getPathId(), endsWith("anotherfile.dummy"));        assertThat(applicableFiles.get(1).getPathId(), endsWith("somefile.dummy"));        assertThat(applicableFiles.get(2).getPathId(), endsWith("somefile.dummy"));    }    @Test    void testGetApplicableFilesWithIgnores() {        FileCollector collector = newCollector();        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist3.txt");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        FileCollectionUtil.collectFiles(configuration, collector);        List<TextFile> applicableFiles = collector.getCollectedFiles();        assertThat(applicableFiles, hasSize(2));        assertThat(applicableFiles.get(0).getPathId(), endsWith("somefile2.dummy"));        assertThat(applicableFiles.get(1).getPathId(), endsWith("somefile4.dummy"));    }    @Test    void testGetApplicableFilesWithDirAndIgnores() {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputPaths("src/test/resources/net/sourceforge/pmd/cli/src");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        FileCollector collector = newCollector();        FileCollectionUtil.collectFiles(configuration, collector);        List<TextFile> applicableFiles = collector.getCollectedFiles();        assertThat(applicableFiles, hasSize(4));        assertThat(applicableFiles.get(0).getPathId(), endsWith("anotherfile.dummy"));        assertThat(applicableFiles.get(1).getPathId(), endsWith("somefile.dummy"));        assertThat(applicableFiles.get(2).getPathId(), endsWith("somefile2.dummy"));        assertThat(applicableFiles.get(3).getPathId(), endsWith("somefile4.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.empty;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.cache.NoopAnalysisCache;import net.sourceforge.pmd.lang.LanguageRegistry;import com.github.stefanbirkner.systemlambda.SystemLambda;/** * Unit test for {@link PMDCommandLineInterface} */class PMDCommandLineInterfaceTest {    @BeforeEach    void clearSystemProperties() {        System.clearProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN);        System.clearProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY);    }    @Test    void testProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "yahtml", "-P", "outputDir=output_folder", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertEquals("output_folder", params.getProperties().getProperty("outputDir"));    }    @Test    void testMultipleProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "ideaj", "-P", "sourcePath=/home/user/source/", "-P",            "fileName=Foo.java", "-P", "classAndMethodName=Foo.method", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertEquals("/home/user/source/", params.getProperties().getProperty("sourcePath"));        assertEquals("Foo.java", params.getProperties().getProperty("fileName"));        assertEquals("Foo.method", params.getProperties().getProperty("classAndMethodName"));    }    @Test    void testNoCacheSwitch() {        PMDParameters params = new PMDParameters();        String[] args = {"-d", "source_folder", "-f", "ideaj", "-R", "java-empty", "-cache", "/home/user/.pmd/cache", "-no-cache", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertTrue(params.isIgnoreIncrementalAnalysis());        PMDConfiguration config = params.toConfiguration(LanguageRegistry.PMD);        assertTrue(config.isIgnoreIncrementalAnalysis());        assertTrue(config.getAnalysisCache() instanceof NoopAnalysisCache);    }    @Test    void testNoCacheSwitchLongOption() {        PMDParameters params = new PMDParameters();        String[] args = {"-d", "source_folder", "-f", "ideaj", "-R", "java-empty", "--cache", "/home/user/.pmd/cache", "--no-cache", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertTrue(params.isIgnoreIncrementalAnalysis());        PMDConfiguration config = params.toConfiguration();        assertTrue(config.isIgnoreIncrementalAnalysis());        assertTrue(config.getAnalysisCache() instanceof NoopAnalysisCache);    }    @Test    void testSetStatusCodeOrExitDoExit() throws Exception {        int code = SystemLambda.catchSystemExit(() -> PMDCommandLineInterface.setStatusCodeOrExit(0));        assertEquals(0, code);    }    @Test    void testSetStatusCodeOrExitSetStatus() {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "1");        PMDCommandLineInterface.setStatusCodeOrExit(0);        assertEquals(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY), "0");    }    @Test    void testBuildUsageText() {        // no exception..        assertNotNull(PMDCommandLineInterface.buildUsageText());    }    @Test    void testOnlyFileListOption() {        PMDParameters params = new PMDParameters();        String[] args = {"--file-list", "pmd.filelist", "-f", "text", "-R", "rulesets/java/quickstart.xml", "--no-cache", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        PMDConfiguration config = params.toConfiguration();        assertEquals("pmd.filelist", config.getInputFile().toString());        assertThat(config.getInputPathList(), empty()); // no additional input paths    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.hamcrest.Matchers.containsStringIgnoringCase;import static org.hamcrest.Matchers.not;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.fail;import java.io.FilterOutputStream;import java.io.IOException;import java.io.PrintStream;import java.nio.ByteBuffer;import java.nio.charset.StandardCharsets;import java.nio.file.FileSystems;import java.nio.file.Files;import java.nio.file.Path;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMD.StatusCode;import net.sourceforge.pmd.internal.Slf4jSimpleConfiguration;import net.sourceforge.pmd.util.IOUtil;import com.github.stefanbirkner.systemlambda.SystemLambda;/** * */class CoreCliTest {    @TempDir    private Path tempDir;    private static final String DUMMY_RULESET = "net/sourceforge/pmd/cli/FakeRuleset.xml";    private static final String STRING_TO_REPLACE = "__should_be_replaced__";    private Path srcDir;    @AfterAll    static void resetLogging() {        // reset logging in case "--debug" changed the logging properties        // See also Slf4jSimpleConfigurationForAnt        Slf4jSimpleConfiguration.reconfigureDefaultLogLevel(null);    }    @BeforeEach    void setup() throws IOException {        // set current directory to wd        Path root = tempRoot();        System.setProperty("user.dir", root.toString());        // create a few files        srcDir = Files.createDirectories(root.resolve("src"));        writeString(srcDir.resolve("someSource.dummy"), "dummy text");    }    @Test    void testPreExistingReportFile() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        // now we create the file        Files.createDirectories(reportFile.getParent());        writeString(reportFile, STRING_TO_REPLACE);        assertTrue(Files.exists(reportFile), "Report file should exist");        runPmdSuccessfully("--no-cache", "-d", srcDir, "-R", DUMMY_RULESET, "-r", reportFile);        assertNotEquals(readString(reportFile), STRING_TO_REPLACE);    }    @Test    void testPreExistingReportFileLongOption() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        // now we create the file        Files.createDirectories(reportFile.getParent());        writeString(reportFile, STRING_TO_REPLACE);        assertTrue(Files.exists(reportFile), "Report file should exist");        runPmdSuccessfully("--no-cache", "--dir", srcDir, "--rulesets", DUMMY_RULESET, "--report-file", reportFile);        assertNotEquals(readString(reportFile), STRING_TO_REPLACE, "Report file should have been overwritten");    }    @Test    void testNonExistentReportFile() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        assertFalse(Files.exists(reportFile), "Report file should not exist");        try {            runPmdSuccessfully("--no-cache", "-d", srcDir, "-R", DUMMY_RULESET, "-r", reportFile);            assertTrue(Files.exists(reportFile), "Report file should have been created");        } finally {            Files.deleteIfExists(reportFile);        }    }    @Test    void testNonExistentReportFileLongOption() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        assertFalse(Files.exists(reportFile), "Report file should not exist");        runPmdSuccessfully("--no-cache", "--dir", srcDir, "--rulesets", DUMMY_RULESET, "--report-file", reportFile);        assertTrue(Files.exists(reportFile), "Report file should have been created");    }    @Test    void testFileCollectionWithUnknownFiles() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        Files.createFile(srcDir.resolve("foo.not_analysable"));        assertFalse(Files.exists(reportFile), "Report file should not exist");        // restoring system properties: --debug might change logging properties        SystemLambda.restoreSystemProperties(() -> {            runPmdSuccessfully("--no-cache", "--dir", srcDir, "--rulesets", DUMMY_RULESET, "--report-file", reportFile, "--debug");        });        assertTrue(Files.exists(reportFile), "Report file should have been created");        String reportText = IOUtil.readToString(Files.newBufferedReader(reportFile, StandardCharsets.UTF_8));        assertThat(reportText, not(containsStringIgnoringCase("error")));    }    @Test    void testNonExistentReportFileDeprecatedOptions() throws Exception {        Path reportFile = tempRoot().resolve("out/reportFile.txt");        assertFalse(Files.exists(reportFile), "Report file should not exist");        String log = runPmdSuccessfully("-no-cache", "-dir", srcDir, "-rulesets", DUMMY_RULESET, "-reportfile", reportFile);        assertTrue(Files.exists(reportFile), "Report file should have been created");        assertTrue(log.contains("Some deprecated options were used on the command-line, including -rulesets"));        assertTrue(log.contains("Consider replacing it with --rulesets (or -R)"));        // only one parameter is logged        assertFalse(log.contains("Some deprecated options were used on the command-line, including -reportfile"));        assertFalse(log.contains("Consider replacing it with --report-file"));    }    /**     * This tests to create the report file in the current working directory.     *     * <p>Note: We can't change the cwd in the running VM, so the file will not be created     * in the temporary folder, but really in the cwd. The test fails if a file already exists     * and makes sure to cleanup the file afterwards.     */    @Test    void testRelativeReportFile() throws Exception {        String reportFile = "reportFile.txt";        Path absoluteReportFile = FileSystems.getDefault().getPath(reportFile).toAbsolutePath();        // verify the file doesn't exist yet - we will delete the file at the end!        assertFalse(Files.exists(absoluteReportFile), "Report file must not exist yet! " + absoluteReportFile);        try {            runPmdSuccessfully("--no-cache", "-d", srcDir, "-R", DUMMY_RULESET, "-r", reportFile);            assertTrue(Files.exists(absoluteReportFile), "Report file should have been created");        } finally {            Files.deleteIfExists(absoluteReportFile);        }    }    @Test    void testRelativeReportFileLongOption() throws Exception {        String reportFile = "reportFile.txt";        Path absoluteReportFile = FileSystems.getDefault().getPath(reportFile).toAbsolutePath();        // verify the file doesn't exist yet - we will delete the file at the end!        assertFalse(Files.exists(absoluteReportFile), "Report file must not exist yet!");        try {            runPmdSuccessfully("--no-cache", "--dir", srcDir, "--rulesets", DUMMY_RULESET, "--report-file", reportFile);            assertTrue(Files.exists(absoluteReportFile), "Report file should have been created");        } finally {            Files.deleteIfExists(absoluteReportFile);        }    }    @Test    void debugLogging() throws Exception {        // restoring system properties: --debug might change logging properties        SystemLambda.restoreSystemProperties(() -> {            String log = runPmdSuccessfully("--debug", "--no-cache", "--dir", srcDir, "--rulesets", DUMMY_RULESET);            assertThat(log, containsString("[main] INFO net.sourceforge.pmd.PMD - Log level is at TRACE"));        });    }    @Test    void defaultLogging() throws Exception {        String log = runPmdSuccessfully("--no-cache", "--dir", srcDir, "--rulesets", DUMMY_RULESET);        assertThat(log, containsString("[main] INFO net.sourceforge.pmd.PMD - Log level is at INFO"));    }    @Test    void testDeprecatedRulesetSyntaxOnCommandLine() throws Exception {        String log = SystemLambda.tapSystemErrAndOut(() -> {            runPmd(StatusCode.VIOLATIONS_FOUND, "--no-cache", "--dir", srcDir, "--rulesets", "dummy-basic");        });        assertThat(log, containsString("Ruleset reference 'dummy-basic' uses a deprecated form, use 'rulesets/dummy/basic.xml' instead"));    }    @Test    void testReportToStdoutNotClosing() throws Exception {        PrintStream originalOut = System.out;        PrintStream out = new PrintStream(new FilterOutputStream(originalOut) {            @Override            public void close() {                fail("Stream must not be closed");            }        });        try {            System.setOut(out);            SystemLambda.tapSystemErrAndOut(() -> {                runPmd(StatusCode.VIOLATIONS_FOUND, "--no-cache", "--dir", srcDir, "--rulesets", "dummy-basic");            });        } finally {            System.setOut(originalOut);        }    }    @Test    void testWrongCliOptionsDoNotPrintUsage() throws Exception {        String[] args = { "-invalid" };        PmdParametersParseResult params = PmdParametersParseResult.extractParameters(args);        assertTrue(params.isError(), "Expected invalid args");        String log = SystemLambda.tapSystemErrAndOut(() -> {            StatusCode code = PMD.runPmd(args);            assertEquals(StatusCode.ERROR, code);        });        assertThat(log, not(containsStringIgnoringCase("Available report formats and")));    }    // utilities    private Path tempRoot() {        return tempDir;    }    private static String runPmdSuccessfully(Object... args) throws Exception {        return SystemLambda.tapSystemErrAndOut(() -> {            runPmd(StatusCode.OK, args);        });    }    private static String[] argsToString(Object... args) {        String[] result = new String[args.length];        for (int i = 0; i < args.length; i++) {            result[i] = args[i].toString();        }        return result;    }    // available in Files on java 11+    private static void writeString(Path path, String text) throws IOException {        ByteBuffer encoded = StandardCharsets.UTF_8.encode(text);        Files.write(path, encoded.array());    }    // available in Files on java 11+    private static String readString(Path path) throws IOException {        byte[] bytes = Files.readAllBytes(path);        ByteBuffer buf = ByteBuffer.wrap(bytes);        return StandardCharsets.UTF_8.decode(buf).toString();    }    private static void runPmd(StatusCode expectedExitCode, Object... args) {        StatusCode actualExitCode = PMD.runPmd(argsToString(args));        assertEquals(expectedExitCode, actualExitCode, "Exit code");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.nio.file.Path;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.util.CollectionUtil;class PMDParametersTest {    @Test    void testMultipleDirsAndRuleSets() {        PmdParametersParseResult result = PmdParametersParseResult.extractParameters(            "-d", "a", "b", "-R", "x.xml", "y.xml"        );        assertMultipleDirsAndRulesets(result);    }    @Test    void testMultipleDirsAndRuleSetsWithCommas() {        PmdParametersParseResult result = PmdParametersParseResult.extractParameters(            "-d", "a,b", "-R", "x.xml,y.xml"        );        assertMultipleDirsAndRulesets(result);    }    @Test    void testMultipleDirsAndRuleSetsWithRepeatedOption() {        PmdParametersParseResult result = PmdParametersParseResult.extractParameters(            "-d", "a", "-d", "b", "-R", "x.xml", "-R", "y.xml"        );        assertMultipleDirsAndRulesets(result);    }    @Test    void testNoPositionalParametersAllowed() {        assertError(            //                        vvvv            "-R", "x.xml", "-d", "a", "--", "-d", "b"        );    }    private void assertMultipleDirsAndRulesets(PmdParametersParseResult result) {        assertFalse(result.isError());        PMDConfiguration config = result.toConfiguration();        assertEquals(CollectionUtil.map(config.getInputPathList(), Path::toString), listOf("a", "b"));        assertEquals(config.getRuleSetPaths(), listOf("x.xml", "y.xml"));    }    @Test    void testEmptyDirOption() {        assertError("-d", "-R", "y.xml");    }    @Test    void testEmptyRulesetOption() {        assertError("-R", "-d", "something");    }    private void assertError(String... params) {        PmdParametersParseResult result = PmdParametersParseResult.extractParameters(params);        assertTrue(result.isError());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import org.junit.jupiter.api.Test;class RuleSetFactoryCompatibilityTest {    @Test    void testCorrectOldReference() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\" />\n" + "</ruleset>\n";        RuleSetFactoryCompatibility compat = new RuleSetFactoryCompatibility();        compat.addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        RuleSetLoader rulesetLoader = new RuleSetLoader().setCompatibility(compat);        RuleSet createdRuleSet = rulesetLoader.loadFromString("dummy.xml", ruleset);        assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));    }    @Test    void testCorrectMovedAndRename() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "OldDummyBasicMockRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldDummyBasicMockRule", "NewNameForDummyBasicMockRule");        String out = rsfc.applyRef("rulesets/dummy/notexisting.xml/OldDummyBasicMockRule");        assertEquals("rulesets/dummy/basic.xml/NewNameForDummyBasicMockRule", out);    }    @Test    void testExclusion() {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n" + " <rule ref=\"rulesets/dummy/basic.xml\">\n"                + "   <exclude name=\"OldNameOfSampleXPathRule\"/>\n" + " </rule>\n" + "</ruleset>\n";        RuleSetFactoryCompatibility compat = new RuleSetFactoryCompatibility();        compat.addFilterRuleRenamed("dummy", "basic", "OldNameOfSampleXPathRule", "SampleXPathRule");        RuleSetLoader rulesetLoader = new RuleSetLoader().setCompatibility(compat);        RuleSet createdRuleSet = rulesetLoader.loadFromString("dummy.xml", ruleset);        assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));        assertNull(createdRuleSet.getRuleByName("SampleXPathRule"));    }    @Test    void testExclusionRenamedAndMoved() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMovedAndRenamed("dummy", "oldbasic", "OldDummyBasicMockRule", "basic", "NewNameForDummyBasicMockRule");        String in = "rulesets/dummy/oldbasic.xml";        String out = rsfc.applyRef(in);        assertEquals(in, out);    }    @Test    void testFilter() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        rsfc.addFilterRuleRemoved("dummy", "basic", "DeletedRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldNameOfBasicMockRule", "NewNameOfBasicMockRule");        assertEquals("rulesets/dummy/basic.xml/DummyBasicMockRule",                            rsfc.applyRef("rulesets/dummy/notexisting.xml/DummyBasicMockRule"));        assertEquals("rulesets/dummy/basic.xml/NewNameOfBasicMockRule",                            rsfc.applyRef("rulesets/dummy/basic.xml/OldNameOfBasicMockRule"));        assertNull(rsfc.applyRef("rulesets/dummy/basic.xml/DeletedRule"));    }    @Test    void testExclusionFilter() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleRenamed("dummy", "basic", "AnotherOldNameOfBasicMockRule", "NewNameOfBasicMockRule");        String out = rsfc.applyExclude("rulesets/dummy/basic.xml", "AnotherOldNameOfBasicMockRule", false);        assertEquals("NewNameOfBasicMockRule", out);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ByteArrayInputStream;import java.io.IOException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Locale;import javax.xml.XMLConstants;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.stream.StreamSource;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.xml.sax.EntityResolver;import org.xml.sax.ErrorHandler;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;class RuleSetSchemaTest {    private CollectingErrorHandler errorHandler;    @BeforeEach    void setUp() {        Locale.setDefault(Locale.ROOT);        errorHandler = new CollectingErrorHandler();    }    @Test    void verifyVersion2() throws Exception {        String ruleset = generateRuleSet("2.0.0");        Document doc = parseWithVersion2(ruleset);        assertNotNull(doc);        assertTrue(errorHandler.isValid());        assertEquals("Custom ruleset", ((Attr) doc.getElementsByTagName("ruleset").item(0).getAttributes().getNamedItem("name")).getValue());    }    @Test    void validateOnly() throws Exception {        Validator validator = PMDRuleSetEntityResolver.getSchemaVersion2().newValidator();        validator.setErrorHandler(errorHandler);        validator.validate(new StreamSource(new ByteArrayInputStream(generateRuleSet("2.0.0").getBytes(StandardCharsets.UTF_8))));        assertTrue(errorHandler.isValid());        errorHandler.reset();    }    private Document parseWithVersion2(String ruleset) throws SAXException, ParserConfigurationException, IOException {        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        dbf.setNamespaceAware(true);        dbf.setFeature("http://apache.org/xml/features/validation/schema", true);        DocumentBuilder builder = dbf.newDocumentBuilder();        builder.setErrorHandler(errorHandler);        builder.setEntityResolver(new PMDRuleSetEntityResolver());        Document doc = builder.parse(new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.UTF_8)));        return doc;    }    private String generateRuleSet(String version) {        String versionUnderscore = version.replaceAll("\\.", "_");        String ruleset = "<?xml version=\"1.0\"?>" + PMD.EOL                + "<ruleset " + PMD.EOL                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/" + version + "\"" + PMD.EOL                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" + PMD.EOL                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/" + version + " https://pmd.sourceforge.io/ruleset_" + versionUnderscore + ".xsd\""                + "    name=\"Custom ruleset\" >" + PMD.EOL                + "  <description>" + PMD.EOL                + "  This ruleset checks my code for bad stuff" + PMD.EOL                + "  </description>" + PMD.EOL                + "  <rule name=\"DummyBasicMockRule\" language=\"dummy\" since=\"1.0\" message=\"Test Rule 1\"" + PMD.EOL                + "        class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL                + "        externalInfoUrl=\"${pmd.website.baseurl}/rules/dummy/basic.xml#DummyBasicMockRule\"" + PMD.EOL                + "  >" + PMD.EOL                + "        <description>" + PMD.EOL                + "           Just for test" + PMD.EOL                + "     </description>" + PMD.EOL                + "        <priority>3</priority>" + PMD.EOL                + "        <example>" + PMD.EOL                + " <![CDATA[" + PMD.EOL                + " ]]>" + PMD.EOL                + "     </example>" + PMD.EOL                + "    </rule>" + PMD.EOL                + "  <rule ref=\"rulesets/dummy/basic.xml#DummyBasicMockRule\"/>" + PMD.EOL                + "</ruleset>" + PMD.EOL;        return ruleset;    }    public static class PMDRuleSetEntityResolver implements EntityResolver {        private static URL schema2 = PMDRuleSetEntityResolver.class.getResource("/ruleset_2_0_0.xsd");        private static SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);        @Override        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {            if ("https://pmd.sourceforge.io/ruleset_2_0_0.xsd".equals(systemId)) {                return new InputSource(schema2.toExternalForm());            }            throw new IllegalArgumentException("Unable to resolve entity (publicId=" + publicId + ", systemId=" + systemId + ")");        }        public static Schema getSchemaVersion2() throws SAXException {            return schemaFactory.newSchema(schema2);        }    }    public static class CollectingErrorHandler implements ErrorHandler {        private List<SAXParseException> warnings = new ArrayList<>();        private List<SAXParseException> errors = new ArrayList<>();        private List<SAXParseException> fatalErrors = new ArrayList<>();        public boolean isValid() {            return warnings.isEmpty() && errors.isEmpty() && fatalErrors.isEmpty();        }        public List<SAXParseException> getWarnings() {            return warnings;        }        public List<SAXParseException> getErrors() {            return errors;        }        public List<SAXParseException> getFatalErrors() {            return fatalErrors;        }        @Override        public void warning(SAXParseException exception) throws SAXException {            warnings.add(exception);        }        @Override        public void error(SAXParseException exception) throws SAXException {            errors.add(exception);        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {            fatalErrors.add(exception);        }        @Override        public String toString() {            return "Warnings: " + warnings + "; Errors: " + errors + "; Fatal Errors: " + fatalErrors;        }        public void reset() {            warnings.clear();            errors.clear();            fatalErrors.clear();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.empty;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertSame;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Collections;import java.util.List;import java.util.Properties;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.cache.FileAnalysisCache;import net.sourceforge.pmd.cache.NoopAnalysisCache;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.util.ClasspathClassLoader;class PmdConfigurationTest {    @Test    void testSuppressMarker() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(PMDConfiguration.DEFAULT_SUPPRESS_MARKER, configuration.getSuppressMarker(), "Default suppress marker");        configuration.setSuppressMarker("CUSTOM_MARKER");        assertEquals("CUSTOM_MARKER", configuration.getSuppressMarker(), "Changed suppress marker");    }    @Test    void testThreads() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(Runtime.getRuntime().availableProcessors(), configuration.getThreads(), "Default threads");        configuration.setThreads(0);        assertEquals(0, configuration.getThreads(), "Changed threads");    }    @Test    void testClassLoader() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(PMDConfiguration.class.getClassLoader(), configuration.getClassLoader(), "Default ClassLoader");        configuration.prependAuxClasspath("some.jar");        assertEquals(ClasspathClassLoader.class, configuration.getClassLoader().getClass(),                "Prepended ClassLoader class");        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        assertEquals(1, urls.length, "urls length");        assertTrue(urls[0].toString().endsWith("/some.jar"), "url[0]");        assertEquals(PMDConfiguration.class.getClassLoader(), configuration.getClassLoader().getParent(),                "parent classLoader");        configuration.setClassLoader(null);        assertEquals(PMDConfiguration.class.getClassLoader(), configuration.getClassLoader(),                "Revert to default ClassLoader");    }    @Test    void auxClasspathWithRelativeFileEmpty() {        String relativeFilePath = "src/test/resources/net/sourceforge/pmd/cli/auxclasspath-empty.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependAuxClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        assertEquals(0, urls.length);    }    @Test    void auxClasspathWithRelativeFileEmpty2() {        String relativeFilePath = "./src/test/resources/net/sourceforge/pmd/cli/auxclasspath-empty.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependAuxClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        assertEquals(0, urls.length);    }    @Test    void auxClasspathWithRelativeFile() throws URISyntaxException {        final String FILE_SCHEME = "file";        String currentWorkingDirectory = new File("").getAbsoluteFile().toURI().getPath();        String relativeFilePath = "src/test/resources/net/sourceforge/pmd/cli/auxclasspath.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependAuxClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        URI[] uris = new URI[urls.length];        for (int i = 0; i < urls.length; i++) {            uris[i] = urls[i].toURI();        }        URI[] expectedUris = new URI[] {            new URI(FILE_SCHEME, null, currentWorkingDirectory + "lib1.jar", null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "other/directory/lib2.jar", null),            new URI(FILE_SCHEME, null, new File("/home/jondoe/libs/lib3.jar").getAbsoluteFile().toURI().getPath(), null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "classes", null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "classes2", null),            new URI(FILE_SCHEME, null, new File("/home/jondoe/classes").getAbsoluteFile().toURI().getPath(), null),            new URI(FILE_SCHEME, null, currentWorkingDirectory, null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "relative source dir/bar", null),        };        assertArrayEquals(expectedUris, uris);    }    @Test    void testRuleSetsLegacy() {        PMDConfiguration configuration = new PMDConfiguration();        assertNull(configuration.getRuleSets(), "Default RuleSets");        configuration.setRuleSets("/rulesets/basic.xml");        assertEquals("/rulesets/basic.xml", configuration.getRuleSets(), "Changed RuleSets");        configuration.setRuleSets((String) null);        assertNull(configuration.getRuleSets());    }    @Test    void testRuleSets() {        PMDConfiguration configuration = new PMDConfiguration();        assertThat(configuration.getRuleSetPaths(), empty());        configuration.setRuleSets(listOf("/rulesets/basic.xml"));        assertEquals(listOf("/rulesets/basic.xml"), configuration.getRuleSetPaths());        configuration.addRuleSet("foo.xml");        assertEquals(listOf("/rulesets/basic.xml", "foo.xml"), configuration.getRuleSetPaths());        configuration.setRuleSets(Collections.<String>emptyList());        assertThat(configuration.getRuleSetPaths(), empty());        // should be addable even though we set it to an unmodifiable empty list        configuration.addRuleSet("foo.xml");        assertEquals(listOf("foo.xml"), configuration.getRuleSetPaths());    }    @Test    void testMinimumPriority() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(RulePriority.LOW, configuration.getMinimumPriority(), "Default minimum priority");        configuration.setMinimumPriority(RulePriority.HIGH);        assertEquals(RulePriority.HIGH, configuration.getMinimumPriority(), "Changed minimum priority");    }    @Test    void testSourceEncoding() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(System.getProperty("file.encoding"), configuration.getSourceEncoding().name(), "Default source encoding");        configuration.setSourceEncoding(StandardCharsets.UTF_16LE.name());        assertEquals(StandardCharsets.UTF_16LE, configuration.getSourceEncoding(), "Changed source encoding");    }    @Test    void testInputPaths() {        PMDConfiguration configuration = new PMDConfiguration();        assertThat(configuration.getInputPathList(), empty());        configuration.setInputPaths("a,b,c");        List<Path> expected = listOf(            Paths.get("a"), Paths.get("b"), Paths.get("c")        );        assertEquals(expected, configuration.getInputPathList(), "Changed input paths");    }    @Test    void testReportShortNames() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(false, configuration.isReportShortNames(), "Default report short names");        configuration.setReportShortNames(true);        assertEquals(true, configuration.isReportShortNames(), "Changed report short names");    }    @Test    void testReportFormat() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(null, configuration.getReportFormat(), "Default report format");        configuration.setReportFormat("csv");        assertEquals("csv", configuration.getReportFormat(), "Changed report format");    }    @Test    void testCreateRenderer() {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setReportFormat("csv");        Renderer renderer = configuration.createRenderer();        assertEquals(CSVRenderer.class, renderer.getClass(), "Renderer class");        assertEquals(false, renderer.isShowSuppressedViolations(), "Default renderer show suppressed violations");        configuration.setShowSuppressedViolations(true);        renderer = configuration.createRenderer();        assertEquals(CSVRenderer.class, renderer.getClass(), "Renderer class");        assertEquals(true, renderer.isShowSuppressedViolations(), "Changed renderer show suppressed violations");    }    @Test    void testReportFile() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(null, configuration.getReportFile(), "Default report file");        configuration.setReportFile("somefile");        assertEquals("somefile", configuration.getReportFile(), "Changed report file");    }    @Test    void testShowSuppressedViolations() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(false, configuration.isShowSuppressedViolations(), "Default show suppressed violations");        configuration.setShowSuppressedViolations(true);        assertEquals(true, configuration.isShowSuppressedViolations(), "Changed show suppressed violations");    }    @Test    void testReportProperties() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(0, configuration.getReportProperties().size(), "Default report properties size");        configuration.getReportProperties().put("key", "value");        assertEquals(1, configuration.getReportProperties().size(), "Changed report properties size");        assertEquals("value", configuration.getReportProperties().get("key"), "Changed report properties value");        configuration.setReportProperties(new Properties());        assertEquals(0, configuration.getReportProperties().size(), "Replaced report properties size");    }    @Test    void testDebug() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(false, configuration.isDebug(), "Default debug");        configuration.setDebug(true);        assertEquals(true, configuration.isDebug(), "Changed debug");    }    @Test    void testStressTest() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(false, configuration.isStressTest(), "Default stress test");        configuration.setStressTest(true);        assertEquals(true, configuration.isStressTest(), "Changed stress test");    }    @Test    void testBenchmark() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals(false, configuration.isBenchmark(), "Default benchmark");        configuration.setBenchmark(true);        assertEquals(true, configuration.isBenchmark(), "Changed benchmark");    }    @Test    void testAnalysisCache(@TempDir Path folder) throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        assertNotNull(configuration.getAnalysisCache(), "Default cache is null");        assertTrue(configuration.getAnalysisCache() instanceof NoopAnalysisCache, "Default cache is not a noop");        configuration.setAnalysisCache(null);        assertNotNull(configuration.getAnalysisCache(), "Default cache was set to null");        final File cacheFile = folder.resolve("pmd-cachefile").toFile();        assertTrue(cacheFile.createNewFile());        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertSame(analysisCache, configuration.getAnalysisCache(), "Configured cache not stored");    }    @Test    void testAnalysisCacheLocation() {        final PMDConfiguration configuration = new PMDConfiguration();        configuration.setAnalysisCacheLocation(null);        assertNotNull(configuration.getAnalysisCache(), "Null cache location accepted");        assertTrue(configuration.getAnalysisCache() instanceof NoopAnalysisCache, "Null cache location accepted");        configuration.setAnalysisCacheLocation("pmd.cache");        assertNotNull(configuration.getAnalysisCache(), "Not null cache location produces null cache");        assertTrue(configuration.getAnalysisCache() instanceof FileAnalysisCache,                "File cache location doesn't produce a file cache");    }    @Test    void testIgnoreIncrementalAnalysis(@TempDir Path folder) throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        // set dummy cache location        final File cacheFile = folder.resolve("pmd-cachefile").toFile();        assertTrue(cacheFile.createNewFile());        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertNotNull(configuration.getAnalysisCache(), "Null cache location accepted");        assertFalse(configuration.getAnalysisCache() instanceof NoopAnalysisCache, "Non null cache location, cache should not be noop");        configuration.setIgnoreIncrementalAnalysis(true);        assertTrue(configuration.getAnalysisCache() instanceof NoopAnalysisCache, "Ignoring incremental analysis should turn the cache into a noop");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageFilenameFilter;/** * Tests on FileSelector. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be */class FileSelectorTest {    /**     * Test wanted selection of a source file.     */    @Test    void testWantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(DummyLanguageModule.getInstance());        File javaFile = new File("/path/to/myFile.dummy");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertTrue(selected, "This file should be selected !");    }    /**     * Test unwanted selection of a non source file.     */    @Test    void testUnwantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(DummyLanguageModule.getInstance());        File javaFile = new File("/path/to/myFile.txt");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertFalse(selected, "Not-source file must not be selected!");    }    /**     * Test unwanted selection of a java file.     */    @Test    void testUnwantedJavaFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(DummyLanguageModule.getInstance());        File javaFile = new File("/path/to/MyClass.java");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertFalse(selected, "Unwanted java file must not be selected!");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.empty;import static org.hamcrest.Matchers.equalTo;import static org.hamcrest.Matchers.hasSize;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.never;import static org.mockito.Mockito.spy;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import java.io.IOException;import java.nio.file.Paths;import org.junit.jupiter.api.Test;import org.mockito.ArgumentMatchers;import net.sourceforge.pmd.RuleSetTest.MockRule;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.document.SimpleTestTextFile;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.processor.PmdRunnableTest;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.reporting.ReportStats;/** * @author Clément Fournier */public class PmdAnalysisTest {    @Test    void testPmdAnalysisWithEmptyConfig() {        PMDConfiguration config = new PMDConfiguration();        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            assertThat(pmd.files().getCollectedFiles(), empty());            assertThat(pmd.rulesets(), empty());            assertThat(pmd.renderers(), empty());        }    }    @Test    void testRendererInteractions() throws IOException {        PMDConfiguration config = new PMDConfiguration();        config.setInputPaths("sample-source/dummy");        Renderer renderer = spy(Renderer.class);        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            pmd.addRenderer(renderer);            verify(renderer, never()).start();            pmd.performAnalysis();        }        verify(renderer, times(1)).renderFileReport(ArgumentMatchers.<Report>any());        verify(renderer, times(1)).start();        verify(renderer, times(1)).end();        verify(renderer, times(1)).flush();    }    @Test    void testRulesetLoading() {        PMDConfiguration config = new PMDConfiguration();        config.addRuleSet("rulesets/dummy/basic.xml");        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            assertThat(pmd.rulesets(), hasSize(1));        }    }    @Test    void testRulesetWhenSomeoneHasAnError() {        PMDConfiguration config = new PMDConfiguration();        config.addRuleSet("rulesets/dummy/basic.xml");        config.addRuleSet("rulesets/xxxe/notaruleset.xml");        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            assertThat(pmd.rulesets(), hasSize(1)); // no failure            assertThat(pmd.getReporter().numErrors(), equalTo(1));        }    }    @Test    void testParseException() {        PMDConfiguration config = new PMDConfiguration();        config.setThreads(1);        config.setForceLanguageVersion(PmdRunnableTest.getVersionWithParserThatThrowsSemanticError());        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            pmd.addRuleSet(RuleSet.forSingleRule(new MockRule()));            pmd.files().addSourceFile("file", "some source");            ReportStats stats = pmd.runAndReturnStats();            assertEquals(1, stats.getNumErrors(), "Errors");            assertEquals(0, stats.getNumViolations(), "Violations");        }    }    @Test    void testFileWithSpecificLanguage() {        final Language language = Dummy2LanguageModule.getInstance();        PMDConfiguration config = new PMDConfiguration();        config.setIgnoreIncrementalAnalysis(true);        RuleSet ruleset = RuleSet.forSingleRule(new TestRule());        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            pmd.addRuleSet(ruleset);            pmd.files().addFile(Paths.get("src", "test", "resources", "sample-source", "dummy", "foo.txt"), language);            Report report = pmd.performAnalysisAndCollectReport();            for (Report.ProcessingError error : report.getProcessingErrors()) {                System.out.println("error = " + error.getMsg() + ": " + error.getDetail());            }            assertEquals(0, report.getProcessingErrors().size());            assertEquals(1, report.getViolations().size());        }    }    @Test    void testTextFileWithSpecificLanguage() {        final Language language = Dummy2LanguageModule.getInstance();        PMDConfiguration config = new PMDConfiguration();        config.setIgnoreIncrementalAnalysis(true);        RuleSet ruleset = RuleSet.forSingleRule(new TestRule());        try (PmdAnalysis pmd = PmdAnalysis.create(config)) {            pmd.addRuleSet(ruleset);            pmd.files().addFile(new SimpleTestTextFile("test content foo", "foo.txt", language.getDefaultVersion()));            Report report = pmd.performAnalysisAndCollectReport();            for (Report.ProcessingError error : report.getProcessingErrors()) {                System.out.println("error = " + error.getMsg() + ": " + error.getDetail());            }            assertEquals(0, report.getProcessingErrors().size());            assertEquals(1, report.getViolations().size());        }    }    public static class TestRule extends AbstractRule {        public TestRule() {            setLanguage(Dummy2LanguageModule.getInstance());            setMessage("dummy 2 test rule");        }        @Override        public void apply(Node node, RuleContext ctx) {            ctx.addViolation(node);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.PmdCoreTestUtils.setDummyLanguage;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertSame;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Random;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;class RuleViolationComparatorTest {    @Test    void testComparator() {        Rule rule1 = setDummyLanguage(new MockRule("name1", "desc", "msg", "rulesetname1"));        Rule rule2 = setDummyLanguage(new MockRule("name2", "desc", "msg", "rulesetname2"));        // RuleViolations created in pre-sorted order        RuleViolation[] expectedOrder = new RuleViolation[12];        int index = 0;        // Different begin line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 20, "desc1", 1, 20, 80);        // Different description        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc2", 1, 20, 80);        // Different begin column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 10, 20, 80);        // Different end line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 1, 30, 80);        // Different end column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 1, 20, 90);        // Different rule name        expectedOrder[index++] = createJavaRuleViolation(rule1, "file6", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule2, "file6", 10, "desc1", 1, 20, 80);        // Randomize        List<RuleViolation> ruleViolations = new ArrayList<>(Arrays.asList(expectedOrder));        long seed = System.nanoTime();        Random random = new Random(seed);        Collections.shuffle(ruleViolations, random);        // Sort        Collections.sort(ruleViolations, RuleViolation.DEFAULT_COMPARATOR);        // Check        int count = 0;        for (int i = 0; i < expectedOrder.length; i++) {            count++;            assertSame(expectedOrder[i], ruleViolations.get(i), "Wrong RuleViolation " + i + ", used seed: " + seed);        }        assertEquals(expectedOrder.length, count, "Missing assertion for every RuleViolation");    }    private RuleViolation createJavaRuleViolation(Rule rule, String fileName, int beginLine, String description,            int beginColumn, int endLine, int endColumn) {        FileLocation loc = FileLocation.range(fileName, TextRange2d.range2d(beginLine, beginColumn, endLine, endColumn));        return new ParametricRuleViolation(rule, loc, description);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyLanguage;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;class RuleReferenceTest {    @Test    void testRuleSetReference() {        RuleReference ruleReference = new RuleReference();        RuleSetReference ruleSetReference = new RuleSetReference("somename");        ruleReference.setRuleSetReference(ruleSetReference);        assertEquals(ruleSetReference, ruleReference.getRuleSetReference(), "Not same rule set reference");    }    @Test    void testOverride() {        final PropertyDescriptor<String> PROPERTY1_DESCRIPTOR = PropertyFactory.stringProperty("property1").desc("Test property").defaultValue("").build();        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        Language dummyLang = dummyLanguage();        rule.setLanguage(dummyLang);        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final PropertyDescriptor<String> PROPERTY2_DESCRIPTOR = PropertyFactory.stringProperty("property2").desc("Test property").defaultValue("").build();        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setMinimumLanguageVersion(dummyLang.getVersion("1.3"));        ruleReference.setMaximumLanguageVersion(dummyLang.getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverriddenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, ruleReference);    }    @Test    void testLanguageOverrideDisallowed() {        MockRule rule = new MockRule();        Language dummyLang = dummyLanguage();        rule.setLanguage(dummyLang);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        assertThrows(UnsupportedOperationException.class, () -> ruleReference.setLanguage(Dummy2LanguageModule.getInstance()));        assertEquals(dummyLang, ruleReference.getLanguage());        assertThrows(IllegalArgumentException.class, () -> ruleReference.setMaximumLanguageVersion(Dummy2LanguageModule.getInstance().getVersion("1.0")));        assertEquals(rule.getMaximumLanguageVersion(), ruleReference.getOverriddenMaximumLanguageVersion());        assertThrows(IllegalArgumentException.class, () -> ruleReference.setMinimumLanguageVersion(Dummy2LanguageModule.getInstance().getVersion("1.0")));        assertEquals(rule.getMinimumLanguageVersion(), ruleReference.getMinimumLanguageVersion());    }    @Test    void testDeepCopyOverride() {        final PropertyDescriptor<String> PROPERTY1_DESCRIPTOR = PropertyFactory.stringProperty("property1").desc("Test property").defaultValue("").build();        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        Language dummyLang = dummyLanguage();        rule.setLanguage(dummyLang);        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final PropertyDescriptor<String> PROPERTY2_DESCRIPTOR = PropertyFactory.stringProperty("property2").desc("Test property").defaultValue("").build();        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setLanguage(dummyLang);        ruleReference.setMinimumLanguageVersion(dummyLang.getVersion("1.3"));        ruleReference.setMaximumLanguageVersion(dummyLang.getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverriddenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, (RuleReference) ruleReference.deepCopy());    }    private void validateOverriddenValues(final PropertyDescriptor<String> propertyDescriptor1,            final PropertyDescriptor<String> propertyDescriptor2, RuleReference ruleReference) {        assertEquals(dummyLanguage(), ruleReference.getLanguage(),                     "Override failed");        assertEquals(dummyLanguage().getVersion("1.3"), ruleReference.getMinimumLanguageVersion(),                     "Override failed");        assertEquals(dummyLanguage().getVersion("1.3"), ruleReference.getOverriddenMinimumLanguageVersion(),                     "Override failed");        assertEquals(dummyLanguage().getVersion("1.7"), ruleReference.getMaximumLanguageVersion(),                     "Override failed");        assertEquals(dummyLanguage().getVersion("1.7"), ruleReference.getOverriddenMaximumLanguageVersion(),                     "Override failed");        assertEquals(false, ruleReference.getRule().isDeprecated(), "Override failed");        assertEquals(true, ruleReference.isDeprecated(), "Override failed");        assertEquals(true, ruleReference.isOverriddenDeprecated(), "Override failed");        assertEquals("name2", ruleReference.getName(), "Override failed");        assertEquals("name2", ruleReference.getOverriddenName(), "Override failed");        assertEquals("value2", ruleReference.getProperty(propertyDescriptor1), "Override failed");        assertEquals("value3", ruleReference.getProperty(propertyDescriptor2), "Override failed");        assertTrue(ruleReference.getPropertyDescriptors().contains(propertyDescriptor1), "Override failed");        assertTrue(ruleReference.getPropertyDescriptors().contains(propertyDescriptor2), "Override failed");        assertFalse(ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor1), "Override failed");        assertTrue(ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor2), "Override failed");        assertTrue(ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1),                "Override failed");        assertTrue(ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2),                "Override failed");        assertTrue(ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1),                "Override failed");        assertTrue(ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2),                "Override failed");        assertEquals("message2", ruleReference.getMessage(), "Override failed");        assertEquals("message2", ruleReference.getOverriddenMessage(), "Override failed");        assertEquals("description2", ruleReference.getDescription(), "Override failed");        assertEquals("description2", ruleReference.getOverriddenDescription(), "Override failed");        assertEquals(2, ruleReference.getExamples().size(), "Override failed");        assertEquals("example1", ruleReference.getExamples().get(0), "Override failed");        assertEquals("example2", ruleReference.getExamples().get(1), "Override failed");        assertEquals("example2", ruleReference.getOverriddenExamples().get(0), "Override failed");        assertEquals("externalInfoUrl2", ruleReference.getExternalInfoUrl(), "Override failed");        assertEquals("externalInfoUrl2", ruleReference.getOverriddenExternalInfoUrl(), "Override failed");        assertEquals(RulePriority.MEDIUM_HIGH, ruleReference.getPriority(), "Override failed");        assertEquals(RulePriority.MEDIUM_HIGH, ruleReference.getOverriddenPriority(), "Override failed");    }    @Test    void testNotOverride() {        final PropertyDescriptor<String> PROPERTY1_DESCRIPTOR = PropertyFactory.stringProperty("property1").desc("Test property").defaultValue("").build();        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(dummyLanguage());        rule.setMinimumLanguageVersion(dummyLanguage().getVersion("1.3"));        rule.setMaximumLanguageVersion(dummyLanguage().getVersion("1.7"));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference            .setMinimumLanguageVersion(dummyLanguage().getVersion("1.3"));        ruleReference            .setMaximumLanguageVersion(dummyLanguage().getVersion("1.7"));        ruleReference.setDeprecated(false);        ruleReference.setName("name1");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value1");        ruleReference.setMessage("message1");        ruleReference.setDescription("description1");        ruleReference.addExample("example1");        ruleReference.setExternalInfoUrl("externalInfoUrl1");        ruleReference.setPriority(RulePriority.HIGH);        assertEquals(dummyLanguage().getVersion("1.3"), ruleReference.getMinimumLanguageVersion(),                     "Override failed");        assertNull(ruleReference.getOverriddenMinimumLanguageVersion(), "Override failed");        assertEquals(dummyLanguage().getVersion("1.7"), ruleReference.getMaximumLanguageVersion(),                     "Override failed");        assertNull(ruleReference.getOverriddenMaximumLanguageVersion(), "Override failed");        assertEquals(false, ruleReference.isDeprecated(), "Override failed");        assertNull(ruleReference.isOverriddenDeprecated(), "Override failed");        assertEquals("name1", ruleReference.getName(), "Override failed");        assertNull(ruleReference.getOverriddenName(), "Override failed");        assertEquals("value1", ruleReference.getProperty(PROPERTY1_DESCRIPTOR), "Override failed");        assertEquals("message1", ruleReference.getMessage(), "Override failed");        assertNull(ruleReference.getOverriddenMessage(), "Override failed");        assertEquals("description1", ruleReference.getDescription(), "Override failed");        assertNull(ruleReference.getOverriddenDescription(), "Override failed");        assertEquals(1, ruleReference.getExamples().size(), "Override failed");        assertEquals("example1", ruleReference.getExamples().get(0), "Override failed");        assertNull(ruleReference.getOverriddenExamples(), "Override failed");        assertEquals("externalInfoUrl1", ruleReference.getExternalInfoUrl(), "Override failed");        assertNull(ruleReference.getOverriddenExternalInfoUrl(), "Override failed");        assertEquals(RulePriority.HIGH, ruleReference.getPriority(), "Override failed");        assertNull(ruleReference.getOverriddenPriority(), "Override failed");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ByteArrayOutputStream;import java.util.Random;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.rule.RuleReference;/** * Unit test for {@link RuleSetWriter}. * */class RuleSetWriterTest {    private ByteArrayOutputStream out;    private RuleSetWriter writer;    /**     * Prepare the output stream.     */    @BeforeEach    void setupOutputStream() {        out = new ByteArrayOutputStream();        writer = new RuleSetWriter(out);    }    /**     * Closes the output stream at the end.     */    @AfterEach    void cleanupStream() {        if (writer != null) {            writer.close();        }    }    /**     * Tests the exclude rule behavior. See bug #945.     *     * @throws Exception     *             any error     */    @Test    void testWrite() throws Exception {        RuleSet braces = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/TestRuleset1.xml");        RuleSet ruleSet = new RuleSetBuilder(new Random().nextLong())                .withName("ruleset")                .withDescription("ruleset description")                .addRuleSetByReference(braces, true, "MockRule2")                .build();        writer.write(ruleSet);        String written = out.toString("UTF-8");        assertTrue(written.contains("<exclude name=\"MockRule2\""));    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     * @throws Exception     *             any error     */    @Test    void testRuleReferenceOverriddenName() throws Exception {        RuleSet rs = new RuleSetLoader().loadFromResource("rulesets/dummy/basic.xml");        RuleReference ruleRef = new RuleReference();        ruleRef.setRule(rs.getRuleByName("DummyBasicMockRule"));        ruleRef.setRuleSetReference(new RuleSetReference("rulesets/dummy/basic.xml"));        ruleRef.setName("Foo"); // override the name        RuleSet ruleSet = RuleSet.forSingleRule(ruleRef);        writer.write(ruleSet);        String written = out.toString("UTF-8");        assertTrue(written.contains("ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\""));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import java.util.Collections;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report.SuppressedViolation;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;public class AbstractRuleTest {    public static class MyRule extends AbstractRule {        private static final PropertyDescriptor<String> FOO_PROPERTY = PropertyFactory.stringProperty("foo").desc("foo property").defaultValue("x").build();        private static final PropertyDescriptor<String> FOO_DEFAULT_PROPERTY = PropertyFactory.stringProperty("fooDefault")                .defaultValue("bar")                .desc("Property without value uses default value")                .build();        private static final PropertyDescriptor<String> XPATH_PROPERTY = PropertyFactory.stringProperty("xpath").desc("xpath property").defaultValue("").build();        public MyRule() {            definePropertyDescriptor(FOO_PROPERTY);            definePropertyDescriptor(XPATH_PROPERTY);            definePropertyDescriptor(FOO_DEFAULT_PROPERTY);            setName("MyRule");            setMessage("my rule msg");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(Node target, RuleContext ctx) {        }    }    private static class MyOtherRule extends AbstractRule {        private static final PropertyDescriptor<String> FOO_PROPERTY = PropertyFactory.stringProperty("foo").desc("foo property").defaultValue("x").build();        MyOtherRule() {            definePropertyDescriptor(FOO_PROPERTY);            setName("MyOtherRule");            setMessage("my other rule");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(Node target, RuleContext ctx) {        }    }    @Test    void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        DummyRootNode s = DummyLanguageModule.parse("abc()", "filename");        RuleViolation rv = new ParametricRuleViolation(r, s, r.getMessage());        assertEquals(1, rv.getBeginLine(), "Line number mismatch!");        assertEquals("filename", rv.getFilename(), "Filename mismatch!");        assertEquals(r, rv.getRule(), "Rule object mismatch!");        assertEquals("my rule msg", rv.getDescription(), "Rule msg mismatch!");        assertEquals("foo", rv.getRule().getRuleSetName(), "RuleSet name mismatch!");    }    @Test    void testCreateRV2() {        MyRule r = new MyRule();        DummyRootNode s = DummyLanguageModule.parse("abc()", "filename");        RuleViolation rv = new ParametricRuleViolation(r, s, "specificdescription");        assertEquals(1, rv.getBeginLine(), "Line number mismatch!");        assertEquals("filename", rv.getFilename(), "Filename mismatch!");        assertEquals(r, rv.getRule(), "Rule object mismatch!");        assertEquals("specificdescription", rv.getDescription(), "Rule description mismatch!");    }    @Test    void testRuleWithVariableInMessage() {        MyRule r = new MyRule() {            @Override            public void apply(Node target, RuleContext ctx) {                ctx.addViolation(target);            }        };        r.definePropertyDescriptor(PropertyFactory.intProperty("testInt").desc("description").require(inRange(0, 100)).defaultValue(10).build());        r.setMessage("Message ${packageName} ${className} ${methodName} ${variableName} ${testInt} ${noSuchProperty}");        DummyRootNode s = DummyLanguageModule.parse("abc()", "filename");        RuleViolation rv = RuleContextTest.getReportForRuleApply(r, s).getViolations().get(0);        assertEquals("Message foo    10 ${noSuchProperty}", rv.getDescription());    }    @Test    void testRuleSuppress() {        DummyRootNode n = DummyLanguageModule.parse("abc()", "filename")            .withNoPmdComments(Collections.singletonMap(1, "ohio"));        RuleViolation violation = DefaultRuleViolationFactory.defaultInstance().createViolation(new MyRule(), n, n.getReportLocation(), "specificdescription");        SuppressedViolation suppressed = DefaultRuleViolationFactory.defaultInstance().suppressOrNull(n, violation);        assertNotNull(suppressed);    }    @Test    void testEquals1() {        MyRule r = new MyRule();        assertFalse(r.equals(null), "A rule is never equals to null!");    }    @Test    void testEquals2() {        MyRule r = new MyRule();        assertEquals(r, r, "A rule must be equals to itself");    }    @Test    void testEquals3() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        assertEquals(r1, r2, "Two instances of the same rule are equal");        assertEquals(r1.hashCode(), r2.hashCode(), "Hashcode for two instances of the same rule must be equal");    }    @Test    void testEquals4() {        MyRule myRule = new MyRule();        assertFalse(myRule.equals("MyRule"), "A rule cannot be equal to an object of another class");    }    @Test    void testEquals5() {        MyRule myRule = new MyRule();        MyOtherRule myOtherRule = new MyOtherRule();        assertFalse(myRule.equals(myOtherRule), "Two rules from different classes cannot be equal");    }    @Test    void testEquals6() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setName("MyRule2");        assertFalse(r1.equals(r2), "Rules with different names cannot be equal");    }    @Test    void testEquals7() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setPriority(RulePriority.HIGH);        assertFalse(r1.equals(r2), "Rules with different priority levels cannot be equal");    }    @Test    void testEquals8() {        MyRule r1 = new MyRule();        r1.setProperty(MyRule.XPATH_PROPERTY, "something");        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse(r1.equals(r2), "Rules with different properties values cannot be equal");    }    @Test    void testEquals9() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse(r1.equals(r2), "Rules with different properties cannot be equal");    }    @Test    void testEquals10() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setMessage("another message");        assertEquals(r1, r2, "Rules with different messages are still equal");        assertEquals(r1.hashCode(), r2.hashCode(), "Rules that are equal must have the an equal hashcode");    }    @Test    void testDeepCopyRule() {        MyRule r1 = new MyRule();        MyRule r2 = (MyRule) r1.deepCopy();        assertEquals(r1.getDescription(), r2.getDescription());        assertEquals(r1.getExamples(), r2.getExamples());        assertEquals(r1.getExternalInfoUrl(), r2.getExternalInfoUrl());        assertEquals(r1.getLanguage(), r2.getLanguage());        assertEquals(r1.getMaximumLanguageVersion(), r2.getMaximumLanguageVersion());        assertEquals(r1.getMessage(), r2.getMessage());        assertEquals(r1.getMinimumLanguageVersion(), r2.getMinimumLanguageVersion());        assertEquals(r1.getName(), r2.getName());        assertEquals(r1.getPriority(), r2.getPriority());        assertEquals(r1.getPropertyDescriptors(), r2.getPropertyDescriptors());        assertEquals(r1.getRuleClass(), r2.getRuleClass());        assertEquals(r1.getRuleSetName(), r2.getRuleSetName());        assertEquals(r1.getSince(), r2.getSince());        assertEquals(r1.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY),                r2.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;import static com.github.tomakehurst.wiremock.client.WireMock.findAll;import static com.github.tomakehurst.wiremock.client.WireMock.get;import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.head;import static com.github.tomakehurst.wiremock.client.WireMock.headRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;import static com.github.tomakehurst.wiremock.client.WireMock.verify;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.util.IOUtil;import net.sourceforge.pmd.util.ResourceLoader;import com.github.tomakehurst.wiremock.junit5.WireMockRuntimeInfo;import com.github.tomakehurst.wiremock.junit5.WireMockTest;@WireMockTestclass RuleSetReferenceIdTest {    private static void assertRuleSetReferenceId(final boolean expectedExternal, final String expectedRuleSetFileName,            final boolean expectedAllRules, final String expectedRuleName, final String expectedToString,            final RuleSetReferenceId reference) {        assertEquals(expectedExternal, reference.isExternal(), "Wrong external");        assertEquals(expectedRuleSetFileName, reference.getRuleSetFileName(), "Wrong RuleSet file name");        assertEquals(expectedAllRules, reference.isAllRules(), "Wrong all Rule reference");        assertEquals(expectedRuleName, reference.getRuleName(), "Wrong Rule name");        assertEquals(expectedToString, reference.toString(), "Wrong toString()");    }    @Test    void testCommaInSingleId() {        assertThrows(IllegalArgumentException.class, () -> new RuleSetReferenceId("bad,id"));    }    @Test    void testInternalWithInternal() {        assertThrows(IllegalArgumentException.class, () ->            new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("SomeOtherRule")));    }    @Test    void testExternalWithExternal() {        assertThrows(IllegalArgumentException.class, () ->            new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule")));    }    @Test    void testExternalWithInternal() {        assertThrows(IllegalArgumentException.class, () ->            new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("SomeOtherRule")));    }    @Test    void testInteralWithExternal() {        // This is okay        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test    void testEmptyRuleSet() {        // This is representative of how the Test framework creates        // RuleSetReferenceId from static RuleSet XMLs        RuleSetReferenceId reference = new RuleSetReferenceId(null);        assertRuleSetReferenceId(true, null, true, null, "anonymous all Rule", reference);    }    @Test    void testInternalWithExternalRuleSet() {        // This is representative of how the RuleSetFactory temporarily pairs an        // internal reference        // with an external reference.        RuleSetReferenceId internalRuleSetReferenceId = new RuleSetReferenceId("MockRuleName");        assertRuleSetReferenceId(false, null, false, "MockRuleName", "MockRuleName", internalRuleSetReferenceId);        RuleSetReferenceId externalRuleSetReferenceId = new RuleSetReferenceId("rulesets/java/basic.xml");        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                externalRuleSetReferenceId);        RuleSetReferenceId pairRuleSetReferenceId = new RuleSetReferenceId("MockRuleName", externalRuleSetReferenceId);        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "MockRuleName",                "rulesets/java/basic.xml/MockRuleName", pairRuleSetReferenceId);    }    @Test    void testConstructorGivenHttpUrlIdSucceedsAndProcessesIdCorrectly() {        final String sonarRulesetUrlId = "http://localhost:54321/profiles/export?format=pmd&language=java&name=Sonar%2520way";        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + sonarRulesetUrlId + "  ");        assertRuleSetReferenceId(true, sonarRulesetUrlId, true, null, sonarRulesetUrlId, ruleSetReferenceId);    }    @Test    void testConstructorGivenHttpUrlInputStream(WireMockRuntimeInfo wmRuntimeInfo) throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String rulesetUrl = "http://localhost:" + wmRuntimeInfo.getHttpPort() + path;        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200)));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody("xyz")));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + rulesetUrl + "  ");        assertRuleSetReferenceId(true, rulesetUrl, true, null, rulesetUrl, ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtil.readToString(inputStream, StandardCharsets.UTF_8);            assertEquals("xyz", loaded);        }        verify(1, headRequestedFor(urlEqualTo(path)));        verify(0, headRequestedFor(urlEqualTo("/profiles")));        verify(1, getRequestedFor(urlEqualTo(path)));        assertEquals(1, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    void testConstructorGivenHttpUrlSingleRuleInputStream(WireMockRuntimeInfo wmRuntimeInfo) throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String completePath = path + "/DummyBasicMockRule";        String hostpart = "http://localhost:" + wmRuntimeInfo.getHttpPort();        String basicRuleSet = IOUtil                .readToString(RuleSetReferenceId.class.getResourceAsStream("/rulesets/dummy/basic.xml"), StandardCharsets.UTF_8);        stubFor(head(urlEqualTo(completePath)).willReturn(aResponse().withStatus(404)));        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml")));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody(basicRuleSet)));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + hostpart + completePath + "  ");        assertRuleSetReferenceId(true, hostpart + path, false, "DummyBasicMockRule", hostpart + completePath,                ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtil.readToString(inputStream, StandardCharsets.UTF_8);            assertEquals(basicRuleSet, loaded);        }        verify(1, headRequestedFor(urlEqualTo(completePath)));        verify(1, headRequestedFor(urlEqualTo(path)));        verify(1, getRequestedFor(urlEqualTo(path)));        verify(0, getRequestedFor(urlEqualTo(completePath)));        assertEquals(2, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    void testOneSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));    }    @Test    void testMultipleSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-unusedcode,dummy-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(1));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1201/     */    @Test    void testMultipleRulesWithSpaces() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic, dummy-unusedcode, dummy2-basic");        assertEquals(3, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(1));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(2));    }    @Test    void testOneReleaseRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("50");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/releases/50.xml", true, null, "rulesets/releases/50.xml",                references.get(0));    }    @Test    void testOneFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));    }    @Test    void testOneFullRuleSetURL() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("file://somepath/rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", true, null,                "file://somepath/rulesets/java/unusedcode.xml", references.get(0));    }    @Test    void testMultipleFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("rulesets/java/unusedcode.xml,rulesets/java/basic.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                references.get(1));    }    @Test    void testMixRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/dummy/unusedcode.xml,dummy2-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(1));    }    @Test    void testUnknownRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("nonexistant.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(0));    }    @Test    void testUnknownAndSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic,nonexistant.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(1));    }    @Test    void testSimpleRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic/DummyBasicMockRule");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", false, "DummyBasicMockRule",                "rulesets/dummy/basic.xml/DummyBasicMockRule", references.get(0));    }    @Test    void testFullRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/basic.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "EmptyCatchBlock",                "rulesets/java/basic.xml/EmptyCatchBlock", references.get(0));    }    @Test    void testFullRuleSetURLAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", false, "EmptyCatchBlock",                "file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock", references.get(0));    }    @Test    void testInternalRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(false, null, false, "EmptyCatchBlock", "EmptyCatchBlock", references.get(0));    }    @Test    void testRelativePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "pmd/pmd-ruleset.xml", true, null, "pmd/pmd-ruleset.xml", references.get(0));    }    @Test    void testAbsolutePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("/home/foo/pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "/home/foo/pmd/pmd-ruleset.xml", true, null, "/home/foo/pmd/pmd-ruleset.xml",                references.get(0));    }    @Test    void testFooRules() throws Exception {        String fooRulesFile = new File("./src/test/resources/net/sourceforge/pmd/rulesets/foo-project/foo-rules")                .getCanonicalPath();        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(fooRulesFile);        assertEquals(1, references.size());        assertRuleSetReferenceId(true, fooRulesFile, true, null, fooRulesFile, references.get(0));    }    @Test    void testNullRulesetString() throws Exception {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(null);        assertTrue(references.isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyLanguage;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyLanguage2;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyVersion;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.CoreMatchers.instanceOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.hasSize;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNotSame;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.nio.charset.Charset;import java.nio.file.Paths;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.Set;import java.util.regex.Pattern;import java.util.stream.Collectors;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.lang.rule.RuleTargetSelector;import net.sourceforge.pmd.util.IOUtil;class RuleSetTest {    @Test    void testRuleSetRequiresName() {        assertThrows(NullPointerException.class, () ->            new RuleSetBuilder(new Random().nextLong())                .withName(null));    }    @Test    void testRuleSetRequiresDescription() {        assertThrows(NullPointerException.class, () ->            new RuleSetBuilder(new Random().nextLong())                .withName("some name")                .withDescription(null));    }    @Test    void testRuleSetRequiresName2() {        assertThrows(NullPointerException.class, () ->            new RuleSetBuilder(new Random().nextLong()).build());    }    @Test    void testAccessors() {        RuleSet rs = new RuleSetBuilder(new Random().nextLong())                .withFileName("baz")                .withName("foo")                .withDescription("bar")                .build();        assertEquals("baz", rs.getFileName(), "file name mismatch");        assertEquals("foo", rs.getName(), "name mismatch");        assertEquals("bar", rs.getDescription(), "description mismatch");    }    @Test    void testGetRuleByName() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = RuleSet.forSingleRule(mock);        assertEquals(mock, rs.getRuleByName("name"), "unable to fetch rule by name");    }    @Test    void testGetRuleByName2() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = RuleSet.forSingleRule(mock);        assertNull(rs.getRuleByName("FooRule"), "the rule FooRule must not be found!");    }    @Test    void testRuleList() {        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet ruleset = RuleSet.forSingleRule(rule);        assertEquals(1, ruleset.size(), "Size of RuleSet isn't one.");        Collection<Rule> rules = ruleset.getRules();        Iterator<Rule> i = rules.iterator();        assertTrue(i.hasNext(), "Empty Set");        assertEquals(1, rules.size(), "Returned set of wrong size.");        assertEquals(rule, i.next(), "Rule isn't in ruleset.");    }    private RuleSetBuilder createRuleSetBuilder(String name) {        return new RuleSetBuilder(new Random().nextLong())            .withName(name)            .withDescription("Description for " + name);    }    @Test    void testAddRuleSet() {        RuleSet set1 = createRuleSetBuilder("ruleset1")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        RuleSet set2 = createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSet(set1)                .build();        assertEquals(2, set2.size(), "ruleset size wrong");    }    @Test    void testAddRuleSetByReferenceBad() {        RuleSet set1 = createRuleSetBuilder("ruleset1")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        assertThrows(RuntimeException.class, () ->            createRuleSetBuilder("ruleset2")                    .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                    .addRuleSetByReference(set1, false)                    .build());    }    @Test    void testAddRuleSetByReferenceAllRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")            .withFileName("foo")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))            .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, true)                .build();        assertEquals(2, set1.getRules().size(), "wrong rule size");        for (Rule rule : set1.getRules()) {            assertTrue(rule instanceof RuleReference, "not a rule reference");            RuleReference ruleReference = (RuleReference) rule;            assertEquals("foo", ruleReference.getRuleSetReference().getRuleSetFileName(), "wrong ruleset file name");            assertTrue(ruleReference.getRuleSetReference().isAllRules(), "not all rule reference");        }    }    @Test    void testAddRuleSetByReferenceSingleRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")            .withFileName("foo")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))            .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, false)                .build();        assertEquals(2, set1.getRules().size(), "wrong rule size");        for (Rule rule : set1.getRules()) {            assertTrue(rule instanceof RuleReference, "not a rule reference");            RuleReference ruleReference = (RuleReference) rule;            assertEquals("foo", ruleReference.getRuleSetReference().getRuleSetFileName(), "wrong ruleset file name");            assertFalse(ruleReference.getRuleSetReference().isAllRules(), "should not be all rule reference");        }    }    @Test    void testApply0Rules() throws Exception {        RuleSet ruleset = createRuleSetBuilder("ruleset").build();        verifyRuleSet(ruleset, new HashSet<RuleViolation>());    }    @Test    void testEquals1() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertFalse(s.equals(null), "A ruleset cannot be equals to null");    }    @Test    @SuppressWarnings("PMD.UseAssertEqualsInsteadOfAssertTrue")    void testEquals2() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertTrue(s.equals(s), "A rulset must be equals to itself");    }    @Test    void testEquals3() {        RuleSet s = new RuleSetBuilder(new Random().nextLong())                .withName("basic rules")                .withDescription("desc")                .build();        assertFalse(s.equals("basic rules"), "A ruleset cannot be equals to another kind of object");    }    @Test    void testEquals4() {        RuleSet s1 = createRuleSetBuilder("my ruleset")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        assertEquals(s1, s2, "2 rulesets with same name and rules must be equals");        assertEquals(s1.hashCode(), s2.hashCode(), "Equals rulesets must have the same hashcode");    }    @Test    void testEquals5() {        RuleSet s1 = createRuleSetBuilder("my ruleset")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        RuleSet s2 = createRuleSetBuilder("my other ruleset")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        assertFalse(s1.equals(s2), "2 rulesets with different name but same rules must not be equals");    }    @Test    void testEquals6() {        RuleSet s1 = createRuleSetBuilder("my ruleset")            .addRule(new MockRule("name", "desc", "msg", "rulesetname"))            .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")            .addRule(new MockRule("other rule", "desc", "msg", "rulesetname"))            .build();        assertFalse(s1.equals(s2), "2 rulesets with same name but different rules must not be equals");    }    @Test    void testLanguageApplies() {        Rule rule = new MockRule();        assertFalse(RuleSet.applies(rule, dummyLanguage2().getDefaultVersion()),                "Different languages should not apply");        assertTrue(RuleSet.applies(rule, dummyLanguage().getVersion("1.5")),                "Same language with no min/max should apply");        rule.setMinimumLanguageVersion(dummyLanguage().getVersion("1.5"));        assertTrue(RuleSet.applies(rule, dummyLanguage().getVersion("1.5")),                "Same language with valid min only should apply");        rule.setMaximumLanguageVersion(dummyLanguage().getVersion("1.6"));        assertTrue(RuleSet.applies(rule, dummyLanguage().getVersion("1.5")),                "Same language with valid min and max should apply");        assertFalse(RuleSet.applies(rule, dummyLanguage().getVersion("1.4")),                "Same language with outside range of min/max should not apply");        assertFalse(RuleSet.applies(rule, dummyLanguage().getVersion("1.7")),                "Same language with outside range of min/max should not apply");    }    @Test    void testAddExcludePattern() {        RuleSet ruleSet =            createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull(ruleSet.getFileExclusions(), "Exclude patterns");        assertEquals(1, ruleSet.getFileExclusions().size(), "Invalid number of patterns");    }    @Test    void testExcludePatternAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(Pattern.compile(".*"))                .withFileExclusions(Pattern.compile(".*ha"))                .build();        assertEquals(Arrays.asList(".*", ".*ha"), toStrings(ruleSet2.getFileExclusions()), "Exclude pattern");    }    @Test    void testIncludePatternsAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")            .withFileInclusions(Pattern.compile(".*"))            .withFileInclusions(Arrays.asList(Pattern.compile(".*ha"), Pattern.compile(".*hb")))            .build();        assertEquals(Arrays.asList(".*", ".*ha", ".*hb"), toStrings(ruleSet2.getFileInclusions()), "Exclude pattern");    }    private List<String> toStrings(List<Pattern> strings) {        return strings.stream().map(Pattern::pattern).collect(Collectors.toList());    }    @Test    void testAddExcludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")            .withFileExclusions(Pattern.compile(".*"))            .build();        assertNotNull(ruleSet.getFileExclusions(), "Exclude patterns");        assertEquals(1, ruleSet.getFileExclusions().size(), "Invalid number of patterns");        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(ruleSet.getFileExclusions())                .build();        assertNotNull(ruleSet2.getFileExclusions(), "Exclude patterns");        assertEquals(1, ruleSet2.getFileExclusions().size(), "Invalid number of patterns");    }    @Test    void testSetExcludePatterns() {        List<Pattern> excludePatterns = new ArrayList<>();        excludePatterns.add(Pattern.compile("ah*"));        excludePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset").replaceFileExclusions(excludePatterns).build();        assertNotNull(ruleSet.getFileExclusions(), "Exclude patterns");        assertEquals(2, ruleSet.getFileExclusions().size(), "Invalid number of exclude patterns");        assertEquals("ah*", ruleSet.getFileExclusions().get(0).pattern(), "Exclude pattern");        assertEquals(".*", ruleSet.getFileExclusions().get(1).pattern(), "Exclude pattern");        assertNotNull(ruleSet.getFileInclusions(), "Include patterns");        assertEquals(0, ruleSet.getFileInclusions().size(), "Invalid number of include patterns");    }    @Test    void testAddIncludePattern() {        RuleSet ruleSet = createRuleSetBuilder("ruleset")                .withFileInclusions(Pattern.compile(".*"))                .build();        assertNotNull(ruleSet.getFileInclusions(), "Include patterns");        assertEquals(1, ruleSet.getFileInclusions().size(), "Invalid number of patterns");        assertEquals(".*", ruleSet.getFileInclusions().get(0).pattern(), "Include pattern");        assertNotNull(ruleSet.getFileExclusions(), "Exclude patterns");        assertEquals(0, ruleSet.getFileExclusions().size(), "Invalid number of exclude patterns");    }    @Test    void testAddIncludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")            .withFileInclusions(Pattern.compile("ah*"), Pattern.compile(".*"))            .build();        RuleSet ruleSet2 = createRuleSetBuilder("ruleset1")                .withFileInclusions(ruleSet.getFileInclusions())                .build();        assertNotNull(ruleSet2.getFileInclusions(), "Include patterns");        assertEquals(2, ruleSet2.getFileInclusions().size(), "Invalid number of patterns");        assertEquals("ah*", ruleSet2.getFileInclusions().get(0).pattern(), "Include pattern");        assertEquals(".*", ruleSet2.getFileInclusions().get(1).pattern(), "Include pattern");        assertNotNull(ruleSet.getFileExclusions(), "Exclude patterns");        assertEquals(0, ruleSet.getFileExclusions().size(), "Invalid number of exclude patterns");    }    @Test    void testSetIncludePatterns() {        List<Pattern> includePatterns = new ArrayList<>();        includePatterns.add(Pattern.compile("ah*"));        includePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset")            .replaceFileInclusions(includePatterns)            .build();        assertEquals(includePatterns, ruleSet.getFileInclusions(), "Include patterns");        assertNotNull(ruleSet.getFileInclusions(), "Exclude patterns");        assertEquals(0, ruleSet.getFileExclusions().size(), "Invalid number of exclude patterns");    }    @Test    void testIncludeExcludeApplies() {        TextFile file = TextFile.forPath(Paths.get("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java"), Charset.defaultCharset(), dummyVersion());        RuleSet ruleSet = createRuleSetBuilder("ruleset").build();        assertTrue(ruleSet.applies(file), "No patterns");        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .build();        assertTrue(ruleSet.applies(file), "Non-matching exclude");        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"), Pattern.compile(".*/package/.*"))                .build();        assertFalse(ruleSet.applies(file), "Matching exclude");        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .build();        assertFalse(ruleSet.applies(file), "Non-matching include");        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .withFileInclusions(Pattern.compile(".*/random/.*"))                .build();        assertTrue(ruleSet.applies(file), "Matching include");    }    @Test    void testIncludeExcludeMultipleRuleSetWithRuleChainApplies() throws Exception {        Rule rule = new FooRule();        rule.setName("FooRule1");        rule.setLanguage(dummyLanguage());        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1").addRule(rule).build();        RuleSet ruleSet2 = createRuleSetBuilder("RuleSet2").addRule(rule).build();        RuleSets ruleSets = new RuleSets(listOf(ruleSet1, ruleSet2));        // Two violations        Report report = Report.buildReport(ctx1 -> ruleSets.apply(makeCompilationUnits(), ctx1));        assertEquals(2, report.getViolations().size(), "Violations");        // One violation        ruleSet1 = createRuleSetBuilder("RuleSet1")            .withFileExclusions(Pattern.compile(".*/package/.*"))            .addRule(rule)            .build();        RuleSets ruleSets2 = new RuleSets(listOf(ruleSet1, ruleSet2));        report = Report.buildReport(ctx -> ruleSets2.apply(makeCompilationUnits("C:\\package\\RandomClass.java"), ctx));        assertEquals(1, report.getViolations().size(), "Violations");    }    @Test    void copyConstructorDeepCopies() {        Rule rule = new FooRule();        rule.setName("FooRule1");        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")            .addRule(rule)            .build();        RuleSet ruleSet2 = new RuleSet(ruleSet1);        assertEquals(ruleSet1, ruleSet2);        assertNotSame(ruleSet1, ruleSet2);        assertEquals(rule, ruleSet2.getRuleByName("FooRule1"));        assertNotSame(rule, ruleSet2.getRuleByName("FooRule1"));    }    private void verifyRuleSet(RuleSet ruleset, Set<RuleViolation> expected) throws Exception {        Report report = RuleContextTest.getReportForRuleSetApply(ruleset, makeCompilationUnits());        assertEquals(expected.size(), report.getViolations().size(), "Invalid number of Violations Reported");        for (RuleViolation violation : report.getViolations()) {            assertTrue(expected.contains(violation), "Unexpected Violation Returned: " + violation);        }        for (RuleViolation violation : expected) {            assertTrue(report.getViolations().contains(violation), "Expected Violation not Returned: " + violation);        }    }    private RootNode makeCompilationUnits() {        return makeCompilationUnits("sampleFile.dummy");    }    private RootNode makeCompilationUnits(String filename) {        DummyRootNode node = DummyLanguageModule.parse("dummyCode", filename);        node.setImage("Foo");        return node;        //        DummyRootNode node = new DummyRootNode();        //        node.setCoordsReplaceText(1, 1, 2, 1);        //        node.setImage("Foo");        //        node.withFileName(filename);        //        return node;    }    @Test    void ruleExceptionShouldBeReported() throws Exception {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")            .addRule(new MockRule() {                @Override                public void apply(Node nodes, RuleContext ctx) {                    throw new IllegalStateException("Test exception while applying rule");                }            })            .build();        Report report = RuleContextTest.getReportForRuleSetApply(ruleset, makeCompilationUnits());        List<ProcessingError> errors = report.getProcessingErrors();        assertThat(errors, hasSize(1));        ProcessingError error = errors.get(0);        assertThat(error.getMsg(), containsString("java.lang.IllegalStateException: Test exception while applying rule\n"));        assertThat(error.getMsg(), containsString("Rule applied on node=dummyRootNode[@Image=Foo]"));        assertThat(error.getError().getCause(), instanceOf(IllegalStateException.class));    }    @Test    void ruleExceptionShouldNotStopProcessingFile() throws Exception {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            @Override            public void apply(Node target, RuleContext ctx) {                throw new IllegalStateException("Test exception while applying rule");            }        }).addRule(new MockRule() {            @Override            public void apply(Node target, RuleContext ctx) {                addViolationWithMessage(ctx, target, "Test violation of the second rule in the ruleset");            }        }).build();        Report report = RuleContextTest.getReportForRuleSetApply(ruleset, makeCompilationUnits("samplefile.dummy"));        List<ProcessingError> errors = report.getProcessingErrors();        assertThat(errors, hasSize(1));        ProcessingError error = errors.get(0);        assertThat(error.getMsg(), containsString("java.lang.IllegalStateException: Test exception while applying rule\n"));        assertThat(error.getMsg(), containsString("Rule applied on node=dummyRootNode[@Image=Foo]"));        assertThat(error.getError().getCause(), instanceOf(IllegalStateException.class));        assertThat(IOUtil.normalizePath(error.getFile()), equalTo("samplefile.dummy"));        assertThat(report.getViolations(), hasSize(1));    }    @Test    void ruleExceptionShouldNotStopProcessingFileWithRuleChain() throws Exception {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            @Override            protected @NonNull RuleTargetSelector buildTargetSelector() {                return RuleTargetSelector.forXPathNames(setOf("dummyRootNode"));            }            @Override            public void apply(Node target, RuleContext ctx) {                throw new UnsupportedOperationException("Test exception while applying rule");            }        }).addRule(new MockRule() {            @Override            protected @NonNull RuleTargetSelector buildTargetSelector() {                return RuleTargetSelector.forXPathNames(setOf("dummyRootNode"));            }            @Override            public void apply(Node target, RuleContext ctx) {                addViolationWithMessage(ctx, target, "Test violation of the second rule in the ruleset");            }        }).build();        Report report = RuleContextTest.getReportForRuleSetApply(ruleset, makeCompilationUnits());        List<ProcessingError> errors = report.getProcessingErrors();        assertThat(errors, hasSize(1));        ProcessingError error = errors.get(0);        assertThat(error.getMsg(), containsString("java.lang.UnsupportedOperationException: Test exception while applying rule\n"));        assertThat(error.getMsg(), containsString("Rule applied on node=dummyRootNode[@Image=Foo]"));        assertThat(error.getError().getCause(), instanceOf(UnsupportedOperationException.class));        assertThat(report.getViolations(), hasSize(1));    }    static class MockRule extends net.sourceforge.pmd.lang.rule.MockRule {        MockRule() {            super();            setLanguage(DummyLanguageModule.getInstance());        }        MockRule(String name, String description, String message, String ruleSetName, RulePriority priority) {            super(name, description, message, ruleSetName, priority);            setLanguage(DummyLanguageModule.getInstance());        }        MockRule(String name, String description, String message, String ruleSetName) {            super(name, description, message, ruleSetName);            setLanguage(DummyLanguageModule.getInstance());        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.StringWriter;import java.util.function.Consumer;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;import net.sourceforge.pmd.reporting.FileAnalysisListener;import net.sourceforge.pmd.reporting.GlobalAnalysisListener;public class ReportTest {    // Files are grouped together now.    @Test    void testSortedReportFile() {        Renderer rend = new XMLRenderer();        String result = render(rend, r -> {            FileLocation s = getNode(10, 5, "foo");            Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");            r.onRuleViolation(violation(rule1, s));            FileLocation s1 = getNode(10, 5, "bar");            Rule rule2 = new MockRule("name", "desc", "msg", "rulesetname");            r.onRuleViolation(violation(rule2, s1));        });        assertThat(result, containsString("bar"));        assertThat(result, containsString("foo"));        assertTrue(result.indexOf("bar") < result.indexOf("foo"), "sort order wrong");    }    @Test    void testSortedReportLine() {        Renderer rend = new XMLRenderer();        String result = render(rend, r -> {            FileLocation node1 = getNode(20, 5, "foo1"); // line 20: after rule2 violation            Rule rule1 = new MockRule("rule1", "rule1", "msg", "rulesetname");            r.onRuleViolation(violation(rule1, node1));            FileLocation node2 = getNode(10, 5, "foo1"); // line 10: before rule1 violation            Rule rule2 = new MockRule("rule2", "rule2", "msg", "rulesetname");            r.onRuleViolation(violation(rule2, node2)); // same file!!        });        assertTrue(result.indexOf("rule2") < result.indexOf("rule1"), "sort order wrong");    }    @Test    void testIterator() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        FileLocation loc1 = getNode(5, 5, "file1");        FileLocation loc2 = getNode(5, 6, "file1");        Report r = Report.buildReport(it -> {            it.onRuleViolation(violation(rule, loc1));            it.onRuleViolation(violation(rule, loc2));        });        assertEquals(2, r.getViolations().size());    }    @Test    void testFilterViolations() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        FileLocation loc1 = getNode(5, 5, "file1");        FileLocation loc2 = getNode(5, 6, "file1");        Report r = Report.buildReport(it -> {            it.onRuleViolation(violation(rule, loc1));            it.onRuleViolation(violation(rule, loc2, "to be filtered"));        });        Report filtered = r.filterViolations(ruleViolation -> !"to be filtered".equals(ruleViolation.getDescription()));        assertEquals(1, filtered.getViolations().size());        assertEquals("msg", filtered.getViolations().get(0).getDescription());    }    @Test    void testUnion() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        FileLocation loc1 = getNode(1, 2, "file1");        Report report1 = Report.buildReport(it -> it.onRuleViolation(violation(rule, loc1)));        FileLocation loc2 = getNode(2, 1, "file1");        Report report2 = Report.buildReport(it -> it.onRuleViolation(violation(rule, loc2)));        Report union = report1.union(report2);        assertEquals(2, union.getViolations().size());    }    private @NonNull RuleViolation violation(Rule rule, FileLocation loc2) {        return violation(rule, loc2, rule.getMessage());    }    private @NonNull RuleViolation violation(Rule rule, FileLocation loc1, String rule1) {        return new ParametricRuleViolation(rule, loc1, rule1);    }    private static FileLocation getNode(int line, int column, String filename) {        return FileLocation.range(filename, TextRange2d.range2d(line, column, line, column));    }    public static String render(Renderer renderer, Consumer<? super FileAnalysisListener> listenerEffects) {        return renderGlobal(renderer, globalListener -> {            LanguageVersion dummyVersion = DummyLanguageModule.getInstance().getDefaultVersion();            TextFile dummyFile = TextFile.forCharSeq("dummyText", "file", dummyVersion);            try (FileAnalysisListener fal = globalListener.startFileAnalysis(dummyFile)) {                listenerEffects.accept(fal);            } catch (Exception e) {                throw new AssertionError(e);            }        });    }    public static String renderGlobal(Renderer renderer, Consumer<? super GlobalAnalysisListener> listenerEffects) {        StringWriter writer = new StringWriter();        renderer.setWriter(writer);        try (GlobalAnalysisListener listener = renderer.newListener()) {            listenerEffects.accept(listener);        } catch (Exception e) {            throw new AssertionError(e);        }        return writer.toString();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import org.junit.jupiter.api.Test;import com.github.stefanbirkner.systemlambda.SystemLambda;public class RuleSetFactoryMessagesTest extends RulesetFactoryTestBase {    @Test    public void testFullMessage() throws Exception {        String log = SystemLambda.tapSystemErr(() -> assertCannotParse(            rulesetXml(                dummyRule(                    priority("not a priority")                )            )        ));        assertThat(log, containsString(            "Error at dummyRuleset.xml:9:1\n"                + " 7| \n"                + " 8| <rule name=\"MockRuleName\" language=\"dummy\" class=\"net.sourceforge.pmd.lang.rule.MockRule\" message=\"avoid the mock rule\">\n"                + " 9| <priority>not a priority</priority></rule></ruleset>\n"                + "    ^^^^^^^^^ Not a valid priority: 'not a priority', expected a number in [1,5]"        ));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import com.github.stefanbirkner.systemlambda.SystemLambda;class RuleSetFactoryDuplicatedRuleLoggingTest extends RulesetFactoryTestBase {    private static final String DIR = "net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest";    @Test    void duplicatedRuleReferenceShouldWarn() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet ruleset = loadRuleSetInDir(DIR, "duplicatedRuleReference.xml");            assertEquals(1, ruleset.getRules().size());            Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");            assertNotNull(mockRule);            assertEquals(RulePriority.MEDIUM, mockRule.getPriority());        });        assertThat(log, containsString(            "The rule DummyBasicMockRule is referenced multiple times in ruleset 'Custom Rules'. "                + "Only the last rule configuration is used"));    }    @Test    void duplicatedRuleReferenceWithOverrideShouldNotWarn() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet ruleset = loadRuleSetInDir(DIR, "duplicatedRuleReferenceWithOverride.xml");            assertEquals(2, ruleset.getRules().size());            Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");            assertNotNull(mockRule);            assertEquals(RulePriority.HIGH, mockRule.getPriority());            assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        });        assertTrue(log.isEmpty());    }    @Test    void duplicatedRuleReferenceWithOverrideBeforeShouldNotWarn() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet ruleset = loadRuleSetInDir(DIR, "duplicatedRuleReferenceWithOverrideBefore.xml");            assertEquals(2, ruleset.getRules().size());            Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");            assertNotNull(mockRule);            assertEquals(RulePriority.HIGH, mockRule.getPriority());            assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        });        assertTrue(log.isEmpty());    }    @Test    void multipleDuplicates() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet ruleset = loadRuleSetInDir(DIR, "multipleDuplicates.xml");            assertEquals(2, ruleset.getRules().size());            Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");            assertNotNull(mockRule);            assertEquals(RulePriority.MEDIUM_HIGH, mockRule.getPriority());            assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        });        assertThat(log, containsString("The rule DummyBasicMockRule is referenced multiple times in ruleset 'Custom Rules'. Only the last rule configuration is used."));        assertThat(log, containsString("The ruleset rulesets/dummy/basic.xml is referenced multiple times in ruleset 'Custom Rules'"));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.PmdCoreTestUtils.dummyLanguage;import static net.sourceforge.pmd.util.internal.xml.SchemaConstants.DEPRECATED;import static net.sourceforge.pmd.util.internal.xml.SchemaConstants.NAME;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNotSame;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.InputStream;import java.util.Arrays;import java.util.HashSet;import java.util.Set;import org.junit.jupiter.api.Test;import org.mockito.Mockito;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.ResourceLoader;import net.sourceforge.pmd.util.internal.xml.SchemaConstants;import com.github.stefanbirkner.systemlambda.SystemLambda;class RuleSetFactoryTest extends RulesetFactoryTestBase {    @Test    void testRuleSetFileName() {        RuleSet rs = new RuleSetLoader().loadFromString("dummyRuleset.xml", EMPTY_RULESET);        assertEquals("dummyRuleset.xml", rs.getFileName());        rs = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/TestRuleset1.xml");        assertEquals(rs.getFileName(), "net/sourceforge/pmd/TestRuleset1.xml", "wrong RuleSet file name");    }    @Test    void testRefs() {        RuleSet rs = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/TestRuleset1.xml");        assertNotNull(rs.getRuleByName("TestRuleRef"));    }    @Test    void testExtendedReferences() throws Exception {        InputStream in = new ResourceLoader().loadClassPathResourceAsStream("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        assertNotNull(in, "Test ruleset not found - can't continue with test!");        in.close();        RuleSet rs = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        // added by referencing a complete ruleset (TestRuleset1.xml)        assertNotNull(rs.getRuleByName("MockRule1"));        assertNotNull(rs.getRuleByName("MockRule2"));        assertNotNull(rs.getRuleByName("MockRule3"));        assertNotNull(rs.getRuleByName("TestRuleRef"));        // added by specific reference        assertNotNull(rs.getRuleByName("TestRule"));        // this is from TestRuleset2.xml, but not referenced        assertNull(rs.getRuleByName("TestRule2Ruleset2"));        Rule mockRule3 = rs.getRuleByName("MockRule3");        assertEquals("Overridden message", mockRule3.getMessage());        assertEquals(2, mockRule3.getPriority().getPriority());        Rule mockRule2 = rs.getRuleByName("MockRule2");        assertEquals("Just combine them!", mockRule2.getMessage());        // assert that MockRule2 is only once added to the ruleset, so that it        // really        // overwrites the configuration inherited from TestRuleset1.xml        assertNotNull(rs.getRuleByName("MockRule2"));        Rule mockRule1 = rs.getRuleByName("MockRule1");        assertNotNull(mockRule1);        PropertyDescriptor<?> prop = mockRule1.getPropertyDescriptor("testIntProperty");        Object property = mockRule1.getProperty(prop);        assertEquals("5", String.valueOf(property));        // included from TestRuleset3.xml        assertNotNull(rs.getRuleByName("Ruleset3Rule2"));        // excluded from TestRuleset3.xml        assertNull(rs.getRuleByName("Ruleset3Rule1"));        // overridden to 5        Rule ruleset4Rule1 = rs.getRuleByName("Ruleset4Rule1");        assertNotNull(ruleset4Rule1);        assertEquals(5, ruleset4Rule1.getPriority().getPriority());        assertNotNull(rs.getRuleByName("Ruleset4Rule1"));        // priority overridden for whole TestRuleset4 group        Rule ruleset4Rule2 = rs.getRuleByName("Ruleset4Rule2");        assertNotNull(ruleset4Rule2);        assertEquals(2, ruleset4Rule2.getPriority().getPriority());    }    @Test    void testRuleSetNotFound() {        assertThrows(RuleSetLoadException.class, () -> new RuleSetLoader().loadFromResource("fooooo"));    }    @Test    void testCreateEmptyRuleSet() {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertEquals("Custom ruleset", rs.getName());        assertEquals(0, rs.size());    }    @Test    void testSingleRule() {        RuleSet rs = loadRuleSet(SINGLE_RULE);        assertEquals(1, rs.size());        Rule r = rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("net.sourceforge.pmd.lang.rule.MockRule", r.getRuleClass());        assertEquals("avoid the mock rule", r.getMessage());    }    @Test    void testSingleRuleEmptyRef() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSet(SINGLE_RULE_EMPTY_REF);            assertEquals(1, rs.size());            Rule r = rs.getRules().iterator().next();            assertEquals("MockRuleName", r.getName());            assertEquals("net.sourceforge.pmd.lang.rule.MockRule", r.getRuleClass());            assertEquals("avoid the mock rule", r.getMessage());        });        assertThat(log, containsString("Empty ref attribute"));    }    @Test    void testMultipleRules() {        RuleSet rs = loadRuleSet(rulesetXml(            dummyRule(attrs -> attrs.put(NAME, "MockRuleName1")),            dummyRule(attrs -> attrs.put(NAME, "MockRuleName2"))        ));        assertEquals(2, rs.size());        Set<String> expected = new HashSet<>();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Rule rule : rs.getRules()) {            assertTrue(expected.contains(rule.getName()));        }    }    @Test    void testSingleRuleWithPriority() {        Rule rule = loadFirstRule(rulesetXml(            rule(                dummyRuleDefAttrs(),                priority("3")            )        ));        assertEquals(RulePriority.MEDIUM, rule.getPriority());    }    @Test    void testProps() {        Rule r = loadFirstRule(PROPERTIES);        assertEquals("bar", r.getProperty(r.getPropertyDescriptor("fooString")));        assertEquals(3, r.getProperty(r.getPropertyDescriptor("fooInt")));        assertEquals(true, r.getProperty(r.getPropertyDescriptor("fooBoolean")));        assertEquals(3.0d, (Double) r.getProperty(r.getPropertyDescriptor("fooDouble")), 0.05);        assertNull(r.getPropertyDescriptor("BuggleFish"));        assertNotSame(r.getDescription().indexOf("testdesc2"), -1);    }    @Test    void testStringMultiPropertyDefaultDelimiter() {        Rule r = loadFirstRule(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ruleset name=\"the ruleset\">\n  <description>Desc</description>\n"                + "     <rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s instead.\" \n"                + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                + " value=\"com.aptsssss|com.abc\" \ntype=\"List[String]\" "                + "description=\"valid packages\"/>\n         </properties></rule></ruleset>");        Object propValue = r.getProperty(r.getPropertyDescriptor("packageRegEx"));        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), propValue);    }    @Test    void testStringMultiPropertyDelimiter() {        Rule r = loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n "                + " <description>ruleset desc</description>\n     "                + "<rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s"                + " instead.\" \n"                + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                + " value=\"com.aptsssss,com.abc\" \ntype=\"List[String]\" delimiter=\",\" "                + "description=\"valid packages\"/>\n"                + "         </properties></rule>" + "</ruleset>");        Object propValue = r.getProperty(r.getPropertyDescriptor("packageRegEx"));        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), propValue);    }    @Test    void testRuleSetWithDeprecatedRule() {        RuleSet rs = loadRuleSet("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"ruleset\">\n"                                     + "  <description>ruleset desc</description>\n"                                     + "     <rule deprecated=\"true\" ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\"/>"                                     + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("DummyBasicMockRule");        assertNotNull(rule);    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole, we shouldn't get a deprecation warning. The deprecated     * rule reference should be ignored, so at the end, we only have the new rule name in the ruleset.     * This is because the deprecated reference points to a rule in the same ruleset.     *     */    @Test    void testRuleSetWithDeprecatedButRenamedRule() throws Exception {        SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                    + "  <description>ruleset desc</description>\n"                    + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                    + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                    + "         <description>d</description>\n" + "         <priority>2</priority>\n" + "     </rule>"                    + "</ruleset>");            assertEquals(1, rs.getRules().size());            Rule rule = rs.getRuleByName("NewName");            assertNotNull(rule);            assertNull(rs.getRuleByName("OldName"));        });        verifyNoWarnings();    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole for generating the documentation, we should still     * include the deprecated rule reference, so that we can create a nice documentation.     *     */    @Test    void testRuleSetWithDeprecatedRenamedRuleForDoc() {        RuleSetLoader loader = new RuleSetLoader().includeDeprecatedRuleReferences(true);        RuleSet rs = loader.loadFromString("",                                           "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                                               + "  <description>ruleset desc</description>\n"                                               + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                                               + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                                               + "         <description>d</description>\n"                                               + "         <priority>2</priority>\n"                                               + "     </rule>"                                               + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("NewName"));        assertNotNull(rs.getRuleByName("OldName"));    }    /**     * This is an example of a custom user ruleset, that references a rule, that has been renamed.     * The user should get a deprecation warning.     */    @Test    void testRuleSetReferencesADeprecatedRenamedRule() throws Exception {        SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                    + "  <description>ruleset desc</description>\n"                    + "     <rule ref=\"rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule\"/>" + "</ruleset>");            assertEquals(1, rs.getRules().size());            Rule rule = rs.getRuleByName("OldNameOfDummyBasicMockRule");            assertNotNull(rule);        });        verifyFoundAWarningWithMessage(            containing("Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule "                           + "instead of the deprecated Rule name rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule")        );    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Although the referenced ruleset contains     * a deprecated rule, there should be no warning about it, because all deprecated rules are ignored,     * if a whole ruleset is referenced.     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     */    @Test    void testRuleSetReferencesRulesetWithADeprecatedRenamedRule() throws Exception {        SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                    + "  <description>ruleset desc</description>\n"                    + "     <rule ref=\"rulesets/dummy/basic.xml\"/>" + "</ruleset>");            assertEquals(2, rs.getRules().size());            assertNotNull(rs.getRuleByName("DummyBasicMockRule"));            assertNotNull(rs.getRuleByName("SampleXPathRule"));        });        verifyNoWarnings();    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule. The deprecated     * rule is excluded.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Since the deprecated rule is excluded,     * there should be no deprecation warning at all, although the deprecated ruleset would have been     * excluded by default (without explictly excluding it).     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     */    @Test    void testRuleSetReferencesRulesetWithAExcludedDeprecatedRule() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                            + "  <description>ruleset desc</description>\n"                            + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"DeprecatedRule\"/></rule>"                            + "</ruleset>");            assertEquals(2, rs.getRules().size());            assertNotNull(rs.getRuleByName("DummyBasicMockRule"));            assertNotNull(rs.getRuleByName("SampleXPathRule"));        });        assertTrue(log.isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     * There is a exclusion of a rule, that no longer exists.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset.     * Since the rule to be excluded doesn't exist, there should be a warning about that.     *     */    @Test    void testRuleSetReferencesRulesetWithAExcludedNonExistingRule() throws Exception {        SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                rulesetXml(                    rulesetRef("rulesets/dummy/basic.xml",                               excludeRule("NonExistingRule"))                ));            assertEquals(2, rs.getRules().size());            assertNotNull(rs.getRuleByName("DummyBasicMockRule"));            assertNotNull(rs.getRuleByName("SampleXPathRule"));        });        verifyFoundWarningWithMessage(            Mockito.never(),            containing("Discontinue using Rule rulesets/dummy/basic.xml/DeprecatedRule")        );        verifyFoundAWarningWithMessage(containing(            "Exclude pattern 'NonExistingRule' did not match any rule in ruleset"        ));    }    /**     * When a custom ruleset references a ruleset that only contains deprecated rules, then this ruleset itself is     * considered deprecated and the user should get a deprecation warning for the ruleset.     */    @Test    void testRuleSetReferencesDeprecatedRuleset() throws Exception {        SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                rulesetXml(                    rulesetRef("rulesets/dummy/deprecated.xml")                ));            assertEquals(2, rs.getRules().size());            assertNotNull(rs.getRuleByName("DummyBasicMockRule"));            assertNotNull(rs.getRuleByName("SampleXPathRule"));        });        verifyFoundAWarningWithMessage(containing(            "The RuleSet rulesets/dummy/deprecated.xml has been deprecated and will be removed in PMD"        ));    }    /**     * When a custom ruleset references a ruleset that contains both rules and rule references, that are left     * for backwards compatibility, because the rules have been moved to a different ruleset, then there should be     * no warning about deprecation - since the deprecated rules are not used.     */    @Test    void testRuleSetReferencesRulesetWithAMovedRule() throws Exception {        SystemLambda.tapSystemErr(() -> {            RuleSet rs = loadRuleSetWithDeprecationWarnings(                rulesetXml(                    ruleRef("rulesets/dummy/basic2.xml")                )            );            assertEquals(1, rs.getRules().size());            assertNotNull(rs.getRuleByName("DummyBasic2MockRule"));        });        verifyFoundWarningWithMessage(            Mockito.never(),            containing("Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic2.xml/DummyBasicMockRule")        );    }    @Test    @SuppressWarnings("unchecked")    void testXPath() {        Rule r = loadFirstRule(XPATH);        PropertyDescriptor<String> xpathProperty = (PropertyDescriptor<String>) r.getPropertyDescriptor("xpath");        assertNotNull(xpathProperty, "xpath property descriptor");        assertNotSame(r.getProperty(xpathProperty).indexOf("//Block"), -1);    }    @Test    void testExternalReferenceOverride() {        Rule r = loadFirstRule(REF_OVERRIDE);        assertEquals("TestNameOverride", r.getName());        assertEquals("Test message override", r.getMessage());        assertEquals("Test description override", r.getDescription());        assertEquals(2, r.getExamples().size(), "Test that both example are stored");        assertEquals("Test example override", r.getExamples().get(1));        assertEquals(RulePriority.MEDIUM, r.getPriority());        PropertyDescriptor<?> test2Descriptor = r.getPropertyDescriptor("test2");        assertNotNull(test2Descriptor, "test2 descriptor");        assertEquals("override2", r.getProperty(test2Descriptor));        PropertyDescriptor<?> test3Descriptor = r.getPropertyDescriptor("test3");        assertNotNull(test3Descriptor, "test3 descriptor");        assertEquals("override3", r.getProperty(test3Descriptor));    }    @Test    void testExternalReferenceOverrideNonExistent() {        assertThrows(RuleSetLoadException.class,                     () -> loadFirstRule(REF_OVERRIDE_NONEXISTENT));        verifyFoundAnErrorWithMessage(            containing("Cannot set non-existent property 'test4' on rule TestNameOverride")        );    }    @Test    void testReferenceInternalToInternal() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull(rule, "Could not find Rule MockRuleName");        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull(ruleRef, "Could not find Rule MockRuleNameRef");    }    @Test    void testReferenceInternalToInternalChain() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull(rule, "Could not find Rule MockRuleName");        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull(ruleRef, "Could not find Rule MockRuleNameRef");        Rule ruleRefRef = ruleSet.getRuleByName("MockRuleNameRefRef");        assertNotNull(ruleRefRef, "Could not find Rule MockRuleNameRefRef");    }    @Test    void testReferenceInternalToExternal() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull(rule, "Could not find Rule ExternalRefRuleName");        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull(ruleRef, "Could not find Rule ExternalRefRuleNameRef");    }    @Test    void testReferenceInternalToExternalChain() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull(rule, "Could not find Rule ExternalRefRuleName");        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull(ruleRef, "Could not find Rule ExternalRefRuleNameRef");        Rule ruleRefRef = ruleSet.getRuleByName("ExternalRefRuleNameRefRef");        assertNotNull(ruleRefRef, "Could not find Rule ExternalRefRuleNameRefRef");    }    @Test    void testReferencePriority() {        RuleSetLoader config = new RuleSetLoader().warnDeprecated(false).enableCompatibility(true);        RuleSetLoader rulesetLoader = config.filterAbovePriority(RulePriority.LOW);        RuleSet ruleSet = rulesetLoader.loadFromString("", REF_INTERNAL_TO_INTERNAL_CHAIN);        assertEquals(3, ruleSet.getRules().size(), "Number of Rules");        assertNotNull(ruleSet.getRuleByName("MockRuleName"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rulesetLoader = config.filterAbovePriority(RulePriority.MEDIUM_HIGH);        ruleSet = rulesetLoader.loadFromString("", REF_INTERNAL_TO_INTERNAL_CHAIN);        assertEquals(2, ruleSet.getRules().size(), "Number of Rules");        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rulesetLoader = config.filterAbovePriority(RulePriority.HIGH);        ruleSet = rulesetLoader.loadFromString("", REF_INTERNAL_TO_INTERNAL_CHAIN);        assertEquals(1, ruleSet.getRules().size(), "Number of Rules");        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rulesetLoader = config.filterAbovePriority(RulePriority.LOW);        ruleSet = rulesetLoader.loadFromString("", REF_INTERNAL_TO_EXTERNAL_CHAIN);        assertEquals(3, ruleSet.getRules().size(), "Number of Rules");        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleName"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rulesetLoader = config.filterAbovePriority(RulePriority.MEDIUM_HIGH);        ruleSet = rulesetLoader.loadFromString("", REF_INTERNAL_TO_EXTERNAL_CHAIN);        assertEquals(2, ruleSet.getRules().size(), "Number of Rules");        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rulesetLoader = config.filterAbovePriority(RulePriority.HIGH);        ruleSet = rulesetLoader.loadFromString("", REF_INTERNAL_TO_EXTERNAL_CHAIN);        assertEquals(1, ruleSet.getRules().size(), "Number of Rules");        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));    }    @Test    void testOverridePriorityLoadWithMinimum() {        RuleSetLoader rulesetLoader = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_LOW)                .warnDeprecated(true).enableCompatibility(true);        RuleSet ruleset = rulesetLoader.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        // only one rule should remain, since we filter out the other rule by minimum priority        assertEquals(1, ruleset.getRules().size(), "Number of Rules");        // Priority is overridden and applied, rule is missing        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        // now, load with default minimum priority        rulesetLoader = new RuleSetLoader();        ruleset = rulesetLoader.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        assertEquals(2, ruleset.getRules().size(), "Number of Rules");        Rule dummyBasicMockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertEquals(RulePriority.LOW, dummyBasicMockRule.getPriority(), "Wrong Priority");    }    @Test    void testExcludeWithMinimumPriority() {        RuleSetLoader rulesetLoader = new RuleSetLoader().filterAbovePriority(RulePriority.HIGH);        RuleSet ruleset = rulesetLoader                .loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // no rules should be loaded        assertEquals(0, ruleset.getRules().size(), "Number of Rules");        // now, load with default minimum priority        rulesetLoader = new RuleSetLoader().filterAbovePriority(RulePriority.LOW);        ruleset = rulesetLoader.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // only one rule, we have excluded one...        assertEquals(1, ruleset.getRules().size(), "Number of Rules");        // rule is excluded        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));    }    @Test    void testOverrideMessage() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test    void testOverrideMessageOneElem() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test    void testIncorrectExternalRef() {        assertCannotParse(REF_MISSPELLED_XREF);    }    @Test    void testSetPriority() {        RuleSetLoader rulesetLoader = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_HIGH).warnDeprecated(false);        assertEquals(0, rulesetLoader.loadFromString("", SINGLE_RULE).size());        rulesetLoader = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_LOW).warnDeprecated(false);        assertEquals(1, rulesetLoader.loadFromString("", SINGLE_RULE).size());    }    @Test    void testLanguage() {        Rule r = loadFirstRule(rulesetXml(            dummyRule(                attrs -> attrs.put(SchemaConstants.LANGUAGE, "dummy")            )        ));        assertEquals(dummyLanguage(), r.getLanguage());    }    @Test    void testIncorrectLanguage() {        assertCannotParse(rulesetXml(            dummyRule(                attrs -> attrs.put(SchemaConstants.LANGUAGE, "bogus")            )        ));    }    @Test    void testIncorrectPriority() {        assertCannotParse(rulesetXml(            dummyRule(                priority("not a priority")            )        ));        verifyFoundAnErrorWithMessage(containing("Not a valid priority: 'not a priority'"));    }    @Test    void testMinimumLanguageVersion() {        Rule r = loadFirstRule(rulesetXml(            dummyRule(                attrs -> attrs.put(SchemaConstants.MINIMUM_LANGUAGE_VERSION, "1.4")            )        ));        assertEquals(dummyLanguage().getVersion("1.4"),                     r.getMinimumLanguageVersion());    }    @Test    void testIncorrectMinimumLanguageVersion() {        assertCannotParse(rulesetXml(            dummyRule(                attrs -> attrs.put(SchemaConstants.MINIMUM_LANGUAGE_VERSION, "bogus")            )        ));        verifyFoundAnErrorWithMessage(            containing("valid language version")                .and(containing("'1.0', '1.1', '1.2'")) // and not "dummy 1.0, dummy 1.1, ..."        );    }    @Test    void testIncorrectMinimumLanguageVersionWithLanguageSetInJava() {        assertCannotParse("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                              + "<ruleset name=\"TODO\">\n"                              + "    <description>TODO</description>\n"                              + "\n"                              + "    <rule name=\"TODO\"\n"                              + "          message=\"TODO\"\n"                              + "          class=\"net.sourceforge.pmd.util.FooRuleWithLanguageSetInJava\"\n"                              + "          minimumLanguageVersion=\"12\">\n"                              + "        <description>TODO</description>\n"                              + "        <priority>2</priority>\n"                              + "    </rule>\n"                              + "\n"                              + "</ruleset>");        verifyFoundAnErrorWithMessage(            containing("valid language version")        );    }    @Test    void testMaximumLanguageVersion() {        Rule r = loadFirstRule(rulesetXml(            dummyRule(attrs -> attrs.put(SchemaConstants.MAXIMUM_LANGUAGE_VERSION, "1.7"))        ));        assertEquals(dummyLanguage().getVersion("1.7"),                     r.getMaximumLanguageVersion());    }    @Test    void testIncorrectMaximumLanguageVersion() {        assertCannotParse(rulesetXml(            dummyRule(attrs -> attrs.put(SchemaConstants.MAXIMUM_LANGUAGE_VERSION, "bogus"))        ));        verifyFoundAnErrorWithMessage(            containing("valid language version")                .and(containing("'1.0', '1.1', '1.2'"))        );    }    @Test    void testInvertedMinimumMaximumLanguageVersions() {        assertCannotParse(rulesetXml(            dummyRule(                attrs -> {                    attrs.put(SchemaConstants.MINIMUM_LANGUAGE_VERSION, "1.7");                    attrs.put(SchemaConstants.MAXIMUM_LANGUAGE_VERSION, "1.4");                }            )        ));        verifyFoundAnErrorWithMessage(containing("version range"));    }    @Test    public void testDirectDeprecatedRule() {        Rule r = loadFirstRule(rulesetXml(            dummyRule(attrs -> attrs.put(DEPRECATED, "true"))        ));        assertNotNull(r, "Direct Deprecated Rule");        assertTrue(r.isDeprecated());    }    @Test    void testReferenceToDeprecatedRule() {        Rule r = loadFirstRule(REFERENCE_TO_DEPRECATED_RULE);        assertNotNull(r, "Reference to Deprecated Rule");        assertTrue(r instanceof RuleReference, "Rule Reference");        assertFalse(r.isDeprecated(), "Not deprecated");        assertTrue(((RuleReference) r).getRule().isDeprecated(), "Original Rule Deprecated");        assertEquals(r.getName(), DEPRECATED_RULE_NAME, "Rule name");    }    @Test    void testRuleSetReferenceWithDeprecatedRule() {        RuleSet ruleSet = loadRuleSet(REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE);        assertNotNull(ruleSet, "RuleSet");        assertFalse(ruleSet.getRules().isEmpty(), "RuleSet empty");        // No deprecated Rules should be loaded when loading an entire RuleSet        // by reference - unless it contains only deprecated rules - then all rules would be added        Rule r = ruleSet.getRuleByName(DEPRECATED_RULE_NAME);        assertNull(r, "Deprecated Rule Reference");        for (Rule rule : ruleSet.getRules()) {            assertFalse(rule.isDeprecated(), "Rule not deprecated");        }    }    @Test    void testDeprecatedRuleSetReference() {        RuleSet ruleSet = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/rulesets/ruleset-deprecated.xml");        assertEquals(2, ruleSet.getRules().size());    }    @Test    void testExternalReferences() {        RuleSet rs = loadRuleSet(            rulesetXml(                ruleRef("net/sourceforge/pmd/external-reference-ruleset.xml/MockRule")            )        );        assertEquals(1, rs.size());        assertEquals(MockRule.class.getName(), rs.getRuleByName("MockRule").getRuleClass());    }    @Test    void testIncludeExcludePatterns() {        RuleSet ruleSet = loadRuleSet(INCLUDE_EXCLUDE_RULESET);        assertNotNull(ruleSet.getFileInclusions(), "Include patterns");        assertEquals(2, ruleSet.getFileInclusions().size(), "Include patterns size");        assertEquals("include1", ruleSet.getFileInclusions().get(0).pattern(), "Include pattern #1");        assertEquals("include2", ruleSet.getFileInclusions().get(1).pattern(), "Include pattern #2");        assertNotNull(ruleSet.getFileExclusions(), "Exclude patterns");        assertEquals(3, ruleSet.getFileExclusions().size(), "Exclude patterns size");        assertEquals("exclude1", ruleSet.getFileExclusions().get(0).pattern(), "Exclude pattern #1");        assertEquals("exclude2", ruleSet.getFileExclusions().get(1).pattern(), "Exclude pattern #2");        assertEquals("exclude3", ruleSet.getFileExclusions().get(2).pattern(), "Exclude pattern #3");    }    /**     * Rule reference can't be resolved - ref is used instead of class and the     * class is old (pmd 4.3 and not pmd 5).     */    @Test    void testBug1202() {        assertCannotParse(            rulesetXml(                ruleRef(                    "net.sourceforge.pmd.rules.XPathRule",                    priority("1"),                    properties(                        propertyWithValueAttr("xpath", "//TypeDeclaration"),                        propertyWithValueAttr("message", "Foo")                    )                )            )        );    }    /**     * See https://sourceforge.net/p/pmd/bugs/1225/     */    @Test    void testEmptyRuleSetFile() {        RuleSet ruleset = loadRuleSet(            rulesetXml(                excludePattern(".*Test.*")            ));        assertEquals(0, ruleset.getRules().size());    }    /**     * See https://github.com/pmd/pmd/issues/782     * Empty ruleset should be interpreted as deprecated.     */    @Test    void testEmptyRuleSetReferencedShouldNotBeDeprecated() {        RuleSet ruleset = loadRuleSet(            rulesetXml(                ruleRef("rulesets/dummy/empty-ruleset.xml")            )        );        assertEquals(0, ruleset.getRules().size());        verifyNoWarnings();    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    void testWrongRuleNameReferenced() {        assertCannotParse(rulesetXml(            ruleRef("net/sourceforge/pmd/TestRuleset1.xml/ThisRuleDoesNotExist")        ));    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     */    @Test    void testRuleReferenceWithNameOverridden() {        RuleSet rs = loadRuleSet("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                                     + "<ruleset xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                     + "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                     + "         name=\"pmd-eclipse\"\n"                                     + "         xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                     + "   <description>PMD Plugin preferences rule set</description>\n"                                     + "<rule name=\"OverriddenDummyBasicMockRule\"\n"                                     + "    ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\">\n" + "</rule>\n" + "\n"                                     + "</ruleset>");        Rule r = rs.getRules().iterator().next();        assertEquals("OverriddenDummyBasicMockRule", r.getName());        RuleReference ruleRef = (RuleReference) r;        assertEquals("DummyBasicMockRule", ruleRef.getRule().getName());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     *     * <p>See https://github.com/pmd/pmd/issues/1978 - with that, it should not be an error anymore.     *     */    @Test    void testWrongRuleNameExcluded() {        RuleSet ruleset = loadRuleSet("<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                                          + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                          + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                          + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                          + "  <description>Custom ruleset for tests</description>\n"                                          + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml\">\n"                                          + "    <exclude name=\"ThisRuleDoesNotExist\"/>\n" + "  </rule>\n"                                          + "</ruleset>\n");        assertEquals(4, ruleset.getRules().size());    }    /**     * This unit test manifests the current behavior - which might change in the     * future. See #1537.     *     * Currently, if a ruleset is imported twice, the excludes of the first     * import are ignored. Duplicated rules are silently ignored.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1537/">#1537 Implement     *      strict ruleset parsing</a>     * @see <a href=     *      "http://stackoverflow.com/questions/40299075/custom-pmd-ruleset-not-working">stackoverflow     *      - custom ruleset not working</a>     */    @Test    void testExcludeAndImportTwice() {        RuleSet ruleset = loadRuleSet(            rulesetXml(                rulesetRef("rulesets/dummy/basic.xml",                           excludeRule("DummyBasicMockRule")                )            )        );        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        RuleSet ruleset2 = loadRuleSet(            rulesetXml(                rulesetRef("rulesets/dummy/basic.xml",                           excludeRule("DummyBasicMockRule")                ),                rulesetRef("rulesets/dummy/basic.xml")            )        );        assertNotNull(ruleset2.getRuleByName("DummyBasicMockRule"));        RuleSet ruleset3 = loadRuleSet(            rulesetXml(                rulesetRef("rulesets/dummy/basic.xml"),                rulesetRef("rulesets/dummy/basic.xml",                           excludeRule("DummyBasicMockRule")                )            )        );        assertNotNull(ruleset3.getRuleByName("DummyBasicMockRule"));    }    @Test    void testMissingRuleSetNameIsWarning() throws Exception {        SystemLambda.tapSystemErr(() -> {            loadRuleSetWithDeprecationWarnings(                "<?xml version=\"1.0\"?>\n" + "<ruleset \n"                    + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                    + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                    + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                    + "  <description>Custom ruleset for tests</description>\n"                    + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                    + "  </ruleset>\n"            );        });        verifyFoundAWarningWithMessage(containing("RuleSet name is missing."));    }    @Test    public void testMissingRuleSetDescriptionIsWarning() {        loadRuleSetWithDeprecationWarnings(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"then name\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                        + "  </ruleset>\n"        );        verifyFoundAWarningWithMessage(containing("RuleSet description is missing."));    }    @Test    void testDeprecatedRulesetReferenceProducesWarning() throws Exception {        String log = SystemLambda.tapSystemErr(            () -> loadRuleSetWithDeprecationWarnings(                rulesetXml(                    ruleRef("dummy-basic")                )));        System.out.println(log);        verifyFoundAWarningWithMessage(containing(            "Ruleset reference 'dummy-basic' uses a deprecated form, use 'rulesets/dummy/basic.xml' instead"        ));    }    private static final String REF_OVERRIDE_ORIGINAL_NAME = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "\n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"> \n"        + "\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_MISSPELLED_XREF = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/FooMockRule1\"> \n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"/> \n"        + "\n"        + "</ruleset>";    private static final String REF_OVERRIDE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" \n"        + "  name=\"TestNameOverride\" \n"        + "\n"        + "  message=\"Test message override\"> \n"        + "  <description>Test description override</description>\n"        + "  <example>Test example override</example>\n"        + "  <priority>3</priority>\n"        + "  <properties>\n"        + "   <property name=\"test2\" description=\"test2\" type=\"String\" value=\"override2\"/>\n"        + "   <property name=\"test3\" type=\"String\" description=\"test3\"><value>override3</value></property>\n"        + "\n"        + "  </properties>\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_OVERRIDE_NONEXISTENT = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" \n"        + "  name=\"TestNameOverride\" \n"        + "\n"        + "  message=\"Test message override\"> \n"        + "  <description>Test description override</description>\n"        + "  <example>Test example override</example>\n"        + "  <priority>3</priority>\n"        + "  <properties>\n"        + "   <property name=\"test4\" description=\"test4\" type=\"String\" value=\"new property\"/>\n"        + "  </properties>\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "</rule>\n"        + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"/> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL_CHAIN = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "</rule>\n"        + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"><priority>2</priority></rule> \n"        + " <rule ref=\"MockRuleNameRef\" name=\"MockRuleNameRefRef\"><priority>1</priority></rule> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "name=\"ExternalRefRuleName\" \n"        + "ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\"/>\n"        + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"/> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL_CHAIN = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "name=\"ExternalRefRuleName\" \n"        + "ref=\"net/sourceforge/pmd/TestRuleset2.xml/TestRule\"/>\n"        + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"><priority>2</priority></rule> \n"        + "\n"        + " <rule ref=\"ExternalRefRuleNameRef\" name=\"ExternalRefRuleNameRefRef\"><priority>1</priority></rule> \n"        + "\n"        + "</ruleset>";    private static final String EMPTY_RULESET = rulesetXml();    private static final String SINGLE_RULE =        rulesetXml(            rule(                dummyRuleDefAttrs(),                priority("3")            )        );    private static final String SINGLE_RULE_EMPTY_REF =        "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "ref=\"\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "</rule></ruleset>";    private static final String PROPERTIES =        rulesetXml(            rule(dummyRuleDefAttrs(),                 description("testdesc2"),                 properties(                     "<property name=\"fooBoolean\" description=\"test\" type=\"Boolean\" value=\"true\" />\n",                     "<property name=\"fooChar\" description=\"test\" type=\"Character\" value=\"B\" />\n",                     "<property name=\"fooInt\" description=\"test\" type=\"Integer\" min=\"1\" max=\"10\" value=\"3\" />",                     "<property name=\"fooDouble\" description=\"test\" type=\"Double\" min=\"1.0\" max=\"9.0\" value=\"3.0\"  />\n",                     "<property name=\"fooString\" description=\"test\" type=\"String\" value=\"bar\" />\n"                 ))        );    private static final String XPATH =        rulesetXml(            rule(                dummyRuleDefAttrs(),                description("testDesc"),                properties(                    "<property name=\"xpath\" description=\"test\" type=\"String\">\n"                        + "<value>\n"                        + "<![CDATA[ //Block ]]>\n"                        + "</value>"                        + "</property>"                )            )        );    // Note: Update this RuleSet name to a different RuleSet with deprecated    // Rules when the Rules are finally removed.    private static final String DEPRECATED_RULE_RULESET_NAME = "net/sourceforge/pmd/TestRuleset1.xml";    // Note: Update this Rule name to a different deprecated Rule when the one    // listed here is finally removed.    private static final String DEPRECATED_RULE_NAME = "MockRule3";    private static final String REFERENCE_TO_DEPRECATED_RULE =        rulesetXml(            ruleRef(DEPRECATED_RULE_RULESET_NAME + "/" + DEPRECATED_RULE_NAME)        );    private static final String REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE =        rulesetXml(            rulesetRef(DEPRECATED_RULE_RULESET_NAME)        );    private static final String INCLUDE_EXCLUDE_RULESET =        rulesetXml(            includePattern("include1"),            includePattern("include2"),            excludePattern("exclude1"),            excludePattern("exclude2"),            excludePattern("exclude3")        );}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.function.BiConsumer;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil;public class RuleContextTest {    static Report getReport(Rule rule, BiConsumer<Rule, RuleContext> sideEffects) {        return Report.buildReport(listener -> sideEffects.accept(rule, RuleContext.create(listener, rule)));    }    public static Report getReportForRuleApply(Rule rule, Node node) {        return getReport(rule, (r, ctx) -> r.apply(node, ctx));    }    static Report getReportForRuleSetApply(RuleSet ruleset, RootNode node) {        return Report.buildReport(listener -> new RuleSets(ruleset).apply(node, listener));    }    @Test    void testMessage() throws Exception {        Report report = getReport(new FooRule(), (r, ctx) -> ctx.addViolationWithMessage(DummyTreeUtil.tree(DummyTreeUtil::root), "message with \"'{'\""));        assertEquals("message with \"{\"", report.getViolations().get(0).getDescription());    }    @Test    void testMessageEscaping() throws Exception {        RuleViolation violation = makeViolation("message with \"'{'\"");        assertEquals("message with \"{\"", violation.getDescription());    }    @Test    void testMessageEscaping2() throws Exception {        RuleViolation violation = makeViolation("message with ${ohio}");        assertEquals("message with ${ohio}", violation.getDescription());    }    private RuleViolation makeViolation(String unescapedMessage, Object... args) throws Exception {        Report report = getReport(new FooRule(), (r, ctx) -> {            DummyRootNode node = DummyTreeUtil.tree(DummyTreeUtil::root);            ctx.addViolationWithMessage(node, unescapedMessage, args);        });        return report.getViolations().get(0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.Comparator;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyRootNode;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.lang.document.TextFile;import net.sourceforge.pmd.lang.document.TextRange2d;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;class RuleViolationTest {    @Test    void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        DummyRootNode s = DummyLanguageModule.parse("abcd", "filename");        RuleViolation r = new ParametricRuleViolation(rule, s, rule.getMessage());        assertEquals(rule, r.getRule(), "object mismatch");        assertEquals(1, r.getBeginLine(), "line number is wrong");        assertEquals("filename", r.getFilename(), "filename is wrong");    }    @Test    void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        DummyRootNode s = DummyLanguageModule.parse("abcd", "filename");        RuleViolation r = new ParametricRuleViolation(rule, s, "description");        assertEquals(rule, r.getRule(), "object mismatch");        assertEquals(1, r.getBeginLine(), "line number is wrong");        assertEquals("filename", r.getFilename(), "filename is wrong");        assertEquals("description", r.getDescription(), "description is wrong");    }    @Test    void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        DummyNode s = DummyLanguageModule.parse("(abc)", "filename1").getFirstChild();        DummyNode s1 = DummyLanguageModule.parse("(abc)", "filename2").getFirstChild();        RuleViolation r1 = new ParametricRuleViolation(rule, s, "description");        RuleViolation r2 = new ParametricRuleViolation(rule, s1, "description");        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    @Test    void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        DummyRootNode root = DummyLanguageModule.parse("(abc) (def)");        DummyNode abcChild = root.getChild(0);        DummyNode defChild = root.getChild(1);        RuleViolation r1 = new ParametricRuleViolation(rule, abcChild, "description");        RuleViolation r2 = new ParametricRuleViolation(rule, defChild, "description");        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    @Test    void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        String filename = TextFile.UNKNOWN_FILENAME;        FileLocation loc = FileLocation.range(filename, TextRange2d.range2d(10, 1, 15, 10));        RuleViolation r1 = new ParametricRuleViolation(rule, loc, "description");        RuleViolation r2 = new ParametricRuleViolation(rule, loc, "description");        assertEquals(0, comp.compare(r1, r2));        assertEquals(0, comp.compare(r2, r1));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.resolver;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.modelica.ModelicaParsingHelper;import net.sourceforge.pmd.lang.modelica.ast.ASTExtendsClause;import net.sourceforge.pmd.lang.modelica.ast.ASTStoredDefinition;import net.sourceforge.pmd.lang.modelica.ast.ModelicaClassSpecifierNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaParserVisitorAdapter;class ModelicaResolverTest {    private final ModelicaParsingHelper modelica = ModelicaParsingHelper.DEFAULT;    private static class NodeFinder extends ModelicaParserVisitorAdapter {        private ModelicaNode result;        private Class<?> nodeClass;        private String nodeName;        NodeFinder(Class<?> nodeClass, String nodeName) {            this.nodeClass = nodeClass;            this.nodeName = nodeName;        }        @Override        public Object visitModelicaNode(ModelicaNode node, Object data) {            if (nodeClass.isInstance(node) && node.getImage().equals(nodeName)) {                assertNull(result);                result = node;            }            return super.visitModelicaNode(node, data);        }        ModelicaNode getResult() {            return result;        }    }    private ModelicaNode findNodeByClassAndImage(ASTStoredDefinition ast, Class<?> clazz, String image) {        NodeFinder vis = new NodeFinder(clazz, image);        ast.acceptVisitor(vis, null);        return vis.getResult();    }    private void ensureCounts(ResolutionResult result, int best, int hidden) {        assertFalse(result.wasTimedOut());        assertEquals(best, result.getBestCandidates().size());        assertEquals(hidden, result.getHiddenCandidates().size());    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, SubcomponentResolver resolver, boolean absolute, String[] names) {        ResolutionResult<ResolvableEntity> result = resolver.safeResolveComponent(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, ModelicaScope resolver, boolean absolute, String[] names) {        ResolutionResult<ResolvableEntity> result = resolver.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, SubcomponentResolver scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedComponentCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forComponentReference(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testLexicallyResolvedComponents(int best, int hidden, ModelicaClassScope scope, boolean absolute, String... names) {        ResolutionState state = ResolutionState.forComponentReference();        ResolutionResult<ResolvableEntity> result = scope.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    @Test    void verySimpleScopeTest() {        String contents =              "model TestPackage"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        assertNotNull(ast);        assertTrue(ast.getMostSpecificScope() instanceof ModelicaSourceFileScope);        ModelicaSourceFileScope scope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        assertTrue(scope.getParent() instanceof RootScope);        assertNull(scope.getParent().getParent());    }    @Test    void simpleScopeTest() {        String contents =              "package TestPackage"            + "  connector TestConnector"            + "  end TestConnector;"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        ModelicaSourceFileScope sourceFileScope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        assertEquals(1, sourceFileScope.getContainedDeclarations().size());        ModelicaNode testSubmodel = findNodeByClassAndImage(ast, ModelicaClassSpecifierNode.class, "TestSubmodel");        assertNotNull(testSubmodel);        assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:TestSubmodel",                ((AbstractModelicaScope) testSubmodel.getMostSpecificScope()).getNestingRepresentation()        );        ModelicaScope testPackage = testSubmodel.getMostSpecificScope().getParent().getParent();        assertTrue(testPackage instanceof ModelicaClassScope);        assertEquals("TestPackage", ((ModelicaClassScope) testPackage).getClassDeclaration().getSimpleTypeName());        assertEquals(3, testPackage.getContainedDeclarations().size());    }    @Test    void extendsScopeTest() {        String contents =                  "package Test"                + "  model A"                + "    extends B;"                + "  end A;"                + "  model B"                + "  end B;"                + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ASTExtendsClause> extendsClauses = ast.findDescendantsOfType(ASTExtendsClause.class);        assertEquals(1, extendsClauses.size());        ASTExtendsClause extendsB = extendsClauses.get(0);        assertEquals("#ROOT#FILE#Class:Test#Class:A", ((AbstractModelicaScope) extendsB.getMostSpecificScope()).getNestingRepresentation());    }    @Test    void absoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    void nonAbsoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    void multipleResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model A"            + "    end A;"            + "  end TestModel;"            + "  model A"            + "  end A;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        ResolutionResult<ResolvableEntity> testModelCandidates = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel");        ModelicaClassScope testModelScope = ((ModelicaClassType) testModelCandidates.getBestCandidates().get(0)).getClassScope();        assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel",                testModelScope.getNestingRepresentation()        );        ResolutionResult<ResolvableEntity> aCandidates = testLexicallyResolvedComponents(1, 1, testModelScope, false, "A");        ModelicaClassType aBest = (ModelicaClassType) aCandidates.getBestCandidates().get(0);        ModelicaClassType aHidden = (ModelicaClassType) aCandidates.getHiddenCandidates().get(0);        assertEquals("#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:A",                aBest.getClassScope().getNestingRepresentation());        assertEquals("#ROOT#FILE#Class:TestPackage#Class:A",                aHidden.getClassScope().getNestingRepresentation());    }    @Test    void constantComponentResolutionTest() {        String contents =              "model Test"            + "  model A"            + "    constant Real x = 1;"            + "  end A;"            + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ResolvableEntity> xs = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "A", "x").getBestCandidates();        assertEquals(            "#ROOT#FILE#Class:Test#Class:A",                ((ModelicaComponentDeclaration) xs.get(0)).getContainingScope().getNestingRepresentation()        );    }    @Test    void nestedStoredDefinitionTest() {        String contents =              "within TestPackage.SubPackage;\n"            + "model Test\n"            + "end Test;\n";        ASTStoredDefinition ast = modelica.parse(contents);        RootScope rootScope = (RootScope) ast.getMostSpecificScope().getParent();        List<ResolvableEntity> nestedTest = testResolvedTypeCount(1, 0, rootScope, false, "TestPackage", "SubPackage", "Test").getBestCandidates();        assertEquals(                "#ROOT#FILE#Class:Test",                ((ModelicaClassType) nestedTest.get(0)).getClassScope().getNestingRepresentation()        );        // Simple names are visible from within the same file        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test");        // ... but from other files they should be resolved w.r.t. the within clause        testResolvedTypeCount(0, 0, rootScope, false, "Test");    }    @Test    void extendsTest() {        String contents =              "model A\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "B", "X");    }    @Test    void importTest() {        String contents =              "model I\n"            + "  model Z\n"            + "  end Z;\n"            + "end I;\n"            + "model A\n"            + "  import I.Z;\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "A", "Z");        testResolvedTypeCount(0, 0, ast.getMostSpecificScope(), false, "B", "Z");    }    @Test    void builtinTest() {        String contents =              "model A"            + "  encapsulated model B"            + "    Real x;"            + "  end B;"            + "end A;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ResolvableEntity> xs = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), true, "A", "B", "x").getBestCandidates();        ModelicaComponentDeclaration x = (ModelicaComponentDeclaration) xs.get(0);        ResolutionResult<ModelicaType> xTypes = x.getTypeCandidates();        ensureCounts(xTypes, 1, 0);        ResolvableEntity tpe = xTypes.getBestCandidates().get(0);        assertTrue(tpe instanceof ModelicaBuiltinType);        assertEquals(ModelicaBuiltinType.BaseType.REAL, ((ModelicaBuiltinType) tpe).getBaseType());    }    @Test    void testRepeatingNameResolution() {        String contents =                  "package Test"                + "  model X"                + "    model X"                + "    end X;"                + "    Test.X.X mdl;"                + "  end X;"                + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "Test", "X", "X");        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "X");        ResolutionResult<ResolvableEntity> result = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "mdl");        ModelicaComponentDeclaration mdl = (ModelicaComponentDeclaration) result.getBestCandidates().get(0);        ensureCounts(mdl.getTypeCandidates(), 1, 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ConnectUsingNonConnectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ClassStartNameEqualsEndNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AmbiguousResolutionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica;import org.junit.jupiter.api.Test;class ModelicaParserTest {    @Test    void testParsingGrapgical() {        ModelicaParsingHelper.DEFAULT.parseResource("ParserTestGraphical.mo");    }    @Test    void testParsingTextual() {        ModelicaParsingHelper.DEFAULT.parseResource("ParserTestTextual.mo");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.modelica.ModelicaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ModelicaLanguageModule.NAME, ModelicaLanguageModule.TERSE_NAME, "",                getLanguage(ModelicaLanguageModule.NAME).getDefaultVersion(),            },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class MatlabTokenizerTest extends CpdTextComparisonTest {    MatlabTokenizerTest() {        super(".m");    }    @Override    protected String getResourcePrefix() {        return "../lang/matlab/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new MatlabTokenizer();    }        @Test    void testLongSample() {        doTest("sample-matlab");    }    @Test    void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    void testComments() {        doTest("comments");    }    @Test    void testBlockComments() {        doTest("multilineComments");    }    @Test    void testQuestionMark() {        doTest("questionMark");    }    @Test    public void testDoubleQuotedStrings() {        doTest("doubleQuotedStrings");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UseAltAttributeForImagesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidInlineStylesTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnnecessaryTypeAttributeTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.CoordinatesPrinter;class PositionTest extends BaseTreeDumpTest {    PositionTest() {        super(CoordinatesPrinter.INSTANCE, ".html");    }    @Override    public BaseParsingHelper<HtmlParsingHelper, ASTHtmlDocument> getParser() {        return HtmlParsingHelper.DEFAULT.withResourceContext(HtmlTreeDumpTest.class, "testdata");    }    @Test    void testPositions() {        doTest("SimpleHtmlFile2");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;class HtmlTreeDumpTest extends BaseTreeDumpTest {    HtmlTreeDumpTest() {        super(new RelevantAttributePrinter(), ".html");    }    @Override    public BaseParsingHelper<HtmlParsingHelper, ASTHtmlDocument> getParser() {        return HtmlParsingHelper.DEFAULT.withResourceContext(HtmlTreeDumpTest.class, "testdata");    }    @Test    void simpleHtmlFile() {        doTest("SimpleHtmlFile");    }    @Test    void templateFragment() {        doTest("TemplateFragment");    }    @Test    void simpleXmlFile() {        doTest("SimpleXmlFile");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.html.ast.ASTHtmlElement;import net.sourceforge.pmd.lang.html.rule.AbstractHtmlRule;import net.sourceforge.pmd.lang.rule.xpath.Attribute;class HtmlJavaRuleTest {    // from https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.js_props_getter    private static final String LIGHTNING_WEB_COMPONENT = "<!-- helloExpressions.html -->\n"            + "<template>\n"            + "    <p>Hello, { greeting}!</p>\n"            + "    <lightning-input label=\"Name\" value={ greeting} onchange=\"{ handleChange }\"></lightning-input>\n"            + "    <div class=\"slds-m-around_medium\">\n"            + "        <lightning-input name='firstName' label=\"First Name\" onchange={ handleChange }></lightning-input>\n"            + "        <lightning-input name='lastName' label=\"Last Name\" onchange={handleChange}></lightning-input>\n"            + "        <p class=\"slds-m-top_medium\">Uppercased Full Name: {uppercasedFullName}</p>\n"            + "    </div>\n"            + "</template>";    @Test    void findAllAttributesWithInvalidExpression() {        // "Don’t add spaces around the property, for example, { data } is not valid HTML."        Rule rule = new AbstractHtmlRule() {            @Override            public String getMessage() {                return "Invalid expression";            }            @Override            public Object visit(ASTHtmlElement node, Object data) {                for (Attribute attribute : node.getAttributes()) {                    if ("{".equals(attribute.getValue())) {                        RuleContext ctx = (RuleContext) data;                        ctx.addViolation(node);                    }                }                return super.visit(node, data);            }        };        rule.setLanguage(HtmlParsingHelper.DEFAULT.getLanguage());        List<RuleViolation> violations = runRule(LIGHTNING_WEB_COMPONENT, rule);        assertEquals(2, violations.size());        assertEquals(4, violations.get(0).getBeginLine());        assertEquals(6, violations.get(1).getBeginLine());    }    private List<RuleViolation> runRule(String html, Rule rule) {        Report report = HtmlParsingHelper.DEFAULT.executeRule(rule, html);        return report.getViolations();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.html.ast.ASTHtmlComment;import net.sourceforge.pmd.lang.html.ast.ASTHtmlDocument;import net.sourceforge.pmd.lang.html.ast.ASTHtmlTextNode;import net.sourceforge.pmd.lang.html.ast.HtmlParsingHelper;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;class HtmlXPathRuleTest {    // from https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.js_props_getter    private static final String LIGHTNING_WEB_COMPONENT = "<!-- helloExpressions.html -->\n"            + "<template>\n"            + "    <p>Hello, { greeting}!</p>\n"            + "    <lightning-input label=\"Name\" value={ greeting} onchange={handleChange}></lightning-input>\n"            + "    <div class=\"slds-m-around_medium\">\n"            + "        <lightning-input name='firstName' label=\"First Name\" onchange={ handleChange}></lightning-input>\n"            + "        <lightning-input name='lastName' label=\"Last Name\" onchange={handleChange}></lightning-input>\n"            + "        <p class=\"slds-m-top_medium\">Uppercased Full Name: {uppercasedFullName}</p>\n"            + "    </div>\n"            + "    <template if:true={visible}>\n"            + "      <p>Test</p>\n"            + "    </template>\n"            + "</template>";    @Test    void selectTextNode() {        // from https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.js_props_getter        // "Don’t add spaces around the property, for example, { data } is not valid HTML."        String xpath = "//text()[contains(., '{ ')]";        List<RuleViolation> violations = runXPath(LIGHTNING_WEB_COMPONENT, xpath);        assertEquals(1, violations.size());        assertEquals(3, violations.get(0).getBeginLine());    }    @Test    void selectTextNodeByNodeNameShouldNotWork() {        String xpath = "//*[local-name() = '#text']";        List<RuleViolation> violations = runXPath(LIGHTNING_WEB_COMPONENT, xpath);        assertEquals(0, violations.size());    }    @Test    void verifyTextNodeName() {        ASTHtmlDocument document = HtmlParsingHelper.DEFAULT.parse("<p>foobar</p>");        ASTHtmlTextNode textNode = document.getFirstDescendantOfType(ASTHtmlTextNode.class);        assertEquals("#text", textNode.getXPathNodeName());    }    @Test    void verifyCommentNodeName() {        ASTHtmlDocument document = HtmlParsingHelper.DEFAULT.parse("<p><!-- a comment --></p>");        ASTHtmlComment comment = document.getFirstDescendantOfType(ASTHtmlComment.class);        assertEquals("#comment", comment.getXPathNodeName());    }    @Test    void selectAttributes() {        // from https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.js_props_getter        // "Don’t add spaces around the property, for example, { data } is not valid HTML."        String xpath = "//*[@value = '{']";        List<RuleViolation> violations = runXPath(LIGHTNING_WEB_COMPONENT, xpath);        assertEquals(1, violations.size());        assertEquals(4, violations.get(0).getBeginLine());    }    @Test    void selectAttributesMultiple() {        // from https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.js_props_getter        // "Don’t add spaces around the property, for example, { data } is not valid HTML."        String xpath = "//*[@*[local-name() = ('value', 'onchange')] = '{']";        List<RuleViolation> violations = runXPath(LIGHTNING_WEB_COMPONENT, xpath);        assertEquals(2, violations.size());        assertEquals(4, violations.get(0).getBeginLine());        assertEquals(6, violations.get(1).getBeginLine());    }    @Test    void selectAttributeByName() {        String xpath = "//*[@*[local-name() = 'if:true']]";        List<RuleViolation> violations = runXPath(LIGHTNING_WEB_COMPONENT, xpath);        assertEquals(1, violations.size());        assertEquals(10, violations.get(0).getBeginLine());    }    private List<RuleViolation> runXPath(String html, String xpath) {        XPathRule rule = new XPathRule(XPathVersion.DEFAULT, xpath);        rule.setMessage("test");        rule.setLanguage(HtmlParsingHelper.DEFAULT.getLanguage());        Report report = HtmlParsingHelper.DEFAULT.executeRule(rule, html);        return report.getViolations();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.html.ast.HtmlTokenizer;class HtmlTokenizerTest extends CpdTextComparisonTest {    HtmlTokenizerTest() {        super(".html");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new HtmlTokenizer();    }    @Override    protected String getResourcePrefix() {        return "cpd";    }    @Test    void testSimpleHtmlFile() {        doTest("SimpleHtmlFile");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.html;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class LuaTokenizerTest extends CpdTextComparisonTest {    LuaTokenizerTest() {        super(".lua");    }    @Override    protected String getResourcePrefix() {        return "../lang/lua/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new LuaTokenizer();    }    @Test    void testSimple() {        doTest("helloworld");    }    @Test    void testFactorial() {        doTest("factorial");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }    @Test    public void testLuauTypes() {        doTest("luauTypes");    }    @Test    public void testComment() {        doTest("comment");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class RubyTokenizerTest extends CpdTextComparisonTest {    RubyTokenizerTest() {        super(".rb");    }    @Override    protected String getResourcePrefix() {        return "../lang/ruby/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new RubyLanguage().getTokenizer();    }    @Test    void testSimple() {        doTest("server");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class CPPTokenizerTest extends CpdTextComparisonTest {    CPPTokenizerTest() {        super(".cpp");    }    @Override    protected String getResourcePrefix() {        return "../lang/cpp/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties props) {        CPPTokenizer tok = new CPPTokenizer();        tok.setProperties(props);        return tok;    }    @Override    public Properties defaultProperties() {        return dontSkipBlocks();    }    @Test    void testUTFwithBOM() {        Tokenizer tokenizer = newTokenizer(dontSkipBlocks());        Tokens tokens = tokenize(tokenizer, "\ufeffint start()\n{ int ret = 1;\nreturn ret;\n}\n");        assertEquals(15, tokens.size());    }    @Test    void testContinuation() {        doTest("continuation");    }    @Test    void testContinuationInIdent() {        doTest("continuation_intra_token");    }    @Test    void testContinuationBetweenTokens() {        doTest("continuation_inter_token");    }    @Test    void testUnicodeStringSupport() {        doTest("unicodeStrings");    }    @Test    void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    void testMultiLineMacros() {        doTest("multilineMacros");    }    @Test    void testIdentifierValidChars() {        doTest("identifierChars");    }    @Test    void testWrongUnicodeInIdentifier() {        expectTokenMgrError(" void main() { int ⚜ = __; }");    }    @Test    void testTokenizerWithSkipBlocks() {        doTest("simpleSkipBlocks", "_skipDefault", skipBlocks());    }    @Test    void testTokenizerWithSkipBlocksPattern() {        doTest("simpleSkipBlocks", "_skipDebug", skipBlocks("#if debug|#endif"));    }    @Test    void testTokenizerWithoutSkipBlocks() {        doTest("simpleSkipBlocks", "_noSkip", dontSkipBlocks());    }    @Test    void testAsm() {        // ASM code containing the '@' character        doTest("asm", "", dontSkipBlocks());    }    @Test    void testPreprocessingDirectives() {        doTest("preprocessorDirectives");    }    @Test    void testLiterals() {        doTest("literals");    }    @Test    void testLexicalErrorFilename() {        expectTokenMgrError(sourceText("issue-1559"), dontSkipBlocks());    }    @Test    void testRawStringLiterals() {        doTest("issue-1784");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }    @Test    void testLongListsOfNumbersAreNotIgnored() {        doTest("listOfNumbers");    }    @Test    void testLongListsOfNumbersAreIgnored() {        doTest("listOfNumbers", "_ignored", skipLiteralSequences());    }    private static Properties skipBlocks(String skipPattern) {        return properties(true, skipPattern, false);    }    private static Properties skipBlocks() {        return skipBlocks(null);    }    private static Properties dontSkipBlocks() {        return properties(false, null, false);    }    private static Properties skipLiteralSequences() {        return properties(false, null, true);    }    private static Properties properties(boolean skipBlocks, String skipPattern, boolean skipLiteralSequences) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS, Boolean.toString(skipBlocks));        if (skipPattern != null) {            properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS_PATTERN, skipPattern);        }        properties.setProperty(Tokenizer.OPTION_IGNORE_LITERAL_SEQUENCES, Boolean.toString(skipLiteralSequences));        return properties;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import java.io.IOException;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.impl.javacc.CharStream;import net.sourceforge.pmd.lang.document.CpdCompat;import net.sourceforge.pmd.lang.document.TextDocument;import net.sourceforge.pmd.lang.document.TextFile;class CppCharStreamTest {    @NonNull    public CharStream charStreamFor(String source) throws IOException {        TextDocument textDoc = TextDocument.readOnlyString(source, TextFile.UNKNOWN_FILENAME, CpdCompat.dummyVersion());        return CharStream.create(textDoc, new CPPTokenizer().tokenBehavior());    }    @Test    void testContinuationUnix() throws IOException {        CharStream stream = charStreamFor("a\\\nb");        assertStream(stream, "ab");    }    @Test    void testContinuationWindows() throws IOException {        // note that the \r is normalized to a \n by the TextFile        CharStream stream = charStreamFor("a\\\r\nb");        assertStream(stream, "ab");    }    @Test    void testBackup() throws IOException {        // note that the \r is normalized to a \n by the TextFile        CharStream stream = charStreamFor("a\\b\\qc");        assertStream(stream, "a\\b\\qc");    }    private void assertStream(CharStream stream, String token) throws IOException {        char c = stream.markTokenStart();        assertEquals(token.charAt(0), c);        for (int i = 1; i < token.length(); i++) {            c = stream.readChar();            assertEquals(token.charAt(i), c, token + " char at " + i + ": " + token.charAt(i) + " != " + c);        }        assertEquals(token, stream.getTokenImage());        // StringBuilder sb = new StringBuilder();        // stream.appendSuffix(sb, token.length());        // assertEquals(token, sb.toString());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.test.schema;import java.io.IOException;import java.text.MessageFormat;import java.util.function.Consumer;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import org.xml.sax.InputSource;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.annotation.Experimental;import com.github.oowekyala.ooxml.messages.NiceXmlMessageSpec;import com.github.oowekyala.ooxml.messages.OoxmlFacade;import com.github.oowekyala.ooxml.messages.PositionedXmlDoc;import com.github.oowekyala.ooxml.messages.PrintStreamMessageHandler;import com.github.oowekyala.ooxml.messages.XmlException;import com.github.oowekyala.ooxml.messages.XmlMessageReporter;import com.github.oowekyala.ooxml.messages.XmlMessageReporterBase;import com.github.oowekyala.ooxml.messages.XmlPosition;import com.github.oowekyala.ooxml.messages.XmlPositioner;import com.github.oowekyala.ooxml.messages.XmlSeverity;/** * Entry point to parse a test file. * * @author Clément Fournier */@Experimentalpublic class TestSchemaParser {    private final TestSchemaVersion version;    TestSchemaParser(TestSchemaVersion version) {        this.version = version;    }    public TestSchemaParser() {        this(TestSchemaVersion.V1);    }    /**     * Entry point to parse a test file.     *     * @param rule        Rule which owns the tests     * @param inputSource Where to access the test file to parse     *     * @return A test collection, possibly incomplete     *     * @throws IOException  If parsing throws this     * @throws XmlException If parsing throws this     */    public RuleTestCollection parse(Rule rule, InputSource inputSource) throws IOException, XmlException {        // note: need to explicitly specify the writer here, so that in unit tests        // System.err can be swapped out and in        OoxmlFacade ooxml = new OoxmlFacade().withPrinter(new PrintStreamMessageHandler(System.err));        PositionedXmlDoc doc = ooxml.parse(newDocumentBuilder(), inputSource);        try (PmdXmlReporterImpl err = new PmdXmlReporterImpl(ooxml, doc.getPositioner())) {            RuleTestCollection collection = version.getParserImpl().parseDocument(rule, doc, err);            if (err.hasError()) {                // todo maybe add a way not to throw here                throw new IllegalStateException("Errors were encountered while parsing XML tests");            }            return collection;        }    }    interface PmdXmlReporter extends XmlMessageReporter<Reporter> {        boolean hasError();        PmdXmlReporter newScope();    }    private static class PmdXmlReporterImpl        extends XmlMessageReporterBase<Reporter>        implements PmdXmlReporter {        private boolean hasError;        protected PmdXmlReporterImpl(OoxmlFacade ooxml,                                     XmlPositioner positioner) {            super(ooxml, positioner);        }        @Override        protected Reporter create2ndStage(XmlPosition position, XmlPositioner positioner) {            return new Reporter(position, positioner, ooxml, this::handleEx);        }        @Override        protected void handleEx(XmlException e) {            super.handleEx(e);            hasError |= e.getSeverity() == XmlSeverity.ERROR;        }        @Override        public PmdXmlReporter newScope() {            return new PmdXmlReporterImpl(ooxml, positioner) {                @Override                protected void handleEx(XmlException e) {                    super.handleEx(e);                    PmdXmlReporterImpl.this.hasError |= this.hasError();                }            };        }        @Override        public boolean hasError() {            return hasError;        }    }    private DocumentBuilder newDocumentBuilder() {        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        try {            // don't use the schema as it adds deprecated attributes implicitly...            // dbf.setSchema(version.getSchema());            dbf.setNamespaceAware(true);            return dbf.newDocumentBuilder();        } catch (ParserConfigurationException e) {            throw new RuntimeException(e);        }    }    static final class Reporter {        private final XmlPosition position;        private final XmlPositioner positioner;        private final OoxmlFacade ooxml;        private final Consumer<XmlException> handler;        private Reporter(XmlPosition position, XmlPositioner positioner, OoxmlFacade ooxml, Consumer<XmlException> handler) {            this.position = position;            this.positioner = positioner;            this.ooxml = ooxml;            this.handler = handler;        }        public void warn(String messageFormat, Object... args) {            reportImpl(XmlSeverity.WARNING, MessageFormat.format(messageFormat, args));        }        public void error(String messageFormat, Object... args) {            reportImpl(XmlSeverity.ERROR, MessageFormat.format(messageFormat, args));        }        private void reportImpl(XmlSeverity severity, String formattedMessage) {            NiceXmlMessageSpec spec =                new NiceXmlMessageSpec(position, formattedMessage)                    .withSeverity(severity);            String fullMessage = ooxml.getFormatter().formatSpec(ooxml, spec, positioner);            XmlException ex = new XmlException(spec, fullMessage);            handler.accept(ex);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.test.schema;import java.net.URL;import java.util.Objects;import javax.xml.XMLConstants;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import org.xml.sax.SAXException;/** * Internal for now, there's only one version. * * @author Clément Fournier */enum TestSchemaVersion {    V1("rule-tests_1_0_0.xsd", new BaseTestParserImpl.ParserV1());    private final Schema schema;    private String schemaLoc;    private BaseTestParserImpl parser;    TestSchemaVersion(String schemaLoc, BaseTestParserImpl parser) {        this.schemaLoc = schemaLoc;        this.parser = parser;        this.schema = parseSchema();    }    BaseTestParserImpl getParserImpl() {        return parser;    }    public Schema getSchema() {        return schema;    }    private Schema parseSchema() {        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);        try {            return schemaFactory.newSchema(locateSchema());        } catch (SAXException e) {            throw new RuntimeException("Cannot parse schema " + this, e);        }    }    private URL locateSchema() {        URL resource = TestSchemaVersion.class.getResource(schemaLoc);        return Objects.requireNonNull(resource, "Cannot find schema location " + schemaLoc);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.test.schema;import static org.hamcrest.Matchers.containsString;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertThrows;import java.io.IOException;import java.io.StringReader;import org.hamcrest.MatcherAssert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import org.xml.sax.InputSource;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.PlainTextLanguage;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;/** * @author Clément Fournier */public class TestSchemaParserTest {    @Rule    public final SystemErrRule errStreamCaptor = new SystemErrRule().muteForSuccessfulTests();    @Test    public void testSchemaSimple() throws IOException {        String file = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                      + "<test-data\n"                      + "        xmlns=\"http://pmd.sourceforge.net/rule-tests\"\n"                      + "        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                      + "        xsi:schemaLocation=\"http://pmd.sourceforge.net/rule-tests net/sourceforge/pmd/test/schema/rule-tests_1_0_0.xsd\">\n"                      + "    <test-code>\n"                      + "        <description>equality operators with Double.NaN</description>\n"                      + "        <expected-problems>4</expected-problems>\n"                      + "        <code><![CDATA[\n"                      + "            public class Foo {\n"                      + "            }\n"                      + "            ]]></code>\n"                      + "    </test-code>\n"                      + "    <test-code>\n"                      + "        <description>equality operators with Float.NaN</description>\n"                      + "        <expected-problems>4</expected-problems>\n"                      + "        <code><![CDATA[\n"                      + "            public class Foo {\n"                      + "            }\n"                      + "            ]]></code>\n"                      + "    </test-code>\n"                      + "</test-data>\n";        RuleTestCollection parsed = parseFile(file);        assertEquals(2, parsed.getTests().size());    }    @Test    public void testSchemaDeprecatedAttr() throws IOException {        String file = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                      + "<test-data\n"                      + "        xmlns=\"http://pmd.sourceforge.net/rule-tests\"\n"                      + "        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                      + "        xsi:schemaLocation=\"http://pmd.sourceforge.net/rule-tests net/sourceforge/pmd/test/schema/rule-tests_1_0_0.xsd\">\n"                      + "    <test-code regressionTest='false'>\n"                      + "        <description>equality operators with Double.NaN</description>\n"                      + "        <expected-problems>4</expected-problems>\n"                      + "        <code><![CDATA[\n"                      + "            public class Foo {\n"                      + "            }\n"                      + "            ]]></code>\n"                      + "    </test-code>\n"                      + "</test-data>\n";        errStreamCaptor.enableLog();        RuleTestCollection parsed = parseFile(file);        assertEquals(1, parsed.getTests().size());        MatcherAssert.assertThat(errStreamCaptor.getLog(), containsString(" 6|     <test-code regressionTest='false'>\n"                                                                          + "                   ^^^^^^^^^^^^^^ Attribute 'regressionTest' is deprecated, use 'disabled' with inverted value\n"));    }    @Test    public void testUnknownProperty() throws IOException {        String file = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                + "<test-data\n"                + "        xmlns=\"http://pmd.sourceforge.net/rule-tests\"\n"                + "        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "        xsi:schemaLocation=\"http://pmd.sourceforge.net/rule-tests net/sourceforge/pmd/test/schema/rule-tests_1_0_0.xsd\">\n"                + "    <test-code>\n"                + "        <description>equality operators with Double.NaN</description>\n"                + "        <rule-property name='invalid_property'>foo</rule-property>\n"                + "        <expected-problems>0</expected-problems>\n"                + "        <code><![CDATA[\n"                + "            public class Foo {\n"                + "            }\n"                + "            ]]></code>\n"                + "    </test-code>\n"                + "</test-data>\n";        errStreamCaptor.enableLog();        assertThrows(IllegalStateException.class, () -> parseFile(file));        MatcherAssert.assertThat(errStreamCaptor.getLog(), containsString("  8|         <rule-property name='invalid_property'>foo</rule-property>\n"              + "                            ^^^^ Unknown property, known property names are violationSuppressRegex, violationSuppressXPath\n"));    }    private RuleTestCollection parseFile(String file) throws IOException {        MockRule mockRule = new MockRule();        mockRule.setLanguage(PlainTextLanguage.getInstance());        InputSource is = new InputSource();        is.setSystemId("a/file.xml");        is.setCharacterStream(new StringReader(file));        return new TestSchemaParser().parse(mockRule, is);    }    public static final class MockRule extends AbstractRule {        @Override        public void apply(Node target, RuleContext ctx) {            // do nothing        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestAccessEvaluator.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import java.util.HashSet;import java.util.Objects;import java.util.Set;import apex.jorje.semantic.compiler.Namespace;import apex.jorje.semantic.compiler.StructuredVersion;import apex.jorje.semantic.compiler.sfdc.AccessEvaluator;import apex.jorje.semantic.compiler.sfdc.PlaceholderOrgPerm;import apex.jorje.semantic.symbol.type.SObjectTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfoImpl;import apex.jorje.semantic.symbol.type.TypeInfo;import com.google.common.collect.HashMultimap;import com.google.common.collect.Iterables;import com.google.common.collect.SetMultimap;/** * For now everything returns false. * If you actually need to override something, it would be easier to probably mock and adjust what you needed. * Otherwise this is simply to create a concrete representation and not force a mockito init. * * @author jspagnola */class TestAccessEvaluator implements AccessEvaluator {    private final SetMultimap<Namespace, StructuredVersion> validPageVersions;    private final SetMultimap<SObjectTypeInfo, TypeInfo> visibleSetupEntitiesToTypes;    private final Set<Namespace> accessibleSystemNamespaces;    private final Set<PlaceholderOrgPerm> orgPerm;    private final Set<AllowedPermGuard> allowedPermGuards;    private final Set<Namespace> reservedNamespaces;    private final Set<String> globalComponents;    private final Set<Namespace> managedPackagesNotInstalled;    private final Set<String> typesWithConnectApiDeserializers;    private boolean hasInternalSfdc;    private boolean isRunningTests;    private boolean hasPrivateApi;    private boolean isTrustedApplication;    private boolean hasLocalizedTranslation;    private boolean isSfdc;    private boolean isReallyRunningTests;    private boolean hasApexGenericTypes;    private boolean hasRemoteActionPerm;    private boolean hasPersonAccountApiAvailable;    TestAccessEvaluator() {        validPageVersions = HashMultimap.create();        visibleSetupEntitiesToTypes = HashMultimap.create();        managedPackagesNotInstalled = new HashSet<>();        accessibleSystemNamespaces = new HashSet<>();        orgPerm = new HashSet<>();        allowedPermGuards = new HashSet<>();        reservedNamespaces = new HashSet<>();        globalComponents = new HashSet<>();        typesWithConnectApiDeserializers = new HashSet<>();        hasRemoteActionPerm = true;        hasPersonAccountApiAvailable = true;    }    @Override    public boolean hasPermission(final PlaceholderOrgPerm orgPerm) {        return this.orgPerm.contains(orgPerm);    }    @Override    public boolean hasPermissionForPermGuard(final Namespace referencingNamespace, final String orgPerm) {        return allowedPermGuards.contains(new AllowedPermGuard(referencingNamespace, orgPerm));    }    @Override    public boolean hasPersonAccountApiAvailable() {        return hasPersonAccountApiAvailable;    }    @Override    public boolean hasPrivateApi() {        return hasPrivateApi;    }    @Override    public boolean hasLocalizedTranslation() {        return hasLocalizedTranslation;    }    @Override    public boolean hasInternalSfdc() {        return hasInternalSfdc;    }    @Override    public boolean isTrustedApplication(TypeInfo arg0) {        return isTrustedApplication;    }    @Override    public boolean isReservedNamespace(final Namespace namespace) {        return reservedNamespaces.contains(namespace);    }    @Override    public boolean isReservedNamespace(final Namespace namespace, final boolean excludePackages) {        return reservedNamespaces.contains(namespace);    }    /**     * See {@link #isAccessibleOrTrustedNamespace(Namespace)}     */    @Override    public boolean isAccessibleSystemNamespace(final Namespace namespace) {        return accessibleSystemNamespaces.contains(namespace);    }    /**     * Okay so this check and its partner isAccessibleSystemNamespace are used slightly differently.     * This is like a black list check, that prevents referencing code from seeing things in a reserved namespace.     * The other check allows code to see certain things if the code's namespace is a reserved namespace.     * <p>     * Hence here we return true by default, and the {@link #isAccessibleSystemNamespace(Namespace)} returns false     * by default.     */    @Override    public boolean isAccessibleOrTrustedNamespace(final Namespace namespace) {        return true;    }    @Override    public boolean isRunningTests() {        return isRunningTests;    }    @Override    public boolean isReallyRunningTests() {        return isReallyRunningTests;    }    @Override    public boolean isSfdc() {        return isSfdc;    }    @Override    public boolean hasApexParameterizedTypes() {        return hasApexGenericTypes;    }    @Override    public boolean isValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        return validPageVersions.containsEntry(namespace, version);    }    /**     * @return 'true' for everything EXCEPT namespaces you've added through {@link #addManagedPackageNotInstalled(Namespace)}     */    @Override    public boolean isManagedPackageInstalled(final Namespace namespace) {        return !managedPackagesNotInstalled.contains(namespace);    }    @Override    public boolean isSetupEntityVisibleToType(final SObjectTypeInfo type, final TypeInfo referencingType) {        final TypeInfo visibleReferencingType = Iterables.getFirst(visibleSetupEntitiesToTypes.get(type), null);        return visibleReferencingType != null            && visibleReferencingType.getBytecodeName().equals(referencingType.getBytecodeName());    }    @Override    public boolean hasConnectDeserializer(final TypeInfo type) {        return typesWithConnectApiDeserializers.contains(type.getApexName());    }    @Override    public boolean hasRemoteAction(final TypeInfo type) {        return false;    }    @Override    public boolean hasRemoteActionPerm() {        return hasRemoteActionPerm;    }    @Override    public boolean isGlobalComponent(final TypeInfo type) {        return globalComponents.contains(type.getApexName());    }    /**     * Things isManagedPackageInstalled will say 'false' to.     */    public TestAccessEvaluator addManagedPackageNotInstalled(final Namespace namespace) {        managedPackagesNotInstalled.add(namespace);        return this;    }    public TestAccessEvaluator addReservedNamespace(final Namespace namespace) {        reservedNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator addPermission(final PlaceholderOrgPerm orgPerm) {        this.orgPerm.add(orgPerm);        return this;    }    public TestAccessEvaluator setHasInternalSfdc(final boolean hasInternalSfdc) {        this.hasInternalSfdc = hasInternalSfdc;        return this;    }    public TestAccessEvaluator addValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        validPageVersions.put(namespace, version);        return this;    }    public TestAccessEvaluator addSetupEntityVisibleToType(        final SObjectTypeInfo type,        final String typeName    ) {        final StandardTypeInfo typeInfo = StandardTypeInfoImpl.builder()            .setApexName(typeName)            .setBytecodeName(typeName)            .buildResolved();        visibleSetupEntitiesToTypes.put(type, typeInfo);        return this;    }    public TestAccessEvaluator setIsRunningTests(final boolean isRunningTests) {        this.isRunningTests = isRunningTests;        return this;    }    public TestAccessEvaluator setHasPrivateApi(final boolean hasPrivateApi) {        this.hasPrivateApi = hasPrivateApi;        return this;    }    public TestAccessEvaluator setIsTrustedApplication(final boolean isTrustedApplication) {        this.isTrustedApplication = isTrustedApplication;        return this;    }    public TestAccessEvaluator setHasLocalizedTranslation(final boolean hasLocalizedTranslation) {        this.hasLocalizedTranslation = hasLocalizedTranslation;        return this;    }    public TestAccessEvaluator setIsSfdc(final boolean isSfdc) {        this.isSfdc = isSfdc;        return this;    }    public TestAccessEvaluator setIsReallyRunningTests(final boolean isReallyRunningTests) {        this.isReallyRunningTests = isReallyRunningTests;        return this;    }    public TestAccessEvaluator setAccessibleSystemNamespace(final Namespace namespace) {        accessibleSystemNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator setHasApexGenericType(final boolean hasApexGenericTypes) {        this.hasApexGenericTypes = hasApexGenericTypes;        return this;    }    public TestAccessEvaluator allowPermGuard(final Namespace namespace, final String permGuard) {        allowedPermGuards.add(new AllowedPermGuard(namespace, permGuard));        return this;    }    /**     * It appears that remote action is enabled by default in most orgs, at least test orgs.     * So we will behave the same.     */    public TestAccessEvaluator setHasRemoteActionPerm(final boolean hasRemoteActionPerm) {        this.hasRemoteActionPerm = hasRemoteActionPerm;        return this;    }    public TestAccessEvaluator setTypeWithConnectApiDeserializer(final String typeName) {        typesWithConnectApiDeserializers.add(typeName);        return this;    }    public void setGlobalComponent(final String globalComponent) {        globalComponents.add(globalComponent);    }    private static class AllowedPermGuard {        private final Namespace referencingNamespace;        private final String permGuard;        AllowedPermGuard(final Namespace namespace, final String permGuard) {            referencingNamespace = namespace;            this.permGuard = permGuard;        }        @Override        public int hashCode() {            return Objects.hash(referencingNamespace, permGuard);        }        @Override        public boolean equals(final Object obj) {            if (this == obj) {                return true;            }            if (obj == null || getClass() != obj.getClass()) {                return false;            }            final AllowedPermGuard other = (AllowedPermGuard) obj;            return Objects.equals(referencingNamespace, other.referencingNamespace)                && Objects.equals(permGuard, other.permGuard);        }    }    @Override    public boolean isSecondGenerationPackagingNamespace(Namespace namespace) {        return false;    }    @Override    public boolean useTestValueForAnonymousScriptLengthLimit() {        return false;    }    @Override    public boolean hasNamespaceGuardedAccess(Namespace namespace, String arg1) {        return false;    }    @Override    public boolean isNamespaceGuardNamespace(Namespace arg0) {        return false;    }    @Override    public boolean doesLightningWebComponentExist(String var1) {        return false;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestQueryValidators.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import apex.jorje.semantic.ast.expression.SoqlExpression;import apex.jorje.semantic.ast.expression.SoslExpression;import apex.jorje.semantic.ast.visitor.ValidationScope;import apex.jorje.semantic.compiler.sfdc.QueryValidator;import apex.jorje.semantic.symbol.resolver.SymbolResolver;/** * The test query validators will return back the query it was given. The real implementation actually creates its own * query. * * @author jspagnola */@SuppressWarnings("PMD.MissingStaticMethodInNonInstantiatableClass") // this class provides utility classesfinal class TestQueryValidators {    private TestQueryValidators() {    }    public static class Noop implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope typeInfo,            final SoslExpression sosl        ) {            return sosl.getCanonicalQuery();        }    }    public static class Error implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            scope.getErrors().markInvalid(soql, "Bad Soql");            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope scope,            final SoslExpression sosl        ) {            scope.getErrors().markInvalid(sosl, "Bad Sosl");            return sosl.getCanonicalQuery();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.metrics.impl;import net.sourceforge.pmd.lang.apex.ast.ApexQualifiableNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clément Fournier */class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/apex/metrics_test.xml";    @Override    public void setUp() {        addRule(RULESET, "CycloTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "CognitiveComplexityTest");    }    static String formatApexMessage(Node node, Integer result, String defaultMessage) {        if (node instanceof ApexQualifiableNode) {            return "''" + ((ApexQualifiableNode) node).getQualifiedName() + "'' has value " + result + ".";        }        return defaultMessage;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.multifile;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsStringIgnoringCase;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.util.IOUtil;import com.github.stefanbirkner.systemlambda.SystemLambda;class ApexMultifileAnalysisTest {    @TempDir    private Path tempFolder;    @Test    void testNoSfdxProjectJsonProducesFailedAnalysis() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            ApexMultifileAnalysis analysisInstance = getAnalysisForTempFolder();            assertTrue(analysisInstance.isFailed());            assertTrue(analysisInstance.getFileIssues("any file").isEmpty());        });        assertThat(log, containsStringIgnoringCase("Missing project file"));    }    @Test    void testMalformedSfdxProjectJsonProducesFailedAnalysis() throws Exception {        copyResource("malformedSfdxFile.json", "sfdx-project.json");        String log = SystemLambda.tapSystemErr(() -> {            ApexMultifileAnalysis analysisInstance = getAnalysisForTempFolder();            assertTrue(analysisInstance.isFailed());            assertTrue(analysisInstance.getFileIssues("any file").isEmpty());        });        assertThat(log,                containsStringIgnoringCase("error: 'path' is required for all 'packageDirectories' elements"));    }    @Test    void testWellFormedSfdxProjectJsonProducesFunctionalAnalysis() throws Exception {        copyResource("correctSfdxFile.json", "sfdx-project.json");        String log = SystemLambda.tapSystemErr(() -> {            ApexMultifileAnalysis analysisInstance = getAnalysisForTempFolder();            assertFalse(analysisInstance.isFailed());        });        assertTrue(log.isEmpty());    }    private @NonNull ApexMultifileAnalysis getAnalysisForTempFolder() {        return ApexMultifileAnalysis.getAnalysisInstance(tempFolder.toAbsolutePath().toString());    }    private void copyResource(String resourcePath, String relativePathInTempDir) throws IOException {        Path file = tempFolder.resolve(relativePathInTempDir);        String fileContents = IOUtil.readToString(getClass().getResourceAsStream(resourcePath), StandardCharsets.UTF_8);        Files.write(file, Arrays.asList(fileContents.split("\\R").clone()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexBadCryptoTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexXSSFromURLParamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexCRUDViolationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexInsecureEndpointTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexXSSFromEscapeFalseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.MethodSource;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;/** * <p>Sharing settings are not inherited by inner classes. Sharing settings need to be declared on the class that * contains the Database method, DML, SOQL, or SOSL.</p> * * <p>This test runs against Apex code that has an Outer class and and Inner class. Different Apex code is generated * based on the boolean permutations. Any classes that includes data access cod, but doesn't declare a sharing setting * should trigger a violation.</p> */class ApexSharingViolationsNestedClassTest extends ApexParserTestBase {    /**     * Type of operation that may require a sharing declaration.     */    private enum Operation {        NONE(null),        DML_DELETE("Contact c = new Contact(); delete c;"),        DML_INSERT("Contact c = new Contact(); insert c;"),        DML_MERGE("Contact c1 = new Contact(); Contact c2 = new Contact(); merge c1 c2;"),        DML_UNDELETE("Contact c = new Contact(); undelete c;"),        DML_UPDATE("Contact c = new Contact(); update c;"),        DML_UPSERT("Contact c = new Contact(); upsert c;"),        METHOD_DATABASE("Database.query('Select Id from Contact LIMIT 100');"),        SOQL("[SELECT Name FROM Contact];"),        SOSL("[FIND 'Foo' IN ALL FIELDS RETURNING Account(Name)];");        final boolean requiresSharingDeclaration;        final String codeSnippet;        Operation(String codeSnippet) {            this.requiresSharingDeclaration = codeSnippet != null;            this.codeSnippet = codeSnippet;        }    }    /**     * The permutations used for class generation. See {@link #generateClass(boolean, Operation, boolean, Operation)}     */    @ParameterizedTest    @MethodSource("data")    void testSharingPermutation(boolean outerSharingDeclared, Operation outerOperation,                                boolean innerSharingDeclared, Operation innerOperation,                                int expectedViolations, List<Integer> expectedLineNumbers) {        String apexClass = generateClass(outerSharingDeclared, outerOperation, innerSharingDeclared, innerOperation);        ApexSharingViolationsRule rule = new ApexSharingViolationsRule();        rule.setMessage("a message");        Report rpt = apex.executeRule(rule, apexClass);        List<RuleViolation> violations = rpt.getViolations();        assertEquals(expectedViolations, violations.size(), "Unexpected Violation Size\n" + apexClass);        List<Integer> lineNumbers = violations.stream().map(v -> v.getBeginLine()).collect(Collectors.toList());        assertEquals(expectedLineNumbers, lineNumbers, "Unexpected Line Numbers\n" + apexClass);    }    /**     * Parameter provider that covers are all permutations     */    static Collection<?> data() {        List<Object[]> data = new ArrayList<>();        boolean[] boolPermutations = {false, true};        for (boolean outerSharingDeclared : boolPermutations) {            for (Operation outerOperation : Operation.values()) {                for (boolean innerSharingDeclared : boolPermutations) {                    for (Operation innerOperation : Operation.values()) {                        int expectedViolations = 0;                        List<Integer> expectedLineNumbers = new ArrayList<>();                        if (outerOperation.requiresSharingDeclaration && !outerSharingDeclared) {                            // The outer class contains SOQL but doesn't declare sharing                            expectedViolations++;                            expectedLineNumbers.add(1);                        }                        if (innerOperation.requiresSharingDeclaration && !innerSharingDeclared) {                            // The inner class contains SOQL but doesn't declare sharing                            expectedViolations++;                            // The location of the inner class declaration depends upon the content of the outer class                            expectedLineNumbers.add(outerOperation.requiresSharingDeclaration ? 3 : 2);                        }                        data.add(new Object[]{outerSharingDeclared, outerOperation, innerSharingDeclared, innerOperation,                                              expectedViolations, expectedLineNumbers});                    }                }            }        }        return data;    }    /**     * <p>Generate an Apex class with various Sharing/Database/DML/SOQL/SOSL permutations. An example of the class     * returned when invoked with generateClass(true, SOQL, true, SOQL).</p>     *     * <pre>     * public with sharing class Outer {     *    public void outerSOQL() {[SELECT Name FROM Contact];}     *    public with sharing class Inner {     *       public void innerSOQL() {[SELECT Name FROM Contact];}     *    }     * }     * </pre>     *     * @param outerSharing Add 'with sharing' to Outer class definition     * @param outerOperation Add a method to Outer class that performs the given operation     * @param innerSharing Add 'with sharing' to Inner class definition     * @param innerOperation Add a method to Inner class that performs the given operation     * @return String that represents Apex code     */    private static String generateClass(boolean outerSharing, Operation outerOperation, boolean innerSharing,                                        Operation innerOperation) {        StringBuilder sb = new StringBuilder();        sb.append("public ");        if (outerSharing) {            sb.append("with sharing ");        }        sb.append("class Outer {\n");        switch (outerOperation) {        case NONE:            // Do nothing            break;        default:            sb.append(String.format("\t\tpublic void outer%s(){ %s }\n", outerOperation.name(), outerOperation.codeSnippet));            break;        }        sb.append("\tpublic ");        if (innerSharing) {            sb.append("with sharing ");        }        sb.append("class Inner {\n");        switch (innerOperation) {        case NONE:            // DO Nothing            break;        default:            sb.append(String.format("\t\tpublic void inner%s(){ %s }\n", innerOperation.name(), innerOperation.codeSnippet));            break;        }        sb.append("\t}\n"); // Closes class Inner        sb.append("}\n"); // Closes class Outer        return sb.toString();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexSOQLInjectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexOpenRedirectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexSuggestUsingNamedCredTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexDangerousMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexSharingViolationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyTryOrFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidNonExistentAnnotationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexCSRFTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class TestMethodsMustBeInTestClassesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDirectAccessTriggerMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidHardcodingIdTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;class InaccessibleAuraEnabledGetterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class CognitiveComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NcssConstructorCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NcssTypeCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidSoqlInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDebugStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class OperationWithLimitsInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class EagerlyLoadedDescribeSObjectResultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidDmlStatementsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidSoslInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexDocTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FieldDeclarationsShouldBeAtStartTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class PropertyNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidLogicInTriggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexUnitTestClassShouldHaveAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class AvoidGlobalModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexUnitTestMethodShouldHaveIsTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class ApexUnitTestShouldNotUseSeeAllDataTrueTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;class DebugsShouldUseLoggingLevelTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestClassShouldHaveRunAsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.apex.ast.ASTAnonymousClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;import net.sourceforge.pmd.lang.apex.ast.ASTUserInterface;import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;class AbstractApexRuleTest extends ApexParserTestBase {    @Test    void shouldVisitTopLevelClass() {        run("class Foo { }");    }    @Test    void shouldVisitTopLevelInterface() {        run("interface Foo { }");    }    @Test    void shouldVisitTopLevelTrigger() {        run("trigger Foo on Account (before insert, before update) { }");    }    @Test    void shouldVisitTopLevelEnum() {        run("enum Foo { }");    }    private void run(String code) {        TopLevelRule rule = new TopLevelRule();        Report report = apex.executeRule(rule, code);        TestUtilsKt.assertSize(report, 1);    }    private static class TopLevelRule extends AbstractApexRule {        @Override        public String getMessage() {            return "a message";        }        @Override        public Object visit(ASTUserClass node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserInterface node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserTrigger node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserEnum node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTAnonymousClass node, Object data) {            addViolation(data, node);            return data;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.rule.XPathRule;/** * @author daniels */class ApexXPathRuleTest extends ApexParserTestBase {    private XPathRule makeXPath(String expression) {        return apex.newXpathRule(expression);    }    @Test    void testFileNameInXpath() {        Report report = apex.executeRule(makeXPath("/UserClass[pmd:fileName() = 'Foo.cls']"),                                         "class Foo {}",                                         "src/Foo.cls");        assertSize(report, 1);    }    @Test    void testBooleanExpressions() {        Report report = apex.executeRuleOnResource(makeXPath("//BooleanExpression[@Operator='&&']"),                                                   "BooleanExpressions.cls");        assertSize(report, 1);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;class ASTUserEnumTest extends ApexParserTestBase {    @Test    void testEnumName() {        ASTUserClass node = (ASTUserClass) parse("class Foo { enum Bar { } }");        ASTUserEnum enumNode = node.descendants(ASTUserEnum.class).firstOrThrow();        assertEquals("Bar", enumNode.getSimpleName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertThrows;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.ParseException;class ApexCompilerTest extends ApexParserTestBase {    @Test    void compileShouldFail() {        assertThrows(ParseException.class, () -> apex.parse("public class Foo { private String myField = \"a\"; }"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertSame;import java.util.Arrays;import org.junit.jupiter.api.Test;class ASTUserTriggerTest extends ApexParserTestBase {    @Test    void testTriggerName() {        ApexNode<?> node = parse("trigger HelloWorldTrigger on Book__c (before insert, after update) {\n"                + "   Book__c[] books = Trigger.new;\n" + "   MyHelloWorld.applyDiscount(books);\n" + "}\n");        assertSame(ASTUserTrigger.class, node.getClass());        assertEquals("HelloWorldTrigger", node.getImage());        ASTUserTrigger trigger = (ASTUserTrigger) node;        assertEquals("Book__c", trigger.getTargetName());        assertEquals(Arrays.asList(TriggerUsage.AFTER_UPDATE, TriggerUsage.BEFORE_INSERT), trigger.getUsages());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.Arrays;import org.junit.jupiter.api.Test;class ASTUserClassTest extends ApexParserTestBase {    @Test    void testClassName() {        ASTUserClass node = (ASTUserClass) parse("class Foo { }");        assertEquals("Foo", node.getSimpleName());    }    @Test    void testInnerClassName() {        ASTUserClass foo = (ASTUserClass) parse("class Foo { class Bar { } }");        ASTUserClass innerNode = foo.descendants(ASTUserClass.class).firstOrThrow();        assertEquals("Bar", innerNode.getSimpleName());    }    @Test    void testSuperClassName() {        ASTUserClass toplevel = (ASTUserClass) parse("public class AccountTriggerHandler extends TriggerHandler {}");        assertEquals("TriggerHandler", toplevel.getSuperClassName());    }    @Test    void testSuperClassName2() {        ASTUserClass toplevel = (ASTUserClass) parse("public class AccountTriggerHandler extends Other.TriggerHandler {}");        assertEquals("Other.TriggerHandler", toplevel.getSuperClassName());    }    @Test    void testInterfaces() {        ASTUserClass toplevel = (ASTUserClass) parse("public class AccountTriggerHandler implements TriggerHandler, Other.Interface2 {}");        assertEquals(Arrays.asList("TriggerHandler", "Other.Interface2"), toplevel.getInterfaceNames());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import org.junit.jupiter.api.Test;class ASTTryCatchFinallyBlockStatementTest extends ApexParserTestBase {    @Test    void testTryFinally() {        ApexNode<?> node = parse("class Foo { void bar() { try { methodCall(); } finally { methodCall(); } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        assertNotNull(statement.getTryBlock());        assertEquals(0, statement.getTryBlock().getIndexInParent());        assertNotNull(statement.getFinallyBlock());        assertEquals(1, statement.getFinallyBlock().getIndexInParent());        assertEquals(0, statement.getCatchClauses().size());    }    @Test    void testTryCatch() {        ApexNode<?> node = parse("class Foo { void bar() { try { methodCall(); } catch (Exception e) { methodCall(); } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        assertNotNull(statement.getTryBlock());        assertEquals(0, statement.getTryBlock().getIndexInParent());        assertNull(statement.getFinallyBlock());        assertEquals(1, statement.getCatchClauses().size());        assertNotNull(statement.getCatchClauses().get(0).getBody());        assertEquals(1, statement.getCatchClauses().get(0).getIndexInParent());    }    @Test    void testTryCatchFinally() {        ApexNode<?> node = parse("class Foo { void bar() { try { methodCall(); } catch (Exception e) { methodCall(); } finally { } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        assertNotNull(statement.getTryBlock());        assertEquals(0, statement.getTryBlock().getIndexInParent());        assertNotNull(statement.getFinallyBlock());        assertEquals(2, statement.getFinallyBlock().getIndexInParent());        assertEquals(1, statement.getCatchClauses().size());        assertNotNull(statement.getCatchClauses().get(0).getBody());        assertEquals(1, statement.getCatchClauses().get(0).getIndexInParent());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;class ApexTreeDumpTest extends BaseTreeDumpTest {    ApexTreeDumpTest() {        super(new RelevantAttributePrinter(), ".cls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return ApexParsingHelper.DEFAULT;    }    @Test    void safeNavigationOperator() {        doTest("SafeNavigationOperator");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNull;import org.junit.jupiter.api.Test;class ASTFieldTest extends ApexParserTestBase {    @Test    void testGetType() {        ASTField field = parse("public class Foo { private String myField = 'a'; }")            .descendants(ASTField.class).firstOrThrow();        assertEquals("myField", field.getImage());        assertEquals("String", field.getType());        assertEquals("a", field.getValue());    }    @Test    void testGetValue() {        ASTField field = parse("public class Foo { private String myField = 'a'; }")            .descendants(ASTField.class).firstOrThrow();        assertEquals("a", field.getValue());    }    @Test    void testGetNoValue() {        ASTField field = parse("public class Foo { private String myField; }")            .descendants(ASTField.class).firstOrThrow();        assertNull(field.getValue());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;class ASTSwitchStatementTest extends ApexParserTestBase {    @Test    void testExamples() {        ApexNode<?> node = parseResource("SwitchStatements.cls");        List<ASTSwitchStatement> switchStatements = node.findDescendantsOfType(ASTSwitchStatement.class);        assertEquals(4, switchStatements.size());        assertTrue(switchStatements.get(0).getChild(0) instanceof ASTVariableExpression);        assertEquals(5, switchStatements.get(0).findChildrenOfType(ASTValueWhenBlock.class).size());        assertEquals(3, switchStatements.get(0).findChildrenOfType(ASTValueWhenBlock.class)            .get(1).findChildrenOfType(ASTLiteralCase.class).size());        assertEquals(1, switchStatements.get(0).findChildrenOfType(ASTElseWhenBlock.class).size());        assertTrue(switchStatements.get(1).getChild(0) instanceof ASTMethodCallExpression);        assertEquals(2, switchStatements.get(1).findChildrenOfType(ASTValueWhenBlock.class).size());        assertEquals(1, switchStatements.get(1).findChildrenOfType(ASTElseWhenBlock.class).size());        assertTrue(switchStatements.get(2).getChild(0) instanceof ASTVariableExpression);        assertEquals(2, switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class).size());        assertEquals("Account", switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class)            .get(0).getType());        assertEquals("a", switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class)            .get(0).getName());        assertEquals(1, switchStatements.get(2).findChildrenOfType(ASTValueWhenBlock.class).size());        assertEquals(1, switchStatements.get(2).findChildrenOfType(ASTElseWhenBlock.class).size());        assertTrue(switchStatements.get(3).getChild(0) instanceof ASTVariableExpression);        assertEquals(2, switchStatements.get(3).findChildrenOfType(ASTValueWhenBlock.class).size());        assertEquals(1, switchStatements.get(3).findChildrenOfType(ASTElseWhenBlock.class).size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;class ApexCommentTest extends ApexParserTestBase {    @Test    public void testContainsComment1() {        ASTApexFile file = apex.parse("class Foo {void foo(){try {\n"                                          + "} catch (Exception e) {\n"                                          + "  /* OK: block comment inside of empty catch block; should not be reported */\n"                                          + "}}}");        ASTCatchBlockStatement catchBlock = file.descendants(ASTCatchBlockStatement.class).crossFindBoundaries().firstOrThrow();        assertTrue(catchBlock.getContainsComment());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import org.antlr.runtime.ANTLRStringStream;import org.antlr.runtime.CharStream;import org.antlr.runtime.CommonTokenStream;import org.antlr.runtime.Token;import org.junit.jupiter.api.Test;import apex.jorje.data.ast.CompilationUnit;import apex.jorje.parser.impl.ApexLexer;import apex.jorje.parser.impl.ApexParser;class ApexLexerTest {    private static final String CODE = "public class Foo {\n"            + "   public List<SObject> test1() {\n"            + "       return Database.query(\"Select Id from Account LIMIT 100\");\n"            + "   }\n"            + "}\n";    @Test    void testLexer() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        Token token = lexer.nextToken();        int tokenCount = 0;        while (token.getType() != Token.EOF) {            tokenCount++;            token = lexer.nextToken();        }        assertEquals(43, tokenCount);    }    @Test    void testParser() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        ApexParser parser = new ApexParser(new CommonTokenStream(lexer));        CompilationUnit compilationUnit = parser.compilationUnit();        assertNotNull(compilationUnit);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.jupiter.api.Test;class ApexCompilerSoqlTest extends ApexParserTestBase {    private static final String CODE = "public class Foo {\n"        + "   public List<SObject> test1() {\n"        + "       return Database.query(\'Select Id from Account LIMIT 100\');\n"        + "   }\n"        + "}\n";    @Test    void testSoqlCompilation() {        apex.parse(CODE);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;class ASTSoqlExpressionTest extends ApexParserTestBase {    @Test    void testQuery() {        ApexNode<?> root = parse("class Foo { void test1() { Account acc = [SELECT col FROM Account]; } }");        ASTSoqlExpression soqlExpression = root.descendants(ASTSoqlExpression.class).firstOrThrow();        assertEquals("SELECT col FROM Account", soqlExpression.getQuery());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;class ASTNewKeyValueObjectExpressionTest extends ApexParserTestBase {    @Test    void testParameterName() {        ASTUserClassOrInterface<?> node = parse("public class Foo { \n"                + "    public void foo(String newName, String tempID) { \n"                + "        if (Contact.sObjectType.getDescribe().isCreateable() && Contact.sObjectType.getDescribe().isUpdateable()) {\n"                + "            upsert new Contact(FirstName = 'First', LastName = 'Last', Phone = '414-414-4414');\n"                + "        }\n" + "    } \n" + "}");        ASTNewKeyValueObjectExpression keyValueExpr = node.getFirstDescendantOfType(ASTNewKeyValueObjectExpression.class);        assertEquals(3, keyValueExpr.getParameterCount());        List<ASTLiteralExpression> literals = keyValueExpr.findDescendantsOfType(ASTLiteralExpression.class);        assertEquals(3, literals.size());        assertEquals("FirstName", literals.get(0).getName());        assertEquals("LastName", literals.get(1).getName());        assertEquals("Phone", literals.get(2).getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertNotEquals;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.List;import org.junit.jupiter.api.Test;/** * @author Clément Fournier */class ApexQualifiedNameTest extends ApexParserTestBase {    @Test    void testClass() {        ASTUserClass root = (ASTUserClass) parse("public class Foo {}");        ApexQualifiedName qname = root.getQualifiedName();        assertEquals("c__Foo", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    void testNestedClass() {        ASTUserClass root = (ASTUserClass) parse("public class Foo { class Bar {}}");        ASTUserClass inner = root.descendants(ASTUserClass.class).firstOrThrow();        ApexQualifiedName qname = inner.getQualifiedName();        assertEquals("c__Foo.Bar", qname.toString());        assertEquals(2, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    void testSimpleMethod() {        ASTUserClass root = (ASTUserClass) parse("public class Foo { String foo() {}}");        ApexQualifiedName qname = root.descendants(ASTMethod.class).firstOrThrow().getQualifiedName();        assertEquals("c__Foo#foo()", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo()", qname.getOperation());    }    @Test    void testMethodWithArguments() {        ASTUserClass root = (ASTUserClass) parse("public class Foo { String foo(String h, Foo g) {}}");        ApexQualifiedName qname = root.descendants(ASTMethod.class).firstOrThrow().getQualifiedName();        assertEquals("c__Foo#foo(String, Foo)", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo(String, Foo)", qname.getOperation());    }    @Test    void testOverLoads() {        ASTUserClass root = (ASTUserClass) parse("public class Foo { "                                                                 + "String foo(String h) {} "                                                                 + "String foo(int c) {}"                                                                 + "String foo(Foo c) {}}");        for (ASTMethod m1 : root.descendants(ASTMethod.class)) {            for (ASTMethod m2 : root.descendants(ASTMethod.class)) {                if (m1 != m2) {                    assertNotEquals(m1.getQualifiedName(), m2.getQualifiedName());                }            }        }    }    @Test    void testTrigger() {        ASTUserTrigger root = (ASTUserTrigger) parse("trigger myAccountTrigger on Account (before insert, before update) {}");        ASTMethod m = root.descendants(ASTMethod.class).firstOrThrow();        assertEquals("c__trigger.Account#myAccountTrigger", m.getQualifiedName().toString());    }    @Test    public void testUnqualifiedEnum() {        ASTUserEnum root = (ASTUserEnum) parse("public enum primaryColor { RED, YELLOW, BLUE }");        ApexQualifiedName enumQName = root.getQualifiedName();        List<ASTMethod> methods = root.descendants(ASTMethod.class).toList();        assertEquals("c__primaryColor", enumQName.toString());        for (ASTMethod m : methods) {            assertTrue(m.getQualifiedName().toString().startsWith("c__primaryColor#"));        }    }    @Test    public void testQualifiedEnum() {        ASTUserClass root = (ASTUserClass) parse("public class Outer { public enum Inner { OK } }");        ASTUserEnum enumNode = root.descendants(ASTUserEnum.class).firstOrThrow();        ApexQualifiedName enumQName = enumNode.getQualifiedName();        List<ASTMethod> methods = enumNode.descendants(ASTMethod.class).toList();        assertEquals("c__Outer.Inner", enumQName.toString());        for (ASTMethod m : methods) {            assertTrue(m.getQualifiedName().toString().startsWith("c__Outer.Inner#"));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.ast.test.NodeExtensionsKt.textOfReportLocation;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertPosition;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.core.IsInstanceOf.instanceOf;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.document.FileLocation;import net.sourceforge.pmd.util.IOUtil;class ApexParserTest extends ApexParserTestBase {    @Test    void understandsSimpleFile() {        // Setup        String code = "@isTest\n"            + " public class SimpleClass {\n"            + "    @isTest\n public static void testAnything() {\n"            + "        \n"            + "    }\n"            + "}";        // Exercise        ASTUserClassOrInterface<?> rootNode = parse(code);        // Verify        List<ASTMethod> methods = rootNode.findDescendantsOfType(ASTMethod.class);        assertEquals(4, methods.size());    }    @Test    void fileName() {        String code = "class Outer { class Inner {}}";        ASTUserClass rootNode = (ASTUserClass) parse(code, "src/filename.cls");        assertEquals("src/filename.cls", rootNode.getTextDocument().getDisplayName());    }    private final String testCodeForLineNumbers =              "public class SimpleClass {\n" // line 1            + "    public void method1() {\n" // line 2            + "        System.out.println('abc');\n" // line 3            + "        // this is a comment\n" // line 4            + "    }\n" // line 5            + "}"; // line 6    @Test    void verifyLineColumnNumbers() {        ASTUserClassOrInterface<?> rootNode = parse(testCodeForLineNumbers);        assertLineNumbersForTestCode(rootNode);    }    @Test    void verifyLineColumnNumbersWithWindowsLineEndings() {        String windowsLineEndings = testCodeForLineNumbers.replaceAll(" \n", "\r\n");        ASTUserClassOrInterface<?> rootNode = parse(windowsLineEndings);        assertLineNumbersForTestCode(rootNode);    }    private void assertLineNumbersForTestCode(ASTUserClassOrInterface<?> classNode) {        // whole source code, well from the beginning of the class        // name Modifier of the class - doesn't work. This node just        // sees the identifier ("SimpleClass")        // assertPosition(rootNode.getChild(0), 1, 1, 1, 6);        // identifier: "SimpleClass"        assertPosition(classNode, 1, 14, 1, 25);        assertTextEquals("SimpleClass", classNode);        // identifier: "method1"        Node method1 = classNode.getChild(1);        assertTextEquals("method1", method1);        assertPosition(method1, 2, 17, 2, 24);        // modifiers have same location        assertPosition(method1.getChild(0), 2, 17, 2, 24);        // BlockStatement - the whole method body        Node blockStatement = method1.getChild(1);        assertTrue(((ASTBlockStatement) blockStatement).hasCurlyBrace(), "should detect curly brace");        assertPosition(blockStatement, 2, 27, 5, 6);        // the expression ("System.out...")        Node expressionStatement = blockStatement.getChild(0);        assertPosition(expressionStatement, 3, 20, 3, 35);        assertTextEquals("println('abc');", expressionStatement);    }    @Test    void verifyEndLine() {        String code = "public class SimpleClass {\n" // line 1                + "    public void method1() {\n" // line 2                + "    }\n" // line 3                + "    public void method2() {\n" // line 4                + "    }\n" // line 5                + "}\n"; // line 6        ASTUserClassOrInterface<?> rootNode = parse(code);        Node method1 = rootNode.getChild(1);        assertPosition(method1, 2, 17, 2, 24);        Node method2 = rootNode.getChild(2);        assertPosition(method2, 4, 17, 4, 24);    }    @Test    void checkComments() {        String code = "public  /** Comment on Class */ class SimpleClass {\n" // line 1            + "    /** Comment on m1 */"            + "    public void method1() {\n" // line 2            + "    }\n" // line 3            + "    public void method2() {\n" // line 4            + "    }\n" // line 5            + "}\n"; // line 6        ASTUserClassOrInterface<?> root = parse(code);        assertThat(root, instanceOf(ASTUserClass.class));        ApexNode<?> comment = root.getChild(0);        assertThat(comment, instanceOf(ASTFormalComment.class));        assertPosition(comment, 1, 9, 1, 32);        assertEquals("/** Comment on Class */", ((ASTFormalComment) comment).getToken().toString());        ApexNode<?> m1 = root.getChild(2);        assertThat(m1, instanceOf(ASTMethod.class));        ApexNode<?> comment2 = m1.getChild(0);        assertThat(comment2, instanceOf(ASTFormalComment.class));        assertEquals("/** Comment on m1 */", ((ASTFormalComment) comment2).getToken().toString());    }    @Test    void parsesRealWorldClasses() throws Exception {        File directory = new File("src/test/resources");        File[] fList = directory.listFiles();        for (File file : fList) {            if (file.isFile() && file.getName().endsWith(".cls")) {                String sourceCode = IOUtil.readFileToString(file, StandardCharsets.UTF_8);                assertNotNull(parse(sourceCode));            }        }    }    /**     * See github issue #1546     * @see <a href="https://github.com/pmd/pmd/issues/1546">[apex] PMD parsing exception for Apex classes using 'inherited sharing' keyword</a>     */    @Test    void parseInheritedSharingClass() throws IOException {        String source = IOUtil.readToString(ApexParserTest.class.getResourceAsStream("InheritedSharing.cls"),                StandardCharsets.UTF_8);        assertNotNull(parse(source));    }    /**     * See bug #1485     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1485/">#1485 [apex] Analysis of some apex classes cause a stackoverflow error</a>     */    @Test    void stackOverflowDuringClassParsing() throws Exception {        String source = IOUtil.readToString(ApexParserTest.class.getResourceAsStream("StackOverflowClass.cls"),                StandardCharsets.UTF_8);        ASTUserClassOrInterface<?> rootNode = parse(source);        assertNotNull(rootNode);        int count = visitPosition(rootNode, 0);        assertEquals(487, count);    }    @Test    void verifyLineColumnNumbersInnerClasses() {        ASTApexFile rootNode = apex.parseResource("InnerClassLocations.cls");        assertNotNull(rootNode);        visitPosition(rootNode, 0);        ASTUserClassOrInterface<?> classNode = rootNode.getMainNode();        assertEquals("InnerClassLocations", classNode.getSimpleName());        assertTextEquals("InnerClassLocations", classNode);        // Note: Apex parser doesn't provide positions for "public class" keywords. The        // position of the UserClass node is just the identifier. So, the node starts        // with the identifier and not with the first keyword in the file...        assertPosition(classNode, 1, 14, 1, 33);        List<ASTUserClass> classes = classNode.descendants(ASTUserClass.class).toList();        assertEquals(2, classes.size());        assertEquals("bar1", classes.get(0).getSimpleName());        List<ASTMethod> methods = classes.get(0).children(ASTMethod.class).toList();        assertEquals(2, methods.size()); // m() and synthetic clone()        assertEquals("m", methods.get(0).getImage());        assertPosition(methods.get(0), 4, 21, 4, 22);        assertEquals("clone", methods.get(1).getImage());        assertFalse(methods.get(1).hasRealLoc());        assertPosition(methods.get(1), 3, 18, 3, 22);        // Position of the first inner class is its identifier        assertPosition(classes.get(0), 3, 18, 3, 22);        assertEquals("bar2", classes.get(1).getSimpleName());        assertPosition(classes.get(1), 10, 18, 10, 22);    }    // TEST HELPER    private int visitPosition(Node node, int count) {        int result = count + 1;        FileLocation loc = node.getReportLocation();        assertTrue(loc.getStartLine() > 0);        assertTrue(loc.getStartColumn() > 0);        assertTrue(loc.getEndLine() > 0);        assertTrue(loc.getEndColumn() > 0);        for (int i = 0; i < node.getNumChildren(); i++) {            result = visitPosition(node.getChild(i), result);        }        return result;    }    private void assertTextEquals(String expected, Node expressionStatement) {        assertEquals(expected, textOfReportLocation(expressionStatement));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;class ASTMethodTest extends ApexParserTestBase {    @Test    void testConstructorName() {        ASTUserClass node = (ASTUserClass) parse("public class Foo { public Foo() {} public void bar() {} }");        List<ASTMethod> methods = node.children(ASTMethod.class).toList();        assertEquals("Foo", methods.get(0).getImage()); // constructor        assertEquals("<init>", methods.get(0).getCanonicalName());        assertEquals("bar", methods.get(1).getImage()); // normal method    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;class ASTUserInterfaceTest extends ApexParserTestBase {    @Test    void testInterfaceName() {        ASTUserInterface node = (ASTUserInterface) parse("interface Foo { }");        assertEquals("Foo", node.getSimpleName());    }    @Test    void testInnerInterfaceName() {        ASTUserClass node = (ASTUserClass) parse("class Foo { interface Bar { } }");        ASTUserInterface innerNode = node.descendants(ASTUserInterface.class).firstOrThrow();        assertEquals("Bar", innerNode.getSimpleName());    }    @Test    void testSuperInterface() {        ASTUserInterface toplevel = (ASTUserInterface) parse("public interface CustomInterface extends A {}");        assertEquals("A", toplevel.getSuperInterfaceName());    }    @Test    void testSuperInterface2() {        ASTUserInterface toplevel = (ASTUserInterface) parse("public interface CustomInterface extends Other.A {}");        assertEquals("Other.A", toplevel.getSuperInterfaceName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import static org.junit.jupiter.api.Assertions.assertEquals;import java.util.List;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ViolationSuppressor;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;class SuppressWarningsTest extends ApexParserTestBase {    // This could be a regular xml test    private static class BarRule extends AbstractApexRule {        @Override        public String getMessage() {            return "a message";        }        @Override        public Object visit(ASTUserClass clazz, Object ctx) {            if (clazz.getSimpleName().equalsIgnoreCase("bar")) {                addViolation(ctx, clazz);            }            return super.visit(clazz, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    void testClassLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST1);        assertSize(rpt, 0);        rpt = apex.executeRule(new FooRule(), TEST2);        assertSize(rpt, 0);    }    @Test    void testInheritedSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST3);        assertSize(rpt, 0);    }    @Test    void testMethodLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST4);        assertSize(rpt, 1);    }    @Test    void testConstructorLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST5);        assertSize(rpt, 0);    }    @Test    void testFieldLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST6);        assertSize(rpt, 1);    }    @Test    void testParameterLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST7);        assertSize(rpt, 1);    }    @Test    void testLocalVariableLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST8);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST9);        assertSize(rpt, 1);    }    @Test    void testSpecificSuppressionMulitpleValues() {        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);        assertSize(rpt, 0);    }    @Test    void testNoSuppressionBlank() {        Report rpt = apex.executeRule(new FooRule(), TEST10);        assertSize(rpt, 2);    }    @Test    void testNoSuppressionSomethingElseS() {        Report rpt = apex.executeRule(new FooRule(), TEST11);        assertSize(rpt, 2);    }    @Test    void testSuppressAll() {        Report rpt = apex.executeRule(new FooRule(), TEST12);        assertSize(rpt, 0);    }    @Test    void testSpecificSuppressionAtTopLevel() {        Report rpt = apex.executeRule(new BarRule(), TEST13);        assertSize(rpt, 0);    }    @Test    void testCommentSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST14);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    void testMessageWithCommentSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST15);        assertSize(rpt, 0);        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);        Report.SuppressedViolation suppression = suppressions.get(0);        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());        assertEquals("We allow foo here", suppression.getUserMessage());    }    private static final String TEST1 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {}";    private static final String TEST2 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST3 = "public class Baz {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public class Bar {" + PMD.EOL + "  void bar() {" + PMD.EOL + "   Integer foo;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "public class Foo {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST5 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public Bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST6 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST7 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL            + " void bar(@SuppressWarnings('PMD') Integer foo) {}" + PMD.EOL + "}";    private static final String TEST8 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD.NoFoo') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_MULTIPLE_VALUES = "@SuppressWarnings('PMD.NoFoo, PMD.NoBar')"            + PMD.EOL + "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL            + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST10 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST11 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('SomethingElse') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST12 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('all') Integer foo;"            + PMD.EOL + "}";    private static final String TEST13 = "@SuppressWarnings('PMD.NoBar')" + PMD.EOL + "public class Bar {" + PMD.EOL            + "}";    private static final String TEST14 = "public class Bar {" + PMD.EOL + "Integer foo; // NOPMD" + PMD.EOL + "}";    private static final String TEST15 = "public class Bar {" + PMD.EOL + "Integer foo; //NOPMD We allow foo here" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.AbstractLanguageVersionTest;import net.sourceforge.pmd.lang.LanguageVersion;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<?> data() {        return Arrays.asList(new Object[][] { { ApexLanguageModule.NAME, ApexLanguageModule.TERSE_NAME, "35",            getLanguage("Apex").getVersion("35"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;import com.github.stefanbirkner.systemlambda.SystemLambda;class DefaultRulesetTest {    @Test    void loadDefaultRuleset() {        RuleSet ruleset = rulesetLoader().loadFromResource("rulesets/apex/ruleset.xml");        assertNotNull(ruleset);    }    @Test    void loadQuickstartRuleset() throws Exception {        String log = SystemLambda.tapSystemErr(() -> {            RuleSet ruleset = rulesetLoader().loadFromResource("rulesets/apex/quickstart.xml");            assertNotNull(ruleset);        });        assertTrue(log.isEmpty(), "No Logging expected");    }    private RuleSetLoader rulesetLoader() {        return new RuleSetLoader().enableCompatibility(false);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.File;import java.io.IOException;import java.util.Iterator;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.util.IOUtil;class ApexCpdTest {    private File testdir;    @BeforeEach    void setUp() {        String path = IOUtil.normalizePath("src/test/resources/net/sourceforge/pmd/cpd/issue427");        testdir = new File(path);    }    @Test    void testIssue427() throws IOException {        CPDConfiguration configuration = new CPDConfiguration();        configuration.setMinimumTileSize(10);        configuration.setLanguage(LanguageFactory.createLanguage(ApexLanguageModule.TERSE_NAME));        CPD cpd = new CPD(configuration);        cpd.add(new File(testdir, "SFDCEncoder.cls"));        cpd.add(new File(testdir, "SFDCEncoderConstants.cls"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        int duplications = 0;        while (matches.hasNext()) {            matches.next();            duplications++;        }        assertEquals(1, duplications);        Match firstDuplication = cpd.getMatches().next();        assertTrue(firstDuplication.getSourceCodeSlice().startsWith("global with sharing class SFDCEncoder"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.jupiter.api.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;class ApexTokenizerTest extends CpdTextComparisonTest {    ApexTokenizerTest() {        super(".cls");    }    @Override    protected String getResourcePrefix() {        return "../lang/apex/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        ApexTokenizer tokenizer = new ApexTokenizer();        tokenizer.setProperties(properties);        return tokenizer;    }    @Test    void testTokenize() {        doTest("Simple");    }    @Test    void testTokenizeCaseSensitive() {        doTest("Simple", "_caseSensitive", caseSensitive());    }    /**     * Comments are ignored since using ApexLexer.     */    @Test    void testTokenizeWithComments() {        doTest("comments");    }    @Test    void testTabWidth() {        doTest("tabWidth");    }    private Properties caseSensitive() {        return properties(true);    }    private Properties properties(boolean caseSensitive) {        Properties properties = new Properties();        properties.setProperty(ApexTokenizer.CASE_SENSITIVE, Boolean.toString(caseSensitive));        return properties;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.it;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.io.TempDir;import net.sourceforge.pmd.PMDVersion;abstract class AbstractBinaryDistributionTest {    public static final String PMD_BIN_PREFIX = "pmd-bin-";    protected static File getBinaryDistribution() {        return new File(".", "target/" + PMD_BIN_PREFIX + PMDVersion.VERSION + ".zip");    }    @TempDir    static Path folder;    /**     * The temporary directory, to which the binary distribution will be extracted.     * It will be deleted again after the test.     */    protected static Path tempDir;    protected Path createTemporaryReportFile() throws IOException {        return Files.createTempFile(folder, null, null);    }    @BeforeAll    static void setupTempDirectory() throws Exception {        tempDir = Files.createTempDirectory(folder, null);        if (getBinaryDistribution().exists()) {            ZipFileExtractor.extractZipFile(getBinaryDistribution().toPath(), tempDir);        }    }}