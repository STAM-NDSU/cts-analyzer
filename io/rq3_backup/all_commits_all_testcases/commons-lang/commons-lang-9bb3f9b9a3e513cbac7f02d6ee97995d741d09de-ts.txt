/* * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//lang/src/test/org/apache/commons/lang/util/Attic/BitFieldTest.java,v 1.1 2002/12/18 02:50:36 bayard Exp $ * $Revision: 1.1 $ * $Date: 2002/12/18 02:50:36 $ * * ==================================================================== * * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Group. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. * */package org.apache.commons.lang.util;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Class to test BitField functionality * * @author Scott Sanders (sanders at apache dot org) * @author Marc Johnson * @author Glen Stampoultzis (gstamp@iprimus.com.au) * @version $Id: BitFieldTest.java,v 1.1 2002/12/18 02:50:36 bayard Exp $ */public class BitFieldTest    extends TestCase{    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(BitFieldTest.class);    suite.setName("BitField Tests");        return suite;    }    private static BitField bf_multi  = new BitField(0x3F80);    private static BitField bf_single = new BitField(0x4000);    /**     * Constructor BitFieldTest     *     * @param name     */    public BitFieldTest(String name)    {        super(name);    }    /**     * test the getValue() method     */    public void testGetValue()    {        assertEquals(bf_multi.getValue(-1), 127);        assertEquals(bf_multi.getValue(0), 0);        assertEquals(bf_single.getValue(-1), 1);        assertEquals(bf_single.getValue(0), 0);    }    /**     * test the getShortValue() method     */    public void testGetShortValue()    {        assertEquals(bf_multi.getShortValue(( short ) -1), ( short ) 127);        assertEquals(bf_multi.getShortValue(( short ) 0), ( short ) 0);        assertEquals(bf_single.getShortValue(( short ) -1), ( short ) 1);        assertEquals(bf_single.getShortValue(( short ) 0), ( short ) 0);    }    /**     * test the getRawValue() method     */    public void testGetRawValue()    {        assertEquals(bf_multi.getRawValue(-1), 0x3F80);        assertEquals(bf_multi.getRawValue(0), 0);        assertEquals(bf_single.getRawValue(-1), 0x4000);        assertEquals(bf_single.getRawValue(0), 0);    }    /**     * test the getShortRawValue() method     */    public void testGetShortRawValue()    {        assertEquals(bf_multi.getShortRawValue(( short ) -1),                     ( short ) 0x3F80);        assertEquals(bf_multi.getShortRawValue(( short ) 0), ( short ) 0);        assertEquals(bf_single.getShortRawValue(( short ) -1),                     ( short ) 0x4000);        assertEquals(bf_single.getShortRawValue(( short ) 0), ( short ) 0);    }    /**     * test the isSet() method     */    public void testIsSet()    {        assertTrue(!bf_multi.isSet(0));        for (int j = 0x80; j <= 0x3F80; j += 0x80)        {            assertTrue(bf_multi.isSet(j));        }        assertTrue(!bf_single.isSet(0));        assertTrue(bf_single.isSet(0x4000));    }    /**     * test the isAllSet() method     */    public void testIsAllSet()    {        for (int j = 0; j < 0x3F80; j += 0x80)        {            assertTrue(!bf_multi.isAllSet(j));        }        assertTrue(bf_multi.isAllSet(0x3F80));        assertTrue(!bf_single.isAllSet(0));        assertTrue(bf_single.isAllSet(0x4000));    }    /**     * test the setValue() method     */    public void testSetValue()    {        for (int j = 0; j < 128; j++)        {            assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);            assertEquals(bf_multi.setValue(0, j), j << 7);        }        // verify that excess bits are stripped off        assertEquals(bf_multi.setValue(0x3f80, 128), 0);        for (int j = 0; j < 2; j++)        {            assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);            assertEquals(bf_single.setValue(0, j), j << 14);        }        // verify that excess bits are stripped off        assertEquals(bf_single.setValue(0x4000, 2), 0);    }    /**     * test the setShortValue() method     */    public void testSetShortValue()    {        for (int j = 0; j < 128; j++)        {            assertEquals(bf_multi                .getShortValue(bf_multi                    .setShortValue(( short ) 0, ( short ) j)), ( short ) j);            assertEquals(bf_multi.setShortValue(( short ) 0, ( short ) j),                         ( short ) (j << 7));        }        // verify that excess bits are stripped off        assertEquals(bf_multi.setShortValue(( short ) 0x3f80, ( short ) 128),                     ( short ) 0);        for (int j = 0; j < 2; j++)        {            assertEquals(bf_single                .getShortValue(bf_single                    .setShortValue(( short ) 0, ( short ) j)), ( short ) j);            assertEquals(bf_single.setShortValue(( short ) 0, ( short ) j),                         ( short ) (j << 14));        }        // verify that excess bits are stripped off        assertEquals(bf_single.setShortValue(( short ) 0x4000, ( short ) 2),                     ( short ) 0);    }    public void testByte()    {        assertEquals(1, new BitField(1).setByteBoolean(( byte ) 0, true));        assertEquals(2, new BitField(2).setByteBoolean(( byte ) 0, true));        assertEquals(4, new BitField(4).setByteBoolean(( byte ) 0, true));        assertEquals(8, new BitField(8).setByteBoolean(( byte ) 0, true));        assertEquals(16, new BitField(16).setByteBoolean(( byte ) 0, true));        assertEquals(32, new BitField(32).setByteBoolean(( byte ) 0, true));        assertEquals(64, new BitField(64).setByteBoolean(( byte ) 0, true));        assertEquals(-128,                     new BitField(128).setByteBoolean(( byte ) 0, true));        assertEquals(0, new BitField(1).setByteBoolean(( byte ) 1, false));        assertEquals(0, new BitField(2).setByteBoolean(( byte ) 2, false));        assertEquals(0, new BitField(4).setByteBoolean(( byte ) 4, false));        assertEquals(0, new BitField(8).setByteBoolean(( byte ) 8, false));        assertEquals(0, new BitField(16).setByteBoolean(( byte ) 16, false));        assertEquals(0, new BitField(32).setByteBoolean(( byte ) 32, false));        assertEquals(0, new BitField(64).setByteBoolean(( byte ) 64, false));        assertEquals(0, new BitField(128).setByteBoolean(( byte ) 128,                                     false));        assertEquals(-2, new BitField(1).setByteBoolean(( byte ) 255, false));        byte clearedBit = new BitField(0x40).setByteBoolean(( byte ) -63,                                       false);        assertEquals(false, new BitField(0x40).isSet(clearedBit));    }    /**     * test the clear() method     */    public void testClear()    {        assertEquals(bf_multi.clear(-1), 0xFFFFC07F);        assertEquals(bf_single.clear(-1), 0xFFFFBFFF);    }    /**     * test the clearShort() method     */    public void testClearShort()    {        assertEquals(bf_multi.clearShort(( short ) -1), ( short ) 0xC07F);        assertEquals(bf_single.clearShort(( short ) -1), ( short ) 0xBFFF);    }    /**     * test the set() method     */    public void testSet()    {        assertEquals(bf_multi.set(0), 0x3F80);        assertEquals(bf_single.set(0), 0x4000);    }    /**     * test the setShort() method     */    public void testSetShort()    {        assertEquals(bf_multi.setShort(( short ) 0), ( short ) 0x3F80);        assertEquals(bf_single.setShort(( short ) 0), ( short ) 0x4000);    }    /**     * test the setBoolean() method     */    public void testSetBoolean()    {        assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));        assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));        assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));        assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));    }    /**     * test the setShortBoolean() method     */    public void testSetShortBoolean()    {        assertEquals(bf_multi.setShort(( short ) 0),                     bf_multi.setShortBoolean(( short ) 0, true));        assertEquals(bf_single.setShort(( short ) 0),                     bf_single.setShortBoolean(( short ) 0, true));        assertEquals(bf_multi.clearShort(( short ) -1),                     bf_multi.setShortBoolean(( short ) -1, false));        assertEquals(bf_single.clearShort(( short ) -1),                     bf_single.setShortBoolean(( short ) -1, false));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.util;import junit.framework.Test;import junit.framework.TestSuite;/** * Tests the org.apache.commons.lang.util.IdentifierUtils class. * * @author Stephen Colebourne * @version $Id: IdentifierUtilsTest.java,v 1.2 2003/05/16 22:07:38 scolebourne Exp $ */public class IdentifierUtilsTest extends junit.framework.TestCase {    /**     * Construct     */    public IdentifierUtilsTest(String name) {        super(name);    }    /**     * Return class aa a test suite.     */    public static Test suite() {        TestSuite suite = new TestSuite(IdentifierUtilsTest.class);        suite.setName("IdentifierUtils Tests");        return suite;    }    //--------------------------------------------------------------------------    public void testLongIncrementing() {        LongIdentifierFactory f = IdentifierUtils.LONG_IDENTIFIER_FACTORY;        assertEquals(new Long(0), f.nextLongIdentifier());        assertEquals(new Long(1), f.nextLongIdentifier());        assertEquals(new Long(2), f.nextIdentifier());        assertEquals(new Long(3), f.nextLongIdentifier());        assertEquals(new Long(4), IdentifierUtils.nextLongIdentifier());        assertEquals(new Long(5), f.nextLongIdentifier());        assertEquals(new Long(6), IdentifierUtils.nextLongIdentifier());        assertEquals(new Long(7), IdentifierUtils.nextLongIdentifier());    }    public void testLongIncrementingNoArgs() {        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory();        assertEquals(new Long(0), f.nextLongIdentifier());        assertEquals(new Long(1), f.nextLongIdentifier());        assertTrue(f != IdentifierUtils.LONG_IDENTIFIER_FACTORY);    }    public void testLongIncrementingInit() {        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory(true, 100);        assertEquals(new Long(100), f.nextLongIdentifier());        assertEquals(new Long(101), f.nextLongIdentifier());    }    public void testLongIncrementingWrap() {        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory(true, Long.MAX_VALUE);        assertEquals(new Long(Long.MAX_VALUE), f.nextLongIdentifier());        assertEquals(new Long(Long.MIN_VALUE), f.nextLongIdentifier());    }    public void testLongIncrementingNoWrap() {        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory(false, Long.MAX_VALUE);        try {            f.nextLongIdentifier();            fail();        } catch (IllegalStateException ex) {}    }    //--------------------------------------------------------------------------    public void testStringNumericLong() {        StringIdentifierFactory f = IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY;        assertEquals("0", f.nextStringIdentifier());        assertEquals("1", f.nextStringIdentifier());        assertEquals("2", f.nextIdentifier());        assertEquals("3", f.nextStringIdentifier());        assertEquals("4", IdentifierUtils.nextStringNumericIdentifier());        assertEquals("5", f.nextStringIdentifier());        assertEquals("6", IdentifierUtils.nextStringNumericIdentifier());        assertEquals("7", IdentifierUtils.nextStringNumericIdentifier());    }    public void testStringNumericNoArgs() {        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory();        assertEquals("0", f.nextStringIdentifier());        assertEquals("1", f.nextStringIdentifier());        assertTrue(f != IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY);    }    public void testStringNumericInit() {        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory(true, 100);        assertEquals("100", f.nextStringIdentifier());        assertEquals("101", f.nextStringIdentifier());    }    public void testStringNumericWrap() {        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory(true, Long.MAX_VALUE);        assertEquals(Long.toString(Long.MAX_VALUE), f.nextStringIdentifier());        assertEquals(Long.toString(Long.MIN_VALUE), f.nextStringIdentifier());    }    public void testStringNumericNoWrap() {        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory(false, Long.MAX_VALUE);        try {            f.nextStringIdentifier();            fail();        } catch (IllegalStateException ex) { }    }    //--------------------------------------------------------------------------    public void testStringAlphanumeric() {        StringIdentifierFactory f = IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY;        assertEquals("000000000000001", f.nextStringIdentifier());        assertEquals("000000000000002", f.nextStringIdentifier());        assertEquals("000000000000003", f.nextStringIdentifier());        assertEquals("000000000000004", f.nextStringIdentifier());        assertEquals("000000000000005", f.nextStringIdentifier());        assertEquals("000000000000006", f.nextStringIdentifier());        assertEquals("000000000000007", f.nextStringIdentifier());        assertEquals("000000000000008", f.nextStringIdentifier());        assertEquals("000000000000009", f.nextStringIdentifier());        assertEquals("00000000000000a", f.nextStringIdentifier());        assertEquals("00000000000000b", f.nextStringIdentifier());        assertEquals("00000000000000c", f.nextStringIdentifier());        assertEquals("00000000000000d", IdentifierUtils.nextStringAlphanumericIdentifier());        assertEquals("00000000000000e", f.nextStringIdentifier());        assertEquals("00000000000000f", f.nextStringIdentifier());        assertEquals("00000000000000g", f.nextStringIdentifier());        assertEquals("00000000000000h", f.nextStringIdentifier());        assertEquals("00000000000000i", f.nextStringIdentifier());        assertEquals("00000000000000j", f.nextStringIdentifier());        assertEquals("00000000000000k", f.nextStringIdentifier());        assertEquals("00000000000000l", f.nextStringIdentifier());        assertEquals("00000000000000m", f.nextStringIdentifier());        assertEquals("00000000000000n", f.nextStringIdentifier());        assertEquals("00000000000000o", f.nextStringIdentifier());        assertEquals("00000000000000p", f.nextStringIdentifier());        assertEquals("00000000000000q", f.nextStringIdentifier());        assertEquals("00000000000000r", f.nextStringIdentifier());        assertEquals("00000000000000s", f.nextStringIdentifier());        assertEquals("00000000000000t", f.nextStringIdentifier());        assertEquals("00000000000000u", f.nextStringIdentifier());        assertEquals("00000000000000v", f.nextStringIdentifier());        assertEquals("00000000000000w", f.nextStringIdentifier());        assertEquals("00000000000000x", f.nextStringIdentifier());        assertEquals("00000000000000y", f.nextStringIdentifier());        assertEquals("00000000000000z", f.nextStringIdentifier());        assertEquals("000000000000010", f.nextStringIdentifier());        assertEquals("000000000000011", f.nextStringIdentifier());        assertEquals("000000000000012", f.nextStringIdentifier());        assertEquals("000000000000013", f.nextStringIdentifier());    }    public void testLongAlphanumericNoArgs() {        StringIdentifierFactory f = IdentifierUtils.stringAlphanumericIdentifierFactory();        assertEquals("000000000000001", f.nextStringIdentifier());        assertEquals("000000000000002", f.nextStringIdentifier());        assertTrue(f != IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY);    }    public void testStringAlphanumericWrap() {        StringIdentifierFactory f = IdentifierUtils.stringAlphanumericIdentifierFactory(true, 1);        assertEquals("1", f.nextStringIdentifier());        assertEquals("2", f.nextStringIdentifier());        assertEquals("3", f.nextStringIdentifier());        assertEquals("4", f.nextStringIdentifier());        assertEquals("5", f.nextStringIdentifier());        assertEquals("6", f.nextStringIdentifier());        assertEquals("7", f.nextStringIdentifier());        assertEquals("8", f.nextStringIdentifier());        assertEquals("9", f.nextStringIdentifier());        assertEquals("a", f.nextStringIdentifier());        assertEquals("b", f.nextStringIdentifier());        assertEquals("c", f.nextStringIdentifier());        assertEquals("d", f.nextStringIdentifier());        assertEquals("e", f.nextStringIdentifier());        assertEquals("f", f.nextStringIdentifier());        assertEquals("g", f.nextStringIdentifier());        assertEquals("h", f.nextStringIdentifier());        assertEquals("i", f.nextStringIdentifier());        assertEquals("j", f.nextStringIdentifier());        assertEquals("k", f.nextStringIdentifier());        assertEquals("l", f.nextStringIdentifier());        assertEquals("m", f.nextStringIdentifier());        assertEquals("n", f.nextStringIdentifier());        assertEquals("o", f.nextStringIdentifier());        assertEquals("p", f.nextStringIdentifier());        assertEquals("q", f.nextStringIdentifier());        assertEquals("r", f.nextStringIdentifier());        assertEquals("s", f.nextStringIdentifier());        assertEquals("t", f.nextStringIdentifier());        assertEquals("u", f.nextStringIdentifier());        assertEquals("v", f.nextStringIdentifier());        assertEquals("w", f.nextStringIdentifier());        assertEquals("x", f.nextStringIdentifier());        assertEquals("y", f.nextStringIdentifier());        assertEquals("z", f.nextStringIdentifier());        assertEquals("0", f.nextStringIdentifier());    }    public void testStringAlphanumericNoWrap() {        StringIdentifierFactory f = IdentifierUtils.stringAlphanumericIdentifierFactory(false, 1);        assertEquals("1", f.nextStringIdentifier());        assertEquals("2", f.nextStringIdentifier());        assertEquals("3", f.nextStringIdentifier());        assertEquals("4", f.nextStringIdentifier());        assertEquals("5", f.nextStringIdentifier());        assertEquals("6", f.nextStringIdentifier());        assertEquals("7", f.nextStringIdentifier());        assertEquals("8", f.nextStringIdentifier());        assertEquals("9", f.nextStringIdentifier());        assertEquals("a", f.nextStringIdentifier());        assertEquals("b", f.nextStringIdentifier());        assertEquals("c", f.nextStringIdentifier());        assertEquals("d", f.nextStringIdentifier());        assertEquals("e", f.nextStringIdentifier());        assertEquals("f", f.nextStringIdentifier());        assertEquals("g", f.nextStringIdentifier());        assertEquals("h", f.nextStringIdentifier());        assertEquals("i", f.nextStringIdentifier());        assertEquals("j", f.nextStringIdentifier());        assertEquals("k", f.nextStringIdentifier());        assertEquals("l", f.nextStringIdentifier());        assertEquals("m", f.nextStringIdentifier());        assertEquals("n", f.nextStringIdentifier());        assertEquals("o", f.nextStringIdentifier());        assertEquals("p", f.nextStringIdentifier());        assertEquals("q", f.nextStringIdentifier());        assertEquals("r", f.nextStringIdentifier());        assertEquals("s", f.nextStringIdentifier());        assertEquals("t", f.nextStringIdentifier());        assertEquals("u", f.nextStringIdentifier());        assertEquals("v", f.nextStringIdentifier());        assertEquals("w", f.nextStringIdentifier());        assertEquals("x", f.nextStringIdentifier());        assertEquals("y", f.nextStringIdentifier());        assertEquals("z", f.nextStringIdentifier());        try {            f.nextStringIdentifier();            fail();        } catch (IllegalStateException ex) {}    }    //--------------------------------------------------------------------------    public void testStringSession() {        StringIdentifierFactory f = IdentifierUtils.STRING_SESSION_IDENTIFIER_FACTORY;        assertTrue(f != IdentifierUtils.stringSessionIdentifierFactory());                String a = (String) f.nextStringIdentifier();        String b = (String) IdentifierUtils.nextStringSessionIdentifier();        assertTrue(a.length() >= 10);        assertTrue(b.length() >= 10);        // could fail, but unlikely        assertTrue(a.substring(6, 9) != b.substring(6, 9));        assertEquals("0", a.substring(9));        assertEquals("1", b.substring(9));    }    //--------------------------------------------------------------------------}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.util;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.util.Validate}. * * @author Stephen Colebourne * @version $Id: ValidateTest.java,v 1.1 2002/12/29 22:09:53 scolebourne Exp $ */public class ValidateTest extends TestCase {    public ValidateTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(ValidateTest.class);    suite.setName("Validate Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testIsTrue1() {        Validate.isTrue(true);        try {            Validate.isTrue(false);        } catch (IllegalArgumentException ex) {            assertEquals("The validated expression is false", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testIsTrue2() {        Validate.isTrue(true, "MSG");        try {            Validate.isTrue(false, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testIsTrue3() {        Validate.isTrue(true, "MSG", new Integer(6));        try {            Validate.isTrue(false, "MSG", new Integer(6));        } catch (IllegalArgumentException ex) {            assertEquals("MSG6", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testIsTrue4() {        Validate.isTrue(true, "MSG", 7);        try {            Validate.isTrue(false, "MSG", 7);        } catch (IllegalArgumentException ex) {            assertEquals("MSG7", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testIsTrue5() {        Validate.isTrue(true, "MSG", 7.4d);        try {            Validate.isTrue(false, "MSG", 7.4d);        } catch (IllegalArgumentException ex) {            assertEquals("MSG7.4", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNotNull1() {        Validate.notNull(new Object());        try {            Validate.notNull(null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated object is null", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNotNull2() {        Validate.notNull(new Object(), "MSG");        try {            Validate.notNull(null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNotEmptyArray1() {        Validate.notEmpty(new Object[] {null});        try {            Validate.notEmpty((Object[]) null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated array is empty", ex.getMessage());        }        try {            Validate.notEmpty(new Object[0]);        } catch (IllegalArgumentException ex) {            assertEquals("The validated array is empty", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNotEmptyArray2() {        Validate.notEmpty(new Object[] {null}, "MSG");        try {            Validate.notEmpty((Object[]) null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }        try {            Validate.notEmpty(new Object[0], "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNotEmptyCollection1() {        Collection coll = new ArrayList();        try {            Validate.notEmpty((Collection) null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated collection is empty", ex.getMessage());        }        try {            Validate.notEmpty(coll);        } catch (IllegalArgumentException ex) {            assertEquals("The validated collection is empty", ex.getMessage());        }        coll.add(new Integer(8));        Validate.notEmpty(coll);    }    //-----------------------------------------------------------------------    public void testNotEmptyCollection2() {        Collection coll = new ArrayList();        try {            Validate.notEmpty((Collection) null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }        try {            Validate.notEmpty(coll, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }        coll.add(new Integer(8));        Validate.notEmpty(coll, "MSG");    }    //-----------------------------------------------------------------------    public void testNotEmptyMap1() {        Map map = new HashMap();        try {            Validate.notEmpty((Map) null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated map is empty", ex.getMessage());        }        try {            Validate.notEmpty(map);        } catch (IllegalArgumentException ex) {            assertEquals("The validated map is empty", ex.getMessage());        }        map.put("ll", new Integer(8));        Validate.notEmpty(map);    }    //-----------------------------------------------------------------------    public void testNotEmptyMap2() {        Map map = new HashMap();        try {            Validate.notEmpty((Map) null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }        try {            Validate.notEmpty(map, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }        map.put("ll", new Integer(8));        Validate.notEmpty(map, "MSG");    }    //-----------------------------------------------------------------------    public void testNotEmptyString1() {        Validate.notEmpty("hjl");        try {            Validate.notEmpty((String) null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated string is empty", ex.getMessage());        }        try {            Validate.notEmpty("");        } catch (IllegalArgumentException ex) {            assertEquals("The validated string is empty", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNotEmptyString2() {        Validate.notEmpty(new Object[] {null}, "MSG");        try {            Validate.notEmpty((String) null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }        try {            Validate.notEmpty("", "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNoNullElementsArray1() {        String[] array = new String[] {"a", "b"};        Validate.noNullElements(array);        try {            Validate.noNullElements((Object[]) null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated object is null", ex.getMessage());        }        array[1] = null;        try {            Validate.notEmpty(array);        } catch (IllegalArgumentException ex) {            assertEquals("The validated array contains null element at index: 1", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNoNullElementsArray2() {        String[] array = new String[] {"a", "b"};        Validate.noNullElements(array, "MSG");        try {            Validate.noNullElements((Object[]) null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("The validated object is null", ex.getMessage());        }        array[1] = null;        try {            Validate.notEmpty(array, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNoNullElementsCollection1() {        List coll = new ArrayList();        coll.add("a");        coll.add("b");        Validate.noNullElements(coll);        try {            Validate.noNullElements((Collection) null);        } catch (IllegalArgumentException ex) {            assertEquals("The validated object is null", ex.getMessage());        }        coll.set(1, null);        try {            Validate.notEmpty(coll);        } catch (IllegalArgumentException ex) {            assertEquals("The validated collection contains null element at index: 1", ex.getMessage());        }    }    //-----------------------------------------------------------------------    public void testNoNullElementsCollection2() {        List coll = new ArrayList();        coll.add("a");        coll.add("b");        Validate.noNullElements(coll, "MSG");        try {            Validate.noNullElements((Collection) null, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("The validated object is null", ex.getMessage());        }        coll.set(1, null);        try {            Validate.notEmpty(coll, "MSG");        } catch (IllegalArgumentException ex) {            assertEquals("MSG", ex.getMessage());        }    }    //-----------------------------------------------------------------------}
/* * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//lang/src/test/org/apache/commons/lang/reflect/Attic/TestBean.java,v 1.1 2002/11/14 18:53:36 rdonkin Exp $ * $Revision: 1.1 $ * $Date: 2002/11/14 18:53:36 $ * * ==================================================================== * * The Apache Software License, Version 1.1 * * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Group. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. * */package org.apache.commons.lang.reflect;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * General purpose test bean for JUnit tests for the "beanutils" component. * * @author Craig R. McClanahan * @version $Revision: 1.1 $ $Date: 2002/11/14 18:53:36 $ */public class TestBean {    // ------------------------------------------------------------- Properties    /**     * A boolean property.     */    private boolean booleanProperty = true;    public boolean getBooleanProperty() {        return (booleanProperty);    }    public void setBooleanProperty(boolean booleanProperty) {        this.booleanProperty = booleanProperty;    }    /**     * A boolean property that uses an "is" method for the getter.     */    private boolean booleanSecond = true;    public boolean isBooleanSecond() {        return (booleanSecond);    }    public void setBooleanSecond(boolean booleanSecond) {        this.booleanSecond = booleanSecond;    }    /**     * A double property.     */    private double doubleProperty = 321.0;    public double getDoubleProperty() {        return (this.doubleProperty);    }    public void setDoubleProperty(double doubleProperty) {        this.doubleProperty = doubleProperty;    }    /**     * An "indexed property" accessible via both array and subscript     * based getters and setters.     */    private String dupProperty[] =    { "Dup 0", "Dup 1", "Dup 2", "Dup 3", "Dup 4" };    public String[] getDupProperty() {        return (this.dupProperty);    }    public String getDupProperty(int index) {        return (this.dupProperty[index]);    }    public void setDupProperty(int index, String value) {        this.dupProperty[index] = value;    }    public void setDupProperty(String dupProperty[]) {        this.dupProperty = dupProperty;    }    /**     * A float property.     */    private float floatProperty = (float) 123.0;    public float getFloatProperty() {        return (this.floatProperty);    }    public void setFloatProperty(float floatProperty) {        this.floatProperty = floatProperty;    }    /**     * An integer array property accessed as an array.     */    private int intArray[] = { 0, 10, 20, 30, 40 };    public int[] getIntArray() {        return (this.intArray);    }    public void setIntArray(int intArray[]) {        this.intArray = intArray;    }    /**     * An integer array property accessed as an indexed property.     */    private int intIndexed[] = { 0, 10, 20, 30, 40 };    public int getIntIndexed(int index) {        return (intIndexed[index]);    }    public void setIntIndexed(int index, int value) {        intIndexed[index] = value;    }    /**     * An integer property.     */    private int intProperty = 123;    public int getIntProperty() {        return (this.intProperty);    }    public void setIntProperty(int intProperty) {        this.intProperty = intProperty;    }    /**     * A List property accessed as an indexed property.     */    private static List listIndexed = new ArrayList();    static {        listIndexed.add("String 0");        listIndexed.add("String 1");        listIndexed.add("String 2");        listIndexed.add("String 3");        listIndexed.add("String 4");    }    public List getListIndexed() {        return (listIndexed);    }    /**     * A long property.     */    private long longProperty = 321;    public long getLongProperty() {        return (this.longProperty);    }    public void setLongProperty(long longProperty) {        this.longProperty = longProperty;    }    /**     * A mapped property with only a getter and setter for a Map.     */    private Map mapProperty = null;    public Map getMapProperty() {        // Create the map the very first time        if (mapProperty == null) {            mapProperty = new HashMap();            mapProperty.put("First Key", "First Value");            mapProperty.put("Second Key", "Second Value");        }        return (mapProperty);    }    public void setMapProperty(Map mapProperty) {        // Create the map the very first time        if (mapProperty == null) {            mapProperty = new HashMap();            mapProperty.put("First Key", "First Value");            mapProperty.put("Second Key", "Second Value");        }        this.mapProperty = mapProperty;    }    /**     * A mapped property that has String keys and Object values.     */    private HashMap mappedObjects = null;    public Object getMappedObjects(String key) {        // Create the map the very first time        if (mappedObjects == null) {            mappedObjects = new HashMap();            mappedObjects.put("First Key", "First Value");            mappedObjects.put("Second Key", "Second Value");        }        return (mappedObjects.get(key));    }    public void setMappedObjects(String key, Object value) {        // Create the map the very first time        if (mappedObjects == null) {            mappedObjects = new HashMap();            mappedObjects.put("First Key", "First Value");            mappedObjects.put("Second Key", "Second Value");        }        mappedObjects.put(key, value);    }    /**     * A mapped property that has String keys and String values.     */    private HashMap mappedProperty = null;    public String getMappedProperty(String key) {        // Create the map the very first time        if (mappedProperty == null) {            mappedProperty = new HashMap();            mappedProperty.put("First Key", "First Value");            mappedProperty.put("Second Key", "Second Value");        }        return ((String) mappedProperty.get(key));    }    public void setMappedProperty(String key, String value) {        // Create the map the very first time        if (mappedProperty == null) {            mappedProperty = new HashMap();            mappedProperty.put("First Key", "First Value");            mappedProperty.put("Second Key", "Second Value");        }        mappedProperty.put(key, value);    }    /**     * A mapped property that has String keys and int values.     */    private HashMap mappedIntProperty = null;    public int getMappedIntProperty(String key) {        // Create the map the very first time        if (mappedProperty == null) {            mappedProperty = new HashMap();            mappedProperty.put("One", new Integer(1));            mappedProperty.put("Two", new Integer(2));        }        Integer x = (Integer) mappedIntProperty.get(key);        return ((x == null) ? 0 : x.intValue());    }    public void setMappedIntProperty(String key, int value) {        mappedIntProperty.put(key, new Integer(value));    }    /**     * A nested reference to another test bean (populated as needed).     */    private TestBean nested = null;    public TestBean getNested() {        if (nested == null)            nested = new TestBean();        return (nested);    }    /*     * Another nested reference to a bean containing mapp properties     */    class MappedTestBean {         public void setValue(String key,String val) { }        public String getValue(String key) { return "Mapped Value"; }    }        private MappedTestBean mappedNested = null;    public MappedTestBean getMappedNested() {         if (mappedNested == null)         {            mappedNested = new MappedTestBean();        }        return mappedNested;    }    /**     * A String property with an initial value of null.     */    private String nullProperty = null;    public String getNullProperty() {        return (this.nullProperty);    }    public void setNullProperty(String nullProperty) {        this.nullProperty = nullProperty;    }    /**     * A read-only String property.     */    private String readOnlyProperty = "Read Only String Property";    public String getReadOnlyProperty() {        return (this.readOnlyProperty);    }    /**     * A short property.     */    private short shortProperty = (short) 987;    public short getShortProperty() {        return (this.shortProperty);    }    public void setShortProperty(short shortProperty) {        this.shortProperty = shortProperty;    }    /**     * A String array property accessed as a String.     */    private String stringArray[] =            { "String 0", "String 1", "String 2", "String 3", "String 4" };    public String[] getStringArray() {        return (this.stringArray);    }    public void setStringArray(String stringArray[]) {        this.stringArray = stringArray;    }    /**     * A String array property accessed as an indexed property.     */    private String stringIndexed[] =            { "String 0", "String 1", "String 2", "String 3", "String 4" };    public String getStringIndexed(int index) {        return (stringIndexed[index]);    }    public void setStringIndexed(int index, String value) {        stringIndexed[index] = value;    }    /**     * A String property.     */    private String stringProperty = "This is a string";    public String getStringProperty() {        return (this.stringProperty);    }    public void setStringProperty(String stringProperty) {        this.stringProperty = stringProperty;    }    /**     * A write-only String property.     */    private String writeOnlyProperty = "Write Only String Property";    public String getWriteOnlyPropertyValue() {        return (this.writeOnlyProperty);    }    public void setWriteOnlyProperty(String writeOnlyProperty) {        this.writeOnlyProperty = writeOnlyProperty;    }        // ------------------------------------------------------- Static Variables    /**     * A static variable that is accessed and updated via static methods     * for MethodUtils testing.     */    private static int counter = 0;    /**     * Return the current value of the counter.     */    public static int currentCounter() {        return (counter);    }    /**     * Increment the current value of the counter by 1.     */    public static void incrementCounter() {        incrementCounter(1);    }    /**     * Increment the current value of the counter by the specified amount.     *     * @param amount Amount to be added to the current counter     */    public static void incrementCounter(int amount) {        counter += amount;    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: ValuedEnumTest.java,v 1.3 2003/05/22 22:00:06 scolebourne Exp $ */public final class ValuedEnumTest extends TestCase {    public ValuedEnumTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(ValuedEnumTest.class);        suite.setName("ValuedEnum Tests");        return suite;    }    public void testName() {        assertEquals("Red", ValuedColorEnum.RED.getName());        assertEquals("Green", ValuedColorEnum.GREEN.getName());        assertEquals("Blue", ValuedColorEnum.BLUE.getName());    }    public void testValue() {        assertEquals(1, ValuedColorEnum.RED.getValue());        assertEquals(2, ValuedColorEnum.GREEN.getValue());        assertEquals(3, ValuedColorEnum.BLUE.getValue());    }    public void testCompareTo() {        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.BLUE) == 0);        assertTrue(ValuedColorEnum.RED.compareTo(ValuedColorEnum.BLUE) < 0);        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.RED) > 0);    }    public void testEquals() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.RED);        assertSame(ValuedColorEnum.getEnum("Red"), ValuedColorEnum.RED);    }    public void testToString() {        assertEquals("ValuedColorEnum[Red=1]", ValuedColorEnum.RED.toString());    }    public void testIterator() {        Iterator it = ValuedColorEnum.iterator();        assertSame(ValuedColorEnum.RED, it.next());        assertSame(ValuedColorEnum.GREEN, it.next());        assertSame(ValuedColorEnum.BLUE, it.next());    }    public void testList() {        List list = ValuedColorEnum.getEnumList();                assertNotNull(list);                assertEquals( list.size(),         ValuedColorEnum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(ValuedColorEnum.RED, it.next());        assertSame(ValuedColorEnum.GREEN, it.next());        assertSame(ValuedColorEnum.BLUE, it.next());    }    public void testMap() {        Map map = ValuedColorEnum.getEnumMap();                assertNotNull(map);                assertEquals( map.keySet().size(),         ValuedColorEnum.getEnumList().size());                 assertTrue(map.containsValue(ValuedColorEnum.RED));        assertTrue(map.containsValue(ValuedColorEnum.GREEN));        assertTrue(map.containsValue(ValuedColorEnum.BLUE));        assertSame(ValuedColorEnum.RED, map.get("Red"));        assertSame(ValuedColorEnum.GREEN, map.get("Green"));        assertSame(ValuedColorEnum.BLUE, map.get("Blue"));    }    public void testGet() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum("Red"));        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum("Green"));        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum("Blue"));        assertSame(null, ValuedColorEnum.getEnum("Pink"));    }    public void testGetValue() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(1));        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(2));        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(3));        assertSame(null, ValuedColorEnum.getEnum(4));    }    public void testSerialization() {        assertSame(ValuedColorEnum.RED, SerializationUtils.clone(ValuedColorEnum.RED));        assertSame(ValuedColorEnum.GREEN, SerializationUtils.clone(ValuedColorEnum.GREEN));        assertSame(ValuedColorEnum.BLUE, SerializationUtils.clone(ValuedColorEnum.BLUE));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author Stephen Colebourne * @version $Id: EnumTest.java,v 1.7 2003/05/22 22:00:06 scolebourne Exp $ */public final class EnumTest extends TestCase {    public EnumTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(EnumTest.class);        suite.setName("Enum Tests");        return suite;    }    public void testName() {        assertEquals("Red", ColorEnum.RED.getName());        assertEquals("Green", ColorEnum.GREEN.getName());        assertEquals("Blue", ColorEnum.BLUE.getName());    }    public void testCompareTo() {        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);    }    public void testEquals() {        assertSame(ColorEnum.RED, ColorEnum.RED);        assertSame(ColorEnum.getEnum("Red"), ColorEnum.RED);    }    public void testToString() {        assertEquals("ColorEnum[Red]", ColorEnum.RED.toString());    }    public void testIterator() {        Iterator it = ColorEnum.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testList() {        List list = ColorEnum.getEnumList();                assertNotNull(list);                assertEquals( list.size(),        ColorEnum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testMap() {        Map map = ColorEnum.getEnumMap();                assertNotNull(map);                assertEquals( map.keySet().size(),        ColorEnum.getEnumList().size());                assertTrue(map.containsValue(ColorEnum.RED));        assertTrue(map.containsValue(ColorEnum.GREEN));        assertTrue(map.containsValue(ColorEnum.BLUE));        assertSame(ColorEnum.RED, map.get("Red"));        assertSame(ColorEnum.GREEN, map.get("Green"));        assertSame(ColorEnum.BLUE, map.get("Blue"));    }    public void testGet() {        assertSame(ColorEnum.RED, ColorEnum.getEnum("Red"));        assertSame(ColorEnum.GREEN, ColorEnum.getEnum("Green"));        assertSame(ColorEnum.BLUE, ColorEnum.getEnum("Blue"));        assertSame(null, ColorEnum.getEnum("Pink"));    }    public void testSerialization() {        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));    }    public void testBroken1() {        try {            Broken1Enum.RED.getName();            fail();        } catch (ExceptionInInitializerError ex) {            assertTrue(ex.getException() instanceof IllegalArgumentException);        }    }    public void testBroken2() {        try {            Broken2Enum.RED.getName();            fail();        } catch (ExceptionInInitializerError ex) {            assertTrue(ex.getException() instanceof IllegalArgumentException);        }    }    public void testBroken3() {        try {            Broken3Enum.RED.getName();            fail();        } catch (ExceptionInInitializerError ex) {            assertTrue(ex.getException() instanceof IllegalArgumentException);        }    }    public void testOperationGet() {        assertSame(OperationEnum.PLUS, OperationEnum.getEnum("Plus"));        assertSame(OperationEnum.MINUS, OperationEnum.getEnum("Minus"));        assertSame(null, OperationEnum.getEnum("Pink"));    }    public void testOperationSerialization() {        assertSame(OperationEnum.PLUS, SerializationUtils.clone(OperationEnum.PLUS));        assertSame(OperationEnum.MINUS, SerializationUtils.clone(OperationEnum.MINUS));    }    public void testOperationToString() {        assertEquals("OperationEnum[Plus]", OperationEnum.PLUS.toString());    }    public void testOperationList() {        List list = OperationEnum.getEnumList();        assertNotNull(list);        assertEquals(2, list.size());        assertEquals(list.size(), OperationEnum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(OperationEnum.PLUS, it.next());        assertSame(OperationEnum.MINUS, it.next());    }    public void testOperationMap() {        Map map = OperationEnum.getEnumMap();        assertNotNull(map);        assertEquals(map.keySet().size(), OperationEnum.getEnumList().size());                assertTrue(map.containsValue(OperationEnum.PLUS));        assertTrue(map.containsValue(OperationEnum.MINUS));        assertSame(OperationEnum.PLUS, map.get("Plus"));        assertSame(OperationEnum.MINUS, map.get("Minus"));    }    public void testOperationCalculation() {        assertEquals(3, OperationEnum.PLUS.eval(1, 2));        assertEquals(-1, OperationEnum.MINUS.eval(1, 2));    }        //-----------------------------------------------------------------------    public void testExtended1Get() {        assertSame(Extended1Enum.ALPHA, Extended1Enum.getEnum("Alpha"));        assertSame(Extended1Enum.BETA, Extended1Enum.getEnum("Beta"));        assertSame(null, Extended1Enum.getEnum("Gamma"));        assertSame(null, Extended1Enum.getEnum("Delta"));    }                public void testExtended2Get() {        assertSame(Extended1Enum.ALPHA, Extended2Enum.ALPHA);        assertSame(Extended1Enum.BETA, Extended2Enum.BETA);                assertSame(Extended2Enum.ALPHA, Extended2Enum.getEnum("Alpha"));        assertSame(Extended2Enum.BETA, Extended2Enum.getEnum("Beta"));        assertSame(Extended2Enum.GAMMA, Extended2Enum.getEnum("Gamma"));        assertSame(null, Extended2Enum.getEnum("Delta"));    }    public void testExtended3Get() {        assertSame(Extended2Enum.ALPHA, Extended3Enum.ALPHA);        assertSame(Extended2Enum.BETA, Extended3Enum.BETA);        assertSame(Extended2Enum.GAMMA, Extended3Enum.GAMMA);                assertSame(Extended3Enum.ALPHA, Extended3Enum.getEnum("Alpha"));        assertSame(Extended3Enum.BETA, Extended3Enum.getEnum("Beta"));        assertSame(Extended3Enum.GAMMA, Extended3Enum.getEnum("Gamma"));        assertSame(Extended3Enum.DELTA, Extended3Enum.getEnum("Delta"));    }    public void testExtendedSerialization() {        assertSame(Extended1Enum.ALPHA, SerializationUtils.clone(Extended1Enum.ALPHA));        assertSame(Extended1Enum.BETA, SerializationUtils.clone(Extended1Enum.BETA));        assertSame(Extended2Enum.GAMMA, SerializationUtils.clone(Extended2Enum.GAMMA));        assertSame(Extended3Enum.DELTA, SerializationUtils.clone(Extended3Enum.DELTA));    }    public void testExtendedToString() {        assertEquals("Extended1Enum[Alpha]", Extended1Enum.ALPHA.toString());        assertEquals("Extended1Enum[Beta]", Extended1Enum.BETA.toString());                assertEquals("Extended1Enum[Alpha]", Extended2Enum.ALPHA.toString());        assertEquals("Extended1Enum[Beta]", Extended2Enum.BETA.toString());        assertEquals("Extended2Enum[Gamma]", Extended2Enum.GAMMA.toString());                assertEquals("Extended1Enum[Alpha]", Extended3Enum.ALPHA.toString());        assertEquals("Extended1Enum[Beta]", Extended3Enum.BETA.toString());        assertEquals("Extended2Enum[Gamma]", Extended3Enum.GAMMA.toString());        assertEquals("Extended3Enum[Delta]", Extended3Enum.DELTA.toString());    }    public void testExtended1List() {        List list = Extended1Enum.getEnumList();        assertNotNull(list);        assertEquals(2, list.size());        assertEquals(list.size(), Extended1Enum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(Extended1Enum.ALPHA, it.next());        assertSame(Extended1Enum.BETA, it.next());    }    public void testExtended2List() {        List list = Extended2Enum.getEnumList();        assertNotNull(list);        assertEquals(3, list.size());        assertEquals(list.size(), Extended2Enum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(Extended2Enum.ALPHA, it.next());        assertSame(Extended2Enum.BETA, it.next());        assertSame(Extended2Enum.GAMMA, it.next());    }    public void testExtended3List() {        List list = Extended3Enum.getEnumList();        assertNotNull(list);        assertEquals(4, list.size());        assertEquals(list.size(), Extended3Enum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(Extended3Enum.ALPHA, it.next());        assertSame(Extended3Enum.BETA, it.next());        assertSame(Extended3Enum.GAMMA, it.next());        assertSame(Extended3Enum.DELTA, it.next());    }    public void testExtended1Map() {        Map map = Extended1Enum.getEnumMap();        assertNotNull(map);        assertEquals(map.keySet().size(), Extended1Enum.getEnumList().size());                assertTrue(map.containsValue(Extended1Enum.ALPHA));        assertTrue(map.containsValue(Extended1Enum.BETA));        assertSame(Extended1Enum.ALPHA, map.get("Alpha"));        assertSame(Extended1Enum.BETA, map.get("Beta"));    }    public void testExtended2Map() {        Map map = Extended2Enum.getEnumMap();        assertNotNull(map);        assertEquals(map.keySet().size(), Extended2Enum.getEnumList().size());                assertTrue(map.containsValue(Extended2Enum.ALPHA));        assertTrue(map.containsValue(Extended2Enum.BETA));        assertTrue(map.containsValue(Extended2Enum.GAMMA));        assertSame(Extended2Enum.ALPHA, map.get("Alpha"));        assertSame(Extended2Enum.BETA, map.get("Beta"));        assertSame(Extended2Enum.GAMMA, map.get("Gamma"));    }    public void testExtended3Map() {        Map map = Extended3Enum.getEnumMap();        assertNotNull(map);        assertEquals(map.keySet().size(), Extended3Enum.getEnumList().size());                assertTrue(map.containsValue(Extended3Enum.ALPHA));        assertTrue(map.containsValue(Extended3Enum.BETA));        assertTrue(map.containsValue(Extended3Enum.GAMMA));        assertTrue(map.containsValue(Extended3Enum.DELTA));        assertSame(Extended3Enum.ALPHA, map.get("Alpha"));        assertSame(Extended3Enum.BETA, map.get("Beta"));        assertSame(Extended3Enum.GAMMA, map.get("Gamma"));        assertSame(Extended3Enum.DELTA, map.get("Delta"));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EnumUtilsTest.java,v 1.3 2003/05/22 22:00:06 scolebourne Exp $ */public final class EnumUtilsTest extends TestCase {    public EnumUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(EnumUtilsTest.class);        suite.setName("EnumUtils Tests");        return suite;    }    public void testIterator() {        Iterator it = EnumUtils.iterator(ColorEnum.class);        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testIteratorEx() {        try {            EnumUtils.iterator(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testList() {        List list = EnumUtils.getEnumList(ColorEnum.class);        Iterator it = list.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testListEx() {        try {            EnumUtils.getEnumList(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMap() {        Map map = EnumUtils.getEnumMap(ColorEnum.class);        assertTrue(map.containsValue(ColorEnum.RED));        assertTrue(map.containsValue(ColorEnum.GREEN));        assertTrue(map.containsValue(ColorEnum.BLUE));        assertSame(ColorEnum.RED, map.get("Red"));        assertSame(ColorEnum.GREEN, map.get("Green"));        assertSame(ColorEnum.BLUE, map.get("Blue"));    }    public void testMapEx() {        try {            EnumUtils.getEnumMap(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testGet() {        assertSame(ColorEnum.RED, EnumUtils.getEnum(ColorEnum.class, "Red"));        assertSame(ColorEnum.GREEN, EnumUtils.getEnum(ColorEnum.class, "Green"));        assertSame(ColorEnum.BLUE, EnumUtils.getEnum(ColorEnum.class, "Blue"));        assertSame(null, EnumUtils.getEnum(ColorEnum.class, "Pink"));    }    public void testGetEx() {        try {            EnumUtils.getEnum(null, "");        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testGetValue() {        assertSame(ValuedColorEnum.RED, EnumUtils.getEnum(ValuedColorEnum.class, 1));        assertSame(ValuedColorEnum.GREEN, EnumUtils.getEnum(ValuedColorEnum.class, 2));        assertSame(ValuedColorEnum.BLUE, EnumUtils.getEnum(ValuedColorEnum.class, 3));        assertSame(null, EnumUtils.getEnum(ValuedColorEnum.class, 4));    }    public void testGetValueEx() {        try {            EnumUtils.getEnum(null, 0);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.time;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * TestCase for StopWatch. * * @author Stephen Colebourne * @version $Id: StopWatchTest.java,v 1.2 2003/05/21 23:40:24 scolebourne Exp $ */public class StopWatchTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StopWatchTest.class);    suite.setName("StopWatch Tests");        return suite;    }    public StopWatchTest(String s) {        super(s);    }    public void testToString(){        long time = 0;        assertEquals("0:00:00.000", StopWatch.toString(time));                time = 1;        assertEquals("0:00:00.001", StopWatch.toString(time));                time = 15;        assertEquals("0:00:00.015", StopWatch.toString(time));                time = 165;        assertEquals("0:00:00.165", StopWatch.toString(time));                time = 1675;        assertEquals("0:00:01.675", StopWatch.toString(time));                time = 13465;        assertEquals("0:00:13.465", StopWatch.toString(time));                time = 72789;        assertEquals("0:01:12.789", StopWatch.toString(time));                time = 12789 + 32 * 60000;        assertEquals("0:32:12.789", StopWatch.toString(time));                time = 12789 + 62 * 60000;        assertEquals("1:02:12.789", StopWatch.toString(time));    }        public void testStopWatchSimple(){        StopWatch watch = new StopWatch();        assertEquals(0, watch.getTime());                watch.start();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.stop();        long time = watch.getTime();        assertEquals(time, watch.getTime());                assertTrue(time >= 500);        assertTrue(time < 650);                watch.reset();        assertEquals(0, watch.getTime());    }        public void testStopWatchSplit(){        StopWatch watch = new StopWatch();        watch.start();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.split();        long splitTime = watch.getTime();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.unsplit();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.stop();        long totalTime = watch.getTime();        //        System.err.println(splitTime +"  "+totalTime);        assertTrue(splitTime >= 500);        assertTrue(splitTime < 650);        assertTrue(totalTime >= 1500);        assertTrue(totalTime < 1800);    }        public void testStopWatchSuspend(){        StopWatch watch = new StopWatch();        watch.start();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.suspend();        long suspendTime = watch.getTime();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.resume();            try {Thread.sleep(550);} catch (InterruptedException ex) {}        watch.stop();        long totalTime = watch.getTime();        //        System.err.println(suspendTime +"  "+totalTime);        assertTrue(suspendTime >= 500);        assertTrue(suspendTime < 600);        assertTrue(totalTime >= 1000);        assertTrue(totalTime < 1200);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.time;import java.text.DateFormat;import java.util.Calendar;import java.util.Date;import java.util.Iterator;import junit.framework.AssertionFailedError;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.CalendarUtils}. * * @author <a href="mailto:sergek@lokitech.com">Serge Knystautas</a> */public class CalendarUtilsTest extends TestCase {    DateFormat parser = null;    Date date1 = null;    Date date2 = null;    public CalendarUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(CalendarUtilsTest.class);    suite.setName("CalendarUtilsTest Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        parser = new java.text.SimpleDateFormat("MMM dd, yyyy H:mm:ss.SSS");        date1 = parser.parse("February 12, 2002 12:34:56.789");        date2 = parser.parse("November 18, 2001 1:23:11.321");    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    /**     * Tests various values with the round method     */    public void testRound() throws Exception {        assertEquals("round year-1 failed",                new Date("2002 January 1"),                CalendarUtils.round(date1, Calendar.YEAR));        assertEquals("round year-2 failed",                new Date("2002 January 1"),                CalendarUtils.round(date2, Calendar.YEAR));        assertEquals("round month-1 failed",                new Date("2002 February 1"),                CalendarUtils.round(date1, Calendar.MONTH));        assertEquals("round month-2 failed",                new Date("2001 December 1"),                CalendarUtils.round(date2, Calendar.MONTH));        assertEquals("round semimonth-1 failed",                new Date("2002 February 16"),                CalendarUtils.round(date1, CalendarUtils.SEMI_MONTH));        assertEquals("round semimonth-2 failed",                new Date("2001 November 16"),                CalendarUtils.round(date2, CalendarUtils.SEMI_MONTH));        assertEquals("round date-1 failed",                new Date("2002 February 13"),                CalendarUtils.round(date1, Calendar.DATE));        assertEquals("round date-2 failed",                new Date("2001 November 18"),                CalendarUtils.round(date2, Calendar.DATE));        assertEquals("round hour-1 failed",                parser.parse("February 12, 2002 13:00:00.000"),                CalendarUtils.round(date1, Calendar.HOUR));        assertEquals("round hour-2 failed",                parser.parse("November 18, 2001 1:00:00.000"),                CalendarUtils.round(date2, Calendar.HOUR));        assertEquals("round minute-1 failed",                parser.parse("February 12, 2002 12:35:00.000"),                CalendarUtils.round(date1, Calendar.MINUTE));        assertEquals("round minute-2 failed",                parser.parse("November 18, 2001 1:23:00.000"),                CalendarUtils.round(date2, Calendar.MINUTE));        assertEquals("round second-1 failed",                parser.parse("February 12, 2002 12:34:57.000"),                CalendarUtils.round(date1, Calendar.SECOND));        assertEquals("round second-2 failed",                parser.parse("November 18, 2001 1:23:11.000"),                CalendarUtils.round(date2, Calendar.SECOND));    }    /**     * Tests various values with the trunc method     */    public void testTrunc() throws Exception {        assertEquals("trunc year-1 failed",                new Date("2002 January 1"),                CalendarUtils.trunc(date1, Calendar.YEAR));        assertEquals("trunc year-2 failed",                new Date("2001 January 1"),                CalendarUtils.trunc(date2, Calendar.YEAR));        assertEquals("trunc month-1 failed",                new Date("2002 February 1"),                CalendarUtils.trunc(date1, Calendar.MONTH));        assertEquals("trunc month-2 failed",                new Date("2001 November 1"),                CalendarUtils.trunc(date2, Calendar.MONTH));        assertEquals("trunc semimonth-1 failed",                new Date("2002 February 1"),                CalendarUtils.trunc(date1, CalendarUtils.SEMI_MONTH));        assertEquals("trunc semimonth-2 failed",                new Date("2001 November 16"),                CalendarUtils.trunc(date2, CalendarUtils.SEMI_MONTH));        assertEquals("trunc date-1 failed",                new Date("2002 February 12"),                CalendarUtils.trunc(date1, Calendar.DATE));        assertEquals("trunc date-2 failed",                new Date("2001 November 18"),                CalendarUtils.trunc(date2, Calendar.DATE));        assertEquals("trunc hour-1 failed",                parser.parse("February 12, 2002 12:00:00.000"),                CalendarUtils.trunc(date1, Calendar.HOUR));        assertEquals("trunc hour-2 failed",                parser.parse("November 18, 2001 1:00:00.000"),                CalendarUtils.trunc(date2, Calendar.HOUR));        assertEquals("trunc minute-1 failed",                parser.parse("February 12, 2002 12:34:00.000"),                CalendarUtils.trunc(date1, Calendar.MINUTE));        assertEquals("trunc minute-2 failed",                parser.parse("November 18, 2001 1:23:00.000"),                CalendarUtils.trunc(date2, Calendar.MINUTE));        assertEquals("trunc second-1 failed",                parser.parse("February 12, 2002 12:34:56.000"),                CalendarUtils.trunc(date1, Calendar.SECOND));        assertEquals("trunc second-2 failed",                parser.parse("November 18, 2001 1:23:11.000"),                CalendarUtils.trunc(date2, Calendar.SECOND));    }    /**     * Tests the parse method, which is supposed to handle various strings     * as flexibly as CVS supports.     */    public void testParse() throws Exception {        //This is difficult to test since the "now" used in the        //  parse function cannot be controlled.  We could possibly control        //  it by trying before and after and making sure the value we expect        //  is between the two values calculated.        //For now we're just using the custom assertEquals that takes a delta        Calendar now = null;        now = Calendar.getInstance();        now.add(Calendar.MINUTE, -1);        assertEquals("parse 1 minute ago",                now, CalendarUtils.parse("1 minute ago"), 50);        now = Calendar.getInstance();        now.add(Calendar.MINUTE, -8);        assertEquals("parse 8 minutes ago",                now, CalendarUtils.parse("8 minutes ago"), 50);        now = Calendar.getInstance();        now.add(Calendar.DATE, -1);        assertEquals("parse yesterday",                now, CalendarUtils.parse("yesterday"), 50);        now = Calendar.getInstance();        now.add(Calendar.DATE, 1);        assertEquals("parse tomorrow",                now, CalendarUtils.parse("tomorrow"), 50);        now = Calendar.getInstance();        //Sunday would be 1, Saturday would be 7, so we walk back up to 6 days.        if (now.get(Calendar.DATE) == 1) {            //If Sunday already, we go back a full week            now.add(Calendar.DATE, -7);        } else {            now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK));        }        assertEquals("parse last Sunday",                now, CalendarUtils.parse("last Sunday"), 50);        now = Calendar.getInstance();        now.add(Calendar.DATE, -7);        assertEquals("parse last week",                now, CalendarUtils.parse("last week"), 50);        now = Calendar.getInstance();        //January would be 0, December would be 11, so we walk back up to 11 months        if (now.get(Calendar.MONTH) == 0) {            //If January already, we go back a full year            now.add(Calendar.MONTH, -12);        } else {            now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH));        }        assertEquals("parse last January",                now, CalendarUtils.parse("last January"), 50);    }    /**     * Tests the calendar iterator for week ranges     */    public void testWeekIterator() throws Exception {        Calendar now = Calendar.getInstance();        Calendar today = CalendarUtils.trunc(now, Calendar.DATE);        Calendar sunday = CalendarUtils.trunc(now, Calendar.DATE);        sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));        Calendar monday = CalendarUtils.trunc(now, Calendar.DATE);        if (monday.get(Calendar.DATE) == 1) {            //This is sunday... roll back 6 days            monday.add(Calendar.DATE, -6);        } else {            monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));        }        Calendar centered = CalendarUtils.trunc(now, Calendar.DATE);        centered.add(Calendar.DATE, -3);        Iterator it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_SUNDAY);        assertWeekIterator(it, sunday);        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_MONDAY);        assertWeekIterator(it, monday);        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_RELATIVE);        assertWeekIterator(it, today);        it = CalendarUtils.getCalendarIterator(now, CalendarUtils.RANGE_WEEK_CENTER);        assertWeekIterator(it, centered);    }    /**     * Tests the calendar iterator for month-based ranges     */    public void testMonthIterator() throws Exception {        Iterator it = CalendarUtils.getCalendarIterator(date1, CalendarUtils.RANGE_MONTH_SUNDAY);        assertWeekIterator(it,                new Date("January 27, 2002"),                new Date("March 2, 2002"));        it = CalendarUtils.getCalendarIterator(date1, CalendarUtils.RANGE_MONTH_MONDAY);        assertWeekIterator(it,                new Date("January 28, 2002"),                new Date("March 3, 2002"));        it = CalendarUtils.getCalendarIterator(date2, CalendarUtils.RANGE_MONTH_SUNDAY);        assertWeekIterator(it,                new Date("October 28, 2001"),                new Date("December 1, 2001"));        it = CalendarUtils.getCalendarIterator(date2, CalendarUtils.RANGE_MONTH_MONDAY);        assertWeekIterator(it,                new Date("October 29, 2001"),                new Date("December 2, 2001"));    }    /**     * This checks that this is a 7 element iterator of Calendar objects     * that are dates (no time), and exactly 1 day spaced after each other.     */    private static void assertWeekIterator(Iterator it, Calendar start) {        Calendar end = (Calendar) start.clone();        end.add(Calendar.DATE, 6);        assertWeekIterator(it, start, end);    }    /**     * Convenience method for when working with Date objects     */    private static void assertWeekIterator(Iterator it, Date start, Date end) {        Calendar calStart = Calendar.getInstance();        calStart.setTime(start);        Calendar calEnd = Calendar.getInstance();        calEnd.setTime(end);        assertWeekIterator(it, calStart, calEnd);    }    /**     * This checks that this is a 7 divisble iterator of Calendar objects     * that are dates (no time), and exactly 1 day spaced after each other     * (in addition to the proper start and stop dates)     */    private static void assertWeekIterator(Iterator it, Calendar start, Calendar end) {        Calendar cal = (Calendar) it.next();        assertEquals("", start, cal, 0);        Calendar last = null;        int count = 1;        while (it.hasNext()) {            //Check this is just a date (no time component)            assertEquals("", cal, CalendarUtils.trunc(cal, Calendar.DATE), 0);            last = cal;            cal = (Calendar) it.next();            count++;            //Check that this is one day more than the last date            last.add(Calendar.DATE, 1);            assertEquals("", last, cal, 0);        }        if (count % 7 != 0) {            throw new AssertionFailedError("There were " + count + " days in this iterator");        }        assertEquals("", end, cal, 0);    }    /**     * Used to check that Calendar objects are close enough     * delta is in milliseconds     */    public static void assertEquals(String message, Calendar cal1, Calendar cal2, long delta) {        if (Math.abs(cal1.getTime().getTime() - cal2.getTime().getTime()) > delta) {            throw new AssertionFailedError(                    message + " expected " + cal1.getTime() + " but got " + cal2.getTime());        }    }}
/* * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Ant", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Group. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.time;import java.util.Calendar;import java.util.TimeZone;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * TestCase for DateUtils.  [Relies heavily on code taken from the * DateUtilsTest class of the jakarata-ant project.] * * @author <a href="mailto:sbailliez@apache.org">Stephane Bailliez</a> * @author <a href="mailto:stefan.bodewig@epost.de">Stefan Bodewig</a> */public class DateUtilsTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(DateUtilsTest.class);    suite.setName("DateUtils Tests");        return suite;    }    public DateUtilsTest(String s) {        super(s);    }    public void testElapsedTime(){        String text = DateUtils.formatElapsedTime(50*1000);        assertEquals("50 seconds", text);        text = DateUtils.formatElapsedTime(65*1000);        assertEquals("1 minute 5 seconds", text);        text = DateUtils.formatElapsedTime(120*1000);        assertEquals("2 minutes 0 seconds", text);        text = DateUtils.formatElapsedTime(121*1000);        assertEquals("2 minutes 1 second", text);    }    public void testDateTimeISO(){        TimeZone timeZone = TimeZone.getTimeZone("GMT+1");        Calendar cal = Calendar.getInstance(timeZone);        cal.set(2002,1,23,10,11,12);        String text = DateUtils.format(cal.getTime(),                DateUtils.ISO8601_DATETIME_PATTERN);        assertEquals("2002-02-23T09:11:12", text);    }    public void testDateISO(){        TimeZone timeZone = TimeZone.getTimeZone("GMT");        Calendar cal = Calendar.getInstance(timeZone);        cal.set(2002,1,23);        String text = DateUtils.format(cal.getTime(),                DateUtils.ISO8601_DATE_PATTERN);        assertEquals("2002-02-23", text);    }    public void testTimeISODate(){        // make sure that elapsed time in set via date works        TimeZone timeZone = TimeZone.getTimeZone("GMT+1");        Calendar cal = Calendar.getInstance(timeZone);        cal.set(2002,1,23, 21, 11, 12);        String text = DateUtils.format(cal.getTime(),                DateUtils.ISO8601_TIME_PATTERN);        assertEquals("20:11:12", text);    }    public void testTimeISO(){        // make sure that elapsed time in ms works        long ms = (20*3600 + 11*60 + 12)*1000;        String text = DateUtils.format(ms,                DateUtils.ISO8601_TIME_PATTERN);        assertEquals("20:11:12", text);    }    public void testPhaseOfMoon() {        TimeZone timeZone = TimeZone.getTimeZone("GMT");        Calendar cal = Calendar.getInstance(timeZone);        // should be full moon        cal.set(2002, 2, 27);        assertEquals(4, DateUtils.getPhaseOfMoon(cal));        // should be new moon        cal.set(2002, 2, 12);        assertEquals(0, DateUtils.getPhaseOfMoon(cal));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.time;import java.text.SimpleDateFormat;import java.util.Locale;import java.util.TimeZone;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.time.FastDateFormat}. * * @author Sean Schofield * @since 2.0 * @version $Id: FastDateFormatTest.java,v 1.3 2003/05/21 23:41:21 scolebourne Exp $ */public class FastDateFormatTest extends TestCase {    private FastDateFormat fastDateFormat = null;    public FastDateFormatTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(FastDateFormatTest.class);        suite.setName("FastDateFormat Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    public void test_getInstance() {        FastDateFormat format1 = FastDateFormat.getInstance();        FastDateFormat format2 = FastDateFormat.getInstance();        assertSame(format1, format2);        assertEquals(new SimpleDateFormat().toPattern(), format1.getPattern());    }    public void test_getInstance_String() {        FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy");        FastDateFormat format2 = FastDateFormat.getInstance("MM-DD-yyyy");        assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);        assertSame(format1, FastDateFormat.getInstance("MM/DD/yyyy"));        assertEquals("MM/DD/yyyy", format1.getPattern());    }    public void test_getInstance_String_TimeZone() {        Locale realDefaultLocale = Locale.getDefault();        TimeZone realDefaultZone = TimeZone.getDefault();        try {            Locale.setDefault(Locale.US);            TimeZone.setDefault(TimeZone.getTimeZone("America/New_York"));                FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",                    TimeZone.getTimeZone("Atlantic/Reykjavik"));            FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");            FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());            FastDateFormat format4 = FastDateFormat.getInstance("MM/DD/yyyy", TimeZone.getDefault());            FastDateFormat format5 = FastDateFormat.getInstance("MM-DD-yyyy", TimeZone.getDefault());                assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);            assertTrue(format1.getTimeZone().equals(TimeZone.getTimeZone("Atlantic/Reykjavik")));            assertNull(format2.getTimeZone());            assertSame(format3, format4);            assertTrue(format3 != format5); // -- junit 3.8 version -- assertFalse(format3 == format5);                    } finally {            Locale.setDefault(realDefaultLocale);            TimeZone.setDefault(realDefaultZone);        }    }    public void test_getInstance_String_Locale() {        Locale realDefaultLocale = Locale.getDefault();        try {            Locale.setDefault(Locale.US);            FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);            FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy");            FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);            assertSame(format1, format3);            assertSame(Locale.GERMANY, format1.getLocale());                    } finally {            Locale.setDefault(realDefaultLocale);        }    }    public void test_getInstance_String_TimeZone_Locale() {        Locale realDefaultLocale = Locale.getDefault();        TimeZone realDefaultZone = TimeZone.getDefault();        try {            Locale.setDefault(Locale.US);            TimeZone.setDefault(TimeZone.getTimeZone("America/New_York"));                FastDateFormat format1 = FastDateFormat.getInstance("MM/DD/yyyy",                    TimeZone.getTimeZone("Atlantic/Reykjavik"), Locale.GERMANY);            FastDateFormat format2 = FastDateFormat.getInstance("MM/DD/yyyy", Locale.GERMANY);            FastDateFormat format3 = FastDateFormat.getInstance("MM/DD/yyyy",                    TimeZone.getDefault(), Locale.GERMANY);                assertTrue(format1 != format2); // -- junit 3.8 version -- assertNotSame(format1, format2);            assertEquals(format1.getTimeZone(), TimeZone.getTimeZone("Atlantic/Reykjavik"));            assertNull(format2.getTimeZone());            assertEquals(format3.getTimeZone(), TimeZone.getDefault());            assertEquals(format3.getTimeZone(), TimeZone.getTimeZone("America/New_York"));                    } finally {            Locale.setDefault(realDefaultLocale);            TimeZone.setDefault(realDefaultZone);        }    }    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link DoubleRange} class. * * @author Stephen Colebourne * @version $Id: DoubleRangeTest.java,v 1.2 2003/06/08 14:19:43 scolebourne Exp $ */public final class DoubleRangeTest extends AbstractRangeTest {    public DoubleRangeTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(DoubleRangeTest.class);        suite.setName("DoubleRange Tests");        return suite;    }        public void setUp() {        super.setUp();        tenToTwenty = new DoubleRange(double10, double20);        otherRange = new NumberRange(ten, twenty);    }    protected Range createRange(Integer integer1, Integer integer2) {        return new DoubleRange(integer1, integer2);    }    protected Range createRange(Integer integer) {        return new NumberRange(integer);    }        //--------------------------------------------------------------------------    public void testConstructor1a() {        DoubleRange nr = new DoubleRange(8d);        assertEquals(double8, nr.getMinimumNumber());        assertEquals(double8, nr.getMaximumNumber());                try {            new DoubleRange(Double.NaN);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor1b() {        DoubleRange nr = new DoubleRange(double8);        assertSame(double8, nr.getMinimumNumber());        assertSame(double8, nr.getMaximumNumber());                Range r = new DoubleRange(nonComparable);                try {            new DoubleRange(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DoubleRange(new Double(Double.NaN));            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor2a() {        DoubleRange nr = new DoubleRange(8d, 10d);        assertEquals(double8, nr.getMinimumNumber());        assertEquals(double10, nr.getMaximumNumber());                nr = new DoubleRange(10d, 8d);        assertEquals(double8, nr.getMinimumNumber());        assertEquals(double10, nr.getMaximumNumber());                try {            new DoubleRange(Double.NaN, 8d);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor2b() {        DoubleRange nr = new DoubleRange(double8, double10);        assertSame(double8, nr.getMinimumNumber());        assertSame(double10, nr.getMaximumNumber());                nr = new DoubleRange(double10, double8);        assertSame(double8, nr.getMinimumNumber());        assertSame(double10, nr.getMaximumNumber());                nr = new DoubleRange(double8, double10);        assertSame(double8, nr.getMinimumNumber());        assertEquals(double10, nr.getMaximumNumber());                // not null        try {            new DoubleRange(double8, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DoubleRange(null, double8);            fail();        } catch (IllegalArgumentException ex) {}        try {            new DoubleRange(null, null);            fail();        } catch (IllegalArgumentException ex) {}                try {            new DoubleRange(new Double(Double.NaN), double10);            fail();        } catch (IllegalArgumentException ex) {}    }    //--------------------------------------------------------------------------    public void testIncludesNumber() {        assertEquals(false, tenToTwenty.includesNumber(null));        assertEquals(true, tenToTwenty.includesNumber(nonComparable));                assertEquals(false, tenToTwenty.includesNumber(five));        assertEquals(true, tenToTwenty.includesNumber(ten));        assertEquals(true, tenToTwenty.includesNumber(fifteen));        assertEquals(true, tenToTwenty.includesNumber(twenty));        assertEquals(false, tenToTwenty.includesNumber(twentyFive));                assertEquals(false, tenToTwenty.includesNumber(long8));        assertEquals(true, tenToTwenty.includesNumber(long10));        assertEquals(true, tenToTwenty.includesNumber(long12));        assertEquals(true, tenToTwenty.includesNumber(long20));        assertEquals(false, tenToTwenty.includesNumber(long21));                assertEquals(false, tenToTwenty.includesNumber(double8));        assertEquals(true, tenToTwenty.includesNumber(double10));        assertEquals(true, tenToTwenty.includesNumber(double12));        assertEquals(true, tenToTwenty.includesNumber(double20));        assertEquals(false, tenToTwenty.includesNumber(double21));                assertEquals(false, tenToTwenty.includesNumber(float8));        assertEquals(true, tenToTwenty.includesNumber(float10));        assertEquals(true, tenToTwenty.includesNumber(float12));        assertEquals(true, tenToTwenty.includesNumber(float20));        assertEquals(false, tenToTwenty.includesNumber(float21));    }    public void testToString() {        assertEquals("Range[10.0,20.0]", tenToTwenty.toString());        assertEquals("Range[-20.0,-10.0]", createRange(new Integer(-20), new Integer(-10)).toString());    }        //--------------------------------------------------------------------------    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link LongRange} class. * * @author Stephen Colebourne * @version $Id: LongRangeTest.java,v 1.2 2003/06/08 14:19:43 scolebourne Exp $ */public final class LongRangeTest extends AbstractRangeTest {    public LongRangeTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(LongRangeTest.class);        suite.setName("LongRange Tests");        return suite;    }        public void setUp() {        super.setUp();        tenToTwenty = new LongRange(long10, long20);        otherRange = new NumberRange(ten, twenty);    }    protected Range createRange(Integer integer1, Integer integer2) {        return new LongRange(integer1, integer2);    }    protected Range createRange(Integer integer) {        return new NumberRange(integer);    }        //--------------------------------------------------------------------------    public void testConstructor1a() {        LongRange nr = new LongRange(8L);        assertEquals(long8, nr.getMinimumNumber());        assertEquals(long8, nr.getMaximumNumber());    }        public void testConstructor1b() {        LongRange nr = new LongRange(long8);        assertSame(long8, nr.getMinimumNumber());        assertSame(long8, nr.getMaximumNumber());                Range r = new LongRange(nonComparable);                try {            new LongRange(null);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor2a() {        LongRange nr = new LongRange(8L, 10L);        assertEquals(long8, nr.getMinimumNumber());        assertEquals(long10, nr.getMaximumNumber());                nr = new LongRange(10L, 8L);        assertEquals(long8, nr.getMinimumNumber());        assertEquals(long10, nr.getMaximumNumber());    }    public void testConstructor2b() {        LongRange nr = new LongRange(long8, long10);        assertSame(long8, nr.getMinimumNumber());        assertSame(long10, nr.getMaximumNumber());                nr = new LongRange(long10, long8);        assertSame(long8, nr.getMinimumNumber());        assertSame(long10, nr.getMaximumNumber());                nr = new LongRange(long8, long10);        assertSame(long8, nr.getMinimumNumber());        assertEquals(long10, nr.getMaximumNumber());                // not null        try {            new LongRange(long8, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new LongRange(null, long8);            fail();        } catch (IllegalArgumentException ex) {}        try {            new LongRange(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //--------------------------------------------------------------------------    public void testIncludesNumber() {        assertEquals(false, tenToTwenty.includesNumber(null));        assertEquals(true, tenToTwenty.includesNumber(nonComparable));                assertEquals(false, tenToTwenty.includesNumber(five));        assertEquals(true, tenToTwenty.includesNumber(ten));        assertEquals(true, tenToTwenty.includesNumber(fifteen));        assertEquals(true, tenToTwenty.includesNumber(twenty));        assertEquals(false, tenToTwenty.includesNumber(twentyFive));                assertEquals(false, tenToTwenty.includesNumber(long8));        assertEquals(true, tenToTwenty.includesNumber(long10));        assertEquals(true, tenToTwenty.includesNumber(long12));        assertEquals(true, tenToTwenty.includesNumber(long20));        assertEquals(false, tenToTwenty.includesNumber(long21));                assertEquals(false, tenToTwenty.includesNumber(double8));        assertEquals(true, tenToTwenty.includesNumber(double10));        assertEquals(true, tenToTwenty.includesNumber(double12));        assertEquals(true, tenToTwenty.includesNumber(double20));        assertEquals(false, tenToTwenty.includesNumber(double21));                assertEquals(false, tenToTwenty.includesNumber(float8));        assertEquals(true, tenToTwenty.includesNumber(float10));        assertEquals(true, tenToTwenty.includesNumber(float12));        assertEquals(true, tenToTwenty.includesNumber(float20));        assertEquals(false, tenToTwenty.includesNumber(float21));    }    public void testIncludesLongBig() {        LongRange big = new LongRange(Long.MAX_VALUE, Long.MAX_VALUE- 2);        assertEquals(true, big.includesLong(Long.MAX_VALUE - 1));        assertEquals(false, big.includesLong(Long.MAX_VALUE - 3));    }    //--------------------------------------------------------------------------    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link IntRange} class. * * @author Stephen Colebourne * @version $Id: IntRangeTest.java,v 1.2 2003/06/08 14:19:43 scolebourne Exp $ */public final class IntRangeTest extends AbstractRangeTest {    public IntRangeTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(IntRangeTest.class);        suite.setName("IntRange Tests");        return suite;    }        public void setUp() {        super.setUp();        tenToTwenty = new IntRange(ten, twenty);        otherRange = new NumberRange(ten, twenty);    }    protected Range createRange(Integer integer1, Integer integer2) {        return new IntRange(integer1, integer2);    }    protected Range createRange(Integer integer) {        return new NumberRange(integer);    }        //--------------------------------------------------------------------------    public void testConstructor1a() {        IntRange nr = new IntRange(5);        assertEquals(five, nr.getMinimumNumber());        assertEquals(five, nr.getMaximumNumber());    }        public void testConstructor1b() {        IntRange nr = new IntRange(five);        assertSame(five, nr.getMinimumNumber());        assertSame(five, nr.getMaximumNumber());                Range r = new IntRange(nonComparable);                try {            new IntRange(null);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor2a() {        IntRange nr = new IntRange(5, 10);        assertEquals(five, nr.getMinimumNumber());        assertEquals(ten, nr.getMaximumNumber());                nr = new IntRange(5, 10);        assertEquals(five, nr.getMinimumNumber());        assertEquals(ten, nr.getMaximumNumber());    }    public void testConstructor2b() {        IntRange nr = new IntRange(five, ten);        assertSame(five, nr.getMinimumNumber());        assertSame(ten, nr.getMaximumNumber());                nr = new IntRange(ten, five);        assertSame(five, nr.getMinimumNumber());        assertSame(ten, nr.getMaximumNumber());                nr = new IntRange(five, long10);        assertSame(five, nr.getMinimumNumber());        assertEquals(ten, nr.getMaximumNumber());                // not null        try {            new IntRange(five, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new IntRange(null, five);            fail();        } catch (IllegalArgumentException ex) {}        try {            new IntRange(null, null);            fail();        } catch (IllegalArgumentException ex) {}    }    //--------------------------------------------------------------------------    public void testIncludesNumber() {        assertEquals(false, tenToTwenty.includesNumber(null));        assertEquals(true, tenToTwenty.includesNumber(nonComparable));                assertEquals(false, tenToTwenty.includesNumber(five));        assertEquals(true, tenToTwenty.includesNumber(ten));        assertEquals(true, tenToTwenty.includesNumber(fifteen));        assertEquals(true, tenToTwenty.includesNumber(twenty));        assertEquals(false, tenToTwenty.includesNumber(twentyFive));                assertEquals(false, tenToTwenty.includesNumber(long8));        assertEquals(true, tenToTwenty.includesNumber(long10));        assertEquals(true, tenToTwenty.includesNumber(long12));        assertEquals(true, tenToTwenty.includesNumber(long20));        assertEquals(false, tenToTwenty.includesNumber(long21));                assertEquals(false, tenToTwenty.includesNumber(double8));        assertEquals(true, tenToTwenty.includesNumber(double10));        assertEquals(true, tenToTwenty.includesNumber(double12));        assertEquals(true, tenToTwenty.includesNumber(double20));        assertEquals(false, tenToTwenty.includesNumber(double21));                assertEquals(false, tenToTwenty.includesNumber(float8));        assertEquals(true, tenToTwenty.includesNumber(float10));        assertEquals(true, tenToTwenty.includesNumber(float12));        assertEquals(true, tenToTwenty.includesNumber(float20));        assertEquals(false, tenToTwenty.includesNumber(float21));    }    public void testIncludesIntegerBig() {        IntRange big = new IntRange(Integer.MAX_VALUE, Integer.MAX_VALUE- 2);        assertEquals(true, big.includesInteger(Integer.MAX_VALUE - 1));        assertEquals(false, big.includesInteger(Integer.MAX_VALUE - 3));    }    //--------------------------------------------------------------------------    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link FloatRange} class. * * @author Stephen Colebourne * @version $Id: FloatRangeTest.java,v 1.2 2003/06/08 14:19:43 scolebourne Exp $ */public final class FloatRangeTest extends AbstractRangeTest {    public FloatRangeTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(FloatRangeTest.class);        suite.setName("FloatRange Tests");        return suite;    }        public void setUp() {        super.setUp();        tenToTwenty = new FloatRange(float10, float20);        otherRange = new NumberRange(ten, twenty);    }    protected Range createRange(Integer integer1, Integer integer2) {        return new FloatRange(integer1, integer2);    }    protected Range createRange(Integer integer) {        return new NumberRange(integer);    }        //--------------------------------------------------------------------------    public void testConstructor1a() {        FloatRange nr = new FloatRange(8f);        assertEquals(float8, nr.getMinimumNumber());        assertEquals(float8, nr.getMaximumNumber());                try {            new FloatRange(Float.NaN);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor1b() {        FloatRange nr = new FloatRange(float8);        assertSame(float8, nr.getMinimumNumber());        assertSame(float8, nr.getMaximumNumber());                Range r = new FloatRange(nonComparable);                try {            new FloatRange(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new FloatRange(new Double(Double.NaN));            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor2a() {        FloatRange nr = new FloatRange(8f, 10f);        assertEquals(float8, nr.getMinimumNumber());        assertEquals(float10, nr.getMaximumNumber());                nr = new FloatRange(10f, 8f);        assertEquals(float8, nr.getMinimumNumber());        assertEquals(float10, nr.getMaximumNumber());                try {            new FloatRange(Float.NaN, 8f);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testConstructor2b() {        FloatRange nr = new FloatRange(float8, float10);        assertSame(float8, nr.getMinimumNumber());        assertSame(float10, nr.getMaximumNumber());                nr = new FloatRange(float10, float8);        assertSame(float8, nr.getMinimumNumber());        assertSame(float10, nr.getMaximumNumber());                nr = new FloatRange(float8, float10);        assertSame(float8, nr.getMinimumNumber());        assertEquals(float10, nr.getMaximumNumber());                // not null        try {            new FloatRange(float8, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new FloatRange(null, float8);            fail();        } catch (IllegalArgumentException ex) {}        try {            new FloatRange(null, null);            fail();        } catch (IllegalArgumentException ex) {}                try {            new FloatRange(new Double(Double.NaN), float10);            fail();        } catch (IllegalArgumentException ex) {}    }    //--------------------------------------------------------------------------    public void testIncludesNumber() {        assertEquals(false, tenToTwenty.includesNumber(null));        assertEquals(true, tenToTwenty.includesNumber(nonComparable));                assertEquals(false, tenToTwenty.includesNumber(five));        assertEquals(true, tenToTwenty.includesNumber(ten));        assertEquals(true, tenToTwenty.includesNumber(fifteen));        assertEquals(true, tenToTwenty.includesNumber(twenty));        assertEquals(false, tenToTwenty.includesNumber(twentyFive));                assertEquals(false, tenToTwenty.includesNumber(long8));        assertEquals(true, tenToTwenty.includesNumber(long10));        assertEquals(true, tenToTwenty.includesNumber(long12));        assertEquals(true, tenToTwenty.includesNumber(long20));        assertEquals(false, tenToTwenty.includesNumber(long21));                assertEquals(false, tenToTwenty.includesNumber(double8));        assertEquals(true, tenToTwenty.includesNumber(double10));        assertEquals(true, tenToTwenty.includesNumber(double12));        assertEquals(true, tenToTwenty.includesNumber(double20));        assertEquals(false, tenToTwenty.includesNumber(double21));                assertEquals(false, tenToTwenty.includesNumber(float8));        assertEquals(true, tenToTwenty.includesNumber(float10));        assertEquals(true, tenToTwenty.includesNumber(float12));        assertEquals(true, tenToTwenty.includesNumber(float20));        assertEquals(false, tenToTwenty.includesNumber(float21));    }    public void testToString() {        assertEquals("Range[10.0,20.0]", tenToTwenty.toString());        assertEquals("Range[-20.0,-10.0]", createRange(new Integer(-20), new Integer(-10)).toString());    }        //--------------------------------------------------------------------------    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.TestCase;/** * Test cases for the {@link Range} classes. * * @author Stephen Colebourne * @version $Id: AbstractRangeTest.java,v 1.2 2003/06/08 14:19:43 scolebourne Exp $ */public abstract class AbstractRangeTest extends TestCase {    protected Range tenToTwenty;    protected Range otherRange;        protected Integer five;    protected Integer ten;    protected Integer twelve;    protected Integer fifteen;    protected Integer twenty;    protected Integer twentyFive;    protected Long long8;    protected Long long10;    protected Long long12;    protected Long long20;    protected Long long21;    protected Double double8;    protected Double double10;    protected Double double12;    protected Double double20;    protected Double double21;    protected Float float8;    protected Float float10;    protected Float float12;    protected Float float20;    protected Float float21;        private static class InnerNumber extends Number {        public double doubleValue() {            return 12d;        }        public float floatValue() {            return 12f;        }        public int intValue() {            return 12;        }        public long longValue() {            return 12L;        }    }        protected InnerNumber nonComparable = new InnerNumber();    public AbstractRangeTest(String name) {        super(name);    }    public void setUp() {        five        = new Integer(5);        ten         = new Integer(10);        twelve      = new Integer(12);        fifteen     = new Integer(15);        twenty      = new Integer(20);        twentyFive  = new Integer(25);        long8       = new Long(8);        long10      = new Long(10);        long12      = new Long(12);        long20      = new Long(20);        long21      = new Long(21);        double8     = new Double(8);        double10    = new Double(10);        double12    = new Double(12);        double20    = new Double(20);        double21    = new Double(21);        float8      = new Float(8);        float10     = new Float(10);        float12     = new Float(12);        float20     = new Float(20);        float21     = new Float(21);    }    //--------------------------------------------------------------------------    public void testGetMinimum() {        assertEquals(10L, tenToTwenty.getMinimumLong());        assertEquals(10, tenToTwenty.getMinimumInteger());        assertEquals(10d, tenToTwenty.getMinimumDouble(), 0.00001d);        assertEquals(10f, tenToTwenty.getMinimumFloat(), 0.00001f);    }        public void testGetMaximum() {        assertEquals(20L, tenToTwenty.getMaximumLong());        assertEquals(20, tenToTwenty.getMaximumInteger());        assertEquals(20d, tenToTwenty.getMaximumDouble(), 0.00001d);        assertEquals(20f, tenToTwenty.getMaximumFloat(), 0.00001f);    }    //--------------------------------------------------------------------------    public void testIncludesLong() {        assertEquals(false, tenToTwenty.includesLong(null));        assertEquals(true, tenToTwenty.includesLong(nonComparable));                assertEquals(false, tenToTwenty.includesLong(five));        assertEquals(true, tenToTwenty.includesLong(ten));        assertEquals(true, tenToTwenty.includesLong(fifteen));        assertEquals(true, tenToTwenty.includesLong(twenty));        assertEquals(false, tenToTwenty.includesLong(twentyFive));                assertEquals(false, tenToTwenty.includesLong(long8));        assertEquals(true, tenToTwenty.includesLong(long10));        assertEquals(true, tenToTwenty.includesLong(long12));        assertEquals(true, tenToTwenty.includesLong(long20));        assertEquals(false, tenToTwenty.includesLong(long21));                assertEquals(false, tenToTwenty.includesLong(double8));        assertEquals(true, tenToTwenty.includesLong(double10));        assertEquals(true, tenToTwenty.includesLong(double12));        assertEquals(true, tenToTwenty.includesLong(double20));        assertEquals(false, tenToTwenty.includesLong(double21));                assertEquals(false, tenToTwenty.includesLong(float8));        assertEquals(true, tenToTwenty.includesLong(float10));        assertEquals(true, tenToTwenty.includesLong(float12));        assertEquals(true, tenToTwenty.includesLong(float20));        assertEquals(false, tenToTwenty.includesLong(float21));                assertEquals(false, tenToTwenty.includesLong(9L));        assertEquals(true, tenToTwenty.includesLong(10L));        assertEquals(true, tenToTwenty.includesLong(15L));        assertEquals(true, tenToTwenty.includesLong(20L));        assertEquals(false, tenToTwenty.includesLong(21L));    }            public void testIncludesInteger() {        assertEquals(false, tenToTwenty.includesInteger(null));        assertEquals(true, tenToTwenty.includesInteger(nonComparable));                assertEquals(false, tenToTwenty.includesInteger(five));        assertEquals(true, tenToTwenty.includesInteger(ten));        assertEquals(true, tenToTwenty.includesInteger(fifteen));        assertEquals(true, tenToTwenty.includesInteger(twenty));        assertEquals(false, tenToTwenty.includesInteger(twentyFive));                assertEquals(false, tenToTwenty.includesInteger(long8));        assertEquals(true, tenToTwenty.includesInteger(long10));        assertEquals(true, tenToTwenty.includesInteger(long12));        assertEquals(true, tenToTwenty.includesInteger(long20));        assertEquals(false, tenToTwenty.includesInteger(long21));                assertEquals(false, tenToTwenty.includesInteger(double8));        assertEquals(true, tenToTwenty.includesInteger(double10));        assertEquals(true, tenToTwenty.includesInteger(double12));        assertEquals(true, tenToTwenty.includesInteger(double20));        assertEquals(false, tenToTwenty.includesInteger(double21));                assertEquals(false, tenToTwenty.includesInteger(float8));        assertEquals(true, tenToTwenty.includesInteger(float10));        assertEquals(true, tenToTwenty.includesInteger(float12));        assertEquals(true, tenToTwenty.includesInteger(float20));        assertEquals(false, tenToTwenty.includesInteger(float21));                assertEquals(false, tenToTwenty.includesInteger(9));        assertEquals(true, tenToTwenty.includesInteger(10));        assertEquals(true, tenToTwenty.includesInteger(15));        assertEquals(true, tenToTwenty.includesInteger(20));        assertEquals(false, tenToTwenty.includesInteger(21));    }    public void testIncludesDouble() {        assertEquals(false, tenToTwenty.includesDouble(null));        assertEquals(true, tenToTwenty.includesDouble(nonComparable));                assertEquals(false, tenToTwenty.includesDouble(five));        assertEquals(true, tenToTwenty.includesDouble(ten));        assertEquals(true, tenToTwenty.includesDouble(fifteen));        assertEquals(true, tenToTwenty.includesDouble(twenty));        assertEquals(false, tenToTwenty.includesDouble(twentyFive));                assertEquals(false, tenToTwenty.includesDouble(long8));        assertEquals(true, tenToTwenty.includesDouble(long10));        assertEquals(true, tenToTwenty.includesDouble(long12));        assertEquals(true, tenToTwenty.includesDouble(long20));        assertEquals(false, tenToTwenty.includesDouble(long21));                assertEquals(false, tenToTwenty.includesDouble(double8));        assertEquals(true, tenToTwenty.includesDouble(double10));        assertEquals(true, tenToTwenty.includesDouble(double12));        assertEquals(true, tenToTwenty.includesDouble(double20));        assertEquals(false, tenToTwenty.includesDouble(double21));                assertEquals(false, tenToTwenty.includesDouble(float8));        assertEquals(true, tenToTwenty.includesDouble(float10));        assertEquals(true, tenToTwenty.includesDouble(float12));        assertEquals(true, tenToTwenty.includesDouble(float20));        assertEquals(false, tenToTwenty.includesDouble(float21));                assertEquals(false, tenToTwenty.includesDouble(9d));        assertEquals(true, tenToTwenty.includesDouble(10d));        assertEquals(true, tenToTwenty.includesDouble(15d));        assertEquals(true, tenToTwenty.includesDouble(20d));        assertEquals(false, tenToTwenty.includesDouble(21d));    }    public void testIncludesFloat() {        assertEquals(false, tenToTwenty.includesFloat(null));        assertEquals(true, tenToTwenty.includesFloat(nonComparable));                assertEquals(false, tenToTwenty.includesFloat(five));        assertEquals(true, tenToTwenty.includesFloat(ten));        assertEquals(true, tenToTwenty.includesFloat(fifteen));        assertEquals(true, tenToTwenty.includesFloat(twenty));        assertEquals(false, tenToTwenty.includesFloat(twentyFive));                assertEquals(false, tenToTwenty.includesFloat(long8));        assertEquals(true, tenToTwenty.includesFloat(long10));        assertEquals(true, tenToTwenty.includesFloat(long12));        assertEquals(true, tenToTwenty.includesFloat(long20));        assertEquals(false, tenToTwenty.includesFloat(long21));                assertEquals(false, tenToTwenty.includesFloat(double8));        assertEquals(true, tenToTwenty.includesFloat(double10));        assertEquals(true, tenToTwenty.includesFloat(double12));        assertEquals(true, tenToTwenty.includesFloat(double20));        assertEquals(false, tenToTwenty.includesFloat(double21));                assertEquals(false, tenToTwenty.includesFloat(float8));        assertEquals(true, tenToTwenty.includesFloat(float10));        assertEquals(true, tenToTwenty.includesFloat(float12));        assertEquals(true, tenToTwenty.includesFloat(float20));        assertEquals(false, tenToTwenty.includesFloat(float21));                assertEquals(false, tenToTwenty.includesFloat(9f));        assertEquals(true, tenToTwenty.includesFloat(10f));        assertEquals(true, tenToTwenty.includesFloat(15f));        assertEquals(true, tenToTwenty.includesFloat(20f));        assertEquals(false, tenToTwenty.includesFloat(21f));    }    //--------------------------------------------------------------------------    public void testIncludesRange() {        assertEquals(false, tenToTwenty.includesRange(createRange(five, five)));        assertEquals(false, tenToTwenty.includesRange(createRange(five, ten)));        assertEquals(false, tenToTwenty.includesRange(createRange(five, twelve)));        assertEquals(false, tenToTwenty.includesRange(createRange(five, fifteen)));        assertEquals(false, tenToTwenty.includesRange(createRange(five, twenty)));        assertEquals(false, tenToTwenty.includesRange(createRange(five, twentyFive)));                assertEquals(true, tenToTwenty.includesRange(createRange(ten, ten)));        assertEquals(true, tenToTwenty.includesRange(createRange(ten, twelve)));        assertEquals(true, tenToTwenty.includesRange(createRange(ten, fifteen)));        assertEquals(true, tenToTwenty.includesRange(createRange(ten, twenty)));        assertEquals(false, tenToTwenty.includesRange(createRange(ten, twentyFive)));                assertEquals(true, tenToTwenty.includesRange(createRange(twelve, twelve)));        assertEquals(true, tenToTwenty.includesRange(createRange(twelve, fifteen)));        assertEquals(true, tenToTwenty.includesRange(createRange(twelve, twenty)));        assertEquals(false, tenToTwenty.includesRange(createRange(twelve, twentyFive)));                assertEquals(true, tenToTwenty.includesRange(createRange(fifteen, fifteen)));        assertEquals(true, tenToTwenty.includesRange(createRange(fifteen, twenty)));        assertEquals(false, tenToTwenty.includesRange(createRange(fifteen, twentyFive)));                assertEquals(true, tenToTwenty.includesRange(createRange(twenty, twenty)));        assertEquals(false, tenToTwenty.includesRange(createRange(twenty, twentyFive)));                assertEquals(false, tenToTwenty.includesRange(createRange(twentyFive, twentyFive)));    }    public void testOverlapsRange() {        assertEquals(false, tenToTwenty.overlapsRange(createRange(five, five)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, ten)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, twelve)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, fifteen)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, twenty)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(five, twentyFive)));                assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, ten)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, twelve)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, fifteen)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, twenty)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(ten, twentyFive)));                assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, twelve)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, fifteen)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, twenty)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(twelve, twentyFive)));                assertEquals(true, tenToTwenty.overlapsRange(createRange(fifteen, fifteen)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(fifteen, twenty)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(fifteen, twentyFive)));                assertEquals(true, tenToTwenty.overlapsRange(createRange(twenty, twenty)));        assertEquals(true, tenToTwenty.overlapsRange(createRange(twenty, twentyFive)));                assertEquals(false, tenToTwenty.overlapsRange(createRange(twentyFive, twentyFive)));    }    //--------------------------------------------------------------------------    public void testEquals() {        assertEquals(false, tenToTwenty.equals(createRange(ten, fifteen)));        assertEquals(false, tenToTwenty.equals(createRange(ten, twentyFive)));                assertEquals(false, tenToTwenty.equals(createRange(fifteen, twenty)));        assertEquals(false, tenToTwenty.equals(createRange(five, twenty)));                assertEquals(false, tenToTwenty.equals(createRange(five, ten)));        assertEquals(false, tenToTwenty.equals(createRange(ten)));        assertEquals(true, tenToTwenty.equals(createRange(ten, twenty)));        assertEquals(true, tenToTwenty.equals(createRange(twenty, ten)));                assertEquals(false, tenToTwenty.equals(null));        assertEquals(false, tenToTwenty.equals(new Object()));        assertEquals(false, tenToTwenty.equals(otherRange));    }    public void testHashCode() {        assertEquals(tenToTwenty.hashCode(), tenToTwenty.hashCode());        assertTrue(tenToTwenty.hashCode() != 0);    }        public void testToString() {        assertEquals("Range[10,20]", tenToTwenty.toString());        assertEquals("Range[-20,-10]", createRange(new Integer(-20), new Integer(-10)).toString());    }    protected abstract Range createRange(Integer integer);    protected abstract Range createRange(Integer integer1, Integer integer2);}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Fraction} classes. * * @author Stephen Colebourne * @version $Id: FractionTest.java,v 1.2 2002/12/22 21:18:51 scolebourne Exp $ */public class FractionTest extends TestCase {        private static final int SKIP = 17;    public FractionTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(FractionTest.class);        suite.setName("Fraction Tests");        return suite;    }        public void setUp() {    }    //--------------------------------------------------------------------------        public void testConstants() {        assertEquals(0, Fraction.ZERO.getNumerator());        assertEquals(1, Fraction.ZERO.getDenominator());                assertEquals(1, Fraction.ONE.getNumerator());        assertEquals(1, Fraction.ONE.getDenominator());                assertEquals(1, Fraction.ONE_HALF.getNumerator());        assertEquals(2, Fraction.ONE_HALF.getDenominator());                assertEquals(1, Fraction.ONE_THIRD.getNumerator());        assertEquals(3, Fraction.ONE_THIRD.getDenominator());                assertEquals(2, Fraction.TWO_THIRDS.getNumerator());        assertEquals(3, Fraction.TWO_THIRDS.getDenominator());                assertEquals(1, Fraction.ONE_QUARTER.getNumerator());        assertEquals(4, Fraction.ONE_QUARTER.getDenominator());                assertEquals(2, Fraction.TWO_QUARTERS.getNumerator());        assertEquals(4, Fraction.TWO_QUARTERS.getDenominator());                assertEquals(3, Fraction.THREE_QUARTERS.getNumerator());        assertEquals(4, Fraction.THREE_QUARTERS.getDenominator());                assertEquals(1, Fraction.ONE_FIFTH.getNumerator());        assertEquals(5, Fraction.ONE_FIFTH.getDenominator());                assertEquals(2, Fraction.TWO_FIFTHS.getNumerator());        assertEquals(5, Fraction.TWO_FIFTHS.getDenominator());                assertEquals(3, Fraction.THREE_FIFTHS.getNumerator());        assertEquals(5, Fraction.THREE_FIFTHS.getDenominator());                assertEquals(4, Fraction.FOUR_FIFTHS.getNumerator());        assertEquals(5, Fraction.FOUR_FIFTHS.getDenominator());    }        public void testFactory_int_int() {        Fraction f = null;                // zero        f = Fraction.getFraction(0, 1);        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getFraction(0, 2);        assertEquals(0, f.getNumerator());        assertEquals(2, f.getDenominator());                // normal        f = Fraction.getFraction(1, 1);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getFraction(2, 1);        assertEquals(2, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getFraction(23, 345);        assertEquals(23, f.getNumerator());        assertEquals(345, f.getDenominator());                // improper        f = Fraction.getFraction(22, 7);        assertEquals(22, f.getNumerator());        assertEquals(7, f.getDenominator());                // negatives        f = Fraction.getFraction(-6, 10);        assertEquals(-6, f.getNumerator());        assertEquals(10, f.getDenominator());                f = Fraction.getFraction(6, -10);        assertEquals(-6, f.getNumerator());        assertEquals(10, f.getDenominator());                f = Fraction.getFraction(-6, -10);        assertEquals(6, f.getNumerator());        assertEquals(10, f.getDenominator());                // zero denominator        try {            f = Fraction.getFraction(1, 0);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(2, 0);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(-3, 0);        } catch (ArithmeticException ex) {}    }    public void testFactory_int_int_int() {        Fraction f = null;                // zero        f = Fraction.getFraction(0, 0, 2);        assertEquals(0, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getFraction(2, 0, 2);        assertEquals(4, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getFraction(0, 1, 2);        assertEquals(1, f.getNumerator());        assertEquals(2, f.getDenominator());                // normal        f = Fraction.getFraction(1, 1, 2);        assertEquals(3, f.getNumerator());        assertEquals(2, f.getDenominator());                // negatives        try {            f = Fraction.getFraction(1, -6, -10);        } catch (ArithmeticException ex) {}        try {            f = Fraction.getFraction(1, -6, -10);        } catch (ArithmeticException ex) {}        try {            f = Fraction.getFraction(1, -6, -10);        } catch (ArithmeticException ex) {}                // negative whole        f = Fraction.getFraction(-1, 6, 10);        assertEquals(-16, f.getNumerator());        assertEquals(10, f.getDenominator());                try {            f = Fraction.getFraction(-1, -6, 10);        } catch (ArithmeticException ex) {}        try {            f = Fraction.getFraction(-1, 6, -10);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(-1, -6, -10);        } catch (ArithmeticException ex) {}                // zero denominator        try {            f = Fraction.getFraction(0, 1, 0);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(1, 2, 0);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(-1, -3, 0);        } catch (ArithmeticException ex) {}    }    public void testReducedFactory_int_int() {        Fraction f = null;                // zero        f = Fraction.getReducedFraction(0, 1);        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                // normal        f = Fraction.getReducedFraction(1, 1);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getReducedFraction(2, 1);        assertEquals(2, f.getNumerator());        assertEquals(1, f.getDenominator());                // improper        f = Fraction.getReducedFraction(22, 7);        assertEquals(22, f.getNumerator());        assertEquals(7, f.getDenominator());                // negatives        f = Fraction.getReducedFraction(-6, 10);        assertEquals(-3, f.getNumerator());        assertEquals(5, f.getDenominator());                f = Fraction.getReducedFraction(6, -10);        assertEquals(-3, f.getNumerator());        assertEquals(5, f.getDenominator());                f = Fraction.getReducedFraction(-6, -10);        assertEquals(3, f.getNumerator());        assertEquals(5, f.getDenominator());                // zero denominator        try {            f = Fraction.getReducedFraction(1, 0);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getReducedFraction(2, 0);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getReducedFraction(-3, 0);        } catch (ArithmeticException ex) {}        // reduced                f = Fraction.getReducedFraction(0, 2);        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getReducedFraction(2, 2);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getReducedFraction(2, 4);        assertEquals(1, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getReducedFraction(15, 10);        assertEquals(3, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getReducedFraction(121, 22);        assertEquals(11, f.getNumerator());        assertEquals(2, f.getDenominator());    }    public void testFactory_double() {        Fraction f = null;                try {            f = Fraction.getFraction(Double.NaN);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(Double.POSITIVE_INFINITY);        } catch (ArithmeticException ex) {}                try {            f = Fraction.getFraction(Double.NEGATIVE_INFINITY);        } catch (ArithmeticException ex) {}                // zero        f = Fraction.getFraction(0.0d);        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                // one        f = Fraction.getFraction(1.0d);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                // one half        f = Fraction.getFraction(0.5d);        assertEquals(1, f.getNumerator());        assertEquals(2, f.getDenominator());                // negative        f = Fraction.getFraction(-0.875d);        assertEquals(-7, f.getNumerator());        assertEquals(8, f.getDenominator());                // over 1        f = Fraction.getFraction(1.25d);        assertEquals(5, f.getNumerator());        assertEquals(4, f.getDenominator());                // two thirds        f = Fraction.getFraction(0.66666d);        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());                // small        f = Fraction.getFraction(1.0d/10001d);        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                // normal        Fraction f2 = null;        int remainder, number1, number2 = 0;        for (int i = 1; i <= 100; i++) {  // denominator            for (int j = 1; j <= i; j++) {  // numerator                try {                    f = Fraction.getFraction((double) j / (double) i);                } catch (ArithmeticException ex) {                    System.err.println(j + " " + i);                    throw ex;                }                f2 = Fraction.getReducedFraction(j, i);                assertEquals(f2.getNumerator(), f.getNumerator());                assertEquals(f2.getDenominator(), f.getDenominator());            }        }        // save time by skipping some tests!        for (int i = 1001; i <= 10000; i+=SKIP) {  // denominator            for (int j = 1; j <= i; j++) {  // numerator                try {                    f = Fraction.getFraction((double) j / (double) i);                } catch (ArithmeticException ex) {                    System.err.println(j + " " + i);                    throw ex;                }                f2 = Fraction.getReducedFraction(j, i);                assertEquals(f2.getNumerator(), f.getNumerator());                assertEquals(f2.getDenominator(), f.getDenominator());            }        }    }    public void testFactory_String() {        try {            Fraction.getFraction(null);        } catch (IllegalArgumentException ex) {}    }        public void testFactory_String_double() {        Fraction f = null;                f = Fraction.getFraction("0.0");        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getFraction("0.2");        assertEquals(1, f.getNumerator());        assertEquals(5, f.getDenominator());                f = Fraction.getFraction("0.5");        assertEquals(1, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getFraction("0.66666");        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());                try {            f = Fraction.getFraction("2.3R");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction(".");        } catch (NumberFormatException ex) {}    }    public void testFactory_String_proper() {        Fraction f = null;                f = Fraction.getFraction("0 0/1");        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getFraction("1 1/5");        assertEquals(6, f.getNumerator());        assertEquals(5, f.getDenominator());                f = Fraction.getFraction("7 1/2");        assertEquals(15, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getFraction("1 2/4");        assertEquals(6, f.getNumerator());        assertEquals(4, f.getDenominator());                try {            f = Fraction.getFraction("2 3");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction("a 3");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction("2 b/4");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction("2 ");        } catch (NumberFormatException ex) {}        try {            f = Fraction.getFraction(" 3");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction(" ");        } catch (NumberFormatException ex) {}    }    public void testFactory_String_improper() {        Fraction f = null;                f = Fraction.getFraction("0/1");        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                f = Fraction.getFraction("1/5");        assertEquals(1, f.getNumerator());        assertEquals(5, f.getDenominator());                f = Fraction.getFraction("1/2");        assertEquals(1, f.getNumerator());        assertEquals(2, f.getDenominator());                f = Fraction.getFraction("2/3");        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());                f = Fraction.getFraction("7/3");        assertEquals(7, f.getNumerator());        assertEquals(3, f.getDenominator());                f = Fraction.getFraction("2/4");        assertEquals(2, f.getNumerator());        assertEquals(4, f.getDenominator());                try {            f = Fraction.getFraction("2/d");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction("2e/3");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction("2/");        } catch (NumberFormatException ex) {}                try {            f = Fraction.getFraction("/");        } catch (NumberFormatException ex) {}    }    public void testGets() {        Fraction f = null;                f = Fraction.getFraction(3, 5, 6);        assertEquals(23, f.getNumerator());        assertEquals(3, f.getProperWhole());        assertEquals(5, f.getProperNumerator());        assertEquals(6, f.getDenominator());                f = Fraction.getFraction(-3, 5, 6);        assertEquals(-23, f.getNumerator());        assertEquals(-3, f.getProperWhole());        assertEquals(5, f.getProperNumerator());        assertEquals(6, f.getDenominator());    }                public void testConversions() {        Fraction f = null;                f = Fraction.getFraction(3, 7, 8);        assertEquals(3, f.intValue());        assertEquals(3L, f.longValue());        assertEquals(3.875f, f.floatValue(), 0.00001f);        assertEquals(3.875d, f.doubleValue(), 0.00001d);    }        public void testReduce() {        Fraction f = null;                f = Fraction.getFraction(50, 75);        f = f.reduce();        assertEquals(2, f.getNumerator());        assertEquals(3, f.getDenominator());    }        public void testInvert() {        Fraction f = null;                f = Fraction.getFraction(50, 75);        f = f.invert();        assertEquals(75, f.getNumerator());        assertEquals(50, f.getDenominator());                f = Fraction.getFraction(4, 3);        f = f.invert();        assertEquals(3, f.getNumerator());        assertEquals(4, f.getDenominator());                f = Fraction.getFraction(0, 3);        try {            f = f.invert();        } catch (ArithmeticException ex) {}    }        public void testNegate() {        Fraction f = null;                f = Fraction.getFraction(50, 75);        f = f.negate();        assertEquals(-50, f.getNumerator());        assertEquals(75, f.getDenominator());                f = Fraction.getFraction(-50, 75);        f = f.negate();        assertEquals(50, f.getNumerator());        assertEquals(75, f.getDenominator());    }        public void testAbs() {        Fraction f = null;                f = Fraction.getFraction(50, 75);        f = f.abs();        assertEquals(50, f.getNumerator());        assertEquals(75, f.getDenominator());                f = Fraction.getFraction(-50, 75);        f = f.abs();        assertEquals(50, f.getNumerator());        assertEquals(75, f.getDenominator());    }        public void testPow() {        Fraction f = null;                f = Fraction.getFraction(3, 5);        assertEquals(Fraction.ONE, f.pow(0));                f = Fraction.getFraction(3, 5);        assertSame(f, f.pow(1));        f = Fraction.getFraction(3, 5);        f = f.pow(2);        assertEquals(9, f.getNumerator());        assertEquals(25, f.getDenominator());                f = Fraction.getFraction(3, 5);        f = f.pow(3);        assertEquals(27, f.getNumerator());        assertEquals(125, f.getDenominator());                f = Fraction.getFraction(3, 5);        f = f.pow(-1);        assertEquals(5, f.getNumerator());        assertEquals(3, f.getDenominator());                f = Fraction.getFraction(3, 5);        f = f.pow(-2);        assertEquals(25, f.getNumerator());        assertEquals(9, f.getDenominator());    }        public void testAdd() {        Fraction f = null;        Fraction f1 = null;        Fraction f2 = null;                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(1, 5);        f = f1.add(f2);        assertEquals(4, f.getNumerator());        assertEquals(5, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(2, 5);        f = f1.add(f2);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(3, 5);        f = f1.add(f2);        assertEquals(6, f.getNumerator());        assertEquals(5, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(-4, 5);        f = f1.add(f2);        assertEquals(-1, f.getNumerator());        assertEquals(5, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(1, 2);        f = f1.add(f2);        assertEquals(11, f.getNumerator());        assertEquals(10, f.getDenominator());                f1 = Fraction.getFraction(0, 5);        f2 = Fraction.getFraction(1, 5);        f = f1.add(f2);        assertSame(f2, f);        f = f2.add(f1);        assertSame(f2, f);                try {            f.add(null);        } catch (IllegalArgumentException ex) {}    }                public void testSubtract() {        Fraction f = null;        Fraction f1 = null;        Fraction f2 = null;                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(1, 5);        f = f1.subtract(f2);        assertEquals(2, f.getNumerator());        assertEquals(5, f.getDenominator());                f1 = Fraction.getFraction(7, 5);        f2 = Fraction.getFraction(2, 5);        f = f1.subtract(f2);        assertEquals(1, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(3, 5);        f = f1.subtract(f2);        assertEquals(0, f.getNumerator());        assertEquals(1, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(-4, 5);        f = f1.subtract(f2);        assertEquals(7, f.getNumerator());        assertEquals(5, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(1, 2);        f = f1.subtract(f2);        assertEquals(1, f.getNumerator());        assertEquals(10, f.getDenominator());                f1 = Fraction.getFraction(0, 5);        f2 = Fraction.getFraction(1, 5);        f = f2.subtract(f1);        assertSame(f2, f);                try {            f.subtract(null);        } catch (IllegalArgumentException ex) {}    }                public void testMultiply() {        Fraction f = null;        Fraction f1 = null;        Fraction f2 = null;                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(2, 5);        f = f1.multiplyBy(f2);        assertEquals(6, f.getNumerator());        assertEquals(25, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(-2, 5);        f = f1.multiplyBy(f2);        assertEquals(-6, f.getNumerator());        assertEquals(25, f.getDenominator());                f1 = Fraction.getFraction(-3, 5);        f2 = Fraction.getFraction(-2, 5);        f = f1.multiplyBy(f2);        assertEquals(6, f.getNumerator());        assertEquals(25, f.getDenominator());                f1 = Fraction.getFraction(0, 5);        f2 = Fraction.getFraction(2, 7);        f = f1.multiplyBy(f2);        assertSame(Fraction.ZERO, f);                try {            f.multiplyBy(null);        } catch (IllegalArgumentException ex) {}    }                public void testDivide() {        Fraction f = null;        Fraction f1 = null;        Fraction f2 = null;                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(2, 5);        f = f1.divideBy(f2);        assertEquals(3, f.getNumerator());        assertEquals(2, f.getDenominator());                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.ZERO;        try {            f = f1.divideBy(f2);        } catch (ArithmeticException ex) {}                f1 = Fraction.getFraction(0, 5);        f2 = Fraction.getFraction(2, 7);        f = f1.divideBy(f2);        assertSame(Fraction.ZERO, f);                try {            f.divideBy(null);        } catch (IllegalArgumentException ex) {}    }                public void testEquals() {        Fraction f1 = null;        Fraction f2 = null;                f1 = Fraction.getFraction(3, 5);        assertEquals(false, f1.equals(null));        assertEquals(false, f1.equals(new Object()));        assertEquals(false, f1.equals(new Integer(6)));                f1 = Fraction.getFraction(3, 5);        f2 = Fraction.getFraction(2, 5);        assertEquals(false, f1.equals(f2));        assertEquals(true, f1.equals(f1));        assertEquals(true, f2.equals(f2));                f2 = Fraction.getFraction(3, 5);        assertEquals(true, f1.equals(f2));                f2 = Fraction.getFraction(6, 10);        assertEquals(false, f1.equals(f2));    }        public void testHashCode() {        Fraction f1 = Fraction.getFraction(3, 5);        Fraction f2 = Fraction.getFraction(3, 5);                assertTrue(f1.hashCode() == f2.hashCode());                f2 = Fraction.getFraction(2, 5);        assertTrue(f1.hashCode() != f2.hashCode());                f2 = Fraction.getFraction(6, 10);        assertTrue(f1.hashCode() != f2.hashCode());    }        public void testCompareTo() {        Fraction f1 = null;        Fraction f2 = null;                f1 = Fraction.getFraction(3, 5);                try {            f1.compareTo(null);        } catch (NullPointerException ex) {}                try {            f1.compareTo(new Object());        } catch (ClassCastException ex) {}                f2 = Fraction.getFraction(2, 5);        assertTrue(f1.compareTo(f2) > 0);                f2 = Fraction.getFraction(4, 5);        assertTrue(f1.compareTo(f2) < 0);                f2 = Fraction.getFraction(3, 5);        assertTrue(f1.compareTo(f2) == 0);                f2 = Fraction.getFraction(6, 10);        assertTrue(f1.compareTo(f2) == 0);    }        public void testToString() {        Fraction f = null;        f = Fraction.getFraction(3, 5);        assertEquals("3/5", f.toString());                f = Fraction.getFraction(7, 5);        assertEquals("7/5", f.toString());                        f = Fraction.getFraction(4, 2);        assertEquals("4/2", f.toString());                        f = Fraction.getFraction(0, 2);        assertEquals("0/2", f.toString());                        f = Fraction.getFraction(2, 2);        assertEquals("2/2", f.toString());            }        public void testToProperString() {        Fraction f = null;        f = Fraction.getFraction(3, 5);        assertEquals("3/5", f.toProperString());                        f = Fraction.getFraction(7, 5);        assertEquals("1 2/5", f.toProperString());                        f = Fraction.getFraction(14, 10);        assertEquals("1 4/10", f.toProperString());                        f = Fraction.getFraction(4, 2);        assertEquals("2", f.toProperString());                        f = Fraction.getFraction(0, 2);        assertEquals("0", f.toProperString());                        f = Fraction.getFraction(2, 2);        assertEquals("1", f.toProperString());                        f = Fraction.getFraction(-7, 5);        assertEquals("-1 2/5", f.toProperString());            }    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import junit.framework.Test;import junit.framework.TestSuite;/** * Test cases for the {@link NumberRange} class. * * @author <a href="mailto:chrise@esha.com">Christopher Elkins</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @author Stephen Colebourne * @version $Id: NumberRangeTest.java,v 1.2 2003/06/08 14:19:43 scolebourne Exp $ */public final class NumberRangeTest extends AbstractRangeTest {    public NumberRangeTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberRangeTest.class);        suite.setName("NumberRange Tests");        return suite;    }        public void setUp() {        super.setUp();        tenToTwenty = new NumberRange(ten, twenty);        otherRange = new IntRange(ten, twenty);    }    protected Range createRange(Integer integer1, Integer integer2) {        return new NumberRange(integer1, integer2);    }    protected Range createRange(Integer integer) {        return new NumberRange(integer);    }    //--------------------------------------------------------------------------    public void testConstructor1() {        NumberRange nr = new NumberRange(five);        assertSame(five, nr.getMinimumNumber());        assertSame(five, nr.getMaximumNumber());                try {            new NumberRange(null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new NumberRange(nonComparable);            fail();        } catch (IllegalArgumentException ex) {}    }        public void testConstructor2() {        NumberRange nr = new NumberRange(five, ten);        assertSame(five, nr.getMinimumNumber());        assertSame(ten, nr.getMaximumNumber());                nr = new NumberRange(ten, five);        assertSame(five, nr.getMinimumNumber());        assertSame(ten, nr.getMaximumNumber());                // not null        try {            new NumberRange(five, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            new NumberRange(null, five);            fail();        } catch (IllegalArgumentException ex) {}        try {            new NumberRange(null, null);            fail();        } catch (IllegalArgumentException ex) {}                // no mixed types        try {            new NumberRange(five, long21);            fail();        } catch (IllegalArgumentException ex) {}                // must be comparable        try {            new NumberRange(nonComparable, nonComparable);            fail();        } catch (IllegalArgumentException ex) {}                // no double NaN        try {            new NumberRange(new Double(0), new Double(Double.NaN));            fail();        } catch (IllegalArgumentException ex) {}                try {            new NumberRange(new Double(Double.NaN), new Double(0));            fail();        } catch (IllegalArgumentException ex) {}                // no float NaN        try {            new NumberRange(new Float(0), new Float(Float.NaN));            fail();        } catch (IllegalArgumentException ex) {}                try {            new NumberRange(new Float(Float.NaN), new Float(0));            fail();        } catch (IllegalArgumentException ex) {}    }    //--------------------------------------------------------------------------    public void testIncludesNumber() {        assertEquals(false, tenToTwenty.includesNumber(null));        assertEquals(false, tenToTwenty.includesNumber(five));        assertEquals(true, tenToTwenty.includesNumber(ten));        assertEquals(true, tenToTwenty.includesNumber(fifteen));        assertEquals(true, tenToTwenty.includesNumber(twenty));        assertEquals(false, tenToTwenty.includesNumber(twentyFive));                try {            tenToTwenty.includesNumber(long21);            fail();        } catch (IllegalArgumentException ex) {}    }    public void testIncludesLongBig() {        // original NumberRange class failed this test        NumberRange big = new NumberRange(new Long(Long.MAX_VALUE), new Long(Long.MAX_VALUE- 2));        assertEquals(true, big.includesLong(Long.MAX_VALUE - 1));        assertEquals(false, big.includesLong(Long.MAX_VALUE - 3));    }    //--------------------------------------------------------------------------}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.math;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link RandomUtils} class. * * @author <a href="mailto:phil@steitz.com">Phil Steitz</a> * @version $Revision: 1.2 $ $Date: 2003/06/08 14:19:43 $ */public final class RandomUtilsTest extends TestCase {    public RandomUtilsTest(String name) {        super(name);    }        public void setUp() {    }        public static Test suite() {        TestSuite suite = new TestSuite(RandomUtilsTest.class);        suite.setName("RandomUtils Tests");        return suite;    }        /** test distribution of nextInt() */    public void testNextInt() {        tstNextInt(null);    }        /** test distribution of nextInt(Random) */    public void testNextInt2() {        Random rnd = new Random();        rnd.setSeed(System.currentTimeMillis());        tstNextInt(rnd);    }         /**      * Generate 1000 values for nextInt(bound) and compare     * the observed frequency counts to expected counts using     * a chi-square test.     * @param rnd Random to use if not null     */    private void tstNextInt(Random rnd) {        int bound = 0;        int result = 0;        // test boundary condition: n = Integer.MAX_VALUE;        bound = Integer.MAX_VALUE;        if (rnd == null) {            result = RandomUtils.nextInt(bound);        } else {            result = RandomUtils.nextInt(rnd,bound);        }              assertTrue("result less than bound",result < bound);        assertTrue("result non-negative",result >= 0);                // test uniformity -- use Chi-Square test at .01 level        bound = 4;        int[] expected = new int[] {250,250,250,250};        int[] observed = new int[] {0,0,0,0};        for (int i = 0; i < 1000; i ++) {            if (rnd == null) {                result = RandomUtils.nextInt(bound);            } else {                result = RandomUtils.nextInt(rnd,bound);            }                 assertTrue(result < bound);            assertTrue(result >= 0);            observed[result]++;        }         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .01         * Change to 16.27 for alpha = .001         */        assertTrue(            "chi-square test -- will fail about 1 in 100 times",            chiSquare(expected,observed) < 11.34);                                                                }          /** test distribution of nextLong() */    public void testNextLong() {        tstNextLong(null);    }        /** test distribution of nextLong(Random) BROKEN     *  contract of nextLong(Random) is different from     * nextLong() */    public void testNextLong2() {        Random rnd = new Random();        rnd.setSeed(System.currentTimeMillis());        tstNextLong(rnd);    }         /**      * Generate 1000 values for nextLong and check that     * p(value < long.MAXVALUE/2) ~ 0.5. Use chi-square test     * with df = 2-1 = 1       * @param rnd Random to use if not null     */    private void tstNextLong(Random rnd) {        int[] expected = new int[] {500,500};        int[] observed = new int[] {0,0};        long result = 0;        long midPoint = Long.MAX_VALUE/2;        for (int i = 0; i < 1000; i ++) {            if (rnd == null) {                result = Math.abs(RandomUtils.nextLong());            } else {                result = Math.abs(RandomUtils.nextLong(rnd));            }              if (result < midPoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01         * Change to 10.83 for alpha = .001          */         assertTrue(            "chi-square test -- will fail about 1 in 100 times",            chiSquare(expected,observed) < 6.64);     }                /** test distribution of nextBoolean() */    public void testNextBoolean() {        tstNextBoolean(null);    }        /** test distribution of nextBoolean(Random) */    public void testNextBoolean2() {        Random rnd = new Random();        rnd.setSeed(System.currentTimeMillis());        tstNextBoolean(rnd);    }        /**      * Generate 1000 values for nextBoolean and check that     * p(value = false) ~ 0.5. Use chi-square test     * with df = 2-1 = 1       * @param rnd Random to use if not null     */    private void tstNextBoolean(Random rnd) {        int[] expected = new int[] {500,500};        int[] observed = new int[] {0,0};        boolean result = false;        for (int i = 0; i < 1000; i ++) {            if (rnd == null) {                result = RandomUtils.nextBoolean();            } else {                result = RandomUtils.nextBoolean(rnd);            }                 if (result) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01         * Change to 10.83 for alpha = .001         */        assertTrue(            "chi-square test -- will fail about 1 in 100 times",            chiSquare(expected,observed) < 6.64);      }        /** test distribution of nextFloat() */    public void testNextFloat() {        tstNextFloat(null);    }        /** test distribution of nextFloat(Random) */    public void testNextFloat2() {        Random rnd = new Random();        rnd.setSeed(System.currentTimeMillis());        tstNextFloat(rnd);    }        /**      * Generate 1000 values for nextFloat and check that     * p(value < 0.5) ~ 0.5. Use chi-square test     * with df = 2-1 = 1       * @param rnd Random to use if not null     */    private void tstNextFloat(Random rnd) {        int[] expected = new int[] {500,500};        int[] observed = new int[] {0,0};        float result = 0;        for (int i = 0; i < 1000; i ++) {            if (rnd == null) {                result = RandomUtils.nextFloat();            } else {                result = RandomUtils.nextFloat(rnd);            }                 if (result < 0.5) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01         * Change to 10.83 for alpha = .001         */        assertTrue(            "chi-square test -- will fail about 1 in 100 times",            chiSquare(expected,observed) < 6.64);      }        /** test distribution of nextDouble() */    public void testNextDouble() {        tstNextDouble(null);    }        /** test distribution of nextDouble(Random) */    public void testNextDouble2() {        Random rnd = new Random();        rnd.setSeed(System.currentTimeMillis());        tstNextDouble(rnd);    }        /**      * Generate 1000 values for nextFloat and check that     * p(value < 0.5) ~ 0.5. Use chi-square test     * with df = 2-1 = 1       * @param rnd Random to use if not null     */    private void tstNextDouble(Random rnd) {        int[] expected = new int[] {500,500};        int[] observed = new int[] {0,0};        double result = 0;        for (int i = 0; i < 1000; i ++) {            if (rnd == null) {                result = RandomUtils.nextDouble();            } else {                result = RandomUtils.nextDouble(rnd);            }                 if (result < 0.5) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .01         * Change to 10.83 for alpha = .001         */        assertTrue(            "chi-square test -- will fail about 1 in 100 times",            chiSquare(expected,observed) < 6.64);      }        /** make sure that setSeed fails */    public void testSetSeed() {        try {            RandomUtils.JVM_RANDOM.setSeed(1000);            fail("expecting UnsupportedOperationException");        } catch (UnsupportedOperationException ex) {            ;        }    }        /**     * Computes Chi-Square statistic given observed and expected counts     * @param observed array of observed frequency counts     * @param expected array of exptected frequency counts     */    private double chiSquare(int[] expected, int[] observed) {        double sumSq = 0.0d;        double dev = 0.0d;        for (int i = 0; i< observed.length; i++) {            dev = (double)(observed[i] - expected[i]);            sumSq += dev*dev/(double)expected[i];        }        return sumSq;    }           }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: StandardToStringStyleTest.java,v 1.3 2003/05/21 23:49:15 scolebourne Exp $ */public class StandardToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = "Integer";        private static final StandardToStringStyle STYLE = new StandardToStringStyle();        static {        STYLE.setShortClassName(true);        STYLE.setUseIdentityHashCode(false);        STYLE.setArrayStart("[");        STYLE.setArraySeparator(", ");        STYLE.setArrayEnd("]");        STYLE.setNullText("%NULL%");        STYLE.setSizeStartText("%SIZE=");        STYLE.setSizeEndText("%");        STYLE.setSummaryObjectStartText("%");        STYLE.setSummaryObjectEndText("%");    }        public StandardToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(StandardToStringStyleTest.class);        suite.setName("StandardToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }    public void testAppendSuper() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).appendSuper("Integer@8888[%NULL%]").toString());                assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());        assertEquals(baseStr + "[%NULL%,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[%NULL%]").append("a", "hello").toString());        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[a=%NULL%]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[a=%Integer%]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: DefaultToStringStyleTest.java,v 1.3 2003/05/21 23:49:14 scolebourne Exp $ */public class DefaultToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public DefaultToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(DefaultToStringStyleTest.class);        suite.setName("DefaultToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }    public void testAppendSuper() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());                assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());        assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.HashCodeBuilder}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: HashCodeBuilderTest.java,v 1.4 2003/05/21 23:49:15 scolebourne Exp $ */public class HashCodeBuilderTest extends TestCase {    public HashCodeBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(HashCodeBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testConstructorEx1() {        try {            new HashCodeBuilder(0, 0);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testConstructorEx2() {        try {            new HashCodeBuilder(2, 2);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    static class TestObject {        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }    }    static class TestSubObject extends TestObject {        private int b;        transient private int t;        public TestSubObject() {            super(0);        }        public TestSubObject(int a, int b, int t) {            super(a);            this.b = b;            this.t = t;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestSubObject)) {                return false;            }            TestSubObject rhs = (TestSubObject) o;            return super.equals(o) && (b == rhs.b);        }    }    public void testReflectionHashCode() {        assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));        assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));    }    public void testReflectionHierarchyHashCode() {        assertEquals(17 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0)));        assertEquals(17 * 37 * 37 * 37, HashCodeBuilder.reflectionHashCode(new TestSubObject(0, 0, 0), true));        assertEquals((17 * 37 + 7890) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0)));        assertEquals(((17 * 37 + 7890) * 37 + 0) * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestSubObject(123456, 7890, 0), true));    }    public void testReflectionHierarchyHashCodeEx1() {        try {            HashCodeBuilder.reflectionHashCode(0, 0, new TestSubObject(0, 0, 0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHierarchyHashCodeEx2() {        try {            HashCodeBuilder.reflectionHashCode(2, 2, new TestSubObject(0, 0, 0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx1() {        try {            HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx2() {        try {            HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx3() {        try {            HashCodeBuilder.reflectionHashCode(13, 19, null, true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testSuper() {        Object obj = new Object();        assertEquals(17 * 37 + (19 * 41 + obj.hashCode()), new HashCodeBuilder(17, 37).appendSuper(            new HashCodeBuilder(19, 41).append(obj).toHashCode()        ).toHashCode());    }    public void testObject() {        Object obj = null;        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj = new Object();        assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLong() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append((long) 123456789L).toHashCode());    }    public void testInt() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode());        assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode());    }    public void testShort() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());        assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());    }    public void testChar() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());        assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());    }    public void testByte() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());        assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());    }    public void testDouble() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());        double d = 1234567.89;        long l = Double.doubleToLongBits(d);        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());    }    public void testFloat() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());        float f = 1234.89f;        int i = Float.floatToIntBits(f);        assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());    }    public void testBoolean() {        assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());        assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());    }    public void testObjectArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testObjectArrayAsObject() {        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testLongArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLongArrayAsObject() {        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testIntArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testIntArrayAsObject() {        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testShortArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testShortArrayAsObject() {        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testCharArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testCharArrayAsObject() {        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testByteArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testByteArrayAsObject() {        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testDoubleArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testDoubleArrayAsObject() {        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testFloatArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testFloatArrayAsObject() {        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testBooleanArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testBooleanArrayAsObject() {        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testBooleanMultiArray() {        boolean[][] obj = new boolean[2][];        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[0];        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[1];        assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[2];        assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0][0] = true;        assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new boolean[1];        assertEquals( (((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests for {@link org.apache.commons.lang.ToStringBuilder}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a> * @author <a href="mailto:alex@apache.org">Alex Chaffee</a> * @version $Id: ToStringBuilderTest.java,v 1.8 2003/06/03 20:15:32 ggregory Exp $ */public class ToStringBuilderTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public ToStringBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(ToStringBuilderTest.class);        suite.setName("ToStringBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testConstructorEx1() {        try {            new ToStringBuilder(null);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testConstructorEx2() {        try {            new ToStringBuilder(null, null);                    } catch (IllegalArgumentException ex) {            try {                new ToStringBuilder(base, null);                            } catch (Exception ex2) {                fail();            }            return;        }        fail();    }    public void testConstructorEx3() {        try {            new ToStringBuilder(null, null, null);                    } catch (IllegalArgumentException ex) {            try {                new ToStringBuilder(base, null, null);                new ToStringBuilder(base, ToStringStyle.DEFAULT_STYLE, null);                            } catch (Exception ex2) {                fail();            }            return;        }        fail();    }    public void testGetSetDefault() {        try {            ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);            assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle());        } finally {            // reset for other tests            ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);        }    }    public void testSetDefaultEx() {        try {            ToStringBuilder.setDefaultStyle(null);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }        /**     * Test wrapper for int primitive.     */    public void testReflectionInteger() {        assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base));    }    /**     * Test wrapper for char primitive.     */    public void testReflectionCharacter() {        Character c = new Character('A');        assertEquals(this.toBaseString(c) + "[value=A]", ToStringBuilder.reflectionToString(c));    }    /**     * Test wrapper for char boolean.     */    public void testReflectionBoolean() {        Boolean b;        b = Boolean.TRUE;        assertEquals(this.toBaseString(b) + "[value=true]", ToStringBuilder.reflectionToString(b));        b = Boolean.FALSE;        assertEquals(this.toBaseString(b) + "[value=false]", ToStringBuilder.reflectionToString(b));    }    /**     * Create the same toString() as Object.toString().     * @param o the object to create the string for.     * @return a String in the Object.toString format.     */    private String toBaseString(Object o) {        return o.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(o));    }        // Reflection Array tests        //    // Note on the following line of code repeated in the reflection array tests.    //    // assertReflectionArray("<null>", array);    //    // The expected value is not baseStr + "[<null>]" since array==null and is typed as Object.    // The null array does not carry array type information.    // If we added a primitive array type constructor and pile of associated methods,     // then type declaring type information could be carried forward. IMHO, null is null.    //    // Gary Gregory - 2003-03-12 - ggregory@seagullsw.com      //        public void assertReflectionArray(String expected, Object actual) {        if (actual == null) {            // Until ToStringBuilder supports null objects.            return;        }        assertEquals(expected, ToStringBuilder.reflectionToString(actual));        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null));        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, true));        assertEquals(expected, ToStringBuilder.reflectionToString(actual, null, false));    }    public void testReflectionObjectArray() {        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{<null>,5,{3,6}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionLongArray() {        long[] array = new long[] { 1, 2, -3, 4 };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionIntArray() {        int[] array = new int[] { 1, 2, -3, 4 };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionShortArray() {        short[] array = new short[] { 1, 2, -3, 4 };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionyteArray() {        byte[] array = new byte[] { 1, 2, -3, 4 };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{1,2,-3,4}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionCharArray() {        char[] array = new char[] { 'A', '2', '_', 'D' };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{A,2,_,D}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionDoubleArray() {        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionFloatArray() {        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionBooleanArray() {        boolean[] array = new boolean[] { true, false, false };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{true,false,false}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }        // Reflection Array Array tests    public void testReflectionFloatArrayArray() {        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionLongArrayArray() {        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionIntArrayArray() {        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionhortArrayArray() {        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionByteArrayArray() {        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionCharArrayArray() {        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionDoubleArrayArray() {        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }    public void testReflectionBooleanArrayArray() {        boolean[][] array = new boolean[][] { { true, false }, null, { false } };        String baseStr = this.toBaseString(array);        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array));        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", ToStringBuilder.reflectionToString(array));        array = null;        assertReflectionArray("<null>", array);        this.validateEmptyReflectionRegistry();    }        // Reflection hierarchy tests    public void testReflectionHierarchyArrayList() {        List base = new ArrayList();        String baseStr = this.toBaseString(base);        assertEquals(baseStr + "[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]", ToStringBuilder.reflectionToString(base, null, true));        assertEquals(baseStr + "[size=0]", ToStringBuilder.reflectionToString(base, null, false));        this.validateEmptyReflectionRegistry();    }    public void testReflectionHierarchy() {        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();        String baseStr = this.toBaseString(baseA);        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA));        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null));        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false));        assertEquals(baseStr + "[a=a,transientA=t]", ToStringBuilder.reflectionToString(baseA, null, true));        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, null));        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, List.class));        assertEquals(baseStr + "[a=a]", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));                ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();        baseStr = this.toBaseString(baseB);        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false));        assertEquals(baseStr + "[b=b,transientB=t,a=a,transientA=t]", ToStringBuilder.reflectionToString(baseB, null, true));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, null));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, List.class));        assertEquals(baseStr + "[b=b,a=a]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));        assertEquals(baseStr + "[b=b]", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));        this.validateEmptyReflectionRegistry();    }static class ReflectionTestFixtureA {private char a='a';        private transient char transientA='t';}static class ReflectionTestFixtureB extends ReflectionTestFixtureA {private char b='b';        private transient char transientB='t';}    public void testInnerClassReflection() {        Outer outer = new Outer();        assertEquals(toBaseString(outer) + "[inner=" + toBaseString(outer.inner) + "[]]", outer.toString());    }        static class Outer {        Inner inner = new Inner();        class Inner {            public String toString() {                return ToStringBuilder.reflectionToString(this);            }        }        public String toString() {            return ToStringBuilder.reflectionToString(this);        }    }        // Reflection cycle tests    /**     * Test an array element pointing to its container.     */    public void testReflectionArrayCycle() throws Exception {        Object[] objects = new Object[1];        objects[0] = objects;        assertEquals(            this.toBaseString(objects) + "[{" + this.toBaseString(objects) + "}]",            ToStringBuilder.reflectionToString(objects));        this.validateEmptyReflectionRegistry();    }    /**     * Test an array element pointing to its container.     */    public void testReflectionArrayCycleLevel2() throws Exception {        Object[] objects = new Object[1];        Object[] objectsLevel2 = new Object[1];        objects[0] = objectsLevel2;        objectsLevel2[0] = (Object) objects;        assertEquals(            this.toBaseString(objects) + "[{{" + this.toBaseString(objects) + "}}]",            ToStringBuilder.reflectionToString(objects));        assertEquals(            this.toBaseString(objectsLevel2) + "[{{" + this.toBaseString(objectsLevel2) + "}}]",            ToStringBuilder.reflectionToString(objectsLevel2));        this.validateEmptyReflectionRegistry();    }    public void testReflectionArrayArrayCycle() throws Exception {        Object[][] objects = new Object[2][2];        objects[0][0] = objects;        objects[0][1] = objects;        objects[1][0] = objects;        objects[1][1] = objects;        String basicToString = this.toBaseString(objects);        assertEquals(            basicToString                + "[{{"                + basicToString                + ","                + basicToString                + "},{"                + basicToString                + ","                + basicToString                + "}}]",            ToStringBuilder.reflectionToString(objects));        this.validateEmptyReflectionRegistry();    }    /**     * A reflection test fixture.     */    static class ReflectionTestCycleA {        ReflectionTestCycleB b;        public String toString() {            return ToStringBuilder.reflectionToString(this);        }    }    /**     * A reflection test fixture.     */    static class ReflectionTestCycleB {        ReflectionTestCycleA a;        public String toString() {            return ToStringBuilder.reflectionToString(this);        }    }    /**     * A reflection test fixture.     */    static class SimpleReflectionTestFixture {        Object o;        public SimpleReflectionTestFixture() {        }        public SimpleReflectionTestFixture(Object o) {            this.o = o;        }        public String toString() {            return ToStringBuilder.reflectionToString(this);        }    }    /**     * Test an Object pointing to itself, the simplest test.     *      * @throws Exception     */    public void testSimpleReflectionObjectCycle() throws Exception {        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();        simple.o = simple;        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());        assertEquals(this.toBaseString(simple) + "[o=" + this.toBaseString(simple) + "]", simple.toString());        this.validateEmptyReflectionRegistry();    }    /**     * Test Objects pointing to each other.     *      * @throws Exception     */    public void testReflectionObjectCycle() throws Exception {        ReflectionTestCycleA a = new ReflectionTestCycleA();        ReflectionTestCycleB b = new ReflectionTestCycleB();        a.b = b;        b.a = a;        assertEquals(            this.toBaseString(a) + "[b=" + this.toBaseString(b) + "[a=" + this.toBaseString(a) + "]]",            a.toString());        this.validateEmptyReflectionRegistry();    }    /**     * Test a nasty combination of arrays and Objects pointing to each other.     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]     *      * @throws Exception     */    public void testReflectionArrayAndObjectCycle() throws Exception {        Object[] objects = new Object[1];        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);        objects[0] = (Object) simple;        assertEquals(            this.toBaseString(objects)                + "[{"                + this.toBaseString(simple)                + "[o="                + this.toBaseString(objects)                + "]"                + "}]",            ToStringBuilder.reflectionToString(objects));        assertEquals(            this.toBaseString(simple)                + "[o={"                + this.toBaseString(simple)                + "}]",            ToStringBuilder.reflectionToString(simple));        this.validateEmptyReflectionRegistry();    }            void validateEmptyReflectionRegistry() {        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());            }    //  End: Reflection cycle tests    public void testAppendSuper() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());                assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());        assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());    }        public void testAppendToString() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendToString("Integer@8888[]").toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").toString());                assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[]").append("a", "hello").toString());        assertEquals(baseStr + "[<null>,a=hello]", new ToStringBuilder(base).appendToString("Integer@8888[<null>]").append("a", "hello").toString());        assertEquals(baseStr + "[a=hello]", new ToStringBuilder(base).appendToString(null).append("a", "hello").toString());    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testInt() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((int) 3).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (int) 3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (int) 3).append("b", (int) 4).toString());    }    public void testShort() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString());    }    public void testChar() {        assertEquals(baseStr + "[A]", new ToStringBuilder(base).append((char) 65).toString());        assertEquals(baseStr + "[a=A]", new ToStringBuilder(base).append("a", (char) 65).toString());        assertEquals(baseStr + "[a=A,b=B]", new ToStringBuilder(base).append("a", (char) 65).append("b", (char) 66).toString());    }    public void testByte() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString());    }    public void testDouble() {        assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((double) 3.2).toString());        assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (double) 3.2).toString());        assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (double) 3.2).append("b", (double) 4.3).toString());    }    public void testFloat() {        assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString());        assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString());        assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString());    }    public void testBoolean() {        assertEquals(baseStr + "[true]", new ToStringBuilder(base).append(true).toString());        assertEquals(baseStr + "[a=true]", new ToStringBuilder(base).append("a", true).toString());        assertEquals(baseStr + "[a=true,b=false]", new ToStringBuilder(base).append("a", true).append("b", false).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testIntArray() {        int[] array = new int[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testShortArray() {        short[] array = new short[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }        public void testByteArray() {        byte[] array = new byte[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testCharArray() {        char[] array = new char[] {'A', '2', '_', 'D'};        assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testDoubleArray() {        double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3};        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testFloatArray() {        float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f};        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }        public void testBooleanArray() {        boolean[] array = new boolean[] {true, false, false};        assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testIntArrayArray() {        int[][] array = new int[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testShortArrayArray() {        short[][] array = new short[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testByteArrayArray() {        byte[][] array = new byte[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testCharArrayArray() {        char[][] array = new char[][] {{'A', 'B'}, null, {'p'}};        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testDoubleArrayArray() {        double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}};        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testFloatArrayArray() {        float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}};        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testBooleanArrayArray() {        boolean[][] array = new boolean[][] {{true, false}, null, {false}};        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: SimpleToStringStyleTest.java,v 1.3 2003/05/21 23:49:15 scolebourne Exp $ */public class SimpleToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);        public SimpleToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(SimpleToStringStyleTest.class);        suite.setName("DefaultToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.SIMPLE_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals("", new ToStringBuilder(base).toString());    }    public void testAppendSuper() {        assertEquals("", new ToStringBuilder(base).appendSuper("").toString());        assertEquals("<null>", new ToStringBuilder(base).appendSuper("<null>").toString());                assertEquals("hello", new ToStringBuilder(base).appendSuper("").append("a", "hello").toString());        assertEquals("<null>,hello", new ToStringBuilder(base).appendSuper("<null>").append("a", "hello").toString());        assertEquals("hello", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals("<null>", new ToStringBuilder(base).append((Object) null).toString());        assertEquals("3", new ToStringBuilder(base).append(i3).toString());        assertEquals("<null>", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals("3", new ToStringBuilder(base).append("a", i3).toString());        assertEquals("3,4", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals("<Integer>", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals("<size=0>", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals("[]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals("<size=0>", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals("{}", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals("<size=0>", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals("{}", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals("3", new ToStringBuilder(base).append(3L).toString());        assertEquals("3", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals("3,4", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append(array).toString());        assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals("<null>", new ToStringBuilder(base).append(array).toString());        assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append(array).toString());        assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals("<null>", new ToStringBuilder(base).append(array).toString());        assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString());        assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals("<null>", new ToStringBuilder(base).append(array).toString());        assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.EqualsBuilder}. * * @author <a href="mailto:sdowney@panix.com">Steve Downey</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a> * @version $Id: EqualsBuilderTest.java,v 1.5 2003/05/21 23:49:14 scolebourne Exp $ */public class EqualsBuilderTest extends TestCase {    public EqualsBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(EqualsBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    static class TestObject {        private int a;        public TestObject() {        }        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }    }    static class TestSubObject extends TestObject {        private int b;        public TestSubObject() {            super(0);        }        public TestSubObject(int a, int b) {            super(a);            this.b = b;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestSubObject)) {                return false;            }            TestSubObject rhs = (TestSubObject) o;            return super.equals(o) && (b == rhs.b);        }        public void setB(int b) {            this.b = b;        }        public int getB() {            return b;        }    }    static class TestEmptySubObject extends TestObject {        public TestEmptySubObject(int a) {            super(a);        }    }    static class TestTSubObject extends TestObject {        private transient int t;        public TestTSubObject(int a, int t) {            super(a);            this.t = t;        }    }    static class TestTTSubObject extends TestTSubObject {        private transient int tt;        public TestTTSubObject(int a, int t, int tt) {            super(a, t);            this.tt = tt;        }    }    static class TestTTLeafObject extends TestTTSubObject {        private int leafValue;        public TestTTLeafObject(int a, int t, int tt, int leafValue) {            super(a, t, tt);            this.leafValue = leafValue;        }    }    static class TestTSubObject2 extends TestObject {        private transient int t;        public TestTSubObject2(int a, int t) {            super(a);        }        public int getT() {            return t;        }        public void setT(int t) {            this.t = t;        }    }    public void testReflectionEquals() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(EqualsBuilder.reflectionEquals(o1, o1));        assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));        o2.setA(4);        assertTrue(EqualsBuilder.reflectionEquals(o1, o2));        assertTrue(!EqualsBuilder.reflectionEquals(o1, this));        assertTrue(!EqualsBuilder.reflectionEquals(o1, null));        assertTrue(!EqualsBuilder.reflectionEquals(null, o2));        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));    }        public void testReflectionHierarchyEquals() {        testReflectionHierarchyEquals(false);        testReflectionHierarchyEquals(true);        // Transients        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));        assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));        assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));    }    public void testReflectionHierarchyEquals(boolean testTransients) {        TestObject to1 = new TestObject(4);        TestObject to1Bis = new TestObject(4);        TestObject to1Ter = new TestObject(4);        TestObject to2 = new TestObject(5);        TestEmptySubObject teso = new TestEmptySubObject(4);        TestTSubObject ttso = new TestTSubObject(4, 1);        TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);        TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);        TestSubObject tso1 = new TestSubObject(1, 4);        TestSubObject tso1bis = new TestSubObject(1, 4);        TestSubObject tso1ter = new TestSubObject(1, 4);        TestSubObject tso2 = new TestSubObject(2, 5);        testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);        testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);        // More sanity checks:        // same values        assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));        assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));        // same super values, diff sub values        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));        // diff super values, same sub values        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));        // mix super and sub types: equals        assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));        assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));        assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert        assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert        assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert        assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert        assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert        assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert        // mix super and sub types: NOT equals        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));        assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));    }    /**     * Equivalence relationship tests inspired by "Effective Java":     * <ul>     * <li>reflection</li>     * <li>symetry</li>     * <li>transitive</li>     * <li>consistency</li>     * <li>non-null reference</li>     * </ul>     * @param to a TestObject     * @param toBis a TestObject, equal to to and toTer     * @param toTer Left hand side, equal to to and toBis     * @param to2 a different TestObject     * @param oToChange a TestObject that will be changed     */    public void testReflectionEqualsEquivalenceRelationship(        TestObject to,        TestObject toBis,        TestObject toTer,        TestObject to2,        TestObject oToChange,        boolean testTransients) {        // reflection test        assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));        assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));        // symetry test        assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));        // transitive test        assertTrue(            EqualsBuilder.reflectionEquals(to, toBis, testTransients)                && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)                && EqualsBuilder.reflectionEquals(to, toTer, testTransients));        // consistency test        oToChange.setA(to.getA());        if (oToChange instanceof TestSubObject) {            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());        }        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));        assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));        oToChange.setA(to.getA() + 1);        if (oToChange instanceof TestSubObject) {            ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);        }        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));        // non-null reference test        assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients));        assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients));        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));    }    public void testSuper() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertEquals(true, new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());        assertEquals(false, new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());        assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());    }    public void testObject() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        o2.setA(4);        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, this).isEquals());                assertTrue(!new EqualsBuilder().append(o1, null).isEquals());        assertTrue(!new EqualsBuilder().append(null, o2).isEquals());        assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());    }    public void testLong() {        long o1 = 1L;        long o2 = 2L;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testInt() {        int o1 = 1;        int o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testShort() {        short o1 = 1;        short o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testChar() {        char o1 = 1;        char o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testByte() {        byte o1 = 1;        byte o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testDouble() {        double o1 = 1;        double o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());    }    public void testFloat() {        float o1 = 1;        float o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());    }    public void testBoolean() {        boolean o1 = true;        boolean o2 = false;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testObjectArray() {        TestObject[] obj1 = new TestObject[2];        obj1[0] = new TestObject(4);        obj1[1] = new TestObject(5);        TestObject[] obj2 = new TestObject[2];        obj2[0] = new TestObject(4);        obj2[1] = new TestObject(5);        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1].setA(6);        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testLongArray() {        long[] obj1 = new long[2];        obj1[0] = 5L;        obj1[1] = 6L;        long[] obj2 = new long[2];        obj2[0] = 5L;        obj2[1] = 6L;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testIntArray() {        int[] obj1 = new int[2];        obj1[0] = 5;        obj1[1] = 6;        int[] obj2 = new int[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testShortArray() {        short[] obj1 = new short[2];        obj1[0] = 5;        obj1[1] = 6;        short[] obj2 = new short[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testCharArray() {        char[] obj1 = new char[2];        obj1[0] = 5;        obj1[1] = 6;        char[] obj2 = new char[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testByteArray() {        byte[] obj1 = new byte[2];        obj1[0] = 5;        obj1[1] = 6;        byte[] obj2 = new byte[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testDoubleArray() {        double[] obj1 = new double[2];        obj1[0] = 5;        obj1[1] = 6;        double[] obj2 = new double[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testFloatArray() {        float[] obj1 = new float[2];        obj1[0] = 5;        obj1[1] = 6;        float[] obj2 = new float[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testBooleanArray() {        boolean[] obj1 = new boolean[2];        obj1[0] = true;        obj1[1] = false;        boolean[] obj2 = new boolean[2];        obj2[0] = true;        obj2[1] = false;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = true;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testMultiLongArray() {        long[][] array1 = new long[2][2];        long[][] array2 = new long[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiIntArray() {        int[][] array1 = new int[2][2];        int[][] array2 = new int[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiShortArray() {        short[][] array1 = new short[2][2];        short[][] array2 = new short[2][2];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiCharArray() {        char[][] array1 = new char[2][2];        char[][] array2 = new char[2][2];        for (char i = 0; i < array1.length; ++i) {            for (char j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiByteArray() {        byte[][] array1 = new byte[2][2];        byte[][] array2 = new byte[2][2];        for (byte i = 0; i < array1.length; ++i) {            for (byte j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiFloatArray() {        float[][] array1 = new float[2][2];        float[][] array2 = new float[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiDoubleArray() {        double[][] array1 = new double[2][2];        double[][] array2 = new double[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiBooleanArray() {        boolean[][] array1 = new boolean[2][2];        boolean[][] array2 = new boolean[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i == 1) || (j == 1);                array2[i][j] = (i == 1) || (j == 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = false;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testRaggedArray() {        long array1[][] = new long[2][];        long array2[][] = new long[2][];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            for (int j = 0; j < array1[i].length; ++j) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMixedArray() {        Object array1[] = new Object[2];        Object array2[] = new Object[2];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            for (int j = 0; j < 2; ++j) {                ((long[]) array1[i])[j] = (i + 1) * (j + 1);                ((long[]) array2[i])[j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        ((long[]) array1[1])[1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testObjectArrayHiddenByObject() {        TestObject[] array1 = new TestObject[2];        array1[0] = new TestObject(4);        array1[1] = new TestObject(5);        TestObject[] array2 = new TestObject[2];        array2[0] = new TestObject(4);        array2[1] = new TestObject(5);        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1].setA(6);        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testLongArrayHiddenByObject() {        long[] array1 = new long[2];        array1[0] = 5L;        array1[1] = 6L;        long[] array2 = new long[2];        array2[0] = 5L;        array2[1] = 6L;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testIntArrayHiddenByObject() {        int[] array1 = new int[2];        array1[0] = 5;        array1[1] = 6;        int[] array2 = new int[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testShortArrayHiddenByObject() {        short[] array1 = new short[2];        array1[0] = 5;        array1[1] = 6;        short[] array2 = new short[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testCharArrayHiddenByObject() {        char[] array1 = new char[2];        array1[0] = 5;        array1[1] = 6;        char[] array2 = new char[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testByteArrayHiddenByObject() {        byte[] array1 = new byte[2];        array1[0] = 5;        array1[1] = 6;        byte[] array2 = new byte[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testDoubleArrayHiddenByObject() {        double[] array1 = new double[2];        array1[0] = 5;        array1[1] = 6;        double[] array2 = new double[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testFloatArrayHiddenByObject() {        float[] array1 = new float[2];        array1[0] = 5;        array1[1] = 6;        float[] array2 = new float[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testBooleanArrayHiddenByObject() {        boolean[] array1 = new boolean[2];        array1[0] = true;        array1[1] = false;        boolean[] array2 = new boolean[2];        array2[0] = true;        array2[1] = false;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = true;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import org.apache.commons.lang.SystemUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: MultiLineToStringStyleTest.java,v 1.3 2003/05/21 23:49:15 scolebourne Exp $ */public class MultiLineToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public MultiLineToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(MultiLineToStringStyleTest.class);        suite.setName("DefaultToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.MULTI_LINE_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).toString());    }    public void testAppendSuper() {        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "]").toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]").toString());                assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "]").append("a", "hello").toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "  a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper("Integer@8888[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]").append("a", "hello").toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=hello" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "  b=4" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<Integer>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=[]" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "  b=4" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {<null>,5,{3,6}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {<null>,5,{3,6}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {1,2,-3,4}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {1,2,-3,4}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {{1,2},<null>,{5}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {{1,2},<null>,{5}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: NoFieldNamesToStringStyleTest.java,v 1.3 2003/05/21 23:49:14 scolebourne Exp $ */public class NoFieldNamesToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public NoFieldNamesToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(NoFieldNamesToStringStyleTest.class);        suite.setName("NoFieldNamesToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }    public void testAppendSuper() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).appendSuper("Integer@8888[]").toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").toString());                assertEquals(baseStr + "[hello]", new ToStringBuilder(base).appendSuper("Integer@8888[]").append("a", "hello").toString());        assertEquals(baseStr + "[<null>,hello]", new ToStringBuilder(base).appendSuper("Integer@8888[<null>]").append("a", "hello").toString());        assertEquals(baseStr + "[hello]", new ToStringBuilder(base).appendSuper(null).append("a", "hello").toString());    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Tests HashCodeBuilder and EqualsBuilderTest to insure that equal  * objects must have equal hash codes. *  * @author Gary Gregory * @version $Id: HashCodeBuilderAndEqualsBuilderTest.java,v 1.2 2003/05/21 23:49:15 scolebourne Exp $ */public class HashCodeBuilderAndEqualsBuilderTest extends TestCase {    /**     * Constructor for HashCodeBuilderAndEqualsBuilderTest.     * @param name     */    public HashCodeBuilderAndEqualsBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(HashCodeBuilderAndEqualsBuilderTest.class);        suite.setName("HashCodeBuilderAndEqualsBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testInteger(boolean testTransients) {        Integer i1 = new Integer(12345);        Integer i2 = new Integer(12345);        assertEqualsAndHashCodeContract(i1, i2, testTransients);    }    public void testInteger() {        testInteger(false);    }    public void testIntegerWithTransients() {        testInteger(true);    }    public void testFixture() {        testFixture(false);    }    public void testFixtureWithTransients() {        testFixture(true);    }    public void testFixture(boolean testTransients) {        assertEqualsAndHashCodeContract(new TestFixture(2, 'c', "Test", (short) 2), new TestFixture(2, 'c', "Test", (short) 2), testTransients);        assertEqualsAndHashCodeContract(            new AllTransientFixture(2, 'c', "Test", (short) 2),            new AllTransientFixture(2, 'c', "Test", (short) 2),            testTransients);        assertEqualsAndHashCodeContract(            new SubTestFixture(2, 'c', "Test", (short) 2, "Same"),            new SubTestFixture(2, 'c', "Test", (short) 2, "Same"),            testTransients);        assertEqualsAndHashCodeContract(            new SubAllTransientFixture(2, 'c', "Test", (short) 2, "Same"),            new SubAllTransientFixture(2, 'c', "Test", (short) 2, "Same"),            testTransients);    }    /**     * Asserts that if <code>lhs</code> equals <code>rhs</code>      * then their hash codes MUST be identical.     *      * @param lhs The Left-Hand-Side of the equals test     * @param rhs The Right-Hand-Side of the equals test     * @param testTransients wether to test transient fields     */    public void assertEqualsAndHashCodeContract(Object lhs, Object rhs, boolean testTransients) {        if (EqualsBuilder.reflectionEquals(lhs, rhs, testTransients)) {            // test a couple of times for consistency.            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));            assertEquals(HashCodeBuilder.reflectionHashCode(lhs, testTransients), HashCodeBuilder.reflectionHashCode(rhs, testTransients));        }    }    static class TestFixture {        int i;        char c;        String string;        short s;        TestFixture(int i, char c, String string, short s) {            this.i = i;            this.c = c;            this.string = string;            this.s = s;        }    }    static class SubTestFixture extends TestFixture {        transient String tString;        SubTestFixture(int i, char c, String string, short s, String tString) {            super(i, c, string, s);            this.tString = tString;        }    }    static class AllTransientFixture {        transient int i;        transient char c;        transient String string;        transient short s;        AllTransientFixture(int i, char c, String string, short s) {            this.i = i;            this.c = c;            this.string = string;            this.s = s;        }    }    static class SubAllTransientFixture extends AllTransientFixture {        transient String tString;        SubAllTransientFixture(int i, char c, String string, short s, String tString) {            super(i, c, string, s);            this.tString = tString;        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import java.math.BigInteger;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.CompareToBuilder}. * * @author <a href="mailto:sdowney@panix.com">Steve Downey</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: CompareToBuilderTest.java,v 1.5 2003/05/21 23:49:14 scolebourne Exp $ */public class CompareToBuilderTest extends TestCase {  public CompareToBuilderTest(String name) {    super(name);  }     public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(CompareToBuilderTest.class);        suite.setName("CompareToBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    static class TestObject implements Comparable {        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }public int compareTo(Object o) {TestObject rhs = (TestObject) o;return (a < rhs.a) ? -1 : (a > rhs.a) ? +1 : 0;}    }    static class TestSubObject extends TestObject {        private int b;        public TestSubObject() {            super(0);        }        public TestSubObject(int a, int b) {            super(a);            this.b = b;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestSubObject)) {                return false;            }            TestSubObject rhs = (TestSubObject) o;            return super.equals(o) && (b == rhs.b);        }    }    static class TestTransientSubObject extends TestObject {        private transient int t;        public TestTransientSubObject(int a, int t) {            super(a);            this.t = t;        }    }    public void testReflectionCompare() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(4);        assertTrue(CompareToBuilder.reflectionCompare(o1, o1) == 0);        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) == 0);        o2.setA(5);        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) < 0);        assertTrue(CompareToBuilder.reflectionCompare(o2, o1) > 0);    }    public void testReflectionCompareEx1() {        TestObject o1 = new TestObject(4);        try {            CompareToBuilder.reflectionCompare(o1, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testReflectionCompareEx2() {        TestObject o1 = new TestObject(4);        Object o2 = new Object();        try {            CompareToBuilder.reflectionCompare(o1, o2);            fail();        } catch (ClassCastException ex) {}    }    public void testReflectionHierarchyCompare() {        testReflectionHierarchyCompare(false);    }        public void testReflectionHierarchyCompareTransients() {        testReflectionHierarchyCompare(true);        TestTransientSubObject x;        TestTransientSubObject y;        TestTransientSubObject z;        x = new TestTransientSubObject(1, 1);        y = new TestTransientSubObject(2, 2);        z = new TestTransientSubObject(3, 3);        assertXYZCompareOrder(x, y, z, true);                x = new TestTransientSubObject(1, 1);        y = new TestTransientSubObject(1, 2);        z = new TestTransientSubObject(1, 3);        assertXYZCompareOrder(x, y, z, true);      }        private void assertXYZCompareOrder(Object x, Object y, Object z, boolean testTransients) {        assertTrue(0 == CompareToBuilder.reflectionCompare(x, x, testTransients));        assertTrue(0 == CompareToBuilder.reflectionCompare(y, y, testTransients));        assertTrue(0 == CompareToBuilder.reflectionCompare(z, z, testTransients));                assertTrue(0 > CompareToBuilder.reflectionCompare(x, y, testTransients));        assertTrue(0 > CompareToBuilder.reflectionCompare(x, z, testTransients));        assertTrue(0 > CompareToBuilder.reflectionCompare(y, z, testTransients));                assertTrue(0 < CompareToBuilder.reflectionCompare(y, x, testTransients));        assertTrue(0 < CompareToBuilder.reflectionCompare(z, x, testTransients));        assertTrue(0 < CompareToBuilder.reflectionCompare(z, y, testTransients));    }        public void testReflectionHierarchyCompare(boolean testTransients) {        TestObject to1 = new TestObject(1);        TestObject to2 = new TestObject(2);        TestObject to3 = new TestObject(3);        TestSubObject tso1 = new TestSubObject(1, 1);        TestSubObject tso2 = new TestSubObject(2, 2);        TestSubObject tso3 = new TestSubObject(3, 3);                assertReflectionCompareContract(to1, to1, to1, false);        assertReflectionCompareContract(to1, to2, to3, false);        assertReflectionCompareContract(tso1, tso1, tso1, false);        assertReflectionCompareContract(tso1, tso2, tso3, false);        assertReflectionCompareContract("1", "2", "3", false);                assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(1, 0), testTransients));        assertTrue(0 != CompareToBuilder.reflectionCompare(tso1, new TestSubObject(0, 1), testTransients));        // root class        assertXYZCompareOrder(to1, to2, to3, true);        // subclass          assertXYZCompareOrder(tso1, tso2, tso3, true);      }    /**     * See "Effective Java" under "Consider Implementing Comparable".     *       * @param x an object to compare      * @param y an object to compare     * @param z an object to compare     * @param testTransients Whether to include transients in the comparison     */    public void assertReflectionCompareContract(Object x, Object y, Object z, boolean testTransients) {        // signum        assertTrue(reflectionCompareSignum(x, y, testTransients) == -reflectionCompareSignum(y, x, testTransients));                // transitive        if (CompareToBuilder.reflectionCompare(x, y, testTransients) > 0 && CompareToBuilder.reflectionCompare(y, z, testTransients) > 0){            assertTrue(CompareToBuilder.reflectionCompare(x, z, testTransients) > 0);        }                // un-named        if (CompareToBuilder.reflectionCompare(x, y, testTransients) == 0) {            assertTrue(reflectionCompareSignum(x, z, testTransients) == -reflectionCompareSignum(y, z, testTransients));        }                // strongly recommended but not strictly required        assertTrue((CompareToBuilder.reflectionCompare(x, y, testTransients) ==0 ) == EqualsBuilder.reflectionEquals(x, y, testTransients));    }        /**     * Returns the signum of the result of comparing x and y with     * <code>CompareToBuilder.reflectionCompare</code>     *      * @param lhs The "left-hand-side" of the comparison.     * @param rhs The "right-hand-side" of the comparison.     * @param testTransients Whether to include transients in the comparison     * @return int The signum     */    private int reflectionCompareSignum(Object lhs, Object rhs, boolean testTransients) {        return BigInteger.valueOf(CompareToBuilder.reflectionCompare(lhs, rhs, testTransients)).signum();    }        public void testAppendSuper() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);                assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0);        assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0);                assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0);    }        public void testObject() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(4);        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0);        o2.setA(5);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);                assertTrue(new CompareToBuilder().append(o1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((Object) null, (Object) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, o1).toComparison() < 0);    }    public void testObjectEx2() {        TestObject o1 = new TestObject(4);        Object o2 = new Object();        try {            new CompareToBuilder().append(o1, o2);            fail();        } catch (ClassCastException ex) {}    }    public void testObjectComparator() {        String o1 = "Fred";        String o2 = "Fred";        assertTrue(new CompareToBuilder().append(o1, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);        o2 = "FRED";        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);        o2 = "FREDA";        assertTrue(new CompareToBuilder().append(o1, o2, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);                assertTrue(new CompareToBuilder().append(o1, null, String.CASE_INSENSITIVE_ORDER).toComparison() > 0);        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, String.CASE_INSENSITIVE_ORDER).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, o1, String.CASE_INSENSITIVE_ORDER).toComparison() < 0);    }        public void testObjectComparatorNull() {        String o1 = "Fred";        String o2 = "Fred";        assertTrue(new CompareToBuilder().append(o1, o1, null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() == 0);        o2 = "Zebra";        assertTrue(new CompareToBuilder().append(o1, o2, null).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1, null).toComparison() > 0);                assertTrue(new CompareToBuilder().append(o1, null, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((Object) null, (Object) null, null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, o1, null).toComparison() < 0);    }    public void testLong() {        long o1 = 1L;        long o2 = 2L;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Long.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Long.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Long.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Long.MIN_VALUE, o1).toComparison() < 0);    }    public void testInt() {        int o1 = 1;        int o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Integer.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Integer.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Integer.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Integer.MIN_VALUE, o1).toComparison() < 0);    }    public void testShort() {        short o1 = 1;        short o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Short.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Short.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Short.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Short.MIN_VALUE, o1).toComparison() < 0);    }    public void testChar() {        char o1 = 1;        char o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Character.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Character.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Character.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Character.MIN_VALUE, o1).toComparison() < 0);    }    public void testByte() {        byte o1 = 1;        byte o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Byte.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Byte.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Byte.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Byte.MIN_VALUE, o1).toComparison() < 0);    }    public void testDouble() {        double o1 = 1;        double o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Double.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Double.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Double.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Double.MIN_VALUE, o1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Double.NaN, Double.NaN).toComparison() == 0);        assertTrue(new CompareToBuilder().append(Double.NaN, Double.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Double.POSITIVE_INFINITY, Double.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Double.NEGATIVE_INFINITY, Double.MIN_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o1, Double.NaN).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Double.NaN, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);    }    public void testFloat() {        float o1 = 1;        float o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Float.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Float.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Float.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Float.MIN_VALUE, o1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Float.NaN, Float.NaN).toComparison() == 0);        assertTrue(new CompareToBuilder().append(Float.NaN, Float.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Float.POSITIVE_INFINITY, Float.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Float.NEGATIVE_INFINITY, Float.MIN_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o1, Float.NaN).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Float.NaN, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);    }    public void testBoolean() {        boolean o1 = true;        boolean o2 = false;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o2, o2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0);    }    public void testObjectArray() {        TestObject[] obj1 = new TestObject[2];        obj1[0] = new TestObject(4);        obj1[1] = new TestObject(5);        TestObject[] obj2 = new TestObject[2];        obj2[0] = new TestObject(4);        obj2[1] = new TestObject(5);        TestObject[] obj3 = new TestObject[3];        obj3[0] = new TestObject(4);        obj3[1] = new TestObject(5);        obj3[2] = new TestObject(6);                assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);                obj1[1] = new TestObject(7);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((Object[]) null, (Object[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testLongArray() {        long[] obj1 = new long[2];        obj1[0] = 5L;        obj1[1] = 6L;        long[] obj2 = new long[2];        obj2[0] = 5L;        obj2[1] = 6L;        long[] obj3 = new long[3];        obj3[0] = 5L;        obj3[1] = 6L;        obj3[2] = 7L;                assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((long[]) null, (long[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testIntArray() {        int[] obj1 = new int[2];        obj1[0] = 5;        obj1[1] = 6;        int[] obj2 = new int[2];        obj2[0] = 5;        obj2[1] = 6;        int[] obj3 = new int[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((int[]) null, (int[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testShortArray() {        short[] obj1 = new short[2];        obj1[0] = 5;        obj1[1] = 6;        short[] obj2 = new short[2];        obj2[0] = 5;        obj2[1] = 6;        short[] obj3 = new short[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((short[]) null, (short[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testCharArray() {        char[] obj1 = new char[2];        obj1[0] = 5;        obj1[1] = 6;        char[] obj2 = new char[2];        obj2[0] = 5;        obj2[1] = 6;        char[] obj3 = new char[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((char[]) null, (char[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testByteArray() {        byte[] obj1 = new byte[2];        obj1[0] = 5;        obj1[1] = 6;        byte[] obj2 = new byte[2];        obj2[0] = 5;        obj2[1] = 6;        byte[] obj3 = new byte[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((byte[]) null, (byte[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testDoubleArray() {        double[] obj1 = new double[2];        obj1[0] = 5;        obj1[1] = 6;        double[] obj2 = new double[2];        obj2[0] = 5;        obj2[1] = 6;        double[] obj3 = new double[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((double[]) null, (double[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testFloatArray() {        float[] obj1 = new float[2];        obj1[0] = 5;        obj1[1] = 6;        float[] obj2 = new float[2];        obj2[0] = 5;        obj2[1] = 6;        float[] obj3 = new float[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((float[]) null, (float[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testBooleanArray() {        boolean[] obj1 = new boolean[2];        obj1[0] = true;        obj1[1] = false;        boolean[] obj2 = new boolean[2];        obj2[0] = true;        obj2[1] = false;        boolean[] obj3 = new boolean[3];        obj3[0] = true;        obj3[1] = false;        obj3[2] = true;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = true;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj1, null).toComparison() > 0);        assertTrue(new CompareToBuilder().append((boolean[]) null, (boolean[]) null).toComparison() == 0);        assertTrue(new CompareToBuilder().append(null, obj1).toComparison() < 0);    }    public void testMultiLongArray() {        long[][] array1 = new long[2][2];        long[][] array2 = new long[2][2];        long[][] array3 = new long[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);                array3[i][j] = (i + 1) * (j + 1);            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiIntArray() {        int[][] array1 = new int[2][2];        int[][] array2 = new int[2][2];        int[][] array3 = new int[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);                array3[i][j] = (i + 1) * (j + 1);            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiShortArray() {        short[][] array1 = new short[2][2];        short[][] array2 = new short[2][2];        short[][] array3 = new short[2][3];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = (short)((i + 1) * (j + 1));                array2[i][j] = (short)((i + 1) * (j + 1));                array3[i][j] = (short)((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiCharArray() {        char[][] array1 = new char[2][2];        char[][] array2 = new char[2][2];        char[][] array3 = new char[2][3];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = (char)((i + 1) * (j + 1));                array2[i][j] = (char)((i + 1) * (j + 1));                array3[i][j] = (char)((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiByteArray() {        byte[][] array1 = new byte[2][2];        byte[][] array2 = new byte[2][2];        byte[][] array3 = new byte[2][3];        for (byte i = 0; i < array1.length; ++i) {            for (byte j = 0; j < array1[0].length; j++) {                array1[i][j] = (byte)((i + 1) * (j + 1));                array2[i][j] = (byte)((i + 1) * (j + 1));                array3[i][j] = (byte)((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 127;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }        public void testMultiFloatArray() {        float[][] array1 = new float[2][2];        float[][] array2 = new float[2][2];        float[][] array3 = new float[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = ((i + 1) * (j + 1));                array2[i][j] = ((i + 1) * (j + 1));                array3[i][j] = ((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 127;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiDoubleArray() {        double[][] array1 = new double[2][2];        double[][] array2 = new double[2][2];        double[][] array3 = new double[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = ((i + 1) * (j + 1));                array2[i][j] = ((i + 1) * (j + 1));                array3[i][j] = ((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 127;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiBooleanArray() {        boolean[][] array1 = new boolean[2][2];        boolean[][] array2 = new boolean[2][2];        boolean[][] array3 = new boolean[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = ((i == 1) ^ (j == 1));                array2[i][j] = ((i == 1) ^ (j == 1));                array3[i][j] = ((i == 1) ^ (j == 1));            }        }        array3[1][2] = false;        array3[1][2] = false;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = true;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testRaggedArray() {        long array1[][] = new long[2][];        long array2[][] = new long[2][];        long array3[][] = new long[3][];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            array3[i] = new long[3];            for (int j = 0; j < array1[i].length; ++j) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);                array3[i][j] = (i + 1) * (j + 1);            }        }        array3[1][2] = 100;        array3[1][2] = 100;                        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMixedArray() {        Object array1[] = new Object[2];        Object array2[] = new Object[2];        Object array3[] = new Object[2];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            array3[i] = new long[3];            for (int j = 0; j < 2; ++j) {                ((long[]) array1[i])[j] = (i + 1) * (j + 1);                ((long[]) array2[i])[j] = (i + 1) * (j + 1);                ((long[]) array3[i])[j] = (i + 1) * (j + 1);            }        }        ((long[]) array3[0])[2] = 1;        ((long[]) array3[1])[2] = 1;        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        ((long[]) array1[1])[1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testObjectArrayHiddenByObject() {        TestObject[] array1 = new TestObject[2];        array1[0] = new TestObject(4);        array1[1] = new TestObject(5);        TestObject[] array2 = new TestObject[2];        array2[0] = new TestObject(4);        array2[1] = new TestObject(5);        TestObject[] array3 = new TestObject[3];        array3[0] = new TestObject(4);        array3[1] = new TestObject(5);        array3[2] = new TestObject(6);                Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;                assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = new TestObject(7);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testLongArrayHiddenByObject() {        long[] array1 = new long[2];        array1[0] = 5L;        array1[1] = 6L;        long[] array2 = new long[2];        array2[0] = 5L;        array2[1] = 6L;        long[] array3 = new long[3];        array3[0] = 5L;        array3[1] = 6L;        array3[2] = 7L;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testIntArrayHiddenByObject() {        int[] array1 = new int[2];        array1[0] = 5;        array1[1] = 6;        int[] array2 = new int[2];        array2[0] = 5;        array2[1] = 6;        int[] array3 = new int[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testShortArrayHiddenByObject() {        short[] array1 = new short[2];        array1[0] = 5;        array1[1] = 6;        short[] array2 = new short[2];        array2[0] = 5;        array2[1] = 6;        short[] array3 = new short[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testCharArrayHiddenByObject() {        char[] array1 = new char[2];        array1[0] = 5;        array1[1] = 6;        char[] array2 = new char[2];        array2[0] = 5;        array2[1] = 6;        char[] array3 = new char[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testByteArrayHiddenByObject() {        byte[] array1 = new byte[2];        array1[0] = 5;        array1[1] = 6;        byte[] array2 = new byte[2];        array2[0] = 5;        array2[1] = 6;        byte[] array3 = new byte[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testDoubleArrayHiddenByObject() {        double[] array1 = new double[2];        array1[0] = 5;        array1[1] = 6;        double[] array2 = new double[2];        array2[0] = 5;        array2[1] = 6;        double[] array3 = new double[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testFloatArrayHiddenByObject() {        float[] array1 = new float[2];        array1[0] = 5;        array1[1] = 6;        float[] array2 = new float[2];        array2[0] = 5;        array2[1] = 6;        float[] array3 = new float[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testBooleanArrayHiddenByObject() {        boolean[] array1 = new boolean[2];        array1[0] = true;        array1[1] = false;        boolean[] array2 = new boolean[2];        array2[0] = true;        array2[1] = false;        boolean[] array3 = new boolean[3];        array3[0] = true;        array3[1] = false;        array3[2] = true;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = true;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }   }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * JUnit tests. *  * @author Matthew Hawthorne * @version $Id: NotImplementedExceptionTest.java,v 1.1 2003/05/15 04:05:11 bayard Exp $ * @see NotImplementedException */public class NotImplementedExceptionTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        return new TestSuite(NotImplementedExceptionTest.class);    }    public NotImplementedExceptionTest(String testName) {        super(testName);    }    // testConstructor    public void testConstructor_classArg_nullInput() {        final Class c = null;        new NotImplementedException(c);    }    public void testConstructor_stringArg_nullInput() {        final String s = null;        new NotImplementedException(s);    }    // testGetMessage    public void testGetMessage_classArg_nullInput() {        final Class c = null;        final Throwable t = new NotImplementedException(c);        assertEquals("Method is not implemented in class null", t.getMessage());    }    public void testGetMessage_classArg_validInput() {        final Throwable t = new NotImplementedException(String.class);        assertEquals(            "Method is not implemented in class java.lang.String",            t.getMessage());    }    public void testGetMessage_stringArg_nullInput() {        final String s = null;        final Throwable t = new NotImplementedException(s);        assertEquals(null, t.getMessage());    }    public void testGetMessage_stringArg_validInput() {        final String msg = "message";        final Throwable t = new NotImplementedException(msg);        assertEquals(msg, t.getMessage());    }} // NotImplementedExceptionTest
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.BooleanUtils}. * * @author Stephen Colebourne * @version $Id: BooleanUtilsTest.java,v 1.3 2003/03/23 21:47:30 scolebourne Exp $ */public class BooleanUtilsTest extends TestCase {    public BooleanUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(BooleanUtilsTest.class);    suite.setName("BooleanUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void test_negate_Boolean() {        assertSame(null, BooleanUtils.negate(null));        assertSame(Boolean.TRUE, BooleanUtils.negate(Boolean.FALSE));        assertSame(Boolean.FALSE, BooleanUtils.negate(Boolean.TRUE));    }    //-----------------------------------------------------------------------    public void test_toBooleanObject_boolean() {        assertSame(Boolean.TRUE, BooleanUtils.toBooleanObject(true));        assertSame(Boolean.FALSE, BooleanUtils.toBooleanObject(false));    }    public void test_toBoolean_Boolean() {        assertEquals(true, BooleanUtils.toBoolean(Boolean.TRUE));        assertEquals(false, BooleanUtils.toBoolean(Boolean.FALSE));        assertEquals(false, BooleanUtils.toBoolean((Boolean) null));    }    public void test_toBooleanDefaultIfNull_Boolean_boolean() {        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, true));        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false));        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true));        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, false));        assertEquals(true, BooleanUtils.toBooleanDefaultIfNull((Boolean) null, true));        assertEquals(false, BooleanUtils.toBooleanDefaultIfNull((Boolean) null, false));    }    //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void test_toBoolean_int() {        assertEquals(true, BooleanUtils.toBoolean(1));        assertEquals(true, BooleanUtils.toBoolean(-1));        assertEquals(false, BooleanUtils.toBoolean(0));    }        public void test_toBooleanObject_int() {        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(1));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(-1));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(0));    }        public void test_toBooleanObject_Integer() {        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(1)));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(-1)));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(new Integer(0)));        assertEquals(null, BooleanUtils.toBooleanObject((Integer) null));    }        //-----------------------------------------------------------------------    public void test_toBoolean_int_int_int() {        assertEquals(true, BooleanUtils.toBoolean(6, 6, 7));        assertEquals(false, BooleanUtils.toBoolean(7, 6, 7));        try {            BooleanUtils.toBoolean(8, 6, 7);            fail();        } catch (IllegalArgumentException ex) {}    }        public void test_toBoolean_Integer_Integer_Integer() {        Integer six = new Integer(6);        Integer seven = new Integer(7);        assertEquals(true, BooleanUtils.toBoolean(new Integer(6), six, seven));        assertEquals(false, BooleanUtils.toBoolean(new Integer(7), six, seven));        try {            BooleanUtils.toBoolean(new Integer(8), six, seven);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void test_toBooleanObject_int_int_int() {        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(6, 6, 7, 8));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(7, 6, 7, 8));        assertEquals(null, BooleanUtils.toBooleanObject(8, 6, 7, 8));        try {            BooleanUtils.toBooleanObject(9, 6, 7, 8);            fail();        } catch (IllegalArgumentException ex) {}    }        public void test_toBooleanObject_Integer_Integer_Integer() {        Integer six = new Integer(6);        Integer seven = new Integer(7);        Integer eight = new Integer(8);        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject(new Integer(6), six, seven, eight));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject(new Integer(7), six, seven, eight));        assertEquals(null, BooleanUtils.toBooleanObject(new Integer(8), six, seven, eight));        try {            BooleanUtils.toBooleanObject(new Integer(9), six, seven, eight);            fail();        } catch (IllegalArgumentException ex) {}    }        //-----------------------------------------------------------------------    public void test_toInteger_boolean() {        assertEquals(1, BooleanUtils.toInteger(true));        assertEquals(0, BooleanUtils.toInteger(false));    }        public void test_toIntegerObject_boolean() {        assertEquals(new Integer(1), BooleanUtils.toIntegerObject(true));        assertEquals(new Integer(0), BooleanUtils.toIntegerObject(false));    }        public void test_toIntegerObject_Boolean() {        assertEquals(new Integer(1), BooleanUtils.toIntegerObject(Boolean.TRUE));        assertEquals(new Integer(0), BooleanUtils.toIntegerObject(Boolean.FALSE));        assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null));    }        //-----------------------------------------------------------------------    public void test_toInteger_boolean_int_int() {        assertEquals(6, BooleanUtils.toInteger(true, 6, 7));        assertEquals(7, BooleanUtils.toInteger(false, 6, 7));    }        public void test_toInteger_Boolean_int_int_int() {        assertEquals(6, BooleanUtils.toInteger(Boolean.TRUE, 6, 7, 8));        assertEquals(7, BooleanUtils.toInteger(Boolean.FALSE, 6, 7, 8));        assertEquals(8, BooleanUtils.toInteger(null, 6, 7, 8));    }        public void test_toIntegerObject_boolean_Integer_Integer() {        Integer six = new Integer(6);        Integer seven = new Integer(7);        assertEquals(six, BooleanUtils.toIntegerObject(true, six, seven));        assertEquals(seven, BooleanUtils.toIntegerObject(false, six, seven));    }        public void test_toIntegerObject_Boolean_Integer_Integer_Integer() {        Integer six = new Integer(6);        Integer seven = new Integer(7);        Integer eight = new Integer(8);        assertEquals(six, BooleanUtils.toIntegerObject(Boolean.TRUE, six, seven, eight));        assertEquals(seven, BooleanUtils.toIntegerObject(Boolean.FALSE, six, seven, eight));        assertEquals(eight, BooleanUtils.toIntegerObject((Boolean) null, six, seven, eight));        assertEquals(null, BooleanUtils.toIntegerObject((Boolean) null, six, seven, null));    }        //-----------------------------------------------------------------------    //-----------------------------------------------------------------------    public void test_toBooleanObject_String() {        assertEquals(null, BooleanUtils.toBooleanObject((String) null));        assertEquals(null, BooleanUtils.toBooleanObject(""));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("false"));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("no"));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("off"));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("FALSE"));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("NO"));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("OFF"));        assertEquals(null, BooleanUtils.toBooleanObject("oof"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("true"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("yes"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("on"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TRUE"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("ON"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("YES"));        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("TruE"));    }        public void test_toBooleanObject_String_String_String_String() {        assertEquals(Boolean.TRUE, BooleanUtils.toBooleanObject("Y", "Y", "N", "U"));        assertEquals(Boolean.FALSE, BooleanUtils.toBooleanObject("N", "Y", "N", "U"));        assertEquals(null, BooleanUtils.toBooleanObject("U", "Y", "N", "U"));        try {            BooleanUtils.toBooleanObject(null, "Y", "N", "U");            fail();        } catch (IllegalArgumentException ex) {}        try {            BooleanUtils.toBooleanObject("X", "Y", "N", "U");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_toBoolean_String() {        assertEquals(false, BooleanUtils.toBoolean((String) null));        assertEquals(false, BooleanUtils.toBoolean(""));        assertEquals(false, BooleanUtils.toBoolean("off"));        assertEquals(false, BooleanUtils.toBoolean("oof"));        assertEquals(true, BooleanUtils.toBoolean("true"));        assertEquals(true, BooleanUtils.toBoolean("yes"));        assertEquals(true, BooleanUtils.toBoolean("on"));        assertEquals(true, BooleanUtils.toBoolean("TRUE"));        assertEquals(true, BooleanUtils.toBoolean("ON"));        assertEquals(true, BooleanUtils.toBoolean("YES"));        assertEquals(true, BooleanUtils.toBoolean("TruE"));    }    public void test_toBoolean_String_String_String() {        assertEquals(true, BooleanUtils.toBoolean("Y", "Y", "N"));        assertEquals(false, BooleanUtils.toBoolean("N", "Y", "N"));        try {            BooleanUtils.toBoolean(null, "Y", "N");            fail();        } catch (IllegalArgumentException ex) {}        try {            BooleanUtils.toBoolean("X", "Y", "N");            fail();        } catch (IllegalArgumentException ex) {}    }    //-----------------------------------------------------------------------    public void test_toStringTrueFalse_Boolean() {        assertEquals(null, BooleanUtils.toStringTrueFalse((Boolean) null));        assertEquals("true", BooleanUtils.toStringTrueFalse(Boolean.TRUE));        assertEquals("false", BooleanUtils.toStringTrueFalse(Boolean.FALSE));    }        public void test_toStringOnOff_Boolean() {        assertEquals(null, BooleanUtils.toStringOnOff((Boolean) null));        assertEquals("on", BooleanUtils.toStringOnOff(Boolean.TRUE));        assertEquals("off", BooleanUtils.toStringOnOff(Boolean.FALSE));    }        public void test_toStringYesNo_Boolean() {        assertEquals(null, BooleanUtils.toStringYesNo((Boolean) null));        assertEquals("yes", BooleanUtils.toStringYesNo(Boolean.TRUE));        assertEquals("no", BooleanUtils.toStringYesNo(Boolean.FALSE));    }        public void test_toString_Boolean_String_String_String() {        assertEquals("U", BooleanUtils.toString((Boolean) null, "Y", "N", "U"));        assertEquals("Y", BooleanUtils.toString(Boolean.TRUE, "Y", "N", "U"));        assertEquals("N", BooleanUtils.toString(Boolean.FALSE, "Y", "N", "U"));    }        //-----------------------------------------------------------------------    public void test_toStringTrueFalse_boolean() {        assertEquals("true", BooleanUtils.toStringTrueFalse(true));        assertEquals("false", BooleanUtils.toStringTrueFalse(false));    }        public void test_toStringOnOff_boolean() {        assertEquals("on", BooleanUtils.toStringOnOff(true));        assertEquals("off", BooleanUtils.toStringOnOff(false));    }        public void test_toStringYesNo_boolean() {        assertEquals("yes", BooleanUtils.toStringYesNo(true));        assertEquals("no", BooleanUtils.toStringYesNo(false));    }        public void test_toString_boolean_String_String_String() {        assertEquals("Y", BooleanUtils.toString(true, "Y", "N"));        assertEquals("N", BooleanUtils.toString(false, "Y", "N"));    }    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: StringUtilsIsTest.java,v 1.5 2003/03/23 21:51:51 scolebourne Exp $ */public class StringUtilsIsTest extends TestCase {    public StringUtilsIsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsIsTest.class);    suite.setName("StringUtilsIsXxx Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testIsAlpha() {        assertEquals(false, StringUtils.isAlpha(null));        assertEquals(true, StringUtils.isAlpha(""));        assertEquals(false, StringUtils.isAlpha(" "));        assertEquals(true, StringUtils.isAlpha("a"));        assertEquals(true, StringUtils.isAlpha("A"));        assertEquals(true, StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isAlpha("ham kso"));        assertEquals(false, StringUtils.isAlpha("1"));        assertEquals(false, StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlpha("_"));        assertEquals(false, StringUtils.isAlpha("hkHKHik*khbkuh"));    }    public void testIsAlphanumeric() {        assertEquals(false, StringUtils.isAlphanumeric(null));        assertEquals(true, StringUtils.isAlphanumeric(""));        assertEquals(false, StringUtils.isAlphanumeric(" "));        assertEquals(true, StringUtils.isAlphanumeric("a"));        assertEquals(true, StringUtils.isAlphanumeric("A"));        assertEquals(true, StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isAlphanumeric("ham kso"));        assertEquals(true, StringUtils.isAlphanumeric("1"));        assertEquals(true, StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphanumeric("_"));        assertEquals(false, StringUtils.isAlphanumeric("hkHKHik*khbkuh"));    }    public void testIsWhitespace() {        assertEquals(false, StringUtils.isWhitespace(null));        assertEquals(true, StringUtils.isWhitespace(""));        assertEquals(true, StringUtils.isWhitespace(" "));        assertEquals(true, StringUtils.isWhitespace("\t \n \t"));        assertEquals(false, StringUtils.isWhitespace("\t aa\n \t"));        assertEquals(true, StringUtils.isWhitespace(" "));        assertEquals(false, StringUtils.isWhitespace(" a "));        assertEquals(false, StringUtils.isWhitespace("a  "));        assertEquals(false, StringUtils.isWhitespace("  a"));        assertEquals(false, StringUtils.isWhitespace("aba"));    }    public void testIsAlphaspace() {        assertEquals(false, StringUtils.isAlphaSpace(null));        assertEquals(true, StringUtils.isAlphaSpace(""));        assertEquals(true, StringUtils.isAlphaSpace(" "));        assertEquals(true, StringUtils.isAlphaSpace("a"));        assertEquals(true, StringUtils.isAlphaSpace("A"));        assertEquals(true, StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(true, StringUtils.isAlphaSpace("ham kso"));        assertEquals(false, StringUtils.isAlphaSpace("1"));        assertEquals(false, StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphaSpace("_"));        assertEquals(false, StringUtils.isAlphaSpace("hkHKHik*khbkuh"));    }    public void testIsAlphanumericSpace() {        assertEquals(false, StringUtils.isAlphanumericSpace(null));        assertEquals(true, StringUtils.isAlphanumericSpace(""));        assertEquals(true, StringUtils.isAlphanumericSpace(" "));        assertEquals(true, StringUtils.isAlphanumericSpace("a"));        assertEquals(true, StringUtils.isAlphanumericSpace("A"));        assertEquals(true, StringUtils.isAlphanumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(true, StringUtils.isAlphanumericSpace("ham kso"));        assertEquals(true, StringUtils.isAlphanumericSpace("1"));        assertEquals(true, StringUtils.isAlphanumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphanumericSpace("_"));        assertEquals(false, StringUtils.isAlphanumericSpace("hkHKHik*khbkuh"));    }    public void testIsNumeric() {        assertEquals(false, StringUtils.isNumeric(null));        assertEquals(true, StringUtils.isNumeric(""));        assertEquals(false, StringUtils.isNumeric(" "));        assertEquals(false, StringUtils.isNumeric("a"));        assertEquals(false, StringUtils.isNumeric("A"));        assertEquals(false, StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isNumeric("ham kso"));        assertEquals(true, StringUtils.isNumeric("1"));        assertEquals(true, StringUtils.isNumeric("1000"));        assertEquals(false, StringUtils.isNumeric("2.3"));        assertEquals(false, StringUtils.isNumeric("10 00"));        assertEquals(false, StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isNumeric("_"));        assertEquals(false, StringUtils.isNumeric("hkHKHik*khbkuh"));    }    public void testIsNumericSpace() {        assertEquals(false, StringUtils.isNumericSpace(null));        assertEquals(true, StringUtils.isNumericSpace(""));        assertEquals(true, StringUtils.isNumericSpace(" "));        assertEquals(false, StringUtils.isNumericSpace("a"));        assertEquals(false, StringUtils.isNumericSpace("A"));        assertEquals(false, StringUtils.isNumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isNumericSpace("ham kso"));        assertEquals(true, StringUtils.isNumericSpace("1"));        assertEquals(true, StringUtils.isNumericSpace("1000"));        assertEquals(false, StringUtils.isNumericSpace("2.3"));        assertEquals(true, StringUtils.isNumericSpace("10 00"));        assertEquals(false, StringUtils.isNumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isNumericSpace("_"));        assertEquals(false, StringUtils.isNumericSpace("hkHKHik*khbkuh"));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ObjectUtils}. * * @author <a href="mailto:jmcnally@collab.net">John McNally</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: ObjectUtilsTest.java,v 1.4 2003/03/23 21:49:13 scolebourne Exp $ */public class ObjectUtilsTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    public ObjectUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(ObjectUtilsTest.class);        suite.setName("ObjectUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testIsNull() {        Object o = FOO;        Object dflt = BAR;        assertSame("dflt was not returned when o was null", dflt, ObjectUtils.defaultIfNull(null, dflt));        assertSame("dflt was returned when o was not null", o, ObjectUtils.defaultIfNull(o, dflt));    }    public void testEquals() {        assertTrue("ObjectUtils.equals(null, null) returned false", ObjectUtils.equals(null, null));        assertTrue("ObjectUtils.equals(\"foo\", null) returned true", !ObjectUtils.equals(FOO, null));        assertTrue("ObjectUtils.equals(null, \"bar\") returned true", !ObjectUtils.equals(null, BAR));        assertTrue("ObjectUtils.equals(\"foo\", \"bar\") returned true", !ObjectUtils.equals(FOO, BAR));        assertTrue("ObjectUtils.equals(\"foo\", \"foo\") returned false", ObjectUtils.equals(FOO, FOO));    }    public void testIdentityToString() {        assertEquals(            "java.lang.String@" + Integer.toHexString(System.identityHashCode(FOO)),            ObjectUtils.identityToString(FOO));        Integer i = new Integer(90);        assertEquals(            "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)),            ObjectUtils.identityToString(i));        assertEquals(null, ObjectUtils.identityToString(null));    }    public void testNull() {        assertTrue(ObjectUtils.NULL != null);        assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null);        assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL));    }   }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import java.util.ArrayList;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ClassUtils}. * * @author Stephen Colebourne * @version $Id: ClassUtilsTest.java,v 1.3 2003/03/23 21:47:30 scolebourne Exp $ */public class ClassUtilsTest extends TestCase {    public ClassUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(ClassUtilsTest.class);    suite.setName("ClassUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    private static class Inner {    }        // -------------------------------------------------------------------------    public void test_getShortClassName_Object() {        assertEquals("ClassUtils", ClassUtils.getShortClassName(new ClassUtils(), "<null>"));        assertEquals("ClassUtilsTest.Inner", ClassUtils.getShortClassName(new Inner(), "<null>"));        assertEquals("String", ClassUtils.getShortClassName("hello", "<null>"));        assertEquals("<null>", ClassUtils.getShortClassName(null, "<null>"));    }        public void test_getShortClassName_Class() {        assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class));        assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class));        try {            ClassUtils.getShortClassName((Class) null);            fail();        } catch (IllegalArgumentException ex) {}    }        public void test_getShortClassName_String() {        assertEquals("ClassUtils", ClassUtils.getShortClassName(ClassUtils.class.getName()));        assertEquals("Map.Entry", ClassUtils.getShortClassName(Map.Entry.class.getName()));        try {            ClassUtils.getShortClassName((String) null);            fail();        } catch (IllegalArgumentException ex) {}        try {            ClassUtils.getShortClassName("");            fail();        } catch (IllegalArgumentException ex) {}    }        // -------------------------------------------------------------------------    public void test_getPackageName_Object() {        assertEquals("org.apache.commons.lang", ClassUtils.getPackageName(new ClassUtils(), "<null>"));        assertEquals("org.apache.commons.lang", ClassUtils.getPackageName(new Inner(), "<null>"));        assertEquals("<null>", ClassUtils.getPackageName(null, "<null>"));    }        public void test_getPackageName_Class() {        assertEquals("java.lang", ClassUtils.getPackageName(String.class));        assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class));        try {            ClassUtils.getPackageName((Class) null);            fail();        } catch (IllegalArgumentException ex) {}    }        public void test_getPackageName_String() {        assertEquals("org.apache.commons.lang", ClassUtils.getPackageName(ClassUtils.class.getName()));        assertEquals("java.util", ClassUtils.getPackageName(Map.Entry.class.getName()));        try {            ClassUtils.getPackageName((String) null);            fail();        } catch (IllegalArgumentException ex) {}        try {            ClassUtils.getPackageName("");            fail();        } catch (IllegalArgumentException ex) {}    }        // -------------------------------------------------------------------------    public void test_getAllSuperclasses_Class() {        List list = ClassUtils.getAllSuperclasses(CY.class);        assertEquals(2, list.size());        assertEquals(CX.class, list.get(0));        assertEquals(Object.class, list.get(1));        try {            ClassUtils.getAllSuperclasses(null);            fail();        } catch (IllegalArgumentException ex) {}    }        public void test_getAllInterfaces_Class() {        List list = ClassUtils.getAllInterfaces(CY.class);        assertEquals(6, list.size());        assertEquals(IB.class, list.get(0));        assertEquals(IC.class, list.get(1));        assertEquals(ID.class, list.get(2));        assertEquals(IE.class, list.get(3));        assertEquals(IF.class, list.get(4));        assertEquals(IA.class, list.get(5));        try {            ClassUtils.getAllInterfaces(null);            fail();        } catch (IllegalArgumentException ex) {}    }        private static interface IA {    }    private static interface IB {    }    private static interface IC extends ID, IE {    }    private static interface ID {    }    private static interface IE extends IF {    }    private static interface IF {    }    private static class CX implements IB, IA, IE {    }    private static class CY extends CX implements IB, IC {    }        // -------------------------------------------------------------------------    public void test_convertClassNamesToClasses_List() {        List list = new ArrayList();        List result = ClassUtils.convertClassNamesToClasses(list);        assertEquals(0, result.size());                list.add("java.lang.String");        list.add("java.lang.xxx");        list.add("java.lang.Object");        result = ClassUtils.convertClassNamesToClasses(list);        assertEquals(3, result.size());        assertEquals(String.class, result.get(0));        assertEquals(null, result.get(1));        assertEquals(Object.class, result.get(2));        list.add(new Object());        try {            ClassUtils.convertClassNamesToClasses(list);            fail();        } catch (ClassCastException ex) {}                try {            ClassUtils.convertClassNamesToClasses(null);            fail();        } catch (IllegalArgumentException ex) {}    }        public void test_convertClassesToClassNames_List() {        List list = new ArrayList();        List result = ClassUtils.convertClassesToClassNames(list);        assertEquals(0, result.size());                list.add(String.class);        list.add(Object.class);        result = ClassUtils.convertClassesToClassNames(list);        assertEquals(2, result.size());        assertEquals("java.lang.String", result.get(0));        assertEquals("java.lang.Object", result.get(1));        list.add(new Object());        try {            ClassUtils.convertClassesToClassNames(list);            fail();        } catch (ClassCastException ex) {}                try {            ClassUtils.convertClassesToClassNames(null);            fail();        } catch (IllegalArgumentException ex) {}    }        // -------------------------------------------------------------------------    public void test_isInnerClass_Class() {        assertEquals(true, ClassUtils.isInnerClass(Inner.class));        assertEquals(true, ClassUtils.isInnerClass(Map.Entry.class));        assertEquals(true, ClassUtils.isInnerClass(new Cloneable() {        }.getClass()));        assertEquals(false, ClassUtils.isInnerClass(this.getClass()));        assertEquals(false, ClassUtils.isInnerClass(String.class));        try {            ClassUtils.isInnerClass(null);            fail();        } catch (IllegalArgumentException ex) {}    }        // -------------------------------------------------------------------------    public void test_isAssignable_ClassArray_ClassArray() throws Exception {        Class[] array2 = new Class[] {Object.class, Object.class};        Class[] array1 = new Class[] {Object.class};        Class[] array1s = new Class[] {String.class};        Class[] array0 = new Class[] {};        assertEquals(false, ClassUtils.isAssignable(array1, array2));        assertEquals(false, ClassUtils.isAssignable(null, array2));        assertEquals(true, ClassUtils.isAssignable(null, array0));        assertEquals(true, ClassUtils.isAssignable(array0, array0));        assertEquals(true, ClassUtils.isAssignable(array0, null));        assertEquals(true, ClassUtils.isAssignable((Class[]) null, (Class[]) null));                assertEquals(false, ClassUtils.isAssignable(array1, array1s));        assertEquals(true, ClassUtils.isAssignable(array1s, array1s));        assertEquals(true, ClassUtils.isAssignable(array1s, array1));    }        public void test_isAssignable() throws Exception {        try {            ClassUtils.isAssignable(String.class, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            ClassUtils.isAssignable((Class) null, (Class) null);            fail();        } catch (IllegalArgumentException ex) {}        assertEquals(true, ClassUtils.isAssignable(null, Object.class));        assertEquals(true, ClassUtils.isAssignable(null, Integer.class));        assertEquals(false, ClassUtils.isAssignable(null, Integer.TYPE));        assertEquals(true, ClassUtils.isAssignable(String.class, Object.class));        assertEquals(true, ClassUtils.isAssignable(String.class, String.class));        assertEquals(false, ClassUtils.isAssignable(Object.class, String.class));        assertEquals(false, ClassUtils.isAssignable(Integer.TYPE, Integer.class));        assertEquals(false, ClassUtils.isAssignable(Integer.class, Integer.TYPE));        assertEquals(true, ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));        assertEquals(true, ClassUtils.isAssignable(Integer.class, Integer.class));    }        public void test_isAssignable_Widening() throws Exception {        // test byte conversions        assertEquals("byte -> char", false, ClassUtils.isAssignable(Byte.TYPE, Character.TYPE));        assertEquals("byte -> byte", true, ClassUtils.isAssignable(Byte.TYPE, Byte.TYPE));        assertEquals("byte -> short", true, ClassUtils.isAssignable(Byte.TYPE, Short.TYPE));        assertEquals("byte -> int", true, ClassUtils.isAssignable(Byte.TYPE, Integer.TYPE));        assertEquals("byte -> long", true, ClassUtils.isAssignable(Byte.TYPE, Long.TYPE));        assertEquals("byte -> float", true, ClassUtils.isAssignable(Byte.TYPE, Float.TYPE));        assertEquals("byte -> double", true, ClassUtils.isAssignable(Byte.TYPE, Double.TYPE));        assertEquals("byte -> boolean", false, ClassUtils.isAssignable(Byte.TYPE, Boolean.TYPE));                // test short conversions        assertEquals("short -> char", false, ClassUtils.isAssignable(Short.TYPE, Character.TYPE));        assertEquals("short -> byte", false, ClassUtils.isAssignable(Short.TYPE, Byte.TYPE));        assertEquals("short -> short", true, ClassUtils.isAssignable(Short.TYPE, Short.TYPE));        assertEquals("short -> int", true, ClassUtils.isAssignable(Short.TYPE, Integer.TYPE));        assertEquals("short -> long", true, ClassUtils.isAssignable(Short.TYPE, Long.TYPE));        assertEquals("short -> float", true, ClassUtils.isAssignable(Short.TYPE, Float.TYPE));        assertEquals("short -> double", true, ClassUtils.isAssignable(Short.TYPE, Double.TYPE));        assertEquals("short -> boolean", false, ClassUtils.isAssignable(Short.TYPE, Boolean.TYPE));                // test char conversions        assertEquals("char -> char", true, ClassUtils.isAssignable(Character.TYPE, Character.TYPE));        assertEquals("char -> byte", false, ClassUtils.isAssignable(Character.TYPE, Byte.TYPE));        assertEquals("char -> short", false, ClassUtils.isAssignable(Character.TYPE, Short.TYPE));        assertEquals("char -> int", true, ClassUtils.isAssignable(Character.TYPE, Integer.TYPE));        assertEquals("char -> long", true, ClassUtils.isAssignable(Character.TYPE, Long.TYPE));        assertEquals("char -> float", true, ClassUtils.isAssignable(Character.TYPE, Float.TYPE));        assertEquals("char -> double", true, ClassUtils.isAssignable(Character.TYPE, Double.TYPE));        assertEquals("char -> boolean", false, ClassUtils.isAssignable(Character.TYPE, Boolean.TYPE));                // test int conversions        assertEquals("int -> char", false, ClassUtils.isAssignable(Integer.TYPE, Character.TYPE));        assertEquals("int -> byte", false, ClassUtils.isAssignable(Integer.TYPE, Byte.TYPE));        assertEquals("int -> short", false, ClassUtils.isAssignable(Integer.TYPE, Short.TYPE));        assertEquals("int -> int", true, ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));        assertEquals("int -> long", true, ClassUtils.isAssignable(Integer.TYPE, Long.TYPE));        assertEquals("int -> float", true, ClassUtils.isAssignable(Integer.TYPE, Float.TYPE));        assertEquals("int -> double", true, ClassUtils.isAssignable(Integer.TYPE, Double.TYPE));        assertEquals("int -> boolean", false, ClassUtils.isAssignable(Integer.TYPE, Boolean.TYPE));         // test long conversions        assertEquals("long -> char", false, ClassUtils.isAssignable(Long.TYPE, Character.TYPE));        assertEquals("long -> byte", false, ClassUtils.isAssignable(Long.TYPE, Byte.TYPE));        assertEquals("long -> short", false, ClassUtils.isAssignable(Long.TYPE, Short.TYPE));        assertEquals("long -> int", false, ClassUtils.isAssignable(Long.TYPE, Integer.TYPE));        assertEquals("long -> long", true, ClassUtils.isAssignable(Long.TYPE, Long.TYPE));        assertEquals("long -> float", true, ClassUtils.isAssignable(Long.TYPE, Float.TYPE));        assertEquals("long -> double", true, ClassUtils.isAssignable(Long.TYPE, Double.TYPE));        assertEquals("long -> boolean", false, ClassUtils.isAssignable(Long.TYPE, Boolean.TYPE));         // test float conversions        assertEquals("float -> char", false, ClassUtils.isAssignable(Float.TYPE, Character.TYPE));        assertEquals("float -> byte", false, ClassUtils.isAssignable(Float.TYPE, Byte.TYPE));        assertEquals("float -> short", false, ClassUtils.isAssignable(Float.TYPE, Short.TYPE));        assertEquals("float -> int", false, ClassUtils.isAssignable(Float.TYPE, Integer.TYPE));        assertEquals("float -> long", false, ClassUtils.isAssignable(Float.TYPE, Long.TYPE));        assertEquals("float -> float", true, ClassUtils.isAssignable(Float.TYPE, Float.TYPE));        assertEquals("float -> double", true, ClassUtils.isAssignable(Float.TYPE, Double.TYPE));        assertEquals("float -> boolean", false, ClassUtils.isAssignable(Float.TYPE, Boolean.TYPE));                // test float conversions        assertEquals("double -> char", false, ClassUtils.isAssignable(Double.TYPE, Character.TYPE));        assertEquals("double -> byte", false, ClassUtils.isAssignable(Double.TYPE, Byte.TYPE));        assertEquals("double -> short", false, ClassUtils.isAssignable(Double.TYPE, Short.TYPE));        assertEquals("double -> int", false, ClassUtils.isAssignable(Double.TYPE, Integer.TYPE));        assertEquals("double -> long", false, ClassUtils.isAssignable(Double.TYPE, Long.TYPE));        assertEquals("double -> float", false, ClassUtils.isAssignable(Double.TYPE, Float.TYPE));        assertEquals("double -> double", true, ClassUtils.isAssignable(Double.TYPE, Double.TYPE));        assertEquals("double -> boolean", false, ClassUtils.isAssignable(Double.TYPE, Boolean.TYPE));                // test float conversions        assertEquals("boolean -> char", false, ClassUtils.isAssignable(Boolean.TYPE, Character.TYPE));        assertEquals("boolean -> byte", false, ClassUtils.isAssignable(Boolean.TYPE, Byte.TYPE));        assertEquals("boolean -> short", false, ClassUtils.isAssignable(Boolean.TYPE, Short.TYPE));        assertEquals("boolean -> int", false, ClassUtils.isAssignable(Boolean.TYPE, Integer.TYPE));        assertEquals("boolean -> long", false, ClassUtils.isAssignable(Boolean.TYPE, Long.TYPE));        assertEquals("boolean -> float", false, ClassUtils.isAssignable(Boolean.TYPE, Float.TYPE));        assertEquals("boolean -> double", false, ClassUtils.isAssignable(Boolean.TYPE, Double.TYPE));        assertEquals("boolean -> boolean", true, ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE));    }    //    public static List getAssignableFrom(List classes, Class superclass) {//    public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {//    public static boolean isAssignable(Class cls, Class toClass) {}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.CharSetUtils}. * * @author <a href="mailto:bayard@generationjava.com">Henri Yandell</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: CharSetUtilsTest.java,v 1.7 2003/03/23 21:47:30 scolebourne Exp $ */public class CharSetUtilsTest extends TestCase{    public CharSetUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(CharSetUtilsTest.class);    suite.setName("CharSetUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSqueeze()    {        assertEquals("squeeze(String,String[]) failed",                     "helo", CharSetUtils.squeeze("hello", new String[] {"el"}));        assertEquals("squeeze(String,String[]) failed",                     "", CharSetUtils.squeeze("", new String[] {"el"}));        assertEquals("squeeze(String,String[]) failed",                     "hello", CharSetUtils.squeeze("hello", new String[] {"e"}));        assertEquals("squeeze(String,String[]) failed",                     "fofof", CharSetUtils.squeeze("fooffooff", new String[] {"of"}));        assertEquals("squeeze(String,String[]) failed",                     "fof", CharSetUtils.squeeze("fooooff", new String[] {"fo"}));    }    public void testCount()    {        assertEquals("count(String,String[]) failed",                     3, CharSetUtils.count("hello", new String[] {"el"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("", new String[] {"el"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("hello", new String[] {"x"}));        assertEquals("count(String,String[]) failed",                     2, CharSetUtils.count("hello", new String[] {"e-i"}));        assertEquals("count(String,String[]) failed",                     5, CharSetUtils.count("hello", new String[] {"a-z"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("hello", new String[] {""}));    }    public void testKeep()    {        assertEquals("keep(String,String[]) failed",                     "ell", CharSetUtils.keep("hello", new String[] {"el"}));        assertEquals("keep(String,String[]) failed",                     "hello", CharSetUtils.keep("hello", new String[] {"elho"}));        assertEquals("keep(String,String[]) failed",                     "", CharSetUtils.keep("hello", new String[] {""}));        assertEquals("keep(String,String[]) failed",                     "hello", CharSetUtils.keep("hello", new String[] {"a-z"}));        assertEquals("keep(String,String[]) failed",                     "----", CharSetUtils.keep("----", new String[] {"-"}));        assertEquals("keep(String,String[]) failed",                     "ll", CharSetUtils.keep("hello", new String[] {"l"}));    }    public void testDelete()    {        assertEquals("delete(String,String[]) failed",                     "ho", CharSetUtils.delete("hello", new String[] {"el"}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("hello", new String[] {"elho"}));        assertEquals("delete(String,String[]) failed",                     "hello", CharSetUtils.delete("hello", new String[] {""}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("hello", new String[] {"a-z"}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("----", new String[] {"-"}));        assertEquals("delete(String,String[]) failed",                     "heo", CharSetUtils.delete("hello", new String[] {"l"}));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import java.util.Arrays;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ArrayUtils}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author Moritz Petersen * @author Nikolay Metchev * @version $Id: ArrayUtilsTest.java,v 1.6 2003/03/23 21:47:30 scolebourne Exp $ */public class ArrayUtilsTest extends TestCase {    public ArrayUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(ArrayUtilsTest.class);    suite.setName("ArrayUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testToString() {        assertEquals("{}", ArrayUtils.toString(null));        assertEquals("{}", ArrayUtils.toString(new Object[0]));        assertEquals("{}", ArrayUtils.toString(new String[0]));        assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}));        assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}));                assertEquals("<empty>", ArrayUtils.toString(null, "<empty>"));        assertEquals("{}", ArrayUtils.toString(new Object[0], "<empty>"));        assertEquals("{}", ArrayUtils.toString(new String[0], "<empty>"));        assertEquals("{<null>}", ArrayUtils.toString(new String[] {null}, "<empty>"));        assertEquals("{pink,blue}", ArrayUtils.toString(new String[] {"pink","blue"}, "<empty>"));    }    //-----------------------------------------------------------------------    public void testHashCode() {        long[][] array1 = new long[][] {{2,5}, {4,5}};        long[][] array2 = new long[][] {{2,5}, {4,6}};        assertEquals(true, ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array1));        assertEquals(false, ArrayUtils.hashCode(array1) == ArrayUtils.hashCode(array2));                Object[] array3 = new Object[] {new String(new char[] {'A', 'B'})};        Object[] array4 = new Object[] {"AB"};        assertEquals(true, ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array3));        assertEquals(true, ArrayUtils.hashCode(array3) == ArrayUtils.hashCode(array4));    }        //-----------------------------------------------------------------------    public void testIsEquals() {        long[][] array1 = new long[][] {{2,5}, {4,5}};        long[][] array2 = new long[][] {{2,5}, {4,6}};        assertEquals(true, ArrayUtils.isEquals(array1, array1));        assertEquals(false, ArrayUtils.isEquals(array1, array2));                Object[] array3 = new Object[] {new String(new char[] {'A', 'B'})};        Object[] array4 = new Object[] {"AB"};        assertEquals(true, ArrayUtils.isEquals(array3, array3));        assertEquals(true, ArrayUtils.isEquals(array3, array4));    }        //-----------------------------------------------------------------------    public void testToMap() {        Map map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}});                assertEquals("bar", map.get("foo"));        assertEquals("world", map.get("hello"));                try {            ArrayUtils.toMap(null);            fail("exception expected");        } catch (IllegalArgumentException ex) {}        try {            ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}});            fail("exception expected");        } catch (IllegalArgumentException ex) {}        try {            ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"});            fail("exception expected");        } catch (IllegalArgumentException ex) {}        try {            ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null});            fail("exception expected");        } catch (IllegalArgumentException ex) {}                map = ArrayUtils.toMap(new Object[] {new Map.Entry() {            public Object getKey() {                return "foo";            }            public Object getValue() {                return "bar";            }            public Object setValue(Object value) {                throw new UnsupportedOperationException();            }            public boolean equals(Object o) {                throw new UnsupportedOperationException();            }            public int hashCode() {                throw new UnsupportedOperationException();            }        }});        assertEquals("bar", map.get("foo"));    }    //-----------------------------------------------------------------------    public void testClone() {        assertEquals(null, ArrayUtils.clone((Object[]) null));        Object[] original1 = new Object[0];        Object[] cloned1 = ArrayUtils.clone(original1);        assertTrue(Arrays.equals(original1, cloned1));        assertTrue(original1 != cloned1);                StringBuffer buf = new StringBuffer("pick");        original1 = new Object[] {buf, "a", new String[] {"stick"}};        cloned1 = ArrayUtils.clone(original1);        assertTrue(Arrays.equals(original1, cloned1));        assertTrue(original1 != cloned1);        assertSame(original1[0], cloned1[0]);        assertSame(original1[1], cloned1[1]);        assertSame(original1[2], cloned1[2]);    }    public void testCloneBoolean() {        boolean[] original = new boolean[] {true, false};        boolean[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneLong() {        long[] original = new long[] {0L, 1L};        long[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneInt() {        int[] original = new int[] {5, 8};        int[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneShort() {        short[] original = new short[] {1, 4};        short[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneChar() {        char[] original = new char[] {'a', '4'};        char[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneByte() {        byte[] original = new byte[] {1, 6};        byte[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneDouble() {        double[] original = new double[] {2.4d, 5.7d};        double[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }        public void testCloneFloat() {        float[] original = new float[] {2.6f, 6.4f};        float[] cloned = ArrayUtils.clone(original);        assertTrue(Arrays.equals(original, cloned));        assertTrue(original != cloned);    }    //-----------------------------------------------------------------------    public void testSameLength() {        Object[] nullArray = null;        Object[] emptyArray = new Object[0];        Object[] oneArray = new Object[] {"pick"};        Object[] twoArray = new Object[] {"pick", "stick"};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }    public void testSameLengthBoolean() {        boolean[] nullArray = null;        boolean[] emptyArray = new boolean[0];        boolean[] oneArray = new boolean[] {true};        boolean[] twoArray = new boolean[] {true, false};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthLong() {        long[] nullArray = null;        long[] emptyArray = new long[0];        long[] oneArray = new long[] {0L};        long[] twoArray = new long[] {0L, 76L};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthInt() {        int[] nullArray = null;        int[] emptyArray = new int[0];        int[] oneArray = new int[] {4};        int[] twoArray = new int[] {5, 7};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthShort() {        short[] nullArray = null;        short[] emptyArray = new short[0];        short[] oneArray = new short[] {4};        short[] twoArray = new short[] {6, 8};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthChar() {        char[] nullArray = null;        char[] emptyArray = new char[0];        char[] oneArray = new char[] {'f'};        char[] twoArray = new char[] {'d', 't'};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthByte() {        byte[] nullArray = null;        byte[] emptyArray = new byte[0];        byte[] oneArray = new byte[] {3};        byte[] twoArray = new byte[] {4, 6};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthDouble() {        double[] nullArray = null;        double[] emptyArray = new double[0];        double[] oneArray = new double[] {1.3d};        double[] twoArray = new double[] {4.5d, 6.3d};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        public void testSameLengthFloat() {        float[] nullArray = null;        float[] emptyArray = new float[0];        float[] oneArray = new float[] {2.5f};        float[] twoArray = new float[] {6.4f, 5.8f};                assertEquals(true, ArrayUtils.isSameLength(nullArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(nullArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(nullArray, twoArray));                assertEquals(true, ArrayUtils.isSameLength(emptyArray, nullArray));        assertEquals(true, ArrayUtils.isSameLength(emptyArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(emptyArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(oneArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, emptyArray));        assertEquals(true, ArrayUtils.isSameLength(oneArray, oneArray));        assertEquals(false, ArrayUtils.isSameLength(oneArray, twoArray));                assertEquals(false, ArrayUtils.isSameLength(twoArray, nullArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, emptyArray));        assertEquals(false, ArrayUtils.isSameLength(twoArray, oneArray));        assertEquals(true, ArrayUtils.isSameLength(twoArray, twoArray));    }        //-----------------------------------------------------------------------    public void testSameType() {        try {            ArrayUtils.isSameType(null, null);            fail();        } catch (IllegalArgumentException ex) {}        try {            ArrayUtils.isSameType(null, new Object[0]);            fail();        } catch (IllegalArgumentException ex) {}        try {            ArrayUtils.isSameType(new Object[0], null);            fail();        } catch (IllegalArgumentException ex) {}                assertEquals(true, ArrayUtils.isSameType(new Object[0], new Object[0]));        assertEquals(false, ArrayUtils.isSameType(new String[0], new Object[0]));        assertEquals(true, ArrayUtils.isSameType(new String[0][0], new String[0][0]));        assertEquals(false, ArrayUtils.isSameType(new String[0], new String[0][0]));        assertEquals(false, ArrayUtils.isSameType(new String[0][0], new String[0]));    }        //-----------------------------------------------------------------------    public void testReverse() {        StringBuffer str1 = new StringBuffer("pick");        String str2 = "a";        String[] str3 = new String[] {"stick"};        String str4 = "up";                Object[] array = new Object[] {str1, str2, str3};        ArrayUtils.reverse(array);        assertEquals(array[0], str3);        assertEquals(array[1], str2);        assertEquals(array[2], str1);                array = new Object[] {str1, str2, str3, str4};        ArrayUtils.reverse(array);        assertEquals(array[0], str4);        assertEquals(array[1], str3);        assertEquals(array[2], str2);        assertEquals(array[3], str1);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }    public void testReverseLong() {        long[] array = new long[] {1L, 2L, 3L};        ArrayUtils.reverse(array);        assertEquals(array[0], 3L);        assertEquals(array[1], 2L);        assertEquals(array[2], 1L);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseInt() {        int[] array = new int[] {1, 2, 3};        ArrayUtils.reverse(array);        assertEquals(array[0], 3);        assertEquals(array[1], 2);        assertEquals(array[2], 1);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseShort() {        short[] array = new short[] {1, 2, 3};        ArrayUtils.reverse(array);        assertEquals(array[0], 3);        assertEquals(array[1], 2);        assertEquals(array[2], 1);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseChar() {        char[] array = new char[] {'a', 'f', 'C'};        ArrayUtils.reverse(array);        assertEquals(array[0], 'C');        assertEquals(array[1], 'f');        assertEquals(array[2], 'a');        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseByte() {        byte[] array = new byte[] {2, 3, 4};        ArrayUtils.reverse(array);        assertEquals(array[0], 4);        assertEquals(array[1], 3);        assertEquals(array[2], 2);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseDouble() {        double[] array = new double[] {0.3d, 0.4d, 0.5d};        ArrayUtils.reverse(array);        assertEquals(array[0], 0.5d, 0.0d);        assertEquals(array[1], 0.4d, 0.0d);        assertEquals(array[2], 0.3d, 0.0d);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseFloat() {        float[] array = new float[] {0.3f, 0.4f, 0.5f};        ArrayUtils.reverse(array);        assertEquals(array[0], 0.5f, 0.0f);        assertEquals(array[1], 0.4f, 0.0f);        assertEquals(array[2], 0.3f, 0.0f);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        public void testReverseBoolean() {        boolean[] array = new boolean[] {false, false, true};        ArrayUtils.reverse(array);        assertEquals(array[0], true);        assertEquals(array[1], false);        assertEquals(array[2], false);        array = null;        ArrayUtils.reverse(array);        assertEquals(null, array);    }        //-----------------------------------------------------------------------    public void testIndexOf() {        Object[] array = new Object[] { "0", "1", "2", "3", null, "0" };        assertEquals(-1, ArrayUtils.indexOf(null, null));        assertEquals(-1, ArrayUtils.indexOf(null, "0"));        assertEquals(0, ArrayUtils.indexOf(array, "0"));        assertEquals(1, ArrayUtils.indexOf(array, "1"));        assertEquals(2, ArrayUtils.indexOf(array, "2"));        assertEquals(3, ArrayUtils.indexOf(array, "3"));        assertEquals(4, ArrayUtils.indexOf(array, null));        assertEquals(-1, ArrayUtils.indexOf(array, "notInArray"));    }    public void testIndexOfWithStartIndex() {        Object[] array = new Object[] { "0", "1", "2", "3", null, "0" };        assertEquals(-1, ArrayUtils.indexOf(null, null, 2));        assertEquals(-1, ArrayUtils.indexOf(null, "0", 2));        assertEquals(5, ArrayUtils.indexOf(array, "0", 2));        assertEquals(-1, ArrayUtils.indexOf(array, "1", 2));        assertEquals(2, ArrayUtils.indexOf(array, "2", 2));        assertEquals(3, ArrayUtils.indexOf(array, "3", 2));        assertEquals(4, ArrayUtils.indexOf(array, null, 2));        assertEquals(-1, ArrayUtils.indexOf(array, "notInArray"));                assertEquals(4, ArrayUtils.indexOf(array, null, -1));        assertEquals(-1, ArrayUtils.indexOf(array, "0", 6));    }    public void testLastIndexOf() {        Object[] array = new Object[] { "0", "1", "2", "3", null, "0" };        assertEquals(-1, ArrayUtils.lastIndexOf(null, null));        assertEquals(-1, ArrayUtils.lastIndexOf(null, "0"));        assertEquals(5, ArrayUtils.lastIndexOf(array, "0"));        assertEquals(1, ArrayUtils.lastIndexOf(array, "1"));        assertEquals(2, ArrayUtils.lastIndexOf(array, "2"));        assertEquals(3, ArrayUtils.lastIndexOf(array, "3"));        assertEquals(4, ArrayUtils.lastIndexOf(array, null));        assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray"));    }    public void testLastIndexOfWithStartIndex() {        Object[] array = new Object[] { "0", "1", "2", "3", null, "0" };        assertEquals(-1, ArrayUtils.lastIndexOf(null, null, 2));        assertEquals(-1, ArrayUtils.lastIndexOf(null, "0", 2));        assertEquals(0, ArrayUtils.lastIndexOf(array, "0", 2));        assertEquals(1, ArrayUtils.lastIndexOf(array, "1", 2));        assertEquals(2, ArrayUtils.lastIndexOf(array, "2", 2));        assertEquals(-1, ArrayUtils.lastIndexOf(array, "3", 2));        assertEquals(4, ArrayUtils.lastIndexOf(array, null, 5));        assertEquals(-1, ArrayUtils.lastIndexOf(array, null, 2));        assertEquals(-1, ArrayUtils.lastIndexOf(array, "notInArray"));                assertEquals(-1, ArrayUtils.lastIndexOf(array, null, -1));        assertEquals(5, ArrayUtils.lastIndexOf(array, "0", 88));    }    public void testContains() {        Object[] array = new Object[] { "0", "1", "2", "3", null, "0" };        assertEquals(false, ArrayUtils.contains(null, null));        assertEquals(false, ArrayUtils.contains(null, "1"));        assertEquals(true, ArrayUtils.contains(array, "0"));        assertEquals(true, ArrayUtils.contains(array, "1"));        assertEquals(true, ArrayUtils.contains(array, "2"));        assertEquals(true, ArrayUtils.contains(array, "3"));        assertEquals(true, ArrayUtils.contains(array, null));        assertEquals(false, ArrayUtils.contains(array, "notInArray"));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;import org.apache.commons.lang.exception.Nestable;/** * JUnit tests. *  * @author Matthew Hawthorne * @version $Id: UnhandledExceptionTest.java,v 1.1 2003/05/15 04:05:11 bayard Exp $ * @see UnhandledException */public class UnhandledExceptionTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        return new TestSuite(UnhandledExceptionTest.class);    }    public UnhandledExceptionTest(String testName) {        super(testName);    }    // testConstructor    public void testConstructor_throwable_nullInput() {        final Throwable t = null;        new UnhandledException(t);    }    public void testConstructor_stringAndThrowable_nullInput() {        new UnhandledException(null, null);    }    // testGetCause    public void testGetCause() {        final Throwable t = new NullPointerException();        final Nestable n = new UnhandledException(t);        assertEquals(t, n.getCause());    }    public void testGetCauseAndGetMessage() {        final Throwable t = new NullPointerException();        final String msg = "nullArg";        final Nestable n = new UnhandledException(msg, t);        assertEquals(t, n.getCause());        assertEquals(msg, n.getMessage());    }} // UnhandledExceptionTest
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsEqualsIndexOfTest.java,v 1.2 2003/03/23 21:50:58 scolebourne Exp $ */public class StringUtilsEqualsIndexOfTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String FOOBAR = "foobar";    private static final String[] FOOBAR_SUB_ARRAY = new String[] {"ob", "ba"};    public StringUtilsEqualsIndexOfTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsEqualsIndexOfTest.class);    suite.setName("StringUtilsEqualsIndexOf Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testEquals() {        assertEquals(true, StringUtils.equals(null, null));        assertEquals(true, StringUtils.equals(FOO, FOO));        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));        assertEquals(false, StringUtils.equals(FOO, BAR));        assertEquals(false, StringUtils.equals(FOO, null));        assertEquals(false, StringUtils.equals(null, FOO));    }    public void testEqualsIgnoreCase() {        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));    }    public void testIndexOfAny() {        assertEquals(-1, StringUtils.indexOfAny(null, null));        assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, null));        assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {"llll"}));    }    public void testLastIndexOfAny() {        assertEquals(-1, StringUtils.lastIndexOfAny(null, null));        assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, null));        assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {"llll"}));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils}. * * @author <a href="mailto:dlr@collab.net">Daniel Rall</a> * @author <a href="mailto:bayard@generationjava.com">Henri Yandell</a> * @author Stephen Colebourne * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @author <a href="mailto:fredrik@westermarck.com>Fredrik Westermarck</a> * @author Holger Krauth * @author <a href="hps@intermeta.de">Henning P. Schmiedehausen</a> * @version $Id: StringUtilsTest.java,v 1.19 2003/04/16 04:37:33 bayard Exp $ */public class StringUtilsTest extends TestCase {    private static final String[] ARRAY_LIST = { "foo", "bar", "baz" };    private static final String[] EMPTY_ARRAY_LIST = {};    private static final String SEPARATOR = ",";    private static final char   SEPARATOR_CHAR = ';';    private static final String TEXT_LIST = "foo,bar,baz";    private static final String TEXT_LIST_CHAR = "foo;bar;baz";    private static final String TEXT_LIST_NOSEP = "foobarbaz";    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String CAP_FOO = "Foo";    private static final String SENTENCE = "foo bar baz";    public StringUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsTest.class);    suite.setName("StringUtilsTest Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testCaseFunctions() {        assertEquals("capitalise(String) failed",                     CAP_FOO, StringUtils.capitalise(FOO) );        assertEquals("capitalise(empty-string) failed",                     "", StringUtils.capitalise("") );        assertEquals("capitalise(single-char-string) failed",                     "X", StringUtils.capitalise("x") );        assertEquals("capitaliseAllWords(String) failed",                     "Foo Bar Baz", StringUtils.capitaliseAllWords(SENTENCE) );        assertEquals("capitaliseAllWords(empty-string) failed",                     "", StringUtils.capitaliseAllWords("") );        assertEquals("uncapitalise(String) failed",                     FOO, StringUtils.uncapitalise(CAP_FOO) );        assertEquals("uncapitalise(empty-string) failed",                     "", StringUtils.uncapitalise("") );        assertEquals("uncapitalise(single-char-string) failed",                     "x", StringUtils.uncapitalise("X") );        assertEquals("uncapitaliseAllWords(String) failed",                     SENTENCE, StringUtils.uncapitaliseAllWords("Foo Bar Baz") );        assertEquals("uncapitaliseAllWords(empty-string) failed",                     "", StringUtils.uncapitaliseAllWords("") );        assertEquals("upperCase(String) failed",                     "FOO TEST THING", StringUtils.upperCase("fOo test THING") );        assertEquals("upperCase(empty-string) failed",                     "", StringUtils.upperCase("") );        assertEquals("lowerCase(String) failed",                     "foo test thing", StringUtils.lowerCase("fOo test THING") );        assertEquals("lowerCase(empty-string) failed",                     "", StringUtils.lowerCase("") );        assertEquals("swapCase(empty-string) failed",                     "", StringUtils.swapCase("") );        assertEquals("swapCase(String-with-numbers) failed",                     "a123RgYu", StringUtils.swapCase("A123rGyU") );        assertEquals("swapCase(String) failed",                     "Hello aPACHE", StringUtils.swapCase("hELLO Apache") );    }    public void testJoin() {        assertEquals("concatenate(Object[]) failed",                     TEXT_LIST_NOSEP, StringUtils.concatenate(ARRAY_LIST));        assertEquals("join(Object[], String) failed", TEXT_LIST,                     StringUtils.join(ARRAY_LIST, SEPARATOR));        assertEquals("join(Iterator, String) failed", TEXT_LIST,                     StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),                                      SEPARATOR));        assertEquals("join(Object[], char) failed", TEXT_LIST_CHAR,                     StringUtils.join(ARRAY_LIST, SEPARATOR_CHAR));        assertEquals("join(Iterator, char) failed", TEXT_LIST_CHAR,                     StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),                                      SEPARATOR_CHAR));        assertEquals("join(Object[], null) failed", TEXT_LIST_NOSEP,                     StringUtils.join(ARRAY_LIST, null));        assertEquals("join(Iterator, null) failed", TEXT_LIST_NOSEP,                     StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),                                      null));        assertEquals("concatenate(Object[]) failed",                     "", StringUtils.concatenate(EMPTY_ARRAY_LIST));        assertEquals("join(Object[], String) failed", "",                     StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR));        assertEquals("join(Iterator, String) failed", "",                     StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(),                                      SEPARATOR));        assertEquals("join(Object[], char) failed", "",                     StringUtils.join(EMPTY_ARRAY_LIST, SEPARATOR_CHAR));        assertEquals("join(Iterator, char) failed", "",                     StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(),                                      SEPARATOR_CHAR));        assertEquals("join(Object[], null) failed", "",                     StringUtils.join(EMPTY_ARRAY_LIST, null));        assertEquals("join(Iterator, null) failed", "",                     StringUtils.join(Arrays.asList(EMPTY_ARRAY_LIST).iterator(),                                      null));    }    public void testSplit() {        String[] result = StringUtils.split(TEXT_LIST, SEPARATOR, 2);        String[] expected = { "foo", "bar,baz" };        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split(TEXT_LIST, SEPARATOR, 0);        expected = ARRAY_LIST;        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split(TEXT_LIST, SEPARATOR, -1);        expected = ARRAY_LIST;        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split("one two three four five six", null, 3);        assertEquals("split(Object[], null, int)[0] failed", "one", result[0]);        assertEquals("split(Object[], null, int)[1] failed", "two", result[1]);        assertEquals("split(Object[], null, int)[2] failed", "three four five six", result[2]);    }    public void testReplaceFunctions() {        assertEquals("replace(String, String, String, int) failed",                     FOO, StringUtils.replace("oo" + FOO, "o", "", 2));        assertEquals("replace(String, String, String) failed",                     "", StringUtils.replace(FOO + FOO + FOO, FOO, ""));        assertEquals("replaceOnce(String, String, String) failed",                     FOO, StringUtils.replaceOnce(FOO + FOO, FOO, ""));        assertEquals("carriage-return replace(String,String,String) failed",                     "test123", StringUtils.replace("test\r1\r2\r3", "\r", ""));        assertEquals("replace(String, String, String) failed",            "FOO", StringUtils.replace("FOO", "", "any"));        assertEquals("replace(String, String, String) failed",            "FOO", StringUtils.replace("FOO", null, "any"));        assertEquals("replace(String, String, String) failed",            "FOO", StringUtils.replace("FOO", "F", null));        assertEquals("replace(String, String, String) failed",            "FOO", StringUtils.replace("FOO", null, null));        assertEquals("replace(String, String, String) failed",            null, StringUtils.replace(null, "", "any"));    }    public void testOverlayString() {        assertEquals("overlayString(String, String, int, int) failed",                     "foo foor baz", StringUtils.overlayString(SENTENCE, FOO, 4, 6) );    }    public void testRepeat() {        assertEquals("repeat(String, int) failed",                     FOO + FOO + FOO, StringUtils.repeat(FOO, 3) );    }    public void testCenter() {        assertEquals("center(String, int) failed",                     "   "+FOO+"   ", StringUtils.center(FOO, 9) );    }    public void testDeprecatedChompFunctions() {        assertEquals("chompLast(String) failed",                     FOO, StringUtils.chompLast(FOO + "\n") );        assertEquals("getChomp(String, String) failed",                     "\n" + FOO, StringUtils.getChomp(FOO + "\n" + FOO, "\n") );        assertEquals("prechomp(String, String) failed",                     FOO, StringUtils.prechomp(FOO + "\n" + FOO, "\n") );        assertEquals("getPrechomp(String, String) failed",                     FOO + "\n", StringUtils.getPrechomp(FOO + "\n" + FOO, "\n") );        assertEquals("chopNewline(String, String) failed",                     FOO, StringUtils.chopNewline(FOO + "\r\n") );    }    public void testChop() {        String[][] chopCases = {            { FOO + "\r\n", FOO } ,            { FOO + "\n" , FOO } ,            { FOO + "\r", FOO },            { "foo", "fo"},            { "foo\nfoo", "foo\nfo" },            { "\n", "" },            { "\r", "" },            { "\r\n", "" },        };        for (int i = 0; i < chopCases.length; i++) {            String original = chopCases[i][0];            String expectedResult = chopCases[i][1];            assertEquals("chop(String) failed",                    expectedResult, StringUtils.chop(original));        }    }    public void testChomp() {        String[][] chompCases = {            { FOO + "\r\n", FOO } ,            { FOO + "\n" , FOO } ,            { FOO + "\r", FOO },            { FOO, FOO },            { FOO + "\n\n", FOO + "\n"},            { "foo\nfoo", "foo\nfoo" },            { "\n", "" },            { "\r", "" },            { "\r\n", "" },        };        for (int i = 0; i < chompCases.length; i++) {            String original = chompCases[i][0];            String expectedResult = chompCases[i][1];            assertEquals("chomp(String) failed",                    expectedResult, StringUtils.chomp(original));        }        assertEquals("chomp(String, String) failed",                "foo", StringUtils.chomp("foobar", "bar"));        assertEquals("chomp(String, String) failed",                "foobar", StringUtils.chomp("foobar", "baz"));        assertEquals("chomp(String, String) failed",                "foo", StringUtils.chomp("foo", "foooo"));    }    public void testSliceFunctions() {        String[][] sliceCases = {            {"foo\n", "foo"},            {"foo\nbar", "foo"},            {"foo\nbar\n", "foo\nbar"},            {"foo\nbar\nbaz", "foo\nbar"},        };        for (int i = 0; i < sliceCases.length; i++) {            String original = sliceCases[i][0];            String expectedResult = sliceCases[i][1];            assertEquals("slice(String) failed",                    expectedResult, StringUtils.slice(original));        }        String original = "fooXXbarXXbaz";        String sep = "XX";        assertEquals("slice(String,String) failed",                     "fooXXbar", StringUtils.slice(original, sep) );        assertEquals("sliceRemainder(String, String) failed",                     "baz", StringUtils.sliceRemainder(original, sep) );        assertEquals("sliceFirst(String, String) failed",                     "foo", StringUtils.sliceFirst(original, sep) );        assertEquals("sliceFirstRemainder(String, String) failed",                     "barXXbaz", StringUtils.sliceFirstRemainder(original, sep) );    }    public void testPadFunctions() {        assertEquals("rightPad(String, int) failed",                     "1234    ", StringUtils.rightPad ("1234", 8) );        assertEquals("rightPad(String, int, String) failed",                     "1234-+-+", StringUtils.rightPad ("1234", 8, "-+") );        assertEquals("rightPad(String, int, String) failed",                     "123456-+~", StringUtils.rightPad ("123456", 9, "-+~") );        assertEquals("leftPad(String, int) failed",                     "    1234", StringUtils.leftPad("1234", 8) );        assertEquals("leftPad(String, int, String) failed",                     "-+-+1234", StringUtils.leftPad("1234", 8, "-+") );        assertEquals("leftPad(String, int, String) failed",                     "-+~123456", StringUtils.leftPad("123456", 9, "-+~") );    }    public void testReverseFunctions() {        assertEquals("reverse(String) failed",                     "sdrawkcab", StringUtils.reverse("backwards") );        assertEquals("reverse(empty-string) failed",                     "", StringUtils.reverse("") );        assertEquals("reverseDelimitedString(String,'.') failed",                     "org.apache.test",                       StringUtils.reverseDelimitedString("test.apache.org", ".") );        assertEquals("reverseDelimitedString(empty-string,'.') failed",                     "",                       StringUtils.reverseDelimitedString("", ".") );        assertEquals("reverseDelimitedString(String,' ') failed",                     "once upon a time",                       StringUtils.reverseDelimitedString("time a upon once"," ") );    }    public void testDefaultFunctions() {        assertEquals("defaultString(empty-string) failed",                     "", StringUtils.defaultString("") );        assertEquals("defaultString(String) failed",                     FOO, StringUtils.defaultString(FOO) );        assertEquals("defaultString(null) failed",                     "", StringUtils.defaultString(null) );        assertEquals("defaultString(empty-string,String) failed",                     "", StringUtils.defaultString("", BAR) );        assertEquals("defaultString(String,String) failed",                     FOO, StringUtils.defaultString(FOO, BAR) );        assertEquals("defaultString(null,String) failed",                     BAR, StringUtils.defaultString(null, BAR) );    }    public void testEscapeFunctions() {        assertEquals("escape(empty-string) failed",                     "", StringUtils.escape("") );        assertEquals("escape(String) failed",                     FOO, StringUtils.escape(FOO) );        assertEquals("escape(String) failed",                     "\\t", StringUtils.escape("\t") );        assertEquals("escape(String) failed",                     "\\\\", StringUtils.escape("\\") );        assertEquals("escape(String) failed",                     "\\\\\\b\\t\\r", StringUtils.escape("\\\b\t\r") );        assertEquals("escape(String) failed",                     "\\u1234", StringUtils.escape("\u1234") );        assertEquals("escape(String) failed",                     "\\u0234", StringUtils.escape("\u0234") );        assertEquals("escape(String) failed",                     "\\u00FD", StringUtils.escape("\u00fd") );        assertEquals("unescape(String) failed",                     "", StringUtils.unescape("") );        assertEquals("unescape(String) failed",                     "test", StringUtils.unescape("test") );        assertEquals("unescape(String) failed",                     "\ntest\b", StringUtils.unescape("\\ntest\\b") );        assertEquals("unescape(String) failed",                     "\u123425foo\ntest\b", StringUtils.unescape("\\u123425foo\\ntest\\b") );        assertEquals("unescape(String) failed with unicode as final char",                     "\u1234", StringUtils.unescape("\\u1234") );    }    public void testGetLevenshteinDistance() {        assertEquals("getLevenshteinDistance(empty-string, empty-string) failed",                     0, StringUtils.getLevenshteinDistance("", "") );        assertEquals("getLevenshteinDistance(empty-string, String) failed",                     1, StringUtils.getLevenshteinDistance("", "a") );        assertEquals("getLevenshteinDistance(String, empty-string) failed",                     7, StringUtils.getLevenshteinDistance("aaapppp", "") );        assertEquals("getLevenshteinDistance(String, String) failed",                     1, StringUtils.getLevenshteinDistance("frog", "fog") );        assertEquals("getLevenshteinDistance(String, String) failed",                     3, StringUtils.getLevenshteinDistance("fly", "ant") );        assertEquals("getLevenshteinDistance(String, String) failed",                     7, StringUtils.getLevenshteinDistance("elephant", "hippo") );        assertEquals("getLevenshteinDistance(String, String) failed",                     7, StringUtils.getLevenshteinDistance("hippo", "elephant") );        assertEquals("getLevenshteinDistance(String, String) failed",                     1, StringUtils.getLevenshteinDistance("hello", "hallo") );    }    public void testContainsOnlyString() {        String str1 = "a";        String str2 = "b";        String str3 = "ab";        String chars1= "b";        String chars2= "a";        String chars3= "ab";        String emptyChars = "";        assertEquals("containsOnly(null, null) failed", false, StringUtils.containsOnly(null, (String) null));        assertEquals("containsOnly(empty-string, null) failed", false, StringUtils.containsOnly("", (String) null));        assertEquals("containsOnly(null, empty-string) failed", false, StringUtils.containsOnly(null, emptyChars));        assertEquals("containsOnly(str1, empty-char-array) failed", false, StringUtils.containsOnly(str1, emptyChars));        assertEquals("containsOnly(empty-string, empty-char-array) failed", true, StringUtils.containsOnly("", emptyChars));        assertEquals("containsOnly(empty-string, chars1) failed", true, StringUtils.containsOnly("", chars1));        assertEquals("containsOnly(str1, chars1) failed", false, StringUtils.containsOnly(str1, chars1));        assertEquals("containsOnly(str1, chars2) success", true, StringUtils.containsOnly(str1, chars2));        assertEquals("containsOnly(str1, chars3) success", true, StringUtils.containsOnly(str1, chars3));        assertEquals("containsOnly(str2, chars1) success", true, StringUtils.containsOnly(str2, chars1));        assertEquals("containsOnly(str2, chars2) failed", false, StringUtils.containsOnly(str2, chars2));        assertEquals("containsOnly(str2, chars3) success", true, StringUtils.containsOnly(str2, chars3));        assertEquals("containsOnly(String3, chars1) failed", false, StringUtils.containsOnly(str3, chars1));        assertEquals("containsOnly(String3, chars2) failed", false, StringUtils.containsOnly(str3, chars2));        assertEquals("containsOnly(String3, chars3) success", true, StringUtils.containsOnly(str3, chars3));    }    public void testContainsOnlyCharArray() {        String str1 = "a";        String str2 = "b";        String str3 = "ab";        char[] chars1= {'b'};        char[] chars2= {'a'};        char[] chars3= {'a', 'b'};        char[] emptyChars = new char[0];        assertEquals("containsOnly(null, null) failed", false, StringUtils.containsOnly(null, (char[]) null));        assertEquals("containsOnly(empty-string, null) failed", false, StringUtils.containsOnly("", (char[]) null));        assertEquals("containsOnly(null, empty-string) failed", false, StringUtils.containsOnly(null, emptyChars));        assertEquals("containsOnly(str1, empty-char-array) failed", false, StringUtils.containsOnly(str1, emptyChars));        assertEquals("containsOnly(empty-string, empty-char-array) failed", true, StringUtils.containsOnly("", emptyChars));        assertEquals("containsOnly(empty-string, chars1) failed", true, StringUtils.containsOnly("", chars1));        assertEquals("containsOnly(str1, chars1) failed", false, StringUtils.containsOnly(str1, chars1));        assertEquals("containsOnly(str1, chars2) success", true, StringUtils.containsOnly(str1, chars2));        assertEquals("containsOnly(str1, chars3) success", true, StringUtils.containsOnly(str1, chars3));        assertEquals("containsOnly(str2, chars1) success", true, StringUtils.containsOnly(str2, chars1));        assertEquals("containsOnly(str2, chars2) failed", false, StringUtils.containsOnly(str2, chars2));        assertEquals("containsOnly(str2, chars3) success", true, StringUtils.containsOnly(str2, chars3));        assertEquals("containsOnly(String3, chars1) failed", false, StringUtils.containsOnly(str3, chars1));        assertEquals("containsOnly(String3, chars2) failed", false, StringUtils.containsOnly(str3, chars2));        assertEquals("containsOnly(String3, chars3) success", true, StringUtils.containsOnly(str3, chars3));    }    public void testContainsNoneString() {        String str1 = "a";        String str2 = "b";        String str3 = "ab.";        String chars1= "b";        String chars2= ".";        String chars3= "cd";        String emptyChars = "";        assertEquals("containsNone(null, null) failed", true, StringUtils.containsNone(null, (String) null));        assertEquals("containsNone(empty-string, null) failed", true, StringUtils.containsNone("", (String) null));        assertEquals("containsNone(null, empty-string) failed", true, StringUtils.containsNone(null, emptyChars));        assertEquals("containsNone(str1, empty-char-array) failed", true, StringUtils.containsNone(str1, emptyChars));        assertEquals("containsNone(empty-string, empty-char-array) failed", true, StringUtils.containsNone("", emptyChars));        assertEquals("containsNone(empty-string, chars1) failed", true, StringUtils.containsNone("", chars1));        assertEquals("containsNone(str1, chars1)", true, StringUtils.containsNone(str1, chars1));        assertEquals("containsNone(str1, chars2)", true, StringUtils.containsNone(str1, chars2));        assertEquals("containsNone(str1, chars3)", true, StringUtils.containsNone(str1, chars3));        assertEquals("containsNone(str2, chars1)", false, StringUtils.containsNone(str2, chars1));        assertEquals("containsNone(str2, chars2)", true, StringUtils.containsNone(str2, chars2));        assertEquals("containsNone(str2, chars3)", true, StringUtils.containsNone(str2, chars3));        assertEquals("containsNone(str3, chars1)", false, StringUtils.containsNone(str3, chars1));        assertEquals("containsNone(str3, chars2)", false, StringUtils.containsNone(str3, chars2));        assertEquals("containsNone(str3, chars3)", true, StringUtils.containsNone(str3, chars3));    }    public void testContainsNoneCharArray() {        String str1 = "a";        String str2 = "b";        String str3 = "ab.";        char[] chars1= {'b'};        char[] chars2= {'.'};        char[] chars3= {'c', 'd'};        char[] emptyChars = new char[0];        assertEquals("containsNone(null, null) failed", true, StringUtils.containsNone(null, (char[]) null));        assertEquals("containsNone(empty-string, null) failed", true, StringUtils.containsNone("", (char[]) null));        assertEquals("containsNone(null, empty-string) failed", true, StringUtils.containsNone(null, emptyChars));        assertEquals("containsNone(str1, empty-char-array) failed", true, StringUtils.containsNone(str1, emptyChars));        assertEquals("containsNone(empty-string, empty-char-array) failed", true, StringUtils.containsNone("", emptyChars));        assertEquals("containsNone(empty-string, chars1) failed", true, StringUtils.containsNone("", chars1));        assertEquals("containsNone(str1, chars1)", true, StringUtils.containsNone(str1, chars1));        assertEquals("containsNone(str1, chars2)", true, StringUtils.containsNone(str1, chars2));        assertEquals("containsNone(str1, chars3)", true, StringUtils.containsNone(str1, chars3));        assertEquals("containsNone(str2, chars1)", false, StringUtils.containsNone(str2, chars1));        assertEquals("containsNone(str2, chars2)", true, StringUtils.containsNone(str2, chars2));        assertEquals("containsNone(str2, chars3)", true, StringUtils.containsNone(str2, chars3));        assertEquals("containsNone(str3, chars1)", false, StringUtils.containsNone(str3, chars1));        assertEquals("containsNone(str3, chars2)", false, StringUtils.containsNone(str3, chars2));        assertEquals("containsNone(str3, chars3)", true, StringUtils.containsNone(str3, chars3));    }    public void testIndexOfAnyBut() {        String str1 = "a";        String str2 = "b";        String str3 = "ab";        String chars1= "b";        String chars2= "a";        String chars3= "ab";        String emptyChars = "";        assertEquals("indexOfAnyBut(null, null)", -1, StringUtils.indexOfAnyBut(null, (String) null));        assertEquals("indexOfAnyBut(empty-string, null)", -1, StringUtils.indexOfAnyBut("", (String) null));        assertEquals("indexOfAnyBut(null, empty-string)", -1, StringUtils.indexOfAnyBut(null, emptyChars));        assertEquals("indexOfAnyBut(str1, empty-char-array)", 0, StringUtils.indexOfAnyBut(str1, emptyChars));        assertEquals("indexOfAnyBut(empty-string, empty-char-array)", -1, StringUtils.indexOfAnyBut("", emptyChars));        assertEquals("indexOfAnyBut(empty-string, chars1)", -1, StringUtils.indexOfAnyBut("", chars1));        assertEquals("indexOfAnyBut(str1, chars1)", 0, StringUtils.indexOfAnyBut(str1, chars1));        assertEquals("indexOfAnyBut(str1, chars2)", -1, StringUtils.indexOfAnyBut(str1, chars2));        assertEquals("indexOfAnyBut(str1, chars3)", -1, StringUtils.indexOfAnyBut(str1, chars3));        assertEquals("indexOfAnyBut(str2, chars1)", -1, StringUtils.indexOfAnyBut(str2, chars1));        assertEquals("indexOfAnyBut(str2, chars2)", 0, StringUtils.indexOfAnyBut(str2, chars2));        assertEquals("indexOfAnyBut(str2, chars3)", -1, StringUtils.indexOfAnyBut(str2, chars3));        assertEquals("indexOfAnyBut(String3, chars1)", 0, StringUtils.indexOfAnyBut(str3, chars1));        assertEquals("indexOfAnyBut(String3, chars2)", 1, StringUtils.indexOfAnyBut(str3, chars2));        assertEquals("indexOfAnyBut(String3, chars3)", -1, StringUtils.indexOfAnyBut(str3, chars3));    }    public void testAbbreviate()    {        assertEquals("abbreviate(String,int) failed",     "short", StringUtils.abbreviate("short", 10));        assertEquals("abbreviate(String,int) failed",     "Now is ...", StringUtils.abbreviate("Now is the time for all good men to come to the aid of their party.", 10));        String raspberry = "raspberry peach";        assertEquals("abbreviate(String,int) failed (one past limit)",     "raspberry p...", StringUtils.abbreviate(raspberry, 14));        assertEquals("abbreviate(String,int) (at limit)",     "raspberry peach", StringUtils.abbreviate("raspberry peach", 15));        assertEquals("abbreviate(String,int) (one below limit)",     "raspberry peach", StringUtils.abbreviate("raspberry peach", 16));        assertEquals("abbreviate(String,int,int) failed",                "raspberry peach", StringUtils.abbreviate(raspberry, 11, 15));        assertAbbreviateWithOffset("abcdefg...", -1, 10);        assertAbbreviateWithOffset("abcdefg...", 0, 10);        assertAbbreviateWithOffset("abcdefg...", 1, 10);        assertAbbreviateWithOffset("abcdefg...", 2, 10);        assertAbbreviateWithOffset("abcdefg...", 3, 10);        assertAbbreviateWithOffset("abcdefg...", 4, 10);        assertAbbreviateWithOffset("...fghi...", 5, 10);        assertAbbreviateWithOffset("...ghij...", 6, 10);        assertAbbreviateWithOffset("...hijk...", 7, 10);        assertAbbreviateWithOffset("...ijklmno", 8, 10);        assertAbbreviateWithOffset("...ijklmno", 9, 10);        assertAbbreviateWithOffset("...ijklmno", 10, 10);        assertAbbreviateWithOffset("...ijklmno", 10, 10);        assertAbbreviateWithOffset("...ijklmno", 11, 10);        assertAbbreviateWithOffset("...ijklmno", 12, 10);        assertAbbreviateWithOffset("...ijklmno", 13, 10);        assertAbbreviateWithOffset("...ijklmno", 14, 10);        assertAbbreviateWithOffset("...ijklmno", 15, 10);        assertAbbreviateWithOffset("...ijklmno", 16, 10);        assertAbbreviateWithOffset("...ijklmno", Integer.MAX_VALUE, 10);    }    private void assertAbbreviateWithOffset(String expected, int offset, int maxWidth)    {        String abcdefghijklmno = "abcdefghijklmno";        String message = "abbreviate(String,int,int) failed";        String actual = StringUtils.abbreviate(abcdefghijklmno, offset, maxWidth);        if (offset >= 0 && offset < abcdefghijklmno.length()) {            assertTrue(message + " -- should contain offset character",                    actual.indexOf((char)('a'+offset)) != -1);        }        assertTrue(message + " -- should not be greater than maxWidth",                actual.length() <= maxWidth);        assertEquals(message, expected, actual);    }    public void testDifference()    {        assertEquals("robot", StringUtils.difference("i am a machine", "i am a robot"));        assertEquals("", StringUtils.difference("foo", "foo"));        assertEquals("you are a robot", StringUtils.difference("i am a robot", "you are a robot"));    }    public void testDifferenceAt()    {        assertEquals(7, StringUtils.differenceAt("i am a machine", "i am a robot"));        assertEquals(-1, StringUtils.differenceAt("foo", "foo"));        assertEquals(0, StringUtils.differenceAt("i am a robot", "you are a robot"));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;public class EntitiesPerformanceTest extends TestCase {    private int COUNT = 10000;    private int STRING_LENGTH = 1000;    private static String stringWithUnicode;    private static String stringWithEntities;    private static Entities treeEntities;    private static Entities hashEntities;    private static Entities arrayEntities;    private static Entities binaryEntities;    public EntitiesPerformanceTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(EntitiesPerformanceTest.class);        return suite;    }    public void setUp() {        if (stringWithUnicode == null) {            StringBuffer buf = new StringBuffer(STRING_LENGTH);            for (int i = 0; i < STRING_LENGTH/5; ++i) {                buf.append("xxxx");                char ch = html40value(i);                buf.append(ch);            }            stringWithUnicode = buf.toString();            stringWithEntities = Entities.HTML40.unescape(stringWithUnicode);        }    }    private char html40value(int i) {        String entityValue = Entities.html40[i % Entities.html40.length][1];        char ch = (char) Integer.parseInt(entityValue);        return ch;    }    public void testBuildHash() throws Exception {        for (int i = 0; i < COUNT; ++i) {            hashEntities = new Entities();            hashEntities.map = new Entities.HashIntMap();            Entities.fillWithHtml40Entities(hashEntities);        }    }    public void testBuildTree() throws Exception {        for (int i = 0; i < COUNT; ++i) {            treeEntities = new Entities();            treeEntities.map = new Entities.TreeIntMap();            Entities.fillWithHtml40Entities(treeEntities);        }    }    public void testBuildArray() throws Exception {        for (int i = 0; i < COUNT; ++i) {            arrayEntities = new Entities();            arrayEntities.map = new Entities.ArrayIntMap();            Entities.fillWithHtml40Entities(arrayEntities);        }    }    public void testBuildBinary() throws Exception {        for (int i = 0; i < COUNT; ++i) {            binaryEntities = new Entities();            binaryEntities.map = new Entities.BinaryIntMap();            Entities.fillWithHtml40Entities(binaryEntities);        }    }    public void testLookupHash() throws Exception {        lookup(hashEntities);    }    public void testLookupTree() throws Exception {        lookup(treeEntities);    }    public void testLookupArray() throws Exception {        lookup(arrayEntities);    }    public void testLookupBinary() throws Exception {        lookup(binaryEntities);    }    public void testEscapeHash() throws Exception {        escapeIt(hashEntities);    }    public void testEscapeTree() throws Exception {        escapeIt(treeEntities);    }    public void testEscapeArray() throws Exception {        escapeIt(arrayEntities);    }    public void testEscapeBinary() throws Exception {        escapeIt(binaryEntities);    }    public void testUnescapeHash() throws Exception {        unescapeIt(hashEntities);    }    public void testUnescapeTree() throws Exception {        unescapeIt(treeEntities);    }    public void testUnescapeArray() throws Exception {        unescapeIt(arrayEntities);    }    public void testUnescapeBinary() throws Exception {        unescapeIt(binaryEntities);    }    private void lookup(Entities entities) {        for (int i = 0; i < COUNT*1000; ++i) {            entities.entityName(html40value(i));        }    }    private void escapeIt(Entities entities) {        for (int i = 0; i < COUNT; ++i) {            String escaped  = entities.escape(stringWithUnicode);            assertEquals("xxxx&fnof;", escaped.substring(0,10));        }    }    private void unescapeIt(Entities entities) {        for (int i = 0; i < COUNT; ++i) {            String unescaped  = entities.unescape(stringWithEntities);            assertEquals("xxxx\u0192", unescaped.substring(0,5));        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Trim/Empty methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsTrimEmptyTest.java,v 1.7 2003/03/24 00:47:02 scolebourne Exp $ */public class StringUtilsTrimEmptyTest extends TestCase {    private static final String FOO = "foo";    public StringUtilsTrimEmptyTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsTrimEmptyTest.class);    suite.setName("StringUtilsTrimEmpty Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testClean() {        assertEquals(FOO, StringUtils.clean(FOO + "  "));        assertEquals(FOO, StringUtils.clean(" " + FOO + "  "));        assertEquals(FOO, StringUtils.clean(" " + FOO));        assertEquals(FOO, StringUtils.clean(FOO + ""));        assertEquals("", StringUtils.clean(" \t\r\n\b "));        assertEquals("", StringUtils.clean(""));        assertEquals("", StringUtils.clean(null));    }    public void testTrim() {        assertEquals(FOO, StringUtils.trim(FOO + "  "));        assertEquals(FOO, StringUtils.trim(" " + FOO + "  "));        assertEquals(FOO, StringUtils.trim(" " + FOO));        assertEquals(FOO, StringUtils.trim(FOO + ""));        assertEquals("", StringUtils.trim(" \t\r\n\b "));        assertEquals("", StringUtils.trim(""));        assertEquals(null, StringUtils.trim(null));    }    public void testTrimToNull() {        assertEquals(FOO, StringUtils.trimToNull(FOO + "  "));        assertEquals(FOO, StringUtils.trimToNull(" " + FOO + "  "));        assertEquals(FOO, StringUtils.trimToNull(" " + FOO));        assertEquals(FOO, StringUtils.trimToNull(FOO + ""));        assertEquals(null, StringUtils.trimToNull(" \t\r\n\b "));        assertEquals(null, StringUtils.trimToNull(""));        assertEquals(null, StringUtils.trimToNull(null));    }    public void testTrimToEmpty() {        assertEquals(FOO, StringUtils.trimToEmpty(FOO + "  "));        assertEquals(FOO, StringUtils.trimToEmpty(" " + FOO + "  "));        assertEquals(FOO, StringUtils.trimToEmpty(" " + FOO));        assertEquals(FOO, StringUtils.trimToEmpty(FOO + ""));        assertEquals("", StringUtils.trimToEmpty(" \t\r\n\b "));        assertEquals("", StringUtils.trimToEmpty(""));        assertEquals("", StringUtils.trimToEmpty(null));    }    public void testIsNotEmpty() {        assertEquals(true, StringUtils.isNotEmpty(FOO));        assertEquals(true, StringUtils.isNotEmpty(" "));        assertEquals(false, StringUtils.isNotEmpty(""));        assertEquals(false, StringUtils.isNotEmpty(null));    }    public void testIsEmpty() {        assertEquals(false, StringUtils.isEmpty(FOO));        assertEquals(true, StringUtils.isEmpty(" "));        assertEquals(true, StringUtils.isEmpty(""));        assertEquals(true, StringUtils.isEmpty(null));    }    public void testDeleteSpace() {        assertEquals("deleteWhitespace(String) failed",                     "", StringUtils.deleteWhitespace(""));        assertEquals("deleteWhitespace(String) failed",                     "", StringUtils.deleteWhitespace("  \u000C  \t\t\u001F\n\n \u000B  "));        // Note: u-2007 and u-000A both cause problems in the source code        // it should ignore 2007 but delete 000A        assertEquals("deleteWhitespace(String) failed",                     "\u00A0\u202F", StringUtils.deleteWhitespace("  \u00A0  \t\t\n\n \u202F  "));        assertEquals("deleteWhitespace(String) failed",                     "\u00A0\u202F", StringUtils.deleteWhitespace("\u00A0\u202F"));        assertEquals("deleteWhitespace(String) failed",                     "test", StringUtils.deleteWhitespace("\u000Bt  \t\n\u0009e\rs\n\n   \tt"));        assertEquals("deleteSpaces(String) failed",                     "", StringUtils.deleteSpaces(""));        assertEquals("deleteSpaces(String) failed",                     "", StringUtils.deleteSpaces("    \t\t\n\n   "));        assertEquals("deleteSpaces(String) failed",                     "test", StringUtils.deleteSpaces("t  \t\ne\rs\n\n   \tt"));    }    public void testStrip() {        // it's important that foo2Space is fooLeftSpace and fooRightSpace         // merged together. So same number of spaces to left as fLS and same         // to right as fLS. Same applies for foo2Dots.        String foo2Space = "    "+FOO+"    ";        String foo2Dots = "......"+FOO+".........";        String fooLeftSpace = "    "+FOO;        String fooLeftDots = "......"+FOO;        String fooRightSpace = FOO+"    ";        String fooRightDots = FOO+".........";        assertEquals("", StringUtils.strip(""));        assertEquals("", StringUtils.strip("        "));        assertEquals(FOO, StringUtils.strip(foo2Space));        assertEquals(FOO, StringUtils.strip(foo2Dots, "."));        assertEquals(FOO, StringUtils.strip(fooRightSpace));        assertEquals(FOO, StringUtils.strip(fooRightDots, "."));        assertEquals(FOO, StringUtils.strip(fooLeftSpace));        assertEquals(FOO, StringUtils.strip(fooLeftDots, "."));        assertEquals("", StringUtils.stripStart("", " "));        assertEquals(fooRightSpace, StringUtils.stripStart(foo2Space, " "));        assertEquals(fooRightDots, StringUtils.stripStart(foo2Dots, "."));        assertEquals(fooRightSpace, StringUtils.stripStart(fooRightSpace, " "));        assertEquals(fooRightDots, StringUtils.stripStart(fooRightDots, "."));        assertEquals(FOO, StringUtils.stripStart(fooLeftSpace, " "));        assertEquals(FOO, StringUtils.stripStart(fooLeftDots, "."));        assertEquals("", StringUtils.stripEnd("", " "));        assertEquals(fooLeftSpace, StringUtils.stripEnd(foo2Space, " "));        assertEquals(fooLeftDots, StringUtils.stripEnd(foo2Dots, "."));        assertEquals(FOO, StringUtils.stripEnd(fooRightSpace, " "));        assertEquals(FOO, StringUtils.stripEnd(fooRightDots, "."));        assertEquals(fooLeftSpace, StringUtils.stripEnd(fooLeftSpace, " "));        assertEquals(fooLeftDots, StringUtils.stripEnd(fooLeftDots, "."));        assertEquals(FOO, StringUtils.strip(". . . . ."+FOO+". . ", " ."));        assertEquals("-."+FOO, StringUtils.strip(". . . . -."+FOO+". . ", " ."));        assertEquals(FOO, StringUtils.strip("..  .."+FOO+".. ", " ."));        assertEquals(FOO, StringUtils.strip("..  .."+FOO+".. ", "+= ."));        // test stripAll method, merely an array version of the above strip        String[] empty = new String[0];        String[] fooSpace = new String[] { foo2Space, fooLeftSpace, fooRightSpace };        String[] fooDots = new String[] { foo2Dots, fooLeftDots, fooRightDots };        String[] foo = new String[] { FOO, FOO, FOO };        assertArrayEquals(empty, StringUtils.stripAll(empty));        assertArrayEquals(foo, StringUtils.stripAll(fooSpace));        assertArrayEquals(foo, StringUtils.stripAll(fooDots, "."));    }    private void assertArrayEquals(Object[] o1, Object[] o2) {        if(o1 == null) {            assertEquals(o1,o2);            return;        }        assertEquals("Length not equal. ", o1.length, o2.length);        int sz = o1.length;        for(int i=0; i<sz; i++) {            if(o1[i] instanceof Object[]) {                // do an assert equals on type....                assertArrayEquals( (Object[]) o1[i], (Object[]) o2[i] );            } else {                assertEquals(o1[i], o2[i]);            }        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * JUnit tests. *  * @author Matthew Hawthorne * @version $Id: IllegalClassExceptionTest.java,v 1.2 2003/06/06 07:04:12 rdonkin Exp $ * @see IllegalClassException */public class IllegalClassExceptionTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        return new TestSuite(IllegalClassExceptionTest.class);    }    public IllegalClassExceptionTest(String testName) {        super(testName);    }    // testConstructor_classArgs    public void testConstructor_classArgs_allNullInput() {        new IllegalClassException(null, null);    }    public void testConstructor_classArgs_nullExpected() {        new IllegalClassException(null, String.class);    }    public void testConstructor_classArgs_nullActual() {        new IllegalClassException(String.class, null);    }    //  testConstructor_stringArg    public void testConstructor_stringArg_nullInput() {        new IllegalClassException(null);    }    // testGetMessage    public void testGetMessage_classArgs_nullInput() {        final Throwable t = new IllegalClassException(null, null);        assertEquals("Expected: null, actual: null", t.getMessage());    }    public void testGetMessage_classArgs_normalInput() {        final Throwable t =            new IllegalClassException(String.class, Integer.class);        assertEquals(            "Expected: java.lang.String, actual: java.lang.Integer",            t.getMessage());    }    public void testGetMessage_stringArg_nullInput() {        final Throwable t = new IllegalClassException(null);        assertEquals(null, t.getMessage());    }    public void testGetMessage_stringArg_validInput() {        final String message = "message";        final Throwable t = new IllegalClassException(message);        assertEquals(message, t.getMessage());    }} // IllegalClassExceptionTest
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsSubstringTest.java,v 1.3 2003/03/23 21:51:19 scolebourne Exp $ */public class StringUtilsSubstringTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String BAZ = "baz";    private static final String FOOBAR = "foobar";    private static final String SENTENCE = "foo bar baz";    public StringUtilsSubstringTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsSubstringTest.class);    suite.setName("StringUtilsSubstring Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSubstring2() {        assertEquals("", StringUtils.substring(SENTENCE, 80));        assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));        assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));    }        public void testSubstring3() {        assertEquals("", StringUtils.substring(SENTENCE, 8, 6));        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));        assertEquals("o", StringUtils.substring(SENTENCE, -9, 3));        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));        assertEquals("o", StringUtils.substring(SENTENCE, -9, -8));        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));    }        public void testLeft() {        assertSame(null, StringUtils.left(null, 0));        assertSame(null, StringUtils.left(null, 2));        assertSame("", StringUtils.left("", 0));        assertSame("", StringUtils.left("", 2));        assertEquals("", StringUtils.left(FOOBAR, 0));        assertEquals(FOO, StringUtils.left(FOOBAR, 3));        assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));    }        public void testLeftEx() {        try {            StringUtils.left(FOOBAR, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testRight() {        assertSame(null, StringUtils.right(null, 0));        assertSame(null, StringUtils.right(null, 2));        assertSame("", StringUtils.right("", 0));        assertSame("", StringUtils.right("", 2));        assertEquals("", StringUtils.right(FOOBAR, 0));        assertEquals(BAR, StringUtils.right(FOOBAR, 3));        assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));    }        public void testRightEx() {        try {            StringUtils.right(FOOBAR, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMid() {        assertSame(null, StringUtils.mid(null, 3, 0));        assertSame(null, StringUtils.mid(null, 3, 2));        assertSame("", StringUtils.mid("", 0, 0));        assertSame("", StringUtils.mid("", 0, 2));        assertEquals("", StringUtils.mid(FOOBAR, 3, 0));        assertEquals("b", StringUtils.mid(FOOBAR, 3, 1));        assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));        assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));    }        public void testMidEx1() {        try {            StringUtils.mid(FOOBAR, 0, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMidEx2() {        try {            StringUtils.mid(FOOBAR, -1, 3);        } catch (IndexOutOfBoundsException ex) {            return;        }        fail();    }    public void testMidEx3() {        try {            StringUtils.mid(FOOBAR, 7, 3);        } catch (IndexOutOfBoundsException ex) {            return;        }        fail();    }    public void testCountMatches() {        try {            assertEquals(-1,                 StringUtils.countMatches(null, null));            throw new RuntimeException("Should have thrown a NullPointerException. ");        } catch(NullPointerException npe) {        }        assertEquals(0,              StringUtils.countMatches("x", "") );        assertEquals(0,              StringUtils.countMatches("", "") );        assertEquals(3,              StringUtils.countMatches("one long someone sentence of one", "one"));        assertEquals(0,              StringUtils.countMatches("one long someone sentence of one", "two"));        assertEquals(4,              StringUtils.countMatches("oooooooooooo", "ooo"));    }    public void testGetNestedString() {        assertEquals( "", StringUtils.getNestedString("", "") );        assertEquals( "", StringUtils.getNestedString("    ", " ") );        assertEquals( "bar", StringUtils.getNestedString("\nbar\n", "\n") );        assertEquals( "", StringUtils.getNestedString("", "", "") );        assertEquals( "", StringUtils.getNestedString("    ", " ", "  ") );        assertEquals( "bar", StringUtils.getNestedString("<foo>bar</foo>", "<foo>", "</foo>") );    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests for {@link StringEscapeUtils}. * * @author of original StringUtilsTest.testEscape = ? * @author <a href="mailto:alex@purpletech.com">Alexander Day Chaffee</a> * @version $Id: EntitiesTest.java,v 1.5 2003/05/24 19:24:15 ggregory Exp $ */public class EntitiesTest extends TestCase{    public EntitiesTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(EntitiesTest.class);        suite.setName("EntitiesTest Tests");        return suite;    }    Entities entities;    public void setUp()    {        entities = new Entities();        entities.addEntity("foo", 161);        entities.addEntity("bar", 162);    }    public void testEscapeNamedEntity() throws Exception    {        assertEquals("&foo;", entities.escape("\u00A1"));        assertEquals("x&foo;", entities.escape("x\u00A1"));        assertEquals("&foo;x", entities.escape("\u00A1x"));        assertEquals("x&foo;x", entities.escape("x\u00A1x"));        assertEquals("&foo;&bar;", entities.escape("\u00A1\u00A2"));    }    public void testUnescapeNamedEntity() throws Exception    {        assertEquals("\u00A1", entities.unescape("&foo;"));        assertEquals("x\u00A1", entities.unescape("x&foo;"));        assertEquals("\u00A1x", entities.unescape("&foo;x"));        assertEquals("x\u00A1x", entities.unescape("x&foo;x"));        assertEquals("\u00A1\u00A2", entities.unescape("&foo;&bar;"));    }    public void testUnescapeUnknownEntity() throws Exception    {        assertEquals("&zzzz;", entities.unescape("&zzzz;"));    }    public void testAddEntitiesArray() throws Exception    {        String[][] array = {{"foo", "100"}, {"bar", "101"}};        Entities e = new Entities();        e.addEntities(array);        assertEquals("foo", e.entityName(100));        assertEquals("bar", e.entityName(101));        assertEquals(100, e.entityValue("foo"));        assertEquals(101, e.entityValue("bar"));    }    public void testEntitiesXmlObject() throws Exception    {        assertEquals("gt", Entities.XML.entityName('>'));        assertEquals((int) '>', Entities.XML.entityValue("gt"));        assertEquals(-1, Entities.XML.entityValue("xyzzy"));    }    public void testArrayIntMap() throws Exception    {        Entities.ArrayIntMap map = new Entities.ArrayIntMap(2);        checkSomeIntMap(map);    }    public void testTreeIntMap() throws Exception    {        Entities.IntMap map = new Entities.TreeIntMap();        checkSomeIntMap(map);    }    public void testHashIntMap() throws Exception    {        Entities.IntMap map = new Entities.HashIntMap();        checkSomeIntMap(map);    }    public void testBinaryIntMap() throws Exception    {        Entities.BinaryIntMap map = new Entities.BinaryIntMap(2);        checkSomeIntMap(map);    }    private void checkSomeIntMap(Entities.IntMap map) {        map.add("foo", 1);        assertEquals(1, map.value("foo"));        assertEquals("foo", map.name(1));        map.add("bar", 2);        map.add("baz", 3);        assertEquals(3, map.value("baz"));        assertEquals("baz", map.name(3));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link NumberRange} class. * * @author <a href="mailto:chrise@esha.com">Christopher Elkins</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Revision: 1.4 $ $Date: 2003/03/23 21:49:13 $ */public final class NumberRangeTest extends TestCase {    private NumberRange tenToTwenty;    private Number five;    private Number ten;    private Number fifteen;    private Number twenty;    private Number twentyFive;    public NumberRangeTest(String name) {        super(name);    }    public void setUp() {        five       = new Integer(5);        ten        = new Integer(10);        fifteen    = new Integer(15);        twenty     = new Integer(20);        twentyFive = new Integer(25);        tenToTwenty = new NumberRange(ten, twenty);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberRangeTest.class);        suite.setName("NumberRange Tests");        return suite;    }    public void testMaxMin() {        boolean expected = true;        boolean result = tenToTwenty.getMaximum().equals(twenty);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.getMinimum().equals(ten);        assertEquals(expected, result);    }    public void testEquals() {        boolean expected = false;        boolean result = tenToTwenty.equals(new NumberRange(five, ten));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.equals(new NumberRange(ten, twenty));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.equals(new NumberRange(ten, fifteen));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.equals(new NumberRange(fifteen, twenty));        assertEquals(expected, result);    }    public void testIncludesNumber() {        boolean expected = false;        boolean result = tenToTwenty.includesNumber(five);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(ten);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(fifteen);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(twenty);        assertEquals(expected, result);        expected = false;        result = tenToTwenty.includesNumber(twentyFive);        assertEquals(expected, result);    }    public void testIncludesRange() {        boolean expected = false;        boolean result = tenToTwenty.includesRange(new NumberRange(five, ten));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.includesRange(new NumberRange(five, fifteen));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(ten, fifteen));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(ten, twenty));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(fifteen, twenty));        assertEquals(expected, result);        expected = false;        result =             tenToTwenty.includesRange(new NumberRange(fifteen, twentyFive));        assertEquals(expected, result);        expected = false;        result =             tenToTwenty.includesRange(new NumberRange(twenty, twentyFive));        assertEquals(expected, result);    }public void testConstructorNullParameters(){try{NumberRange nr = new NumberRange(null);fail("NumberRange(null) did not throw an exception.");}catch (Exception e){assertTrue("NumberRange(null)",e instanceof NullPointerException);}try{NumberRange nr = new NumberRange(five, null);fail("NumberRange(five, null) did not throw an exception.");}catch (Exception e){assertTrue("NumberRange(five, null)",e instanceof NullPointerException);}try{NumberRange nr = new NumberRange(null, five);fail("NumberRange(null, five) did not throw an exception.");}catch (Exception e){assertTrue("NumberRange(null, five)",e instanceof NullPointerException);}}    public void testToString() {        String expected = "10-20";        String result = tenToTwenty.toString();        assertEquals(expected, result);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.ObjectOutputStream;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.SerializationUtils}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: SerializationUtilsTest.java,v 1.2 2003/03/23 21:50:58 scolebourne Exp $ */public class SerializationUtilsTest extends TestCase {    private String iString;    private Integer iInteger;    private HashMap iMap;    public SerializationUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(SerializationUtilsTest.class);    suite.setName("SerializationUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        iString = "foo";        iInteger = new Integer(7);        iMap = new HashMap();        iMap.put("FOO", iString);        iMap.put("BAR", iInteger);    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSerializeStream() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        SerializationUtils.serialize(iMap, streamTest);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        byte[] testBytes = streamTest.toByteArray();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeStreamUnserializable() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            iMap.put(new Object(), new Object());            SerializationUtils.serialize(iMap, streamTest);        } catch (SerializationException ex) {            return;        }        fail();    }    public void testSerializeStreamNullObj() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        SerializationUtils.serialize(null, streamTest);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        byte[] testBytes = streamTest.toByteArray();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeStreamObjNull() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            SerializationUtils.serialize(iMap, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testSerializeStreamNullNull() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            SerializationUtils.serialize(null, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testDeserializeStream() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());        Object test = SerializationUtils.deserialize(inTest);        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testDeserializeStreamOfNull() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());        Object test = SerializationUtils.deserialize(inTest);        assertNull(test);    }    public void testDeserializeStreamNull() throws Exception {        try {            SerializationUtils.deserialize((InputStream) null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testDeserializeStreamBadStream() throws Exception {        try {            SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));        } catch (SerializationException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testSerializeBytes() throws Exception {        byte[] testBytes = SerializationUtils.serialize(iMap);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeBytesUnserializable() throws Exception {        try {            iMap.put(new Object(), new Object());            SerializationUtils.serialize(iMap);        } catch (SerializationException ex) {            return;        }        fail();    }    public void testSerializeBytesNull() throws Exception {        byte[] testBytes = SerializationUtils.serialize(null);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    //-----------------------------------------------------------------------    public void testDeserializeBytes() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        Object test = SerializationUtils.deserialize(streamReal.toByteArray());        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testDeserializeBytesOfNull() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        Object test = SerializationUtils.deserialize(streamReal.toByteArray());        assertNull(test);    }    public void testDeserializeBytesNull() throws Exception {        try {            SerializationUtils.deserialize((byte[]) null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testDeserializeBytesBadStream() throws Exception {        try {            SerializationUtils.deserialize(new byte[0]);        } catch (SerializationException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testClone() throws Exception {        Object test = SerializationUtils.clone(iMap);        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testCloneNull() throws Exception {        Object test = SerializationUtils.clone(null);        assertNull(test);    }    public void testCloneUnserializable() throws Exception {        try {            iMap.put(new Object(), new Object());            SerializationUtils.clone(iMap);        } catch (SerializationException ex) {            return;        }        fail();    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * JUnit tests. *  * @author Matthew Hawthorne * @version $Id: NullArgumentExceptionTest.java,v 1.1 2003/05/15 04:05:11 bayard Exp $ * @see NullArgumentException */public class NullArgumentExceptionTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        return new TestSuite(NullArgumentExceptionTest.class);    }    public NullArgumentExceptionTest(String testName) {        super(testName);    }    // testConstructor    public void testConstructor_nullInput() {        new NullArgumentException(null);    }    // testGetMessage    public void testGetMessage_nullConstructorInput() {        final Throwable t = new NullArgumentException(null);        assertEquals("null cannot be null.", t.getMessage());    }    public void testGetMessage_validConstructorInput() {        final String argName = "name";        final Throwable t = new NullArgumentException(argName);        assertEquals(argName + " cannot be null.", t.getMessage());    }} // NullArgumentExceptionTest
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Unit tests for the wrap methods of WordWrapUtils. *  * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: WordWrapUtilsTest.java,v 1.1 2003/04/15 14:28:41 bayard Exp $ */public class WordWrapUtilsTest extends TestCase {    public WordWrapUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(WordWrapUtilsTest.class);        suite.setName("WordWrapperTests");        return suite;    }    /**     * Wrap text. This is the most general use.     */    public void testWrapText1() {        String input =                "Here is one line of text that is going to be wrapped after 20 columns.";        String expected =                "Here is one line of\ntext that is going\nto be wrapped after\n20 columns.";        assertEquals("Text didn't wrap correctly, ", expected, WordWrapUtils.wrapText(input, "\n", 20));    }    /**     * Wrap text with a tab character in the middle of a string.     */    public void testWrapText2() {        String input =                "Here is\tone line of text that is going to be wrapped after 20 columns.";        String expected =                "Here is\tone line of\ntext that is going\nto be wrapped after\n20 columns.";        assertEquals("Text with tab didn't wrap correctly, ", expected, WordWrapUtils.wrapText(input, "\n", 20));    }    /**     * Wrap text with a tab character located at the wrapping column index.     */    public void testWrapText3() {        String input =                "Here is one line of\ttext that is going to be wrapped after 20 columns.";        String expected =                "Here is one line\nof\ttext that is\ngoing to be wrapped\nafter 20 columns.";        assertEquals("Text with tab at wrapping index didn't wrap correctly, ", expected, WordWrapUtils.wrapText(input, "\n", 20));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.SystemUtils}. *  * Only limited testing can be performed. * * @author Stephen Colebourne * @version $Id: SystemUtilsTest.java,v 1.2 2003/05/24 14:34:14 scolebourne Exp $ */public class SystemUtilsTest extends TestCase {    public SystemUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());//        SystemUtils s = new SystemUtils();//        System.out.println(s.IS_OS_WINDOWS);//        System.out.println(s.IS_OS_WINDOWS_95);//        System.out.println(s.IS_OS_WINDOWS_98);//        java.util.Properties p = System.getProperties();//        java.util.Enumeration keys = p.keys();//        java.util.List list = new java.util.ArrayList();//        while( keys.hasMoreElements() ) {//            list.add(keys.nextElement());//        }//        java.util.Collections.sort(list);//        for (java.util.Iterator it = list.iterator(); it.hasNext();) {//            String key = (String) it.next();//            System.out.println(key + " " + p.getProperty(key));//        }        }    public static Test suite() {        TestSuite suite = new TestSuite(SystemUtilsTest.class);        suite.setName("SystemUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    // COPIED FROM SystemUtils    //-----------------------------------------------------------------------    private String JAVA_VERSION;    private String OS_NAME;    private String OS_VERSION;        /**     * Decides if the java version matches.     *      * @param versionPrefix  the prefix for the java version     * @return true if matches, or false if not or can't determine     */    private boolean getJavaVersionMatches(String versionPrefix) {        if (JAVA_VERSION == null) {            return false;        }        return JAVA_VERSION.startsWith(versionPrefix);    }        /**     * <p>Get the Java version number as a <code>float</code>.</p>     *     * <p>Example output:</p>     * <ul>     *  <li><code>1.2f</code> for JDK 1.2     *  <li><code>1.31f</code> for JDK 1.3.1     * </ul>     *      * <p>Patch releases are not reported.     * Zero is returned if JAVA_VERSION is <code>null</code>.</p>     *      * @return the version, for example 1.31f for JDK 1.3.1     */    private float getJavaVersionAsFloat() {        if (JAVA_VERSION == null) {            return 0f;        }        String str = JAVA_VERSION.substring(0, 3);        if (JAVA_VERSION.length() >= 5) {            str = str + JAVA_VERSION.substring(4, 5);        }        return Float.parseFloat(str);    }        /**     * <p>Get the Java version number as an <code>int</code>.</p>     *     * <p>Example output:</p>     * <ul>     *  <li><code>120</code> for JDK 1.2     *  <li><code>131</code> for JDK 1.3.1     * </ul>     *      * <p>Patch releases are not reported.     * Zero is returned if JAVA_VERSION is <code>null</code>.</p>     *      * @return the version, for example 131 for JDK 1.3.1     */    private int getJavaVersionAsInt() {        if (JAVA_VERSION == null) {            return 0;        }        String str = JAVA_VERSION.substring(0, 1);        str = str + JAVA_VERSION.substring(2, 3);        if (JAVA_VERSION.length() >= 5) {            str = str + JAVA_VERSION.substring(4, 5);        } else {            str = str + "0";        }        return Integer.parseInt(str);    }    /**     * Decides if the operating system matches.     *      * @param osNamePrefix  the prefix for the os name     * @return true if matches, or false if not or can't determine     */    private boolean getOSMatches(String osNamePrefix) {        if (OS_NAME == null) {            return false;        }        return OS_NAME.startsWith(osNamePrefix);    }        /**     * Decides if the operating system matches.     *      * @param osNamePrefix  the prefix for the os name     * @param osVersionPrefix  the prefix for the version     * @return true if matches, or false if not or can't determine     */    private boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {        if (OS_NAME == null || OS_VERSION == null) {            return false;        }        return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);    }        //-----------------------------------------------------------------------    public void testJavaVersionMatches() {        JAVA_VERSION = null;        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.1";        assertEquals(true, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.2";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(true, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.3.0";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(true, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.3.1";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(true, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.4.0";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(true, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.4.1";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(true, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.5.0";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(true, getJavaVersionMatches("1.5"));        JAVA_VERSION = "1.6.0";        assertEquals(false, getJavaVersionMatches("1.1"));        assertEquals(false, getJavaVersionMatches("1.2"));        assertEquals(false, getJavaVersionMatches("1.3"));        assertEquals(false, getJavaVersionMatches("1.4"));        assertEquals(false, getJavaVersionMatches("1.5"));    }       public void testJavaVersionAsFloat() {        JAVA_VERSION = null;        assertEquals(0f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.1";        assertEquals(1.1f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.2";        assertEquals(1.2f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.3.0";        assertEquals(1.3f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.3.1";        assertEquals(1.31f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.4.0";        assertEquals(1.4f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.4.1";        assertEquals(1.41f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.5.0";        assertEquals(1.5f, getJavaVersionAsFloat(), 0.000001f);        JAVA_VERSION = "1.6.0";        assertEquals(1.6f, getJavaVersionAsFloat(), 0.000001f);    }        public void testJavaVersionAsInt() {        JAVA_VERSION = null;        assertEquals(0, getJavaVersionAsInt());        JAVA_VERSION = "1.1";        assertEquals(110, getJavaVersionAsInt());        JAVA_VERSION = "1.2";        assertEquals(120, getJavaVersionAsInt());        JAVA_VERSION = "1.3.0";        assertEquals(130, getJavaVersionAsInt());        JAVA_VERSION = "1.3.1";        assertEquals(131, getJavaVersionAsInt());        JAVA_VERSION = "1.4.0";        assertEquals(140, getJavaVersionAsInt());        JAVA_VERSION = "1.4.1";        assertEquals(141, getJavaVersionAsInt());        JAVA_VERSION = "1.5.0";        assertEquals(150, getJavaVersionAsInt());        JAVA_VERSION = "1.6.0";        assertEquals(160, getJavaVersionAsInt());    }        public void testJavaVersionAtLeastFloat() {        float version = SystemUtils.JAVA_VERSION_FLOAT;        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));        version -= 0.1f;        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));        version += 0.2f;        assertEquals(false, SystemUtils.isJavaVersionAtLeast(version));    }        public void testJavaVersionAtLeastInt() {        int version = SystemUtils.JAVA_VERSION_INT;        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));        version -= 10;        assertEquals(true, SystemUtils.isJavaVersionAtLeast(version));        version += 20;        assertEquals(false, SystemUtils.isJavaVersionAtLeast(version));    }        public void testOSMatches() {        OS_NAME = null;        assertEquals(false, getOSMatches("Windows"));        OS_NAME = "Windows 95";        assertEquals(true, getOSMatches("Windows"));        OS_NAME = "Windows NT";        assertEquals(true, getOSMatches("Windows"));        OS_NAME = "OS/2";        assertEquals(false, getOSMatches("Windows"));    }        public void testOSMatches2() {        OS_NAME = null;        OS_VERSION = null;        assertEquals(false, getOSMatches("Windows 9", "4.1"));        OS_NAME = "Windows 95";        OS_VERSION = "4.0";        assertEquals(false, getOSMatches("Windows 9", "4.1"));        OS_NAME = "Windows 95";        OS_VERSION = "4.1";        assertEquals(true, getOSMatches("Windows 9", "4.1"));        OS_NAME = "Windows 98";        OS_VERSION = "4.1";        assertEquals(true, getOSMatches("Windows 9", "4.1"));        OS_NAME = "Windows NT";        OS_VERSION = "4.0";        assertEquals(false, getOSMatches("Windows 9", "4.1"));        OS_NAME = "OS/2";        OS_VERSION = "4.0";        assertEquals(false, getOSMatches("Windows 9", "4.1"));    }    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * JUnit tests. *  * @author Matthew Hawthorne * @version $Id: IncompleteArgumentExceptionTest.java,v 1.1 2003/05/15 04:05:11 bayard Exp $ * @see IncompleteArgumentException */public class IncompleteArgumentExceptionTest extends TestCase {    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        return new TestSuite(IncompleteArgumentExceptionTest.class);    }    public IncompleteArgumentExceptionTest(String testName) {        super(testName);    }    // testConstructor    public void test1arg_nullInput() {        final Throwable t = new IncompleteArgumentException(null);        assertEquals("null is incomplete.", t.getMessage());    }    public void test1arg_validInput() {        final String name = "argument";        final Throwable t = new IncompleteArgumentException(name);        assertEquals(name + " is incomplete.", t.getMessage());    }    public void test2arg_allNullInput() {        final Throwable t = new IncompleteArgumentException(null, null);        assertEquals(            "null is missing the following items: null",            t.getMessage());    }    public void test2arg_nullString() {        final Throwable t =            new IncompleteArgumentException(                null,                new String[] { "one", "two" });        assertEquals(            "null is missing the following items: [one, two]",            t.getMessage());    }    public void test2arg_nullArray() {        final String name = "one";        final Throwable t = new IncompleteArgumentException(name, null);        assertEquals(            name + " is missing the following items: null",            t.getMessage());    }    public void test2arg_validInput() {        final String name = "input";        final Throwable t =            new IncompleteArgumentException(                name,                new String[] { "one", "two" });        assertEquals(            name + " is missing the following items: [one, two]",            t.getMessage());    }} // IncompleteArgumentExceptionTest
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import java.math.BigDecimal;import java.math.BigInteger;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Unit tests {@link org.apache.commons.lang.NumberUtils}. * * @author <a href="mailto:rand_mcneely@yahoo.com">Rand McNeely</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @author Eric Pugh * @author Phil Steitz * @author Stephen Colebourne * @version $Id: NumberUtilsTest.java,v 1.7 2003/06/08 14:14:01 scolebourne Exp $ */public class NumberUtilsTest extends TestCase {    public NumberUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberUtilsTest.class);        suite.setName("NumberUtils Tests");        return suite;    }    //---------------------------------------------------------------------    /**     * Test for int stringToInt(String)     */    public void testStringToIntString() {        assertTrue("stringToInt(String) 1 failed", NumberUtils.stringToInt("12345") == 12345);        assertTrue("stringToInt(String) 2 failed", NumberUtils.stringToInt("abc") == 0);    }    /**     * Test for int stringToInt(String, int)     */    public void testStringToIntStringI() {        assertTrue("stringToInt(String,int) 1 failed", NumberUtils.stringToInt("12345", 5) == 12345);        assertTrue("stringToInt(String,int) 2 failed", NumberUtils.stringToInt("1234.5", 5) == 5);    }    public void testCreateNumber() {        //a lot of things can go wrong        assertEquals("createNumber(String) 1 failed", new Float("1234.5"), NumberUtils.createNumber("1234.5"));        assertEquals("createNumber(String) 2 failed", new Integer("12345"), NumberUtils.createNumber("12345"));        assertEquals("createNumber(String) 3 failed", new Double("1234.5"), NumberUtils.createNumber("1234.5D"));        assertEquals("createNumber(String) 4 failed", new Float("1234.5"), NumberUtils.createNumber("1234.5F"));        assertEquals("createNumber(String) 5 failed", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber("" + (Integer.MAX_VALUE + 1L)));        assertEquals("createNumber(String) 6 failed", new Long(12345), NumberUtils.createNumber("12345L"));        assertEquals("createNumber(String) 7 failed", new Float("-1234.5"), NumberUtils.createNumber("-1234.5"));        assertEquals("createNumber(String) 8 failed", new Integer("-12345"), NumberUtils.createNumber("-12345"));        assertTrue("createNumber(String) 9 failed", 0xFADE == NumberUtils.createNumber("0xFADE").intValue());        assertTrue("createNumber(String) 10 failed", -0xFADE == NumberUtils.createNumber("-0xFADE").intValue());        assertEquals("createNumber(String) 11 failed", new Double("1.1E200"), NumberUtils.createNumber("1.1E200"));        assertEquals("createNumber(String) 12 failed", new Float("1.1E20"), NumberUtils.createNumber("1.1E20"));        assertEquals("createNumber(String) 13 failed", new Double("-1.1E200"), NumberUtils.createNumber("-1.1E200"));        assertEquals("createNumber(String) 14 failed", new Double("1.1E-200"), NumberUtils.createNumber("1.1E-200"));        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2        if(SystemUtils.isJavaVersionAtLeast(1.3f)) {             assertEquals("createNumber(String) 15 failed", new BigDecimal("1.1E-700"), NumberUtils.createNumber("1.1E-700F"));        }        assertEquals(            "createNumber(String) 16 failed",            new Long("10" + Integer.MAX_VALUE),            NumberUtils.createNumber("10" + Integer.MAX_VALUE + "L"));        assertEquals(            "createNumber(String) 17 failed",            new Long("10" + Integer.MAX_VALUE),            NumberUtils.createNumber("10" + Integer.MAX_VALUE));        assertEquals(            "createNumber(String) 18 failed",            new BigInteger("10" + Long.MAX_VALUE),            NumberUtils.createNumber("10" + Long.MAX_VALUE));    }    public void testCreateFloat() {        assertEquals("createFloat(String) failed", new Float("1234.5"), NumberUtils.createFloat("1234.5"));    }    public void testCreateDouble() {        assertEquals("createDouble(String) failed", new Double("1234.5"), NumberUtils.createDouble("1234.5"));    }    public void testCreateInteger() {        assertEquals("createInteger(String) failed", new Integer("12345"), NumberUtils.createInteger("12345"));    }    public void testCreateLong() {        assertEquals("createInteger(String) failed", new Long("12345"), NumberUtils.createLong("12345"));    }    public void testCreateBigInteger() {        assertEquals("createBigInteger(String) failed", new BigInteger("12345"), NumberUtils.createBigInteger("12345"));    }    public void testCreateBigDecimal() {        assertEquals("createBigDecimal(String) failed", new BigDecimal("1234.5"), NumberUtils.createBigDecimal("1234.5"));    }    public void testMinimumLong() {        assertEquals("minimum(long,long,long) 1 failed", 12345L, NumberUtils.minimum(12345L, 12345L + 1L, 12345L + 2L));        assertEquals("minimum(long,long,long) 2 failed", 12345L, NumberUtils.minimum(12345L + 1L, 12345L, 12345 + 2L));        assertEquals("minimum(long,long,long) 3 failed", 12345L, NumberUtils.minimum(12345L + 1L, 12345L + 2L, 12345L));        assertEquals("minimum(long,long,long) 4 failed", 12345L, NumberUtils.minimum(12345L + 1L, 12345L, 12345L));        assertEquals("minimum(long,long,long) 5 failed", 12345L, NumberUtils.minimum(12345L, 12345L, 12345L));    }    public void testMinimumInt() {        assertEquals("minimum(int,int,int) 1 failed", 12345, NumberUtils.minimum(12345, 12345 + 1, 12345 + 2));        assertEquals("minimum(int,int,int) 2 failed", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345 + 2));        assertEquals("minimum(int,int,int) 3 failed", 12345, NumberUtils.minimum(12345 + 1, 12345 + 2, 12345));        assertEquals("minimum(int,int,int) 4 failed", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345));        assertEquals("minimum(int,int,int) 5 failed", 12345, NumberUtils.minimum(12345, 12345, 12345));    }    public void testMaximumLong() {        assertEquals("maximum(long,long,long) 1 failed", 12345L, NumberUtils.maximum(12345L, 12345L - 1L, 12345L - 2L));        assertEquals("maximum(long,long,long) 2 failed", 12345L, NumberUtils.maximum(12345L - 1L, 12345L, 12345L - 2L));        assertEquals("maximum(long,long,long) 3 failed", 12345L, NumberUtils.maximum(12345L - 1L, 12345L - 2L, 12345L));        assertEquals("maximum(long,long,long) 4 failed", 12345L, NumberUtils.maximum(12345L - 1L, 12345L, 12345L));        assertEquals("maximum(long,long,long) 5 failed", 12345L, NumberUtils.maximum(12345L, 12345L, 12345L));    }    public void testMaximumInt() {        assertEquals("maximum(int,int,int) 1 failed", 12345, NumberUtils.maximum(12345, 12345 - 1, 12345 - 2));        assertEquals("maximum(int,int,int) 2 failed", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345 - 2));        assertEquals("maximum(int,int,int) 3 failed", 12345, NumberUtils.maximum(12345 - 1, 12345 - 2, 12345));        assertEquals("maximum(int,int,int) 4 failed", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345));        assertEquals("maximum(int,int,int) 5 failed", 12345, NumberUtils.maximum(12345, 12345, 12345));    }    public void testCompareDouble() {        assertTrue(NumberUtils.compare(Double.NaN, Double.NaN) == 0);        assertTrue(NumberUtils.compare(Double.NaN, Double.POSITIVE_INFINITY) == +1);        assertTrue(NumberUtils.compare(Double.NaN, Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.NaN, 1.2d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, 0.0d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, -0.0d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, -1.2d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.NaN, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NaN) == -1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY) == 0);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 1.2d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 0.0d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -0.0d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -1.2d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NaN) == -1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 1.2d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 0.0d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -0.0d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -1.2d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(1.2d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(1.2d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(1.2d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(1.2d, 1.2d) == 0);        assertTrue(NumberUtils.compare(1.2d, 0.0d) == +1);        assertTrue(NumberUtils.compare(1.2d, -0.0d) == +1);        assertTrue(NumberUtils.compare(1.2d, -1.2d) == +1);        assertTrue(NumberUtils.compare(1.2d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(1.2d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(0.0d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(0.0d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(0.0d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(0.0d, 1.2d) == -1);        assertTrue(NumberUtils.compare(0.0d, 0.0d) == 0);        assertTrue(NumberUtils.compare(0.0d, -0.0d) == +1);        assertTrue(NumberUtils.compare(0.0d, -1.2d) == +1);        assertTrue(NumberUtils.compare(0.0d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(0.0d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-0.0d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(-0.0d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-0.0d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-0.0d, 1.2d) == -1);        assertTrue(NumberUtils.compare(-0.0d, 0.0d) == -1);        assertTrue(NumberUtils.compare(-0.0d, -0.0d) == 0);        assertTrue(NumberUtils.compare(-0.0d, -1.2d) == +1);        assertTrue(NumberUtils.compare(-0.0d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-0.0d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-1.2d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(-1.2d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-1.2d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-1.2d, 1.2d) == -1);        assertTrue(NumberUtils.compare(-1.2d, 0.0d) == -1);        assertTrue(NumberUtils.compare(-1.2d, -0.0d) == -1);        assertTrue(NumberUtils.compare(-1.2d, -1.2d) == 0);        assertTrue(NumberUtils.compare(-1.2d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-1.2d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NaN) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 1.2d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 0.0d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -0.0d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -1.2d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -Double.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NaN) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 1.2d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 0.0d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -0.0d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -1.2d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) == 0);    }    public void testCompareFloat() {        assertTrue(NumberUtils.compare(Float.NaN, Float.NaN) == 0);        assertTrue(NumberUtils.compare(Float.NaN, Float.POSITIVE_INFINITY) == +1);        assertTrue(NumberUtils.compare(Float.NaN, Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.NaN, 1.2f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, 0.0f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, -0.0f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, -1.2f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.NaN, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NaN) == -1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY) == 0);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 1.2f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 0.0f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -0.0f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -1.2f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NaN) == -1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 1.2f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 0.0f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -0.0f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -1.2f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(1.2f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(1.2f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(1.2f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(1.2f, 1.2f) == 0);        assertTrue(NumberUtils.compare(1.2f, 0.0f) == +1);        assertTrue(NumberUtils.compare(1.2f, -0.0f) == +1);        assertTrue(NumberUtils.compare(1.2f, -1.2f) == +1);        assertTrue(NumberUtils.compare(1.2f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(1.2f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(0.0f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(0.0f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(0.0f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(0.0f, 1.2f) == -1);        assertTrue(NumberUtils.compare(0.0f, 0.0f) == 0);        assertTrue(NumberUtils.compare(0.0f, -0.0f) == +1);        assertTrue(NumberUtils.compare(0.0f, -1.2f) == +1);        assertTrue(NumberUtils.compare(0.0f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(0.0f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-0.0f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(-0.0f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-0.0f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-0.0f, 1.2f) == -1);        assertTrue(NumberUtils.compare(-0.0f, 0.0f) == -1);        assertTrue(NumberUtils.compare(-0.0f, -0.0f) == 0);        assertTrue(NumberUtils.compare(-0.0f, -1.2f) == +1);        assertTrue(NumberUtils.compare(-0.0f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-0.0f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-1.2f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(-1.2f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-1.2f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-1.2f, 1.2f) == -1);        assertTrue(NumberUtils.compare(-1.2f, 0.0f) == -1);        assertTrue(NumberUtils.compare(-1.2f, -0.0f) == -1);        assertTrue(NumberUtils.compare(-1.2f, -1.2f) == 0);        assertTrue(NumberUtils.compare(-1.2f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-1.2f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NaN) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 1.2f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 0.0f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -0.0f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -1.2f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -Float.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NaN) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 1.2f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 0.0f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -0.0f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -1.2f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY) == 0);    }    public void testIsDigits() {        assertEquals("isDigits(null) failed", false, NumberUtils.isDigits(null));        assertEquals("isDigits('') failed", false, NumberUtils.isDigits(""));        assertEquals("isDigits(String) failed", true, NumberUtils.isDigits("12345"));        assertEquals("isDigits(String) neg 1 failed", false, NumberUtils.isDigits("1234.5"));        assertEquals("isDigits(String) neg 3 failed", false, NumberUtils.isDigits("1ab"));        assertEquals("isDigits(String) neg 4 failed", false, NumberUtils.isDigits("abc"));    }        /**     * Tests isNumber(String) and tests that createNumber(String) returns     * a valid number iff isNumber(String) returns false.     */    public void testIsNumber() {        String val = "12345";        assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val));        val = "1234.5";        assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val));        val = ".12345";        assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val));        val = "1234E5";        assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val));        val = "1234E+5";        assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val));        val = "1234E-5";        assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val));        val = "123.4E5";        assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val));        val = "-1234";        assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val));        val = "-1234.5";        assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val));        val = "-.12345";        assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val));        val = "-1234E5";        assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val));        val = "0";        assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val));        val = "-0";        assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val));        val = "01234";        assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val));        val = "-01234";        assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val));        val = "0xABC123";        assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val));        val = "0x0";        assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val));        val = "123.4E21D";        assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val));        val = "-221.23F";        assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val));        val = "22338L";        assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val));        val = null;        assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val));        val = "";        assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val));        val = "--2.3";        assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val));        val = ".12.3";        assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val));        val = "-123E";        assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val));        val = "-123E+-212";        assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val));        val = "-123E2.12";        assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val));        val = "0xGF";        assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val));        val = "0xFAE-1";        assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val));        val = ".";        assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val));        val = "-0ABC123";        assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val));        val = "123.4E-D";        assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val));        val = "123.4ED";        assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val));        val = "1234E5l";        assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val));        val = "11a";        assertTrue("isNumber(String) 15 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 15 Neg failed", !checkCreateNumber(val));         val = "1a";        assertTrue("isNumber(String) 16 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 16 Neg failed", !checkCreateNumber(val));         val = "a";        assertTrue("isNumber(String) 17 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 17 Neg failed", !checkCreateNumber(val));         val = "11g";        assertTrue("isNumber(String) 18 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 18 Neg failed", !checkCreateNumber(val));         val = "11z";        assertTrue("isNumber(String) 19 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 19 Neg failed", !checkCreateNumber(val));         val = "11def";        assertTrue("isNumber(String) 20 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 20 Neg failed", !checkCreateNumber(val));         val = "11d11";        assertTrue("isNumber(String) 21 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 21 Neg failed", !checkCreateNumber(val));     }    private boolean checkCreateNumber(String val) {        try {            Object obj = NumberUtils.createNumber(val);            if (obj == null) {                return false;            }            return true;        } catch (NumberFormatException e) {            return false;        } catch (NullPointerException e) {            return false;        }    }    public void testConstants() {        assertTrue(NumberUtils.LONG_ZERO instanceof Long);        assertTrue(NumberUtils.LONG_ONE instanceof Long);        assertTrue(NumberUtils.LONG_MINUS_ONE instanceof Long);        assertTrue(NumberUtils.INTEGER_ZERO instanceof Integer);        assertTrue(NumberUtils.INTEGER_ONE instanceof Integer);        assertTrue(NumberUtils.INTEGER_MINUS_ONE instanceof Integer);        assertTrue(NumberUtils.SHORT_ZERO instanceof Short);        assertTrue(NumberUtils.SHORT_ONE instanceof Short);        assertTrue(NumberUtils.SHORT_MINUS_ONE instanceof Short);        assertTrue(NumberUtils.BYTE_ZERO instanceof Byte);        assertTrue(NumberUtils.BYTE_ONE instanceof Byte);        assertTrue(NumberUtils.BYTE_MINUS_ONE instanceof Byte);        assertTrue(NumberUtils.DOUBLE_ZERO instanceof Double);        assertTrue(NumberUtils.DOUBLE_ONE instanceof Double);        assertTrue(NumberUtils.DOUBLE_MINUS_ONE instanceof Double);        assertTrue(NumberUtils.FLOAT_ZERO instanceof Float);        assertTrue(NumberUtils.FLOAT_ONE instanceof Float);        assertTrue(NumberUtils.FLOAT_MINUS_ONE instanceof Float);                assertTrue(NumberUtils.LONG_ZERO.longValue() == 0);        assertTrue(NumberUtils.LONG_ONE.longValue() == 1);        assertTrue(NumberUtils.LONG_MINUS_ONE.longValue() == -1);        assertTrue(NumberUtils.INTEGER_ZERO.intValue() == 0);        assertTrue(NumberUtils.INTEGER_ONE.intValue() == 1);        assertTrue(NumberUtils.INTEGER_MINUS_ONE.intValue() == -1);        assertTrue(NumberUtils.SHORT_ZERO.shortValue() == 0);        assertTrue(NumberUtils.SHORT_ONE.shortValue() == 1);        assertTrue(NumberUtils.SHORT_MINUS_ONE.shortValue() == -1);        assertTrue(NumberUtils.BYTE_ZERO.byteValue() == 0);        assertTrue(NumberUtils.BYTE_ONE.byteValue() == 1);        assertTrue(NumberUtils.BYTE_MINUS_ONE.byteValue() == -1);        assertTrue(NumberUtils.DOUBLE_ZERO.doubleValue() == 0.0d);        assertTrue(NumberUtils.DOUBLE_ONE.doubleValue() == 1.0d);        assertTrue(NumberUtils.DOUBLE_MINUS_ONE.doubleValue() == -1.0d);        assertTrue(NumberUtils.FLOAT_ZERO.floatValue() == 0.0f);        assertTrue(NumberUtils.FLOAT_ONE.floatValue() == 1.0f);        assertTrue(NumberUtils.FLOAT_MINUS_ONE.floatValue() == -1.0f);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import java.util.Random;import junit.framework.*;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.RandomStringUtils}. * * @author <a href="mailto:steven@caswell.name">Steven Caswell</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: RandomStringUtilsTest.java,v 1.6 2003/05/14 02:50:43 bayard Exp $ */public class RandomStringUtilsTest extends junit.framework.TestCase {    /**     * Construct a new instance of RandomStringUtilsTest with the specified name     */    public RandomStringUtilsTest(String name) {        super(name);    }    public static Test suite() {    TestSuite suite = new TestSuite(RandomStringUtilsTest.class);    suite.setName("RandomStringUtils Tests");        return suite;    }        /**     * Set up instance variables required by this test case.     */    public void setUp() {    }        /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }        /**     * Test the implementation     */    public void testRandomStringUtils() {        String r1 = RandomStringUtils.random(50);        assertEquals("random(50) length", 50, r1.length());        String r2 = RandomStringUtils.random(50);        assertEquals("random(50) length", 50, r2.length());        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomAscii(50);        assertEquals("randomAscii(50) length", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("char between 32 and 127", (int) r1.charAt(i) >= 32 && (int) r1.charAt(i) <= 127);        }                r2 = RandomStringUtils.randomAscii(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));        r1 = RandomStringUtils.randomAlphabetic(50);        assertEquals("randomAlphabetic(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains alphabetic", true, Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));        }        r2 = RandomStringUtils.randomAlphabetic(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomAlphanumeric(50);        assertEquals("randomAlphanumeric(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains alphanumeric", true, Character.isLetterOrDigit(r1.charAt(i)));        }        r2 = RandomStringUtils.randomAlphabetic(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomNumeric(50);        assertEquals("randomNumeric(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains numeric", true, Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));        }        r2 = RandomStringUtils.randomNumeric(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                String set = "abcdefg";        r1 = RandomStringUtils.random(50, set);        assertEquals("random(50, \"abcdefg\")", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);        }        r2 = RandomStringUtils.random(50, set);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                set = "stuvwxyz";        r1 = RandomStringUtils.random(50, set.toCharArray());        assertEquals("random(50, \"stuvwxyz\")", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);        }        r2 = RandomStringUtils.random(50, set);        assertTrue("!r1.equals(r2)", !r1.equals(r2));        long seed = System.currentTimeMillis();        r1 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));        r2 = RandomStringUtils.random(50,0,0,true,true,null,new Random(seed));        assertEquals("r1.equals(r2)", r1, r2);        r1 = RandomStringUtils.random(0);        assertEquals("random(0).equals(\"\")", "", r1);        Exception e = null;        try {            r1 = RandomStringUtils.random(-1);        } catch (Exception e2) {            e = e2;        }        assertNotNull("random(<0) throws exception", e);    }        /**      * Test homogeneity of random strings generated --     * i.e., test that characters show up with expected frequencies     * in generated strings.  Will fail randomly about 1 in 1000 times.     * Repeated failures indicate a problem.     */    public void testRandomStringUtilsHomog() {        String set = "abc";        char[] chars = set.toCharArray();        String gen = "";        int[] counts = {0,0,0};        int[] expected = {200,200,200};        for (int i = 0; i< 100; i++) {           gen = RandomStringUtils.random(6,chars);           for (int j = 0; j < 6; j++) {               switch (gen.charAt(j)) {                   case 'a': {counts[0]++; break;}                   case 'b': {counts[1]++; break;}                   case 'c': {counts[2]++; break;}                   default: {fail("generated character not in set");}               }           }        }         // Perform chi-square test with df = 3-1 = 2, testing at .001 level        assertTrue("test homogeneity -- will fail about 1 in 1000 times",            chiSquare(expected,counts) < 13.82);      }        //FIXME: add similar tests for other functions        /**     * Computes Chi-Square statistic given observed and expected counts     * @param observed array of observed frequency counts     * @param expected array of exptected frequency counts     */    private double chiSquare(int[] expected, int[] observed) {        double sumSq = 0.0d;        double dev = 0.0d;        for (int i = 0; i< observed.length; i++) {            dev = (double)(observed[i] - expected[i]);            sumSq += dev*dev/(double)expected[i];        }        return sumSq;    }                       public static void main(String args[]) {        TestRunner.run(suite());    }}