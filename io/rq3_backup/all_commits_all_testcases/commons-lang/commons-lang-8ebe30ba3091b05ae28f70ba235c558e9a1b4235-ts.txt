/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: ValuedEnumTest.java,v 1.2 2002/10/13 18:42:06 sullis Exp $ */public final class ValuedEnumTest extends TestCase {    public ValuedEnumTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(ValuedEnumTest.class);        suite.setName("ValuedEnum Tests");        return suite;    }    public void testName() {        assertEquals("Red", ValuedColorEnum.RED.getName());        assertEquals("Green", ValuedColorEnum.GREEN.getName());        assertEquals("Blue", ValuedColorEnum.BLUE.getName());    }    public void testValue() {        assertEquals(1, ValuedColorEnum.RED.getValue());        assertEquals(2, ValuedColorEnum.GREEN.getValue());        assertEquals(3, ValuedColorEnum.BLUE.getValue());    }    public void testCompareTo() {        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.BLUE) == 0);        assertTrue(ValuedColorEnum.RED.compareTo(ValuedColorEnum.BLUE) < 0);        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.RED) > 0);    }    public void testEquals() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.RED);        assertSame(ValuedColorEnum.getEnum("Red"), ValuedColorEnum.RED);    }    public void testToString() {        assertEquals("ValuedColorEnum[Red=1]", ValuedColorEnum.RED.toString());    }    public void testIterator() {        Iterator it = ValuedColorEnum.iterator();        assertSame(ValuedColorEnum.RED, it.next());        assertSame(ValuedColorEnum.GREEN, it.next());        assertSame(ValuedColorEnum.BLUE, it.next());    }    public void testList() {        List list = ValuedColorEnum.getEnumList();                assertNotNull(list);                assertEquals( list.size(),         ValuedColorEnum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(ValuedColorEnum.RED, it.next());        assertSame(ValuedColorEnum.GREEN, it.next());        assertSame(ValuedColorEnum.BLUE, it.next());    }    public void testMap() {        Map map = ValuedColorEnum.getEnumMap();                assertNotNull(map);                assertEquals( map.keySet().size(),         ValuedColorEnum.getEnumList().size());                 assertTrue(map.containsValue(ValuedColorEnum.RED));        assertTrue(map.containsValue(ValuedColorEnum.GREEN));        assertTrue(map.containsValue(ValuedColorEnum.BLUE));        assertSame(ValuedColorEnum.RED, map.get("Red"));        assertSame(ValuedColorEnum.GREEN, map.get("Green"));        assertSame(ValuedColorEnum.BLUE, map.get("Blue"));    }    public void testGet() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum("Red"));        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum("Green"));        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum("Blue"));        assertSame(null, ValuedColorEnum.getEnum("Pink"));    }    public void testGetValue() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(1));        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(2));        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(3));        assertSame(null, ValuedColorEnum.getEnum(4));    }    public void testSerialization() {        assertSame(ValuedColorEnum.RED, SerializationUtils.clone(ValuedColorEnum.RED));        assertSame(ValuedColorEnum.GREEN, SerializationUtils.clone(ValuedColorEnum.GREEN));        assertSame(ValuedColorEnum.BLUE, SerializationUtils.clone(ValuedColorEnum.BLUE));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EnumTest.java,v 1.3 2002/11/02 13:17:06 scolebourne Exp $ */public final class EnumTest extends TestCase {    public EnumTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(EnumTest.class);        suite.setName("Enum Tests");        return suite;    }    public void testName() {        assertEquals("Red", ColorEnum.RED.getName());        assertEquals("Green", ColorEnum.GREEN.getName());        assertEquals("Blue", ColorEnum.BLUE.getName());    }    public void testCompareTo() {        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);    }    public void testEquals() {        assertSame(ColorEnum.RED, ColorEnum.RED);        assertSame(ColorEnum.getEnum("Red"), ColorEnum.RED);    }    public void testToString() {        assertEquals("ColorEnum[Red]", ColorEnum.RED.toString());    }    public void testIterator() {        Iterator it = ColorEnum.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testList() {        List list = ColorEnum.getEnumList();                assertNotNull(list);                assertEquals( list.size(),        ColorEnum.getEnumMap().keySet().size());                Iterator it = list.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testMap() {        Map map = ColorEnum.getEnumMap();                assertNotNull(map);                assertEquals( map.keySet().size(),        ColorEnum.getEnumList().size());                assertTrue(map.containsValue(ColorEnum.RED));        assertTrue(map.containsValue(ColorEnum.GREEN));        assertTrue(map.containsValue(ColorEnum.BLUE));        assertSame(ColorEnum.RED, map.get("Red"));        assertSame(ColorEnum.GREEN, map.get("Green"));        assertSame(ColorEnum.BLUE, map.get("Blue"));    }    public void testGet() {        assertSame(ColorEnum.RED, ColorEnum.getEnum("Red"));        assertSame(ColorEnum.GREEN, ColorEnum.getEnum("Green"));        assertSame(ColorEnum.BLUE, ColorEnum.getEnum("Blue"));        assertSame(null, ColorEnum.getEnum("Pink"));    }    public void testSerialization() {        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));    }    public void testBroken1() {        try {            Broken1Enum.RED.getName();            fail();        } catch (ExceptionInInitializerError ex) {            assertTrue(ex.getCause() instanceof IllegalArgumentException);        }    }    public void testBroken2() {        try {            Broken2Enum.RED.getName();            fail();        } catch (ExceptionInInitializerError ex) {            assertTrue(ex.getCause() instanceof IllegalArgumentException);        }    }    public void testBroken3() {        try {            Broken3Enum.RED.getName();            fail();        } catch (ExceptionInInitializerError ex) {            assertTrue(ex.getCause() instanceof IllegalArgumentException);        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EnumUtilsTest.java,v 1.1 2002/08/11 23:17:54 scolebourne Exp $ */public final class EnumUtilsTest extends TestCase {    public EnumUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(EnumUtilsTest.class);        suite.setName("EnumUtils Tests");        return suite;    }    public void testIterator() {        Iterator it = EnumUtils.iterator(ColorEnum.class);        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testIteratorEx() {        try {            EnumUtils.iterator(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testList() {        List list = EnumUtils.getEnumList(ColorEnum.class);        Iterator it = list.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testListEx() {        try {            EnumUtils.getEnumList(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMap() {        Map map = EnumUtils.getEnumMap(ColorEnum.class);        assertTrue(map.containsValue(ColorEnum.RED));        assertTrue(map.containsValue(ColorEnum.GREEN));        assertTrue(map.containsValue(ColorEnum.BLUE));        assertSame(ColorEnum.RED, map.get("Red"));        assertSame(ColorEnum.GREEN, map.get("Green"));        assertSame(ColorEnum.BLUE, map.get("Blue"));    }    public void testMapEx() {        try {            EnumUtils.getEnumMap(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testGet() {        assertSame(ColorEnum.RED, EnumUtils.getEnum(ColorEnum.class, "Red"));        assertSame(ColorEnum.GREEN, EnumUtils.getEnum(ColorEnum.class, "Green"));        assertSame(ColorEnum.BLUE, EnumUtils.getEnum(ColorEnum.class, "Blue"));        assertSame(null, EnumUtils.getEnum(ColorEnum.class, "Pink"));    }    public void testGetEx() {        try {            EnumUtils.getEnum(null, "");        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testGetValue() {        assertSame(ValuedColorEnum.RED, EnumUtils.getEnum(ValuedColorEnum.class, 1));        assertSame(ValuedColorEnum.GREEN, EnumUtils.getEnum(ValuedColorEnum.class, 2));        assertSame(ValuedColorEnum.BLUE, EnumUtils.getEnum(ValuedColorEnum.class, 3));        assertSame(null, EnumUtils.getEnum(ValuedColorEnum.class, 4));    }    public void testGetValueEx() {        try {            EnumUtils.getEnum(null, 0);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.functor;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.Map;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.lang.functor.Predicate;import org.apache.commons.lang.functor.PredicateUtils;/** * Tests the org.apache.commons.lang.functor.ClosureUtils class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: TestClosureUtils.java,v 1.1 2002/11/05 16:45:13 bayard Exp $ */public class TestClosureUtils extends junit.framework.TestCase {    private static final Object cObject = new Object();    private static final Object cString = "Hello";    private static final Object cInteger = new Integer(6);    /**     * Construct     */    public TestClosureUtils(String name) {        super(name);    }    /**     * Return class aa a test suite.     */    public static Test suite() {        return new TestSuite(TestClosureUtils.class);    }    /**     * Set up instance variables required by this test case.     */    public void setUp() {    }    /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }        static class MockClosure implements Closure {        int count = 0;                /**         * @see org.apache.commons.lang.functor.Closure#execute(Object)         */        public void execute(Object object) {            count++;        }    }    // exceptionClosure    //------------------------------------------------------------------    public void testExceptionClosure() {        assertNotNull(ClosureUtils.exceptionClosure());        assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());        try {            ClosureUtils.exceptionClosure().execute(null);        } catch (ClosureException ex) {            try {                ClosureUtils.exceptionClosure().execute(cString);            } catch (ClosureException ex2) {                return;            }        }        fail();    }        // nopClosure    //------------------------------------------------------------------    public void testNopClosure() {        StringBuffer buf = new StringBuffer("Hello");        ClosureUtils.nopClosure().execute(null);        assertEquals("Hello", buf.toString());        ClosureUtils.nopClosure().execute("Hello");        assertEquals("Hello", buf.toString());    }    // invokeClosure    //------------------------------------------------------------------    public void testInvokeClosure() {        StringBuffer buf = new StringBuffer("Hello");        ClosureUtils.invokerClosure("reverse").execute(buf);        assertEquals("olleH", buf.toString());        buf = new StringBuffer("Hello");        ClosureUtils.invokerClosure("setLength", new Class[] {Integer.TYPE}, new Object[] {new Integer(2)}).execute(buf);        assertEquals("He", buf.toString());    }    // forClosure    //------------------------------------------------------------------    public void testForClosure() {        MockClosure cmd = new MockClosure();        ClosureUtils.forClosure(5, cmd).execute(null);        assertEquals(5, cmd.count);        try {            ClosureUtils.forClosure(-1, new MockClosure());        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    // whileClosure    //------------------------------------------------------------------    public void testWhileClosure() {        MockClosure cmd = new MockClosure();        ClosureUtils.whileClosure(PredicateUtils.falsePredicate(), cmd).execute(null);        assertEquals(0, cmd.count);        try {            ClosureUtils.whileClosure(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    // doWhileClosure    //------------------------------------------------------------------    public void testDoWhileClosure() {        MockClosure cmd = new MockClosure();        ClosureUtils.doWhileClosure(cmd, PredicateUtils.falsePredicate()).execute(null);        assertEquals(1, cmd.count);        try {            ClosureUtils.doWhileClosure(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    // chainedClosure    //------------------------------------------------------------------    public void testChainedClosure() {        MockClosure a = new MockClosure();        MockClosure b = new MockClosure();        ClosureUtils.chainedClosure(a, b).execute(null);        assertEquals(1, a.count);        assertEquals(1, b.count);                a = new MockClosure();        b = new MockClosure();        ClosureUtils.chainedClosure(new Closure[] {a, b, a}).execute(null);        assertEquals(2, a.count);        assertEquals(1, b.count);                a = new MockClosure();        b = new MockClosure();        Collection coll = new ArrayList();        coll.add(b);        coll.add(a);        coll.add(b);        ClosureUtils.chainedClosure(coll).execute(null);        assertEquals(1, a.count);        assertEquals(2, b.count);    }    public void testChainedClosureEx1a() {        try {            ClosureUtils.chainedClosure(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedClosureEx1b() {        try {            ClosureUtils.chainedClosure((Closure[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedClosureEx1c() {        try {            ClosureUtils.chainedClosure((Collection) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedClosureEx2() {        try {            ClosureUtils.chainedClosure(new Closure[0]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedClosureEx3() {        try {            ClosureUtils.chainedClosure(new Closure[] {null, null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedClosureEx4() {        try {            ClosureUtils.chainedClosure(Collections.EMPTY_LIST);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedClosureEx5() {        try {            Collection coll = new ArrayList();            coll.add(null);            coll.add(null);            ClosureUtils.chainedClosure(coll);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // switchClosure    //------------------------------------------------------------------    public void testSwitchClosure() {        MockClosure a = new MockClosure();        MockClosure b = new MockClosure();        ClosureUtils.switchClosure(PredicateUtils.truePredicate(), a, b).execute(null);        assertEquals(1, a.count);        assertEquals(0, b.count);                a = new MockClosure();        b = new MockClosure();        ClosureUtils.switchClosure(PredicateUtils.falsePredicate(), a, b).execute(null);        assertEquals(0, a.count);        assertEquals(1, b.count);                a = new MockClosure();        b = new MockClosure();        ClosureUtils.switchClosure(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Closure[] {a, b}).execute("WELL");        assertEquals(0, a.count);        assertEquals(0, b.count);                a = new MockClosure();        b = new MockClosure();        ClosureUtils.switchClosure(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Closure[] {a, b}).execute("HELLO");        assertEquals(1, a.count);        assertEquals(0, b.count);                a = new MockClosure();        b = new MockClosure();        MockClosure c = new MockClosure();        ClosureUtils.switchClosure(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Closure[] {a, b}, c).execute("WELL");        assertEquals(0, a.count);        assertEquals(0, b.count);        assertEquals(1, c.count);                a = new MockClosure();        b = new MockClosure();        Map map = new HashMap();        map.put(PredicateUtils.equalPredicate("HELLO"), a);        map.put(PredicateUtils.equalPredicate("THERE"), b);        ClosureUtils.switchClosure(map).execute(null);        assertEquals(0, a.count);        assertEquals(0, b.count);        a = new MockClosure();        b = new MockClosure();        map = new HashMap();        map.put(PredicateUtils.equalPredicate("HELLO"), a);        map.put(PredicateUtils.equalPredicate("THERE"), b);        ClosureUtils.switchClosure(map).execute("THERE");        assertEquals(0, a.count);        assertEquals(1, b.count);        a = new MockClosure();        b = new MockClosure();        c = new MockClosure();        map = new HashMap();        map.put(PredicateUtils.equalPredicate("HELLO"), a);        map.put(PredicateUtils.equalPredicate("THERE"), b);        map.put(null, c);        ClosureUtils.switchClosure(map).execute("WELL");        assertEquals(0, a.count);        assertEquals(0, b.count);        assertEquals(1, c.count);    }    public void testSwitchClosureEx1a() {        try {            ClosureUtils.switchClosure(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx1b() {        try {            ClosureUtils.switchClosure((Predicate[]) null, (Closure[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx1c() {        try {            ClosureUtils.switchClosure((Map) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx2() {        try {            ClosureUtils.switchClosure(new Predicate[0], new Closure[0]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx3() {        try {            ClosureUtils.switchClosure(new Predicate[2], new Closure[2]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx4() {        try {            ClosureUtils.switchClosure(Collections.EMPTY_MAP);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx5() {        try {            Map map = new HashMap();            map.put(null, null);            map.put(null, null);            ClosureUtils.switchClosure(map);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchClosureEx6() {        try {            ClosureUtils.switchClosure(new Predicate[2], new Closure[1]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // switchMapClosure    //------------------------------------------------------------------    public void testSwitchMapClosure() {        MockClosure a = new MockClosure();        MockClosure b = new MockClosure();        Map map = new HashMap();        map.put("HELLO", a);        map.put("THERE", b);        ClosureUtils.switchMapClosure(map).execute(null);        assertEquals(0, a.count);        assertEquals(0, b.count);        a = new MockClosure();        b = new MockClosure();        map = new HashMap();        map.put("HELLO", a);        map.put("THERE", b);        ClosureUtils.switchMapClosure(map).execute("THERE");        assertEquals(0, a.count);        assertEquals(1, b.count);        a = new MockClosure();        b = new MockClosure();        MockClosure c = new MockClosure();        map = new HashMap();        map.put("HELLO", a);        map.put("THERE", b);        map.put(null, c);        ClosureUtils.switchMapClosure(map).execute("WELL");        assertEquals(0, a.count);        assertEquals(0, b.count);        assertEquals(1, c.count);    }    public void testSwitchMapClosureEx1() {        try {            ClosureUtils.switchMapClosure(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchMapClosureEx2() {        try {            ClosureUtils.switchMapClosure(Collections.EMPTY_MAP);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.functor;import java.io.Serializable;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.Date;import java.util.List;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationException;import org.apache.commons.lang.functor.TransformerUtils;/** * Tests the org.apache.commons.lang.functor.PredicateUtils class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: TestPredicateUtils.java,v 1.1 2002/11/05 16:45:13 bayard Exp $ */public class TestPredicateUtils extends junit.framework.TestCase {    private static final Object cObject = new Object();    private static final Object cString = "Hello";    private static final Object cInteger = new Integer(6);    /**     * Construct     */    public TestPredicateUtils(String name) {        super(name);    }    /**     * Return class aa a test suite.     */    public static Test suite() {        return new TestSuite(TestPredicateUtils.class);    }    /**     * Set up instance variables required by this test case.     */    public void setUp() {    }    /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }    // exceptionPredicate    //------------------------------------------------------------------    public void testExceptionPredicate() {        assertNotNull(PredicateUtils.exceptionPredicate());        assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());        try {            PredicateUtils.exceptionPredicate().evaluate(null);        } catch (PredicateException ex) {            try {                PredicateUtils.exceptionPredicate().evaluate(cString);            } catch (PredicateException ex2) {                return;            }        }        fail();    }        // nullPredicate    //------------------------------------------------------------------    public void testNullPredicate() {        assertNotNull(PredicateUtils.nullPredicate());        assertSame(PredicateUtils.nullPredicate(), PredicateUtils.nullPredicate());        assertEquals(true, PredicateUtils.nullPredicate().evaluate(null));        assertEquals(false, PredicateUtils.nullPredicate().evaluate(cObject));        assertEquals(false, PredicateUtils.nullPredicate().evaluate(cString));        assertEquals(false, PredicateUtils.nullPredicate().evaluate(cInteger));    }    // notNullPredicate    //------------------------------------------------------------------    public void testIsNotNullPredicate() {        assertNotNull(PredicateUtils.notNullPredicate());        assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());        assertEquals(false, PredicateUtils.notNullPredicate().evaluate(null));        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cObject));        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cString));        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cInteger));    }    // equalPredicate    //------------------------------------------------------------------    public void testEqualPredicate() {        assertSame(PredicateUtils.nullPredicate(), PredicateUtils.equalPredicate(null));        assertNotNull(PredicateUtils.equalPredicate(new Integer(6)));        assertEquals(false, PredicateUtils.equalPredicate(new Integer(6)).evaluate(null));        assertEquals(false, PredicateUtils.equalPredicate(new Integer(6)).evaluate(cObject));        assertEquals(false, PredicateUtils.equalPredicate(new Integer(6)).evaluate(cString));        assertEquals(true, PredicateUtils.equalPredicate(new Integer(6)).evaluate(cInteger));    }    // identityPredicate    //------------------------------------------------------------------    public void testIdentityPredicate() {        assertSame(PredicateUtils.nullPredicate(), PredicateUtils.identityPredicate(null));        assertNotNull(PredicateUtils.identityPredicate(new Integer(6)));        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(null));        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(cObject));        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(cString));        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(cInteger));        assertEquals(true, PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));    }    // truePredicate    //------------------------------------------------------------------    public void testTruePredicate() {        assertNotNull(PredicateUtils.truePredicate());        assertSame(PredicateUtils.truePredicate(), PredicateUtils.truePredicate());        assertEquals(true, PredicateUtils.truePredicate().evaluate(null));        assertEquals(true, PredicateUtils.truePredicate().evaluate(cObject));        assertEquals(true, PredicateUtils.truePredicate().evaluate(cString));        assertEquals(true, PredicateUtils.truePredicate().evaluate(cInteger));    }    // falsePredicate    //------------------------------------------------------------------    public void testFalsePredicate() {        assertNotNull(PredicateUtils.falsePredicate());        assertSame(PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate());        assertEquals(false, PredicateUtils.falsePredicate().evaluate(null));        assertEquals(false, PredicateUtils.falsePredicate().evaluate(cObject));        assertEquals(false, PredicateUtils.falsePredicate().evaluate(cString));        assertEquals(false, PredicateUtils.falsePredicate().evaluate(cInteger));    }    // notPredicate    //------------------------------------------------------------------    public void testNotPredicate() {        assertNotNull(PredicateUtils.notPredicate(PredicateUtils.truePredicate()));        assertEquals(false, PredicateUtils.notPredicate(PredicateUtils.truePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.notPredicate(PredicateUtils.truePredicate()).evaluate(cObject));        assertEquals(false, PredicateUtils.notPredicate(PredicateUtils.truePredicate()).evaluate(cString));        assertEquals(false, PredicateUtils.notPredicate(PredicateUtils.truePredicate()).evaluate(cInteger));    }        public void testNotPredicateEx() {        try {            PredicateUtils.notPredicate(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // andPredicate    //------------------------------------------------------------------    public void testAndPredicate() {        assertEquals(true, PredicateUtils.andPredicate(PredicateUtils.truePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.andPredicate(PredicateUtils.truePredicate(), PredicateUtils.falsePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.andPredicate(PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.andPredicate(PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()).evaluate(null));    }    public void testAndPredicateEx() {        try {            PredicateUtils.andPredicate(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // allPredicate    //------------------------------------------------------------------    public void testAllPredicate() {        assertEquals(true, PredicateUtils.allPredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.truePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.allPredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.allPredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.allPredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()}).evaluate(null));        Collection coll = new ArrayList();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(true, PredicateUtils.allPredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.allPredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.allPredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        assertEquals(false, PredicateUtils.allPredicate(coll).evaluate(null));    }    public void testAllPredicateEx1() {        try {            PredicateUtils.allPredicate((Predicate[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAllPredicateEx2() {        try {            PredicateUtils.allPredicate(new Predicate[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAllPredicateEx3() {        try {            PredicateUtils.allPredicate(new Predicate[] {null, null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAllPredicateEx4() {        try {            PredicateUtils.allPredicate((Collection) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAllPredicateEx5() {        try {            PredicateUtils.allPredicate(Collections.EMPTY_LIST);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAllPredicateEx6() {        try {            Collection coll = new ArrayList();            coll.add(null);            coll.add(null);            PredicateUtils.allPredicate(coll);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // orPredicate    //------------------------------------------------------------------    public void testOrPredicate() {        assertEquals(true, PredicateUtils.orPredicate(PredicateUtils.truePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.orPredicate(PredicateUtils.truePredicate(), PredicateUtils.falsePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.orPredicate(PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.orPredicate(PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()).evaluate(null));    }        public void testOrPredicateEx() {        try {            PredicateUtils.orPredicate(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // anyPredicate    //------------------------------------------------------------------    public void testAnyPredicate() {        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.truePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.anyPredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()}).evaluate(null));        Collection coll = new ArrayList();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        assertEquals(false, PredicateUtils.anyPredicate(coll).evaluate(null));    }    public void testAnyPredicateEx1() {        try {            PredicateUtils.anyPredicate((Predicate[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAnyPredicateEx2() {        try {            PredicateUtils.anyPredicate(new Predicate[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAnyPredicateEx3() {        try {            PredicateUtils.anyPredicate(new Predicate[] {null, null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAnyPredicateEx4() {        try {            PredicateUtils.anyPredicate((Collection) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAnyPredicateEx5() {        try {            PredicateUtils.anyPredicate(Collections.EMPTY_LIST);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAnyPredicateEx6() {        try {            Collection coll = new ArrayList();            coll.add(null);            coll.add(null);            PredicateUtils.anyPredicate(coll);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // eitherPredicate    //------------------------------------------------------------------    public void testEitherPredicate() {        assertEquals(false, PredicateUtils.eitherPredicate(PredicateUtils.truePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.eitherPredicate(PredicateUtils.truePredicate(), PredicateUtils.falsePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.eitherPredicate(PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.eitherPredicate(PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()).evaluate(null));    }    public void testEitherPredicateEx() {        try {            PredicateUtils.eitherPredicate(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // onePredicate    //------------------------------------------------------------------    public void testOnePredicate() {        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.truePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()}).evaluate(null));        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.truePredicate(), PredicateUtils.falsePredicate()}).evaluate(null));        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()}).evaluate(null));        Collection coll = new ArrayList();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(true, PredicateUtils.onePredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));    }    public void testOnePredicateEx1() {        try {            PredicateUtils.onePredicate((Predicate[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testOnePredicateEx2() {        try {            PredicateUtils.onePredicate(new Predicate[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testOnePredicateEx3() {        try {            PredicateUtils.onePredicate(new Predicate[] {null, null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testOnePredicateEx4() {        try {            PredicateUtils.onePredicate((Collection) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testOnePredicateEx5() {        try {            PredicateUtils.onePredicate(Collections.EMPTY_LIST);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testOnePredicateEx6() {        try {            Collection coll = new ArrayList();            coll.add(null);            coll.add(null);            PredicateUtils.onePredicate(coll);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // neitherPredicate    //------------------------------------------------------------------    public void testNeitherPredicate() {        assertEquals(false, PredicateUtils.neitherPredicate(PredicateUtils.truePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.neitherPredicate(PredicateUtils.truePredicate(), PredicateUtils.falsePredicate()).evaluate(null));        assertEquals(false, PredicateUtils.neitherPredicate(PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.neitherPredicate(PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()).evaluate(null));    }    public void testNeitherPredicateEx() {        try {            PredicateUtils.neitherPredicate(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // nonePredicate    //------------------------------------------------------------------    public void testNonePredicate() {        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.truePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {            PredicateUtils.truePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.truePredicate()}).evaluate(null));        assertEquals(true, PredicateUtils.nonePredicate(new Predicate[] {            PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate(), PredicateUtils.falsePredicate()}).evaluate(null));        Collection coll = new ArrayList();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.truePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.truePredicate());        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));        coll.clear();        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        coll.add(PredicateUtils.falsePredicate());        assertEquals(true, PredicateUtils.nonePredicate(coll).evaluate(null));    }    public void testNonePredicateEx1() {        try {            PredicateUtils.nonePredicate((Predicate[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testNonePredicateEx2() {        try {            PredicateUtils.nonePredicate(new Predicate[] {null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testNonePredicateEx3() {        try {            PredicateUtils.nonePredicate(new Predicate[] {null, null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testNonePredicateEx4() {        try {            PredicateUtils.nonePredicate((Collection) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testNonePredicateEx5() {        try {            PredicateUtils.nonePredicate(Collections.EMPTY_LIST);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testNonePredicateEx6() {        try {            Collection coll = new ArrayList();            coll.add(null);            coll.add(null);            PredicateUtils.nonePredicate(coll);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // instanceofPredicate    //------------------------------------------------------------------    public void testInstanceOfPredicate() {        assertNotNull(PredicateUtils.instanceofPredicate(String.class));        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(null));        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));        assertEquals(true, PredicateUtils.instanceofPredicate(String.class).evaluate(cString));        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));    }    // uniquePredicate    //------------------------------------------------------------------    public void testUniquePredicate() {        Predicate p = PredicateUtils.uniquePredicate();        assertEquals(true, p.evaluate(new Object()));        assertEquals(true, p.evaluate(new Object()));        assertEquals(true, p.evaluate(new Object()));        assertEquals(true, p.evaluate(cString));        assertEquals(false, p.evaluate(cString));        assertEquals(false, p.evaluate(cString));    }        // asPredicate(Transformer)    //------------------------------------------------------------------    public void testAsPredicateTransformer() {        assertEquals(false, PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(Boolean.FALSE));        assertEquals(true, PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(Boolean.TRUE));    }    public void testAsPredicateTransformerEx1() {        try {            PredicateUtils.asPredicate(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testAsPredicateTransformerEx2() {        try {            PredicateUtils.asPredicate(TransformerUtils.nopTransformer()).evaluate(null);        } catch (PredicateException ex) {            return;        }        fail();    }        // invokerPredicate    //------------------------------------------------------------------    public void testInvokerPredicate() {        List list = new ArrayList();        assertEquals(true, PredicateUtils.invokerPredicate("isEmpty").evaluate(list));        list.add(new Object());        assertEquals(false, PredicateUtils.invokerPredicate("isEmpty").evaluate(list));    }    public void testInvokerPredicateEx1() {        try {            PredicateUtils.invokerPredicate(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testInvokerPredicateEx2() {        try {            PredicateUtils.invokerPredicate("isEmpty").evaluate(null);        } catch (PredicateException ex) {            return;        }        fail();    }        public void testInvokerPredicateEx3() {        try {            PredicateUtils.invokerPredicate("noSuchMethod").evaluate(new Object());        } catch (PredicateException ex) {            return;        }        fail();    }        // invokerPredicate2    //------------------------------------------------------------------    public void testInvokerPredicate2() {        List list = new ArrayList();        assertEquals(false, PredicateUtils.invokerPredicate(            "contains", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));        list.add(cString);        assertEquals(true, PredicateUtils.invokerPredicate(            "contains", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));    }    public void testInvokerPredicate2Ex1() {        try {            PredicateUtils.invokerPredicate(null, null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testInvokerPredicate2Ex2() {        try {            PredicateUtils.invokerPredicate("contains", new Class[] {Object.class}, new Object[] {cString}).evaluate(null);        } catch (PredicateException ex) {            return;        }        fail();    }        public void testInvokerPredicate2Ex3() {        try {            PredicateUtils.invokerPredicate(                "noSuchMethod", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object());        } catch (PredicateException ex) {            return;        }        fail();    }        // nullIsException    //------------------------------------------------------------------    public void testNullIsExceptionPredicate() {        assertEquals(true, PredicateUtils.nullIsExceptionPredicate(PredicateUtils.truePredicate()).evaluate(new Object()));        try {            PredicateUtils.nullIsExceptionPredicate(PredicateUtils.truePredicate()).evaluate(null);        } catch (PredicateException ex) {            return;        }        fail();    }    public void testNullIsExceptionPredicateEx1() {        try {            PredicateUtils.nullIsExceptionPredicate(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // nullIsTrue    //------------------------------------------------------------------    public void testNullIsTruePredicate() {        assertEquals(true, PredicateUtils.nullIsTruePredicate(PredicateUtils.truePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.nullIsTruePredicate(PredicateUtils.truePredicate()).evaluate(new Object()));        assertEquals(false, PredicateUtils.nullIsTruePredicate(PredicateUtils.falsePredicate()).evaluate(new Object()));    }    public void testNullIsTruePredicateEx1() {        try {            PredicateUtils.nullIsTruePredicate(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // nullIsFalse    //------------------------------------------------------------------    public void testNullIsFalsePredicate() {        assertEquals(false, PredicateUtils.nullIsFalsePredicate(PredicateUtils.truePredicate()).evaluate(null));        assertEquals(true, PredicateUtils.nullIsFalsePredicate(PredicateUtils.truePredicate()).evaluate(new Object()));        assertEquals(false, PredicateUtils.nullIsFalsePredicate(PredicateUtils.falsePredicate()).evaluate(new Object()));    }    public void testNullIsFalsePredicateEx1() {        try {            PredicateUtils.nullIsFalsePredicate(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.functor;import java.io.Serializable;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationException;import org.apache.commons.lang.functor.Closure;import org.apache.commons.lang.functor.ClosureUtils;import org.apache.commons.lang.functor.Factory;import org.apache.commons.lang.functor.FactoryUtils;import org.apache.commons.lang.functor.Predicate;import org.apache.commons.lang.functor.PredicateUtils;/** * Tests the org.apache.commons.lang.functor.TransformerUtils class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: TestTransformerUtils.java,v 1.1 2002/11/05 16:45:13 bayard Exp $ */public class TestTransformerUtils extends junit.framework.TestCase {    private static final Object cObject = new Object();    private static final Object cString = "Hello";    private static final Object cInteger = new Integer(6);    /**     * Construct     */    public TestTransformerUtils(String name) {        super(name);    }    /**     * Return class aa a test suite.     */    public static Test suite() {        return new TestSuite(TestTransformerUtils.class);    }    /**     * Set up instance variables required by this test case.     */    public void setUp() {    }    /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }    // exceptionTransformer    //------------------------------------------------------------------    public void testExceptionTransformer() {        assertNotNull(TransformerUtils.exceptionTransformer());        assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());        try {            TransformerUtils.exceptionTransformer().transform(null);        } catch (TransformerException ex) {            try {                TransformerUtils.exceptionTransformer().transform(cString);            } catch (TransformerException ex2) {                return;            }        }        fail();    }        // nullTransformer    //------------------------------------------------------------------    public void testNullTransformer() {        assertNotNull(TransformerUtils.nullTransformer());        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());        assertEquals(null, TransformerUtils.nullTransformer().transform(null));        assertEquals(null, TransformerUtils.nullTransformer().transform(cObject));        assertEquals(null, TransformerUtils.nullTransformer().transform(cString));        assertEquals(null, TransformerUtils.nullTransformer().transform(cInteger));    }    // nopTransformer    //------------------------------------------------------------------    public void testNopTransformer() {        assertNotNull(TransformerUtils.nullTransformer());        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());        assertEquals(null, TransformerUtils.nopTransformer().transform(null));        assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));        assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));        assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));    }    // constantTransformer    //------------------------------------------------------------------    public void testConstantTransformer() {        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));    }    // cloneTransformer    //------------------------------------------------------------------    public void testCloneTransformer() {        assertEquals(null, TransformerUtils.cloneTransformer().transform(null));        assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));        assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));        try {            assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));        } catch (TransformerException ex) {            return;        }        fail();    }    // mapTransformer    //------------------------------------------------------------------    public void testMapTransformer() {        Map map = new HashMap();        map.put(null, new Integer(0));        map.put(cObject, new Integer(1));        map.put(cString, new Integer(2));        assertEquals(new Integer(0), TransformerUtils.mapTransformer(map).transform(null));        assertEquals(new Integer(1), TransformerUtils.mapTransformer(map).transform(cObject));        assertEquals(new Integer(2), TransformerUtils.mapTransformer(map).transform(cString));        assertEquals(null, TransformerUtils.mapTransformer(map).transform(cInteger));    }    // commandTransformer    //------------------------------------------------------------------    public void testClosureTransformer() {        assertEquals(null, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));        assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));        assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));        assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));        try {            TransformerUtils.asTransformer((Closure) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    // predicateTransformer    //------------------------------------------------------------------    public void testPredicateTransformer() {        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(PredicateUtils.truePredicate()).transform(null));        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(PredicateUtils.truePredicate()).transform(cObject));        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(PredicateUtils.truePredicate()).transform(cString));        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(PredicateUtils.truePredicate()).transform(cInteger));        try {            TransformerUtils.asTransformer((Predicate) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    // factoryTransformer    //------------------------------------------------------------------    public void testFactoryTransformer() {        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));        try {            TransformerUtils.asTransformer((Factory) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    // chainedTransformer    //------------------------------------------------------------------    public void testChainedTransformer() {        Transformer a = TransformerUtils.constantTransformer("A");        Transformer b = TransformerUtils.constantTransformer("B");                assertEquals("A", TransformerUtils.chainedTransformer(b, a).transform(null));        assertEquals("B", TransformerUtils.chainedTransformer(a, b).transform(null));        assertEquals("A", TransformerUtils.chainedTransformer(new Transformer[] {b, a}).transform(null));        Collection coll = new ArrayList();        coll.add(b);        coll.add(a);        assertEquals("A", TransformerUtils.chainedTransformer(coll).transform(null));    }    public void testChainedTransformerEx1a() {        try {            TransformerUtils.chainedTransformer(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedTransformerEx1b() {        try {            TransformerUtils.chainedTransformer((Transformer[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedTransformerEx1c() {        try {            TransformerUtils.chainedTransformer((Collection) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedTransformerEx2() {        try {            TransformerUtils.chainedTransformer(new Transformer[0]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedTransformerEx3() {        try {            TransformerUtils.chainedTransformer(new Transformer[] {null, null});        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedTransformerEx4() {        try {            TransformerUtils.chainedTransformer(Collections.EMPTY_LIST);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testChainedTransformerEx5() {        try {            Collection coll = new ArrayList();            coll.add(null);            coll.add(null);            TransformerUtils.chainedTransformer(coll);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // switchTransformer    //------------------------------------------------------------------    public void testSwitchTransformer() {        Transformer a = TransformerUtils.constantTransformer("A");        Transformer b = TransformerUtils.constantTransformer("B");        Transformer c = TransformerUtils.constantTransformer("C");                assertEquals("A", TransformerUtils.switchTransformer(PredicateUtils.truePredicate(), a, b).transform(null));        assertEquals("B", TransformerUtils.switchTransformer(PredicateUtils.falsePredicate(), a, b).transform(null));                assertEquals(null, TransformerUtils.switchTransformer(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Transformer[] {a, b}).transform("WELL"));        assertEquals("A", TransformerUtils.switchTransformer(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Transformer[] {a, b}).transform("HELLO"));        assertEquals("B", TransformerUtils.switchTransformer(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Transformer[] {a, b}).transform("THERE"));                    assertEquals("C", TransformerUtils.switchTransformer(            new Predicate[] {PredicateUtils.equalPredicate("HELLO"), PredicateUtils.equalPredicate("THERE")},             new Transformer[] {a, b}, c).transform("WELL"));                    Map map = new HashMap();        map.put(PredicateUtils.equalPredicate("HELLO"), a);        map.put(PredicateUtils.equalPredicate("THERE"), b);        assertEquals(null, TransformerUtils.switchTransformer(map).transform("WELL"));        assertEquals("A", TransformerUtils.switchTransformer(map).transform("HELLO"));        assertEquals("B", TransformerUtils.switchTransformer(map).transform("THERE"));        map.put(null, c);        assertEquals("C", TransformerUtils.switchTransformer(map).transform("WELL"));    }    public void testSwitchTransformerEx1a() {        try {            TransformerUtils.switchTransformer(null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx1b() {        try {            TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx1c() {        try {            TransformerUtils.switchTransformer((Map) null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx2() {        try {            TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx3() {        try {            TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx4() {        try {            TransformerUtils.switchTransformer(Collections.EMPTY_MAP);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx5() {        try {            Map map = new HashMap();            map.put(null, null);            map.put(null, null);            TransformerUtils.switchTransformer(map);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchTransformerEx6() {        try {            TransformerUtils.switchTransformer(new Predicate[2], new Transformer[1]);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // switchMapTransformer    //------------------------------------------------------------------    public void testSwitchMapTransformer() {        Transformer a = TransformerUtils.constantTransformer("A");        Transformer b = TransformerUtils.constantTransformer("B");        Transformer c = TransformerUtils.constantTransformer("C");                Map map = new HashMap();        map.put("HELLO", a);        map.put("THERE", b);        assertEquals(null, TransformerUtils.switchMapTransformer(map).transform("WELL"));        assertEquals("A", TransformerUtils.switchMapTransformer(map).transform("HELLO"));        assertEquals("B", TransformerUtils.switchMapTransformer(map).transform("THERE"));        map.put(null, c);        assertEquals("C", TransformerUtils.switchMapTransformer(map).transform("WELL"));    }    public void testSwitchMapTransformerEx1() {        try {            TransformerUtils.switchMapTransformer(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testSwitchMapTransformerEx2() {        try {            TransformerUtils.switchMapTransformer(Collections.EMPTY_MAP);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        // invokerTransformer    //------------------------------------------------------------------    public void testInvokerTransformer() {        List list = new ArrayList();        assertEquals(new Integer(0), TransformerUtils.invokerTransformer("size").transform(list));        list.add(new Object());        assertEquals(new Integer(1), TransformerUtils.invokerTransformer("size").transform(list));        assertEquals(null, TransformerUtils.invokerTransformer("size").transform(null));    }    public void testInvokerTransformerEx1() {        try {            TransformerUtils.invokerTransformer(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testInvokerTransformerEx3() {        try {            TransformerUtils.invokerTransformer("noSuchMethod").transform(new Object());        } catch (TransformerException ex) {            return;        }        fail();    }        // invokerTransformer2    //------------------------------------------------------------------    public void testInvokerTransformer2() {        List list = new ArrayList();        assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer(            "contains", new Class[] {Object.class}, new Object[] {cString}).transform(list));        list.add(cString);        assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer(            "contains", new Class[] {Object.class}, new Object[] {cString}).transform(list));        assertEquals(null, TransformerUtils.invokerTransformer(            "contains", new Class[] {Object.class}, new Object[] {cString}).transform(null));    }    public void testInvokerTransformer2Ex1() {        try {            TransformerUtils.invokerTransformer(null, null, null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }        public void testInvokerTransformer2Ex3() {        try {            TransformerUtils.invokerTransformer(                "noSuchMethod", new Class[] {Object.class}, new Object[] {cString}).transform(new Object());        } catch (TransformerException ex) {            return;        }        fail();    }    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.functor;import java.io.Serializable;import java.util.Date;import java.util.TimeZone;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationException;/** * Tests the org.apache.commons.lang.functor.FactoryUtils class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: TestFactoryUtils.java,v 1.1 2002/11/05 16:45:13 bayard Exp $ */public class TestFactoryUtils extends junit.framework.TestCase {    /**     * Construct     */    public TestFactoryUtils(String name) {        super(name);    }    /**     * Return class aa a test suite.     */    public static Test suite() {        return new TestSuite(TestFactoryUtils.class);    }    /**     * Set up instance variables required by this test case.     */    public void setUp() {    }    /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }    // exceptionFactory    //------------------------------------------------------------------    public void testExceptionFactory() {        assertNotNull(FactoryUtils.exceptionFactory());        assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());        try {            FactoryUtils.exceptionFactory().create();        } catch (FactoryException ex) {            try {                FactoryUtils.exceptionFactory().create();            } catch (FactoryException ex2) {                return;            }        }        fail();    }        // nullFactory    //------------------------------------------------------------------        public void testNullFactory() {        Factory factory = FactoryUtils.nullFactory();        assertNotNull(factory);        Object created = factory.create();        assertNull(created);    }    // constantFactory    //------------------------------------------------------------------        public void testConstantFactoryNull() {        Factory factory = FactoryUtils.constantFactory(null);        assertNotNull(factory);        Object created = factory.create();        assertNull(created);    }    public void testConstantFactoryConstant() {        Integer constant = new Integer(9);        Factory factory = FactoryUtils.constantFactory(constant);        assertNotNull(factory);        Object created = factory.create();        assertSame(constant, created);    }    // prototypeFactory    //------------------------------------------------------------------        public void testPrototypeFactoryNull() {        try {            Factory factory = FactoryUtils.prototypeFactory(null);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testPrototypeFactoryPublicCloneMethod() {        Date proto = new Date();        Factory factory = FactoryUtils.prototypeFactory(proto);        assertNotNull(factory);        Object created = factory.create();        assertTrue(proto != created);        assertEquals(proto, created);    }    public void testPrototypeFactoryPublicCopyConstructor() {        Mock1 proto = new Mock1(6);        Factory factory = FactoryUtils.prototypeFactory(proto);        assertNotNull(factory);        Object created = factory.create();        assertTrue(proto != created);        assertEquals(proto, created);    }    public void testPrototypeFactoryPublicSerialization() {        Integer proto = new Integer(9);        Factory factory = FactoryUtils.prototypeFactory(proto);        assertNotNull(factory);        Object created = factory.create();        assertTrue(proto != created);        assertEquals(proto, created);    }    public void testPrototypeFactoryPublicSerializationError() {        Mock2 proto = new Mock2(new Object());        Factory factory = FactoryUtils.prototypeFactory(proto);        assertNotNull(factory);        try {            Object created = factory.create();                    } catch (FactoryException ex) {            assertTrue(ex.getCause() instanceof SerializationException);            return;        }        fail();    }    public void testPrototypeFactoryPublicBad() {        Object proto = new Object();        try {            Factory factory = FactoryUtils.prototypeFactory(proto);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public static class Mock1 {        private final int iVal;        public Mock1(int val) {            iVal = val;        }        public Mock1(Mock1 mock) {            iVal = mock.iVal;        }        public boolean equals(Object obj) {            if (obj instanceof Mock1) {                if (iVal == ((Mock1) obj).iVal) {                    return true;                }            }            return false;        }    }        public static class Mock2 implements Serializable {        private final Object iVal;        public Mock2(Object val) {            iVal = val;        }        public boolean equals(Object obj) {            if (obj instanceof Mock2) {                if (iVal == ((Mock2) obj).iVal) {                    return true;                }            }            return false;        }    }        // reflectionFactory    //------------------------------------------------------------------        public void testReflectionFactoryNull() {        try {            Factory factory = FactoryUtils.reflectionFactory(null);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionFactorySimple() {        Factory factory = FactoryUtils.reflectionFactory(Date.class);        assertNotNull(factory);        Object created = factory.create();        assertTrue(created instanceof Date);        assertEquals((double) System.currentTimeMillis(), (double) ((Date) created).getTime(), 0.01d);    }    public void testReflectionFactoryMismatch() {        try {            Factory factory = FactoryUtils.reflectionFactory(Date.class, null, new Object[] {null});                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionFactoryNoConstructor() {        try {            Factory factory = FactoryUtils.reflectionFactory(Date.class, new Class[] {Long.class}, new Object[] {null});                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionFactoryComplex() {        TimeZone.setDefault(TimeZone.getTimeZone("GMT"));        Factory factory = FactoryUtils.reflectionFactory(Date.class,            new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},            new Object[] {new Integer(70), new Integer(0), new Integer(2)});        assertNotNull(factory);        Object created = factory.create();        assertTrue(created instanceof Date);        assertEquals(new Date(1000 * 60 * 60 * 24), created);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: StandardToStringStyleTest.java,v 1.1 2002/09/17 22:07:50 scolebourne Exp $ */public class StandardToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = "Integer";        private static final StandardToStringStyle STYLE = new StandardToStringStyle();        static {        STYLE.setShortClassName(true);        STYLE.setUseIdentityHashCode(false);        STYLE.setArrayStart("[");        STYLE.setArraySeparator(", ");        STYLE.setArrayEnd("]");        STYLE.setNullText("%NULL%");        STYLE.setSizeStartText("%SIZE=");        STYLE.setSizeEndText("%");        STYLE.setSummaryObjectStartText("%");        STYLE.setSummaryObjectEndText("%");    }        public StandardToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(StandardToStringStyleTest.class);        suite.setName("StandardToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }    public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[a=%NULL%]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[a=%Integer%]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[a=%SIZE=0%]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[[%NULL%, 5, [3, 6]]]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[[1, 2, -3, 4]]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[[[1, 2], %NULL%, [5]]]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[%NULL%]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: DefaultToStringStyleTest.java,v 1.1 2002/09/17 22:07:50 scolebourne Exp $ */public class DefaultToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public DefaultToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(DefaultToStringStyleTest.class);        suite.setName("DefaultToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }    public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.HashCodeBuilder}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: HashCodeBuilderTest.java,v 1.1 2002/09/12 22:01:00 scolebourne Exp $ */public class HashCodeBuilderTest extends TestCase {    public HashCodeBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(HashCodeBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testConstructorEx1() {        try {            new HashCodeBuilder(0, 0);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testConstructorEx2() {        try {            new HashCodeBuilder(2, 2);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    static class TestObject {        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }    }    public void testReflectionHashCode() {        assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));        assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));    }    public void testReflectionHashCodeEx1() {        try {            HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx2() {        try {            HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx3() {        try {            HashCodeBuilder.reflectionHashCode(13, 19, null, true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testObject() {        Object obj = null;        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj = new Object();        assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLong() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append((long) 123456789L).toHashCode());    }    public void testInt() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode());        assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode());    }    public void testShort() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());        assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());    }    public void testChar() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());        assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());    }    public void testByte() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());        assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());    }    public void testDouble() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());        double d = 1234567.89;        long l = Double.doubleToLongBits(d);        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());    }    public void testFloat() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());        float f = 1234.89f;        int i = Float.floatToIntBits(f);        assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());    }    public void testBoolean() {        assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());        assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());    }    public void testObjectArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testObjectArrayAsObject() {        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testLongArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLongArrayAsObject() {        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testIntArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testIntArrayAsObject() {        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testShortArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testShortArrayAsObject() {        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testCharArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testCharArrayAsObject() {        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testByteArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testByteArrayAsObject() {        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testDoubleArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testDoubleArrayAsObject() {        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testFloatArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testFloatArrayAsObject() {        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testBooleanArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testBooleanArrayAsObject() {        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testBooleanMultiArray() {        boolean[][] obj = new boolean[2][];        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[0];        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[1];        assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[2];        assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0][0] = true;        assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new boolean[1];        assertEquals( (((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringBuilder}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: ToStringBuilderTest.java,v 1.1 2002/09/17 22:07:50 scolebourne Exp $ */public class ToStringBuilderTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public ToStringBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(ToStringBuilderTest.class);        suite.setName("ToStringBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testConstructorEx1() {        try {            new ToStringBuilder(null);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testConstructorEx2() {        try {            new ToStringBuilder(null, null);                    } catch (IllegalArgumentException ex) {            try {                new ToStringBuilder(base, null);                            } catch (Exception ex2) {                fail();            }            return;        }        fail();    }    public void testConstructorEx3() {        try {            new ToStringBuilder(null, null, null);                    } catch (IllegalArgumentException ex) {            try {                new ToStringBuilder(base, null, null);                new ToStringBuilder(base, ToStringStyle.DEFAULT_STYLE, null);                            } catch (Exception ex2) {                fail();            }            return;        }        fail();    }    public void testGetSetDefault() {        try {            ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);            assertSame(ToStringStyle.NO_FIELD_NAMES_STYLE, ToStringBuilder.getDefaultStyle());        } finally {            // reset for other tests            ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);        }    }    public void testSetDefaultEx() {        try {            ToStringBuilder.setDefaultStyle(null);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }        public void testReflection() {        assertEquals(baseStr + "[value=5]", ToStringBuilder.reflectionToString(base));    }        public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[a=<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[a=<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[a=[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[a=<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[a={}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testInt() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((int) 3).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (int) 3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (int) 3).append("b", (int) 4).toString());    }    public void testShort() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((short) 3).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (short) 3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (short) 3).append("b", (short) 4).toString());    }    public void testChar() {        assertEquals(baseStr + "[A]", new ToStringBuilder(base).append((char) 65).toString());        assertEquals(baseStr + "[a=A]", new ToStringBuilder(base).append("a", (char) 65).toString());        assertEquals(baseStr + "[a=A,b=B]", new ToStringBuilder(base).append("a", (char) 65).append("b", (char) 66).toString());    }    public void testByte() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append((byte) 3).toString());        assertEquals(baseStr + "[a=3]", new ToStringBuilder(base).append("a", (byte) 3).toString());        assertEquals(baseStr + "[a=3,b=4]", new ToStringBuilder(base).append("a", (byte) 3).append("b", (byte) 4).toString());    }    public void testDouble() {        assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((double) 3.2).toString());        assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (double) 3.2).toString());        assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (double) 3.2).append("b", (double) 4.3).toString());    }    public void testFloat() {        assertEquals(baseStr + "[3.2]", new ToStringBuilder(base).append((float) 3.2).toString());        assertEquals(baseStr + "[a=3.2]", new ToStringBuilder(base).append("a", (float) 3.2).toString());        assertEquals(baseStr + "[a=3.2,b=4.3]", new ToStringBuilder(base).append("a", (float) 3.2).append("b", (float) 4.3).toString());    }    public void testBoolean() {        assertEquals(baseStr + "[true]", new ToStringBuilder(base).append(true).toString());        assertEquals(baseStr + "[a=true]", new ToStringBuilder(base).append("a", true).toString());        assertEquals(baseStr + "[a=true,b=false]", new ToStringBuilder(base).append("a", true).append("b", false).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testIntArray() {        int[] array = new int[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testShortArray() {        short[] array = new short[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }        public void testByteArray() {        byte[] array = new byte[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testCharArray() {        char[] array = new char[] {'A', '2', '_', 'D'};        assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{A,2,_,D}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testDoubleArray() {        double[] array = new double[] {1.0, 2.9876, -3.00001, 4.3};        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testFloatArray() {        float[] array = new float[] {1.0f, 2.9876f, -3.00001f, 4.3f};        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1.0,2.9876,-3.00001,4.3}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }        public void testBooleanArray() {        boolean[] array = new boolean[] {true, false, false};        assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{true,false,false}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testIntArrayArray() {        int[][] array = new int[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testShortArrayArray() {        short[][] array = new short[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testByteArrayArray() {        byte[][] array = new byte[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testCharArrayArray() {        char[][] array = new char[][] {{'A', 'B'}, null, {'p'}};        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{A,B},<null>,{p}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testDoubleArrayArray() {        double[][] array = new double[][] {{1.0, 2.29686}, null, {Double.NaN}};        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testFloatArrayArray() {        float[][] array = new float[][] {{1.0f, 2.29686f}, null, {Float.NaN}};        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1.0,2.29686},<null>,{NaN}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testBooleanArrayArray() {        boolean[][] array = new boolean[][] {{true, false}, null, {false}};        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{true,false},<null>,{false}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: SimpleToStringStyleTest.java,v 1.1 2002/09/17 22:07:50 scolebourne Exp $ */public class SimpleToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);        public SimpleToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(SimpleToStringStyleTest.class);        suite.setName("DefaultToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.SIMPLE_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals("", new ToStringBuilder(base).toString());    }    public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals("<null>", new ToStringBuilder(base).append((Object) null).toString());        assertEquals("3", new ToStringBuilder(base).append(i3).toString());        assertEquals("<null>", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals("3", new ToStringBuilder(base).append("a", i3).toString());        assertEquals("3,4", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals("<Integer>", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals("<size=0>", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals("[]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals("<size=0>", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals("{}", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals("<size=0>", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals("{}", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals("3", new ToStringBuilder(base).append(3L).toString());        assertEquals("3", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals("3,4", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append(array).toString());        assertEquals("{<null>,5,{3,6}}", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals("<null>", new ToStringBuilder(base).append(array).toString());        assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append(array).toString());        assertEquals("{1,2,-3,4}", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals("<null>", new ToStringBuilder(base).append(array).toString());        assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append(array).toString());        assertEquals("{{1,2},<null>,{5}}", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals("<null>", new ToStringBuilder(base).append(array).toString());        assertEquals("<null>", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.EqualsBuilder}. * * @author <a href="mailto:sdowney@panix.com">Steve Downey</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EqualsBuilderTest.java,v 1.1 2002/09/12 22:00:35 scolebourne Exp $ */public class EqualsBuilderTest extends TestCase {    public EqualsBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(EqualsBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    static class TestObject {        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }    }    public void testReflectionEquals() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(EqualsBuilder.reflectionEquals(o1, o1));        assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));        o2.setA(4);        assertTrue(EqualsBuilder.reflectionEquals(o1, o2));        assertTrue(!EqualsBuilder.reflectionEquals(o1, this));                assertTrue(!EqualsBuilder.reflectionEquals(o1, null));        assertTrue(!EqualsBuilder.reflectionEquals(null, o2));        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));    }    public void testObject() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        o2.setA(4);        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, this).isEquals());                assertTrue(!new EqualsBuilder().append(o1, null).isEquals());        assertTrue(!new EqualsBuilder().append(null, o2).isEquals());        assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());    }    public void testLong() {        long o1 = 1L;        long o2 = 2L;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testInt() {        int o1 = 1;        int o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testShort() {        short o1 = 1;        short o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testChar() {        char o1 = 1;        char o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testByte() {        byte o1 = 1;        byte o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testDouble() {        double o1 = 1;        double o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());    }    public void testFloat() {        float o1 = 1;        float o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());    }    public void testBoolean() {        boolean o1 = true;        boolean o2 = false;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testObjectArray() {        TestObject[] obj1 = new TestObject[2];        obj1[0] = new TestObject(4);        obj1[1] = new TestObject(5);        TestObject[] obj2 = new TestObject[2];        obj2[0] = new TestObject(4);        obj2[1] = new TestObject(5);        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1].setA(6);        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testLongArray() {        long[] obj1 = new long[2];        obj1[0] = 5L;        obj1[1] = 6L;        long[] obj2 = new long[2];        obj2[0] = 5L;        obj2[1] = 6L;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testIntArray() {        int[] obj1 = new int[2];        obj1[0] = 5;        obj1[1] = 6;        int[] obj2 = new int[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testShortArray() {        short[] obj1 = new short[2];        obj1[0] = 5;        obj1[1] = 6;        short[] obj2 = new short[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testCharArray() {        char[] obj1 = new char[2];        obj1[0] = 5;        obj1[1] = 6;        char[] obj2 = new char[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testByteArray() {        byte[] obj1 = new byte[2];        obj1[0] = 5;        obj1[1] = 6;        byte[] obj2 = new byte[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testDoubleArray() {        double[] obj1 = new double[2];        obj1[0] = 5;        obj1[1] = 6;        double[] obj2 = new double[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testFloatArray() {        float[] obj1 = new float[2];        obj1[0] = 5;        obj1[1] = 6;        float[] obj2 = new float[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testBooleanArray() {        boolean[] obj1 = new boolean[2];        obj1[0] = true;        obj1[1] = false;        boolean[] obj2 = new boolean[2];        obj2[0] = true;        obj2[1] = false;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = true;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testMultiLongArray() {        long[][] array1 = new long[2][2];        long[][] array2 = new long[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiIntArray() {        int[][] array1 = new int[2][2];        int[][] array2 = new int[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiShortArray() {        short[][] array1 = new short[2][2];        short[][] array2 = new short[2][2];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiCharArray() {        char[][] array1 = new char[2][2];        char[][] array2 = new char[2][2];        for (char i = 0; i < array1.length; ++i) {            for (char j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiByteArray() {        byte[][] array1 = new byte[2][2];        byte[][] array2 = new byte[2][2];        for (byte i = 0; i < array1.length; ++i) {            for (byte j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiFloatArray() {        float[][] array1 = new float[2][2];        float[][] array2 = new float[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiDoubleArray() {        double[][] array1 = new double[2][2];        double[][] array2 = new double[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiBooleanArray() {        boolean[][] array1 = new boolean[2][2];        boolean[][] array2 = new boolean[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i == 1) || (j == 1);                array2[i][j] = (i == 1) || (j == 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = false;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testRaggedArray() {        long array1[][] = new long[2][];        long array2[][] = new long[2][];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            for (int j = 0; j < array1[i].length; ++j) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMixedArray() {        Object array1[] = new Object[2];        Object array2[] = new Object[2];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            for (int j = 0; j < 2; ++j) {                TestObject obj1 = new TestObject((i + 1) * (j + 1));                TestObject obj2 = new TestObject((i + 1) * (j + 1));                ((long[]) array1[i])[j] = (i + 1) * (j + 1);                ((long[]) array2[i])[j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        ((long[]) array1[1])[1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testObjectArrayHiddenByObject() {        TestObject[] array1 = new TestObject[2];        array1[0] = new TestObject(4);        array1[1] = new TestObject(5);        TestObject[] array2 = new TestObject[2];        array2[0] = new TestObject(4);        array2[1] = new TestObject(5);        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1].setA(6);        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testLongArrayHiddenByObject() {        long[] array1 = new long[2];        array1[0] = 5L;        array1[1] = 6L;        long[] array2 = new long[2];        array2[0] = 5L;        array2[1] = 6L;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testIntArrayHiddenByObject() {        int[] array1 = new int[2];        array1[0] = 5;        array1[1] = 6;        int[] array2 = new int[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testShortArrayHiddenByObject() {        short[] array1 = new short[2];        array1[0] = 5;        array1[1] = 6;        short[] array2 = new short[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testCharArrayHiddenByObject() {        char[] array1 = new char[2];        array1[0] = 5;        array1[1] = 6;        char[] array2 = new char[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testByteArrayHiddenByObject() {        byte[] array1 = new byte[2];        array1[0] = 5;        array1[1] = 6;        byte[] array2 = new byte[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testDoubleArrayHiddenByObject() {        double[] array1 = new double[2];        array1[0] = 5;        array1[1] = 6;        double[] array2 = new double[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testFloatArrayHiddenByObject() {        float[] array1 = new float[2];        array1[0] = 5;        array1[1] = 6;        float[] array2 = new float[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testBooleanArrayHiddenByObject() {        boolean[] array1 = new boolean[2];        array1[0] = true;        array1[1] = false;        boolean[] array2 = new boolean[2];        array2[0] = true;        array2[1] = false;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = true;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import org.apache.commons.lang.SystemUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: MultiLineToStringStyleTest.java,v 1.1 2002/09/17 22:07:50 scolebourne Exp $ */public class MultiLineToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public MultiLineToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(MultiLineToStringStyleTest.class);        suite.setName("DefaultToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.MULTI_LINE_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).toString());    }    public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "  b=4" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<Integer>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=[]" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=<size=0>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a={}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  a=3" + SystemUtils.LINE_SEPARATOR + "  b=4" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {<null>,5,{3,6}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {<null>,5,{3,6}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {1,2,-3,4}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {1,2,-3,4}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {{1,2},<null>,{5}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  {{1,2},<null>,{5}}" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[" + SystemUtils.LINE_SEPARATOR + "  <null>" + SystemUtils.LINE_SEPARATOR + "]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */// package org.apache.commons.lang.builderpackage org.apache.commons.lang.builder;import java.util.ArrayList;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ToStringStyle}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: NoFieldNamesToStringStyleTest.java,v 1.1 2002/09/17 22:07:50 scolebourne Exp $ */public class NoFieldNamesToStringStyleTest extends TestCase {    private final Integer base = new Integer(5);    private final String baseStr = base.getClass().getName() + "@" + Integer.toHexString(System.identityHashCode(base));        public NoFieldNamesToStringStyleTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(NoFieldNamesToStringStyleTest.class);        suite.setName("NoFieldNamesToStringStyle Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        ToStringBuilder.setDefaultStyle(ToStringStyle.NO_FIELD_NAMES_STYLE);    }    protected void tearDown() throws Exception {        super.tearDown();        ToStringBuilder.setDefaultStyle(ToStringStyle.DEFAULT_STYLE);    }    //----------------------------------------------------------------        public void testBlank() {        assertEquals(baseStr + "[]", new ToStringBuilder(base).toString());    }    public void testObject() {        Integer i3 = new Integer(3);        Integer i4 = new Integer(4);        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(i3).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append("a", (Object) null).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", i3).toString());        assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", i3).append("b", i4).toString());        assertEquals(baseStr + "[<Integer>]", new ToStringBuilder(base).append("a", i3, false).toString());        assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new ArrayList(), false).toString());        assertEquals(baseStr + "[[]]", new ToStringBuilder(base).append("a", new ArrayList(), true).toString());        assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", new HashMap(), false).toString());        assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", new HashMap(), true).toString());        assertEquals(baseStr + "[<size=0>]", new ToStringBuilder(base).append("a", (Object) new String[0], false).toString());        assertEquals(baseStr + "[{}]", new ToStringBuilder(base).append("a", (Object) new String[0], true).toString());    }    public void testLong() {        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append(3L).toString());        assertEquals(baseStr + "[3]", new ToStringBuilder(base).append("a", 3L).toString());        assertEquals(baseStr + "[3,4]", new ToStringBuilder(base).append("a", 3L).append("b", 4L).toString());    }    public void testObjectArray() {        Object[] array = new Object[] {null, base, new int[] {3, 6}};        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{<null>,5,{3,6}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArray() {        long[] array = new long[] {1, 2, -3, 4};        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{1,2,-3,4}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }    public void testLongArrayArray() {        long[][] array = new long[][] {{1, 2}, null, {5}};        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[{{1,2},<null>,{5}}]", new ToStringBuilder(base).append((Object) array).toString());        array = null;        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append(array).toString());        assertEquals(baseStr + "[<null>]", new ToStringBuilder(base).append((Object) array).toString());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import org.apache.commons.lang.builder.CompareToBuilder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.CompareToBuilder}. * * @author <a href="mailto:sdowney@panix.com">Steve Downey</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: CompareToBuilderTest.java,v 1.1 2002/09/15 10:27:06 scolebourne Exp $ */public class CompareToBuilderTest extends TestCase {  public CompareToBuilderTest(String name) {    super(name);  }     public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(CompareToBuilderTest.class);        suite.setName("CompareToBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    static class TestObject implements Comparable{        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }public int compareTo(Object o) {TestObject rhs = (TestObject) o;return (a < rhs.a) ? -1 : (a > rhs.a) ? +1 : 0;}    }    public void testReflectionCompare() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(4);        assertTrue(CompareToBuilder.reflectionCompare(o1, o1) == 0);        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) == 0);        o2.setA(5);        assertTrue(CompareToBuilder.reflectionCompare(o1, o2) < 0);        assertTrue(CompareToBuilder.reflectionCompare(o2, o1) > 0);    }    public void testReflectionCompareEx1() {        TestObject o1 = new TestObject(4);        try {            CompareToBuilder.reflectionCompare(o1, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testReflectionCompareEx2() {        TestObject o1 = new TestObject(4);        Object o2 = new Object();        try {            CompareToBuilder.reflectionCompare(o1, o2);        } catch (ClassCastException ex) {            return;        }        fail();    }    public void testObject() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(4);        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() == 0);        o2.setA(5);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);    }    public void testObjectEx1() {        TestObject o1 = new TestObject(4);        try {            new CompareToBuilder().append(o1, null).toComparison();        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testObjectEx2() {        TestObject o1 = new TestObject(4);        Object o2 = new Object();        try {            new CompareToBuilder().append(o1, o2).toComparison();        } catch (ClassCastException ex) {            return;        }        fail();    }    public void testLong() {        long o1 = 1L;        long o2 = 2L;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Long.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Long.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Long.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Long.MIN_VALUE, o1).toComparison() < 0);    }    public void testInt() {        int o1 = 1;        int o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Integer.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Integer.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Integer.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Integer.MIN_VALUE, o1).toComparison() < 0);    }    public void testShort() {        short o1 = 1;        short o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Short.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Short.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Short.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Short.MIN_VALUE, o1).toComparison() < 0);    }    public void testChar() {        char o1 = 1;        char o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Character.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Character.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Character.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Character.MIN_VALUE, o1).toComparison() < 0);    }    public void testByte() {        byte o1 = 1;        byte o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Byte.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Byte.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Byte.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Byte.MIN_VALUE, o1).toComparison() < 0);    }    public void testDouble() {        double o1 = 1;        double o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Double.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Double.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Double.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Double.MIN_VALUE, o1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Double.NaN, Double.NaN).toComparison() == 0);        assertTrue(new CompareToBuilder().append(Double.NaN, Double.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Double.POSITIVE_INFINITY, Double.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Double.NEGATIVE_INFINITY, Double.MIN_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o1, Double.NaN).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Double.NaN, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);    }    public void testFloat() {        float o1 = 1;        float o2 = 2;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Float.MAX_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Float.MAX_VALUE, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o1, Float.MIN_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Float.MIN_VALUE, o1).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Float.NaN, Float.NaN).toComparison() == 0);        assertTrue(new CompareToBuilder().append(Float.NaN, Float.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Float.POSITIVE_INFINITY, Float.MAX_VALUE).toComparison() > 0);        assertTrue(new CompareToBuilder().append(Float.NEGATIVE_INFINITY, Float.MIN_VALUE).toComparison() < 0);        assertTrue(new CompareToBuilder().append(o1, Float.NaN).toComparison() < 0);        assertTrue(new CompareToBuilder().append(Float.NaN, o1).toComparison() > 0);        assertTrue(new CompareToBuilder().append(-0.0, 0.0).toComparison() < 0);        assertTrue(new CompareToBuilder().append(0.0, -0.0).toComparison() > 0);    }    public void testBoolean() {        boolean o1 = true;        boolean o2 = false;        assertTrue(new CompareToBuilder().append(o1, o1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o2, o2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(o1, o2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(o2, o1).toComparison() < 0);    }    public void testObjectArray() {        TestObject[] obj1 = new TestObject[2];        obj1[0] = new TestObject(4);        obj1[1] = new TestObject(5);        TestObject[] obj2 = new TestObject[2];        obj2[0] = new TestObject(4);        obj2[1] = new TestObject(5);        TestObject[] obj3 = new TestObject[3];        obj3[0] = new TestObject(4);        obj3[1] = new TestObject(5);        obj3[2] = new TestObject(6);                assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = new TestObject(7);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testObjectArrayEx1() {        TestObject[] obj1 = new TestObject[2];        obj1[0] = new TestObject(4);        obj1[1] = new TestObject(5);        try {            new CompareToBuilder().append(obj1, null).toComparison();        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testLongArray() {        long[] obj1 = new long[2];        obj1[0] = 5L;        obj1[1] = 6L;        long[] obj2 = new long[2];        obj2[0] = 5L;        obj2[1] = 6L;        long[] obj3 = new long[3];        obj3[0] = 5L;        obj3[1] = 6L;        obj3[2] = 7L;                assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testIntArray() {        int[] obj1 = new int[2];        obj1[0] = 5;        obj1[1] = 6;        int[] obj2 = new int[2];        obj2[0] = 5;        obj2[1] = 6;        int[] obj3 = new int[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testShortArray() {        short[] obj1 = new short[2];        obj1[0] = 5;        obj1[1] = 6;        short[] obj2 = new short[2];        obj2[0] = 5;        obj2[1] = 6;        short[] obj3 = new short[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testCharArray() {        char[] obj1 = new char[2];        obj1[0] = 5;        obj1[1] = 6;        char[] obj2 = new char[2];        obj2[0] = 5;        obj2[1] = 6;        char[] obj3 = new char[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testByteArray() {        byte[] obj1 = new byte[2];        obj1[0] = 5;        obj1[1] = 6;        byte[] obj2 = new byte[2];        obj2[0] = 5;        obj2[1] = 6;        byte[] obj3 = new byte[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testDoubleArray() {        double[] obj1 = new double[2];        obj1[0] = 5;        obj1[1] = 6;        double[] obj2 = new double[2];        obj2[0] = 5;        obj2[1] = 6;        double[] obj3 = new double[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testFloatArray() {        float[] obj1 = new float[2];        obj1[0] = 5;        obj1[1] = 6;        float[] obj2 = new float[2];        obj2[0] = 5;        obj2[1] = 6;        float[] obj3 = new float[3];        obj3[0] = 5;        obj3[1] = 6;        obj3[2] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testBooleanArray() {        boolean[] obj1 = new boolean[2];        obj1[0] = true;        obj1[1] = false;        boolean[] obj2 = new boolean[2];        obj2[0] = true;        obj2[1] = false;        boolean[] obj3 = new boolean[3];        obj3[0] = true;        obj3[1] = false;        obj3[2] = true;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        obj1[1] = true;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testMultiLongArray() {        long[][] array1 = new long[2][2];        long[][] array2 = new long[2][2];        long[][] array3 = new long[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);                array3[i][j] = (i + 1) * (j + 1);            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiIntArray() {        int[][] array1 = new int[2][2];        int[][] array2 = new int[2][2];        int[][] array3 = new int[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);                array3[i][j] = (i + 1) * (j + 1);            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiShortArray() {        short[][] array1 = new short[2][2];        short[][] array2 = new short[2][2];        short[][] array3 = new short[2][3];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = (short)((i + 1) * (j + 1));                array2[i][j] = (short)((i + 1) * (j + 1));                array3[i][j] = (short)((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiCharArray() {        char[][] array1 = new char[2][2];        char[][] array2 = new char[2][2];        char[][] array3 = new char[2][3];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = (char)((i + 1) * (j + 1));                array2[i][j] = (char)((i + 1) * (j + 1));                array3[i][j] = (char)((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiByteArray() {        byte[][] array1 = new byte[2][2];        byte[][] array2 = new byte[2][2];        byte[][] array3 = new byte[2][3];        for (byte i = 0; i < array1.length; ++i) {            for (byte j = 0; j < array1[0].length; j++) {                array1[i][j] = (byte)((i + 1) * (j + 1));                array2[i][j] = (byte)((i + 1) * (j + 1));                array3[i][j] = (byte)((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 127;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }        public void testMultiFloatArray() {        float[][] array1 = new float[2][2];        float[][] array2 = new float[2][2];        float[][] array3 = new float[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = ((i + 1) * (j + 1));                array2[i][j] = ((i + 1) * (j + 1));                array3[i][j] = ((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 127;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiDoubleArray() {        double[][] array1 = new double[2][2];        double[][] array2 = new double[2][2];        double[][] array3 = new double[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = ((i + 1) * (j + 1));                array2[i][j] = ((i + 1) * (j + 1));                array3[i][j] = ((i + 1) * (j + 1));            }        }        array3[1][2] = 100;        array3[1][2] = 100;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 127;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMultiBooleanArray() {        boolean[][] array1 = new boolean[2][2];        boolean[][] array2 = new boolean[2][2];        boolean[][] array3 = new boolean[2][3];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = ((i == 1) ^ (j == 1));                array2[i][j] = ((i == 1) ^ (j == 1));                array3[i][j] = ((i == 1) ^ (j == 1));            }        }        array3[1][2] = false;        array3[1][2] = false;                assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = true;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testRaggedArray() {        long array1[][] = new long[2][];        long array2[][] = new long[2][];        long array3[][] = new long[3][];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            array3[i] = new long[3];            for (int j = 0; j < array1[i].length; ++j) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);                array3[i][j] = (i + 1) * (j + 1);            }        }        array3[1][2] = 100;        array3[1][2] = 100;                        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        array1[1][1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testMixedArray() {        Object array1[] = new Object[2];        Object array2[] = new Object[2];        Object array3[] = new Object[2];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            array3[i] = new long[3];            for (int j = 0; j < 2; ++j) {                ((long[]) array1[i])[j] = (i + 1) * (j + 1);                ((long[]) array2[i])[j] = (i + 1) * (j + 1);                ((long[]) array3[i])[j] = (i + 1) * (j + 1);            }        }        ((long[]) array3[0])[2] = 1;        ((long[]) array3[1])[2] = 1;        assertTrue(new CompareToBuilder().append(array1, array1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(array1, array3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(array3, array1).toComparison() > 0);        ((long[]) array1[1])[1] = 200;        assertTrue(new CompareToBuilder().append(array1, array2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(array2, array1).toComparison() < 0);    }    public void testObjectArrayHiddenByObject() {        TestObject[] array1 = new TestObject[2];        array1[0] = new TestObject(4);        array1[1] = new TestObject(5);        TestObject[] array2 = new TestObject[2];        array2[0] = new TestObject(4);        array2[1] = new TestObject(5);        TestObject[] array3 = new TestObject[3];        array3[0] = new TestObject(4);        array3[1] = new TestObject(5);        array3[2] = new TestObject(6);                Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;                assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = new TestObject(7);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testLongArrayHiddenByObject() {        long[] array1 = new long[2];        array1[0] = 5L;        array1[1] = 6L;        long[] array2 = new long[2];        array2[0] = 5L;        array2[1] = 6L;        long[] array3 = new long[3];        array3[0] = 5L;        array3[1] = 6L;        array3[2] = 7L;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testIntArrayHiddenByObject() {        int[] array1 = new int[2];        array1[0] = 5;        array1[1] = 6;        int[] array2 = new int[2];        array2[0] = 5;        array2[1] = 6;        int[] array3 = new int[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testShortArrayHiddenByObject() {        short[] array1 = new short[2];        array1[0] = 5;        array1[1] = 6;        short[] array2 = new short[2];        array2[0] = 5;        array2[1] = 6;        short[] array3 = new short[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testCharArrayHiddenByObject() {        char[] array1 = new char[2];        array1[0] = 5;        array1[1] = 6;        char[] array2 = new char[2];        array2[0] = 5;        array2[1] = 6;        char[] array3 = new char[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testByteArrayHiddenByObject() {        byte[] array1 = new byte[2];        array1[0] = 5;        array1[1] = 6;        byte[] array2 = new byte[2];        array2[0] = 5;        array2[1] = 6;        byte[] array3 = new byte[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testDoubleArrayHiddenByObject() {        double[] array1 = new double[2];        array1[0] = 5;        array1[1] = 6;        double[] array2 = new double[2];        array2[0] = 5;        array2[1] = 6;        double[] array3 = new double[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testFloatArrayHiddenByObject() {        float[] array1 = new float[2];        array1[0] = 5;        array1[1] = 6;        float[] array2 = new float[2];        array2[0] = 5;        array2[1] = 6;        float[] array3 = new float[3];        array3[0] = 5;        array3[1] = 6;        array3[2] = 7;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = 7;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }    public void testBooleanArrayHiddenByObject() {        boolean[] array1 = new boolean[2];        array1[0] = true;        array1[1] = false;        boolean[] array2 = new boolean[2];        array2[0] = true;        array2[1] = false;        boolean[] array3 = new boolean[3];        array3[0] = true;        array3[1] = false;        array3[2] = true;        Object obj1 = array1;        Object obj2 = array2;        Object obj3 = array3;        assertTrue(new CompareToBuilder().append(obj1, obj1).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() == 0);        assertTrue(new CompareToBuilder().append(obj1, obj3).toComparison() < 0);        assertTrue(new CompareToBuilder().append(obj3, obj1).toComparison() > 0);        array1[1] = true;        assertTrue(new CompareToBuilder().append(obj1, obj2).toComparison() > 0);        assertTrue(new CompareToBuilder().append(obj2, obj1).toComparison() < 0);    }   }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: StringUtilsIsTest.java,v 1.2 2002/10/28 04:33:29 bayard Exp $ */public class StringUtilsIsTest extends TestCase {    public StringUtilsIsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsIsTest.class);    suite.setName("StringUtilsIsXxx Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testIsAlpha() {        assertEquals(false, StringUtils.isAlpha(null));        assertEquals(true, StringUtils.isAlpha(""));        assertEquals(false, StringUtils.isAlpha(" "));        assertEquals(true, StringUtils.isAlpha("a"));        assertEquals(true, StringUtils.isAlpha("A"));        assertEquals(true, StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isAlpha("ham kso"));        assertEquals(false, StringUtils.isAlpha("1"));        assertEquals(false, StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlpha("_"));        assertEquals(false, StringUtils.isAlpha("hkHKHik*khbkuh"));    }    public void testIsAlphanumeric() {        assertEquals(false, StringUtils.isAlphanumeric(null));        assertEquals(true, StringUtils.isAlphanumeric(""));        assertEquals(false, StringUtils.isAlphanumeric(" "));        assertEquals(true, StringUtils.isAlphanumeric("a"));        assertEquals(true, StringUtils.isAlphanumeric("A"));        assertEquals(true, StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isAlphanumeric("ham kso"));        assertEquals(true, StringUtils.isAlphanumeric("1"));        assertEquals(true, StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphanumeric("_"));        assertEquals(false, StringUtils.isAlphanumeric("hkHKHik*khbkuh"));    }    public void testIsWhitespace() {        assertEquals(false, StringUtils.isWhitespace(null));        assertEquals(true, StringUtils.isWhitespace(""));        assertEquals(true, StringUtils.isWhitespace(" "));        assertEquals(true, StringUtils.isWhitespace("\t \n \t"));        assertEquals(false, StringUtils.isWhitespace("\t aa\n \t"));        assertEquals(true, StringUtils.isWhitespace(" "));        assertEquals(false, StringUtils.isWhitespace(" a "));        assertEquals(false, StringUtils.isWhitespace("a  "));        assertEquals(false, StringUtils.isWhitespace("  a"));        assertEquals(false, StringUtils.isWhitespace("aba"));    }    public void testIsTrue() {        assertEquals(false, StringUtils.isTrue(null));        assertEquals(false, StringUtils.isTrue(""));        assertEquals(false, StringUtils.isTrue("off"));        assertEquals(false, StringUtils.isTrue("oof"));        assertEquals(true, StringUtils.isTrue("true"));        assertEquals(true, StringUtils.isTrue("yes"));        assertEquals(true, StringUtils.isTrue("on"));    }    public void testIsAlphaspace() {        assertEquals(false, StringUtils.isAlphaSpace(null));        assertEquals(true, StringUtils.isAlphaSpace(""));        assertEquals(true, StringUtils.isAlphaSpace(" "));        assertEquals(true, StringUtils.isAlphaSpace("a"));        assertEquals(true, StringUtils.isAlphaSpace("A"));        assertEquals(true, StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(true, StringUtils.isAlphaSpace("ham kso"));        assertEquals(false, StringUtils.isAlphaSpace("1"));        assertEquals(false, StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphaSpace("_"));        assertEquals(false, StringUtils.isAlphaSpace("hkHKHik*khbkuh"));    }    public void testIsAlphanumericSpace() {        assertEquals(false, StringUtils.isAlphanumericSpace(null));        assertEquals(true, StringUtils.isAlphanumericSpace(""));        assertEquals(true, StringUtils.isAlphanumericSpace(" "));        assertEquals(true, StringUtils.isAlphanumericSpace("a"));        assertEquals(true, StringUtils.isAlphanumericSpace("A"));        assertEquals(true, StringUtils.isAlphanumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(true, StringUtils.isAlphanumericSpace("ham kso"));        assertEquals(true, StringUtils.isAlphanumericSpace("1"));        assertEquals(true, StringUtils.isAlphanumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphanumericSpace("_"));        assertEquals(false, StringUtils.isAlphanumericSpace("hkHKHik*khbkuh"));    }    public void testIsNumeric() {        assertEquals(false, StringUtils.isNumeric(null));        assertEquals(true, StringUtils.isNumeric(""));        assertEquals(false, StringUtils.isNumeric(" "));        assertEquals(false, StringUtils.isNumeric("a"));        assertEquals(false, StringUtils.isNumeric("A"));        assertEquals(false, StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isNumeric("ham kso"));        assertEquals(true, StringUtils.isNumeric("1"));        assertEquals(true, StringUtils.isNumeric("1000"));        assertEquals(false, StringUtils.isNumeric("2.3"));        assertEquals(false, StringUtils.isNumeric("10 00"));        assertEquals(false, StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isNumeric("_"));        assertEquals(false, StringUtils.isNumeric("hkHKHik*khbkuh"));    }    public void testIsNumericSpace() {        assertEquals(false, StringUtils.isNumericSpace(null));        assertEquals(true, StringUtils.isNumericSpace(""));        assertEquals(true, StringUtils.isNumericSpace(" "));        assertEquals(false, StringUtils.isNumericSpace("a"));        assertEquals(false, StringUtils.isNumericSpace("A"));        assertEquals(false, StringUtils.isNumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isNumericSpace("ham kso"));        assertEquals(true, StringUtils.isNumericSpace("1"));        assertEquals(true, StringUtils.isNumericSpace("1000"));        assertEquals(false, StringUtils.isNumericSpace("2.3"));        assertEquals(true, StringUtils.isNumericSpace("10 00"));        assertEquals(false, StringUtils.isNumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isNumericSpace("_"));        assertEquals(false, StringUtils.isNumericSpace("hkHKHik*khbkuh"));    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ObjectUtils}. * * @author <a href="mailto:jmcnally@collab.net">John McNally</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: ObjectUtilsTest.java,v 1.3 2002/09/18 20:12:15 scolebourne Exp $ */public class ObjectUtilsTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    public ObjectUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(ObjectUtilsTest.class);        suite.setName("ObjectUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testIsNull() {        Object o = FOO;        Object dflt = BAR;        assertSame("dflt was not returned when o was null", dflt, ObjectUtils.defaultIfNull(null, dflt));        assertSame("dflt was returned when o was not null", o, ObjectUtils.defaultIfNull(o, dflt));    }    public void testEquals() {        assertTrue("ObjectUtils.equals(null, null) returned false", ObjectUtils.equals(null, null));        assertTrue("ObjectUtils.equals(\"foo\", null) returned true", !ObjectUtils.equals(FOO, null));        assertTrue("ObjectUtils.equals(null, \"bar\") returned true", !ObjectUtils.equals(null, BAR));        assertTrue("ObjectUtils.equals(\"foo\", \"bar\") returned true", !ObjectUtils.equals(FOO, BAR));        assertTrue("ObjectUtils.equals(\"foo\", \"foo\") returned false", ObjectUtils.equals(FOO, FOO));    }    public void testIdentityToString() {        assertEquals(            "java.lang.String@" + Integer.toHexString(System.identityHashCode(FOO)),            ObjectUtils.identityToString(FOO));        Integer i = new Integer(90);        assertEquals(            "java.lang.Integer@" + Integer.toHexString(System.identityHashCode(i)),            ObjectUtils.identityToString(i));        assertEquals(null, ObjectUtils.identityToString(null));    }    public void testNull() {        assertTrue(ObjectUtils.NULL != null);        assertTrue(ObjectUtils.NULL instanceof ObjectUtils.Null);        assertSame(ObjectUtils.NULL, SerializationUtils.clone(ObjectUtils.NULL));    }   }
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.CharSetUtils}. * * @author <a href="mailto:bayard@generationjava.com">Henri Yandell</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: CharSetUtilsTest.java,v 1.4 2002/09/29 07:13:07 bayard Exp $ */public class CharSetUtilsTest extends TestCase{    public CharSetUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(CharSetUtilsTest.class);    suite.setName("CharSetUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSqueeze()    {        assertEquals("squeeze(String,String[]) failed",                     "helo", CharSetUtils.squeeze("hello", new String[] {"el"}));        assertEquals("squeeze(String,String[]) failed",                     "", CharSetUtils.squeeze("", new String[] {"el"}));        assertEquals("squeeze(String,String[]) failed",                     "hello", CharSetUtils.squeeze("hello", new String[] {"e"}));        assertEquals("squeeze(String,String[]) failed",                     "fofof", CharSetUtils.squeeze("fooffooff", new String[] {"of"}));        assertEquals("squeeze(String,String[]) failed",                     "fof", CharSetUtils.squeeze("fooooff", new String[] {"fo"}));    }    public void testCount()    {        assertEquals("count(String,String[]) failed",                     3, CharSetUtils.count("hello", new String[] {"el"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("", new String[] {"el"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("hello", new String[] {"x"}));        assertEquals("count(String,String[]) failed",                     2, CharSetUtils.count("hello", new String[] {"e-i"}));        assertEquals("count(String,String[]) failed",                     5, CharSetUtils.count("hello", new String[] {"a-z"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("hello", new String[] {""}));    }    public void testDelete()    {        assertEquals("delete(String,String[]) failed",                     "ho", CharSetUtils.delete("hello", new String[] {"el"}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("hello", new String[] {"elho"}));        assertEquals("delete(String,String[]) failed",                     "hello", CharSetUtils.delete("hello", new String[] {""}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("hello", new String[] {"a-z"}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("----", new String[] {"-"}));        assertEquals("delete(String,String[]) failed",                     "heo", CharSetUtils.delete("hello", new String[] {"l"}));    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.SerializationUtils}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author Moritz Petersen * @version $Id: ArrayUtilsTest.java,v 1.1 2002/10/13 22:42:59 scolebourne Exp $ */public class ArrayUtilsTest extends TestCase {    public ArrayUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(ArrayUtilsTest.class);    suite.setName("ArrayUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testToMap() {        Map map = ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"hello", "world"}});                assertEquals("bar", map.get("foo"));        assertEquals("world", map.get("hello"));                try {            ArrayUtils.toMap(null);            fail("exception expected");        } catch (IllegalArgumentException e) {            // expected.        }                try {            ArrayUtils.toMap(new String[][] {{"foo", "bar"}, {"short"}});            fail("exception expected");        } catch (IllegalArgumentException e) {            // expected.        }                try {            ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, "illegal type"});            fail("exception expected");        } catch (IllegalArgumentException e) {            // expected.        }                try {            ArrayUtils.toMap(new Object[] {new Object[] {"foo", "bar"}, null});            fail("exception expected");        } catch (IllegalArgumentException e) {            // expected.        }                map = ArrayUtils.toMap(new Object[] {new Map.Entry() {            public Object getKey() {                return "foo";            }            public Object getValue() {                return "bar";            }            public Object setValue(Object value) {                throw new UnsupportedOperationException();            }            public boolean equals(Object o) {                throw new UnsupportedOperationException();            }            public int hashCode() {                throw new UnsupportedOperationException();            }        }});        assertEquals("bar", map.get("foo"));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsEqualsIndexOfTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class StringUtilsEqualsIndexOfTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String FOOBAR = "foobar";    private static final String[] FOOBAR_SUB_ARRAY = new String[] {"ob", "ba"};    public StringUtilsEqualsIndexOfTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsEqualsIndexOfTest.class);    suite.setName("StringUtilsEqualsIndexOf Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testEquals() {        assertEquals(true, StringUtils.equals(null, null));        assertEquals(true, StringUtils.equals(FOO, FOO));        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));        assertEquals(false, StringUtils.equals(FOO, BAR));        assertEquals(false, StringUtils.equals(FOO, null));        assertEquals(false, StringUtils.equals(null, FOO));    }    public void testEqualsIgnoreCase() {        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));    }    public void testIndexOfAny() {        assertEquals(-1, StringUtils.indexOfAny(null, null));        assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, null));        assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {"llll"}));    }    public void testLastIndexOfAny() {        assertEquals(-1, StringUtils.lastIndexOfAny(null, null));        assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, null));        assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {"llll"}));    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils}. * * @author <a href="mailto:dlr@collab.net">Daniel Rall</a> * @author <a href="mailto:bayard@generationjava.com">Henri Yandell</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @author <a href="mailto:fredrik@westermarck.com>Fredrik Westermarck</a> * @version $Id: StringUtilsTest.java,v 1.6 2002/10/28 04:33:29 bayard Exp $ */public class StringUtilsTest extends TestCase{    private static final String[] ARRAY_LIST = { "foo", "bar", "baz" };    private static final String SEPARATOR = ",";    private static final String TEXT_LIST = "foo,bar,baz";    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String CAP_FOO = "Foo";    private static final String UPPER_FOO = "FOO";    private static final String SENTENCE = "foo bar baz";    public StringUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsTest.class);    suite.setName("StringUtilsTest Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testCaseFunctions()    {        assertEquals("capitalise(String) failed",                     CAP_FOO, StringUtils.capitalise(FOO) );        assertEquals("capitalise(empty-string) failed",                     "", StringUtils.capitalise("") );        assertEquals("capitaliseAllWords(String) failed",                     "Foo Bar Baz", StringUtils.capitaliseAllWords(SENTENCE) );        assertEquals("capitaliseAllWords(empty-string) failed",                     "", StringUtils.capitaliseAllWords("") );        assertEquals("uncapitalise(String) failed",                     FOO, StringUtils.uncapitalise(CAP_FOO) );        assertEquals("uncapitalise(empty-string) failed",                     "", StringUtils.uncapitalise("") );        assertEquals("uncapitaliseAllWords(String) failed",                     SENTENCE, StringUtils.uncapitaliseAllWords("Foo Bar Baz") );        assertEquals("uncapitaliseAllWords(empty-string) failed",                     "", StringUtils.uncapitaliseAllWords("") );        assertEquals("upperCase(String) failed",                     "FOO TEST THING", StringUtils.upperCase("fOo test THING") );        assertEquals("upperCase(empty-string) failed",                     "", StringUtils.upperCase("") );        assertEquals("lowerCase(String) failed",                     "foo test thing", StringUtils.lowerCase("fOo test THING") );        assertEquals("lowerCase(empty-string) failed",                     "", StringUtils.lowerCase("") );        assertEquals("swapCase(empty-string) failed",                     "", StringUtils.swapCase("") );        assertEquals("swapCase(String-with-numbers) failed",                     "a123RgYu", StringUtils.swapCase("A123rGyU") );        assertEquals("swapCase(String) failed",                     "Hello aPACHE", StringUtils.swapCase("hELLO Apache") );    }    public void testJoin()    {        assertEquals("concatenate(Object[]) failed",                      "foobarbaz", StringUtils.concatenate(ARRAY_LIST));        assertEquals("join(Object[], String) failed", TEXT_LIST,                     StringUtils.join(ARRAY_LIST, SEPARATOR));        assertEquals("join(Iterator, String) failed", TEXT_LIST,                     StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),                                      SEPARATOR));    }    public void testSplit()    {        String[] result = StringUtils.split(TEXT_LIST, SEPARATOR, 2);        String[] expected = { "foo", "bar,baz" };        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split(TEXT_LIST, SEPARATOR, 0);        expected = ARRAY_LIST;        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split(TEXT_LIST, SEPARATOR, -1);        expected = ARRAY_LIST;        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }    }    public void testReplaceFunctions()    {        assertEquals("replace(String, String, String, int) failed",                     FOO, StringUtils.replace("oo" + FOO, "o", "", 2));        assertEquals("replace(String, String, String) failed",                     "", StringUtils.replace(FOO + FOO + FOO, FOO, ""));        assertEquals("replaceOnce(String, String, String) failed",                     FOO, StringUtils.replaceOnce(FOO + FOO, FOO, ""));    }    public void testOverlayString()    {        assertEquals("overlayString(String, String, int, int) failed",                     "foo foor baz", StringUtils.overlayString(SENTENCE, FOO, 4, 6) );    }    public void testRepeat()    {        assertEquals("repeat(String, int) failed",                     FOO + FOO + FOO, StringUtils.repeat(FOO, 3) );    }    public void testCenter()    {        assertEquals("center(String, int) failed",                     "   "+FOO+"   ", StringUtils.center(FOO, 9) );    }    public void testChompFunctions()    {        assertEquals("chomp(String) failed",                     FOO, StringUtils.chomp(FOO + "\n" + FOO) );        assertEquals("chompLast(String) failed",                     FOO, StringUtils.chompLast(FOO + "\n") );        assertEquals("getChomp(String, String) failed",                     "\n" + FOO, StringUtils.getChomp(FOO + "\n" + FOO, "\n") );        assertEquals("prechomp(String, String) failed",                     FOO, StringUtils.prechomp(FOO + "\n" + FOO, "\n") );        assertEquals("getPrechomp(String, String) failed",                     FOO + "\n", StringUtils.getPrechomp(FOO + "\n" + FOO, "\n") );        assertEquals("chop(String, String) failed",                     FOO, StringUtils.chop(FOO + "\r\n") );        assertEquals("chopNewline(String, String) failed",                     FOO, StringUtils.chopNewline(FOO + "\r\n") );    }    public void testPadFunctions()    {        assertEquals("rightPad(String, int) failed",                     "1234    ", StringUtils.rightPad ("1234", 8) );        assertEquals("rightPad(String, int, String) failed",                     "1234-+-+", StringUtils.rightPad ("1234", 8, "-+") );        assertEquals("rightPad(String, int, String) failed",                     "123456-+~", StringUtils.rightPad ("123456", 9, "-+~") );        assertEquals("leftPad(String, int) failed",                     "    1234", StringUtils.leftPad("1234", 8) );        assertEquals("leftPad(String, int, String) failed",                     "-+-+1234", StringUtils.leftPad("1234", 8, "-+") );        assertEquals("leftPad(String, int, String) failed",                     "-+~123456", StringUtils.leftPad("123456", 9, "-+~") );    }    public void testReverseFunctions() {        assertEquals("reverse(String) failed",                     "sdrawkcab", StringUtils.reverse("backwards") );        assertEquals("reverse(empty-string) failed",                     "", StringUtils.reverse("") );        assertEquals("reverseDelimitedString(String,'.') failed",                     "org.apache.test",                        StringUtils.reverseDelimitedString("test.apache.org", ".") );        assertEquals("reverseDelimitedString(empty-string,'.') failed",                     "",                        StringUtils.reverseDelimitedString("", ".") );        assertEquals("reverseDelimitedString(String,' ') failed",                     "once upon a time",                        StringUtils.reverseDelimitedString("time a upon once"," ") );    }    public void testDefaultFunctions() {        assertEquals("defaultString(empty-string) failed",                     "", StringUtils.defaultString("") );        assertEquals("defaultString(String) failed",                     FOO, StringUtils.defaultString(FOO) );        assertEquals("defaultString(null) failed",                     "", StringUtils.defaultString(null) );        assertEquals("defaultString(empty-string,String) failed",                     "", StringUtils.defaultString("", BAR) );        assertEquals("defaultString(String,String) failed",                     FOO, StringUtils.defaultString(FOO, BAR) );        assertEquals("defaultString(null,String) failed",                     BAR, StringUtils.defaultString(null, BAR) );    }    public void testEscapeFunctions() {        assertEquals("escape(empty-string) failed",                     "", StringUtils.escape("") );        assertEquals("escape(String) failed",                     FOO, StringUtils.escape(FOO) );        assertEquals("escape(String) failed",                     "\\t", StringUtils.escape("\t") );        assertEquals("escape(String) failed",                     "\\\\", StringUtils.escape("\\") );        assertEquals("escape(String) failed",                     "\\\\\\b\\t\\r", StringUtils.escape("\\\b\t\r") );        assertEquals("escape(String) failed",                     "\\u1234", StringUtils.escape("\u1234") );        assertEquals("escape(String) failed",                     "\\u0234", StringUtils.escape("\u0234") );        assertEquals("escape(String) failed",                     "\\u00fd", StringUtils.escape("\u00fd") );    }    public void testGetLevenshteinDistance() {        assertEquals("getLevenshteinDistance(empty-string, empty-string) failed",                     0, StringUtils.getLevenshteinDistance("", "") );        assertEquals("getLevenshteinDistance(empty-string, String) failed",                     1, StringUtils.getLevenshteinDistance("", "a") );        assertEquals("getLevenshteinDistance(String, empty-string) failed",                     7, StringUtils.getLevenshteinDistance("aaapppp", "") );        assertEquals("getLevenshteinDistance(String, String) failed",                     1, StringUtils.getLevenshteinDistance("frog", "fog") );        assertEquals("getLevenshteinDistance(String, String) failed",                     3, StringUtils.getLevenshteinDistance("fly", "ant") );        assertEquals("getLevenshteinDistance(String, String) failed",                     7, StringUtils.getLevenshteinDistance("elephant", "hippo") );        assertEquals("getLevenshteinDistance(String, String) failed",                     7, StringUtils.getLevenshteinDistance("hippo", "elephant") );        assertEquals("getLevenshteinDistance(String, String) failed",                     1, StringUtils.getLevenshteinDistance("hello", "hallo") );    }    public void testContainsOnly() {        String str1 = "a";        String str2 = "b";        String str3 = "ab";        char[] chars1= {'b'};        char[] chars2= {'a'};        char[] chars3= {'a', 'b'};        char[] emptyChars = new char[0];        assertEquals("containsOnly(null, null) failed", false, StringUtils.containsOnly(null, null));        assertEquals("containsOnly(empty-string, null) failed", false, StringUtils.containsOnly("", null));        assertEquals("containsOnly(null, empty-string) failed", false, StringUtils.containsOnly(null, emptyChars));        assertEquals("containsOnly(str1, empty-char-array) failed", false, StringUtils.containsOnly(str1, emptyChars));        assertEquals("containsOnly(empty-string, empty-char-array) failed", true, StringUtils.containsOnly("", emptyChars));        assertEquals("containsOnly(empty-string, chars1) failed", true, StringUtils.containsOnly("", chars1));        assertEquals("containsOnly(str1, chars1) failed", false, StringUtils.containsOnly(str1, chars1));        assertEquals("containsOnly(str1, chars1) failed", false, StringUtils.containsOnly(str1, chars1));        assertEquals("containsOnly(str1, chars1) success", true, StringUtils.containsOnly(str1, chars2));        assertEquals("containsOnly(str1, chars1) success", true, StringUtils.containsOnly(str1, chars3));        assertEquals("containsOnly(str2, chars2) success", true, StringUtils.containsOnly(str2, chars1));        assertEquals("containsOnly(str2, chars2) failed", false, StringUtils.containsOnly(str2, chars2));        assertEquals("containsOnly(str2, chars2) success", true, StringUtils.containsOnly(str2, chars3));        assertEquals("containsOnly(String3, chars3) failed", false, StringUtils.containsOnly(str3, chars1));        assertEquals("containsOnly(String3, chars3) failed", false, StringUtils.containsOnly(str3, chars2));        assertEquals("containsOnly(String3, chars3) success", true, StringUtils.containsOnly(str3, chars3));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Trim/Empty methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsTrimEmptyTest.java,v 1.5 2002/09/27 06:08:16 bayard Exp $ */public class StringUtilsTrimEmptyTest extends TestCase {    private static final String FOO = "foo";    public StringUtilsTrimEmptyTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsTrimEmptyTest.class);    suite.setName("StringUtilsTrimEmpty Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testClean() {        assertEquals(FOO, StringUtils.clean(FOO + "  "));        assertEquals(FOO, StringUtils.clean(" " + FOO + "  "));        assertEquals(FOO, StringUtils.clean(" " + FOO));        assertEquals(FOO, StringUtils.clean(FOO + ""));        assertEquals("", StringUtils.clean(null));    }    public void testTrim() {        assertEquals(FOO, StringUtils.trim(FOO + "  "));        assertEquals(FOO, StringUtils.trim(" " + FOO + "  "));        assertEquals(FOO, StringUtils.trim(" " + FOO));        assertEquals(FOO, StringUtils.trim(FOO + ""));        assertEquals(null, StringUtils.trim(null));    }    public void testIsNotEmpty() {        assertEquals(true, StringUtils.isNotEmpty(FOO));        assertEquals(true, StringUtils.isNotEmpty(" "));        assertEquals(false, StringUtils.isNotEmpty(""));        assertEquals(false, StringUtils.isNotEmpty(null));    }    public void testIsEmpty() {        assertEquals(false, StringUtils.isEmpty(FOO));        assertEquals(true, StringUtils.isEmpty(" "));        assertEquals(true, StringUtils.isEmpty(""));        assertEquals(true, StringUtils.isEmpty(null));    }    public void testDeleteSpace() {        assertEquals("deleteWhitespace(String) failed",                     "", StringUtils.deleteWhitespace(""));        assertEquals("deleteWhitespace(String) failed",                     "", StringUtils.deleteWhitespace("  \u000C  \t\t\u001F\n\n \u000B  "));        // Note: u-2007 and u-000A both cause problems in the source code        // it should ignore 2007 but delete 000A        assertEquals("deleteWhitespace(String) failed",                     "\u00A0\u202F", StringUtils.deleteWhitespace("  \u00A0  \t\t\n\n \u202F  "));        assertEquals("deleteWhitespace(String) failed",                     "\u00A0\u202F", StringUtils.deleteWhitespace("\u00A0\u202F"));        assertEquals("deleteWhitespace(String) failed",                     "test", StringUtils.deleteWhitespace("\u000Bt  \t\n\u0009e\rs\n\n   \tt"));        assertEquals("deleteSpaces(String) failed",                     "", StringUtils.deleteSpaces(""));        assertEquals("deleteSpaces(String) failed",                     "", StringUtils.deleteSpaces("    \t\t\n\n   "));        assertEquals("deleteSpaces(String) failed",                     "test", StringUtils.deleteSpaces("t  \t\ne\rs\n\n   \tt"));    }    public void testStrip() {        // it's important that foo2Space is fooLeftSpace and fooRightSpace         // merged together. So same number of spaces to left as fLS and same         // to right as fLS. Same applies for foo2Dots.        String foo2Space = "    "+FOO+"    ";        String foo2Dots = "......"+FOO+".........";        String fooLeftSpace = "    "+FOO;        String fooLeftDots = "......"+FOO;        String fooRightSpace = FOO+"    ";        String fooRightDots = FOO+".........";        assertEquals("", StringUtils.strip(""));        assertEquals("", StringUtils.strip("        "));        assertEquals(FOO, StringUtils.strip(foo2Space));        assertEquals(FOO, StringUtils.strip(foo2Dots, "."));        assertEquals(FOO, StringUtils.strip(fooRightSpace));        assertEquals(FOO, StringUtils.strip(fooRightDots, "."));        assertEquals(FOO, StringUtils.strip(fooLeftSpace));        assertEquals(FOO, StringUtils.strip(fooLeftDots, "."));        assertEquals("", StringUtils.stripStart("", " "));        assertEquals(fooRightSpace, StringUtils.stripStart(foo2Space, " "));        assertEquals(fooRightDots, StringUtils.stripStart(foo2Dots, "."));        assertEquals(fooRightSpace, StringUtils.stripStart(fooRightSpace, " "));        assertEquals(fooRightDots, StringUtils.stripStart(fooRightDots, "."));        assertEquals(FOO, StringUtils.stripStart(fooLeftSpace, " "));        assertEquals(FOO, StringUtils.stripStart(fooLeftDots, "."));        assertEquals("", StringUtils.stripEnd("", " "));        assertEquals(fooLeftSpace, StringUtils.stripEnd(foo2Space, " "));        assertEquals(fooLeftDots, StringUtils.stripEnd(foo2Dots, "."));        assertEquals(FOO, StringUtils.stripEnd(fooRightSpace, " "));        assertEquals(FOO, StringUtils.stripEnd(fooRightDots, "."));        assertEquals(fooLeftSpace, StringUtils.stripEnd(fooLeftSpace, " "));        assertEquals(fooLeftDots, StringUtils.stripEnd(fooLeftDots, "."));        assertEquals(FOO, StringUtils.strip(". . . . ."+FOO+". . ", " ."));        assertEquals("-."+FOO, StringUtils.strip(". . . . -."+FOO+". . ", " ."));        assertEquals(FOO, StringUtils.strip("..  .."+FOO+".. ", " ."));        assertEquals(FOO, StringUtils.strip("..  .."+FOO+".. ", "+= ."));        // test stripAll method, merely an array version of the above strip        String[] empty = new String[0];        String[] fooSpace = new String[] { foo2Space, fooLeftSpace, fooRightSpace };        String[] fooDots = new String[] { foo2Dots, fooLeftDots, fooRightDots };        String[] foo = new String[] { FOO, FOO, FOO };        assertArrayEquals(empty, StringUtils.stripAll(empty));        assertArrayEquals(foo, StringUtils.stripAll(fooSpace));        assertArrayEquals(foo, StringUtils.stripAll(fooDots, "."));    }    private void assertArrayEquals(Object[] o1, Object[] o2) {        if(o1 == null) {            assertEquals(o1,o2);            return;        }        assertEquals("Length not equal. ", o1.length, o2.length);        int sz = o1.length;        for(int i=0; i<sz; i++) {            if(o1[i] instanceof Object[]) {                // do an assert equals on type....                assertArrayEquals( (Object[]) o1[i], (Object[]) o2[i] );            } else {                assertEquals(o1[i], o2[i]);            }        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsSubstringTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class StringUtilsSubstringTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String BAZ = "baz";    private static final String FOOBAR = "foobar";    private static final String SENTENCE = "foo bar baz";    public StringUtilsSubstringTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsSubstringTest.class);    suite.setName("StringUtilsSubstring Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSubstring2() {        assertEquals("", StringUtils.substring(SENTENCE, 80));        assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));        assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));    }        public void testSubstring3() {        assertEquals("", StringUtils.substring(SENTENCE, 8, 6));        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));        assertEquals("o", StringUtils.substring(SENTENCE, -9, 3));        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));        assertEquals("o", StringUtils.substring(SENTENCE, -9, -8));        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));    }        public void testLeft() {        assertSame(null, StringUtils.left(null, 0));        assertSame(null, StringUtils.left(null, 2));        assertSame("", StringUtils.left("", 0));        assertSame("", StringUtils.left("", 2));        assertEquals("", StringUtils.left(FOOBAR, 0));        assertEquals(FOO, StringUtils.left(FOOBAR, 3));        assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));    }        public void testLeftEx() {        try {            StringUtils.left(FOOBAR, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testRight() {        assertSame(null, StringUtils.right(null, 0));        assertSame(null, StringUtils.right(null, 2));        assertSame("", StringUtils.right("", 0));        assertSame("", StringUtils.right("", 2));        assertEquals("", StringUtils.right(FOOBAR, 0));        assertEquals(BAR, StringUtils.right(FOOBAR, 3));        assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));    }        public void testRightEx() {        try {            StringUtils.right(FOOBAR, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMid() {        assertSame(null, StringUtils.mid(null, 3, 0));        assertSame(null, StringUtils.mid(null, 3, 2));        assertSame("", StringUtils.mid("", 0, 0));        assertSame("", StringUtils.mid("", 0, 2));        assertEquals("", StringUtils.mid(FOOBAR, 3, 0));        assertEquals("b", StringUtils.mid(FOOBAR, 3, 1));        assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));        assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));    }        public void testMidEx1() {        try {            StringUtils.mid(FOOBAR, 0, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMidEx2() {        try {            StringUtils.mid(FOOBAR, -1, 3);        } catch (IndexOutOfBoundsException ex) {            return;        }        fail();    }    public void testMidEx3() {        try {            StringUtils.mid(FOOBAR, 7, 3);        } catch (IndexOutOfBoundsException ex) {            return;        }        fail();    }    public void testCountMatches() {        assertEquals(3,              StringUtils.countMatches("one long someone sentence of one", "one"));        assertEquals(0,              StringUtils.countMatches("one long someone sentence of one", "two"));        assertEquals(4,              StringUtils.countMatches("oooooooooooo", "ooo"));    }    public void testGetNestedString() {        assertEquals( "", StringUtils.getNestedString("", "") );        assertEquals( "", StringUtils.getNestedString("    ", " ") );        assertEquals( "bar", StringUtils.getNestedString("\nbar\n", "\n") );        assertEquals( "", StringUtils.getNestedString("", "", "") );        assertEquals( "", StringUtils.getNestedString("    ", " ", "  ") );        assertEquals( "bar", StringUtils.getNestedString("<foo>bar</foo>", "<foo>", "</foo>") );    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link NumberRange} class. * * @author <a href="mailto:chrise@esha.com">Christopher Elkins</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Revision: 1.2 $ $Date: 2002/10/08 19:14:20 $ */public final class NumberRangeTest extends TestCase {    private NumberRange tenToTwenty;    private Number five;    private Number ten;    private Number fifteen;    private Number twenty;    private Number twentyFive;    public NumberRangeTest(String name) {        super(name);    }    public void setUp() {        five       = new Integer(5);        ten        = new Integer(10);        fifteen    = new Integer(15);        twenty     = new Integer(20);        twentyFive = new Integer(25);        tenToTwenty = new NumberRange(ten, twenty);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberRangeTest.class);        suite.setName("NumberRange Tests");        return suite;    }    public void testEquals() {        boolean expected = false;        boolean result = tenToTwenty.equals(new NumberRange(five, ten));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.equals(new NumberRange(ten, twenty));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.equals(new NumberRange(ten, fifteen));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.equals(new NumberRange(fifteen, twenty));        assertEquals(expected, result);    }    public void testIncludesNumber() {        boolean expected = false;        boolean result = tenToTwenty.includesNumber(five);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(ten);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(fifteen);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(twenty);        assertEquals(expected, result);        expected = false;        result = tenToTwenty.includesNumber(twentyFive);        assertEquals(expected, result);    }    public void testIncludesRange() {        boolean expected = false;        boolean result = tenToTwenty.includesRange(new NumberRange(five, ten));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.includesRange(new NumberRange(five, fifteen));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(ten, fifteen));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(ten, twenty));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(fifteen, twenty));        assertEquals(expected, result);        expected = false;        result =             tenToTwenty.includesRange(new NumberRange(fifteen, twentyFive));        assertEquals(expected, result);        expected = false;        result =             tenToTwenty.includesRange(new NumberRange(twenty, twentyFive));        assertEquals(expected, result);    }public void testConstructorNullParameters(){try{NumberRange nr = new NumberRange(null);fail("NumberRange(null) did not throw an exception.");}catch (Exception e){assertTrue("NumberRange(null)",e instanceof NullPointerException);}try{NumberRange nr = new NumberRange(five, null);fail("NumberRange(five, null) did not throw an exception.");}catch (Exception e){assertTrue("NumberRange(five, null)",e instanceof NullPointerException);}try{NumberRange nr = new NumberRange(null, five);fail("NumberRange(null, five) did not throw an exception.");}catch (Exception e){assertTrue("NumberRange(null, five)",e instanceof NullPointerException);}}    public void testToString() {        String expected = "10-20";        String result = tenToTwenty.toString();        assertEquals(expected, result);    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.ObjectOutputStream;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.SerializationUtils}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: SerializationUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class SerializationUtilsTest extends TestCase {    private String iString;    private Integer iInteger;    private HashMap iMap;    public SerializationUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(SerializationUtilsTest.class);    suite.setName("SerializationUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        iString = "foo";        iInteger = new Integer(7);        iMap = new HashMap();        iMap.put("FOO", iString);        iMap.put("BAR", iInteger);    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSerializeStream() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        SerializationUtils.serialize(iMap, streamTest);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        byte[] testBytes = streamTest.toByteArray();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeStreamUnserializable() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            iMap.put(new Object(), new Object());            SerializationUtils.serialize(iMap, streamTest);        } catch (SerializationException ex) {            return;        }        fail();    }    public void testSerializeStreamNullObj() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        SerializationUtils.serialize(null, streamTest);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        byte[] testBytes = streamTest.toByteArray();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeStreamObjNull() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            SerializationUtils.serialize(iMap, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testSerializeStreamNullNull() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            SerializationUtils.serialize(null, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testDeserializeStream() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());        Object test = SerializationUtils.deserialize(inTest);        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testDeserializeStreamOfNull() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());        Object test = SerializationUtils.deserialize(inTest);        assertNull(test);    }    public void testDeserializeStreamNull() throws Exception {        try {            SerializationUtils.deserialize((InputStream) null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testDeserializeStreamBadStream() throws Exception {        try {            SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));        } catch (SerializationException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testSerializeBytes() throws Exception {        byte[] testBytes = SerializationUtils.serialize(iMap);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeBytesUnserializable() throws Exception {        try {            iMap.put(new Object(), new Object());            SerializationUtils.serialize(iMap);        } catch (SerializationException ex) {            return;        }        fail();    }    public void testSerializeBytesNull() throws Exception {        byte[] testBytes = SerializationUtils.serialize(null);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    //-----------------------------------------------------------------------    public void testDeserializeBytes() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        Object test = SerializationUtils.deserialize(streamReal.toByteArray());        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testDeserializeBytesOfNull() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        Object test = SerializationUtils.deserialize(streamReal.toByteArray());        assertNull(test);    }    public void testDeserializeBytesNull() throws Exception {        try {            SerializationUtils.deserialize((byte[]) null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testDeserializeBytesBadStream() throws Exception {        try {            SerializationUtils.deserialize(new byte[0]);        } catch (SerializationException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testClone() throws Exception {        Object test = SerializationUtils.clone(iMap);        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testCloneNull() throws Exception {        Object test = SerializationUtils.clone(null);        assertNull(test);    }    public void testCloneUnserializable() throws Exception {        try {            iMap.put(new Object(), new Object());            SerializationUtils.clone(iMap);        } catch (SerializationException ex) {            return;        }        fail();    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.lang.reflect.Method;import java.math.BigDecimal;import java.math.BigInteger;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Unit tests {@link org.apache.commons.lang.NumberUtils}. * * @author <a href="mailto:rand_mcneely@yahoo.com">Rand McNeely</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: NumberUtilsTest.java,v 1.2 2002/09/15 10:27:56 scolebourne Exp $ */public class NumberUtilsTest extends TestCase {    public NumberUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberUtilsTest.class);        suite.setName("NumberUtils Tests");        return suite;    }    //---------------------------------------------------------------------    /**     * Test for int stringToInt(String)     */    public void testStringToIntString() {        assertTrue("stringToInt(String) 1 failed", NumberUtils.stringToInt("12345") == 12345);        assertTrue("stringToInt(String) 2 failed", NumberUtils.stringToInt("abc") == 0);    }    /**     * Test for int stringToInt(String, int)     */    public void testStringToIntStringI() {        assertTrue("stringToInt(String,int) 1 failed", NumberUtils.stringToInt("12345", 5) == 12345);        assertTrue("stringToInt(String,int) 2 failed", NumberUtils.stringToInt("1234.5", 5) == 5);    }    public void testCreateNumber() {        //a lot of things can go wrong        assertEquals("createNumber(String) 1 failed", new Float("1234.5"), NumberUtils.createNumber("1234.5"));        assertEquals("createNumber(String) 2 failed", new Integer("12345"), NumberUtils.createNumber("12345"));        assertEquals("createNumber(String) 3 failed", new Double("1234.5"), NumberUtils.createNumber("1234.5D"));        assertEquals("createNumber(String) 4 failed", new Float("1234.5"), NumberUtils.createNumber("1234.5F"));        assertEquals("createNumber(String) 5 failed", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber("" + (Integer.MAX_VALUE + 1L)));        assertEquals("createNumber(String) 6 failed", new Long(12345), NumberUtils.createNumber("12345L"));        assertEquals("createNumber(String) 7 failed", new Float("-1234.5"), NumberUtils.createNumber("-1234.5"));        assertEquals("createNumber(String) 8 failed", new Integer("-12345"), NumberUtils.createNumber("-12345"));        assertTrue("createNumber(String) 9 failed", 0xFADE == NumberUtils.createNumber("0xFADE").intValue());        assertTrue("createNumber(String) 10 failed", -0xFADE == NumberUtils.createNumber("-0xFADE").intValue());        assertEquals("createNumber(String) 11 failed", new Double("1.1E200"), NumberUtils.createNumber("1.1E200"));        assertEquals("createNumber(String) 12 failed", new Float("1.1E20"), NumberUtils.createNumber("1.1E20"));        assertEquals("createNumber(String) 13 failed", new Double("-1.1E200"), NumberUtils.createNumber("-1.1E200"));        assertEquals("createNumber(String) 14 failed", new Double("1.1E-200"), NumberUtils.createNumber("1.1E-200"));        assertEquals("createNumber(String) 15 failed", new BigDecimal("1.1E-700"), NumberUtils.createNumber("1.1E-700F"));        assertEquals(            "createNumber(String) 16 failed",            new Long("10" + Integer.MAX_VALUE),            NumberUtils.createNumber("10" + Integer.MAX_VALUE + "L"));        assertEquals(            "createNumber(String) 17 failed",            new Long("10" + Integer.MAX_VALUE),            NumberUtils.createNumber("10" + Integer.MAX_VALUE));        assertEquals(            "createNumber(String) 18 failed",            new BigInteger("10" + Long.MAX_VALUE),            NumberUtils.createNumber("10" + Long.MAX_VALUE));    }    public void testCreateFloat() {        assertEquals("createFloat(String) failed", new Float("1234.5"), NumberUtils.createFloat("1234.5"));    }    public void testCreateDouble() {        assertEquals("createDouble(String) failed", new Double("1234.5"), NumberUtils.createDouble("1234.5"));    }    public void testCreateInteger() {        assertEquals("createInteger(String) failed", new Integer("12345"), NumberUtils.createInteger("12345"));    }    public void testCreateLong() {        assertEquals("createInteger(String) failed", new Long("12345"), NumberUtils.createLong("12345"));    }    public void testCreateBigInteger() {        assertEquals("createBigInteger(String) failed", new BigInteger("12345"), NumberUtils.createBigInteger("12345"));    }    public void testCreateBigDecimal() {        assertEquals("createBigDecimal(String) failed", new BigDecimal("1234.5"), NumberUtils.createBigDecimal("1234.5"));    }    public void testMinimumLong() {        assertEquals("minimum(long,long,long) 1 failed", 12345L, NumberUtils.minimum(12345L, 12345L + 1L, 12345L + 2L));        assertEquals("minimum(long,long,long) 2 failed", 12345L, NumberUtils.minimum(12345L + 1L, 12345L, 12345 + 2L));        assertEquals("minimum(long,long,long) 3 failed", 12345L, NumberUtils.minimum(12345L + 1L, 12345L + 2L, 12345L));        assertEquals("minimum(long,long,long) 4 failed", 12345L, NumberUtils.minimum(12345L + 1L, 12345L, 12345L));        assertEquals("minimum(long,long,long) 5 failed", 12345L, NumberUtils.minimum(12345L, 12345L, 12345L));    }    public void testMinimumInt() {        assertEquals("minimum(int,int,int) 1 failed", 12345, NumberUtils.minimum(12345, 12345 + 1, 12345 + 2));        assertEquals("minimum(int,int,int) 2 failed", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345 + 2));        assertEquals("minimum(int,int,int) 3 failed", 12345, NumberUtils.minimum(12345 + 1, 12345 + 2, 12345));        assertEquals("minimum(int,int,int) 4 failed", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345));        assertEquals("minimum(int,int,int) 5 failed", 12345, NumberUtils.minimum(12345, 12345, 12345));    }    public void testMaximumLong() {        assertEquals("maximum(long,long,long) 1 failed", 12345L, NumberUtils.maximum(12345L, 12345L - 1L, 12345L - 2L));        assertEquals("maximum(long,long,long) 2 failed", 12345L, NumberUtils.maximum(12345L - 1L, 12345L, 12345L - 2L));        assertEquals("maximum(long,long,long) 3 failed", 12345L, NumberUtils.maximum(12345L - 1L, 12345L - 2L, 12345L));        assertEquals("maximum(long,long,long) 4 failed", 12345L, NumberUtils.maximum(12345L - 1L, 12345L, 12345L));        assertEquals("maximum(long,long,long) 5 failed", 12345L, NumberUtils.maximum(12345L, 12345L, 12345L));    }    public void testMaximumInt() {        assertEquals("maximum(int,int,int) 1 failed", 12345, NumberUtils.maximum(12345, 12345 - 1, 12345 - 2));        assertEquals("maximum(int,int,int) 2 failed", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345 - 2));        assertEquals("maximum(int,int,int) 3 failed", 12345, NumberUtils.maximum(12345 - 1, 12345 - 2, 12345));        assertEquals("maximum(int,int,int) 4 failed", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345));        assertEquals("maximum(int,int,int) 5 failed", 12345, NumberUtils.maximum(12345, 12345, 12345));    }    public void testCompareDouble() {        assertTrue(NumberUtils.compare(Double.NaN, Double.NaN) == 0);        assertTrue(NumberUtils.compare(Double.NaN, Double.POSITIVE_INFINITY) == +1);        assertTrue(NumberUtils.compare(Double.NaN, Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.NaN, 1.2d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, 0.0d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, -0.0d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, -1.2d) == +1);        assertTrue(NumberUtils.compare(Double.NaN, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.NaN, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NaN) == -1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY) == 0);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 1.2d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, 0.0d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -0.0d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -1.2d) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NaN) == -1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 1.2d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, 0.0d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -0.0d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -1.2d) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(1.2d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(1.2d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(1.2d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(1.2d, 1.2d) == 0);        assertTrue(NumberUtils.compare(1.2d, 0.0d) == +1);        assertTrue(NumberUtils.compare(1.2d, -0.0d) == +1);        assertTrue(NumberUtils.compare(1.2d, -1.2d) == +1);        assertTrue(NumberUtils.compare(1.2d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(1.2d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(0.0d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(0.0d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(0.0d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(0.0d, 1.2d) == -1);        assertTrue(NumberUtils.compare(0.0d, 0.0d) == 0);        assertTrue(NumberUtils.compare(0.0d, -0.0d) == +1);        assertTrue(NumberUtils.compare(0.0d, -1.2d) == +1);        assertTrue(NumberUtils.compare(0.0d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(0.0d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-0.0d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(-0.0d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-0.0d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-0.0d, 1.2d) == -1);        assertTrue(NumberUtils.compare(-0.0d, 0.0d) == -1);        assertTrue(NumberUtils.compare(-0.0d, -0.0d) == 0);        assertTrue(NumberUtils.compare(-0.0d, -1.2d) == +1);        assertTrue(NumberUtils.compare(-0.0d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-0.0d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-1.2d, Double.NaN) == -1);        assertTrue(NumberUtils.compare(-1.2d, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-1.2d, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-1.2d, 1.2d) == -1);        assertTrue(NumberUtils.compare(-1.2d, 0.0d) == -1);        assertTrue(NumberUtils.compare(-1.2d, -0.0d) == -1);        assertTrue(NumberUtils.compare(-1.2d, -1.2d) == 0);        assertTrue(NumberUtils.compare(-1.2d, -Double.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-1.2d, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NaN) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 1.2d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, 0.0d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -0.0d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -1.2d) == -1);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, -Double.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NaN) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 1.2d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, 0.0d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -0.0d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -1.2d) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) == 0);    }    public void testCompareFloat() {        assertTrue(NumberUtils.compare(Float.NaN, Float.NaN) == 0);        assertTrue(NumberUtils.compare(Float.NaN, Float.POSITIVE_INFINITY) == +1);        assertTrue(NumberUtils.compare(Float.NaN, Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.NaN, 1.2f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, 0.0f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, -0.0f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, -1.2f) == +1);        assertTrue(NumberUtils.compare(Float.NaN, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.NaN, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NaN) == -1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY) == 0);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 1.2f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, 0.0f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -0.0f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -1.2f) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NaN) == -1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 1.2f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, 0.0f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -0.0f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -1.2f) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(1.2f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(1.2f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(1.2f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(1.2f, 1.2f) == 0);        assertTrue(NumberUtils.compare(1.2f, 0.0f) == +1);        assertTrue(NumberUtils.compare(1.2f, -0.0f) == +1);        assertTrue(NumberUtils.compare(1.2f, -1.2f) == +1);        assertTrue(NumberUtils.compare(1.2f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(1.2f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(0.0f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(0.0f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(0.0f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(0.0f, 1.2f) == -1);        assertTrue(NumberUtils.compare(0.0f, 0.0f) == 0);        assertTrue(NumberUtils.compare(0.0f, -0.0f) == +1);        assertTrue(NumberUtils.compare(0.0f, -1.2f) == +1);        assertTrue(NumberUtils.compare(0.0f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(0.0f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-0.0f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(-0.0f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-0.0f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-0.0f, 1.2f) == -1);        assertTrue(NumberUtils.compare(-0.0f, 0.0f) == -1);        assertTrue(NumberUtils.compare(-0.0f, -0.0f) == 0);        assertTrue(NumberUtils.compare(-0.0f, -1.2f) == +1);        assertTrue(NumberUtils.compare(-0.0f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-0.0f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-1.2f, Float.NaN) == -1);        assertTrue(NumberUtils.compare(-1.2f, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-1.2f, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-1.2f, 1.2f) == -1);        assertTrue(NumberUtils.compare(-1.2f, 0.0f) == -1);        assertTrue(NumberUtils.compare(-1.2f, -0.0f) == -1);        assertTrue(NumberUtils.compare(-1.2f, -1.2f) == 0);        assertTrue(NumberUtils.compare(-1.2f, -Float.MAX_VALUE) == +1);        assertTrue(NumberUtils.compare(-1.2f, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NaN) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 1.2f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, 0.0f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -0.0f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -1.2f) == -1);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, -Float.MAX_VALUE) == 0);        assertTrue(NumberUtils.compare(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY) == +1);                assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NaN) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 1.2f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, 0.0f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -0.0f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -1.2f) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE) == -1);        assertTrue(NumberUtils.compare(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY) == 0);    }    public void testIsDigits() {        assertEquals("isDigits(null) failed", false, NumberUtils.isDigits(null));        assertEquals("isDigits('') failed", false, NumberUtils.isDigits(""));        assertEquals("isDigits(String) failed", true, NumberUtils.isDigits("12345"));        assertEquals("isDigits(String) neg 1 failed", false, NumberUtils.isDigits("1234.5"));        assertEquals("isDigits(String) neg 3 failed", false, NumberUtils.isDigits("1ab"));        assertEquals("isDigits(String) neg 4 failed", false, NumberUtils.isDigits("abc"));    }        /**     * Tests isNumber(String) and tests that createNumber(String) returns     * a valid number iff isNumber(String) returns false.     */    public void testIsNumber() {        String val = "12345";        assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val));        val = "1234.5";        assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val));        val = ".12345";        assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val));        val = "1234E5";        assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val));        val = "1234E+5";        assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val));        val = "1234E-5";        assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val));        val = "123.4E5";        assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val));        val = "-1234";        assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val));        val = "-1234.5";        assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val));        val = "-.12345";        assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val));        val = "-1234E5";        assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val));        val = "0";        assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val));        val = "-0";        assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val));        val = "01234";        assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val));        val = "-01234";        assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val));        val = "0xABC123";        assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val));        val = "0x0";        assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val));        val = "123.4E21D";        assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val));        val = "-221.23F";        assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val));        val = "22338L";        assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val));        val = null;        assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val));        val = "";        assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val));        val = "--2.3";        assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val));        val = ".12.3";        assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val));        val = "-123E";        assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val));        val = "-123E+-212";        assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val));        val = "-123E2.12";        assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val));        val = "0xGF";        assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val));        val = "0xFAE-1";        assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val));        val = ".";        assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val));        val = "-0ABC123";        assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val));        val = "123.4E-D";        assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val));        val = "123.4ED";        assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val));        val = "1234E5l";        assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val));    }    private boolean checkCreateNumber(String val) {        try {            Object obj = NumberUtils.createNumber(val);            if(obj == null) {                return false;            }            return true;        } catch (NumberFormatException e) {            return false;        } catch (NullPointerException e) {            return false;        }    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The names "Apache" and "Apache Software Foundation" and *    "Commons" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache", *    nor may "Apache" appear in their name, without *    prior written permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.*;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.RandomStringUtils}. * * @author <a href="mailto:steven@caswell.name">Steven Caswell</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: RandomStringUtilsTest.java,v 1.2 2002/10/08 19:01:39 sullis Exp $ */public class RandomStringUtilsTest extends junit.framework.TestCase {    /**     * Construct a new instance of RandomStringUtilsTest with the specified name     */    public RandomStringUtilsTest(String name) {        super(name);    }    public static Test suite() {    TestSuite suite = new TestSuite(RandomStringUtilsTest.class);    suite.setName("RandomStringUtils Tests");        return suite;    }        /**     * Set up instance variables required by this test case.     */    public void setUp() {    }        /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }        /**     * Test the implementation     */    public void testRandomStringUtils() {        String r1 = RandomStringUtils.random(50);        assertEquals("random(50) length", 50, r1.length());        String r2 = RandomStringUtils.random(50);        assertEquals("random(50) length", 50, r2.length());        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomAscii(50);        assertEquals("randomAscii(50) length", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("char between 32 and 127", (int) r1.charAt(i) >= 32 && (int) r1.charAt(i) <= 127);        }                r2 = RandomStringUtils.randomAscii(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));        r1 = RandomStringUtils.randomAlphabetic(50);        assertEquals("randomAlphabetic(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains alphabetic", true, Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));        }        r2 = RandomStringUtils.randomAlphabetic(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomAlphanumeric(50);        assertEquals("randomAlphanumeric(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains alphanumeric", true, Character.isLetterOrDigit(r1.charAt(i)));        }        r2 = RandomStringUtils.randomAlphabetic(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomNumeric(50);        assertEquals("randomNumeric(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains numeric", true, Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));        }        r2 = RandomStringUtils.randomNumeric(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                String set = "abcdefg";        r1 = RandomStringUtils.random(50, set);        assertEquals("random(50, \"abcdefg\")", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);        }        r2 = RandomStringUtils.random(50, set);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                set = "stuvwxyz";        r1 = RandomStringUtils.random(50, set.toCharArray());        assertEquals("random(50, \"stuvwxyz\")", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);        }        r2 = RandomStringUtils.random(50, set);        assertTrue("!r1.equals(r2)", !r1.equals(r2));    }    public static void main(String args[]) {        TestRunner.run(suite());    }}