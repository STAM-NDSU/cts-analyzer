/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: ValuedEnumTest.java,v 1.1 2002/08/11 23:17:54 scolebourne Exp $ */public final class ValuedEnumTest extends TestCase {    public ValuedEnumTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(ValuedEnumTest.class);        suite.setName("ValuedEnum Tests");        return suite;    }    public void testName() {        assertEquals("Red", ValuedColorEnum.RED.getName());        assertEquals("Green", ValuedColorEnum.GREEN.getName());        assertEquals("Blue", ValuedColorEnum.BLUE.getName());    }    public void testValue() {        assertEquals(1, ValuedColorEnum.RED.getValue());        assertEquals(2, ValuedColorEnum.GREEN.getValue());        assertEquals(3, ValuedColorEnum.BLUE.getValue());    }    public void testCompareTo() {        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.BLUE) == 0);        assertTrue(ValuedColorEnum.RED.compareTo(ValuedColorEnum.BLUE) < 0);        assertTrue(ValuedColorEnum.BLUE.compareTo(ValuedColorEnum.RED) > 0);    }    public void testEquals() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.RED);        assertSame(ValuedColorEnum.getEnum("Red"), ValuedColorEnum.RED);    }    public void testToString() {        assertEquals("ValuedColorEnum[Red=1]", ValuedColorEnum.RED.toString());    }    public void testIterator() {        Iterator it = ValuedColorEnum.iterator();        assertSame(ValuedColorEnum.RED, it.next());        assertSame(ValuedColorEnum.GREEN, it.next());        assertSame(ValuedColorEnum.BLUE, it.next());    }    public void testList() {        List list = ValuedColorEnum.getEnumList();        Iterator it = list.iterator();        assertSame(ValuedColorEnum.RED, it.next());        assertSame(ValuedColorEnum.GREEN, it.next());        assertSame(ValuedColorEnum.BLUE, it.next());    }    public void testMap() {        Map map = ValuedColorEnum.getEnumMap();        assertTrue(map.containsValue(ValuedColorEnum.RED));        assertTrue(map.containsValue(ValuedColorEnum.GREEN));        assertTrue(map.containsValue(ValuedColorEnum.BLUE));        assertSame(ValuedColorEnum.RED, map.get("Red"));        assertSame(ValuedColorEnum.GREEN, map.get("Green"));        assertSame(ValuedColorEnum.BLUE, map.get("Blue"));    }    public void testGet() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum("Red"));        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum("Green"));        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum("Blue"));        assertSame(null, ValuedColorEnum.getEnum("Pink"));    }    public void testGetValue() {        assertSame(ValuedColorEnum.RED, ValuedColorEnum.getEnum(1));        assertSame(ValuedColorEnum.GREEN, ValuedColorEnum.getEnum(2));        assertSame(ValuedColorEnum.BLUE, ValuedColorEnum.getEnum(3));        assertSame(null, ValuedColorEnum.getEnum(4));    }    public void testSerialization() {        assertSame(ValuedColorEnum.RED, SerializationUtils.clone(ValuedColorEnum.RED));        assertSame(ValuedColorEnum.GREEN, SerializationUtils.clone(ValuedColorEnum.GREEN));        assertSame(ValuedColorEnum.BLUE, SerializationUtils.clone(ValuedColorEnum.BLUE));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EnumTest.java,v 1.1 2002/08/11 23:17:54 scolebourne Exp $ */public final class EnumTest extends TestCase {    public EnumTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(EnumTest.class);        suite.setName("Enum Tests");        return suite;    }    public void testName() {        assertEquals("Red", ColorEnum.RED.getName());        assertEquals("Green", ColorEnum.GREEN.getName());        assertEquals("Blue", ColorEnum.BLUE.getName());    }    public void testCompareTo() {        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.BLUE) == 0);        assertTrue(ColorEnum.RED.compareTo(ColorEnum.BLUE) > 0);        assertTrue(ColorEnum.BLUE.compareTo(ColorEnum.RED) < 0);    }    public void testEquals() {        assertSame(ColorEnum.RED, ColorEnum.RED);        assertSame(ColorEnum.getEnum("Red"), ColorEnum.RED);    }    public void testToString() {        assertEquals("ColorEnum[Red]", ColorEnum.RED.toString());    }    public void testIterator() {        Iterator it = ColorEnum.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testList() {        List list = ColorEnum.getEnumList();        Iterator it = list.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testMap() {        Map map = ColorEnum.getEnumMap();        assertTrue(map.containsValue(ColorEnum.RED));        assertTrue(map.containsValue(ColorEnum.GREEN));        assertTrue(map.containsValue(ColorEnum.BLUE));        assertSame(ColorEnum.RED, map.get("Red"));        assertSame(ColorEnum.GREEN, map.get("Green"));        assertSame(ColorEnum.BLUE, map.get("Blue"));    }    public void testGet() {        assertSame(ColorEnum.RED, ColorEnum.getEnum("Red"));        assertSame(ColorEnum.GREEN, ColorEnum.getEnum("Green"));        assertSame(ColorEnum.BLUE, ColorEnum.getEnum("Blue"));        assertSame(null, ColorEnum.getEnum("Pink"));    }    public void testSerialization() {        assertSame(ColorEnum.RED, SerializationUtils.clone(ColorEnum.RED));        assertSame(ColorEnum.GREEN, SerializationUtils.clone(ColorEnum.GREEN));        assertSame(ColorEnum.BLUE, SerializationUtils.clone(ColorEnum.BLUE));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.enum;import java.util.Iterator;import java.util.List;import java.util.Map;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.lang.SerializationUtils;/** * Test cases for the {@link Enum} class. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EnumUtilsTest.java,v 1.1 2002/08/11 23:17:54 scolebourne Exp $ */public final class EnumUtilsTest extends TestCase {    public EnumUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(EnumUtilsTest.class);        suite.setName("EnumUtils Tests");        return suite;    }    public void testIterator() {        Iterator it = EnumUtils.iterator(ColorEnum.class);        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testIteratorEx() {        try {            EnumUtils.iterator(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testList() {        List list = EnumUtils.getEnumList(ColorEnum.class);        Iterator it = list.iterator();        assertSame(ColorEnum.RED, it.next());        assertSame(ColorEnum.GREEN, it.next());        assertSame(ColorEnum.BLUE, it.next());    }    public void testListEx() {        try {            EnumUtils.getEnumList(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMap() {        Map map = EnumUtils.getEnumMap(ColorEnum.class);        assertTrue(map.containsValue(ColorEnum.RED));        assertTrue(map.containsValue(ColorEnum.GREEN));        assertTrue(map.containsValue(ColorEnum.BLUE));        assertSame(ColorEnum.RED, map.get("Red"));        assertSame(ColorEnum.GREEN, map.get("Green"));        assertSame(ColorEnum.BLUE, map.get("Blue"));    }    public void testMapEx() {        try {            EnumUtils.getEnumMap(null);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testGet() {        assertSame(ColorEnum.RED, EnumUtils.getEnum(ColorEnum.class, "Red"));        assertSame(ColorEnum.GREEN, EnumUtils.getEnum(ColorEnum.class, "Green"));        assertSame(ColorEnum.BLUE, EnumUtils.getEnum(ColorEnum.class, "Blue"));        assertSame(null, EnumUtils.getEnum(ColorEnum.class, "Pink"));    }    public void testGetEx() {        try {            EnumUtils.getEnum(null, "");        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testGetValue() {        assertSame(ValuedColorEnum.RED, EnumUtils.getEnum(ValuedColorEnum.class, 1));        assertSame(ValuedColorEnum.GREEN, EnumUtils.getEnum(ValuedColorEnum.class, 2));        assertSame(ValuedColorEnum.BLUE, EnumUtils.getEnum(ValuedColorEnum.class, 3));        assertSame(null, EnumUtils.getEnum(ValuedColorEnum.class, 4));    }    public void testGetValueEx() {        try {            EnumUtils.getEnum(null, 0);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.HashCodeBuilder}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: HashCodeBuilderTest.java,v 1.1 2002/09/12 22:01:00 scolebourne Exp $ */public class HashCodeBuilderTest extends TestCase {    public HashCodeBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(HashCodeBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testConstructorEx1() {        try {            new HashCodeBuilder(0, 0);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testConstructorEx2() {        try {            new HashCodeBuilder(2, 2);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    static class TestObject {        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }    }    public void testReflectionHashCode() {        assertEquals(17 * 37, HashCodeBuilder.reflectionHashCode(new TestObject(0)));        assertEquals(17 * 37 + 123456, HashCodeBuilder.reflectionHashCode(new TestObject(123456)));    }    public void testReflectionHashCodeEx1() {        try {            HashCodeBuilder.reflectionHashCode(0, 0, new TestObject(0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx2() {        try {            HashCodeBuilder.reflectionHashCode(2, 2, new TestObject(0), true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testReflectionHashCodeEx3() {        try {            HashCodeBuilder.reflectionHashCode(13, 19, null, true);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testObject() {        Object obj = null;        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj = new Object();        assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLong() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append((long) 123456789L).toHashCode());    }    public void testInt() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode());        assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode());    }    public void testShort() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());        assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());    }    public void testChar() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());        assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());    }    public void testByte() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());        assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());    }    public void testDouble() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());        double d = 1234567.89;        long l = Double.doubleToLongBits(d);        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());    }    public void testFloat() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());        float f = 1234.89f;        int i = Float.floatToIntBits(f);        assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());    }    public void testBoolean() {        assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());        assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());    }    public void testObjectArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testObjectArrayAsObject() {        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testLongArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLongArrayAsObject() {        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testIntArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testIntArrayAsObject() {        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testShortArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testShortArrayAsObject() {        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testCharArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testCharArrayAsObject() {        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testByteArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testByteArrayAsObject() {        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testDoubleArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testDoubleArrayAsObject() {        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testFloatArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testFloatArrayAsObject() {        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testBooleanArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testBooleanArrayAsObject() {        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append((Object) obj).toHashCode());    }    public void testBooleanMultiArray() {        boolean[][] obj = new boolean[2][];        assertEquals((17 * 37) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[0];        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[1];        assertEquals((17 * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new boolean[2];        assertEquals(((17 * 37 + 1) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0][0] = true;        assertEquals(((17 * 37 + 0) * 37 + 1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new boolean[1];        assertEquals( (((17 * 37 + 0) * 37 + 1) * 37 + 1), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang.builder;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.EqualsBuilder}. * * @author <a href="mailto:sdowney@panix.com">Steve Downey</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: EqualsBuilderTest.java,v 1.1 2002/09/12 22:00:35 scolebourne Exp $ */public class EqualsBuilderTest extends TestCase {    public EqualsBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(EqualsBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    static class TestObject {        private int a;        public TestObject(int a) {            this.a = a;        }        public boolean equals(Object o) {            if (o == this) {                return true;            }            if (!(o instanceof TestObject)) {                return false;            }            TestObject rhs = (TestObject) o;            return (a == rhs.a);        }        public void setA(int a) {            this.a = a;        }        public int getA() {            return a;        }    }    public void testReflectionEquals() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(EqualsBuilder.reflectionEquals(o1, o1));        assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));        o2.setA(4);        assertTrue(EqualsBuilder.reflectionEquals(o1, o2));        assertTrue(!EqualsBuilder.reflectionEquals(o1, this));                assertTrue(!EqualsBuilder.reflectionEquals(o1, null));        assertTrue(!EqualsBuilder.reflectionEquals(null, o2));        assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));    }    public void testObject() {        TestObject o1 = new TestObject(4);        TestObject o2 = new TestObject(5);        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        o2.setA(4);        assertTrue(new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, this).isEquals());                assertTrue(!new EqualsBuilder().append(o1, null).isEquals());        assertTrue(!new EqualsBuilder().append(null, o2).isEquals());        assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());    }    public void testLong() {        long o1 = 1L;        long o2 = 2L;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testInt() {        int o1 = 1;        int o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testShort() {        short o1 = 1;        short o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testChar() {        char o1 = 1;        char o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testByte() {        byte o1 = 1;        byte o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testDouble() {        double o1 = 1;        double o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());    }    public void testFloat() {        float o1 = 1;        float o2 = 2;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());        assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());        assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());    }    public void testBoolean() {        boolean o1 = true;        boolean o2 = false;        assertTrue(new EqualsBuilder().append(o1, o1).isEquals());        assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());    }    public void testObjectArray() {        TestObject[] obj1 = new TestObject[2];        obj1[0] = new TestObject(4);        obj1[1] = new TestObject(5);        TestObject[] obj2 = new TestObject[2];        obj2[0] = new TestObject(4);        obj2[1] = new TestObject(5);        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1].setA(6);        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testLongArray() {        long[] obj1 = new long[2];        obj1[0] = 5L;        obj1[1] = 6L;        long[] obj2 = new long[2];        obj2[0] = 5L;        obj2[1] = 6L;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testIntArray() {        int[] obj1 = new int[2];        obj1[0] = 5;        obj1[1] = 6;        int[] obj2 = new int[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testShortArray() {        short[] obj1 = new short[2];        obj1[0] = 5;        obj1[1] = 6;        short[] obj2 = new short[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testCharArray() {        char[] obj1 = new char[2];        obj1[0] = 5;        obj1[1] = 6;        char[] obj2 = new char[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testByteArray() {        byte[] obj1 = new byte[2];        obj1[0] = 5;        obj1[1] = 6;        byte[] obj2 = new byte[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testDoubleArray() {        double[] obj1 = new double[2];        obj1[0] = 5;        obj1[1] = 6;        double[] obj2 = new double[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testFloatArray() {        float[] obj1 = new float[2];        obj1[0] = 5;        obj1[1] = 6;        float[] obj2 = new float[2];        obj2[0] = 5;        obj2[1] = 6;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testBooleanArray() {        boolean[] obj1 = new boolean[2];        obj1[0] = true;        obj1[1] = false;        boolean[] obj2 = new boolean[2];        obj2[0] = true;        obj2[1] = false;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        obj1[1] = true;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj2 = null;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());        obj1 = null;        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testMultiLongArray() {        long[][] array1 = new long[2][2];        long[][] array2 = new long[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiIntArray() {        int[][] array1 = new int[2][2];        int[][] array2 = new int[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiShortArray() {        short[][] array1 = new short[2][2];        short[][] array2 = new short[2][2];        for (short i = 0; i < array1.length; ++i) {            for (short j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiCharArray() {        char[][] array1 = new char[2][2];        char[][] array2 = new char[2][2];        for (char i = 0; i < array1.length; ++i) {            for (char j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiByteArray() {        byte[][] array1 = new byte[2][2];        byte[][] array2 = new byte[2][2];        for (byte i = 0; i < array1.length; ++i) {            for (byte j = 0; j < array1[0].length; j++) {                array1[i][j] = i;                array2[i][j] = i;            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiFloatArray() {        float[][] array1 = new float[2][2];        float[][] array2 = new float[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiDoubleArray() {        double[][] array1 = new double[2][2];        double[][] array2 = new double[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMultiBooleanArray() {        boolean[][] array1 = new boolean[2][2];        boolean[][] array2 = new boolean[2][2];        for (int i = 0; i < array1.length; ++i) {            for (int j = 0; j < array1[0].length; j++) {                array1[i][j] = (i == 1) || (j == 1);                array2[i][j] = (i == 1) || (j == 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = false;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testRaggedArray() {        long array1[][] = new long[2][];        long array2[][] = new long[2][];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            for (int j = 0; j < array1[i].length; ++j) {                array1[i][j] = (i + 1) * (j + 1);                array2[i][j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        array1[1][1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testMixedArray() {        Object array1[] = new Object[2];        Object array2[] = new Object[2];        for (int i = 0; i < array1.length; ++i) {            array1[i] = new long[2];            array2[i] = new long[2];            for (int j = 0; j < 2; ++j) {                TestObject obj1 = new TestObject((i + 1) * (j + 1));                TestObject obj2 = new TestObject((i + 1) * (j + 1));                ((long[]) array1[i])[j] = (i + 1) * (j + 1);                ((long[]) array2[i])[j] = (i + 1) * (j + 1);            }        }        assertTrue(new EqualsBuilder().append(array1, array1).isEquals());        assertTrue(new EqualsBuilder().append(array1, array2).isEquals());        ((long[]) array1[1])[1] = 0;        assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());    }    public void testObjectArrayHiddenByObject() {        TestObject[] array1 = new TestObject[2];        array1[0] = new TestObject(4);        array1[1] = new TestObject(5);        TestObject[] array2 = new TestObject[2];        array2[0] = new TestObject(4);        array2[1] = new TestObject(5);        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1].setA(6);        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testLongArrayHiddenByObject() {        long[] array1 = new long[2];        array1[0] = 5L;        array1[1] = 6L;        long[] array2 = new long[2];        array2[0] = 5L;        array2[1] = 6L;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testIntArrayHiddenByObject() {        int[] array1 = new int[2];        array1[0] = 5;        array1[1] = 6;        int[] array2 = new int[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testShortArrayHiddenByObject() {        short[] array1 = new short[2];        array1[0] = 5;        array1[1] = 6;        short[] array2 = new short[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testCharArrayHiddenByObject() {        char[] array1 = new char[2];        array1[0] = 5;        array1[1] = 6;        char[] array2 = new char[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testByteArrayHiddenByObject() {        byte[] array1 = new byte[2];        array1[0] = 5;        array1[1] = 6;        byte[] array2 = new byte[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testDoubleArrayHiddenByObject() {        double[] array1 = new double[2];        array1[0] = 5;        array1[1] = 6;        double[] array2 = new double[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testFloatArrayHiddenByObject() {        float[] array1 = new float[2];        array1[0] = 5;        array1[1] = 6;        float[] array2 = new float[2];        array2[0] = 5;        array2[1] = 6;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = 7;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }    public void testBooleanArrayHiddenByObject() {        boolean[] array1 = new boolean[2];        array1[0] = true;        array1[1] = false;        boolean[] array2 = new boolean[2];        array2[0] = true;        array2[1] = false;        Object obj1 = array1;        Object obj2 = array2;        assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());        assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());        assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());        array1[1] = true;        assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: StringUtilsIsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class StringUtilsIsTest extends TestCase {    public StringUtilsIsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsIsTest.class);    suite.setName("StringUtilsIsXxx Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testIsAlpha() {        assertEquals(false, StringUtils.isAlpha(null));        assertEquals(true, StringUtils.isAlpha(""));        assertEquals(false, StringUtils.isAlpha(" "));        assertEquals(true, StringUtils.isAlpha("a"));        assertEquals(true, StringUtils.isAlpha("A"));        assertEquals(true, StringUtils.isAlpha("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isAlpha("ham kso"));        assertEquals(false, StringUtils.isAlpha("1"));        assertEquals(false, StringUtils.isAlpha("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlpha("_"));        assertEquals(false, StringUtils.isAlpha("hkHKHik*khbkuh"));    }    public void testIsAlphanumeric() {        assertEquals(false, StringUtils.isAlphanumeric(null));        assertEquals(true, StringUtils.isAlphanumeric(""));        assertEquals(false, StringUtils.isAlphanumeric(" "));        assertEquals(true, StringUtils.isAlphanumeric("a"));        assertEquals(true, StringUtils.isAlphanumeric("A"));        assertEquals(true, StringUtils.isAlphanumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isAlphanumeric("ham kso"));        assertEquals(true, StringUtils.isAlphanumeric("1"));        assertEquals(true, StringUtils.isAlphanumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphanumeric("_"));        assertEquals(false, StringUtils.isAlphanumeric("hkHKHik*khbkuh"));    }    public void testIsAlphaspace() {        assertEquals(false, StringUtils.isAlphaSpace(null));        assertEquals(true, StringUtils.isAlphaSpace(""));        assertEquals(true, StringUtils.isAlphaSpace(" "));        assertEquals(true, StringUtils.isAlphaSpace("a"));        assertEquals(true, StringUtils.isAlphaSpace("A"));        assertEquals(true, StringUtils.isAlphaSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(true, StringUtils.isAlphaSpace("ham kso"));        assertEquals(false, StringUtils.isAlphaSpace("1"));        assertEquals(false, StringUtils.isAlphaSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphaSpace("_"));        assertEquals(false, StringUtils.isAlphaSpace("hkHKHik*khbkuh"));    }    public void testIsAlphanumericSpace() {        assertEquals(false, StringUtils.isAlphanumericSpace(null));        assertEquals(true, StringUtils.isAlphanumericSpace(""));        assertEquals(true, StringUtils.isAlphanumericSpace(" "));        assertEquals(true, StringUtils.isAlphanumericSpace("a"));        assertEquals(true, StringUtils.isAlphanumericSpace("A"));        assertEquals(true, StringUtils.isAlphanumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(true, StringUtils.isAlphanumericSpace("ham kso"));        assertEquals(true, StringUtils.isAlphanumericSpace("1"));        assertEquals(true, StringUtils.isAlphanumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isAlphanumericSpace("_"));        assertEquals(false, StringUtils.isAlphanumericSpace("hkHKHik*khbkuh"));    }    public void testIsNumeric() {        assertEquals(false, StringUtils.isNumeric(null));        assertEquals(true, StringUtils.isNumeric(""));        assertEquals(false, StringUtils.isNumeric(" "));        assertEquals(false, StringUtils.isNumeric("a"));        assertEquals(false, StringUtils.isNumeric("A"));        assertEquals(false, StringUtils.isNumeric("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isNumeric("ham kso"));        assertEquals(true, StringUtils.isNumeric("1"));        assertEquals(true, StringUtils.isNumeric("1000"));        assertEquals(false, StringUtils.isNumeric("2.3"));        assertEquals(false, StringUtils.isNumeric("10 00"));        assertEquals(false, StringUtils.isNumeric("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isNumeric("_"));        assertEquals(false, StringUtils.isNumeric("hkHKHik*khbkuh"));    }    public void testIsNumericSpace() {        assertEquals(false, StringUtils.isNumericSpace(null));        assertEquals(true, StringUtils.isNumericSpace(""));        assertEquals(true, StringUtils.isNumericSpace(" "));        assertEquals(false, StringUtils.isNumericSpace("a"));        assertEquals(false, StringUtils.isNumericSpace("A"));        assertEquals(false, StringUtils.isNumericSpace("kgKgKgKgkgkGkjkjlJlOKLgHdGdHgl"));        assertEquals(false, StringUtils.isNumericSpace("ham kso"));        assertEquals(true, StringUtils.isNumericSpace("1"));        assertEquals(true, StringUtils.isNumericSpace("1000"));        assertEquals(false, StringUtils.isNumericSpace("2.3"));        assertEquals(true, StringUtils.isNumericSpace("10 00"));        assertEquals(false, StringUtils.isNumericSpace("hkHKHik6iUGHKJgU7tUJgKJGI87GIkug"));        assertEquals(false, StringUtils.isNumericSpace("_"));        assertEquals(false, StringUtils.isNumericSpace("hkHKHik*khbkuh"));    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.ObjectUtils}. * * @author <a href="mailto:jmcnally@collab.net">John McNally</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: ObjectUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class ObjectUtilsTest extends TestCase{    private static final String FOO = "foo";    private static final String BAR = "bar";    public ObjectUtilsTest(String name)    {        super(name);    }        public static void main(String[] args)     {        TestRunner.run(suite());    }    public static Test suite()     {    TestSuite suite = new TestSuite(ObjectUtilsTest.class);    suite.setName("ObjectUtils Tests");        return suite;    }    protected void setUp() throws Exception     {        super.setUp();    }    protected void tearDown() throws Exception    {        super.tearDown();    }    //-----------------------------------------------------------------------        public void testIsNull()    {        Object o = FOO;        Object dflt = BAR;        assertSame("dflt was not returned when o was null", dflt,                     ObjectUtils.defaultIfNull(null, dflt));        assertSame("dflt was returned when o was not null", o,                     ObjectUtils.defaultIfNull(o, dflt));    }            public void testEquals()    {        assertTrue("ObjectUtils.equals(null, null) returned false",                    ObjectUtils.equals(null, null));        assertTrue("ObjectUtils.equals(\"foo\", null) returned true",                    !ObjectUtils.equals(FOO, null));        assertTrue("ObjectUtils.equals(null, \"bar\") returned true",                    !ObjectUtils.equals(null, BAR));        assertTrue("ObjectUtils.equals(\"foo\", \"bar\") returned true",                    !ObjectUtils.equals(FOO, BAR));        assertTrue("ObjectUtils.equals(\"foo\", \"foo\") returned false",                    ObjectUtils.equals(FOO, FOO));    }        }
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.HashCodeBuilder}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @version $Id: HashCodeBuilderTest.java,v 1.1 2002/08/15 22:37:30 scolebourne Exp $ */public class HashCodeBuilderTest extends TestCase {    public HashCodeBuilderTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {        TestSuite suite = new TestSuite(HashCodeBuilderTest.class);        suite.setName("HashCodeBuilder Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testConstructorEx1() {        try {            new HashCodeBuilder(0, 0);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testConstructorEx2() {        try {            new HashCodeBuilder(2, 2);                    } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testObject() {        Object obj = null;        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj = new Object();        assertEquals(17 * 37 + obj.hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLong() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long) 0L).toHashCode());        assertEquals(17 * 37 + (int) (123456789L ^ (123456789L >> 32)), new HashCodeBuilder(17, 37).append((long) 123456789L).toHashCode());    }    public void testInt() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int) 0).toHashCode());        assertEquals(17 * 37 + 123456, new HashCodeBuilder(17, 37).append((int) 123456).toHashCode());    }    public void testShort() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short) 0).toHashCode());        assertEquals(17 * 37 + 12345, new HashCodeBuilder(17, 37).append((short) 12345).toHashCode());    }    public void testChar() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char) 0).toHashCode());        assertEquals(17 * 37 + 1234, new HashCodeBuilder(17, 37).append((char) 1234).toHashCode());    }    public void testByte() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte) 0).toHashCode());        assertEquals(17 * 37 + 123, new HashCodeBuilder(17, 37).append((byte) 123).toHashCode());    }    public void testDouble() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double) 0d).toHashCode());        double d = 1234567.89;        long l = Double.doubleToLongBits(d);        assertEquals(17 * 37 + (int) (l ^ (l >> 32)), new HashCodeBuilder(17, 37).append(d).toHashCode());    }    public void testFloat() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float) 0f).toHashCode());        float f = 1234.89f;        int i = Float.floatToIntBits(f);        assertEquals(17 * 37 + i, new HashCodeBuilder(17, 37).append(f).toHashCode());    }    public void testBoolean() {        assertEquals(17 * 37 + 0, new HashCodeBuilder(17, 37).append(true).toHashCode());        assertEquals(17 * 37 + 1, new HashCodeBuilder(17, 37).append(false).toHashCode());    }    public void testObjectArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((Object[]) null).toHashCode());        Object[] obj = new Object[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = new Object();        assertEquals((17 * 37 + obj[0].hashCode()) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = new Object();        assertEquals( (17 * 37 + obj[0].hashCode()) * 37 + obj[1].hashCode(), new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testLongArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((long[]) null).toHashCode());        long[] obj = new long[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5L;        int h1 = (int) (5L ^ (5L >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6L;        int h2 = (int) (6L ^ (6L >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testIntArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((int[]) null).toHashCode());        int[] obj = new int[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testShortArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((short[]) null).toHashCode());        short[] obj = new short[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (short) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (short) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testCharArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((char[]) null).toHashCode());        char[] obj = new char[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (char) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (char) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testByteArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((byte[]) null).toHashCode());        byte[] obj = new byte[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = (byte) 5;        assertEquals((17 * 37 + 5) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = (byte) 6;        assertEquals( (17 * 37 + 5) * 37 + 6, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testDoubleArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((double[]) null).toHashCode());        double[] obj = new double[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4d;        long l1 = Double.doubleToLongBits(5.4d);        int h1 = (int) (l1 ^ (l1 >> 32));        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3d;        long l2 = Double.doubleToLongBits(6.3d);        int h2 = (int) (l2 ^ (l2 >> 32));        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testFloatArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((float[]) null).toHashCode());        float[] obj = new float[2];        assertEquals((17 * 37) * 37 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = 5.4f;        int h1 = Float.floatToIntBits(5.4f);        assertEquals((17 * 37 + h1) * 37, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = 6.3f;        int h2 = Float.floatToIntBits(6.3f);        assertEquals( (17 * 37 + h1) * 37 + h2, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }    public void testBooleanArray() {        assertEquals(17 * 37, new HashCodeBuilder(17, 37).append((boolean[]) null).toHashCode());        boolean[] obj = new boolean[2];        assertEquals((17 * 37 + 1) * 37 + 1 , new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[0] = true;        assertEquals((17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());        obj[1] = false;        assertEquals( (17 * 37 + 0) * 37 + 1, new HashCodeBuilder(17, 37).append(obj).toHashCode());    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.CharSetUtils}. * * @author <a href="mailto:bayard@generationjava.com">Henri Yandell</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: CharSetUtilsTest.java,v 1.3 2002/07/21 20:19:50 bayard Exp $ */public class CharSetUtilsTest extends TestCase{    public CharSetUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(CharSetUtilsTest.class);    suite.setName("CharSetUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSqueeze()    {        assertEquals("squeeze(String,String[]) failed",                     "helo", CharSetUtils.squeeze("hello", new String[] {"el"}));        assertEquals("squeeze(String,String[]) failed",                     "", CharSetUtils.squeeze("", new String[] {"el"}));        assertEquals("squeeze(String,String[]) failed",                     "hello", CharSetUtils.squeeze("hello", new String[] {"e"}));        assertEquals("squeeze(String,String[]) failed",                     "fofof", CharSetUtils.squeeze("fooffooff", new String[] {"of"}));        assertEquals("squeeze(String,String[]) failed",                     "fof", CharSetUtils.squeeze("fooooff", new String[] {"fo"}));    }    public void testCount()    {        assertEquals("count(String,String[]) failed",                     3, CharSetUtils.count("hello", new String[] {"el"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("", new String[] {"el"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("hello", new String[] {"x"}));        assertEquals("count(String,String[]) failed",                     2, CharSetUtils.count("hello", new String[] {"e-i"}));        assertEquals("count(String,String[]) failed",                     5, CharSetUtils.count("hello", new String[] {"a-z"}));        assertEquals("count(String,String[]) failed",                     0, CharSetUtils.count("hello", new String[] {""}));    }    public void testDelete()    {        assertEquals("delete(String,String[]) failed",                     "ho", CharSetUtils.delete("hello", new String[] {"el"}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("hello", new String[] {"elho"}));        assertEquals("delete(String,String[]) failed",                     "hello", CharSetUtils.delete("hello", new String[] {""}));        assertEquals("delete(String,String[]) failed",                     "", CharSetUtils.delete("hello", new String[] {"a-z"}));        assertEquals("delete(String,String[]) failed",                     "heo", CharSetUtils.delete("hello", new String[] {"l"}));    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsEqualsIndexOfTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class StringUtilsEqualsIndexOfTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String FOOBAR = "foobar";    private static final String[] FOOBAR_SUB_ARRAY = new String[] {"ob", "ba"};    public StringUtilsEqualsIndexOfTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsEqualsIndexOfTest.class);    suite.setName("StringUtilsEqualsIndexOf Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testEquals() {        assertEquals(true, StringUtils.equals(null, null));        assertEquals(true, StringUtils.equals(FOO, FOO));        assertEquals(true, StringUtils.equals(FOO, new String(new char[] { 'f', 'o', 'o' })));        assertEquals(false, StringUtils.equals(FOO, new String(new char[] { 'f', 'O', 'O' })));        assertEquals(false, StringUtils.equals(FOO, BAR));        assertEquals(false, StringUtils.equals(FOO, null));        assertEquals(false, StringUtils.equals(null, FOO));    }    public void testEqualsIgnoreCase() {        assertEquals(true, StringUtils.equalsIgnoreCase(null, null));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, FOO));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'o', 'o' })));        assertEquals(true, StringUtils.equalsIgnoreCase(FOO, new String(new char[] { 'f', 'O', 'O' })));        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, BAR));        assertEquals(false, StringUtils.equalsIgnoreCase(FOO, null));        assertEquals(false, StringUtils.equalsIgnoreCase(null, FOO));    }    public void testIndexOfAny() {        assertEquals(-1, StringUtils.indexOfAny(null, null));        assertEquals(-1, StringUtils.indexOfAny(null, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, null));        assertEquals(2, StringUtils.indexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[0]));        assertEquals(-1, StringUtils.indexOfAny(FOOBAR, new String[] {"llll"}));    }    public void testLastIndexOfAny() {        assertEquals(-1, StringUtils.lastIndexOfAny(null, null));        assertEquals(-1, StringUtils.lastIndexOfAny(null, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, null));        assertEquals(3, StringUtils.lastIndexOfAny(FOOBAR, FOOBAR_SUB_ARRAY));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[0]));        assertEquals(-1, StringUtils.lastIndexOfAny(FOOBAR, new String[] {"llll"}));    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.util.Arrays;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils}. * * @author <a href="mailto:dlr@collab.net">Daniel Rall</a> * @author <a href="mailto:bayard@generationjava.com">Henri Yandell</a> * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsTest.java,v 1.3 2002/07/26 01:40:11 dlr Exp $ */public class StringUtilsTest extends TestCase{    private static final String[] ARRAY_LIST = { "foo", "bar", "baz" };    private static final String SEPARATOR = ",";    private static final String TEXT_LIST = "foo,bar,baz";    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String CAP_FOO = "Foo";    private static final String UPPER_FOO = "FOO";    private static final String SENTENCE = "foo bar baz";    public StringUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsTest.class);    suite.setName("StringUtilsTest Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testCaseFunctions()    {        assertEquals("capitalise(String) failed",                     CAP_FOO, StringUtils.capitalise(FOO) );        assertEquals("capitalise(empty-string) failed",                     "", StringUtils.capitalise("") );        assertEquals("capitaliseAllWords(String) failed",                     "Foo Bar Baz", StringUtils.capitaliseAllWords(SENTENCE) );        assertEquals("capitaliseAllWords(empty-string) failed",                     "", StringUtils.capitaliseAllWords("") );        assertEquals("uncapitalise(String) failed",                     FOO, StringUtils.uncapitalise(CAP_FOO) );        assertEquals("uncapitalise(empty-string) failed",                     "", StringUtils.uncapitalise("") );        assertEquals("upperCase(String) failed",                     "FOO TEST THING", StringUtils.upperCase("fOo test THING") );        assertEquals("upperCase(empty-string) failed",                     "", StringUtils.upperCase("") );        assertEquals("lowerCase(String) failed",                     "foo test thing", StringUtils.lowerCase("fOo test THING") );        assertEquals("lowerCase(empty-string) failed",                     "", StringUtils.lowerCase("") );        assertEquals("swapCase(empty-string) failed",                     "", StringUtils.swapCase("") );        assertEquals("swapCase(String-with-numbers) failed",                     "a123RgYu", StringUtils.swapCase("A123rGyU") );        assertEquals("swapCase(String) failed",                     "Hello aPACHE", StringUtils.swapCase("hELLO Apache") );    }    public void testJoin()    {        assertEquals("concatenate(Object[]) failed",                      "foobarbaz", StringUtils.concatenate(ARRAY_LIST));        assertEquals("join(Object[], String) failed", TEXT_LIST,                     StringUtils.join(ARRAY_LIST, SEPARATOR));        assertEquals("join(Iterator, String) failed", TEXT_LIST,                     StringUtils.join(Arrays.asList(ARRAY_LIST).iterator(),                                      SEPARATOR));    }    public void testSplit()    {        String[] result = StringUtils.split(TEXT_LIST, SEPARATOR, 2);        String[] expected = { "foo", "bar,baz" };        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split(TEXT_LIST, SEPARATOR, 0);        expected = ARRAY_LIST;        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }        result = StringUtils.split(TEXT_LIST, SEPARATOR, -1);        expected = ARRAY_LIST;        assertEquals("split(Object[], String, int) yielded unexpected length",                     expected.length, result.length);        for (int i = 0; i < result.length; i++)        {            assertEquals("split(Object[], String, int) failed", expected[i],                         result[i]);        }    }    public void testReplaceFunctions()    {        assertEquals("replace(String, String, String, int) failed",                     FOO, StringUtils.replace("oo" + FOO, "o", "", 2));        assertEquals("replace(String, String, String) failed",                     "", StringUtils.replace(FOO + FOO + FOO, FOO, ""));        assertEquals("replaceOnce(String, String, String) failed",                     FOO, StringUtils.replaceOnce(FOO + FOO, FOO, ""));    }    public void testOverlayString()    {        assertEquals("overlayString(String, String, int, int) failed",                     "foo foor baz", StringUtils.overlayString(SENTENCE, FOO, 4, 6) );    }    public void testRepeat()    {        assertEquals("repeat(String, int) failed",                     FOO + FOO + FOO, StringUtils.repeat(FOO, 3) );    }    public void testCenter()    {        assertEquals("center(String, int) failed",                     "   "+FOO+"   ", StringUtils.center(FOO, 9) );    }    public void testChompFunctions()    {        assertEquals("chomp(String) failed",                     FOO, StringUtils.chomp(FOO + "\n" + FOO) );        assertEquals("chompLast(String) failed",                     FOO, StringUtils.chompLast(FOO + "\n") );        assertEquals("getChomp(String, String) failed",                     "\n" + FOO, StringUtils.getChomp(FOO + "\n" + FOO, "\n") );        assertEquals("prechomp(String, String) failed",                     FOO, StringUtils.prechomp(FOO + "\n" + FOO, "\n") );        assertEquals("getPrechomp(String, String) failed",                     FOO + "\n", StringUtils.getPrechomp(FOO + "\n" + FOO, "\n") );        assertEquals("chop(String, String) failed",                     FOO, StringUtils.chop(FOO + "\r\n") );        assertEquals("chopNewline(String, String) failed",                     FOO, StringUtils.chopNewline(FOO + "\r\n") );    }    public void testPadFunctions()    {        assertEquals("rightPad(String, int) failed",                     "1234    ", StringUtils.rightPad ("1234", 8) );        assertEquals("rightPad(String, int, String) failed",                     "1234-+-+", StringUtils.rightPad ("1234", 8, "-+") );        assertEquals("rightPad(String, int, String) failed",                     "123456-+~", StringUtils.rightPad ("123456", 9, "-+~") );        assertEquals("leftPad(String, int) failed",                     "    1234", StringUtils.leftPad("1234", 8) );        assertEquals("leftPad(String, int, String) failed",                     "-+-+1234", StringUtils.leftPad("1234", 8, "-+") );        assertEquals("leftPad(String, int, String) failed",                     "-+~123456", StringUtils.leftPad("123456", 9, "-+~") );    }    public void testReverseFunctions() {        assertEquals("reverse(String) failed",                     "sdrawkcab", StringUtils.reverse("backwards") );        assertEquals("reverse(empty-string) failed",                     "", StringUtils.reverse("") );        assertEquals("reverseDelimitedString(String,'.') failed",                     "org.apache.test",                        StringUtils.reverseDelimitedString("test.apache.org", ".") );        assertEquals("reverseDelimitedString(empty-string,'.') failed",                     "",                        StringUtils.reverseDelimitedString("", ".") );        assertEquals("reverseDelimitedString(String,' ') failed",                     "once upon a time",                        StringUtils.reverseDelimitedString("time a upon once"," ") );    }    public void testDefaultFunctions() {        assertEquals("defaultString(empty-string) failed",                     "", StringUtils.defaultString("") );        assertEquals("defaultString(String) failed",                     FOO, StringUtils.defaultString(FOO) );        assertEquals("defaultString(null) failed",                     "", StringUtils.defaultString(null) );        assertEquals("defaultString(empty-string,String) failed",                     "", StringUtils.defaultString("", BAR) );        assertEquals("defaultString(String,String) failed",                     FOO, StringUtils.defaultString(FOO, BAR) );        assertEquals("defaultString(null,String) failed",                     BAR, StringUtils.defaultString(null, BAR) );    }    public void testEscapeFunctions() {        assertEquals("escape(empty-string) failed",                     "", StringUtils.escape("") );        assertEquals("escape(String) failed",                     FOO, StringUtils.escape(FOO) );        assertEquals("escape(String) failed",                     "\\t", StringUtils.escape("\t") );        assertEquals("escape(String) failed",                     "\\\\", StringUtils.escape("\\") );        assertEquals("escape(String) failed",                     "\\\\\\b\\t\\r", StringUtils.escape("\\\b\t\r") );        assertEquals("escape(String) failed",                     "\\u1234", StringUtils.escape("\u1234") );        assertEquals("escape(String) failed",                     "\\u0234", StringUtils.escape("\u0234") );        assertEquals("escape(String) failed",                     "\\u00fd", StringUtils.escape("\u00fd") );    }    public void testGetLevenshteinDistance() {        assertEquals("getLevenshteinDistance(empty-string, empty-string) failed",                     0, StringUtils.getLevenshteinDistance("", "") );        assertEquals("getLevenshteinDistance(empty-string, String) failed",                     1, StringUtils.getLevenshteinDistance("", "a") );        assertEquals("getLevenshteinDistance(String, empty-string) failed",                     7, StringUtils.getLevenshteinDistance("aaapppp", "") );        assertEquals("getLevenshteinDistance(String, String) failed",                     1, StringUtils.getLevenshteinDistance("frog", "fog") );        assertEquals("getLevenshteinDistance(String, String) failed",                     3, StringUtils.getLevenshteinDistance("fly", "ant") );        assertEquals("getLevenshteinDistance(String, String) failed",                     7, StringUtils.getLevenshteinDistance("elephant", "hippo") );        assertEquals("getLevenshteinDistance(String, String) failed",                     7, StringUtils.getLevenshteinDistance("hippo", "elephant") );        assertEquals("getLevenshteinDistance(String, String) failed",                     1, StringUtils.getLevenshteinDistance("hello", "hallo") );    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Trim/Empty methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsTrimEmptyTest.java,v 1.4 2002/07/21 20:19:50 bayard Exp $ */public class StringUtilsTrimEmptyTest extends TestCase {    private static final String FOO = "foo";    public StringUtilsTrimEmptyTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsTrimEmptyTest.class);    suite.setName("StringUtilsTrimEmpty Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testClean() {        assertEquals(FOO, StringUtils.clean(FOO + "  "));        assertEquals(FOO, StringUtils.clean(" " + FOO + "  "));        assertEquals(FOO, StringUtils.clean(" " + FOO));        assertEquals(FOO, StringUtils.clean(FOO + ""));        assertEquals("", StringUtils.clean(null));    }    public void testTrim() {        assertEquals(FOO, StringUtils.trim(FOO + "  "));        assertEquals(FOO, StringUtils.trim(" " + FOO + "  "));        assertEquals(FOO, StringUtils.trim(" " + FOO));        assertEquals(FOO, StringUtils.trim(FOO + ""));        assertEquals(null, StringUtils.trim(null));    }    public void testIsNotEmpty() {        assertEquals(true, StringUtils.isNotEmpty(FOO));        assertEquals(true, StringUtils.isNotEmpty(" "));        assertEquals(false, StringUtils.isNotEmpty(""));        assertEquals(false, StringUtils.isNotEmpty(null));    }    public void testIsEmpty() {        assertEquals(false, StringUtils.isEmpty(FOO));        assertEquals(true, StringUtils.isEmpty(" "));        assertEquals(true, StringUtils.isEmpty(""));        assertEquals(true, StringUtils.isEmpty(null));    }    public void testDeleteWhitespace() {        assertEquals("deleteWhitespace(String) failed",                     "", StringUtils.deleteWhitespace(""));        assertEquals("deleteWhitespace(String) failed",                     "", StringUtils.deleteWhitespace("    \t\t\n\n   "));        assertEquals("deleteWhitespace(String) failed",                     "test", StringUtils.deleteWhitespace("t  \t\ne\rs\n\n   \tt"));    }    public void testStrip() {        // it's important that foo2Space is fooLeftSpace and fooRightSpace         // merged together. So same number of spaces to left as fLS and same         // to right as fLS. Same applies for foo2Dots.        String foo2Space = "    "+FOO+"    ";        String foo2Dots = "......"+FOO+".........";        String fooLeftSpace = "    "+FOO;        String fooLeftDots = "......"+FOO;        String fooRightSpace = FOO+"    ";        String fooRightDots = FOO+".........";        assertEquals("", StringUtils.strip(""));        assertEquals("", StringUtils.strip("        "));        assertEquals(FOO, StringUtils.strip(foo2Space));        assertEquals(FOO, StringUtils.strip(foo2Dots, "."));        assertEquals(FOO, StringUtils.strip(fooRightSpace));        assertEquals(FOO, StringUtils.strip(fooRightDots, "."));        assertEquals(FOO, StringUtils.strip(fooLeftSpace));        assertEquals(FOO, StringUtils.strip(fooLeftDots, "."));        assertEquals("", StringUtils.stripStart("", " "));        assertEquals(fooRightSpace, StringUtils.stripStart(foo2Space, " "));        assertEquals(fooRightDots, StringUtils.stripStart(foo2Dots, "."));        assertEquals(fooRightSpace, StringUtils.stripStart(fooRightSpace, " "));        assertEquals(fooRightDots, StringUtils.stripStart(fooRightDots, "."));        assertEquals(FOO, StringUtils.stripStart(fooLeftSpace, " "));        assertEquals(FOO, StringUtils.stripStart(fooLeftDots, "."));        assertEquals("", StringUtils.stripEnd("", " "));        assertEquals(fooLeftSpace, StringUtils.stripEnd(foo2Space, " "));        assertEquals(fooLeftDots, StringUtils.stripEnd(foo2Dots, "."));        assertEquals(FOO, StringUtils.stripEnd(fooRightSpace, " "));        assertEquals(FOO, StringUtils.stripEnd(fooRightDots, "."));        assertEquals(fooLeftSpace, StringUtils.stripEnd(fooLeftSpace, " "));        assertEquals(fooLeftDots, StringUtils.stripEnd(fooLeftDots, "."));        assertEquals(FOO, StringUtils.strip(". . . . ."+FOO+". . ", " ."));        assertEquals("-."+FOO, StringUtils.strip(". . . . -."+FOO+". . ", " ."));        assertEquals(FOO, StringUtils.strip("..  .."+FOO+".. ", " ."));        assertEquals(FOO, StringUtils.strip("..  .."+FOO+".. ", "+= ."));        // test stripAll method, merely an array version of the above strip        String[] empty = new String[0];        String[] fooSpace = new String[] { foo2Space, fooLeftSpace, fooRightSpace };        String[] fooDots = new String[] { foo2Dots, fooLeftDots, fooRightDots };        String[] foo = new String[] { FOO, FOO, FOO };        assertArrayEquals(empty, StringUtils.stripAll(empty));        assertArrayEquals(foo, StringUtils.stripAll(fooSpace));        assertArrayEquals(foo, StringUtils.stripAll(fooDots, "."));    }    private void assertArrayEquals(Object[] o1, Object[] o2) {        if(o1 == null) {            assertEquals(o1,o2);            return;        }        assertEquals("Length not equal. ", o1.length, o2.length);        int sz = o1.length;        for(int i=0; i<sz; i++) {            if(o1[i] instanceof Object[]) {                // do an assert equals on type....                assertArrayEquals( (Object[]) o1[i], (Object[]) o2[i] );            } else {                assertEquals(o1[i], o2[i]);            }        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.lang;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.StringUtils} - Substring methods * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: StringUtilsSubstringTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class StringUtilsSubstringTest extends TestCase {    private static final String FOO = "foo";    private static final String BAR = "bar";    private static final String BAZ = "baz";    private static final String FOOBAR = "foobar";    private static final String SENTENCE = "foo bar baz";    public StringUtilsSubstringTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(StringUtilsSubstringTest.class);    suite.setName("StringUtilsSubstring Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSubstring2() {        assertEquals("", StringUtils.substring(SENTENCE, 80));        assertEquals(BAZ, StringUtils.substring(SENTENCE, 8));        assertEquals(BAZ, StringUtils.substring(SENTENCE, -3));        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0));    }        public void testSubstring3() {        assertEquals("", StringUtils.substring(SENTENCE, 8, 6));        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, 3));        assertEquals("o", StringUtils.substring(SENTENCE, -9, 3));        assertEquals(FOO, StringUtils.substring(SENTENCE, 0, -8));        assertEquals("o", StringUtils.substring(SENTENCE, -9, -8));        assertEquals(SENTENCE, StringUtils.substring(SENTENCE, 0, 80));    }        public void testLeft() {        assertSame(null, StringUtils.left(null, 0));        assertSame(null, StringUtils.left(null, 2));        assertSame("", StringUtils.left("", 0));        assertSame("", StringUtils.left("", 2));        assertEquals("", StringUtils.left(FOOBAR, 0));        assertEquals(FOO, StringUtils.left(FOOBAR, 3));        assertSame(FOOBAR, StringUtils.left(FOOBAR, 80));    }        public void testLeftEx() {        try {            StringUtils.left(FOOBAR, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testRight() {        assertSame(null, StringUtils.right(null, 0));        assertSame(null, StringUtils.right(null, 2));        assertSame("", StringUtils.right("", 0));        assertSame("", StringUtils.right("", 2));        assertEquals("", StringUtils.right(FOOBAR, 0));        assertEquals(BAR, StringUtils.right(FOOBAR, 3));        assertSame(FOOBAR, StringUtils.right(FOOBAR, 80));    }        public void testRightEx() {        try {            StringUtils.right(FOOBAR, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMid() {        assertSame(null, StringUtils.mid(null, 3, 0));        assertSame(null, StringUtils.mid(null, 3, 2));        assertSame("", StringUtils.mid("", 0, 0));        assertSame("", StringUtils.mid("", 0, 2));        assertEquals("", StringUtils.mid(FOOBAR, 3, 0));        assertEquals("b", StringUtils.mid(FOOBAR, 3, 1));        assertEquals(FOO, StringUtils.mid(FOOBAR, 0, 3));        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 3));        assertEquals(FOOBAR, StringUtils.mid(FOOBAR, 0, 80));        assertEquals(BAR, StringUtils.mid(FOOBAR, 3, 80));    }        public void testMidEx1() {        try {            StringUtils.mid(FOOBAR, 0, -1);        } catch (IllegalArgumentException ex) {            return;        }        fail();    }    public void testMidEx2() {        try {            StringUtils.mid(FOOBAR, -1, 3);        } catch (IndexOutOfBoundsException ex) {            return;        }        fail();    }    public void testMidEx3() {        try {            StringUtils.mid(FOOBAR, 7, 3);        } catch (IndexOutOfBoundsException ex) {            return;        }        fail();    }    public void testCountMatches() {        assertEquals(3,              StringUtils.countMatches("one long someone sentence of one", "one"));        assertEquals(0,              StringUtils.countMatches("one long someone sentence of one", "two"));        assertEquals(4,              StringUtils.countMatches("oooooooooooo", "ooo"));    }    public void testGetNestedString() {        assertEquals( "", StringUtils.getNestedString("", "") );        assertEquals( "", StringUtils.getNestedString("    ", " ") );        assertEquals( "bar", StringUtils.getNestedString("\nbar\n", "\n") );        assertEquals( "", StringUtils.getNestedString("", "", "") );        assertEquals( "", StringUtils.getNestedString("    ", " ", "  ") );        assertEquals( "bar", StringUtils.getNestedString("<foo>bar</foo>", "<foo>", "</foo>") );    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link NumberRange} class. * * @author <a href="mailto:chrise@esha.com">Christopher Elkins</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Revision: 1.1 $ $Date: 2002/07/19 03:35:55 $ */public final class NumberRangeTest extends TestCase {    private NumberRange tenToTwenty;    private Number five;    private Number ten;    private Number fifteen;    private Number twenty;    private Number twentyFive;    public NumberRangeTest(String name) {        super(name);    }    public void setUp() {        five       = new Integer(5);        ten        = new Integer(10);        fifteen    = new Integer(15);        twenty     = new Integer(20);        twentyFive = new Integer(25);        tenToTwenty = new NumberRange(ten, twenty);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberRangeTest.class);        suite.setName("NumberRange Tests");        return suite;    }    public void testEquals() {        boolean expected = false;        boolean result = tenToTwenty.equals(new NumberRange(five, ten));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.equals(new NumberRange(ten, twenty));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.equals(new NumberRange(ten, fifteen));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.equals(new NumberRange(fifteen, twenty));        assertEquals(expected, result);    }    public void testIncludesNumber() {        boolean expected = false;        boolean result = tenToTwenty.includesNumber(five);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(ten);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(fifteen);        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesNumber(twenty);        assertEquals(expected, result);        expected = false;        result = tenToTwenty.includesNumber(twentyFive);        assertEquals(expected, result);    }    public void testIncludesRange() {        boolean expected = false;        boolean result = tenToTwenty.includesRange(new NumberRange(five, ten));        assertEquals(expected, result);        expected = false;        result = tenToTwenty.includesRange(new NumberRange(five, fifteen));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(ten, fifteen));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(ten, twenty));        assertEquals(expected, result);        expected = true;        result = tenToTwenty.includesRange(new NumberRange(fifteen, twenty));        assertEquals(expected, result);        expected = false;        result =             tenToTwenty.includesRange(new NumberRange(fifteen, twentyFive));        assertEquals(expected, result);        expected = false;        result =             tenToTwenty.includesRange(new NumberRange(twenty, twentyFive));        assertEquals(expected, result);    }    public void testToString() {        String expected = "10-20";        String result = tenToTwenty.toString();        assertEquals(expected, result);    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.io.ObjectOutputStream;import java.util.HashMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.SerializationUtils}. * * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: SerializationUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class SerializationUtilsTest extends TestCase {    private String iString;    private Integer iInteger;    private HashMap iMap;    public SerializationUtilsTest(String name) {        super(name);    }    public static void main(String[] args) {        TestRunner.run(suite());    }    public static Test suite() {    TestSuite suite = new TestSuite(SerializationUtilsTest.class);    suite.setName("SerializationUtils Tests");        return suite;    }    protected void setUp() throws Exception {        super.setUp();        iString = "foo";        iInteger = new Integer(7);        iMap = new HashMap();        iMap.put("FOO", iString);        iMap.put("BAR", iInteger);    }    protected void tearDown() throws Exception {        super.tearDown();    }    //-----------------------------------------------------------------------    public void testSerializeStream() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        SerializationUtils.serialize(iMap, streamTest);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        byte[] testBytes = streamTest.toByteArray();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeStreamUnserializable() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            iMap.put(new Object(), new Object());            SerializationUtils.serialize(iMap, streamTest);        } catch (SerializationException ex) {            return;        }        fail();    }    public void testSerializeStreamNullObj() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        SerializationUtils.serialize(null, streamTest);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        byte[] testBytes = streamTest.toByteArray();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeStreamObjNull() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            SerializationUtils.serialize(iMap, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testSerializeStreamNullNull() throws Exception {        ByteArrayOutputStream streamTest = new ByteArrayOutputStream();        try {            SerializationUtils.serialize(null, null);        } catch (NullPointerException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testDeserializeStream() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());        Object test = SerializationUtils.deserialize(inTest);        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testDeserializeStreamOfNull() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        ByteArrayInputStream inTest = new ByteArrayInputStream(streamReal.toByteArray());        Object test = SerializationUtils.deserialize(inTest);        assertNull(test);    }    public void testDeserializeStreamNull() throws Exception {        try {            SerializationUtils.deserialize((InputStream) null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testDeserializeStreamBadStream() throws Exception {        try {            SerializationUtils.deserialize(new ByteArrayInputStream(new byte[0]));        } catch (SerializationException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testSerializeBytes() throws Exception {        byte[] testBytes = SerializationUtils.serialize(iMap);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    public void testSerializeBytesUnserializable() throws Exception {        try {            iMap.put(new Object(), new Object());            SerializationUtils.serialize(iMap);        } catch (SerializationException ex) {            return;        }        fail();    }    public void testSerializeBytesNull() throws Exception {        byte[] testBytes = SerializationUtils.serialize(null);        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        byte[] realBytes = streamReal.toByteArray();        assertEquals(testBytes.length, realBytes.length);        for (int i = 0; i < realBytes.length; i++) {            assertEquals(realBytes[i], testBytes[i]);        }    }    //-----------------------------------------------------------------------    public void testDeserializeBytes() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(iMap);        oos.flush();        oos.close();        Object test = SerializationUtils.deserialize(streamReal.toByteArray());        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testDeserializeBytesOfNull() throws Exception {        ByteArrayOutputStream streamReal = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(streamReal);        oos.writeObject(null);        oos.flush();        oos.close();        Object test = SerializationUtils.deserialize(streamReal.toByteArray());        assertNull(test);    }    public void testDeserializeBytesNull() throws Exception {        try {            SerializationUtils.deserialize((byte[]) null);        } catch (NullPointerException ex) {            return;        }        fail();    }    public void testDeserializeBytesBadStream() throws Exception {        try {            SerializationUtils.deserialize(new byte[0]);        } catch (SerializationException ex) {            return;        }        fail();    }    //-----------------------------------------------------------------------    public void testClone() throws Exception {        Object test = SerializationUtils.clone(iMap);        assertNotNull(test);        assertTrue(test instanceof HashMap);        assertTrue(test != iMap);        HashMap testMap = (HashMap) test;        assertEquals(iString, testMap.get("FOO"));        assertTrue(iString != testMap.get("FOO"));        assertEquals(iInteger, testMap.get("BAR"));        assertTrue(iInteger != testMap.get("BAR"));        assertEquals(iMap, testMap);    }    public void testCloneNull() throws Exception {        Object test = SerializationUtils.clone(null);        assertNull(test);    }    public void testCloneUnserializable() throws Exception {        try {            iMap.put(new Object(), new Object());            SerializationUtils.clone(iMap);        } catch (SerializationException ex) {            return;        }        fail();    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import java.lang.reflect.Method;import java.math.BigDecimal;import java.math.BigInteger;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Unit tests {@link org.apache.commons.lang.NumberUtils}. * * @author <a href="mailto:rand_mcneely@yahoo.com">Rand McNeely</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: NumberUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class NumberUtilsTest extends TestCase {    public NumberUtilsTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(NumberUtilsTest.class);        suite.setName("NumberUtils Tests");        return suite;    }    //---------------------------------------------------------------------    /**     * Test for int stringToInt(String)     */    public void testStringToIntString() {        assertTrue("stringToInt(String) 1 failed", NumberUtils.stringToInt("12345") == 12345);        assertTrue("stringToInt(String) 2 failed", NumberUtils.stringToInt("abc") == 0);    }    /**     * Test for int stringToInt(String, int)     */    public void testStringToIntStringI() {        assertTrue("stringToInt(String,int) 1 failed", NumberUtils.stringToInt("12345", 5) == 12345);        assertTrue("stringToInt(String,int) 2 failed", NumberUtils.stringToInt("1234.5", 5) == 5);    }    public void testCreateNumber() {        //a lot of things can go wrong        assertEquals("createNumber(String) 1 failed", new Float("1234.5"), NumberUtils.createNumber("1234.5"));        assertEquals("createNumber(String) 2 failed", new Integer("12345"), NumberUtils.createNumber("12345"));        assertEquals("createNumber(String) 3 failed", new Double("1234.5"), NumberUtils.createNumber("1234.5D"));        assertEquals("createNumber(String) 4 failed", new Float("1234.5"), NumberUtils.createNumber("1234.5F"));        assertEquals("createNumber(String) 5 failed", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber("" + (Integer.MAX_VALUE + 1L)));        assertEquals("createNumber(String) 6 failed", new Long(12345), NumberUtils.createNumber("12345L"));        assertEquals("createNumber(String) 7 failed", new Float("-1234.5"), NumberUtils.createNumber("-1234.5"));        assertEquals("createNumber(String) 8 failed", new Integer("-12345"), NumberUtils.createNumber("-12345"));        assertTrue("createNumber(String) 9 failed", 0xFADE == NumberUtils.createNumber("0xFADE").intValue());        assertTrue("createNumber(String) 10 failed", -0xFADE == NumberUtils.createNumber("-0xFADE").intValue());        assertEquals("createNumber(String) 11 failed", new Double("1.1E200"), NumberUtils.createNumber("1.1E200"));        assertEquals("createNumber(String) 12 failed", new Float("1.1E20"), NumberUtils.createNumber("1.1E20"));        assertEquals("createNumber(String) 13 failed", new Double("-1.1E200"), NumberUtils.createNumber("-1.1E200"));        assertEquals("createNumber(String) 14 failed", new Double("1.1E-200"), NumberUtils.createNumber("1.1E-200"));        assertEquals("createNumber(String) 15 failed", new BigDecimal("1.1E-700"), NumberUtils.createNumber("1.1E-700F"));        assertEquals(            "createNumber(String) 16 failed",            new Long("10" + Integer.MAX_VALUE),            NumberUtils.createNumber("10" + Integer.MAX_VALUE + "L"));        assertEquals(            "createNumber(String) 17 failed",            new Long("10" + Integer.MAX_VALUE),            NumberUtils.createNumber("10" + Integer.MAX_VALUE));        assertEquals(            "createNumber(String) 18 failed",            new BigInteger("10" + Long.MAX_VALUE),            NumberUtils.createNumber("10" + Long.MAX_VALUE));    }    public void testCreateFloat() {        assertEquals("createFloat(String) failed", new Float("1234.5"), NumberUtils.createFloat("1234.5"));    }    public void testCreateDouble() {        assertEquals("createDouble(String) failed", new Double("1234.5"), NumberUtils.createDouble("1234.5"));    }    public void testCreateInteger() {        assertEquals("createInteger(String) failed", new Integer("12345"), NumberUtils.createInteger("12345"));    }    public void testCreateLong() {        assertEquals("createInteger(String) failed", new Long("12345"), NumberUtils.createLong("12345"));    }    public void testCreateBigInteger() {        assertEquals("createBigInteger(String) failed", new BigInteger("12345"), NumberUtils.createBigInteger("12345"));    }    public void testCreateBigDecimal() {        assertEquals("createBigDecimal(String) failed", new BigDecimal("1234.5"), NumberUtils.createBigDecimal("1234.5"));    }    public void testMinimum() {        assertEquals("minimum(int,int,int) 1 failed", 12345, NumberUtils.minimum(12345, 12345 + 1, 12345 + 2));        assertEquals("minimum(int,int,int) 2 failed", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345 + 2));        assertEquals("minimum(int,int,int) 3 failed", 12345, NumberUtils.minimum(12345 + 1, 12345 + 2, 12345));        assertEquals("minimum(int,int,int) 4 failed", 12345, NumberUtils.minimum(12345 + 1, 12345, 12345));        assertEquals("minimum(int,int,int) 5 failed", 12345, NumberUtils.minimum(12345, 12345, 12345));    }    public void testMaximum() {        assertEquals("maximum(int,int,int) 1 failed", 12345, NumberUtils.maximum(12345, 12345 - 1, 12345 - 2));        assertEquals("maximum(int,int,int) 2 failed", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345 - 2));        assertEquals("maximum(int,int,int) 3 failed", 12345, NumberUtils.maximum(12345 - 1, 12345 - 2, 12345));        assertEquals("maximum(int,int,int) 4 failed", 12345, NumberUtils.maximum(12345 - 1, 12345, 12345));        assertEquals("maximum(int,int,int) 5 failed", 12345, NumberUtils.maximum(12345, 12345, 12345));    }    public void testIsDigits() {        assertEquals("isDigits(null) failed", false, NumberUtils.isDigits(null));        assertEquals("isDigits('') failed", false, NumberUtils.isDigits(""));        assertEquals("isDigits(String) failed", true, NumberUtils.isDigits("12345"));        assertEquals("isDigits(String) neg 1 failed", false, NumberUtils.isDigits("1234.5"));        assertEquals("isDigits(String) neg 3 failed", false, NumberUtils.isDigits("1ab"));        assertEquals("isDigits(String) neg 4 failed", false, NumberUtils.isDigits("abc"));    }        /**     * Tests isNumber(String) and tests that createNumber(String) returns     * a valid number iff isNumber(String) returns false.     */    public void testIsNumber() {        String val = "12345";        assertTrue("isNumber(String) 1 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 1 failed", checkCreateNumber(val));        val = "1234.5";        assertTrue("isNumber(String) 2 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 2 failed", checkCreateNumber(val));        val = ".12345";        assertTrue("isNumber(String) 3 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 3 failed", checkCreateNumber(val));        val = "1234E5";        assertTrue("isNumber(String) 4 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 4 failed", checkCreateNumber(val));        val = "1234E+5";        assertTrue("isNumber(String) 5 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 5 failed", checkCreateNumber(val));        val = "1234E-5";        assertTrue("isNumber(String) 6 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 6 failed", checkCreateNumber(val));        val = "123.4E5";        assertTrue("isNumber(String) 7 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 7 failed", checkCreateNumber(val));        val = "-1234";        assertTrue("isNumber(String) 8 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 8 failed", checkCreateNumber(val));        val = "-1234.5";        assertTrue("isNumber(String) 9 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 9 failed", checkCreateNumber(val));        val = "-.12345";        assertTrue("isNumber(String) 10 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 10 failed", checkCreateNumber(val));        val = "-1234E5";        assertTrue("isNumber(String) 11 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 11 failed", checkCreateNumber(val));        val = "0";        assertTrue("isNumber(String) 12 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 12 failed", checkCreateNumber(val));        val = "-0";        assertTrue("isNumber(String) 13 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 13 failed", checkCreateNumber(val));        val = "01234";        assertTrue("isNumber(String) 14 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 14 failed", checkCreateNumber(val));        val = "-01234";        assertTrue("isNumber(String) 15 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 15 failed", checkCreateNumber(val));        val = "0xABC123";        assertTrue("isNumber(String) 16 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 16 failed", checkCreateNumber(val));        val = "0x0";        assertTrue("isNumber(String) 17 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 17 failed", checkCreateNumber(val));        val = "123.4E21D";        assertTrue("isNumber(String) 19 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 19 failed", checkCreateNumber(val));        val = "-221.23F";        assertTrue("isNumber(String) 20 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 20 failed", checkCreateNumber(val));        val = "22338L";        assertTrue("isNumber(String) 21 failed", NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 21 failed", checkCreateNumber(val));        val = null;        assertTrue("isNumber(String) 1 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 1 Neg failed", !checkCreateNumber(val));        val = "";        assertTrue("isNumber(String) 2 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 2 Neg failed", !checkCreateNumber(val));        val = "--2.3";        assertTrue("isNumber(String) 3 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 3 Neg failed", !checkCreateNumber(val));        val = ".12.3";        assertTrue("isNumber(String) 4 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 4 Neg failed", !checkCreateNumber(val));        val = "-123E";        assertTrue("isNumber(String) 5 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 5 Neg failed", !checkCreateNumber(val));        val = "-123E+-212";        assertTrue("isNumber(String) 6 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 6 Neg failed", !checkCreateNumber(val));        val = "-123E2.12";        assertTrue("isNumber(String) 7 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 7 Neg failed", !checkCreateNumber(val));        val = "0xGF";        assertTrue("isNumber(String) 8 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 8 Neg failed", !checkCreateNumber(val));        val = "0xFAE-1";        assertTrue("isNumber(String) 9 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 9 Neg failed", !checkCreateNumber(val));        val = ".";        assertTrue("isNumber(String) 10 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 10 Neg failed", !checkCreateNumber(val));        val = "-0ABC123";        assertTrue("isNumber(String) 11 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 11 Neg failed", !checkCreateNumber(val));        val = "123.4E-D";        assertTrue("isNumber(String) 12 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 12 Neg failed", !checkCreateNumber(val));        val = "123.4ED";        assertTrue("isNumber(String) 13 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 13 Neg failed", !checkCreateNumber(val));        val = "1234E5l";        assertTrue("isNumber(String) 14 Neg failed", !NumberUtils.isNumber(val));        assertTrue("isNumber(String)/createNumber(String) 14 Neg failed", !checkCreateNumber(val));    }    private boolean checkCreateNumber(String val) {        try {            Object obj = NumberUtils.createNumber(val);            if(obj == null) {                return false;            }            return true;        } catch (NumberFormatException e) {            return false;        } catch (NullPointerException e) {            return false;        }    }}
package org.apache.commons.lang;/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2002 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, *    if any, must include the following acknowledgment: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowledgment may appear in the software itself, *    if and wherever such third-party acknowledgments normally appear. * * 4. The names "Apache" and "Apache Software Foundation" and *    "Commons" must not be used to endorse or promote products *    derived from this software without prior written permission. For *    written permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache", *    nor may "Apache" appear in their name, without *    prior written permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */import junit.framework.*;import junit.textui.TestRunner;/** * Unit tests {@link org.apache.commons.lang.RandomStringUtils}. * * @author <a href="mailto:steven@caswell.name">Steven Caswell</a> * @author <a href="mailto:ridesmet@users.sourceforge.net">Ringo De Smet</a> * @version $Id: RandomStringUtilsTest.java,v 1.1 2002/07/19 03:35:55 bayard Exp $ */public class RandomStringUtilsTest extends junit.framework.TestCase {    /**     * Construct a new instance of RandomStringUtilsTest with the specified name     */    public RandomStringUtilsTest(String name) {        super(name);    }    public static Test suite() {    TestSuite suite = new TestSuite(RandomStringUtilsTest.class);    suite.setName("RandomStringUtils Tests");        return suite;    }        /**     * Set up instance variables required by this test case.     */    public void setUp() {    }        /**     * Tear down instance variables required by this test case.     */    public void tearDown() {    }        /**     * Test the implementation     */    public void testRandomStringUtils() {        String r1 = RandomStringUtils.random(50);        assertEquals("random(5) length", 50, r1.length());        String r2 = RandomStringUtils.random(50);        assertEquals("random(5) length", 50, r2.length());        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomAscii(50);        assertEquals("randomAscii(10) length", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("char between 32 and 127", (int) r1.charAt(i) >= 32 && (int) r1.charAt(i) <= 127);        }                r2 = RandomStringUtils.randomAscii(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));        r1 = RandomStringUtils.randomAlphabetic(50);        assertEquals("randomAlphabetic(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains alphabetic", true, Character.isLetter(r1.charAt(i)) && !Character.isDigit(r1.charAt(i)));        }        r2 = RandomStringUtils.randomAlphabetic(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomAlphanumeric(50);        assertEquals("randomAlphanumeric(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains alphanumeric", true, Character.isLetterOrDigit(r1.charAt(i)));        }        r2 = RandomStringUtils.randomAlphabetic(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                r1 = RandomStringUtils.randomNumeric(50);        assertEquals("randomNumeric(50)", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertEquals("r1 contains numeric", true, Character.isDigit(r1.charAt(i)) && !Character.isLetter(r1.charAt(i)));        }        r2 = RandomStringUtils.randomNumeric(50);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                String set = "abcdefg";        r1 = RandomStringUtils.random(50, set);        assertEquals("random(50, \"abcdefg\")", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);        }        r2 = RandomStringUtils.random(50, set);        assertTrue("!r1.equals(r2)", !r1.equals(r2));                set = "stuvwxyz";        r1 = RandomStringUtils.random(50, set.toCharArray());        assertEquals("random(50, \"stuvwxyz\")", 50, r1.length());        for(int i = 0; i < r1.length(); i++) {            assertTrue("random char in set", set.indexOf(r1.charAt(i)) > -1);        }        r2 = RandomStringUtils.random(50, set);        assertTrue("!r1.equals(r2)", !r1.equals(r2));    }    public static void main(String args[]) {        TestRunner.run(suite());    }}