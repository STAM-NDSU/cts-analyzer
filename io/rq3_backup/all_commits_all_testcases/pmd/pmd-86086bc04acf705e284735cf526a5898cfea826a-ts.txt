/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class GroovyTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "BTree.groovy";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new GroovyTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(GroovyTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 369;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyForeachStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveTemplateLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineJavaScriptTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineStylesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedMacroParameterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm;import java.io.StringReader;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for VM parsing. *  */public class VmParserTest {    private static final String VM_SRC = "<HTML><BODY>Hello $customer.Name <table> "            + "#foreach($mud in $mudsOnSpecial)" + "  #if ( $customer.hasPurchased($mud) )" + "     <tr>" + "      <td>"            + "       $flogger.getPromo( $mud )" + "    </td>" + "  </tr>" + " #elseif ($customer.broke) do stuff #end"            + "\n " + "#end " + "</table>";    private static final String SRC2 = "#macro(tablerows $color $values ) " + "#foreach( $value in $values ) "            + "<tr><td bgcolor=$color>$value</td></tr> " + "#end " + "#end "            + "#set( $greatlakes = [\"Superior\",\"Michigan\",\"Huron\",\"Erie\",\"Ontario\"] ) "            + "#set( $color = \"blue\" ) " + "<table> " + " #tablerows( $color $greatlakes ) " + "</table>";    private static final String SRC3 = "#if ( $c1 ) #if ( $c2)#end #end";    // private static final String VM_SRC = "#if( $mud == 1 ) blah #if ($dirt ==    // 2) stuff #end #end";    @Test    public void testParser() {        final Node node = parse(VM_SRC);        Assert.assertNotNull(node);    }    @Test    public void testParser2() {        final Node node = parse(SRC2);        Assert.assertNotNull(node);    }    @Test    public void testParser3() {        final Node node = parse(SRC3);        Assert.assertNotNull(node);    }    private Node parse(final String code) {        final LanguageVersionHandler vmLang = LanguageRegistry.getLanguage(VmLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler();        final Parser parser = vmLang.getParser(vmLang.getDefaultParserOptions());        final Node node = parser.parse(null, new StringReader(code));        return node;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vm.VmLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VmLanguageModule.NAME, VmLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(VmLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test velocity's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.dfa;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.AbstractNode;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.dfa.NodeType;import net.sourceforge.pmd.lang.dfa.StartOrEndDataFlowNode;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;import net.sourceforge.pmd.lang.plsql.ast.ASTExpression;import net.sourceforge.pmd.lang.plsql.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.plsql.ast.ASTProgramUnit;import net.sourceforge.pmd.lang.plsql.ast.ASTVariableOrConstantDeclarator;import net.sourceforge.pmd.lang.plsql.ast.PLSQLNode;public class StatementAndBraceFinderTest extends AbstractPLSQLParserTst {    /**     * Java ASTStatementExpression equivalent is inferred as an Expression()     * which has an UnlabelledStatement as a parent.     */    @Test    public void testExpressionParentChildLinks() {        ASTExpression ex = getOrderedNodes(ASTExpression.class, TEST1).get(0);        DataFlowNode dfn = ex.getDataFlowNode();        assertEquals(3, dfn.getLine());        assertTrue(dfn.getNode() instanceof ASTExpression);        List<DataFlowNode> dfns = dfn.getParents();        assertEquals(1, dfns.size());        DataFlowNode parentDfn = dfns.get(0);        assertEquals(2, parentDfn.getLine());        assertTrue(parentDfn.getNode() instanceof ASTProgramUnit);        ASTProgramUnit exParent = (ASTProgramUnit) parentDfn.getNode();        // Validate the two-way link between Program Unit and Statement        assertEquals(ex, exParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(exParent, ex.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testVariableOrConstantDeclaratorParentChildLinks() {        ASTVariableOrConstantDeclarator vd = getOrderedNodes(ASTVariableOrConstantDeclarator.class, TEST2).get(0);        // ASTMethodDeclaration vdParent = (ASTMethodDeclaration)        // ((DataFlowNode) vd.getDataFlowNode().getParents().get(0)).getNode();        ASTProgramUnit vdParent = (ASTProgramUnit) vd.getDataFlowNode().getParents().get(0).getNode();        // Validate the two-way link between Program Unit and Variable        assertEquals(vd, vdParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(vdParent, vd.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testIfStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST3).get(0);        assertEquals(5, exp.getDataFlowNode().getFlow().size());        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.IF_EXPR));        assertEquals(3, dfn.getLine());        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE));        assertEquals(3, dfn.getLine());    }    @Test    public void testWhileStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST4).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.WHILE_EXPR));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.WHILE_LAST_STATEMENT));    }    @Test    public void testForStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST5).get(0);        DataFlowNode dfn = null;        dfn = exp.getDataFlowNode().getFlow().get(0);        assertTrue(dfn instanceof StartOrEndDataFlowNode);        dfn = exp.getDataFlowNode().getFlow().get(1);        assertTrue(dfn.getNode() instanceof ASTProgramUnit);        assertEquals(2, dfn.getLine());        dfn = exp.getDataFlowNode().getFlow().get(2);        assertEquals(3, dfn.getLine());        assertTrue(dfn.isType(NodeType.FOR_EXPR));        assertTrue(dfn.isType(NodeType.FOR_BEFORE_FIRST_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertEquals(3, dfn.getLine());        assertTrue(dfn.isType(NodeType.FOR_END));    }    @Test    public void testSimpleCaseStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST6).get(0);        DataFlowNode dfn = null;        dfn = exp.getDataFlowNode().getFlow().get(0);        assertTrue(dfn instanceof StartOrEndDataFlowNode);        dfn = exp.getDataFlowNode().getFlow().get(1);        assertEquals(2, dfn.getLine());        assertTrue(dfn.getNode() instanceof ASTProgramUnit);        dfn = exp.getDataFlowNode().getFlow().get(2);        assertEquals(4, dfn.getLine());        assertTrue(dfn.isType(NodeType.SWITCH_START));        assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertEquals(5, dfn.getLine());        assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT));        assertTrue(dfn.isType(NodeType.BREAK_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(4);        assertEquals(6, dfn.getLine());        assertTrue(dfn.isType(NodeType.SWITCH_LAST_DEFAULT_STATEMENT));        assertTrue(dfn.isType(NodeType.BREAK_STATEMENT));        dfn = exp.getDataFlowNode().getFlow().get(5);        assertEquals(7, dfn.getLine());        assertTrue(dfn.isType(NodeType.SWITCH_END));    }    /*     * @Test public void testSearchedCaseStmtHasCorrectTypes()     * { List<ASTStatement> statements = getOrderedNodes(ASTStatement.class,     * TEST7); List<ASTExpression> expressions =     * getOrderedNodes(ASTExpression.class, TEST7);     *      * ASTStatement st = statements.get(0); ASTStatement st1 =     * statements.get(1); ASTStatement st2 = statements.get(2); ASTStatement st3     * = statements.get(3);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-st(0)="+st.     * getBeginLine());     *      * ASTExpression ex = expressions.get(0); ASTExpression ex1 =     * expressions.get(1); ASTExpression ex2 = expressions.get(2); ASTExpression     * ex3 = expressions.get(3); ASTExpression ex4 = expressions.get(4);     * System.err.println("ASTExpression="+ex );     *      * DataFlowNode dfn = null; //dfn = ex.getDataFlowNode().getFlow().get(0);     * //dfn = st.getDataFlowNode().getFlow().get(0); dfn = (DataFlowNode)     * st.getDataFlowNode(); System.err.println("DataFlowNode(st-0)="+dfn ) ;     * System.err.println("DataFlowNode(st-1)="+st1.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(st-2)="+st2.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(st-3)="+st3.getDataFlowNode() ) ;     *      * System.err.println("DataFlowNode(ex-0)="+ex.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-1)="+ex1.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-2)="+ex2.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-3)="+ex3.getDataFlowNode() ) ;     * System.err.println("DataFlowNode(ex-4)="+ex4.getDataFlowNode() ) ;     * List<DataFlowNode> dfns = dfn.getFlow();     * System.err.println("DataFlowNodes List size="+dfns.size()) ; DataFlowNode     * firstDfn = dfns.get(0); System.err.println("firstDataFlowNode="+firstDfn     * ) ;     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(0)="+dfn);     * dfn = st.getDataFlowNode().getFlow().get(1);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(1)="+dfn);     * dfn = st.getDataFlowNode().getFlow().get(2);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(2)="+dfn);     * assertTrue(dfn.isType(NodeType.SWITCH_START)); dfn =     * st.getDataFlowNode().getFlow().get(3);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(3)="+dfn);     * assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT)); //dfn =     * st.getDataFlowNode().getFlow().get(4);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(5)="+dfn);     * assertTrue(dfn.isType(NodeType.CASE_LAST_STATEMENT)); dfn =     * st.getDataFlowNode().getFlow().get(5);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(7)="+dfn);     * assertTrue(dfn.isType(NodeType.SWITCH_LAST_DEFAULT_STATEMENT)); dfn =     * st.getDataFlowNode().getFlow().get(6);     * System.err.println("testSearchedCaseStmtHasCorrectTypes-dfn(8)="+dfn);     * assertTrue(dfn.isType(NodeType.SWITCH_END)); }     */    @Test    public void testLabelledStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST8).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertEquals(3, dfn.getLine());        assertTrue(dfn.isType(NodeType.LABEL_STATEMENT));    }    @Test    public void testOnlyWorksForMethodsAndConstructors() {        StatementAndBraceFinder sbf = new StatementAndBraceFinder(LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler().getDataFlowHandler());        PLSQLNode node = new ASTMethodDeclaration(1);        ((AbstractNode) node).testingOnlySetBeginColumn(1);        sbf.buildDataFlowFor(node);        // sbf.buildDataFlowFor(new ASTConstructorDeclaration(1));        node = new ASTProgramUnit(1);        ((AbstractNode) node).testingOnlySetBeginColumn(1);        sbf.buildDataFlowFor(node);    }    private static final String TEST1 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  x := 2;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST2 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS "            + PMD.EOL + "  int x; " + PMD.EOL + "  BEGIN NULL ;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST3 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  if (x) THEN NULL; END IF; " + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST4 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  while (x) LOOP NULL; END LOOP;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST5 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + "  for i in 0..9 LOOP NULL; END LOOP;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";    private static final String TEST6 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS "            + PMD.EOL + " BEGIN" + PMD.EOL + " CASE 1 " + PMD.EOL + " WHEN 0 THEN NULL; " + PMD.EOL            + " WHEN 1 THEN NULL; " + PMD.EOL + " ELSE NULL;" + PMD.EOL + " END CASE; " + PMD.EOL + " END bar; "            + PMD.EOL + "END foo;";    private static final String TEST7 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS "            + PMD.EOL + " BEGIN" + PMD.EOL + " CASE " + PMD.EOL + " WHEN 0=1 THEN NULL; " + PMD.EOL            + " WHEN 1=1 THEN NULL; " + PMD.EOL + " ELSE NULL;" + PMD.EOL + " END CASE;" + PMD.EOL + " END bar;"            + PMD.EOL + "END foo;";    private static final String TEST8 = "CREATE OR REPLACE PACKAGE BODY Foo AS" + PMD.EOL + " PROCEDURE bar IS BEGIN"            + PMD.EOL + " <<label>> NULL;" + PMD.EOL + " END bar;" + PMD.EOL + "END foo;";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToDateToCharTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATE_TO_CHAR");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToDateWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATEWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToTimestampWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_TIMESTAMPWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssObjectCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePackageSpecificationLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveTypeLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePackageBodyLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NPathComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveObjectLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CodeFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LineLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidTabCharacterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MisplacedPragmaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TomKytesDespairTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class InsertIntoClauseTest extends AbstractPLSQLParserTst {    @Test    public void parseInsertInto() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InsertIntoClause.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseInsertIntoReturning() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InsertIntoClauseReturning.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseInsertIntoWithRecord() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InsertIntoClauseRecord.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class XMLElementTest extends AbstractPLSQLParserTst {    @Test    public void testParseXMLElement() throws Exception {        ASTInput input = parsePLSQL(IOUtils.toString(this.getClass().getResourceAsStream("XMLElement.pls"),                StandardCharsets.UTF_8));        Assert.assertNotNull(input);        List<ASTXMLElement> xmlelements = input.findDescendantsOfType(ASTXMLElement.class);        Assert.assertEquals(10, xmlelements.size());        Assert.assertEquals("\"Emp\"", xmlelements.get(0).getFirstChildOfType(ASTID.class).getImage());        Assert.assertTrue(xmlelements.get(3).jjtGetChild(1) instanceof ASTXMLAttributesClause);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorForLoopTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorForLoopSimple() {        String code = loadTestResource("CursorForLoopSimple.pls");        ASTInput input = parsePLSQL(code);        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        Assert.assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        Assert.assertNotNull(forindex);        Assert.assertEquals("someone", forindex.getImage());    }    @Test    public void parseCursorForLoopNested() {        String code = loadTestResource("CursorForLoopNested.pls");        ASTInput input = parsePLSQL(code);        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        Assert.assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        Assert.assertNotNull(forindex);        Assert.assertEquals("c_cmp", forindex.getImage());        ASTCursorForLoopStatement forloop2 = forloop.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex2 = forloop2.getFirstChildOfType(ASTForIndex.class);        Assert.assertEquals("c_con", forindex2.getImage());        ASTCursorForLoopStatement forloop3 = forloop2.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex3 = forloop3.getFirstChildOfType(ASTForIndex.class);        Assert.assertEquals("c_pa", forindex3.getImage());    }    @Test    public void parseCursorForLoop1047a() {        String code = loadTestResource("CursorForLoop1047a.pls");        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseCursorForLoop1047b() {        String code = loadTestResource("CursorForLoop1047b.pls");        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseCursorForLoop681() {        String code = loadTestResource("CursorForLoop681.pls");        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class JoinClauseTest extends AbstractPLSQLParserTst {    @Test    public void testInnerCrossJoin() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InnerCrossJoin.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(1, joins.size());        Assert.assertTrue(joins.get(0).isCross());        Assert.assertFalse(joins.get(0).isNatural());    }    @Test    public void testInnerNaturalJoin() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InnerNaturalJoin.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(2, joins.size());        Assert.assertFalse(joins.get(0).isCross());        Assert.assertTrue(joins.get(0).isNatural());    }    @Test    public void testInnerJoinUsing() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InnerJoinUsing.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(3, joins.size());        Assert.assertFalse(joins.get(0).isCross());        Assert.assertFalse(joins.get(0).isNatural());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        Assert.assertEquals(1, columns.size());        Assert.assertEquals("department_id", columns.get(0).getImage());    }    @Test    public void testOuterJoinUsing() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("OuterJoinUsing.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.FULL, type.getType());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        Assert.assertEquals(1, columns.size());        Assert.assertEquals("department_id", columns.get(0).getImage());    }    @Test    public void testRightOuterJoin() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("RightOuterJoin.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());    }    @Test    public void testLeftOuterJoin() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("LeftOuterJoin.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.LEFT, type.getType());        List<ASTSelectStatement> selects = input.findDescendantsOfType(ASTSelectStatement.class);        Assert.assertEquals(2, selects.size());        Assert.assertTrue(selects.get(0).getFromClause().jjtGetChild(0) instanceof ASTJoinClause);        Assert.assertTrue(selects.get(1).getFromClause().jjtGetChild(0) instanceof ASTJoinClause);    }    @Test    public void testNaturalRightOuterJoin() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("NaturalRightOuterJoin.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        Assert.assertTrue(joins.get(0).isNatural());    }    @Test    public void testOuterJoinPartitioned() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("OuterJoinPartitioned.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        Assert.assertNotNull(joins.get(0).getFirstChildOfType(ASTQueryPartitionClause.class));    }    @Test    public void testFullOuterJoin() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("FullOuterJoin.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testInnerJoinSubquery() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("InnerJoinSubquery.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testJoinOperator() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("JoinOperator.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTOuterJoinExpression> expressions = input.findDescendantsOfType(ASTOuterJoinExpression.class);        Assert.assertEquals(4, expressions.size());        Assert.assertEquals("h.opp_id", expressions.get(3).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorAttributesTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorWithAttribute() {        String code = loadTestResource("CursorAttributes.pls");        ASTInput input = parsePLSQL(code);        ASTExpression exp = input.getFirstDescendantOfType(ASTIfStatement.class).getFirstChildOfType(ASTExpression.class);        Assert.assertEquals("TestSearch%notfound", exp.getImage());    }    @Test    public void parseImplicitCursorAttributeBulkExceptions() {        String code = loadTestResource("CursorAttributesBulkExceptions.pls");        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class DeleteStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseDeleteStatementExample() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("DeleteStatementExample.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTDeleteStatement> deleteStatements = input.findDescendantsOfType(ASTDeleteStatement.class);        Assert.assertEquals(3, deleteStatements.size());        Assert.assertEquals("product_descriptions", deleteStatements.get(0).jjtGetChild(0)                .getFirstChildOfType(ASTTableName.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectUnionTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectUnion() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectUnion.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectIntoWithGroupByTest extends AbstractPLSQLParserTst {    @Test    public void testExample1() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoWithGroupBy1.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        Assert.assertNotNull(groupByClause);    }    @Test    public void testExample2() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoWithGroupBy2.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        Assert.assertNotNull(groupByClause);    }    @Test    public void testExample3WithCube() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoWithGroupBy3.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        ASTRollupCubeClause cubeClause = input.getFirstDescendantOfType(ASTRollupCubeClause.class);        Assert.assertNotNull(cubeClause);        Assert.assertEquals("CUBE", cubeClause.getImage());    }    @Test    public void testExample4WithGroupingSets() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoWithGroupBy4.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        ASTGroupingSetsClause groupingSetsClause = input.getFirstDescendantOfType(ASTGroupingSetsClause.class);        Assert.assertNotNull(groupingSetsClause);        List<ASTFromClause> fromClauses = input.findDescendantsOfType(ASTFromClause.class);        Assert.assertEquals(1, fromClauses.size());        Assert.assertEquals(5, fromClauses.get(0).jjtGetNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectForUpdateTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectForUpdateWait() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectForUpdateWait.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);        Assert.assertEquals(5, input.findDescendantsOfType(ASTForUpdateClause.class).size());    }    @Test    public void parseSelectForUpdate() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectForUpdate.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);        List<ASTForUpdateClause> forUpdateClauses = input.findDescendantsOfType(ASTForUpdateClause.class);        Assert.assertEquals(2, forUpdateClauses.size());        Assert.assertEquals(2, forUpdateClauses.get(1).jjtGetNumChildren());        Assert.assertEquals("e", forUpdateClauses.get(1).jjtGetChild(0).getImage());        Assert.assertEquals("salary", forUpdateClauses.get(1).jjtGetChild(1).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectExpressionsTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectExpression() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectExpressions.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseSelectSimpleExpression() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectSimpleExpression.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);        List<ASTSimpleExpression> simpleExpressions = input.findDescendantsOfType(ASTSimpleExpression.class);        Assert.assertEquals(1, simpleExpressions.size());        ASTSimpleExpression exp = simpleExpressions.get(0);        Assert.assertEquals("e.first_name", exp.getImage());        Assert.assertEquals(2, exp.jjtGetNumChildren());        Assert.assertEquals(ASTTableName.class, exp.jjtGetChild(0).getClass());        Assert.assertEquals(ASTColumn.class, exp.jjtGetChild(1).getClass());    }    @Test    public void parseSelectCount() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectCount.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseSelectSubqueryExpression() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectSubqueryExpressions.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CreateTableTest extends AbstractPLSQLParserTst {    @Test    public void parseCreateTable() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("CreateTable.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);        // 5th column of first table statement has a inline constraint of type check        ASTTableColumn columnStatus = input.findChildrenOfType(ASTTable.class).get(0).findChildrenOfType(ASTTableColumn.class).get(4);        Assert.assertEquals("status", columnStatus.getFirstChildOfType(ASTID.class).getImage());        Assert.assertEquals(ConstraintType.CHECK, columnStatus.getFirstChildOfType(ASTInlineConstraint.class).getType());    }    @Test    public void parseCreateOrganizedTable() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("CreateOrganizedTable.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TrimWithRecordTypeTest extends AbstractPLSQLParserTst {    @Test    public void parseTrimWithRecordType() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("TrimWithRecordType.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class WhereClauseTest extends AbstractPLSQLParserTst {    @Test    public void testFunctionCall() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseFunctionCall.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTSelectIntoStatement> selectStatements = input.findDescendantsOfType(ASTSelectIntoStatement.class);        Assert.assertEquals(4, selectStatements.size());        ASTFunctionCall functionCall = selectStatements.get(0).getFirstDescendantOfType(ASTFunctionCall.class);        Assert.assertEquals("UPPER", functionCall.getImage());        ASTFunctionCall functionCall2 = selectStatements.get(2).getFirstDescendantOfType(ASTFunctionCall.class);        Assert.assertEquals("utils.get_colname", functionCall2.getImage());    }    @Test    public void testLikeCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseLike.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testNullCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseIsNull.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testBetweenCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseBetween.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testInCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseIn.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testIsOfTypeCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseIsOfType.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testConcatenationOperator() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseConcatenation.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testExistsCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseExists.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testMultisetCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseMultiset.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testRegexpLikeCondition() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseRegexpLike.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        List<ASTRegexpLikeCondition> regexps = input.findDescendantsOfType(ASTRegexpLikeCondition.class);        Assert.assertEquals(3, regexps.size());        Assert.assertEquals("last_name", regexps.get(1).getSourceChar().getImage());        Assert.assertEquals("'([aeiou])\\1'", regexps.get(1).getPattern().getImage());        Assert.assertEquals("'i'", regexps.get(1).getMatchParam());    }    @Test    public void testSubqueries() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseSubqueries.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParentheses() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("WhereClauseParens.pls"),                StandardCharsets.UTF_8);        parsePLSQL(code);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class AnonymousBlockTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorInsideProcAnonymousBlock() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("AnonymousBlock1.sql"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseCursorInsideAnonymousBlock() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("AnonymousBlock2.sql"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorWithWithTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorWithWith() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("CursorWithWith.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);        ASTCursorUnit cursor = input.getFirstDescendantOfType(ASTCursorUnit.class);        ASTSelectStatement select = (ASTSelectStatement) cursor.jjtGetChild(1);        ASTWithClause with = (ASTWithClause) select.jjtGetChild(0);        ASTName queryName = (ASTName) with.jjtGetChild(0);        Assert.assertEquals("risk_set", queryName.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectHierarchicalTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectHierarchicalQueries() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectHierarchical.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class XMLTableTest extends AbstractPLSQLParserTst {    @Test    public void testParseXMLTable() throws Exception {        ASTInput input = parsePLSQL(IOUtils.toString(this.getClass().getResourceAsStream("XMLTable.pls"),                StandardCharsets.UTF_8));        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ViewTest extends AbstractPLSQLParserTst {    @Test    public void parseCreateViewIssue981() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("ViewIssue981.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseCreateView() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("CreateViewWithSubquery.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseCreateViewWithoutSemicolon() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("QueryWithoutSemicolon.sql"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class RecordTypeTest extends AbstractPLSQLParserTst {    @Test    public void parseRecordType() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("RecordType.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class FunctionsTest extends AbstractPLSQLParserTst {    @Test    public void parseTrimCall() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("TrimFunction.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseSelectExtractExpression() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("ExtractExpressions.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectIntoStatementTest extends AbstractPLSQLParserTst {    @Test    public void testParsingComplex() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatement.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingExample1() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementExample1.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingExample2() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementExample2.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingExample3() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementExample3.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingExample4() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementExample4.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingExample5() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementExample5.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingWithFunctionCall() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementFunctionCall.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }    @Test    public void testParsingIntoRecordField() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("SelectIntoStatementRecordField.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class IfStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseIfWithElseIf() throws Exception {        String code = "BEGIN\nIF 1 = 1 THEN null;\nELSIF (2 = 2) THEN null;\nELSE null;\nEND IF;\nEND;\n/\n";        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ExecuteImmediateTest extends AbstractPLSQLParserTst {    @Test    public void parseExecuteImmediate1047a() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("ExecuteImmediate1047a.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void parseExecuteImmediate1047b() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("ExecuteImmediate1047b.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class UpdateStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseUpdateStatementExample() {        String code = loadTestResource("UpdateStatementExample.pls");        ASTInput input = parsePLSQL(code);        List<ASTUpdateStatement> updateStatements = input.findDescendantsOfType(ASTUpdateStatement.class);        Assert.assertEquals(2, updateStatements.size());        Assert.assertEquals(2, updateStatements.get(1).getFirstChildOfType(ASTUpdateSetClause.class)                .findChildrenOfType(ASTColumn.class).size());    }    @Test    public void parseUpdateStatementExample2() {        ASTInput input = parsePLSQL(loadTestResource("UpdateStatementExample2.pls"));        Assert.assertNotNull(input);    }    @Test    public void parseUpdateStatementRef() {        ASTInput input = parsePLSQL(loadTestResource("UpdateStatementRef.pls"));        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTCompoundConditionTest extends AbstractPLSQLParserTst {    @Test    public void testParseType() {        ASTInput input = parsePLSQL("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1 AnD user_id = 2; END;");        List<ASTCompoundCondition> compoundConditions = input.findDescendantsOfType(ASTCompoundCondition.class);        Assert.assertFalse(compoundConditions.isEmpty());        Assert.assertEquals("AND", compoundConditions.get(0).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class OrderByExpressionsTest extends AbstractPLSQLParserTst {    @Test    public void parseOrderByExpression() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("OrderByExpression.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTComparisonConditionTest extends AbstractPLSQLParserTst {    @Test    public void testOperator() {        ASTInput input = parsePLSQL("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1; END;");        List<ASTComparisonCondition> conditions = input.findDescendantsOfType(ASTComparisonCondition.class);        Assert.assertEquals(1, conditions.size());        Assert.assertEquals("=", conditions.get(0).getOperator());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TableCollectionExpressionTest extends AbstractPLSQLParserTst {    @Test    public void testExamples() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("TableCollectionExpressionExamples.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }    @Test    public void testIssue1526() throws Exception {        String code = IOUtils.toString(this.getClass().getResourceAsStream("TableCollectionExpressionIssue1526.pls"),                StandardCharsets.UTF_8);        ASTInput input = parsePLSQL(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Test;public class PLSQLParserTest extends AbstractPLSQLParserTst {    @Test    public void testExceptions() {        parsePLSQL("CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                + "        doSomethingElse;" + "END;");    }    /**     * See https://sourceforge.net/p/pmd/bugs/1167/     */    @Test    public void testBOM() {        parsePLSQL("\ufeff" + "CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                + "        doSomethingElse;" + "END;");    }    @Test(timeout = 5000)    public void testBug1531() {        parsePLSQL("create or replace force view oxa.o_xa_function_role_types as\n"                + "select \"CFT_ID\",\"CFR_ID\",\"CFT_NAME\",\"TCN\",\"LOG_MODULE\",\"LOG_USER\",\"LOG_DATE\",\"LOG_TIME\" from crm_function_role_types\n"                + "/");    }    @Test    public void testBug1527() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/InlinePragmaProcError.pls"), StandardCharsets.UTF_8));    }    @Test    public void testBug1520IsOfType() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/IsOfType.pls"), StandardCharsets.UTF_8));    }    @Test    public void testBug1520Using() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/Using.pls"), StandardCharsets.UTF_8));    }    @Test    public void testSingleLineSelect() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/SingleLineSelect.pls"), StandardCharsets.UTF_8));    }    @Test    public void testMultiLineSelect() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/MultiLineSelect.pls"), StandardCharsets.UTF_8));    }    @Test    public void testIsNull() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/IsNull.pls"), StandardCharsets.UTF_8));    }    @Test    public void testCodingStyleExample() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/CodingStyleExample.pls"), StandardCharsets.UTF_8));    }    @Test    public void testCaseIssue1454() throws Exception {        parsePLSQL(IOUtils.toString(PLSQLParserTest.class.getResourceAsStream("ast/CaseIssue1454.pls"), StandardCharsets.UTF_8));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql;import java.util.Arrays;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.plsql.ast.ASTInput;import net.sourceforge.pmd.lang.rule.XPathRule;/** * Tests to use XPath rules with PLSQL. */public class PLSQLXPathRuleTest extends AbstractPLSQLParserTst {    private ASTInput node = parsePLSQL(            "create or replace\n" + "package pkg_xpath_problem\n" + "AS\n" + "    PROCEDURE pkg_minimal\n" + "    IS\n"                    + "        a_variable VARCHAR2(1);\n" + "    BEGIN \n" + "        --PRAGMA INLINE(output,'YES');\n"                    + "        a_variable := 'Y' ;\n" + "    END ;\n" + "end pkg_xpath_problem;\n" + "/\n" + "");    private RuleContext ctx = new RuleContext();    @Before    public void setup() {        ctx.setLanguageVersion(LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule1() {        XPathRule rule = createRule("1.0");        rule.apply(Arrays.asList(node), ctx);        Assert.assertEquals(2, ctx.getReport().treeSize());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule1Compatibility() {        XPathRule rule = createRule("1.0 compatibility");        rule.apply(Arrays.asList(node), ctx);        Assert.assertEquals(2, ctx.getReport().treeSize());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule2() {        XPathRule rule = createRule("2.0");        rule.apply(Arrays.asList(node), ctx);        Assert.assertEquals(2, ctx.getReport().treeSize());    }    private XPathRule createRule(String version) {        XPathRule rule = new XPathRule("//PrimaryPrefix");        rule.setLanguage(LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME));        rule.setVersion(version);        rule.setMessage("Test Violation");        return rule;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class PLSQLTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "sample-plsql.sql";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new PLSQLTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(PLSQLTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 1422;        super.tokenizeTest();    }        @Test    public void testIgnoreBetweenSpecialComments() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("-- CPD-OFF" + PMD.EOL                + "CREATE OR REPLACE" + PMD.EOL                + "PACKAGE \"test_schema\".\"BANK_DATA\"" + PMD.EOL                + "IS" + PMD.EOL                + "pi      CONSTANT NUMBER := 3.1415;" + PMD.EOL                + "--CPD-ON" + PMD.EOL                + "END;"        ));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(3, tokens.size()); // 3 tokens: "END" + ";" + EOF    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on PLSQL file with default version     */    @Test    public void testPlsql() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File plsqlFile = new File("/path/to/MY_PACKAGE.sql");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(plsqlFile);        assertEquals("LanguageVersion must be PLSQL!",                LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { PLSQLLanguageModule.NAME, PLSQLLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test plsql's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForceCastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForceTryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnavailableFunctionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProhibitedInterfaceBuilderTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class SwiftTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "BTree.swift";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new SwiftTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(SwiftTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 4239;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class ObjectiveCTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "AFHTTPRequestOperation.m";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new ObjectiveCTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(ObjectiveCTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 884;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;//Tests if the ObjectiveC tokenizer supports identifiers with unicode characterspublic class UnicodeObjectiveCTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "NCClient.m";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new ObjectiveCTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(ObjectiveCTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 10;        super.tokenizeTest();    }        @Test    public void testIgnoreBetweenSpecialComments() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(            "// CPD-OFF" + PMD.EOL            + "static SecCertificateRef gNСServerLogonCertificate;" + PMD.EOL            + "// CPD-ON" + PMD.EOL            + "@end" + PMD.EOL        ));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(2, tokens.size()); // 2 tokens: "@end" + EOF    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;//Tests if the ObjectiveC tokenizer supports UTF-8 escapes in string literalspublic class UTF8EscapesInStringLiteralObjCTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "FileWithUTF8EscapeInStringLiteral.m";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new ObjectiveCTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(ObjectiveCTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 45;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidTrailingCommaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InnaccurateNumericLiteralTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EqualComparisonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryParenthesesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoElseReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnreachableCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ScopeForInVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsistentReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GlobalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidWithStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseBaseWithParseIntTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import org.mozilla.javascript.ast.AstRoot;/** * See the following bugs: #1141 ECMAScript: getFinallyBlock() is buggy. #1142 * ECMAScript: getCatchClause() is buggy */public class ASTTryStatementTest extends EcmascriptParserTestBase {    private ASTTryStatement getTryStmt(String js) {        EcmascriptNode<AstRoot> node = parse(js);        List<ASTTryStatement> trys = node.findDescendantsOfType(ASTTryStatement.class);        Assert.assertEquals(1, trys.size());        ASTTryStatement tryStmt = trys.get(0);        return tryStmt;    }    @Test    public void testFinallyBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } finally { } }");        Assert.assertNull(tryStmt.getCatchClause(0));        Assert.assertFalse(tryStmt.hasCatch());        Assert.assertEquals(0, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }    @Test    public void testCatchBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(1, tryStmt.getNumCatchClause());        Assert.assertNull(tryStmt.getFinallyBlock());        Assert.assertFalse(tryStmt.hasFinally());    }    @Test    public void testCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } finally { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(1, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }    @Test    public void testMultipleCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt(                "function() { " + "try { } " + "catch (error if error instanceof BadError) { } "                        + "catch (error2 if error2 instanceof OtherError) { } " + "finally { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertNotNull(tryStmt.getCatchClause(1));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(2, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.Reader;import java.io.StringReader;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.Test;import org.mozilla.javascript.ast.AstRoot;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ecmascript.Ecmascript3Parser;import net.sourceforge.pmd.lang.ecmascript.EcmascriptParserOptions;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;public class EcmascriptParserTest extends EcmascriptParserTestBase {    /**     * https://sourceforge.net/p/pmd/bugs/1043/     */    @Test    public void testLineNumbers() {        final String SOURCE_CODE = "function a() {" + PMD.EOL + "  alert('hello');" + PMD.EOL + "}" + PMD.EOL;        EcmascriptNode<AstRoot> node = parse(SOURCE_CODE);        assertEquals(1, node.getBeginLine());        assertEquals(1, node.getBeginColumn());        assertEquals(3, node.getEndLine());        assertEquals(1, node.getEndColumn());        Node child = node.getFirstChildOfType(ASTFunctionNode.class);        assertEquals(1, child.getBeginLine());        assertEquals(1, child.getBeginColumn());        assertEquals(3, child.getEndLine());        assertEquals(1, child.getEndColumn());        child = node.getFirstDescendantOfType(ASTFunctionCall.class);        assertEquals(2, child.getBeginLine());        assertEquals(3, child.getBeginColumn());        assertEquals(2, child.getEndLine());        assertEquals(16, child.getEndColumn());    }    /**     * https://sourceforge.net/p/pmd/bugs/1149/     */    @Test    public void testLineNumbersWithinEcmascriptRules() {        String source = "function f(x){\n" + "   if (x) {\n" + "       return 1;\n" + "   } else {\n"                + "       return 0;\n" + "   }\n" + "}";        final List<String> output = new ArrayList<>();        class MyEcmascriptRule extends AbstractEcmascriptRule {            public Object visit(ASTScope node, Object data) {                output.add("Scope from " + node.getBeginLine() + " to " + node.getEndLine());                return super.visit(node, data);            }        }        MyEcmascriptRule rule = new MyEcmascriptRule();        RuleContext ctx = new RuleContext();        rule.apply(Arrays.asList(parse(source)), ctx);        assertEquals("Scope from 2 to 4", output.get(0));        assertEquals("Scope from 4 to 6", output.get(1));    }    /**     * Test bug https://sourceforge.net/p/pmd/bugs/1118/     */    @Test    public void testArrayAccess() {        EcmascriptNode<AstRoot> node = parse("function a() { b['a'] = 1; c[1] = 2; }");        List<ASTElementGet> arrays = node.findDescendantsOfType(ASTElementGet.class);        assertEquals("b", arrays.get(0).getTarget().getImage());        assertEquals("a", arrays.get(0).getElement().getImage());        assertEquals("c", arrays.get(1).getTarget().getImage());        assertEquals("1", arrays.get(1).getElement().getImage());    }    /**     * Test for bug #1136 ECAMScript: NullPointerException in getLeft() and     * getRight()     */    @Test    public void testArrayMethod() {        EcmascriptNode<AstRoot> rootNode = parse(                "function test(){\n" + "  a();      // OK\n" + "  b.c();    // OK\n" + "  d[0]();   // OK\n"                        + "  e[0].f(); // OK\n" + "  y.z[0](); // FAIL ==> java.lang.NullPointerException\n" + "}");        List<ASTFunctionCall> calls = rootNode.findDescendantsOfType(ASTFunctionCall.class);        List<String> results = new ArrayList<>();        for (ASTFunctionCall f : calls) {            Node node = f.getTarget();            results.add(getName(node));        }        assertEquals("[a, b.c, d[], e[].f, y.z[]]", results.toString());    }    private String getName(Node node) {        if (node instanceof ASTName) {            return ((ASTName) node).getIdentifier();        }        if (node instanceof ASTPropertyGet) {            final ASTPropertyGet pgNode = (ASTPropertyGet) node;            final String leftName = getName(pgNode.getLeft());            final String rightName = getName(pgNode.getRight());            return leftName + "." + rightName;        }        if (node instanceof ASTElementGet) {            return getName(((ASTElementGet) node).getTarget()) + "[]";        }        return "????";    }    /**     * https://sourceforge.net/p/pmd/bugs/1150/ #1150 "EmptyExpression" for     * valid statements!     */    @Test    public void testCaseAsIdentifier() {        ASTAstRoot rootNode = parse("function f(a){\n" + "    a.case.flag = 1;\n" + "    return;\n" + "}");        ASTBlock block = rootNode.getFirstDescendantOfType(ASTBlock.class);        assertFalse(block.jjtGetChild(0) instanceof ASTEmptyExpression);        assertTrue(block.jjtGetChild(0) instanceof ASTExpressionStatement);        assertTrue(block.jjtGetChild(0).jjtGetChild(0) instanceof ASTAssignment);    }    /**     * https://sourceforge.net/p/pmd/bugs/1045/ #1045 //NOPMD not working (or     * not implemented) with ECMAscript     */    @Test    public void testSuppressionComment() {        Ecmascript3Parser parser = new Ecmascript3Parser(new EcmascriptParserOptions());        Reader sourceCode = new StringReader("function(x) {\n" + "x = x; //NOPMD I know what I'm doing\n" + "}\n");        ASTAstRoot root = parser.parse("foo", sourceCode);        assertEquals(" I know what I'm doing", root.getNoPmdComments().get(2));        assertEquals(1, root.getNoPmdComments().size());        EcmascriptParserOptions parserOptions = new EcmascriptParserOptions();        parserOptions.setSuppressMarker("FOOOO");        parser = new Ecmascript3Parser(parserOptions);        sourceCode = new StringReader(                "function(x) {\n" + "y = y; //NOPMD xyz\n" + "x = x; //FOOOO I know what I'm doing\n" + "}\n");        root = parser.parse("foo", sourceCode);        assertEquals(" I know what I'm doing", root.getNoPmdComments().get(3));        assertEquals(1, root.getNoPmdComments().size());    }    /**     * #1191 Ecmascript fails to parse "void(0)"     */    @Test    public void testVoidKeyword() {        ASTAstRoot rootNode = parse("function f(matchFn, fieldval, n){\n"                + "    return (matchFn)?(matcharray = eval(matchFn+\"('\"+fieldval+\"','\"+n.id+\"')\")):void(0);\n"                + "}\n");        ASTUnaryExpression unary = rootNode.getFirstDescendantOfType(ASTUnaryExpression.class);        assertEquals("void", unary.getImage());    }    /**     * #1192 Ecmascript fails to parse this operator " ^= "     */    @Test    public void testXorAssignment() {        ASTAstRoot rootNode = parse("function f() { var x = 2; x ^= 2; x &= 2; x |= 2; "                + "x &&= true; x ||= false; x *= 2; x /= 2; x %= 2; x += 2; x -= 2; "                + "x <<= 2; x >>= 2; x >>>= 2; }");        ASTAssignment infix = rootNode.getFirstDescendantOfType(ASTAssignment.class);        assertEquals("^=", infix.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTFunctionNodeTest extends EcmascriptParserTestBase {    @Test    public void testGetBody() {        ASTAstRoot node = parse("function foo() { var a = 'a'; }");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        Assert.assertFalse(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        Assert.assertTrue(body instanceof ASTBlock);    }    @Test    public void testGetBodyFunctionClosureExpression() {        ASTAstRoot node = parse18("(function(x) x*x)");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        Assert.assertTrue(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        Assert.assertTrue(body instanceof ASTBlock);        Assert.assertTrue(body.jjtGetChild(0) instanceof ASTReturnStatement);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript;import static net.sourceforge.pmd.lang.ParserOptionsTest.verifyOptionsEqualsHashcode;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ecmascript.EcmascriptParserOptions.Version;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;import net.sourceforge.pmd.properties.BooleanProperty;public class EcmascriptParserOptionsTest {    @Test    public void testDefaults() throws Exception {        EcmascriptParserOptions parserOptions = new EcmascriptParserOptions();        assertTrue(parserOptions.isRecordingComments());        assertTrue(parserOptions.isRecordingLocalJsDocComments());        assertEquals(EcmascriptParserOptions.Version.VERSION_DEFAULT, parserOptions.getRhinoLanguageVersion());        MyRule rule = new MyRule();        parserOptions = (EcmascriptParserOptions) rule.getParserOptions();        assertTrue(parserOptions.isRecordingComments());        assertTrue(parserOptions.isRecordingLocalJsDocComments());        assertEquals(EcmascriptParserOptions.Version.VERSION_DEFAULT, parserOptions.getRhinoLanguageVersion());    }    @Test    public void testConstructor() throws Exception {        MyRule rule = new MyRule();        rule.setProperty(EcmascriptParserOptions.RECORDING_COMMENTS_DESCRIPTOR, true);        assertTrue(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingComments());        rule.setProperty(EcmascriptParserOptions.RECORDING_COMMENTS_DESCRIPTOR, false);        assertFalse(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingComments());        rule.setProperty(EcmascriptParserOptions.RECORDING_LOCAL_JSDOC_COMMENTS_DESCRIPTOR, true);        assertTrue(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingLocalJsDocComments());        rule.setProperty(EcmascriptParserOptions.RECORDING_LOCAL_JSDOC_COMMENTS_DESCRIPTOR, false);        assertFalse(((EcmascriptParserOptions) rule.getParserOptions()).isRecordingLocalJsDocComments());        rule.setProperty(EcmascriptParserOptions.RHINO_LANGUAGE_VERSION, Version.VERSION_DEFAULT);        assertEquals(EcmascriptParserOptions.Version.VERSION_DEFAULT,                ((EcmascriptParserOptions) rule.getParserOptions()).getRhinoLanguageVersion());        rule.setProperty(EcmascriptParserOptions.RHINO_LANGUAGE_VERSION, Version.VERSION_1_8);        assertEquals(EcmascriptParserOptions.Version.VERSION_1_8,                ((EcmascriptParserOptions) rule.getParserOptions()).getRhinoLanguageVersion());    }    @Test    public void testSetters() {        EcmascriptParserOptions options = new EcmascriptParserOptions();        options.setSuppressMarker("foo");        assertEquals("foo", options.getSuppressMarker());        options.setSuppressMarker(null);        assertNull(options.getSuppressMarker());    }    @Test    public void testEqualsHashcode() throws Exception {        BooleanProperty[] properties = {EcmascriptParserOptions.RECORDING_COMMENTS_DESCRIPTOR,                                        EcmascriptParserOptions.RECORDING_LOCAL_JSDOC_COMMENTS_DESCRIPTOR, };        for (int i = 0; i < properties.length; i++) {            BooleanProperty property = properties[i];            MyRule rule = new MyRule();            rule.setProperty(property, true);            ParserOptions options1 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options2 = rule.getParserOptions();            rule.setProperty(property, true);            ParserOptions options3 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options4 = rule.getParserOptions();            verifyOptionsEqualsHashcode(options1, options2, options3, options4);        }        EcmascriptParserOptions options1 = new EcmascriptParserOptions();        options1.setSuppressMarker("foo");        EcmascriptParserOptions options2 = new EcmascriptParserOptions();        options2.setSuppressMarker("bar");        EcmascriptParserOptions options3 = new EcmascriptParserOptions();        options3.setSuppressMarker("foo");        EcmascriptParserOptions options4 = new EcmascriptParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);        options1 = new EcmascriptParserOptions();        options1.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_DEFAULT);        options2 = new EcmascriptParserOptions();        options2.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_1_8);        options3 = new EcmascriptParserOptions();        options3.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_DEFAULT);        options4 = new EcmascriptParserOptions();        options4.setRhinoLanguageVersion(EcmascriptParserOptions.Version.VERSION_1_8);        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    private static final class MyRule extends AbstractEcmascriptRule {    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(EcmascriptParserOptionsTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    @Test    public void shouldFindDuplicatesWithDifferentFileExtensions() {        runCPD("--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File1.ts",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File2.ts");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 9 line (30 tokens) duplication in the following files"));    }    @Test    public void shouldFindNoDuplicatesWithDifferentFileExtensions() {        runCPD("--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/");        String out = getOutput();        Assert.assertTrue(out.trim().isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.io.IOException;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;public class EcmascriptTokenizerTest {    @Test    public void test1() throws IOException {        Tokenizer tokenizer = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getCode1()));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(40, tokens.size());    }    @Test    public void test2() throws IOException {        Tokenizer t = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getCode2()));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(45, tokens.size());    }        @Test    public void testIgnoreBetweenSpecialComments() throws IOException {        final String code = "// CPD-OFF" + PMD.EOL            + "function switchToRealPassword() {" + PMD.EOL            + "var real = $('realPass');" + PMD.EOL            + " var prompt = $('promptPass');" + PMD.EOL            + "// CPD-ON" + PMD.EOL            + "}" + PMD.EOL;                Tokenizer t = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(code));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(2, tokens.size()); // Only "}" and EOL    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1239/     *      * @throws IOException     *             IO Exception     */    @Test    public void parseStringNotAsMultiline() throws IOException {        Tokenizer t = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "var s = \"a string \\\n" + "continues\";\n" + "var s = \"a string \\\n" + "continues2\";\n"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(11, tokens.size());        List<TokenEntry> list = tokens.getTokens();        assertEquals("var", list.get(0).getIdentifier(), list.get(5).getIdentifier());        assertEquals("s", list.get(1).getIdentifier(), list.get(6).getIdentifier());        assertEquals("=", list.get(2).getIdentifier(), list.get(7).getIdentifier());        assertEquals("\"a string continues\"", list.get(3).toString());        assertEquals("\"a string continues2\"", list.get(8).toString());        assertFalse(list.get(3).getIdentifier() == list.get(8).getIdentifier());    }    @Test    public void testIgnoreSingleLineComments() throws IOException {        Tokenizer t = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "//This is a single line comment\n" + "var i = 0;\n\n" + "//This is another comment\n" + "i++;"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(9, tokens.size());        List<TokenEntry> list = tokens.getTokens();        assertEquals("var", list.get(0).toString());        assertEquals("++", list.get(6).toString());    }    @Test    public void testIgnoreMultiLineComments() throws IOException {        Tokenizer t = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("/* This is a multi line comment\n"                + " *                             \n" + " */                            \n" + "var i = 0;\n\n"                + "/* This is another multi line comment\n" + " * second line                       \n"                + " * third line                      */\n" + "i++;"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(9, tokens.size());        List<TokenEntry> list = tokens.getTokens();        assertEquals("var", list.get(0).toString());        assertEquals("++", list.get(6).toString());    }    // no semi-colons    private String getCode1() {        StringBuilder sb = new StringBuilder();        sb.append("function switchToRealPassword() {").append(PMD.EOL);        sb.append("   var real = $('realPass')").append(PMD.EOL);        sb.append("   var prompt = $('promptPass')").append(PMD.EOL);        sb.append("   real.style.display = 'inline'").append(PMD.EOL);        sb.append("   prompt.style.display = 'none'").append(PMD.EOL);        sb.append("   real.focus()").append(PMD.EOL);        sb.append("}").append(PMD.EOL);        return sb.toString();    }    // same as getCode1, but lines are ended with semi-colons    private String getCode2() {        StringBuilder sb = new StringBuilder();        sb.append("function switchToRealPassword() {").append(PMD.EOL);        sb.append("   var real = $('realPass');").append(PMD.EOL);        sb.append("   var prompt = $('promptPass');").append(PMD.EOL);        sb.append("   real.style.display = 'inline';").append(PMD.EOL);        sb.append("   prompt.style.display = 'none';").append(PMD.EOL);        sb.append("   real.focus();").append(PMD.EOL);        sb.append("}").append(PMD.EOL);        return sb.toString();    }    @Test    public void testTemplateStrings() throws IOException {        Tokenizer t = new EcmascriptTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                  "export default class DrawLocation extends joint.shapes.basic.Generic {" + PMD.EOL                + "  constructor(location: ILocation) {" + PMD.EOL                + "    this.markup = `<g>" + PMD.EOL                + "        <path class=\"location\"/>" + PMD.EOL                + "        <text x=\"0\" y=\"0\" text-anchor=\"middle\" class=\"location-text\"></text>" + PMD.EOL                + PMD.EOL                + "        <path class=\"location\"/>" + PMD.EOL                + "        <circle class=\"location-circle\"/>" + PMD.EOL                + "        ${drawIndicators.Check.markup}" + PMD.EOL                + PMD.EOL                + "      </g>`;" + PMD.EOL                + "  }" + PMD.EOL                + "" + PMD.EOL                + "}"));        final Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        final String templateString = "`<g>" + PMD.EOL                + "        <path class=\"location\"/>" + PMD.EOL                + "        <text x=\"0\" y=\"0\" text-anchor=\"middle\" class=\"location-text\"></text>" + PMD.EOL                + PMD.EOL                + "        <path class=\"location\"/>" + PMD.EOL                + "        <circle class=\"location-circle\"/>" + PMD.EOL                + "        ${drawIndicators.Check.markup}" + PMD.EOL                + PMD.EOL                + "      </g>`";        assertEquals(templateString, tokens.getTokens().get(24).toString());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testEcmascript() {        executeTarget("testEcmascript");        assertOutputContaining("A 'return', 'break', 'continue', or 'throw' statement should be the last in a block.");        assertOutputContaining("Avoid using global variables");        assertOutputContaining("Use ===/!== to compare with true/false or Numbers");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.util.FileUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; *  */public class CLITest extends BaseCLITest {    @Test    public void useEcmaScript() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "xml", "-R", "ecmascript-basic", "-version", "3", "-l",            "ecmascript", "-debug", };        String resultFilename = runTest(args, "useEcmaScript");        assertTrue("Invalid JavaScript version",                FileUtil.findPatternInFile(new File(resultFilename), "Using Ecmascript version: Ecmascript 3"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ecmascript.EcmascriptLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { EcmascriptLanguageModule.NAME, EcmascriptLanguageModule.TERSE_NAME, "3",            LanguageRegistry.getLanguage(EcmascriptLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ecmascript.EcmascriptLanguageModule;import net.sourceforge.pmd.lang.ecmascript.ast.ASTFunctionNode;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;import net.sourceforge.pmd.testframework.RuleTst;public class ReportTest extends RuleTst {    @Test    public void testExclusionsInReportWithNOPMDEcmascript() throws Exception {        Report rpt = new Report();        Rule rule = new AbstractEcmascriptRule() {            @Override            public Object visit(ASTFunctionNode node, Object data) {                EcmascriptLanguageModule.defaultHandler().getRuleViolationFactory().addViolation((RuleContext) data, this, node, "Test", null);                return super.visit(node, data);            }        };        String code = "function(x) // NOPMD test suppress\n" + "{ x = 1; }";        runTestFromString(code, rule, rpt,                LanguageRegistry.getLanguage(EcmascriptLanguageModule.NAME).getDefaultVersion());        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test javascript's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfUnescapeElTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfCsrfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.HashSet;import java.util.Set;import net.sourceforge.pmd.lang.ast.JavaCharStream;import net.sourceforge.pmd.lang.ast.Node;public abstract class AbstractVfNodesTest {    public <T extends VfNode> void assertNumberOfNodes(Class<T> clazz, String source, int number) {        Set<T> nodes = getNodes(clazz, source);        assertEquals("Exactly " + number + " element(s) expected", number, nodes.size());    }    /**     * Run the VF parser on the source, and return the nodes of type clazz.     *     * @param clazz     * @param source     * @return Set     */    public <T extends VfNode> Set<T> getNodes(Class<T> clazz, String source) {        VfParser parser = new VfParser(new JavaCharStream(new StringReader(source)));        Node rootNode = parser.CompilationUnit();        Set<T> nodes = new HashSet<>();        addNodeAndSubnodes(rootNode, nodes, clazz);        return nodes;    }    /**     * Return a subset of allNodes, containing the items in allNodes that are of     * the given type.     *     * @param clazz     * @param allNodes     * @return Set     */    @SuppressWarnings("unchecked")    public <T extends VfNode> Set<T> getNodesOfType(Class<T> clazz, Set<VfNode> allNodes) {        Set<T> result = new HashSet<>();        for (Node node : allNodes) {            if (clazz.equals(node.getClass())) {                result.add((T) node);            }        }        return result;    }    /**     * Add the given node and its subnodes to the set of nodes. If clazz is not     * null, only nodes of the given class are put in the set of nodes.     */    @SuppressWarnings("unchecked")    private <T extends VfNode> void addNodeAndSubnodes(Node node, Set<T> nodes, Class<T> clazz) {        if (null != node) {            if ((null == clazz) || (clazz.equals(node.getClass()))) {                nodes.add((T) node);            }            for (int i = 0; i < node.jjtGetNumChildren(); i++) {                addNodeAndSubnodes(node.jjtGetChild(i), nodes, clazz);            }        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import java.util.Set;import org.junit.Test;public class VfPageStyleTest extends AbstractVfNodesTest {    /**     * Test parsing of a EL expression.     */    @Test    public void testElExpression() {        Set<ASTElExpression> expressions = getNodes(ASTElExpression.class, VF_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "myBean", id.getImage());        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "get", dotid.getImage());         ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("Correct expression content expected!", "\"{! World }\"", literal.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testElExpressionInAttribute() {        Set<ASTElExpression> expressions = getNodes(ASTElExpression.class, VF_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "myValidator", id.getImage());        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "find", dotid.getImage());        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("Correct expression content expected!", "\"'vf'\"", literal.getImage());    }    private static final String VF_EL_EXPRESSION = "<html><title>Hello {!myBean.get(\"{! World }\") } .vf</title></html>";    private static final String VF_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').{!myValidator.find(\"'vf'\")}\" /> </html>";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VfPageStyleTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import java.util.Set;import org.junit.Test;/** * Test parsing of a VF in document style, by checking the generated AST. * Original @author pieter_van_raemdonck - Application Engineers NV/SA - * www.ae.be *  * @author sergey.gorbaty - VF adaptation * */public class VfDocStyleTest extends AbstractVfNodesTest {    /**     * Smoke test for VF parser.     */    @Test    public void testSimplestVf() {        assertNumberOfNodes(ASTElement.class, TEST_SIMPLEST_HTML, 1);    }    /**     * Test the information on a Element and Attribute.     */    @Test    public void testElementAttributeAndNamespace() {        Set<VfNode> nodes = getNodes(null, TEST_ELEMENT_AND_NAMESPACE);        Set<ASTElement> elementNodes = getNodesOfType(ASTElement.class, nodes);        assertEquals("One element node expected!", 1, elementNodes.size());        ASTElement element = elementNodes.iterator().next();        assertEquals("Correct name expected!", "h:html", element.getName());        assertEquals("Has namespace prefix!", true, element.isHasNamespacePrefix());        assertEquals("Element is empty!", true, element.isEmpty());        assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "html", element.getLocalName());        Set<ASTAttribute> attributeNodes = getNodesOfType(ASTAttribute.class, nodes);        assertEquals("One attribute node expected!", 1, attributeNodes.size());        ASTAttribute attribute = attributeNodes.iterator().next();        assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());        assertEquals("Has namespace prefix!", true, attribute.isHasNamespacePrefix());        assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix", attribute.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    public void testAttributeValueContainingHash() {        Set<VfNode> nodes = getNodes(null, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        Set<ASTAttribute> attributes = getNodesOfType(ASTAttribute.class, nodes);        assertEquals("Three attributes expected!", 3, attributes.size());        List<ASTAttribute> attrsList = new ArrayList<>(attributes);        Collections.sort(attrsList, new Comparator<ASTAttribute>() {            public int compare(ASTAttribute arg0, ASTAttribute arg1) {                return arg0.getName().compareTo(arg1.getName());            }        });        ASTAttribute attr = attrsList.get(0);        assertEquals("Correct attribute name expected!", "foo", attr.getName());        assertEquals("Correct attribute value expected!", "CREATE",                attr.getFirstDescendantOfType(ASTText.class).getImage());        attr = attrsList.get(1);        assertEquals("Correct attribute name expected!", "href", attr.getName());        assertEquals("Correct attribute value expected!", "#", attr.getFirstDescendantOfType(ASTText.class).getImage());        attr = attrsList.get(2);        assertEquals("Correct attribute name expected!", "something", attr.getName());        assertEquals("Correct attribute value expected!", "#yes#",                attr.getFirstDescendantOfType(ASTText.class).getImage());    }    /**     * Test correct parsing of CDATA.     */    @Test    public void testCData() {        Set<ASTCData> cdataNodes = getNodes(ASTCData.class, TEST_CDATA);        assertEquals("One CDATA node expected!", 1, cdataNodes.size());        ASTCData cdata = cdataNodes.iterator().next();        assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());    }    /**     * Test parsing of Doctype declaration.     */    @Test    public void testDoctype() {        Set<VfNode> nodes = getNodes(null, TEST_DOCTYPE);        Set<ASTDoctypeDeclaration> docTypeDeclarations = getNodesOfType(ASTDoctypeDeclaration.class, nodes);        assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());        Set<ASTDoctypeExternalId> externalIds = getNodesOfType(ASTDoctypeExternalId.class, nodes);        assertEquals("One doctype external id expected!", 1, externalIds.size());        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());        assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",                externalId.getUri());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScript() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "Script!", text.getImage());    }    /**     * Test parsing of EL in attribute of an element.     */    @Test    public void testELInTagValue() {        Set<ASTElement> elememts = getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE);        assertEquals("One element expected!", 1, elememts.size());        ASTElement element = elememts.iterator().next();        ASTAttributeValue attribute = element.getFirstDescendantOfType(ASTAttributeValue.class);        ASTIdentifier id = attribute.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "foo", id.getImage());    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    public void testELInTagValueWithCommentDQ() {        Set<ASTElement> elememts = getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT);        assertEquals("One element expected!", 1, elememts.size());        ASTElement element = elememts.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "init", id.getImage());    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    public void testELInTagValueWithCommentSQ() {        Set<ASTElement> elememts = getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ);        assertEquals("One element expected!", 1, elememts.size());        ASTElement element = elememts.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "init", id.getImage());    }    /**     * Test parsing of EL in HTML &lt;script&gt; element.     */    @Test    public void testELInHtmlScript() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext=", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of inline comment in EL.     */    @Test    public void testInlineCommentInEL() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext=", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of quoted EL in HTML &lt;script&gt; element.     */    @Test    public void testQuotedELInHtmlScript() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_QUOTED_EL_IN_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext='textHere", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be     * valid html but it is likely to appear in .page files.     */    @Test    public void testImportHtmlScript() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttribute> attr = script.findDescendantsOfType(ASTAttribute.class);        assertEquals("One script expected!", 1, attr.size());        ASTAttribute att = attr.iterator().next();        ASTAttributeValue val = att.getFirstChildOfType(ASTAttributeValue.class);        ASTText text = val.getFirstChildOfType(ASTText.class);        assertEquals("filename.js", text.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScriptWithAttribute() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "Script!", text.getImage());        List<ASTText> attrs = script.findDescendantsOfType(ASTText.class);        assertTrue("text/javascript".equals(attrs.get(0).getImage()));    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    public void testComplexHtmlScript() {        Set<ASTHtmlScript> script = getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals("One script expected!", 1, script.size());        ASTHtmlScript next = script.iterator().next();        ASTText text = next.getFirstChildOfType(ASTText.class);        assertTrue(text.getImage().contains("<!--"));    }    /**     * Test parsing of HTML &lt;style&gt; element.     */    @Test    public void testInlineCss() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals("Two elements expected!", 3, elements.size());    }    /**     * Test parsing of HTML text within element.     */    @Test    public void testTextInTag() {        Set<ASTText> scripts = getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals("One text chunk expected!", 1, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    public void noSpacesBetweenTags() {        Set<ASTElement> scripts = getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals("Two tags expected!", 2, scripts.size());        List<ASTElement> elmts = sortNodesByName(scripts);        Iterator<ASTElement> iterator = elmts.iterator();        ASTElement script = iterator.next();        assertEquals("Correct content expected!", "a", script.getName());        script = iterator.next();        assertEquals("Correct content expected!", "b", script.getName());    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    public void unclosedTagsWithDollar() {        Set<ASTText> scripts = getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " $ ", script.getImage());    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    public void unclosedTagsWithELWithin() {        Set<ASTElement> element = getNodes(ASTElement.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals("One element expected!", 1, element.size());        for (ASTElement elem : element) {            ASTContent content = elem.getFirstChildOfType(ASTContent.class);            List<ASTElExpression> els = content.findChildrenOfType(ASTElExpression.class);            assertEquals("Two EL expressions expected!", 2, els.size());            ASTElExpression node = (ASTElExpression) content.jjtGetChild(0);            ASTIdentifier id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("Correct content expected!", "expr1", id.getImage());            node = (ASTElExpression) content.jjtGetChild(1);            id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("Correct content expected!", "expr2", id.getImage());        }    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void textAfterOpenAndClosedTag() {        Set<ASTElement> nodes = getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two elements expected!", 2, nodes.size());        List<ASTElement> elmts = sortNodesByName(nodes);        assertEquals("First element should be a", "a", elmts.get(0).getName());        assertFalse("first element should be closed", elmts.get(0).isUnclosed());        assertEquals("Second element should be b", "b", elmts.get(1).getName());        assertTrue("Second element should not be closed", elmts.get(1).isUnclosed());        Set<ASTText> text = getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two text chunks expected!", 2, text.size());    }    @Test    public void quoteEL() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        List<ASTElExpression> els = attr.findChildrenOfType(ASTElExpression.class);        assertEquals("Must be 1!", 1, els.size());        ASTExpression expr = els.get(0).getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = expr.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Expected to detect proper value for attribute!", "something", id.getImage());    }    /**     * smoke test for a non-quoted attribute value     */    @Test    public void quoteAttrValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("Expected to detect proper value for attribute!", "yes|", text.getImage());    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    public void noQuoteAttrEmpty() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_EMPTY_ATTR);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", null, attr.getImage());    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    public void singleQuoteAttrTab() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_TAB_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("Expected to detect proper value for attribute!", "\t", text.getImage());    }    @Test    public void unclosedTag() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be sorted tag:if", "tag:if", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());    }    @Test    public void unclosedTagAndNoQuotesForAttribute() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_ATTR);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be sorted tag:if", "tag:if", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());    }    @Test    public void unclosedTagMultipleLevels() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("3 tags expected", 3, elements.size());        assertEquals("First element should be sorted tag:someTag", "tag:someTag", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertEquals("Third element should be tag:x", "tag:x", sortedElmnts.get(2).getName());        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        assertFalse(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    public void nestedEmptyTags() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Third element should be html", "html", sortedElmnts.get(3).getName());        // a1        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2        assertTrue(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());        // html        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt;     * &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    public void nestedMultipleTags() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 6, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be a3", "a3", sortedElmnts.get(2).getName());        assertEquals("Forth element should be a4", "a4", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be b", "b", sortedElmnts.get(4).getName());        assertEquals("Sixth element should be html", "html", sortedElmnts.get(5).getName());        // a1 not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2 not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // a3 empty and not closed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // a4 empty but closed        assertTrue(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());        // b empty but closed        assertTrue(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());        // html not empty and closed        assertFalse(sortedElmnts.get(5).isEmpty());        assertFalse(sortedElmnts.get(5).isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt;     * &lt;/x&gt; . Here x is the first tag to be closed thus rendering the next     * close of a (&lt;/a&gt;) to be disregarded.     */    @Test    public void unclosedParentTagClosedBeforeChild() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This should     * be disregarded and structure of children and parents should not be     * influenced. in other words &lt;/a&gt; should close the first &lt;a&gt;     * tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    public void unmatchedTagDoesNotInfluenceStructure() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a is not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt; An unmatched closing of 'z' appears randomly in the document.     * This should be disregarded and structure of children and parents should     * not be influenced. Also un unclosed &lt;a&gt; tag appears at the start of     * the document     */    @Test    public void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("5 tags expected", 5, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be a", "a", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be b", "b", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be x", "x", sortedElmnts.get(4).getName());        // first a is empty and unclosed        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // second a not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(3).isEmpty());        assertTrue(sortedElmnts.get(3).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());    }    /**     * will sort the AST element in list in alphabetical order and if tag name     * is the same it will sort against o1.getBeginColumn() +""+     * o1.getBeginLine(). so first criteria is the name, then the second is the     * column +""+line string.     *      * @param elements     * @return     */    private List<ASTElement> sortNodesByName(Set<ASTElement> elements) {        List<ASTElement> list = new ArrayList<>();        list.addAll(elements);        Collections.sort(list, new Comparator<ASTElement>() {            public int compare(ASTElement o1, ASTElement o2) {                if (o1.getName() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getName() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getName().equals(o2.getName())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getName().compareTo(o2.getName());            }        });        return list;    }    @Test    public void noQuoteAttrWithJspEL() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTIdentifier id = attr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Expected to detect proper value for EL in attribute!", "something", id.getImage());    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE = "<apex:page action=\"{!foo}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT = "<apex:page action=\"{!/*comment here*/init}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ = "<apex:page action='{!/*comment here*/init}'>text</apex:page>";    private static final String TEST_EL_IN_HTML_SCRIPT = "<html><head><script>var text={!elInScript};</script></head></html>";    private static final String TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT = "<html><head><script>var text={!/*junk1*/elInScript/*junk2*/};</script></head></html>";    private static final String TEST_QUOTED_EL_IN_HTML_SCRIPT = "<html><head><script>var text='textHere{!elInScript}';</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" /></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>{!expr1}{!expr2}</a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"{!something}\" > </tag:if>";    private static final String TEST_ATTR = "<tag:if something=\"yes|\" > </tag:if>";    private static final String TEST_EMPTY_ATTR = "<tag:if something= >  <a href=\"http://someHost:/some_URL\" >foo</a> </tag:if>";    private static final String TEST_TAB_ATTR = "<tag:if something='\t' >   </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if someting=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag someting=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_ATTR = "<tag:someTag> <tag:if someting='x' > </tag:someTag>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<apex:someTag something={!something} > foo </apex:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @Before    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *      */    @Test    public void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt;     */    @Test    public void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import java.io.StringReader;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;/** * @author sergey.gorbaty * */public class VfParserTest {    @Test    public void testSingleDoubleQuoteAndEL() {        Node node = parse("<span escape='false' attrib=\"{!call}\">${!'yes'}</span>");        Assert.assertNotNull(node);    }    @Test    public void testSingleDoubleQuoteAndELFunction() {        Node node = parse("<span escape='false' attrib=\"{!call}\">${!method}</span>");        Assert.assertNotNull(node);    }        @Test    public void testSingleDoubleQuote() {        Node node = parse("<span escape='false' attrib=\"{!call}\">${\"yes\"}</span>");        Assert.assertNotNull(node);    }    private Node parse(String code) {        LanguageVersionHandler vfLang = LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler();        Parser parser = vfLang.getParser(vfLang.getDefaultParserOptions());        Node node = parser.parse(null, new StringReader(code));        return node;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.vf.VfLanguageModule;/** * @author sergey.gorbaty * */public class LanguageVersionDiscovererTest {    /**     * Test on VF file.     */    @Test    public void testVFFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File vfFile = new File("/path/to/MyPage.page");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals("LanguageVersion must be VF!",                LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), languageVersion);    }    @Test    public void testComponentFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File vfFile = new File("/path/to/MyPage.component");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals("LanguageVersion must be VF!",                LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vf.VfLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VfLanguageModule.NAME, VfLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.Collection;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;@RunWith(Parameterized.class)public class DartTokenizerTest extends AbstractTokenizerTest {    private final String filename;    private final int nExpectedTokens;    public DartTokenizerTest(String filename, int nExpectedTokens) {        this.filename = filename;        this.nExpectedTokens = nExpectedTokens;    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(                new Object[] { "comment.dart", 5 },                new Object[] { "escape_sequences.dart", 13 },                new Object[] { "escaped_backslash.dart", 14 },                new Object[] { "escaped_string.dart", 17 },                new Object[] { "increment.dart", 185 },                new Object[] { "imports.dart", 1 },                new Object[] { "regex.dart", 13 },                new Object[] { "regex2.dart", 13 },                new Object[] { "regex3.dart", 13 },                new Object[] { "string_with_backslashes.dart", 9 },                new Object[] { "string_multiline.dart", 13 }        );    }    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new DartTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), this.filename));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(DartTokenizer.class.getResourceAsStream(this.filename), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = nExpectedTokens;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class PythonTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "sample-python.py";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new PythonTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(PythonTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 1218;        super.tokenizeTest();    }    @Test    public void testIgnoreBetweenSpecialComments() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("import logging" + PMD.EOL                + "# CPD-OFF" + PMD.EOL                + "logger = logging.getLogger('django.request')" + PMD.EOL                + "class BaseHandler(object):" + PMD.EOL                + "    def __init__(self):" + PMD.EOL                + "        self._request_middleware = None" + PMD.EOL                + "        # CPD-ON" + PMD.EOL        ));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(3, tokens.size()); // 3 tokens: "import" + "logging" + EOF    }    @Test    public void testBackticks() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("test = 'hello'" + PMD.EOL                + "quoted = `test`" + PMD.EOL                + "print quoted" + PMD.EOL        ));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens); // should not result in parse error        TokenEntry.getEOF();        assertEquals(3, tokens.getTokens().get(tokens.getTokens().size() - 2).getBeginLine());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MistypedCDATASectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.StringReader;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import org.w3c.dom.Attr;import org.w3c.dom.CharacterData;import org.w3c.dom.Comment;import org.w3c.dom.Document;import org.w3c.dom.DocumentType;import org.w3c.dom.Element;import org.w3c.dom.Entity;import org.w3c.dom.EntityReference;import org.w3c.dom.Notation;import org.w3c.dom.ProcessingInstruction;import org.w3c.dom.Text;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractDomXmlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><?mypi?><!DOCTYPE testDoc [<!ENTITY entity \"e\">]><!--Comment--><foo abc=\"abc\"><bar>TEXT</bar><![CDATA[cdata!]]>&gt;&entity;&lt;</foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setExpandEntityReferences(false);        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        MyRule rule = new MyRule();        rule.apply(nodes, null);        List<org.w3c.dom.Node> visited = rule.visitedNodes.get("Attr");        assertEquals(1, visited.size());        assertEquals("abc", visited.get(0).getLocalName());        visited = rule.visitedNodes.get("CharacterData");        assertEquals(1, visited.size());        assertEquals("cdata!", ((CharacterData) visited.get(0)).getData());        visited = rule.visitedNodes.get("Comment");        assertEquals("Comment", ((Comment) visited.get(0)).getData());        visited = rule.visitedNodes.get("Document");        assertEquals(1, visited.size());        visited = rule.visitedNodes.get("DocumentType");        assertEquals("testDoc", ((DocumentType) visited.get(0)).getName());        visited = rule.visitedNodes.get("Element");        assertEquals(2, visited.size());        assertEquals("foo", visited.get(0).getLocalName());        assertEquals("bar", visited.get(1).getLocalName());        // TODO Figure out how to trigger this.        // visited = rule.visitedNodes.get("Entity");        // assertEquals(0, visited.size());        visited = rule.visitedNodes.get("EntityReference");        assertEquals(1, visited.size());        assertEquals("entity", ((EntityReference) visited.get(0)).getNodeName());        // TODO Figure out how to trigger this.        // visited = rule.visitedNodes.get("Notation");        // assertEquals(0, visited.size());        visited = rule.visitedNodes.get("ProcessingInstruction");        assertEquals(1, visited.size());        assertEquals("mypi", ((ProcessingInstruction) visited.get(0)).getTarget());        visited = rule.visitedNodes.get("Text");        assertEquals(3, visited.size());        assertEquals("TEXT", ((Text) visited.get(0)).getData());        assertEquals(">", ((Text) visited.get(1)).getData());        String text = ((Text) visited.get(2)).getData();        if ("<".equals(text)) {            // java13 and later don't expand entities if setExpandEntityReferences==false            assertEquals("<", ((Text) visited.get(2)).getData());        } else {            assertEquals("e<", ((Text) visited.get(2)).getData());        }    }    @Test    public void dtdIsNotLookedUp() {        String source = "<!DOCTYPE struts-config PUBLIC "                + " \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN \" "                + " \"http://jakarta.inexistinghost.org/struts/dtds/struts-config_1_1.dtd\" >" + "<struts-config/>";        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setLookupDescriptorDoc(false);        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        // no exception should be thrown        MyRule rule = new MyRule();        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        rule.apply(nodes, null);        // first element is still parsed        assertNotNull(rule.visitedNodes.get("Element"));    }    @Test    public void xsdIsNotLookedUp() {        String source = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> "                + "<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" "                + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "                + "xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.inexisting.com/xml/ns/javaee/web-app_2_5.xsd\" "                + "version=\"2.5\">" + "</web-app>";        XmlParserOptions parserOptions = new XmlParserOptions();        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        // no exception should be thrown        // first element is still parsed        MyRule rule = new MyRule();        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        rule.apply(nodes, null);        assertNotNull(rule.visitedNodes.get("Element"));    }    private static class MyRule extends AbstractDomXmlRule {        final Map<String, List<org.w3c.dom.Node>> visitedNodes = new HashMap<>();        MyRule() {        }        private void visit(String key, org.w3c.dom.Node node) {            List<org.w3c.dom.Node> nodes = visitedNodes.get(key);            if (nodes == null) {                nodes = new ArrayList<>();                visitedNodes.put(key, nodes);            }            nodes.add(node);        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            super.apply(nodes, ctx);        }        @Override        protected void visit(XmlNode node, Attr attr, RuleContext ctx) {            visit("Attr", attr);            super.visit(node, attr, ctx);        }        @Override        protected void visit(XmlNode node, CharacterData characterData, RuleContext ctx) {            visit("CharacterData", characterData);            super.visit(node, characterData, ctx);        }        @Override        protected void visit(XmlNode node, Comment comment, RuleContext ctx) {            visit("Comment", comment);            super.visit(node, comment, ctx);        }        @Override        protected void visit(XmlNode node, Document document, RuleContext ctx) {            visit("Document", document);            super.visit(node, document, ctx);        }        @Override        protected void visit(XmlNode node, DocumentType documentType, RuleContext ctx) {            visit("DocumentType", documentType);            super.visit(node, documentType, ctx);        }        @Override        protected void visit(XmlNode node, Element element, RuleContext ctx) {            visit("Element", element);            super.visit(node, element, ctx);        }        @Override        protected void visit(XmlNode node, Entity entity, RuleContext ctx) {            visit("Entity", entity);            super.visit(node, entity, ctx);        }        @Override        protected void visit(XmlNode node, EntityReference entityReference, RuleContext ctx) {            visit("EntityReference", entityReference);            super.visit(node, entityReference, ctx);        }        @Override        protected void visit(XmlNode node, Notation notation, RuleContext ctx) {            visit("Notation", notation);            super.visit(node, notation, ctx);        }        @Override        protected void visit(XmlNode node, ProcessingInstruction processingInstruction, RuleContext ctx) {            visit("ProcessingInstruction", processingInstruction);            super.visit(node, processingInstruction, ctx);        }        @Override        protected void visit(XmlNode node, Text text, RuleContext ctx) {            visit("Text", text);            super.visit(node, text, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractXmlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><foo abc=\"abc\"><bar/></foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        Parser parser = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        MyRule rule = new MyRule();        rule.apply(nodes, null);        assertEquals(3, rule.visitedNodes.size());        assertEquals("document", rule.visitedNodes.get(0).toString());        assertEquals("foo", rule.visitedNodes.get(1).toString());        assertEquals("bar", rule.visitedNodes.get(2).toString());    }    private static class MyRule extends AbstractXmlRule {        final List<XmlNode> visitedNodes = new ArrayList<>();        MyRule() {        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            visitedNodes.clear();            super.apply(nodes, ctx);        }        @Override        protected void visit(XmlNode node, RuleContext ctx) {            visitedNodes.add(node);            super.visit(node, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static net.sourceforge.pmd.lang.ParserOptionsTest.verifyOptionsEqualsHashcode;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.xml.rule.AbstractXmlRule;import net.sourceforge.pmd.properties.BooleanProperty;public class XmlParserOptionsTest {    @Test    public void testDefaults() throws Exception {        XmlParserOptions options = new XmlParserOptions();        assertFalse(options.isCoalescing());        assertTrue(options.isExpandEntityReferences());        assertFalse(options.isIgnoringComments());        assertFalse(options.isIgnoringElementContentWhitespace());        assertTrue(options.isNamespaceAware());        assertFalse(options.isValidating());        assertFalse(options.isXincludeAware());        MyRule rule = new MyRule();        options = (XmlParserOptions) rule.getParserOptions();        assertFalse(options.isCoalescing());        assertTrue(options.isExpandEntityReferences());        assertFalse(options.isIgnoringComments());        assertFalse(options.isIgnoringElementContentWhitespace());        assertTrue(options.isNamespaceAware());        assertFalse(options.isValidating());        assertFalse(options.isXincludeAware());    }    @Test    public void testConstructor() throws Exception {        MyRule rule = new MyRule();        rule.setProperty(XmlParserOptions.COALESCING_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isCoalescing());        rule.setProperty(XmlParserOptions.COALESCING_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isCoalescing());        rule.setProperty(XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isExpandEntityReferences());        rule.setProperty(XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isExpandEntityReferences());        rule.setProperty(XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isIgnoringComments());        rule.setProperty(XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isIgnoringComments());        rule.setProperty(XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isIgnoringElementContentWhitespace());        rule.setProperty(XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isIgnoringElementContentWhitespace());        rule.setProperty(XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isNamespaceAware());        rule.setProperty(XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isNamespaceAware());        rule.setProperty(XmlParserOptions.VALIDATING_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isValidating());        rule.setProperty(XmlParserOptions.VALIDATING_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isValidating());        rule.setProperty(XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isXincludeAware());        rule.setProperty(XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isXincludeAware());    }    @Test    public void testSetters() {        XmlParserOptions options = new XmlParserOptions();        options.setSuppressMarker("foo");        assertEquals("foo", options.getSuppressMarker());        options.setSuppressMarker(null);        assertNull(options.getSuppressMarker());        options.setCoalescing(true);        assertTrue(options.isCoalescing());        options.setCoalescing(false);        assertFalse(options.isCoalescing());        options.setExpandEntityReferences(true);        assertTrue(options.isExpandEntityReferences());        options.setExpandEntityReferences(false);        assertFalse(options.isExpandEntityReferences());        options.setIgnoringComments(true);        assertTrue(options.isIgnoringComments());        options.setIgnoringComments(false);        assertFalse(options.isIgnoringComments());        options.setIgnoringElementContentWhitespace(true);        assertTrue(options.isIgnoringElementContentWhitespace());        options.setIgnoringElementContentWhitespace(false);        assertFalse(options.isIgnoringElementContentWhitespace());        options.setNamespaceAware(true);        assertTrue(options.isNamespaceAware());        options.setNamespaceAware(false);        assertFalse(options.isNamespaceAware());        options.setValidating(true);        assertTrue(options.isValidating());        options.setValidating(false);        assertFalse(options.isValidating());        options.setXincludeAware(true);        assertTrue(options.isXincludeAware());        options.setXincludeAware(false);        assertFalse(options.isXincludeAware());    }    @Test    public void testEqualsHashcode() throws Exception {        BooleanProperty[] properties = new BooleanProperty[] { XmlParserOptions.COALESCING_DESCRIPTOR,            XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR,            XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR,            XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, XmlParserOptions.VALIDATING_DESCRIPTOR,            XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, };        for (int i = 0; i < properties.length; i++) {            BooleanProperty property = properties[i];            MyRule rule = new MyRule();            rule.setProperty(property, true);            ParserOptions options1 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options2 = rule.getParserOptions();            rule.setProperty(property, true);            ParserOptions options3 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options4 = rule.getParserOptions();            verifyOptionsEqualsHashcode(options1, options2, options3, options4);        }        XmlParserOptions options1 = new XmlParserOptions();        options1.setSuppressMarker("foo");        XmlParserOptions options2 = new XmlParserOptions();        options2.setSuppressMarker("bar");        XmlParserOptions options3 = new XmlParserOptions();        options3.setSuppressMarker("foo");        XmlParserOptions options4 = new XmlParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    private static final class MyRule extends AbstractXmlRule {    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(XmlParserOptionsTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static org.junit.Assert.assertNotNull;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.StringReader;import java.io.UnsupportedEncodingException;import java.nio.charset.StandardCharsets;import java.util.Iterator;import java.util.Locale;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.lang.xml.ast.XmlNode;import net.sourceforge.pmd.lang.xml.ast.internal.XmlParserImpl;import net.sourceforge.pmd.util.StringUtil;/** * Unit test for the {@link XmlParserImpl}. */public class XmlParserTest {    private static final String XML_TEST = "<?xml version=\"1.0\"?>\n" + "<!DOCTYPE rootElement\n" + "[\n"            + "<!ELEMENT rootElement (child1,child2)>\n" + "<!ELEMENT child1 (#PCDATA)>\n"            + "<!ATTLIST child1 test CDATA #REQUIRED>\n" + "<!ELEMENT child2 (#PCDATA)>\n" + "\n"            + "<!ENTITY pmd \"Copyright: PMD\">\n" + "]\n" + ">\n" + "<rootElement>\n"            + "    <!-- that's a comment -->\n" + "    <child1 test=\"1\">entity: &pmd;\n" + "    </child1>\n"            + "    <child2>\n" + "      <![CDATA[ cdata section ]]>\n" + "    </child2>\n" + "</rootElement>";    private static final String XML_NAMESPACE_TEST = "<?xml version=\"1.0\"?>\n"            + "<pmd:rootElement xmlns:pmd=\"http://pmd.sf.net\">\n" + "    <!-- that's a comment -->\n"            + "    <pmd:child1 test=\"1\">entity: &amp;\n" + "    </pmd:child1>\n" + "    <pmd:child2>\n"            + "      <![CDATA[ cdata section ]]>\n" + "    </pmd:child2>\n" + "</pmd:rootElement>";    private static final String XML_INVALID_WITH_DTD = "<?xml version=\"1.0\"?>\n" + "<!DOCTYPE rootElement\n" + "[\n"            + "<!ELEMENT rootElement (child)>\n" + "<!ELEMENT child (#PCDATA)>\n" + "]\n" + ">\n" + "<rootElement>\n"            + "  <invalidChild></invalidChild>\n" + "</rootElement>";    /**     * See bug #1054: XML Rules ever report a line -1 and not the line/column     * where the error occurs     *      * @throws Exception     *             any error     */    @Test    public void testLineNumbers() throws Exception {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        Parser parser = xmlVersionHandler.getParser(xmlVersionHandler.getDefaultParserOptions());        Node document = parser.parse(null, new StringReader(XML_TEST));        assertNode(document, "document", 2);        assertLineNumbers(document, 1, 1, 19, 14);        Node dtdElement = document.jjtGetChild(0);        assertNode(dtdElement, "rootElement", 0);        assertLineNumbers(dtdElement, 2, 1, 11, 1);        Node rootElement = document.jjtGetChild(1);        assertNode(rootElement, "rootElement", 7);        assertLineNumbers(rootElement, 12, 1, 19, 14);        assertTextNode(rootElement.jjtGetChild(0), "\\n    ");        assertLineNumbers(rootElement.jjtGetChild(0), 12, 14, 13, 4);        assertNode(rootElement.jjtGetChild(1), "comment", 0);        assertLineNumbers(rootElement.jjtGetChild(1), 13, 5, 13, 29);        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        assertLineNumbers(rootElement.jjtGetChild(2), 13, 30, 14, 4);        Node child1 = rootElement.jjtGetChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertLineNumbers(child1, 14, 5, 15, 13);        assertTextNode(child1.jjtGetChild(0), "entity: Copyright: PMD\\n    ");        assertLineNumbers(child1.jjtGetChild(0), 14, 22, 15, 4);        assertTextNode(rootElement.jjtGetChild(4), "\\n    ");        assertLineNumbers(rootElement.jjtGetChild(4), 15, 14, 16, 4);        Node child2 = rootElement.jjtGetChild(5);        assertNode(child2, "child2", 3);        assertLineNumbers(child2, 16, 5, 18, 13);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertLineNumbers(child2.jjtGetChild(0), 16, 13, 17, 6);        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertLineNumbers(child2.jjtGetChild(1), 17, 7, 17, 33);        assertTextNode(child2.jjtGetChild(2), "\\n    ");        assertLineNumbers(child2.jjtGetChild(2), 17, 34, 18, 4);        assertTextNode(rootElement.jjtGetChild(6), "\\n");        assertLineNumbers(rootElement.jjtGetChild(6), 18, 14, 18, 14);    }    /**     * Verifies the default parsing behavior of the XML parser.     */    @Test    public void testDefaultParsing() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        Parser parser = xmlVersionHandler.getParser(xmlVersionHandler.getDefaultParserOptions());        Node document = parser.parse(null, new StringReader(XML_TEST));        assertNode(document, "document", 2);        Node dtdElement = document.jjtGetChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.jjtGetChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.jjtGetChild(0), "\\n    ");        assertNode(rootElement.jjtGetChild(1), "comment", 0);        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        Node child1 = rootElement.jjtGetChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.jjtGetChild(4), "\\n    ");        Node child2 = rootElement.jjtGetChild(5);        assertNode(child2, "child2", 3);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.jjtGetChild(2), "\\n    ");        assertTextNode(rootElement.jjtGetChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser with coalescing enabled.     */    @Test    public void testParsingCoalescingEnabled() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setCoalescing(true);        Parser parser = xmlVersionHandler.getParser(parserOptions);        Node document = parser.parse(null, new StringReader(XML_TEST));        assertNode(document, "document", 2);        Node dtdElement = document.jjtGetChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.jjtGetChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.jjtGetChild(0), "\\n    ");        assertNode(rootElement.jjtGetChild(1), "comment", 0);        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        Node child1 = rootElement.jjtGetChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.jjtGetChild(4), "\\n    ");        Node child2 = rootElement.jjtGetChild(5);        assertNode(child2, "child2", 1);        assertTextNode(child2.jjtGetChild(0), "\\n       cdata section \\n    ");        assertTextNode(rootElement.jjtGetChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if entities are not     * expanded.     */    @Test    public void testParsingDoNotExpandEntities() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setExpandEntityReferences(false);        Parser parser = xmlVersionHandler.getParser(parserOptions);        Node document = parser.parse(null, new StringReader(XML_TEST));        assertNode(document, "document", 2);        Node dtdElement = document.jjtGetChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.jjtGetChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.jjtGetChild(0), "\\n    ");        assertNode(rootElement.jjtGetChild(1), "comment", 0);        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        Node child1 = rootElement.jjtGetChild(3);        assertNode(child1, "child1", 3, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: ");        assertNode(child1.jjtGetChild(1), "pmd", 0);        // with java13, expandEntityReferences=false works correctly, and the        // entity &pmd; is not expanded        String text = child1.jjtGetChild(2).getImage();        if ("\n    ".equals(text)) {            // java13 and later            assertTextNode(child1.jjtGetChild(2), "\\n    ");        } else {            assertTextNode(child1.jjtGetChild(2), "Copyright: PMD\\n    ");        }        assertTextNode(rootElement.jjtGetChild(4), "\\n    ");        Node child2 = rootElement.jjtGetChild(5);        assertNode(child2, "child2", 3);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.jjtGetChild(2), "\\n    ");        assertTextNode(rootElement.jjtGetChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if ignoring comments.     */    @Test    public void testParsingIgnoreComments() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setIgnoringComments(true);        Parser parser = xmlVersionHandler.getParser(parserOptions);        Node document = parser.parse(null, new StringReader(XML_TEST));        assertNode(document, "document", 2);        Node dtdElement = document.jjtGetChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.jjtGetChild(1);        assertNode(rootElement, "rootElement", 5);        assertTextNode(rootElement.jjtGetChild(0), "\\n    \\n    ");        Node child1 = rootElement.jjtGetChild(1);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        Node child2 = rootElement.jjtGetChild(3);        assertNode(child2, "child2", 3);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.jjtGetChild(2), "\\n    ");        assertTextNode(rootElement.jjtGetChild(4), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if ignoring whitespaces     * in elements.     */    @Test    public void testParsingIgnoreElementContentWhitespace() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setIgnoringElementContentWhitespace(true);        Parser parser = xmlVersionHandler.getParser(parserOptions);        Node document = parser.parse(null, new StringReader(XML_TEST));        assertNode(document, "document", 2);        Node dtdElement = document.jjtGetChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.jjtGetChild(1);        assertNode(rootElement, "rootElement", 3);        assertNode(rootElement.jjtGetChild(0), "comment", 0);        Node child1 = rootElement.jjtGetChild(1);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: Copyright: PMD\\n    ");        Node child2 = rootElement.jjtGetChild(2);        assertNode(child2, "child2", 3);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.jjtGetChild(2), "\\n    ");    }    /**     * Verifies the default parsing behavior of the XML parser with namespaces.     */    @Test    public void testDefaultParsingNamespaces() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        Parser parser = xmlVersionHandler.getParser(xmlVersionHandler.getDefaultParserOptions());        Node document = parser.parse(null, new StringReader(XML_NAMESPACE_TEST));        assertNode(document, "document", 1);        Node rootElement = document.jjtGetChild(0);        assertNode(rootElement, "pmd:rootElement", 7, "xmlns:pmd", "http://pmd.sf.net");        Assert.assertEquals("http://pmd.sf.net", ((XmlNode) rootElement).getNode().getNamespaceURI());        Assert.assertEquals("pmd", ((XmlNode) rootElement).getNode().getPrefix());        Assert.assertEquals("rootElement", ((XmlNode) rootElement).getNode().getLocalName());        Assert.assertEquals("pmd:rootElement", ((XmlNode) rootElement).getNode().getNodeName());        assertTextNode(rootElement.jjtGetChild(0), "\\n    ");        assertNode(rootElement.jjtGetChild(1), "comment", 0);        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        Node child1 = rootElement.jjtGetChild(3);        assertNode(child1, "pmd:child1", 1, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: &\\n    ");        assertTextNode(rootElement.jjtGetChild(4), "\\n    ");        Node child2 = rootElement.jjtGetChild(5);        assertNode(child2, "pmd:child2", 3);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.jjtGetChild(2), "\\n    ");        assertTextNode(rootElement.jjtGetChild(6), "\\n");    }    /**     * Verifies the default parsing behavior of the XML parser with namespaces     * but not namespace aware.     */    @Test    public void testParsingNotNamespaceAware() {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setNamespaceAware(false);        Parser parser = xmlVersionHandler.getParser(parserOptions);        Node document = parser.parse(null, new StringReader(XML_NAMESPACE_TEST));        assertNode(document, "document", 1);        Node rootElement = document.jjtGetChild(0);        assertNode(rootElement, "pmd:rootElement", 7, "xmlns:pmd", "http://pmd.sf.net");        Assert.assertNull(((XmlNode) rootElement).getNode().getNamespaceURI());        Assert.assertNull(((XmlNode) rootElement).getNode().getPrefix());        Assert.assertNull(((XmlNode) rootElement).getNode().getLocalName());        Assert.assertEquals("pmd:rootElement", ((XmlNode) rootElement).getNode().getNodeName());        assertTextNode(rootElement.jjtGetChild(0), "\\n    ");        assertNode(rootElement.jjtGetChild(1), "comment", 0);        assertTextNode(rootElement.jjtGetChild(2), "\\n    ");        Node child1 = rootElement.jjtGetChild(3);        assertNode(child1, "pmd:child1", 1, "test", "1");        assertTextNode(child1.jjtGetChild(0), "entity: &\\n    ");        assertTextNode(rootElement.jjtGetChild(4), "\\n    ");        Node child2 = rootElement.jjtGetChild(5);        assertNode(child2, "pmd:child2", 3);        assertTextNode(child2.jjtGetChild(0), "\\n      ");        assertTextNode(child2.jjtGetChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.jjtGetChild(2), "\\n    ");        assertTextNode(rootElement.jjtGetChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser with validation on.     *      * @throws UnsupportedEncodingException     *             error     */    @Test    public void testParsingWithValidation() throws UnsupportedEncodingException {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setValidating(true);        Parser parser = xmlVersionHandler.getParser(parserOptions);        PrintStream oldErr = System.err;        Locale oldLocale = Locale.getDefault();        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            System.setErr(new PrintStream(bos));            Locale.setDefault(Locale.ENGLISH);            Node document = parser.parse(null, new StringReader(XML_INVALID_WITH_DTD));            Assert.assertNotNull(document);            String output = bos.toString("UTF-8");            Assert.assertTrue(output.contains("Element type \"invalidChild\" must be declared."));            Assert.assertTrue(output.contains("The content of element type \"rootElement\" must match \"(child)\"."));            Assert.assertEquals(2, document.jjtGetNumChildren());            Assert.assertEquals("invalidChild", String.valueOf(document.jjtGetChild(1).jjtGetChild(1)));        } finally {            System.setErr(oldErr);            Locale.setDefault(oldLocale);        }    }    @Test    public void testWithProcessingInstructions() {        String xml = "<?xml version=\"1.0\"?><?mypi?><!DOCTYPE testDoc [<!ENTITY myentity \"e\">]><!--Comment--><foo abc=\"abc\"><bar>TEXT</bar><![CDATA[cdata!]]>&gt;&myentity;&lt;</foo>";        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions options = (XmlParserOptions) xmlVersionHandler.getDefaultParserOptions();        options.setExpandEntityReferences(false);        Parser parser = xmlVersionHandler.getParser(options);        Node document = parser.parse(null, new StringReader(xml));        Assert.assertNotNull(document);        assertNode(document.jjtGetChild(0), "mypi", 0);        assertLineNumbers(document.jjtGetChild(0), 1, 22, 1, 29);    }    private Node parseXml(String xml) {        LanguageVersionHandler xmlVersionHandler = LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion().getLanguageVersionHandler();        XmlParserOptions options = (XmlParserOptions) xmlVersionHandler.getDefaultParserOptions();        Parser parser = xmlVersionHandler.getParser(options);        return parser.parse(null, new StringReader(xml));    }    @Test    public void testBug1518() throws Exception {        String xml = IOUtils.toString(XmlParserTest.class.getResourceAsStream("parsertests/bug1518.xml"),                StandardCharsets.UTF_8);        Node document = parseXml(xml);        assertNotNull(document);    }    @Test    public void testAutoclosingElementLength() {        final String xml = "<elementName att1='foo' att2='bar' att3='other' />";        assertLineNumbers(parseXml(xml), 1, 1, 1, xml.length());    }    /**     * Asserts a single node inclusive attributes.     *      * @param node     *            the node     * @param toString     *            the to String representation to expect     * @param childs     *            number of childs     * @param atts     *            attributes - each object pair forms one attribute: first name,     *            then value.     */    private void assertNode(Node node, String toString, int childs, Object... atts) {        Assert.assertEquals(toString, String.valueOf(node));        Assert.assertEquals(childs, node.jjtGetNumChildren());        Iterator<Attribute> attributeIterator = node.getXPathAttributesIterator();        if (atts != null) {            for (int i = 0; i < atts.length; i += 2) {                Assert.assertTrue(attributeIterator.hasNext());                String name = String.valueOf(atts[i]);                Object value = atts[i + 1];                Attribute attribute = attributeIterator.next();                Assert.assertEquals(name, attribute.getName());                Assert.assertEquals(value, attribute.getValue());            }        }        Assert.assertFalse(attributeIterator.hasNext());    }    /**     * Assert a single text node.     *      * @param node     *            the node to check     * @param text     *            the text to expect     */    private void assertTextNode(Node node, String text) {        assertTextNode(node, text, "text");    }    /**     * Assert a single text node.     *     * @param node     *            the node to check     * @param text     *            the text to expect     * @param toString     *            the to string representation     */    private void assertTextNode(Node node, String text, String toString) {        Assert.assertEquals(toString, String.valueOf(node));        Assert.assertEquals(0, node.jjtGetNumChildren());        Assert.assertEquals(text, StringUtil.escapeWhitespace(node.getImage()));        Iterator<Attribute> attributeIterator = node.getXPathAttributesIterator();        Assert.assertTrue(attributeIterator.hasNext());        Attribute attribute = attributeIterator.next();        Assert.assertEquals("Image", attribute.getName());        Assert.assertEquals(text, StringUtil.escapeWhitespace(attribute.getValue()));        Assert.assertFalse(attributeIterator.hasNext());    }    /**     * Assert the line numbers of a node.     *     * @param node     *            the node     * @param beginLine     *            the begin line     * @param beginColumn     *            the begin column     * @param endLine     *            the end line     * @param endColumn     *            the end column     */    private void assertLineNumbers(Node node, int beginLine, int beginColumn, int endLine, int endColumn) {        Assert.assertEquals("begin line wrong", beginLine, node.getBeginLine());        Assert.assertEquals("begin column wrong", beginColumn, node.getBeginColumn());        Assert.assertEquals("end line wrong", endLine, node.getEndLine());        Assert.assertEquals("end column wrong", endColumn, node.getEndColumn());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProjectVersionAsDependencyVersionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InvalidDependencyTypesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.wsdl.rule;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.wsdl.WsdlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractWsdlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><foo abc=\"abc\"><bar/></foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        Parser parser = LanguageRegistry.getLanguage(WsdlLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getParser(parserOptions);        XmlNode xmlNode = (XmlNode) parser.parse(null, new StringReader(source));        List<XmlNode> nodes = new ArrayList<>();        nodes.add(xmlNode);        MyRule rule = new MyRule();        rule.apply(nodes, null);        assertEquals(3, rule.visitedNodes.size());        assertEquals("document", rule.visitedNodes.get(0).toString());        assertEquals("foo", rule.visitedNodes.get(1).toString());        assertEquals("bar", rule.visitedNodes.get(2).toString());    }    private static class MyRule extends AbstractWsdlRule {        final List<XmlNode> visitedNodes = new ArrayList<>();        MyRule() {        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            visitedNodes.clear();            super.apply(nodes, ctx);        }        @Override        protected void visit(XmlNode node, RuleContext ctx) {            visitedNodes.add(node);            super.visit(node, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidAxisNavigationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseConcatOnceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testXML() {        executeTarget("testXML");        assertOutputContaining("Potentially mistyped CDATA section with extra [ at beginning or ] at the end.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.pom.PomLanguageModule;import net.sourceforge.pmd.lang.wsdl.WsdlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xsl.XslLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { XmlLanguageModule.NAME, XmlLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion(), },            { XslLanguageModule.NAME, XslLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(XslLanguageModule.NAME).getDefaultVersion(), },            { WsdlLanguageModule.NAME, WsdlLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(WsdlLanguageModule.NAME).getDefaultVersion(), },            { PomLanguageModule.NAME, PomLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(PomLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test xml's and xslt's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Test;public class EdgeCasesTokenizerTest {    private String getSampleCode(final String filename) throws IOException {        return IOUtils.toString(GoTokenizer.class.getResourceAsStream(filename), StandardCharsets.UTF_8);    }    @Test    public void testEscapedBackSlash() throws IOException {        // See https://github.com/pmd/pmd/issues/1751        final String filename = "issue1751.go";        final GoTokenizer tokenizer = new GoTokenizer();        final SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(filename), filename));                final Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens); // it should simply not fail    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class GoCPDTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "hello.go";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new GoTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(GoTokenizer.class.getResourceAsStream(FILENAME));    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 23;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class GoTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "btrfs.go";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new GoTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(GoTokenizer.class.getResourceAsStream(FILENAME));    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 3517;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import java.util.List;import org.junit.Before;import org.junit.Test;public class CsTokenizerTest {    private CsTokenizer tokenizer;    private Tokens tokens;    @Before    public void init() {        tokenizer = new CsTokenizer();        tokens = new Tokens();        TokenEntry.clearImages();    }    @Test    public void testSimpleClass() {        tokenizer.tokenize(toSourceCode("class Foo {}"), tokens);        assertEquals(5, tokens.size());    }    @Test    public void testSimpleClassDuplicatedTokens() {        tokenizer.tokenize(toSourceCode("class Foo { class Foo { } }"), tokens);        assertEquals(9, tokens.size());        List<TokenEntry> tokenList = tokens.getTokens();        assertEquals(tokenList.get(0).getIdentifier(), tokenList.get(3).getIdentifier());        assertEquals(tokenList.get(1).getIdentifier(), tokenList.get(4).getIdentifier());        assertEquals(tokenList.get(2).getIdentifier(), tokenList.get(5).getIdentifier());        assertEquals(tokenList.get(6).getIdentifier(), tokenList.get(7).getIdentifier());    }    @Test    public void testSimpleClassMethodMultipleLines() {        tokenizer.tokenize(toSourceCode("class Foo {\n" + "  public String foo(int a) {\n" + "    int i = a;\n"                + "    return \"x\" + a;\n" + "  }\n" + "}"), tokens);        assertEquals(22, tokens.size());        List<TokenEntry> tokenList = tokens.getTokens();        assertEquals(1, tokenList.get(0).getBeginLine());        assertEquals(2, tokenList.get(4).getBeginLine());        assertEquals(3, tokenList.get(11).getBeginLine());    }    @Test    public void testStrings() {        tokenizer.tokenize(toSourceCode("String s =\"aaa \\\"b\\n\";"), tokens);        assertEquals(5, tokens.size());    }    @Test    public void testOpenString() {        tokenizer.tokenize(toSourceCode("String s =\"aaa \\\"b\\"), tokens);        assertEquals(5, tokens.size());    }    @Test    public void testCommentsIgnored1() {        tokenizer.tokenize(toSourceCode("class Foo { /* class * ** X */ }"), tokens);        assertEquals(5, tokens.size());    }    @Test    public void testCommentsIgnored2() {        tokenizer.tokenize(toSourceCode("class Foo { // class X /* aaa */ \n }"), tokens);        assertEquals(5, tokens.size());    }    @Test    public void testCommentsIgnored3() {        tokenizer.tokenize(toSourceCode("class Foo { /// class X /* aaa */ \n }"), tokens);        assertEquals(5, tokens.size());    }    @Test    public void testMoreTokens() {        tokenizer                .tokenize(                        toSourceCode("class Foo {\n" + "  void bar() {\n" + "    int a = 1 >> 2; \n" + "    a += 1; \n"                                + "    a++; \n" + "    a /= 3e2; \n" + "    float f = -3.1; \n" + "    f *= 2; \n"                                + "    bool b = ! (f == 2.0 || f >= 1.0 && f <= 2.0) \n" + "  }\n" + "}"),                        tokens);        assertEquals(50, tokens.size());    }    @Test    public void testLineNumberAfterMultilineComment() {        tokenizer                .tokenize(                        toSourceCode("/* This is a multiline comment \n" + " * \n" + " * Lorem ipsum dolor sit amet, \n"                                + " * consectetur adipiscing elit \n" + " */\n" + "\n" + "class Foo {\n" + "\n" + "}"),                        tokens);        assertEquals(5, tokens.size());        assertEquals(7, tokens.getTokens().get(0).getBeginLine());    }    @Test    public void testLineNumberAfterMultilineString() {        tokenizer.tokenize(toSourceCode(                "class Foo {\n" + "  void bar() {\n" + "    String query = \n" + "      @\"SELECT foo, bar\n"                        + "         FROM table \n" + "         WHERE id = 42\"; \n" + "  }\n" + "}"),                tokens);        assertEquals(16, tokens.size());        assertEquals(8, tokens.getTokens().get(14).getBeginLine());    }    @Test    public void testIgnoreUsingDirectives() {        tokenizer.setIgnoreUsings(true);        tokenizer.tokenize(toSourceCode("using System.Text;\n"), tokens);        assertNotEquals("using", tokens.getTokens().get(0).toString());        assertEquals(2, tokens.size());    }    @Test    public void testUsingStatementsAreNotIgnored() {        tokenizer.setIgnoreUsings(true);        tokenizer.tokenize(toSourceCode(                "using (Font font1 = new Font(\"Arial\", 10.0f)) {\n" + "  byte charset = font1.GdiCharSet;\n" + "}\n"),                tokens);        assertEquals("using", tokens.getTokens().get(0).toString());    }    private SourceCode toSourceCode(String source) {        return new SourceCode(new SourceCode.StringCodeLoader(source));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import java.util.ArrayList;import java.util.List;import java.util.Properties;import org.junit.Ignore;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageVersion;/** * Stores the information required to run a complete test. */@Ignore("this is not a unit test")public class TestDescriptor {    private Rule rule;    private Properties properties;    private String description;    private int numberOfProblemsExpected;    private List<String> expectedMessages = new ArrayList<>();    private List<Integer> expectedLineNumbers = new ArrayList<>();    private String code;    private LanguageVersion languageVersion;    // default, avoids unintentional mixing of state between test cases    private boolean reinitializeRule = true;    private boolean isRegressionTest = true;    private boolean useAuxClasspath = true;    private int numberInDocument = -1;    public TestDescriptor() {        // Empty default descriptor added to please mvn surefire plugin    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this(code, description, numberOfProblemsExpected, rule, rule.getLanguage().getDefaultVersion());    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule,            LanguageVersion languageVersion) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;        this.languageVersion = languageVersion;    }    public int getNumberInDocument() {        return numberInDocument;    }    public void setNumberInDocument(int numberInDocument) {        this.numberInDocument = numberInDocument;    }    public void setExpectedMessages(List<String> messages) {        expectedMessages.clear();        expectedMessages.addAll(messages);    }    public List<String> getExpectedMessages() {        return expectedMessages;    }    public void setExpectedLineNumbers(List<Integer> expectedLineNumbers) {        this.expectedLineNumbers.clear();        this.expectedLineNumbers.addAll(expectedLineNumbers);    }    public List<Integer> getExpectedLineNumbers() {        return expectedLineNumbers;    }    public void setProperties(Properties properties) {        this.properties = properties;    }    public Properties getProperties() {        return properties;    }    public String getCode() {        return code;    }    public LanguageVersion getLanguageVersion() {        return languageVersion;    }    public String getDescription() {        return description;    }    public int getNumberOfProblemsExpected() {        return numberOfProblemsExpected;    }    public Rule getRule() {        return rule;    }    public boolean getReinitializeRule() {        return reinitializeRule;    }    public void setReinitializeRule(boolean reinitializeRule) {        this.reinitializeRule = reinitializeRule;    }    /**     * Checks whether we are testing for regression problems only. Return value     * is based on the system property "pmd.regress".     *     * @return <code>false</code> if system property "pmd.regress" is set to     *         <code>false</code>, <code>true</code> otherwise     */    public static boolean inRegressionTestMode() {        boolean inRegressionMode = true; // default        try {            // get the "pmd.regress" System property            String property = System.getProperty("pmd.regress");            if (property != null) {                inRegressionMode = Boolean.parseBoolean(property);            }        } catch (IllegalArgumentException e) {            throw new RuntimeException("Invalid system property 'pmd.regress'", e);        }        return inRegressionMode;    }    public boolean isRegressionTest() {        return isRegressionTest;    }    public void setRegressionTest(boolean isRegressionTest) {        this.isRegressionTest = isRegressionTest;    }    public void setUseAuxClasspath(boolean useAuxClasspath) {        this.useAuxClasspath = useAuxClasspath;    }    public boolean isUseAuxClasspath() {        return useAuxClasspath;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.util.List;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;/** * @author Romain PELISSE, belaran@gmail.com * */public abstract class AbstractTokenizerTest {    protected int expectedTokenCount;    protected Tokenizer tokenizer;    protected SourceCode sourceCode;    public abstract void buildTokenizer() throws IOException;    public abstract String getSampleCode() throws IOException;    protected void tokenizeTest() throws IOException {        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        List<TokenEntry> entries = tokens.getTokens();        assertEquals(expectedTokenCount, entries.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;/** * Unit tests for {@link ParserOptions}. */public class ParserOptionsTest {    /**     * SuppressMarker should be initially null and changeable.     */    @Test    public void testSuppressMarker() {        ParserOptions parserOptions = new ParserOptions();        Assert.assertNull(parserOptions.getSuppressMarker());        parserOptions.setSuppressMarker("foo");        Assert.assertEquals("foo", parserOptions.getSuppressMarker());    }    /**     * Verify that the equals and hashCode methods work as expected.     */    @Test    public void testEqualsHashcode() {        ParserOptions options1 = new ParserOptions();        options1.setSuppressMarker("foo");        ParserOptions options2 = new ParserOptions();        options2.setSuppressMarker("bar");        ParserOptions options3 = new ParserOptions();        options3.setSuppressMarker("foo");        ParserOptions options4 = new ParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    /**     * Verify equals and hashCode for 4 {@link ParserOptions} instances. The     * given options should be as follows: 1 and 3 are equals, as are 2 and 4.     *     * @param options1     *            first option instance - equals third     * @param options2     *            second option instance - equals fourth     * @param options3     *            third option instance - equals first     * @param options4     *            fourth option instance - equals second     */    public static void verifyOptionsEqualsHashcode(ParserOptions options1, ParserOptions options2,            ParserOptions options3, ParserOptions options4) {        // Objects should be different        Assert.assertNotSame(options1, options2);        Assert.assertNotSame(options1, options2);        Assert.assertNotSame(options1, options3);        Assert.assertNotSame(options2, options3);        Assert.assertNotSame(options2, options4);        Assert.assertNotSame(options3, options4);        // Check all 16 equality combinations        Assert.assertEquals(options1, options1);        Assert.assertFalse(options1.equals(options2));        Assert.assertEquals(options1, options3);        Assert.assertFalse(options1.equals(options4));        Assert.assertFalse(options2.equals(options1));        Assert.assertEquals(options2, options2);        Assert.assertFalse(options2.equals(options3));        Assert.assertEquals(options2, options4);        Assert.assertEquals(options3, options1);        Assert.assertFalse(options3.equals(options2));        Assert.assertEquals(options3, options3);        Assert.assertFalse(options3.equals(options4));        Assert.assertFalse(options4.equals(options1));        Assert.assertEquals(options4, options2);        Assert.assertFalse(options4.equals(options3));        Assert.assertEquals(options4, options4);        // Hashcodes should match up        Assert.assertNotEquals(options1.hashCode(), options2.hashCode());        Assert.assertEquals(options1.hashCode(), options3.hashCode());        Assert.assertNotEquals(options1.hashCode(), options4.hashCode());        Assert.assertNotEquals(options2.hashCode(), options3.hashCode());        Assert.assertEquals(options2.hashCode(), options4.hashCode());        Assert.assertNotEquals(options3.hashCode(), options4.hashCode());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.nio.file.Files;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.BeforeClass;import net.sourceforge.pmd.PMD;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public abstract class BaseCLITest {    protected static final String TEST_OUPUT_DIRECTORY = "target/cli-tests/";    // Points toward a folder with not many source files, to avoid actually PMD    // and slowing down tests    protected static final String SOURCE_FOLDER = "src/test/resources/net/sourceforge/pmd/cli";    protected PrintStream originalOut;    protected PrintStream originalErr;    /**     * @throws java.lang.Exception     */    @BeforeClass    public static void setUp() throws Exception {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        File testOuputDir = new File(TEST_OUPUT_DIRECTORY);        if (!testOuputDir.exists()) {            assertTrue("failed to create output directory for test:" + testOuputDir.getAbsolutePath(),                    testOuputDir.mkdirs());        }    }    @Before    public void setup() {        originalOut = System.out;        originalErr = System.err;    }    @After    public void tearDown() {        IOUtils.closeQuietly(System.out);        System.setOut(originalOut);        System.setErr(originalErr);    }    protected void createTestOutputFile(String filename) {        try {            @SuppressWarnings("PMD.CloseResource")            PrintStream out = new PrintStream(Files.newOutputStream(new File(filename).toPath()));            System.setOut(out);            System.setErr(out);        } catch (IOException e) {            fail("Can't create file " + filename + " for test.");        }    }    protected String runTest(String[] args, String testname) {        return runTest(args, testname, 0);    }    protected String runTest(String[] args, String testname, int expectedExitCode) {        String filename = TEST_OUPUT_DIRECTORY + testname + ".txt";        long start = System.currentTimeMillis();        createTestOutputFile(filename);        System.out.println("Start running test " + testname);        runPMDWith(args);        checkStatusCode(expectedExitCode);        System.out.println("Test finished successfully after " + (System.currentTimeMillis() - start) + "ms.");        return filename;    }    protected void runPMDWith(String[] args) {        PMD.main(args);    }    protected void checkStatusCode(int expectedExitCode) {        int statusCode = getStatusCode();        if (statusCode != expectedExitCode) {            fail("PMD failed with status code:" + statusCode);        }    }    protected int getStatusCode() {        return Integer.parseInt(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.UnsupportedEncodingException;import org.junit.After;import org.junit.Before;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.cpd.CPDCommandLineInterface;public abstract class BaseCPDCLITest {    private ByteArrayOutputStream bufferStdout;    private PrintStream originalStdout;    private PrintStream originalStderr;    @Before    public void setup() throws UnsupportedEncodingException {        originalStdout = System.out;        originalStderr = System.err;        bufferStdout = new ByteArrayOutputStream();        System.setOut(new PrintStream(bufferStdout, false, "UTF-8"));        System.setErr(System.out);    }    @After    public void teardown() {        System.setOut(originalStdout);        System.setErr(originalStderr);    }    public final String getOutput() {        try {            return bufferStdout.toString("UTF-8");        } catch (UnsupportedEncodingException e) {            throw new RuntimeException(e);        }    }    protected void runCPD(String... args) {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPD.main(args);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Properties;import java.util.Set;import java.util.StringTokenizer;import java.util.regex.Pattern;import javax.xml.parsers.ParserConfigurationException;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.apache.commons.io.FilenameUtils;import org.junit.BeforeClass;import org.junit.Test;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import org.xml.sax.helpers.DefaultHandler;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.ResourceLoader;/** * Base test class to verify the language's rulesets. This class should be * subclassed for each language. */public abstract class AbstractRuleSetFactoryTest {    private static SAXParserFactory saxParserFactory;    private static ValidateDefaultHandler validateDefaultHandler;    private static SAXParser saxParser;    protected Set<String> validXPathClassNames = new HashSet<>();    public AbstractRuleSetFactoryTest() {        validXPathClassNames.add(XPathRule.class.getName());    }    /**     * Setups the XML parser with validation.     *      * @throws Exception     *             any error     */    @BeforeClass    public static void init() throws Exception {        saxParserFactory = SAXParserFactory.newInstance();        saxParserFactory.setValidating(true);        saxParserFactory.setNamespaceAware(true);        // Hope we're using Xerces, or this may not work!        // Note: Features are listed here        // http://xerces.apache.org/xerces2-j/features.html        saxParserFactory.setFeature("http://xml.org/sax/features/validation", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema-full-checking", true);        validateDefaultHandler = new ValidateDefaultHandler();        saxParser = saxParserFactory.newSAXParser();    }    /**     * Checks all rulesets of all languages on the classpath and verifies that     * all required attributes for all rules are specified.     *      * @throws Exception     *             any error     */    @Test    public void testAllPMDBuiltInRulesMeetConventions() throws Exception {        int invalidSinceAttributes = 0;        int invalidExternalInfoURL = 0;        int invalidClassName = 0;        int invalidRegexSuppress = 0;        int invalidXPathSuppress = 0;        String messages = "";        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            RuleSet ruleSet = loadRuleSetByFileName(fileName);            for (Rule rule : ruleSet.getRules()) {                // Skip references                if (rule instanceof RuleReference) {                    continue;                }                Language language = rule.getLanguage();                String group = fileName.substring(fileName.lastIndexOf('/') + 1);                group = group.substring(0, group.indexOf(".xml"));                if (group.indexOf('-') >= 0) {                    group = group.substring(0, group.indexOf('-'));                }                // Is since missing ?                if (rule.getSince() == null) {                    invalidSinceAttributes++;                    messages += "Rule " + fileName + "/" + rule.getName() + " is missing 'since' attribute" + PMD.EOL;                }                // Is URL valid ?                if (rule.getExternalInfoUrl() == null || "".equalsIgnoreCase(rule.getExternalInfoUrl())) {                    invalidExternalInfoURL++;                    messages += "Rule " + fileName + "/" + rule.getName() + " is missing 'externalInfoURL' attribute"                            + PMD.EOL;                } else {                    String expectedExternalInfoURL = "https?://pmd.(sourceforge.net|github.io)/.+/pmd_rules_"                            + language.getTerseName() + "_"                            + FilenameUtils.getBaseName(fileName)                            + ".html#"                            + rule.getName().toLowerCase(Locale.ROOT);                    if (rule.getExternalInfoUrl() == null                            || !rule.getExternalInfoUrl().matches(expectedExternalInfoURL)) {                        invalidExternalInfoURL++;                        messages += "Rule " + fileName + "/" + rule.getName()                                + " seems to have an invalid 'externalInfoURL' value (" + rule.getExternalInfoUrl()                                + "), it should be:" + expectedExternalInfoURL + PMD.EOL;                    }                }                // Proper class name/packaging?                String expectedClassName = "net.sourceforge.pmd.lang." + language.getTerseName() + ".rule." + group                        + "." + rule.getName() + "Rule";                if (!rule.getRuleClass().equals(expectedClassName)                        && !validXPathClassNames.contains(rule.getRuleClass())) {                    invalidClassName++;                    messages += "Rule " + fileName + "/" + rule.getName() + " seems to have an invalid 'class' value ("                            + rule.getRuleClass() + "), it should be:" + expectedClassName + PMD.EOL;                }                // Should not have violation suppress regex property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR) != null) {                    invalidRegexSuppress++;                    messages += "Rule " + fileName + "/" + rule.getName() + " should not have '"                            + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name()                            + "', this is intended for end user customization only." + PMD.EOL;                }                // Should not have violation suppress xpath property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) != null) {                    invalidXPathSuppress++;                    messages += "Rule " + fileName + "/" + rule.getName() + " should not have '"                            + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name()                            + "', this is intended for end user customization only." + PMD.EOL;                }            }        }        // We do this at the end to ensure we test ALL the rules before failing        // the test        if (invalidSinceAttributes > 0 || invalidExternalInfoURL > 0 || invalidClassName > 0 || invalidRegexSuppress > 0                || invalidXPathSuppress > 0) {            fail("All built-in PMD rules need 'since' attribute (" + invalidSinceAttributes                    + " are missing), a proper ExternalURLInfo (" + invalidExternalInfoURL                    + " are invalid), a class name meeting conventions (" + invalidClassName + " are invalid), no '"                    + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name() + "' property (" + invalidRegexSuppress                    + " are invalid), and no '" + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name() + "' property ("                    + invalidXPathSuppress + " are invalid)" + PMD.EOL + messages);        }    }    /**     * Verifies that all rulesets are valid XML according to the xsd schema.     *      * @throws Exception     *             any error     */    @Test    public void testXmlSchema() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstSchema(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Verifies that all rulesets are valid XML according to the DTD.     *      * @throws Exception     *             any error     */    @Test    public void testDtd() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstDtd(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Reads and writes the rulesets to make sure, that no data is lost if the     * rulests are processed.     *      * @throws Exception     *             any error     */    @Test    public void testReadWriteRoundTrip() throws Exception {        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            testRuleSet(fileName);        }    }    // Gets all test PMD Ruleset XML files    private List<String> getRuleSetFileNames() throws IOException, RuleSetNotFoundException {        List<String> result = new ArrayList<>();        for (Language language : LanguageRegistry.getLanguages()) {            result.addAll(getRuleSetFileNames(language.getTerseName()));        }        return result;    }    private List<String> getRuleSetFileNames(String language) throws IOException, RuleSetNotFoundException {        List<String> ruleSetFileNames = new ArrayList<>();        try {            Properties properties = new Properties();            try (InputStream is = new ResourceLoader().loadClassPathResourceAsStreamOrThrow("rulesets/" + language + "/rulesets.properties")) {                properties.load(is);            }            String fileNames = properties.getProperty("rulesets.filenames");            StringTokenizer st = new StringTokenizer(fileNames, ",");            while (st.hasMoreTokens()) {                ruleSetFileNames.add(st.nextToken());            }        } catch (RuleSetNotFoundException e) {            // this might happen if a language is only support by CPD, but not            // by PMD            System.err.println("No ruleset found for language " + language);        }        return ruleSetFileNames;    }    private RuleSet loadRuleSetByFileName(String ruleSetFileName) throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory();        return rsf.createRuleSet(ruleSetFileName);    }    private boolean validateAgainstSchema(String fileName)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstSchema(inputStream);            if (!valid) {                System.err.println("Validation against XML Schema failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstSchema(InputStream inputStream)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        saxParser.parse(inputStream, validateDefaultHandler.resetValid());        inputStream.close();        return validateDefaultHandler.isValid();    }    private boolean validateAgainstDtd(String fileName)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstDtd(inputStream);            if (!valid) {                System.err.println("Validation against DTD failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstDtd(InputStream inputStream)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        // Read file into memory        String file = readFullyToString(inputStream);        inputStream.close();        String rulesetNamespace = RuleSetWriter.RULESET_2_0_0_NS_URI;        // Remove XML Schema stuff, replace with DTD        file = file.replaceAll("<\\?xml [ a-zA-Z0-9=\".-]*\\?>", "");        file = file.replaceAll("xmlns=\"" + rulesetNamespace + "\"", "");        file = file.replaceAll("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "");        file = file.replaceAll("xsi:schemaLocation=\"" + rulesetNamespace                + " https://pmd.sourceforge.io/ruleset_\\d_0_0.xsd\"", "");        if (rulesetNamespace.equals(RuleSetWriter.RULESET_2_0_0_NS_URI)) {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset SYSTEM "                    + "\"https://pmd.sourceforge.io/ruleset_2_0_0.dtd\">" + PMD.EOL + file;        } else {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset>" + PMD.EOL + file;        }        try (InputStream modifiedStream = new ByteArrayInputStream(file.getBytes())) {            saxParser.parse(modifiedStream, validateDefaultHandler.resetValid());        }        return validateDefaultHandler.isValid();    }    private String readFullyToString(InputStream inputStream) throws IOException {        StringBuilder buf = new StringBuilder(64 * 1024);        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {            String line;            while ((line = reader.readLine()) != null) {                buf.append(line);                buf.append(PMD.EOL);            }            return buf.toString();        }    }    private static InputStream loadResourceAsStream(String resource) throws RuleSetNotFoundException {        return new ResourceLoader().loadClassPathResourceAsStreamOrThrow(resource);    }    private void testRuleSet(String fileName)            throws IOException, RuleSetNotFoundException, ParserConfigurationException, SAXException {        // Load original XML        // String xml1 =        // readFullyToString(ResourceLoader.loadResourceAsStream(fileName));        // System.out.println("xml1: " + xml1);        // Load the original RuleSet        RuleSet ruleSet1 = loadRuleSetByFileName(fileName);        // Write to XML, first time        ByteArrayOutputStream outputStream1 = new ByteArrayOutputStream();        RuleSetWriter writer1 = new RuleSetWriter(outputStream1);        writer1.write(ruleSet1);        writer1.close();        String xml2 = new String(outputStream1.toByteArray());        // System.out.println("xml2: " + xml2);        // Read RuleSet from XML, first time        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet ruleSet2 = ruleSetFactory.createRuleSet(createRuleSetReferenceId(xml2));        // Do write/read a 2nd time, just to be sure        // Write to XML, second time        ByteArrayOutputStream outputStream2 = new ByteArrayOutputStream();        RuleSetWriter writer2 = new RuleSetWriter(outputStream2);        writer2.write(ruleSet2);        writer2.close();        String xml3 = new String(outputStream2.toByteArray());        // System.out.println("xml3: " + xml3);        // Read RuleSet from XML, second time        RuleSet ruleSet3 = ruleSetFactory.createRuleSet(createRuleSetReferenceId(xml3));        // The 2 written XMLs should all be valid w.r.t Schema/DTD        assertTrue("1st roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml3.getBytes())));        assertTrue("1st roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml3.getBytes())));        // All 3 versions of the RuleSet should be the same        assertEqualsRuleSet("Original RuleSet and 1st roundtrip Ruleset not the same (filename: " + fileName + ")",                ruleSet1, ruleSet2);        assertEqualsRuleSet("1st roundtrip Ruleset and 2nd roundtrip RuleSet not the same (filename: " + fileName + ")",                ruleSet2, ruleSet3);        // It's hard to compare the XML DOMs. At least the roundtrip ones should        // textually be the same.        assertEquals("1st roundtrip RuleSet XML and 2nd roundtrip RuleSet XML (filename: " + fileName + ")", xml2,                xml3);    }    private void assertEqualsRuleSet(String message, RuleSet ruleSet1, RuleSet ruleSet2) {        assertEquals(message + ", RuleSet name", ruleSet1.getName(), ruleSet2.getName());        assertEquals(message + ", RuleSet description", ruleSet1.getDescription(), ruleSet2.getDescription());        assertEquals(message + ", RuleSet exclude patterns", ruleSet1.getExcludePatterns(),                ruleSet2.getExcludePatterns());        assertEquals(message + ", RuleSet include patterns", ruleSet1.getIncludePatterns(),                ruleSet2.getIncludePatterns());        assertEquals(message + ", RuleSet rule count", ruleSet1.getRules().size(), ruleSet2.getRules().size());        for (int i = 0; i < ruleSet1.getRules().size(); i++) {            Rule rule1 = ((List<Rule>) ruleSet1.getRules()).get(i);            Rule rule2 = ((List<Rule>) ruleSet2.getRules()).get(i);            assertFalse(message + ", Different RuleReference",                        rule1 instanceof RuleReference != rule2 instanceof RuleReference);            if (rule1 instanceof RuleReference) {                RuleReference ruleReference1 = (RuleReference) rule1;                RuleReference ruleReference2 = (RuleReference) rule2;                assertEquals(message + ", RuleReference overridden language", ruleReference1.getOverriddenLanguage(),                        ruleReference2.getOverriddenLanguage());                assertEquals(message + ", RuleReference overridden minimum language version",                        ruleReference1.getOverriddenMinimumLanguageVersion(),                        ruleReference2.getOverriddenMinimumLanguageVersion());                assertEquals(message + ", RuleReference overridden maximum language version",                        ruleReference1.getOverriddenMaximumLanguageVersion(),                        ruleReference2.getOverriddenMaximumLanguageVersion());                assertEquals(message + ", RuleReference overridden deprecated", ruleReference1.isOverriddenDeprecated(),                        ruleReference2.isOverriddenDeprecated());                assertEquals(message + ", RuleReference overridden name", ruleReference1.getOverriddenName(),                        ruleReference2.getOverriddenName());                assertEquals(message + ", RuleReference overridden description",                        ruleReference1.getOverriddenDescription(), ruleReference2.getOverriddenDescription());                assertEquals(message + ", RuleReference overridden message", ruleReference1.getOverriddenMessage(),                        ruleReference2.getOverriddenMessage());                assertEquals(message + ", RuleReference overridden external info url",                        ruleReference1.getOverriddenExternalInfoUrl(), ruleReference2.getOverriddenExternalInfoUrl());                assertEquals(message + ", RuleReference overridden priority", ruleReference1.getOverriddenPriority(),                        ruleReference2.getOverriddenPriority());                assertEquals(message + ", RuleReference overridden examples", ruleReference1.getOverriddenExamples(),                        ruleReference2.getOverriddenExamples());            }            assertEquals(message + ", Rule name", rule1.getName(), rule2.getName());            assertEquals(message + ", Rule class", rule1.getRuleClass(), rule2.getRuleClass());            assertEquals(message + ", Rule description " + rule1.getName(), rule1.getDescription(),                    rule2.getDescription());            assertEquals(message + ", Rule message", rule1.getMessage(), rule2.getMessage());            assertEquals(message + ", Rule external info url", rule1.getExternalInfoUrl(), rule2.getExternalInfoUrl());            assertEquals(message + ", Rule priority", rule1.getPriority(), rule2.getPriority());            assertEquals(message + ", Rule examples", rule1.getExamples(), rule2.getExamples());            List<PropertyDescriptor<?>> propertyDescriptors1 = rule1.getPropertyDescriptors();            List<PropertyDescriptor<?>> propertyDescriptors2 = rule2.getPropertyDescriptors();            assertEquals(message + ", Rule property descriptor ", propertyDescriptors1, propertyDescriptors2);            for (int j = 0; j < propertyDescriptors1.size(); j++) {                Object value1 = rule1.getProperty(propertyDescriptors1.get(j));                Object value2 = rule2.getProperty(propertyDescriptors2.get(j));                // special case for Pattern, there is no equals method                if (propertyDescriptors1.get(j).type() == Pattern.class) {                    value1 = ((Pattern) value1).pattern();                    value2 = ((Pattern) value2).pattern();                }                assertEquals(message + ", Rule property value " + j, value1, value2);            }            assertEquals(message + ", Rule property descriptor count", propertyDescriptors1.size(),                    propertyDescriptors2.size());        }    }    /**     * Create a {@link RuleSetReferenceId} by the given XML string.     *      * @param ruleSetXml     *            the ruleset file content as string     * @return the {@link RuleSetReferenceId}     */    protected static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {        return new RuleSetReferenceId(null) {            @Override            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {                try {                    return new ByteArrayInputStream(ruleSetXml.getBytes("UTF-8"));                } catch (UnsupportedEncodingException e) {                    return null;                }            }        };    }    /**     * Validator for the SAX parser     */    private static class ValidateDefaultHandler extends DefaultHandler {        private boolean valid = true;        private final Map<String, String> schemaMapping;        ValidateDefaultHandler() {            schemaMapping = new HashMap<>();            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.xsd", "ruleset_2_0_0.xsd");            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.dtd", "ruleset_2_0_0.dtd");        }        public ValidateDefaultHandler resetValid() {            valid = true;            return this;        }        public boolean isValid() {            return valid;        }        @Override        public void error(SAXParseException e) throws SAXException {            log("Error", e);        }        @Override        public void fatalError(SAXParseException e) throws SAXException {            log("FatalError", e);        }        @Override        public void warning(SAXParseException e) throws SAXException {            log("Warning", e);        }        private void log(String prefix, SAXParseException e) {            String message = prefix + " at (" + e.getLineNumber() + ", " + e.getColumnNumber() + "): " + e.getMessage();            System.err.println(message);            valid = false;        }        @Override        public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {            String resource = schemaMapping.get(systemId);            if (resource != null) {                try {                    InputStream inputStream = loadResourceAsStream(resource);                    return new InputSource(inputStream);                } catch (RuleSetNotFoundException e) {                    System.err.println(e.getMessage());                    throw new IOException(e.getMessage());                }            }            throw new IllegalArgumentException(                    "No clue how to handle: publicId=" + publicId + ", systemId=" + systemId);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.ant.SourceLanguage;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.util.ResourceLoader;/** * Base test class for {@link LanguageVersion} implementations. <br> * Each language implementation should subclass this and provide a data method. * * <pre> * &#64;Parameters *     public static Collection&lt;Object[]&gt; data() { *       return Arrays.asList(new Object[][] { *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.1", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.1") }, *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.2", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.2") }, * *            // doesn't exist *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.3", *              null } *       }); * </pre> * * <p>For the parameters, see the constructor * {@link #AbstractLanguageVersionTest(String, String, String, LanguageVersion)}.</p> */@RunWith(Parameterized.class)public class AbstractLanguageVersionTest {    private String name;    private String version;    private String simpleTerseName;    private LanguageVersion expected;    /**     * Creates a new {@link AbstractLanguageVersionTest}     *     * @param name     *            the name under which the language module is registered     * @param terseName     *            the terse name under which the language module is registered     * @param version     *            the specific version of the language version     * @param expected     *            the expected {@link LanguageVersion} instance     */    public AbstractLanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        this.name = name;        this.version = version;        this.simpleTerseName = terseName;        this.expected = expected;    }    /**     * Checks that the expected {@link LanguageVersion} can be found via     * {@link #name} and {@link #version}.     */    @Test    public void testFindVersionsForLanguageNameAndVersion() {        SourceLanguage sourceLanguage = new SourceLanguage();        sourceLanguage.setName(name);        sourceLanguage.setVersion(version);        Language language = LanguageRegistry.getLanguage(sourceLanguage.getName());        LanguageVersion languageVersion = null;        if (language != null) {            languageVersion = language.getVersion(sourceLanguage.getVersion());        }        assertEquals(expected, languageVersion);    }    /**     * Makes sure, that for each language a "categories.properties" file exists.     *     * @throws Exception     *             any error     */    @Test    public void testRegisteredRulesets() throws Exception {        if (expected == null) {            return;        }        ResourceLoader rl = new ResourceLoader();        Properties props = new Properties();        String rulesetsProperties = "category/" + simpleTerseName + "/categories.properties";        try (InputStream inputStream = rl.loadClassPathResourceAsStreamOrThrow(rulesetsProperties)) {            props.load(inputStream);        }        assertRulesetsAndCategoriesProperties(rl, props);    }    /**     * If a rulesets.properties file still exists, test it as well.     *     * @throws Exception     *             any error     */    @Test    public void testOldRegisteredRulesets() throws Exception {        // only check for languages, that support rules        if (expected == null || expected.getLanguage().getRuleChainVisitorClass() == null) {            return;        }        ResourceLoader rl = new ResourceLoader();        Properties props = new Properties();        String rulesetsProperties = "rulesets/" + simpleTerseName + "/rulesets.properties";        InputStream inputStream = rl.loadClassPathResourceAsStream(rulesetsProperties);        if (inputStream != null) {            // rulesets.properties file exists            try (InputStream in = inputStream) {                props.load(in);            }            assertRulesetsAndCategoriesProperties(rl, props);        }    }    private void assertRulesetsAndCategoriesProperties(ResourceLoader rl, Properties props)            throws IOException, RuleSetNotFoundException {        String rulesetFilenames = props.getProperty("rulesets.filenames");        assertNotNull(rulesetFilenames);        RuleSetFactory factory = new RuleSetFactory();        if (rulesetFilenames.trim().isEmpty()) {            return;        }        String[] rulesets = rulesetFilenames.split(",");        for (String r : rulesets) {            try (InputStream stream = rl.loadClassPathResourceAsStream(r)) {                assertNotNull(stream);            }            RuleSet ruleset = factory.createRuleSet(r);            assertNotNull(ruleset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.mockito.Matchers.any;import static org.mockito.Matchers.anyList;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.verifyNoMoreInteractions;import static org.mockito.Mockito.when;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import org.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.test.lang.ast.DummyNode;public class RuleTstTest {    private LanguageVersion dummyLanguage = LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion();    private Rule rule = mock(Rule.class);    private RuleTst ruleTester = new RuleTst() {    };    @Test    public void shouldCallStartAndEnd() {        Report report = new Report();        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        ruleTester.runTestFromString("the code", rule, report, dummyLanguage, false);        verify(rule).start(any(RuleContext.class));        verify(rule).end(any(RuleContext.class));        verify(rule, times(2)).getLanguage();        verify(rule, times(2)).isRuleChain();        verify(rule).getMinimumLanguageVersion();        verify(rule).getMaximumLanguageVersion();        verify(rule).apply(anyList(), any(RuleContext.class));        verify(rule, times(4)).getName();        verify(rule).getPropertiesByPropertyDescriptor();        verifyNoMoreInteractions(rule);    }    @Test    public void shouldAssertLinenumbersSorted() {        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        Mockito.doAnswer(new Answer<Void>() {            private RuleViolation createViolation(RuleContext context, int beginLine, String message) {                DummyNode node = new DummyNode(1);                node.testingOnlySetBeginLine(beginLine);                node.testingOnlySetBeginColumn(1);                ParametricRuleViolation<Node> violation = new ParametricRuleViolation<Node>(rule, context, node, message);                return violation;            }            @Override            public Void answer(InvocationOnMock invocation) throws Throwable {                RuleContext context = invocation.getArgumentAt(1, RuleContext.class);                // the violations are reported out of order                context.getReport().addRuleViolation(createViolation(context, 15, "first reported violation"));                context.getReport().addRuleViolation(createViolation(context, 5, "second reported violation"));                return null;            }        }).when(rule).apply(Mockito.anyList(), Mockito.any(RuleContext.class));        TestDescriptor testDescriptor = new TestDescriptor("the code", "sample test", 2, rule, dummyLanguage);        testDescriptor.setReinitializeRule(false);        testDescriptor.setExpectedLineNumbers(Arrays.asList(5, 15));        try {            ruleTester.runTest(testDescriptor);            // there should be no assertion failures            // expected line numbers and actual line numbers match        } catch (AssertionError assertionError) {            Assert.fail(assertionError.toString());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.util.Arrays;import java.util.Collection;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;@RunWith(Parameterized.class)public class KotlinTokenizerTest extends AbstractTokenizerTest {    private final String filename;    private final int nExpectedTokens;    public KotlinTokenizerTest(String filename, int nExpectedTokens) {        this.filename = filename;        this.nExpectedTokens = nExpectedTokens;    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(                new Object[] { "comment.kt", 5 },                new Object[] { "increment.kt", 185 },                new Object[] { "imports.kt", 1 }        );    }    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new KotlinTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), this.filename));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(KotlinTokenizer.class.getResourceAsStream(this.filename));    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = nExpectedTokens;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import java.util.List;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.rule.AbstractJUnitRule;public class TestClassWithoutTestCasesRule extends AbstractJUnitRule {    @Override    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {        if (node.isAbstract() || node.isInterface() || node.isNested()) {            return data;        }        List<ASTMethodDeclaration> m = node.findDescendantsOfType(ASTMethodDeclaration.class);        boolean testsFound = false;        if (m != null) {            for (ASTMethodDeclaration md : m) {                if (isJUnitMethod(md, data)) {                    testsFound = true;                    break;                }            }        }        if (!testsFound) {            addViolation(data, node);        }        return data;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.coverage;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.fail;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.charset.StandardCharsets;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardErrorStreamLog;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import net.sourceforge.pmd.PMD;public class PMDCoverageTest {    @Rule    public StandardOutputStreamLog output = new StandardOutputStreamLog();    @Rule    public StandardErrorStreamLog errorStream = new StandardErrorStreamLog();    /**     * Test some of the PMD command line options     */    @Test    public void testPmdOptions() {        runPmd("-d src/main/java/net/sourceforge/pmd/lang/java/rule/design -f text -R rulesets/internal/all-java.xml -language java -stress -benchmark");    }    /**     * Run the PMD command line tool, i.e. call PMD.main().     *      * @param commandLine     */    private void runPmd(String commandLine) {        String[] args;        args = commandLine.split("\\s");        File f = null;        try {            f = File.createTempFile("pmd", ".txt");            int n = args.length;            String[] a = new String[n + 2 + 2];            System.arraycopy(args, 0, a, 0, n);            a[n] = "-reportfile";            a[n + 1] = f.getAbsolutePath();            a[n + 2] = "-threads";            a[n + 3] = String.valueOf(Runtime.getRuntime().availableProcessors());            args = a;            PMD.run(args);            assertEquals("Nothing should be output to stdout", 0, output.getLog().length());            assertEquals("No exceptions expected", 0, StringUtils.countMatches(errorStream.getLog(), "Exception applying rule"));            assertFalse("Wrong configuration? Ruleset not found", errorStream.getLog().contains("Ruleset not found"));            assertEquals("No usage of deprecated XPath attributes expected", 0, StringUtils.countMatches(errorStream.getLog(), "Use of deprecated attribute"));            String report = FileUtils.readFileToString(f, StandardCharsets.UTF_8);            assertEquals("No processing errors expected", 0, StringUtils.countMatches(report, "Error while processing"));            // we might have explicit examples of parsing errors, so these are maybe false positives            assertEquals("No parsing error expected", 0, StringUtils.countMatches(report, "Error while parsing"));        } catch (IOException ioe) {            fail("Problem creating temporary file: " + ioe.getLocalizedMessage());        } finally {            if (f != null) {                f.delete();            }        }    }    /**     * Name of the configuration file used by testResourceFileCommands().     */    private static final String PMD_CONFIG_FILE = "pmd_tests.conf";    /**     * Run PMD using the command lines found in PMD_CONFIG_FILE.     */    @Test    public void testResourceFileCommands() {        InputStream is = getClass().getResourceAsStream(PMD_CONFIG_FILE);        if (is != null) {            try {                BufferedReader r = new BufferedReader(new InputStreamReader(is));                String l;                while ((l = r.readLine()) != null) {                    l = l.trim();                    if (l.length() == 0 || l.charAt(0) == '#') {                        continue;                    }                    runPmd(l);                }                r.close();            } catch (IOException ioe) {                fail("Problem reading config file: " + ioe.getLocalizedMessage());            }        } else {            fail("Missing config file: " + PMD_CONFIG_FILE);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics.impl;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.java.metrics.MetricsHook;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clément Fournier */public class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/java/metrics_test.xml";    @Override    protected Rule reinitializeRule(Rule rule) {        MetricsHook.reset();        return rule;    }    @Override    public void setUp() {        addRule(RULESET, "CycloTest");        addRule(RULESET, "NcssTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "LocTest");        addRule(RULESET, "NPathTest");        addRule(RULESET, "NopaTest");        addRule(RULESET, "NoamTest");        addRule(RULESET, "WocTest");        addRule(RULESET, "TccTest");        addRule(RULESET, "AtfdTest");        addRule(RULESET, "CfoTest");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics.xpath;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.StringReader;import java.util.Iterator;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.xpath.MetricFunction;import net.sourceforge.pmd.lang.rule.XPathRule;/** * @author Clément Fournier * @since 6.0.0 */public class XPathMetricFunctionTest {    private static final String VIOLATION_MESSAGE = "violation";    @org.junit.Rule    public ExpectedException expected = ExpectedException.none();    private Rule makeXpathRuleFromXPath(String xpath) {        XPathRule rule = new XPathRule();        rule.setXPath(xpath);        rule.setMessage(VIOLATION_MESSAGE);        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        return rule;    }    private Iterator<RuleViolation> getViolations(Rule rule, String code) throws PMDException {        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFile(new File("n/a"));        ctx.setIgnoreExceptions(false); // for test, we want immediate exceptions thrown and not collect them        RuleSet rules = new RuleSetFactory().createSingleRuleRuleSet(rule);        p.getSourceCodeProcessor().processSourceCode(new StringReader(code), new RuleSets(rules), ctx);        return report.iterator();    }    @Test    public void testWellFormedClassMetricRule() throws PMDException {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[metric('NCSS') > 0]");        final String code = "class Foo { Foo() {} void bar() {}}";        Iterator<RuleViolation> violations = getViolations(rule, code);        assertTrue(violations.hasNext());    }    @Test    public void testWellFormedOperationMetricRule() throws PMDException {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[metric('CYCLO') > 1]");        final String code = "class Goo { Goo() {if(true){}} }";        Iterator<RuleViolation> violations = getViolations(rule, code);        assertTrue(violations.hasNext());    }    @Test    public void testBadCase() throws PMDException {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[metric('cYclo') > 1]");        final String code = "class Hoo { Hoo() {if(true){}} }";        Iterator<RuleViolation> violations = getViolations(rule, code);        assertTrue(violations.hasNext());    }    @Test    public void testNonexistentMetric() throws Exception {        testWithExpectedException("//ConstructorDeclaration[metric('FOOBAR') > 1]",                                  "class Joo { Joo() {if(true){}} }",                                  IllegalArgumentException.class,                                  MetricFunction.badOperationMetricKeyMessage());    }    @Test    public void testWrongNodeTypeGeneric() throws Exception {        testWithExpectedException("//IfStatement[metric('NCSS') > 1]",                                  "class Koo { Koo() {if(true){}} }",                                  IllegalStateException.class,                                  MetricFunction.genericBadNodeMessage());    }    @Test    public void testWrongMetricKeyForTypeDeclaration() throws Exception {        testWithExpectedException("//EnumDeclaration[metric('CYCLO') > 1]",                                  "enum Loo { FOO; }",                                  IllegalArgumentException.class,                                  MetricFunction.badClassMetricKeyMessage());    }    @Test    public void testWrongMetricKeyForOperationDeclaration() throws Exception {        testWithExpectedException("//MethodDeclaration[metric('WMC') > 1]",                                  "class Moo { void foo() {if(true){}} }",                                  IllegalArgumentException.class,                                  MetricFunction.badOperationMetricKeyMessage());    }    private void testWithExpectedException(String xpath, String code,                                           Class<? extends Exception> expectedThrowable,                                           String expectedMessage) throws Exception {        Rule rule = makeXpathRuleFromXPath(xpath);        expected.expect(expectedThrowable);        expected.expectMessage(expectedMessage);        try {            getViolations(rule, code);        } catch (PMDException pmdE) {            throw (Exception) pmdE.getCause();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.metrics.api.JavaClassMetricKey;import net.sourceforge.pmd.lang.java.metrics.api.JavaOperationMetricKey;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricKeyUtil;import net.sourceforge.pmd.lang.metrics.MetricOption;import net.sourceforge.pmd.lang.metrics.MetricOptions;import net.sourceforge.pmd.lang.metrics.ParameterizedMetricKey;/** * @author Clément Fournier */public class ParameterizedMetricKeyTest {    private static final MetricOptions DUMMY_VERSION_1 = MetricOptions.ofOptions(Options.DUMMY1, Options.DUMMY2);    private static final MetricOptions DUMMY_VERSION_2 = MetricOptions.ofOptions(Options.DUMMY2);    @Test    public void testIdentity() {        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            assertEquals(key1, key2);            assertTrue(key1 == key2);        }        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            assertEquals(key1, key2);            assertTrue(key1 == key2);        }    }    @Test    public void testVersioning() {        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_2);            assertNotEquals(key1, key2);            assertFalse(key1 == key2);        }        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_2);            assertNotEquals(key1, key2);            assertFalse(key1 == key2);        }    }    @Test    public void testToString() {        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);            assertTrue(key1.toString().contains(key1.key.name()));            assertTrue(key1.toString().contains(key1.options.toString()));        }    }    @Test    public void testAdHocMetricKey() {        MetricKey<ASTAnyTypeDeclaration> adHocKey = MetricKeyUtil.of("metric", null);        ParameterizedMetricKey key1 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        ParameterizedMetricKey key2 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        assertNotNull(key1);        assertNotNull(key2);        assertTrue(key1 == key2);        assertEquals(key1, key2);        assertTrue(key1.toString().contains(key1.key.name()));        assertTrue(key1.toString().contains(key1.options.toString()));    }    private enum Options implements MetricOption {        DUMMY1,        DUMMY2;        @Override        public String valueName() {            return null;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.junit.Test;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorReducedAdapter;import net.sourceforge.pmd.lang.java.ast.MethodLikeNode;import net.sourceforge.pmd.lang.java.metrics.testdata.MetricsVisitorTestData;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricKeyUtil;import net.sourceforge.pmd.lang.metrics.MetricMemoizer;import net.sourceforge.pmd.lang.metrics.MetricOptions;/** * @author Clément Fournier */public class ProjectMemoizerTest {    private MetricKey<ASTAnyTypeDeclaration> classMetricKey = MetricKeyUtil.of(null, new RandomClassMetric());    private MetricKey<MethodLikeNode> opMetricKey = MetricKeyUtil.of(null, new RandomOperationMetric());    @Test    public void memoizationTest() {        ASTCompilationUnit acu = ParserTstUtil.parseJavaDefaultVersion(MetricsVisitorTestData.class);        List<Integer> expected = visitWith(acu, true);        List<Integer> real = visitWith(acu, false);        assertEquals(expected, real);    }    @Test    public void forceMemoizationTest() {        ASTCompilationUnit acu = ParserTstUtil.parseJavaDefaultVersion(MetricsVisitorTestData.class);        List<Integer> reference = visitWith(acu, true);        List<Integer> real = visitWith(acu, true);        assertEquals(reference.size(), real.size());        // we force recomputation so each result should be different        for (int i = 0; i < reference.size(); i++) {            assertNotEquals(reference.get(i), real.get(i));        }    }    private List<Integer> visitWith(ASTCompilationUnit acu, final boolean force) {        final JavaProjectMemoizer toplevel = JavaMetrics.getFacade().getLanguageSpecificProjectMemoizer();        final List<Integer> result = new ArrayList<>();        acu.jjtAccept(new JavaParserVisitorReducedAdapter() {            @Override            public Object visit(ASTMethodOrConstructorDeclaration node, Object data) {                MetricMemoizer<MethodLikeNode> op = toplevel.getOperationMemoizer(node.getQualifiedName());                result.add((int) JavaMetricsComputer.getInstance().computeForOperation(opMetricKey, node, force,                                                                                  MetricOptions.emptyOptions(), op));                return super.visit(node, data);            }            @Override            public Object visit(ASTAnyTypeDeclaration node, Object data) {                MetricMemoizer<ASTAnyTypeDeclaration> clazz = toplevel.getClassMemoizer(node.getQualifiedName());                result.add((int) JavaMetricsComputer.getInstance().computeForType(classMetricKey, node, force,                                                                             MetricOptions.emptyOptions(), clazz));                return super.visit(node, data);            }        }, null);        return result;    }    private class RandomOperationMetric extends AbstractJavaOperationMetric {        private Random random = new Random();        @Override        public double computeFor(MethodLikeNode node, MetricOptions options) {            return random.nextInt();        }    }    private class RandomClassMetric extends AbstractJavaClassMetric {        private Random random = new Random();        @Override        public double computeFor(ASTAnyTypeDeclaration node, MetricOptions options) {            return random.nextInt();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getOrderedNodes;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.metrics.SigMask;/** * @author Clément Fournier */public class SigMaskTest {    private static final String TEST_FIELDS = "class Bzaz{"        + "public String x;"        + "private int y;"        + "protected String z;"        + "int s;"        + "public final int t;"        + "private final int a;"        + "protected final double u;"        + "final long v;"        + "static int aa;"        + "static final int ab;"        + "private static int ac;"        + "protected static final int ad;"        + "public static int ag;"        + "}";    private static final String TEST_OPERATIONS = "abstract class Bzaz{ "        + "int x;"        + "int y;"        + "int z;"        // constructors        + "public Bzaz() {}"        + "private Bzaz(int x){}"        + "protected Bzaz(int x, String y){}"        // static        + "public static void main(String[] args){}"        + "protected static void makeFoo(){}"        + "private static void makeBar(){}"        // getters and setters        + "public int getX(){return 2;}"        + "int getY(){return 0;}"        + "protected void setY(int y){}"        + "private void setX(int x){}"        // methods        + "public void foo(){} "        + "void bar(){} "        + "protected void foo(int x){} "        + "private void rand(){}"        // abstract        + "protected abstract int getZ();"        + "abstract int abs2();"        + "public static abstract String abstr();"        + "abstract void setZ(int x);"        + "}";    /**     * Ensure any non-abstract method is covered by a newly created mask.     */    @Test    public void testEmptyOperationMask() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        SigMask<JavaOperationSignature> mask = new JavaOperationSigMask();        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isAbstract()) {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }    /**     * Ensure any field is covered by a newly created mask.     */    @Test    public void testEmptyFieldMask() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        SigMask<JavaFieldSignature> mask = new JavaFieldSigMask();        for (ASTFieldDeclaration node : nodes) {            assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));        }    }    @Test    public void testFinalFields() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.forbidFinal();        for (ASTFieldDeclaration node : nodes) {            if (node.isFinal()) {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testStaticFields() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.forbidStatic();        for (ASTFieldDeclaration node : nodes) {            if (node.isStatic()) {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testFieldvisibility() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.restrictVisibilitiesTo(Visibility.PUBLIC);        for (ASTFieldDeclaration node : nodes) {            if (node.isPublic()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PRIVATE);        for (ASTFieldDeclaration node : nodes) {            if (node.isPrivate()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PACKAGE);        for (ASTFieldDeclaration node : nodes) {            if (node.isPackagePrivate()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PROTECTED);        for (ASTFieldDeclaration node : nodes) {            if (node.isProtected()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testOperationVisibility() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class,                                                                        TEST_OPERATIONS);        JavaOperationSigMask mask = new JavaOperationSigMask();        mask.coverAbstract();        mask.restrictVisibilitiesTo(Visibility.PUBLIC);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPublic()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PRIVATE);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPrivate()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PACKAGE);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPackagePrivate()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PROTECTED);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isProtected()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }    @Test    public void testOperationRoles() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class,                                                                        TEST_OPERATIONS);        JavaOperationSigMask mask = new JavaOperationSigMask();        mask.restrictRolesTo(Role.STATIC);        mask.coverAbstract();        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isStatic()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.CONSTRUCTOR);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTConstructorDeclaration) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.GETTER_OR_SETTER);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTMethodDeclaration                && ((ASTMethodDeclaration) node).getName().matches("(get|set).*")) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.METHOD);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTMethodDeclaration                && !node.isStatic()                && !((ASTMethodDeclaration) node).getName().matches("(get|set).*")) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertTrue;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.MethodLikeNode;import net.sourceforge.pmd.lang.java.metrics.api.JavaClassMetricKey;import net.sourceforge.pmd.lang.java.metrics.api.JavaOperationMetricKey;import net.sourceforge.pmd.lang.metrics.LanguageMetricsProvider;import net.sourceforge.pmd.lang.metrics.MetricKey;/** * @author Clément Fournier */public class JavaMetricsProviderTest {    @Test    public void testComputeAllMetrics() {        LanguageMetricsProvider<?, ?> provider = ParserTstUtil.getLanguageVersionHandler("1.8").getLanguageMetricsProvider();        ASTCompilationUnit acu = ParserTstUtil.parseAndTypeResolveJava("1.8",                                                                       "class Foo { void bar() { System.out.println(1); } }");        ASTAnyTypeDeclaration type = acu.getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> results = provider.computeAllMetricsFor(type);        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            assertTrue(results.containsKey(key));        }        MethodLikeNode op = acu.getFirstDescendantOfType(MethodLikeNode.class);        Map<MetricKey<?>, Double> opResults = provider.computeAllMetricsFor(op);        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            assertTrue(opResults.containsKey(key));        }    }    @Test    public void testThereIsNoMemoisation() {        LanguageMetricsProvider<?, ?> provider = ParserTstUtil.getLanguageVersionHandler("1.8").getLanguageMetricsProvider();        ASTAnyTypeDeclaration tdecl1 = ParserTstUtil.parseAndTypeResolveJava("1.8",                                                                             "class Foo { void bar() { System.out.println(1); } }").getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> reference = provider.computeAllMetricsFor(tdecl1);        ASTAnyTypeDeclaration tdecl2 = ParserTstUtil.parseAndTypeResolveJava("1.8",                                                                             // same name, different characteristics                                                                             "class Foo { void bar(){} \npublic void hey() { System.out.println(1); } }").getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> secondTest = provider.computeAllMetricsFor(tdecl2);        assertNotEquals(reference, secondTest);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getOrderedNodes;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava17;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;import net.sourceforge.pmd.lang.java.metrics.testdata.GetterDetection;import net.sourceforge.pmd.lang.java.metrics.testdata.SetterDetection;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;/** * Test class for {@link JavaSignature} and its subclasses. * * @author Clément Fournier */public class SignatureTest {    // common to operation and field signatures    @Test    public void visibilityTest() {        final String TEST = "class Bzaz{ "            + "public int bar;"            + "String k;"            + "protected double d;"            + "private int i;"            + "protected int x;"            + "public Bzaz(){} "            + "void bar(){} "            + "protected void foo(int x){}"            + "private Bzaz(int y){}"            + "}";        List<ASTMethodOrConstructorDeclaration> operationDeclarations = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<ASTFieldDeclaration> fieldDeclarations = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : operationDeclarations) {            sigs.add(JavaOperationSignature.buildFor(node));        }        // operations        assertEquals(Visibility.PUBLIC, sigs.get(0).visibility);        assertEquals(Visibility.PACKAGE, sigs.get(1).visibility);        assertEquals(Visibility.PROTECTED, sigs.get(2).visibility);        assertEquals(Visibility.PRIVATE, sigs.get(3).visibility);        sigs.clear();        for (ASTFieldDeclaration node : fieldDeclarations) {            sigs.add(JavaFieldSignature.buildFor(node));        }        // fields        assertEquals(Visibility.PUBLIC, sigs.get(0).visibility);        assertEquals(Visibility.PACKAGE, sigs.get(1).visibility);        assertEquals(Visibility.PROTECTED, sigs.get(2).visibility);        assertEquals(Visibility.PRIVATE, sigs.get(3).visibility);    }    @Test    public void operationRoleTest() {        final String TEST = "class Bzaz{ int x; "            + "public static void foo(){} "            + "Bzaz(){} "            + "int getX(){return x;}"            + " void setX(int a){x=a;}"            + " public void doSomething(){}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<JavaOperationSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : nodes) {            sigs.add(JavaOperationSignature.buildFor(node));        }        assertEquals(Role.STATIC, sigs.get(0).role);        assertEquals(Role.CONSTRUCTOR, sigs.get(1).role);        assertEquals(Role.GETTER_OR_SETTER, sigs.get(2).role);        assertEquals(Role.GETTER_OR_SETTER, sigs.get(3).role);        assertEquals(Role.METHOD, sigs.get(4).role);    }    @Test    public void testGetterDetection() {        ASTCompilationUnit compilationUnit = parseJava17(GetterDetection.class);        compilationUnit.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertEquals(Role.GETTER_OR_SETTER, Role.get(node));                return data;            }        }, null);    }    @Test    public void testSetterDetection() {        ASTCompilationUnit compilationUnit = parseJava17(SetterDetection.class);        compilationUnit.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertEquals(Role.GETTER_OR_SETTER, Role.get(node));                return data;            }        }, null);    }    @Test    public void isAbstractOperationTest() {        final String TEST = "abstract class Bzaz{ int x; "            + "public static abstract void foo();"            + "protected abstract int bar(int x);"            + "int getX(){return x;}"            + "void setX(int a){x=a;}"            + "public void doSomething(){}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<JavaOperationSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : nodes) {            sigs.add(JavaOperationSignature.buildFor(node));        }        assertTrue(sigs.get(0).isAbstract);        assertTrue(sigs.get(1).isAbstract);        assertFalse(sigs.get(2).isAbstract);        assertFalse(sigs.get(3).isAbstract);        assertFalse(sigs.get(4).isAbstract);    }    @Test    public void isFinalFieldTest() {        final String TEST = "class Bzaz{"            + "public String x;"            + "private int y;"            + "private final int a;"            + "protected final double u;"            + "final long v;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaFieldSignature> sigs = new ArrayList<>();        for (ASTFieldDeclaration node : nodes) {            sigs.add(JavaFieldSignature.buildFor(node));        }        assertFalse(sigs.get(0).isFinal);        assertFalse(sigs.get(1).isFinal);        assertTrue(sigs.get(2).isFinal);        assertTrue(sigs.get(3).isFinal);        assertTrue(sigs.get(4).isFinal);    }    @Test    public void isStaticFieldTest() {        final String TEST = "class Bzaz{"            + "public final String x;"            + "private int y;"            + "private static int a;"            + "protected static final double u;"            + "static long v;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaFieldSignature> sigs = new ArrayList<>();        for (ASTFieldDeclaration node : nodes) {            sigs.add(JavaFieldSignature.buildFor(node));        }        assertFalse(sigs.get(0).isStatic);        assertFalse(sigs.get(1).isStatic);        assertTrue(sigs.get(2).isStatic);        assertTrue(sigs.get(3).isStatic);        assertTrue(sigs.get(4).isStatic);    }    // Ensure only one instance of a signature is created.    @Test    public void operationPoolTest() {        final String TEST = "class Bzaz{ "            + "public static void foo(){} "            + "public static void az(){} "            + "public static int getX(){return x;}}";        final String TEST2 = "class Bzaz{ "            + "void foo(){} "            + "void az(){} "            + "int rand(){return x;}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<ASTMethodOrConstructorDeclaration> nodes2 = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST2);        List<JavaOperationSignature> sigs = new ArrayList<>();        List<JavaOperationSignature> sigs2 = new ArrayList<>();        for (int i = 0; i < sigs.size(); i++) {            sigs.add(JavaOperationSignature.buildFor(nodes.get(i)));            sigs2.add(JavaOperationSignature.buildFor(nodes2.get(i)));        }        for (int i = 0; i < sigs.size() - 1; i++) {            assertTrue(sigs.get(i) == sigs.get(i + 1));            assertTrue(sigs2.get(i) == sigs2.get(i + 1));        }    }    // Ensure only one instance of a signature is created.    @Test    public void fieldPoolTest() {        final String TEST = "class Bzaz {"            + "public int bar;"            + "public String k;"            + "public double d;"            + "}";        final String TEST2 = "class Foo {"            + "private final int i;"            + "private final int x;"            + "private final String k;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<ASTFieldDeclaration> nodes2 = getOrderedNodes(ASTFieldDeclaration.class, TEST2);        List<JavaFieldSignature> sigs = new ArrayList<>();        List<JavaFieldSignature> sigs2 = new ArrayList<>();        for (int i = 0; i < sigs.size(); i++) {            sigs.add(JavaFieldSignature.buildFor(nodes.get(i)));            sigs2.add(JavaFieldSignature.buildFor(nodes2.get(i)));        }        for (int i = 0; i < sigs.size() - 1; i++) {            assertTrue(sigs.get(i) == sigs.get(i + 1));            assertTrue(sigs2.get(i) == sigs2.get(i + 1));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.dfa.Structure;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;public class StructureTest {    @Test    public void testAddResultsinDFANodeContainingAddedNode() {        Structure s = new Structure(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler().getDataFlowHandler());        Node n = new ASTMethodDeclaration(1);        assertEquals(n, s.createNewNode(n).getNode());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(StructureTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.LinkedList;import org.junit.Test;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.dfa.NodeType;import net.sourceforge.pmd.lang.dfa.StartOrEndDataFlowNode;public class DataFlowNodeTest {    @Test    public void testAddPathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        parent.addPathToChild(child);        assertEquals(parent.getChildren().size(), 1);        assertTrue(child.getParents().contains(parent));        assertTrue(parent.getChildren().contains(child));    }    @Test    public void testRemovePathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        parent.addPathToChild(child);        assertTrue(parent.removePathToChild(child));        assertFalse(child.getParents().contains(parent));        assertFalse(parent.getChildren().contains(child));    }    @Test    public void testRemovePathWithNonChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode child = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        assertFalse(parent.removePathToChild(child));    }    @Test    public void testReverseParentPathsTo() {        DataFlowNode parent1 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        DataFlowNode parent2 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 12, false);        DataFlowNode child1 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 13, false);        DataFlowNode child2 = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 13, false);        parent1.addPathToChild(child1);        parent2.addPathToChild(child1);        assertTrue(parent1.getChildren().contains(child1));        child1.reverseParentPathsTo(child2);        assertTrue(parent1.getChildren().contains(child2));        assertFalse(parent1.getChildren().contains(child1));        assertTrue(parent2.getChildren().contains(child2));        assertFalse(parent2.getChildren().contains(child1));        assertEquals(0, child1.getParents().size());        assertEquals(2, child2.getParents().size());    }    @Test    public void testSetType() {        DataFlowNode node = new StartOrEndDataFlowNode(new LinkedList<DataFlowNode>(), 10, false);        node.setType(NodeType.BREAK_STATEMENT);        assertTrue(node.isType(NodeType.BREAK_STATEMENT));        assertFalse(node.isType(NodeType.CASE_LAST_STATEMENT));    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(DataFlowNodeTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.lang.dfa.VariableAccess;public class VariableAccessTest {    @Test    public void testGetVariableName() {        VariableAccess va = new VariableAccess(VariableAccess.DEFINITION, "foo.bar");        assertEquals("foo", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, ".foobar");        assertEquals("", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar.");        assertEquals("foobar", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar");        assertEquals("foobar", va.getVariableName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getOrderedNodes;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.dfa.pathfinder.CurrentPath;import net.sourceforge.pmd.lang.dfa.pathfinder.DAAPathFinder;import net.sourceforge.pmd.lang.dfa.pathfinder.Executable;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;public class DAAPathFinderTest implements Executable {    @Test    public void testTwoUpdateDefs() {        ASTMethodDeclarator meth = getOrderedNodes(ASTMethodDeclarator.class, TWO_UPDATE_DEFS).get(0);        DAAPathFinder a = new DAAPathFinder(meth.getDataFlowNode().getFlow().get(0), this);        // a.run();    }    public void execute(CurrentPath path) {    }    private static final String TWO_UPDATE_DEFS = "class Foo {" + PMD.EOL + " void bar(int x) {" + PMD.EOL            + "  for (int i=0; i<10; i++, j--) {}" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getOrderedNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.dfa.NodeType;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;public class StatementAndBraceFinderTest {    @Test    public void testStatementExpressionParentChildLinks() {        ASTStatementExpression se = getOrderedNodes(ASTStatementExpression.class, TEST1).get(0);        ASTMethodDeclaration seParent = (ASTMethodDeclaration) se.getDataFlowNode().getParents().get(0).getNode();        assertEquals(se, seParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(seParent, se.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testVariableDeclaratorParentChildLinks() {        ASTVariableDeclarator vd = getOrderedNodes(ASTVariableDeclarator.class, TEST2).get(0);        ASTMethodDeclaration vdParent = (ASTMethodDeclaration) vd.getDataFlowNode().getParents().get(0).getNode();        assertEquals(vd, vdParent.getDataFlowNode().getChildren().get(0).getNode());        assertEquals(vdParent, vd.getDataFlowNode().getParents().get(0).getNode());    }    @Test    public void testIfStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST3).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.IF_EXPR));        assertTrue(dfn.isType(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE));    }    @Test    public void testWhileStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST4).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.WHILE_EXPR));        assertTrue(dfn.isType(NodeType.WHILE_LAST_STATEMENT));    }    @Test    public void testForStmtHasCorrectTypes() {        ASTExpression exp = getOrderedNodes(ASTExpression.class, TEST5).get(0);        DataFlowNode dfn = exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.FOR_INIT));        dfn = exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.FOR_EXPR));        dfn = exp.getDataFlowNode().getFlow().get(4);        assertTrue(dfn.isType(NodeType.FOR_UPDATE));        assertTrue(dfn.isType(NodeType.FOR_BEFORE_FIRST_STATEMENT));        assertTrue(dfn.isType(NodeType.FOR_END));    }    @Test(expected = RuntimeException.class)    public void testOnlyWorksForMethodsAndConstructors() {        StatementAndBraceFinder sbf = new StatementAndBraceFinder(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler().getDataFlowHandler());        sbf.buildDataFlowFor(new ASTMethodDeclaration(1));        sbf.buildDataFlowFor(new ASTConstructorDeclaration(1));        sbf.buildDataFlowFor(new ASTCompilationUnit(1));    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST2 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x;" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST3 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  if (x) {}" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  while (x) {}" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST5 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL            + "  for (int i=0; i<10; i++) {}" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static net.sourceforge.pmd.lang.java.ParserTstUtil.buildDFA;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;public class GeneralFiddlingTest {    /**     * Unit test for https://sourceforge.net/p/pmd/bugs/1325/     */    @Test    public void innerClassShouldWork() {        ASTCompilationUnit acu = buildDFA(                "class Foo {" + "    void bar() {" + "        class X {}" + "        int i;" + "    }" + "}");        assertNotNull(acu);    }    @Test    public void test1() {        ASTCompilationUnit acu = buildDFA(TEST1);        ASTMethodDeclarator meth = acu.findDescendantsOfType(ASTMethodDeclarator.class).get(0);        DataFlowNode n = meth.getDataFlowNode();        List<DataFlowNode> f = n.getFlow();        assertEquals(6, f.size());        assertEquals("Undefinition(x)", String.valueOf(f.get(0).getVariableAccess().get(0)));        assertEquals(0, f.get(1).getVariableAccess().size());        assertEquals("Definition(x)", String.valueOf(f.get(2).getVariableAccess().get(0)));        assertEquals("Reference(x)", String.valueOf(f.get(3).getVariableAccess().get(0)));        assertEquals("Definition(x)", String.valueOf(f.get(4).getVariableAccess().get(0)));        assertEquals("Undefinition(x)", String.valueOf(f.get(5).getVariableAccess().get(0)));        // for (DataFlowNode dfan : f) {        // System.out.println("Flow starting on line " + dfan.getLine());        // List<VariableAccess> va = dfan.getVariableAccess();        // for (VariableAccess o : va) {        // System.out.println(" variable: " + o);        // }        // }    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x = 2;" + PMD.EOL            + "  foo(x);" + PMD.EOL + "  x = 3;" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.dfa;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getOrderedNodes;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.dfa.DataFlowNode;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;/* * Created on 18.08.2004 */public class AcceptanceTest {    @Test    public void testbook() {        getOrderedNodes(ASTMethodDeclarator.class, FOO);    }    private static final String FOO = "class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    @Test    public void testLabelledBreakLockup() {        getOrderedNodes(ASTMethodDeclarator.class, LABELLED_BREAK_LOCKUP);    }    private static final String LABELLED_BREAK_LOCKUP = "class Foo {" + PMD.EOL + " void bar(int x) {" + PMD.EOL            + "  here: if (x>2) {" + PMD.EOL + "   break here;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + "}";    private boolean check(int[][] array, List<ASTMethodDeclarator> methodNodes) {        for (int i = 0; i < methodNodes.size(); i++) {            ASTMethodDeclarator decl = methodNodes.get(i);            DataFlowNode inode = decl.getDataFlowNode();            for (int j = 0; j < inode.getChildren().size(); j++) {                DataFlowNode child = inode.getChildren().get(j);                if (array[i][j] != child.getIndex() - 1) {                    return false;                }            }        }        return true;    }    @Test    public void test1() {        assertTrue(check(TEST1_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST1)));    }    @Test    public void test2() {        assertTrue(check(TEST2_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST2)));    }    @Test    public void test3() {        assertTrue(check(TEST3_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST3)));    }    @Test    public void test4() {        assertTrue(check(TEST4_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST4)));    }    @Test    public void test6() {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST6)));    }    @Test    public void test7() {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST7)));    }    @Test    public void test8() {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST8)));    }    @Test    public void test9() {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST9)));    }    @Test    public void test10() {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST10)));    }    @Test    public void test11() {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST11)));    }    @Test    public void test12() {        assertTrue(check(TEST12_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST12)));    }    @Test    public void test13() {        assertTrue(check(TEST13_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST13)));    }    @Test    public void test14() {        assertTrue(check(TEST14_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST14)));    }    @Test    public void test15() {        assertTrue(check(TEST15_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST15)));    }    @Test    public void test16() {        assertTrue(check(TEST16_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST16)));    }    @Test    public void test17() {        assertTrue(check(TEST17_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST17)));    }    @Test    public void test18() {        assertTrue(check(TEST18_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST18)));    }    @Test    public void test19() {        assertTrue(check(TEST19_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST19)));    }    @Test    public void test20() {        assertTrue(check(TEST20_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST20)));    }    @Test    public void test21() {        assertTrue(check(TEST21_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST21)));    }    @Test    public void test22() {        assertTrue(check(TEST22_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST22)));    }    @Test    public void test23() {        assertTrue(check(TEST23_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST23)));    }    @Test    public void test24() {        assertTrue(check(TEST24_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST24)));    }    @Test    public void test25() {        assertTrue(check(TEST25_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST25)));    }    @Test    public void test26() {        assertTrue(check(TEST26_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST26)));    }    @Test    public void test27() {        assertTrue(check(TEST27_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST27)));    }    @Test    public void test28() {        assertTrue(check(TEST28_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST28)));    }    @Test    public void test29() {        assertTrue(check(TEST29_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST29)));    }    @Test    public void test30() {        assertTrue(check(TEST30_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST30)));    }    // first dimension: the index of a node    // second dimension: the indices of the children    private static final int[][] TEST1_NODES = { { 1, }, { 2, }, { 3, }, { 4, 6, }, { 5, }, { 6, }, {}, };    private static final String TEST1 = "class Foo {" + PMD.EOL + " void test_1() {" + PMD.EOL + "  int x = 0;"            + PMD.EOL + "  if (x == 0) {" + PMD.EOL + "   x++;" + PMD.EOL + "   x = 0;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + " }";    private static final int[][] TEST2_NODES = { { 1, }, { 2, }, { 3, }, { 5, 7, }, { 3, }, { 6, }, { 4, }, {}, };    private static final String TEST2 = "class Foo {" + PMD.EOL + " public void test_2() {" + PMD.EOL            + "  for (int i = 0; i < 1; i++) {" + PMD.EOL + "   i++;" + PMD.EOL + "   i = 8;" + PMD.EOL + "  }"            + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST3_NODES = { { 1, }, { 2, }, { 3, }, { 4, 5, }, { 3, }, {}, };    private static final String TEST3 = "public class Foo {" + PMD.EOL + " public void test_3() {" + PMD.EOL            + "  for (int i = 0; i < 1; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST4_NODES = { { 1, }, { 2, }, { 3, }, {}, };    private static final String TEST4 = "public class Foo {" + PMD.EOL + " public void test_4() {" + PMD.EOL            + "  for (; ;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST5_NODES = { { 1, }, { 2, }, { 3, }, { 4, }, {}, };    private static final String TEST6 = "public class Foo {" + PMD.EOL + " public void test_6() {" + PMD.EOL            + "  for (int i = 0; ;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final String TEST7 = "public class Foo {" + PMD.EOL + " public void test_7() {" + PMD.EOL            + "  for (int i = 0; i < 0;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST8_NODES = { { 1, }, { 2, }, { 3, }, { 4, 5, }, { 3, }, {}, };    public static final String TEST8 = "public class Foo {" + PMD.EOL + " public void test_8() {" + PMD.EOL            + "  for (int i = 0; ; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    public static final String TEST9 = "public class Foo {" + PMD.EOL + " public void test_9() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  for (; i < 0;) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    public static final String TEST10 = "public class Foo {" + PMD.EOL + " public void test_10() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  for (; i < 0; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    public static final String TEST11 = "public class Foo {" + PMD.EOL + " public void test_11() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  for (; ; i++) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST12_NODES = { { 1, }, { 2, }, { 3, }, { 4, 5, }, { 3, }, {}, };    public static final String TEST12 = "public class Foo {" + PMD.EOL + " public void test_12() {" + PMD.EOL            + "  for (; ;) {" + PMD.EOL + "   int i = 0;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST13_NODES = { { 1, }, { 2, }, { 3, }, { 5, 9, }, { 3, }, { 6, }, { 7, 8, }, { 8, }, { 4, },        {}, };    public static final String TEST13 = "public class Foo {" + PMD.EOL + " public void test_13() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   i = 9;" + PMD.EOL + "   if (i < 8) {" + PMD.EOL            + "    i = 7;" + PMD.EOL + "   }" + PMD.EOL + "   i = 6;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + " }";    private static final int[][] TEST14_NODES = { { 1 }, { 2 }, { 3 }, { 5, 8 }, { 3 }, { 6 }, { 7, 4 }, { 4 }, {} };    public static final String TEST14 = "public class Foo {" + PMD.EOL + " public void test_14() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   i = 9;" + PMD.EOL + "   if (i < 8) {" + PMD.EOL            + "    i = 7;" + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST15_NODES = { { 1 }, { 2 }, { 3 }, { 5, 7 }, { 3 }, { 6, 4 }, { 4 }, {} };    public static final String TEST15 = "public class Foo {" + PMD.EOL + " public void test_15() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   if (i < 8) {" + PMD.EOL + "    i = 7;" + PMD.EOL            + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST16_NODES = { { 1 }, { 2 }, { 3 }, { 5, 8 }, { 3 }, { 6, 7 }, { 4 }, { 4 }, {} };    public static final String TEST16 = "public class Foo {" + PMD.EOL + " public void test_16() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   if (i < 8) {" + PMD.EOL + "    i = 7;" + PMD.EOL            + "   } else {" + PMD.EOL + "    i = 6;" + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + " }";    private static final int[][] TEST17_NODES = { { 1 }, { 2 }, { 3 }, { 5, 10 }, { 3 }, { 6, 7 }, { 4 }, { 8, 9 },        { 4 }, { 4 }, {}, };    public static final String TEST17 = "public class Foo {" + PMD.EOL + " public void test_17() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   if (i < 6) {" + PMD.EOL + "    i = 7;" + PMD.EOL            + "   } else if (i > 8) {" + PMD.EOL + "    i = 9;" + PMD.EOL + "   } else {" + PMD.EOL + "    i = 10;"            + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST18_NODES = { { 1 }, { 2 }, { 3 }, { 5, 9 }, { 3 }, { 6 }, { 8, 4 }, { 6 }, { 7 },        {}, };    public static final String TEST18 = "public class Foo {" + PMD.EOL + " public void test_18() {" + PMD.EOL            + "  for (int i = 0; i < 0; i++) {" + PMD.EOL + "   for (int j = 0; j < 0; j++) {" + PMD.EOL + "    j++;"            + PMD.EOL + "   }" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST19_NODES = { { 1 }, { 2 }, { 3 }, { 4, 5 }, { 10 }, { 6, 7 }, { 10 }, { 8, 9 },        { 10 }, { 10 }, {}, };    public static final String TEST19 = "public class Foo {" + PMD.EOL + " public void test_19() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   i = 2;" + PMD.EOL + "  } else if (i == 3) {"            + PMD.EOL + "   i = 4;" + PMD.EOL + "  } else if (i == 5) {" + PMD.EOL + "   i = 6;" + PMD.EOL            + "  } else {" + PMD.EOL + "   i = 7;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST20_NODES = { { 1 }, { 2 }, { 3 }, { 4, 6 }, { 5, 7 }, { 7 }, { 7 }, {} };    public static final String TEST20 = "public class Foo {" + PMD.EOL + " public void test_20() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   if (i == 2) {" + PMD.EOL + "    i = 3;"            + PMD.EOL + "   }" + PMD.EOL + "  } else {" + PMD.EOL + "   i = 7;" + PMD.EOL + "  }" + PMD.EOL + " }"            + PMD.EOL + " }";    private static final int[][] TEST21_NODES = { { 1 }, { 2 }, { 3 }, { 4, 9 }, { 5 }, { 7, 8 }, { 5 }, { 6 }, { 11 },        { 10, 11 }, { 11 }, {}, };    public static final String TEST21 = "public class Foo {" + PMD.EOL + " public void test_21() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   for (i = 3; i < 4; i++) {" + PMD.EOL            + "    i = 5;" + PMD.EOL + "   }" + PMD.EOL + "   i++;" + PMD.EOL + "  } else if (i < 6) {" + PMD.EOL            + "   i = 7;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST22_NODES = { { 1 }, { 2 }, { 3 }, { 4, 8 }, { 5 }, { 7, 9 }, { 5 }, { 6 }, { 9 },        {}, };    public static final String TEST22 = "public class Foo {" + PMD.EOL + " public void test_22() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   for (i = 3; i < 4; i++) {" + PMD.EOL            + "    i = 5;" + PMD.EOL + "   }" + PMD.EOL + "  } else {" + PMD.EOL + "   i = 7;" + PMD.EOL + "  }"            + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST23_NODES = { { 1 }, { 2 }, { 3 }, { 4, 8 }, { 5 }, { 7, 10 }, { 5 }, { 6 },        { 9, 10 }, { 10 }, {}, };    public static final String TEST23 = "public class Foo {" + PMD.EOL + " public void test_23() {" + PMD.EOL            + "  int i = 0;" + PMD.EOL + "  if (i == 1) {" + PMD.EOL + "   for (i = 3; i < 4; i++) {" + PMD.EOL            + "    i = 5;" + PMD.EOL + "   }" + PMD.EOL + "  } else if (i < 6) {" + PMD.EOL + "   i = 7;" + PMD.EOL            + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST24_NODES = { { 1 }, { 2 }, { 3 }, { 4, 9 }, { 5 }, { 7, 11 }, { 5 }, { 8, 6 },        { 6 }, { 10, 11 }, { 11 }, {}, };    public static final String TEST24 = "public class Foo {" + PMD.EOL + " public void test_24() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  if (x > 2) {" + PMD.EOL + "   for (int i = 0; i < 1; i++) {" + PMD.EOL            + "    if (x > 3) {" + PMD.EOL + "     x++;" + PMD.EOL + "    }" + PMD.EOL + "   }" + PMD.EOL            + "  } else if (x > 4) {" + PMD.EOL + "   x++;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST25_NODES = { { 1 }, { 2 }, { 3 }, { 4, 5 }, { 5 }, {} };    public static final String TEST25 = "public class Foo {" + PMD.EOL + " public void test_25() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  switch (x) {" + PMD.EOL + "   default:" + PMD.EOL + "    x = 9;" + PMD.EOL            + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST26_NODES = { { 1 }, { 2 }, { 3 }, { 4 }, { 5, 6 }, { 6 }, { 7 }, { 8, 3 }, { 9 },        {}, };    public static final String TEST26 = "public class Foo {" + PMD.EOL + " public void test_26() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  do {" + PMD.EOL + "   if (x > 0) {" + PMD.EOL + "    x++;" + PMD.EOL            + "   }" + PMD.EOL + "   x++;" + PMD.EOL + "  } while (x < 9);" + PMD.EOL + "  x++;" + PMD.EOL + " }"            + PMD.EOL + " }";    private static final int[][] TEST27_NODES = { { 1 }, { 2 }, { 3 }, { 5, 9 }, { 3 }, { 6 }, { 7 }, { 8 }, { 6, 4 }, {}, };    public static final String TEST27 = "public class Foo {" + PMD.EOL + " public void test_27() {" + PMD.EOL            + "  for (int i = 0; i < 36; i++) {" + PMD.EOL + "   int x = 0;" + PMD.EOL + "   do {" + PMD.EOL            + "    x++;" + PMD.EOL + "   } while (x < 9);" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST28_NODES = { { 1 }, { 2 }, { 3 }, { 5, 14 }, { 3 }, { 6 }, { 7 }, { 8, 12 }, { 9 },        { 10, 12 }, { 11 }, { 12 }, { 13 }, { 6, 4 }, {}, };    public static final String TEST28 = "public class Foo {" + PMD.EOL + " private void test_28() {" + PMD.EOL            + "  for (int i = 0; i < 36; i++) {" + PMD.EOL + "   int x = 0;" + PMD.EOL + "   do {" + PMD.EOL            + "    if (x > 0) {" + PMD.EOL + "     x++;" + PMD.EOL + "     switch (i) {" + PMD.EOL + "      case 0:"            + PMD.EOL + "       x = 0;" + PMD.EOL + "       break;" + PMD.EOL + "     }" + PMD.EOL + "    }" + PMD.EOL            + "    x++;" + PMD.EOL + "   } while (x < 9);" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + " }";    private static final int[][] TEST29_NODES = { { 1 }, { 2 }, { 3, 4, 5 }, { 6 }, { 6 }, { 6 }, {}, };    public static final String TEST29 = "public class Foo {" + PMD.EOL + " private void test_29() {" + PMD.EOL            + "  switch(x) {" + PMD.EOL + "   case 1:" + PMD.EOL + "    break; " + PMD.EOL + "   default: " + PMD.EOL            + "    break;" + PMD.EOL + "   case 2:" + PMD.EOL + "    break;" + PMD.EOL + "  }" + PMD.EOL + " }"            + PMD.EOL + "}";    private static final int[][] TEST30_NODES = { { 1 }, { 2 }, { 3 }, { 4, 7 }, { 5, 6 }, { 4 }, { 3 }, {} };    public static final String TEST30 = "public class Foo {" + PMD.EOL + " private void test_30() {" + PMD.EOL            + "  int x = 0;" + PMD.EOL + "  while (true) {" + PMD.EOL + "   while (x>0) {" + PMD.EOL + "     x++;"            + PMD.EOL + "   }" + PMD.EOL + "   continue;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.multifile;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;import net.sourceforge.pmd.lang.java.ast.JavaQualifiedName;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.multifile.testdata.MultifileVisitorTestData2;import net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;import net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;/** * Tests of the multifile visitor. * * @author Clément Fournier */public class JavaMultifileVisitorTest {    @Test    public void testPackageStatsNotNull() {        assertNotNull(PackageStats.INSTANCE);    }    @Before    public void resetMultifile() {        PackageStats.INSTANCE.reset();    }    @Test    public void testOperationsAreThere() {        ASTCompilationUnit acu = parseAndVisitForClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaOperationSigMask opMask = new JavaOperationSigMask();        // We could parse qnames from string but probably simpler to do that        acu.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertTrue(toplevel.hasMatchingSig(node.getQualifiedName(), opMask));                return data;            }        }, null);    }    @Test    public void testFieldsAreThere() {        parseAndVisitForClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaFieldSigMask fieldSigMask = new JavaFieldSigMask();        JavaTypeQualifiedName clazz = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        String[] fieldNames = {"x", "y", "z", "t"};        Visibility[] visibilities = {Visibility.PUBLIC, Visibility.PRIVATE, Visibility.PROTECTED, Visibility.PACKAGE};        for (int i = 0; i < fieldNames.length; i++) {            fieldSigMask.restrictVisibilitiesTo(visibilities[i]);            assertTrue(toplevel.hasMatchingSig(clazz, fieldNames[i], fieldSigMask));        }    }    @Test    public void testBothClassesOperationsAreThere() {        parseAndVisitForClass(MultifileVisitorTestData2.class);        parseAndVisitForClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaOperationSigMask operationSigMask = new JavaOperationSigMask();        JavaQualifiedName clazz = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        JavaQualifiedName clazz2 = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        String[] opNames = {"getX()", "getY()", "setX(String)", "setY(String)",                            "mymethod1()", "mymethod2()", "mystatic1()",                            "mystatic2(String)", "mystatic2(String, String)", };        Role[] roles = {Role.GETTER_OR_SETTER, Role.GETTER_OR_SETTER, Role.GETTER_OR_SETTER, Role.GETTER_OR_SETTER,                        Role.METHOD, Role.METHOD, Role.STATIC, Role.STATIC, Role.STATIC, };        for (int i = 0; i < opNames.length; i++) {            operationSigMask.restrictRolesTo(roles[i]);            JavaOperationQualifiedName name1 = (JavaOperationQualifiedName) QualifiedNameFactory.ofString(clazz.toString() + "#" + opNames[i]);            JavaOperationQualifiedName name2 = (JavaOperationQualifiedName) QualifiedNameFactory.ofString(clazz2.toString() + "#" + opNames[i]);            assertTrue(toplevel.hasMatchingSig(name1, operationSigMask));            assertTrue(toplevel.hasMatchingSig(name2, operationSigMask));        }    }    @Test    public void testBothClassesFieldsAreThere() {        parseAndVisitForClass(MultifileVisitorTestData2.class);        parseAndVisitForClass(MultifileVisitorTestData2.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final JavaFieldSigMask fieldSigMask = new JavaFieldSigMask();        JavaTypeQualifiedName clazz = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        JavaTypeQualifiedName clazz2 = QualifiedNameFactory.ofClass(MultifileVisitorTestData2.class);        String[] fieldNames = {"x", "y", "z", "t"};        Visibility[] visibilities = {Visibility.PUBLIC, Visibility.PRIVATE, Visibility.PROTECTED, Visibility.PACKAGE};        for (int i = 0; i < fieldNames.length; i++) {            fieldSigMask.restrictVisibilitiesTo(visibilities[i]);            assertTrue(toplevel.hasMatchingSig(clazz, fieldNames[i], fieldSigMask));            assertTrue(toplevel.hasMatchingSig(clazz2, fieldNames[i], fieldSigMask));        }    }    static ASTCompilationUnit parseAndVisitForClass(Class<?> clazz) {        ASTCompilationUnit acu = ParserTstUtil.parseJavaDefaultVersion(clazz);        LanguageVersionHandler handler = ParserTstUtil.getDefaultLanguageVersionHandler();        handler.getQualifiedNameResolutionFacade(JavaMultifileVisitorTest.class.getClassLoader()).start(acu);        handler.getTypeResolutionFacade(JavaMultifileVisitorTest.class.getClassLoader()).start(acu);        handler.getMultifileFacade().start(acu);        return acu;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.multifile;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getOrderedNodes;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;import net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;/** * Tests functionality of PackageStats * * @author Clément Fournier */public class PackageStatsTest {    private PackageStats pack;    @Before    public void setUp() {        pack = PackageStats.INSTANCE;        pack.reset();    }    @Test    public void testAddClass() {        JavaTypeQualifiedName qname = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("org.foo.Boo");        assertNull(pack.getClassStats(qname, false));        assertNotNull(pack.getClassStats(qname, true));        // now it's added, this shouldn't return null        assertNotNull(pack.getClassStats(qname, false));    }    @Test    public void testAddOperation() {        final String TEST = "package org.foo; class Boo{ "            + "public void foo(){}}";        ASTMethodOrConstructorDeclaration node = getOrderedNodes(ASTMethodDeclaration.class, TEST).get(0);        JavaOperationQualifiedName qname = node.getQualifiedName();        JavaOperationSignature signature = JavaOperationSignature.buildFor(node);        assertFalse(pack.hasMatchingSig(qname, new JavaOperationSigMask()));        ClassStats clazz = pack.getClassStats(qname.getClassName(), true);        clazz.addOperation("foo()", signature);        assertTrue(pack.hasMatchingSig(qname, new JavaOperationSigMask()));    }    @Test    public void testAddField() {        final String TEST = "package org.foo; class Boo{ "            + "public String bar;}";        ASTFieldDeclaration node = getOrderedNodes(ASTFieldDeclaration.class, TEST).get(0);        JavaTypeQualifiedName qname = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("org.foo.Boo");        String fieldName = "bar";        JavaFieldSignature signature = JavaFieldSignature.buildFor(node);        assertFalse(pack.hasMatchingSig(qname, fieldName, new JavaFieldSigMask()));        ClassStats clazz = pack.getClassStats(qname, true);        clazz.addField(fieldName, signature);        assertTrue(pack.hasMatchingSig(qname, fieldName, new JavaFieldSigMask()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.multifile;import static org.junit.Assert.assertEquals;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.multifile.testdata.SignatureCountTestData;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;/** * @author Clément Fournier */public class ClassStatsTest {    @Before    public void resetMultifile() {        PackageStats.INSTANCE.reset();    }    @Test    @Ignore("Exception in typeresolution visit")    public void testCountOpSigs() {        JavaMultifileVisitorTest.parseAndVisitForClass(SignatureCountTestData.class);        final ProjectMirror toplevel = PackageStats.INSTANCE;        final ClassMirror classMirror = toplevel.getClassMirror(QualifiedNameFactory.ofClass(SignatureCountTestData.class));        final FluentOperationSigMask opSigMask = new FluentOperationSigMask();        opSigMask.mask.coverAbstract();        opSigMask.restrictRolesTo(Role.STATIC);        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(2, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));        assertEquals(2, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        opSigMask.restrictRolesTo(Role.METHOD).coverAllVisibilities();        assertEquals(6, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(1, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        assertEquals(1, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PROTECTED)));        assertEquals(2, classMirror.countMatchingOpSigs(opSigMask.forbidAbstract()));        opSigMask.restrictRolesTo(Role.GETTER_OR_SETTER).coverAllVisibilities();        assertEquals(8, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PACKAGE)));        assertEquals(4, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        opSigMask.restrictRolesTo(Role.CONSTRUCTOR).coverAllVisibilities();        assertEquals(3, classMirror.countMatchingOpSigs(opSigMask.mask));        assertEquals(3, classMirror.countMatchingOpSigs(opSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        FluentFieldSigMask fieldSigMask = new FluentFieldSigMask();        assertEquals(6, classMirror.countMatchingFieldSigs(fieldSigMask.mask));        assertEquals(3, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PUBLIC)));        assertEquals(1, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PROTECTED)));        assertEquals(2, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));        fieldSigMask.mask.forbidFinal();        assertEquals(0, classMirror.countMatchingFieldSigs(fieldSigMask.restrictVisibilitiesTo(Visibility.PRIVATE)));    }    // Containers to clear up tests    private class FluentOperationSigMask {        JavaOperationSigMask mask = new JavaOperationSigMask();        JavaOperationSigMask forbidAbstract() {            mask.coverAbstract(false);            return mask;        }        JavaOperationSigMask restrictVisibilitiesTo(Visibility... visibilities) {            mask.restrictVisibilitiesTo(visibilities);            return mask;        }        JavaOperationSigMask restrictRolesTo(Role... roles) {            mask.restrictRolesTo(roles);            return mask;        }    }    private class FluentFieldSigMask {        JavaFieldSigMask mask = new JavaFieldSigMask();        JavaFieldSigMask restrictVisibilitiesTo(Visibility... visibilities) {            mask.restrictVisibilitiesTo(visibilities);            return mask;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.io.File;import java.util.HashSet;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader;public class TypeSetTest {    private PMDASMClassLoader pmdClassLoader = PMDASMClassLoader.getInstance(TypeSetTest.class.getClassLoader());    @Test    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    @Test    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    @Test    public void testFindClassImplicitImport() throws ClassNotFoundException {        TypeSet t = new TypeSet();        Class<?> clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    @Test    public void testFindClassSamePackage() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd");        Class<?> clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    @Test    public void testFindClassExplicitImport() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class<?> clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    @Test    public void testFindClassImportOnDemand() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class<?> clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    @Test    public void testFindClassPrimitive() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    @Test    public void testFindClassVoid() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    @Test    public void testFindFullyQualified() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    @Test    public void testPrimitiveTypeResolver() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    @Test(expected = ClassNotFoundException.class)    public void testPrimitiveTypeResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        r.resolve(null);    }    @Test    public void testVoidTypeResolver() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    @Test(expected = ClassNotFoundException.class)    public void testVoidTypeResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.VoidResolver();        r.resolve(null);    }    @Test    public void testExplicitImportResolver() throws ClassNotFoundException {        Set<String> imports = new HashSet<>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, imports);        assertEquals(File.class, r.resolve("File"));    }    @Test(expected = ClassNotFoundException.class)    public void testExplicitImportResolverWithNull() throws ClassNotFoundException {        Set<String> imports = new HashSet<>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, imports);        r.resolve(null);    }    @Test(expected = ClassNotFoundException.class)    public void testExplicitImportResolverWithNullAndEmptyImports() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, new HashSet<String>());        r.resolve(null);    }    @Test    public void testImplicitImportResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        assertEquals(String.class, r.resolve("String"));    }    @Test(expected = ClassNotFoundException.class)    public void testImplicitImportResolverPassFail() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        r.resolve("PMD");    }    @Test(expected = ClassNotFoundException.class)    public void testImplicitImportResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        r.resolve(null);    }    @Test    public void testCurrentPackageResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver(pmdClassLoader, "net.sourceforge.pmd");        assertEquals(PMD.class, r.resolve("PMD"));    }    @Test(expected = ClassNotFoundException.class)    public void testCurrentPackageResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver(pmdClassLoader, "net.sourceforge.pmd");        r.resolve(null);    }    @Test    public void testImportOnDemandResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    @Test(expected = ClassNotFoundException.class)    public void testImportOnDemandResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve(null);    }    @Test(expected = ClassNotFoundException.class)    public void importOnDemandResolverFail1() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve("foo");    }    @Test(expected = ClassNotFoundException.class)    public void importOnDemandResolverFail2() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve("String");    }    private TypeSet.Resolver getResolver() {        Set<String> imports = new HashSet<>();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(pmdClassLoader, imports);        return r;    }    @Test(expected = ClassNotFoundException.class)    public void testFullyQualifiedNameResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.FullyQualifiedNameResolver(pmdClassLoader);        r.resolve(null);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.Scope;public class VariableNameDeclarationTest extends STBBaseTst {    @Test    public void testConstructor() {        parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        Scope s = nodes.get(0).getScope();        NameDeclaration decl = s.getDeclarations().keySet().iterator().next();        assertEquals("bar", decl.getImage());        assertEquals(3, decl.getNode().getBeginLine());    }    @Test    public void testExceptionBlkParam() {        ASTCompilationUnit acu = getNodes(ASTCompilationUnit.class, EXCEPTION_PARAMETER).iterator().next();        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(new VariableNameDeclaration(id).isExceptionBlockParameter());    }    @Test    public void testIsArray() {        parseCode(TEST3);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isArray());    }    @Test    public void testPrimitiveType() {        parseCode(TEST1);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isPrimitiveType());    }    @Test    public void testArrayIsReferenceType() {        parseCode(TEST3);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isReferenceType());    }    @Test    public void testPrimitiveTypeImage() {        parseCode(TEST3);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("int", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testRefTypeImage() {        parseCode(TEST4);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("String", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testParamTypeImage() {        parseCode(TEST5);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("String", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordTypeImage() {        parseCode(TEST6);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("java.util.ArrayList", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordWithPrimitiveTypeImage() {        parseCode(TEST7);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("long", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordWithIndirectReference() {        parseCode(TEST8);        Iterator<NameDeclaration> nameDeclarationIterator = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator();        nameDeclarationIterator.next(); // first variable 'bar'        NameDeclaration decl = nameDeclarationIterator.next(); // second variable 'foo'        assertEquals("java.lang.String", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testLamdaParameterTypeImage() {        parseCode(TEST9);        List<ASTVariableDeclaratorId> variableDeclaratorIds = acu.findDescendantsOfType(                ASTVariableDeclaratorId.class,                true        );        List<VariableNameDeclaration> nameDeclarations = new ArrayList<>();        for (ASTVariableDeclaratorId variableDeclaratorId : variableDeclaratorIds) {            nameDeclarations.add(variableDeclaratorId.getNameDeclaration());        }        assertEquals("Map", nameDeclarations.get(0).getTypeImage()); // variable 'bar'        assertEquals(null, nameDeclarations.get(1).getTypeImage()); // variable 'key'        assertEquals(null, nameDeclarations.get(2).getTypeImage()); // variable 'value'        // variable 'foo'        assertEquals("foo", nameDeclarations.get(3).getName());        assertEquals("long", nameDeclarations.get(3).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, nameDeclarations.get(3).getTypeImage());    }    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int bar = 42;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  try {} catch(Exception e) {}" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int[] x;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  String x;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST5 = "public class Foo {" + PMD.EOL + " void foo(String x) {}" + PMD.EOL + "}";    public static final String TEST6 = "import java.util.ArrayList; public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  var bar = new ArrayList<String>(\"param\");" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST7 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  var bar = 42L;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST8 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  var bar = \"test\";" + PMD.EOL + "  var foo = bar;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST9 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Map<String, Object> bar = new HashMap<>();" + PMD.EOL + "  bar.forEach((key, value) -> {" + PMD.EOL            + "   if (value instanceof String) {" + PMD.EOL + "    var foo = 42L;" + PMD.EOL            + "    System.out.println(value);" + PMD.EOL + "   }" + PMD.EOL + "  });" + PMD.EOL + " }" + PMD.EOL + "}";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VariableNameDeclarationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTBlock;import net.sourceforge.pmd.lang.java.ast.ASTIfStatement;public class ScopeCreationVisitorTest extends STBBaseTst {    @Test    public void testScopesAreCreated() {        parseCode(TEST1);        ASTBlock n = acu.getFirstDescendantOfType(ASTIfStatement.class)                .getFirstDescendantOfType(ASTBlock.class);        assertTrue(n.getScope() instanceof LocalScope);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  if (x>2) {}"            + PMD.EOL + " }" + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ScopeCreationVisitorTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.DummyJavaNode;import net.sourceforge.pmd.lang.java.ast.JavaNode;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class ClassScopeTest extends STBBaseTst {    @Test    public void testEnumsClassScope() {        parseCode15(ENUM_SCOPE);    }    @Test    public void testEnumTypeParameter() {        parseCode15(ENUM_TYPE_PARAMETER);    }    @Test    public void testVarArgsEmpty() {        parseCode15("public class Foo {\n" + "  public void bar1(String s, Integer... i) {}\n"                + "  public void bar1() {}\n" + "  public void c() {\n" + "    bar1();\n" + "  }\n" + "}\n");    }    // FIXME - these will break when this goes from Anonymous$1 to Foo$1    @Test    public void testAnonymousInnerClassName() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        s = new ClassScope(classDeclaration);        assertEquals("Anonymous$1", s.getClassName());        s = new ClassScope(classDeclaration);        assertEquals("Anonymous$2", s.getClassName());    }    @Test    public void testContains() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testCantContainsSuperToString() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        JavaNode node = new DummyJavaNode(1);        node.setImage("super.toString");        assertFalse(s.contains(new JavaNameOccurrence(node, node.getImage())));    }    @Test    public void testContainsStaticVariablePrefixedWithClassName() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("X");        s.addDeclaration(new VariableNameDeclaration(node));        JavaNode node2 = new DummyJavaNode(2);        node2.setImage("Foo.X");        assertTrue(s.contains(new JavaNameOccurrence(node2, node2.getImage())));    }    @Test    public void testClassName() {        parseCode(CLASS_NAME);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        assertEquals("Foo", n.getScope().getEnclosingScope(ClassScope.class).getClassName());    }    @Test    public void testMethodDeclarationRecorded() {        parseCode(METHOD_DECLARATIONS_RECORDED);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope s = (ClassScope) n.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        assertEquals(1, m.size());        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("bar", mnd.getImage());        ASTMethodDeclaration node = (ASTMethodDeclaration) mnd.getNode().jjtGetParent();        assertTrue(node.isPrivate());    }    @Test    public void testTwoMethodsSameNameDiffArgs() {        // TODO this won't work with String and java.lang.String        parseCode(METHODS_WITH_DIFF_ARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        assertEquals(2, m.size());        Iterator<NameDeclaration> i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration) i.next();        assertEquals("bar", mnd.getImage());        assertEquals("bar", ((MethodNameDeclaration) i.next()).getImage());    }    @Test    public final void testOneParam() {        parseCode(ONE_PARAM);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String)", mnd.getParameterDisplaySignature());    }    @Test    public final void testTwoParams() {        parseCode(TWO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,int)", mnd.getParameterDisplaySignature());    }    @Test    public final void testNoParams() {        parseCode(NO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("()", mnd.getParameterDisplaySignature());    }    @Test    public final void testOneParamVararg() {        parseCode15(ONE_PARAM_VARARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String...)", mnd.getParameterDisplaySignature());    }    @Test    public final void testTwoParamsVararg() {        parseCode15(TWO_PARAMS_VARARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,String...)", mnd.getParameterDisplaySignature());    }    @Test    public void testNestedClassesOfImportResolution() {        parseCode(NESTED_CLASSES_OF_IMPORT);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(EnumTest.class, c.resolveType("TheInnerClass.EnumTest"));    }    @Test    public void testNestedClassesResolution() {        parseForClass(InnerClass.class);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(InnerClass.class, c.resolveType("InnerClass"));        assertEquals(TheInnerClass.class, c.resolveType("InnerClass.TheInnerClass"));        assertEquals(TheInnerClass.class, c.resolveType("TheInnerClass")); // Within this scope, we can access it directly    }    @Test    public void testImportNestedClassesResolution() {        parseCode(IMPORT_NESTED_CLASSES);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(EnumTest.class, c.resolveType("EnumTest"));    }    @Test    public final void testNestedClassDeclFound() {        parseCode(NESTED_CLASS_FOUND);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope c = (ClassScope) n.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = c.getDeclarations();        ClassNameDeclaration cnd = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals("Buz", cnd.getImage());    }    @Test    public final void testbuz() {        parseCode(METH);        // SymbolTableViewer st = new SymbolTableViewer();        // acu.jjtAccept(st, null);    }    @Test    public void testMethodUsageSeen() {        parseCode(METHOD_USAGE_SEEN);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Iterator<Map.Entry<NameDeclaration, List<NameOccurrence>>> i = m.entrySet().iterator();        MethodNameDeclaration mnd;        Map.Entry<NameDeclaration, List<NameOccurrence>> entry;        do {            entry = i.next();            mnd = (MethodNameDeclaration) entry.getKey();        } while (!mnd.getImage().equals("bar"));        List<NameOccurrence> usages = entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((JavaNameOccurrence) usages.get(0)).getImage());    }    @Test    public void testMethodUsageSeenWithThis() {        parseCode(METHOD_USAGE_SEEN_WITH_THIS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Iterator<Map.Entry<NameDeclaration, List<NameOccurrence>>> i = m.entrySet().iterator();        MethodNameDeclaration mnd;        Map.Entry<NameDeclaration, List<NameOccurrence>> entry;        do {            entry = i.next();            mnd = (MethodNameDeclaration) entry.getKey();        } while (!mnd.getImage().equals("bar"));        List<NameOccurrence> usages = entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((JavaNameOccurrence) usages.get(0)).getImage());    }    @Test    public void testMethodUsageSeen2() {        parseCode(METHOD_USAGE_SEEN2);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        assertEquals(2, m.size());        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            assertEquals("baz", entry.getKey().getImage());            if (entry.getKey().getNode().getBeginLine() == 2) {                // this is the public method declaration - it is not used                // anywhere                assertEquals(0, entry.getValue().size());            } else if (entry.getKey().getNode().getBeginLine() == 5) {                // this is the private (overloaded) method                assertEquals(1, entry.getValue().size());                // it's used once in line 3                assertEquals(3, entry.getValue().get(0).getLocation().getBeginLine());            } else {                fail("unexpected name declaration");            }        }    }    /**     * Test case for bug report #2410201     */    @Test    public void testNestedClassFieldAndParameter() {        parseCode(NESTED_CLASS_FIELD_AND_PARAM);        ASTMethodDeclaration node = acu.getFirstDescendantOfType(ASTMethodDeclaration.class);        Map<VariableNameDeclaration, List<NameOccurrence>> vd = node.getScope().getDeclarations(VariableNameDeclaration.class);        assertEquals(2, vd.size());        int paramCount = 0;        for (Map.Entry<VariableNameDeclaration, List<NameOccurrence>> entry : vd.entrySet()) {            if (entry.getKey().getDeclaratorId().isFormalParameter()) {                assertEquals("field", entry.getKey().getImage());                    List<NameOccurrence> occurrences = entry.getValue();                assertEquals(2, occurrences.size());                NameOccurrence no1 = occurrences.get(0);                assertEquals(8, no1.getLocation().getBeginLine());                NameOccurrence no2 = occurrences.get(1);                assertEquals(9, no2.getLocation().getBeginLine());                paramCount++;            }        }        assertEquals(1, paramCount);    }    @Test    public void testNullType() {        parseCode(TEST_NULL_TYPE);    }    private static final String NESTED_CLASS_FIELD_AND_PARAM = "public class Foo {" + PMD.EOL + " class Test {"            + PMD.EOL + "   public String field;" + PMD.EOL + "   public Test t;" + PMD.EOL + " }" + PMD.EOL            + " public void foo(String field) {" + PMD.EOL + "   Test t = new Test();" + PMD.EOL + "   t.field = field;"            + PMD.EOL + "   t.t.field = field;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN2 = "public class Foo {" + PMD.EOL + " public void baz() {" + PMD.EOL            + "  baz(x, y);" + PMD.EOL + " }" + PMD.EOL + " private void baz(int x, int y) {}" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN = "public class Foo {" + PMD.EOL + " private void bar() {}" + PMD.EOL            + " public void buz() {" + PMD.EOL + "  bar();" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN_WITH_THIS = "public class Foo {" + PMD.EOL + " private void bar() {}"            + PMD.EOL + " public void buz() {" + PMD.EOL + "  this.bar();" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METH = "public class Test {" + PMD.EOL + "  static { " + PMD.EOL + "   int y; "            + PMD.EOL + "  } " + PMD.EOL + "  void bar(int x) {} " + PMD.EOL + "  void baz(int x) {} " + PMD.EOL + "}";    private static final String NESTED_CLASS_FOUND = "public class Test {" + PMD.EOL + "  private class Buz {} "            + PMD.EOL + "}";    private static final String ONE_PARAM = "public class Test {" + PMD.EOL + "  void bar(String x) {" + PMD.EOL + "  }"            + PMD.EOL + "}";    private static final String TWO_PARAMS = "public class Test {" + PMD.EOL + "  void bar(String x, int y) {" + PMD.EOL            + "  }" + PMD.EOL + "}";    private static final String NO_PARAMS = "public class Test {" + PMD.EOL + "  void bar() {" + PMD.EOL + "  }"            + PMD.EOL + "}";    private static final String ONE_PARAM_VARARG = "public class Test {" + PMD.EOL + "  void bar(String... s) {"            + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String TWO_PARAMS_VARARG = "public class Test {" + PMD.EOL            + "  void bar(String s1, String... s2) {" + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String CLASS_NAME = "public class Foo {}";    private static final String METHOD_DECLARATIONS_RECORDED = "public class Foo {" + PMD.EOL + " private void bar() {}"            + PMD.EOL + "}";    private static final String METHODS_WITH_DIFF_ARG = "public class Foo {" + PMD.EOL            + " private void bar(String x) {}" + PMD.EOL + " private void bar() {}" + PMD.EOL + "}";    private static final String ENUM_SCOPE = "public enum Foo {" + PMD.EOL + " HEAP(\"foo\");" + PMD.EOL            + " private final String fuz;" + PMD.EOL + " public String getFuz() {" + PMD.EOL + "  return fuz;" + PMD.EOL            + " }" + PMD.EOL + "}";    public static final String TEST_NULL_TYPE = "public abstract class NullTypeTest {" + PMD.EOL            + "   protected Comparator<TreeNode> nodesComparator = (o1, o2) -> StringHelper.saveCompare(getFilterableString(o1), getFilterableString(o2));"            + PMD.EOL + "   public abstract String getFilterableString(TreeNode node);" + PMD.EOL + "}";    private static final String ENUM_TYPE_PARAMETER = "public enum Foo {" + PMD.EOL            + "   BAR(isCustomer(BazEnum.FOO_BAR));" + PMD.EOL + "   Foo(boolean isCustomer) { }" + PMD.EOL            + "   private static boolean isCustomer(BazEnum baz) {" + PMD.EOL + "      return false;" + PMD.EOL + "   }"            + PMD.EOL + "}";    private static final String IMPORT_NESTED_CLASSES =            "import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;" + PMD.EOL            + "public class Foo {" + PMD.EOL            + " public EnumTest e;" + PMD.EOL            + "}" + PMD.EOL;    private static final String NESTED_CLASSES_OF_IMPORT =            "import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;" + PMD.EOL            + "public class Foo {" + PMD.EOL            + " public TheInnerClass.EnumTest e;" + PMD.EOL            + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.List;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;public class ScopeAndDeclarationFinderTest extends STBBaseTst {    /**     * Unit test for https://sourceforge.net/p/pmd/bugs/1317/     */    @Test    public void testJava8LambdaScoping() {        String source = "public class MultipleLambdas {\n"                + "  Observer a = (o, arg) -> System.out.println(\"a:\" + arg);\n"                + "  Observer b = (o, arg) -> System.out.println(\"b:\" + arg);\n" + "}";        parseCode(source, LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8"));        List<ASTLambdaExpression> lambdas = acu.findDescendantsOfType(ASTLambdaExpression.class);        Assert.assertEquals(2, lambdas.size());        LocalScope scope1 = (LocalScope) lambdas.get(0).getScope();        LocalScope scope2 = (LocalScope) lambdas.get(1).getScope();        Assert.assertNotSame(scope1, scope2);        for (ASTLambdaExpression l : lambdas) {            LocalScope scope = (LocalScope) l.getScope();            Assert.assertEquals(2, scope.getVariableDeclarations().size());            Assert.assertTrue(scope.contains(new JavaNameOccurrence(null, "o")));            Assert.assertTrue(scope.contains(new JavaNameOccurrence(null, "arg")));            Set<NameDeclaration> declarations = scope.findVariableHere(new JavaNameOccurrence(null, "arg"));            Assert.assertEquals(1, declarations.size());            NameDeclaration decl = declarations.iterator().next();            Assert.assertEquals(1, scope.getVariableDeclarations().get(decl).size());        }    }    @Test    public void testAnnonInnerClassScoping() {        String source = "public class Foo {" + PMD.EOL                + "  public static final Creator<Foo> CREATOR = new Creator<Foo>() {" + PMD.EOL                + "    @Override public Foo createFromParcel(Parcel source) {" + PMD.EOL                + "      return new Foo();" + PMD.EOL                + "    }" + PMD.EOL                + "    @Override public Foo[] newArray(int size) {" + PMD.EOL                + "      return new Foo[size];" + PMD.EOL                + "    }" + PMD.EOL                + "  };" + PMD.EOL                + "}" + PMD.EOL;        parseCode(source, LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.6"));        ClassScope cs = (ClassScope) acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getScope();        Assert.assertEquals(1, cs.getClassDeclarations().size()); // There should be 1 anonymous class        List<ASTMethodDeclarator> methods = acu.getFirstDescendantOfType(ASTClassOrInterfaceBody.class) // outer class                .getFirstDescendantOfType(ASTClassOrInterfaceBody.class) // inner class                .findDescendantsOfType(ASTMethodDeclarator.class, true); // inner class methods        Assert.assertEquals(2, methods.size());        ClassScope scope1 = methods.get(0).getScope().getEnclosingScope(ClassScope.class);        ClassScope scope2 = methods.get(1).getScope().getEnclosingScope(ClassScope.class);        Assert.assertSame(scope1, scope2);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class LocalScopeTest extends STBBaseTst {    @Test    public void testNameWithThisOrSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        name.jjtAddChild(prefix, 1);        JavaNameOccurrence occ = new JavaNameOccurrence(name, "foo");        scope.addNameOccurrence(occ);        assertFalse(scope.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testNameWithSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        name.jjtAddChild(prefix, 1);        JavaNameOccurrence occ = new JavaNameOccurrence(name, "foo");        scope.addNameOccurrence(occ);        assertFalse(scope.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testLocalVariableDeclarationFound() {        parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        assertEquals(1, vars.size());        NameDeclaration decl = vars.keySet().iterator().next();        assertEquals("b", decl.getImage());    }    @Test    public void testQualifiedNameOccurrence() {        parseCode(TEST2);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        NameDeclaration decl = vars.keySet().iterator().next();        JavaNameOccurrence occ = (JavaNameOccurrence) vars.get(decl).get(0);        assertEquals("b", occ.getImage());    }    @Test    public void testPostfixUsageIsRecorded() {        parseCode(TEST3);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        NameDeclaration decl = vars.keySet().iterator().next();        List<NameOccurrence> usages = vars.get(decl);        JavaNameOccurrence occ = (JavaNameOccurrence) usages.get(0);        assertEquals(4, occ.getLocation().getBeginLine());    }    @Test    public void testLocalVariableTypesAreRecorded() {        parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        Map<NameDeclaration, List<NameOccurrence>> vars = nodes.get(0).getScope().getDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("Bar", decl.getTypeImage());    }    @Test    public void testMethodArgumentTypesAreRecorded() {        parseCode(TEST5);        List<ASTFormalParameter> nodes = acu.findDescendantsOfType(ASTFormalParameter.class);        Map<NameDeclaration, List<NameOccurrence>> vars = nodes.get(0).getScope().getDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    @Test    public void testgetEnclosingMethodScope() {        parseCode(TEST4);        ASTLocalVariableDeclaration node = acu.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        LocalScope scope = (LocalScope) node.getScope();        MethodScope ms = scope.getEnclosingScope(MethodScope.class);        assertEquals(2, ms.getDeclarations().size());    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Bar b = new Bar();" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Bar b = new Bar();" + PMD.EOL + "  b.buz = 2;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x = 2;"            + PMD.EOL + "  x++;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo(String x, String z) { { int x; } }"            + PMD.EOL + "}";    public static final String TEST5 = "public class Foo {" + PMD.EOL + " void foo(String x);" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.swing.JComponent;import javax.swing.JTextField;import org.junit.Assert;import org.junit.Test;/** * Unit test for {@link SimpleTypedNameDeclaration} */public class SimpleTypedNameDeclarationTest {    /**     * Tests the equal method.     */    @Test    public void testEquals() {        Assert.assertEquals(byClass(SimpleTypedNameDeclaration.class), byClass(SimpleTypedNameDeclaration.class));        Assert.assertEquals(byClass(List.class), byClass(ArrayList.class));        Assert.assertEquals(byClass(ArrayList.class), byClass(List.class));        Assert.assertEquals(byName("String"), byName("String"));        Assert.assertEquals(byClass(String.class), byName("String"));        Assert.assertEquals(byClass(JComponent.class), byClass(JTextField.class));        Assert.assertFalse(byClass(Map.class).equals(byClass(List.class)));        Assert.assertFalse(byName("A").equals(byName("B")));        Assert.assertFalse(byClass(String.class).equals(byName("A")));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "double"));        Assert.assertEquals(by(Double.class, "Double"), by(null, "double"));        Assert.assertEquals(by(Character.class, "Character"), by(null, "char"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "float"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "int"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "long"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Long.TYPE, "long"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Long.class, "Long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(null, "int"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Integer.TYPE, "int"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Float.TYPE, "float"), by(null, "long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Long.TYPE, "long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Long.class, "Long"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(null, "char"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(Character.TYPE, "char"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(Character.class, "Character"));        Assert.assertEquals(by(Long.TYPE, "long"), by(null, "int"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Integer.TYPE, "int"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Long.TYPE, "long"), by(null, "char"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Character.TYPE, "char"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Character.class, "Character"));        // should always equal to Object        Assert.assertEquals(by(Object.class, "Object"), by(null, "Something"));        Assert.assertEquals(withNext(byName("Foo.I"), "Foo.B"), byName("Foo.I"));        Assert.assertEquals(byName("Foo.I"), withNext(byName("Foo.I"), "Foo.B"));    }    private static SimpleTypedNameDeclaration byClass(Class<?> c) {        return new SimpleTypedNameDeclaration(c.getSimpleName(), c);    }    private static SimpleTypedNameDeclaration byName(String n) {        return new SimpleTypedNameDeclaration(n, null);    }    private static SimpleTypedNameDeclaration by(Class<?> c, String n) {        return new SimpleTypedNameDeclaration(n, c);    }    private static SimpleTypedNameDeclaration withNext(SimpleTypedNameDeclaration next, String n) {        SimpleTypedNameDeclaration t = new SimpleTypedNameDeclaration(n, null);        t.addNext(next);        return t;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class MethodScopeTest extends STBBaseTst {    @Test    public void testMethodParameterOccurrenceRecorded() {        parseCode(TEST1);        Map<NameDeclaration, List<NameOccurrence>> m = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0)                .getScope().getDeclarations();        NameDeclaration vnd = m.keySet().iterator().next();        assertEquals("bar", vnd.getImage());        List<NameOccurrence> occs = m.get(vnd);        NameOccurrence occ = occs.get(0);        assertEquals(3, occ.getLocation().getBeginLine());    }    @Test    public void testMethodName() {        parseCode(TEST1);        ASTMethodDeclaration meth = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0);        MethodScope ms = (MethodScope) meth.getScope();        assertEquals(ms.getName(), "foo");    }    @Test    public void testGenerics() {        parseCode(TEST_GENERICS);    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo(int bar) {" + PMD.EOL + "  bar = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST_GENERICS = "public class Tree {" + PMD.EOL + "  private List<Object> subForest;"            + PMD.EOL + "  public <B> Tree<B> fmap(final F<B> f) { return Tree.<B>foo(); }" + PMD.EOL            + "  public List<Object> subForest() { return null; }" + PMD.EOL + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;public class NameOccurrencesTest extends STBBaseTst {    @Test    public void testSuper() {        parseCode(TEST1);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("super", occs.getNames().get(0).getImage());    }    @Test    public void testThis() {        parseCode(TEST2);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("this", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    @Test    public void testNameLinkage() {        parseCode(TEST2);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        JavaNameOccurrence thisNameOccurrence = occs.getNames().get(0);        assertEquals(thisNameOccurrence.getNameForWhichThisIsAQualifier(), occs.getNames().get(1));    }    @Test    public void testSimpleVariableOccurrence() {        parseCode(TEST3);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("x", occs.getNames().get(0).getImage());        assertFalse(occs.getNames().get(0).isThisOrSuper());        assertFalse(occs.getNames().get(0).isMethodOrConstructorInvocation());        assertTrue(occs.getNames().get(0).isOnLeftHandSide());    }    @Test    public void testQualifiedOccurrence() {        parseCode(TEST4);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("b", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    @Test    public void testIsSelfAssignment() {        parseCode(TEST5);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());        parseCode(TEST6);        nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        occs = new NameFinder(nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());    }    @Test    public void testEnumStaticUsage() {        parseCode(TEST_ENUM);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(4));        List<JavaNameOccurrence> names = occs.getNames();        assertEquals(3, names.size());        assertEquals("myEnum", names.get(0).getImage());        assertFalse(names.get(0).isMethodOrConstructorInvocation());        assertEquals("desc", names.get(1).getImage());        assertFalse(names.get(1).isMethodOrConstructorInvocation());        assertEquals("equals", names.get(2).getImage());        assertTrue(names.get(2).isMethodOrConstructorInvocation());    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  super.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  this.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  b.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST5 = "public class Foo{" + PMD.EOL + "    private int counter;" + PMD.EOL            + "    private Foo(){" + PMD.EOL + "        counter = 0;" + PMD.EOL + "    }" + PMD.EOL            + "    private int foo(){" + PMD.EOL + "        if (++counter < 3) {" + PMD.EOL + "            return 0;"            + PMD.EOL + "        }" + PMD.EOL + "        return 1;" + PMD.EOL + "    }" + PMD.EOL + "}";    public static final String TEST6 = "public class Foo{" + PMD.EOL + "    private int counter;" + PMD.EOL            + "    private Foo(){" + PMD.EOL + "        counter = 0;" + PMD.EOL + "    }" + PMD.EOL            + "    private int foo(){" + PMD.EOL + "        if (++this.counter < 3) {" + PMD.EOL            + "            return 0;" + PMD.EOL + "        }" + PMD.EOL + "        return 1;" + PMD.EOL + "    }"            + PMD.EOL + "}";    public static final String TEST_ENUM = "public enum MyEnum {" + PMD.EOL + "  A(\"a\");" + PMD.EOL            + "  private final String desc;" + PMD.EOL + "  private MyEnum(String desc) {" + PMD.EOL            + "    this.desc = desc;" + PMD.EOL + "  }" + PMD.EOL + "  public static MyEnum byDesc(String desc) {"            + PMD.EOL + "    for (MyEnum myEnum : value()) {" + PMD.EOL            + "      if (myEnum.desc.equals(desc)) return myEnum;" + PMD.EOL + "    }" + PMD.EOL + "    return null;"            + PMD.EOL + "  }" + PMD.EOL + " }";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(NameOccurrencesTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;import net.sourceforge.pmd.lang.symboltable.Scope;public class GlobalScopeTest extends STBBaseTst {    @Test    public void testClassDeclAppears() {        parseCode(TEST1);        ASTCompilationUnit decl = acu;        Scope scope = decl.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = scope.getDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    @Test    public void testEnums() {        parseCode15(TEST2);    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "public enum Bar {" + PMD.EOL + "  FOO1 {          " + PMD.EOL            + "    private static final String FIELD_NAME = \"\";" + PMD.EOL + "  }," + PMD.EOL + "  FOO2 {          "            + PMD.EOL + "    private static final String FIELD_NAME = \"\";" + PMD.EOL + "  }" + PMD.EOL + "}"            + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class MethodNameDeclarationTest extends STBBaseTst {    @Test    public void testEquality() {        // Verify proper number of nodes are not equal        parseCode15(SIMILAR);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Set<NameDeclaration> methodNameDeclarations = m.keySet();        assertEquals("Wrong number of method name declarations", methodNameDeclarations.size(), 3);    }    private static final String SIMILAR = "public class Foo {" + PMD.EOL + " public void bar() {" + PMD.EOL            + "  bar(x, y);" + PMD.EOL + " }" + PMD.EOL + " private void bar(int x, int y) {}" + PMD.EOL            + " private void bar(int x, int... y) {}" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class SourceFileScopeTest extends STBBaseTst {    @Test    public void testClassDeclAppears() {        parseCode(TEST1);        Map<NameDeclaration, List<NameOccurrence>> m = acu.getScope().getDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    @Test    public void testPackageIsEmptyString() {        parseCode(TEST1);        ASTCompilationUnit decl = acu;        assertEquals(decl.getScope().getEnclosingScope(SourceFileScope.class).getPackageName(), "");    }    @Test    public void testPackageNameFound() {        parseCode(TEST2);        ASTCompilationUnit decl = acu;        assertEquals(decl.getScope().getEnclosingScope(SourceFileScope.class).getPackageName(), "foo.bar");    }    @Test    public void testNestedClasses() {        parseCode(TEST3);        Map<NameDeclaration, List<NameOccurrence>> m = acu.getScope().getDeclarations();        Iterator<NameDeclaration> iterator = m.keySet().iterator();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) iterator.next();        assertEquals(classNameDeclaration.getImage(), "Foo");        assertFalse(iterator.hasNext());    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "package foo.bar;" + PMD.EOL + "public class Foo {" + PMD.EOL + "}" + PMD.EOL;    private static final String TEST3 = "public class Foo {" + PMD.EOL + " public class Bar {" + PMD.EOL + " }"            + PMD.EOL + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.ast.ASTBlock;import net.sourceforge.pmd.lang.java.ast.ASTCatchStatement;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;import net.sourceforge.pmd.lang.java.ast.ASTInitializer;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;import net.sourceforge.pmd.lang.symboltable.Scope;public class AcceptanceTest extends STBBaseTst {    @Test    public void testClashingSymbols() {        parseCode(TEST1);    }    @Test    public void testInitializer() {        parseCode(TEST_INITIALIZERS);        ASTInitializer a = acu.findDescendantsOfType(ASTInitializer.class).get(0);        assertFalse(a.isStatic());        a = acu.findDescendantsOfType(ASTInitializer.class).get(1);        assertTrue(a.isStatic());    }    @Test    public void testCatchBlocks() {        parseCode(TEST_CATCH_BLOCKS);        ASTCatchStatement c = acu.findDescendantsOfType(ASTCatchStatement.class).get(0);        ASTBlock a = c.findDescendantsOfType(ASTBlock.class).get(0);        Scope s = a.getScope();        Map<NameDeclaration, List<NameOccurrence>> vars = s.getDeclarations();        assertEquals(1, vars.size());        NameDeclaration v = vars.keySet().iterator().next();        assertEquals("e", v.getImage());        assertEquals(1, (vars.get(v)).size());    }    @Test    public void testEq() {        parseCode(TEST_EQ);        ASTEqualityExpression e = acu.findDescendantsOfType(ASTEqualityExpression.class).get(0);        ASTMethodDeclaration method = e.getFirstParentOfType(ASTMethodDeclaration.class);        Scope s = method.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        assertEquals(2, m.size());        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            NameDeclaration vnd = entry.getKey();            List<NameOccurrence> usages = entry.getValue();            if (vnd.getImage().equals("a") || vnd.getImage().equals("b")) {                assertEquals(1, usages.size());                assertEquals(3, usages.get(0).getLocation().getBeginLine());            } else {                fail("Unkown variable " + vnd);            }        }    }    @Test    public void testFieldFinder() {        parseCode(TEST_FIELD);        // System.out.println(TEST_FIELD);        ASTVariableDeclaratorId declaration = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(1);        assertEquals(3, declaration.getBeginLine());        assertEquals("bbbbbbbbbb", declaration.getImage());        assertEquals(1, declaration.getUsages().size());        NameOccurrence no = declaration.getUsages().get(0);        Node location = no.getLocation();        assertEquals(6, location.getBeginLine());        // System.out.println("variable " + declaration.getImage() + " is used        // here: " + location.getImage());    }    @Test    public void testDemo() {        parseCode(TEST_DEMO);        // System.out.println(TEST_DEMO);        ASTMethodDeclaration node = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0);        Scope s = node.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            assertEquals("buz", entry.getKey().getImage());            assertEquals("ArrayList", ((TypedNameDeclaration) entry.getKey()).getTypeImage());            List<NameOccurrence> u = entry.getValue();            assertEquals(1, u.size());            NameOccurrence o = u.get(0);            int beginLine = o.getLocation().getBeginLine();            assertEquals(3, beginLine);            // System.out.println("Variable: " + d.getImage());            // System.out.println("Type: " + d.getTypeImage());            // System.out.println("Usages: " + u.size());            // System.out.println("Used in line " + beginLine);        }    }    @Test    public void testEnum() {        parseCode(NameOccurrencesTest.TEST_ENUM);        ASTVariableDeclaratorId vdi = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        List<NameOccurrence> usages = vdi.getUsages();        assertEquals(2, usages.size());        assertEquals(5, usages.get(0).getLocation().getBeginLine());        assertEquals(9, usages.get(1).getLocation().getBeginLine());    }    @Test    public void testInnerOuterClass() {        parseCode(TEST_INNER_CLASS);        ASTVariableDeclaratorId vdi = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(1) // get inner class                .getFirstDescendantOfType(ASTVariableDeclaratorId.class); // get first declaration        List<NameOccurrence> usages = vdi.getUsages();        assertEquals(2, usages.size());        assertEquals(5, usages.get(0).getLocation().getBeginLine());        assertEquals(10, usages.get(1).getLocation().getBeginLine());    }    /**     * Unit test for bug #1490     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1490/">#1490 [java] PMD     *      Error while processing - NullPointerException</a>     */    @Test    public void testNullPointerEnumValueOfOverloaded() {        parseCode("public enum EsmDcVoltageSensor {\n" + "    A;\n" + "    void bar(int ... args) {\n"                + "        int idx;\n" + "        int startIdx;\n"                + "        String name = EsmDcVoltageSensor.valueOf((byte) (idx - startIdx)).getName();\n" + "    }\n"                // that's the overloaded method                + "    public EsmDCVoltageSensor valueOf(byte b) {\n"                + "    }\n" + "}\n");    }    private static final String TEST_DEMO = "public class Foo  {" + PMD.EOL + " void bar(ArrayList buz) { " + PMD.EOL            + "  buz.add(\"foo\");" + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_EQ = "public class Foo  {" + PMD.EOL + " boolean foo(String a, String b) { "            + PMD.EOL + "  return a == b; " + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST1 = "import java.io.*;" + PMD.EOL + "public class Foo  {" + PMD.EOL            + " void buz( ) {" + PMD.EOL + "  Object o = new Serializable() { int x; };" + PMD.EOL            + "  Object o1 = new Serializable() { int x; };" + PMD.EOL + " }" + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_INITIALIZERS = "public class Foo  {" + PMD.EOL + " {} " + PMD.EOL + " static {} "            + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_CATCH_BLOCKS = "public class Foo  {" + PMD.EOL + " void foo() { " + PMD.EOL            + "  try { " + PMD.EOL + "  } catch (Exception e) { " + PMD.EOL + "   e.printStackTrace(); " + PMD.EOL            + "  } " + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_FIELD = "public class MyClass {" + PMD.EOL + " private int aaaaaaaaaa; " + PMD.EOL            + " boolean bbbbbbbbbb = MyClass.ASCENDING; " + PMD.EOL + " private int zzzzzzzzzz;" + PMD.EOL            + " private void doIt() {" + PMD.EOL + "  if (bbbbbbbbbb) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + "}" + PMD.EOL;    public static final String TEST_INNER_CLASS = "public class Outer {" + PMD.EOL + "  private static class Inner {"            + PMD.EOL + "    private int i;" + PMD.EOL + "    private Inner(int i) {" + PMD.EOL + "      this.i = i;"            + PMD.EOL + "    }" + PMD.EOL + "  }" + PMD.EOL + "  public int modify(int i) {" + PMD.EOL            + "    Inner in = new Inner(i);" + PMD.EOL + "    return in.i;" + PMD.EOL + "  }" + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AcceptanceTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.ImageFinderFunction;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;public class ImageFinderFunctionTest {    @Test    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    @Test    public void testSeveralImages() {        List<String> imgs = new ArrayList<>();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ImageFinderFunctionTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class HardCodedCryptoKeyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InsecureCryptoIvTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingSerialVersionUIDTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryCaseChangeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLiteralsInIfConditionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryConversionTemporaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeShouldBeProtectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCallingFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperFirstTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MisplacedNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringBufferInstantiationWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodMustBePublicTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptySwitchStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseLocaleWithCaseConversionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseEqualsToCompareStringsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontImportSunTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeOnlyCallsSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodMustImplementCloneableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TestClassWithoutTestCasesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReturnEmptyArrayRatherThanNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BadComparisonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JumbledIncrementerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotHardCodeSDCardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentToNonFinalStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitStaticSuiteTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseCorrectExceptionLoggingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitSpellingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeOverloadedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MoreThanOneLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StaticEJBFieldShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DetachedTestCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousEqualsMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseProperClassLoaderTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotCallGarbageCollectionExplicitlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EqualsNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotExtendJavaLangThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NonStaticInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneThrowsCloneNotSupportedExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BrokenNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassCastExceptionWithToArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimpleDateFormatNeedsLocaleTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidEnumAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InvalidLogMessageFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalizeDoesNotCallSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReturnFromFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProperCloneImplementationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloseResourceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDuplicateLiteralsTest extends PmdRuleTst {    @Test    public void testStringParserEmptyString() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("");        assertTrue(res.isEmpty());    }    @Test    public void testStringParserSimple() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("a,b,c");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("c"));    }    @Test    public void testStringParserEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("a,b,\\,");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains(","));    }    @Test    public void testStringParserEscapedEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set<String> res = p.parse("a,b,\\\\");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("\\"));    }    @Test    public void testSeparatorPropertyWarning() throws Exception {        AvoidDuplicateLiteralsRule rule = new AvoidDuplicateLiteralsRule();        Assert.assertFalse(rule.isPropertyOverridden(AvoidDuplicateLiteralsRule.SEPARATOR_DESCRIPTOR));        Rule copy = rule.deepCopy();        Assert.assertFalse(copy.isPropertyOverridden(AvoidDuplicateLiteralsRule.SEPARATOR_DESCRIPTOR));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperLastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ImportFromSamePackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodReturnTypeMustMatchClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyFinalizerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidAssertAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IdempotentOperationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyTryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LoggerIsNotStaticFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CompareObjectsWithEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotThrowExceptionInFinallyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SingleMethodSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BeanMembersShouldSerializeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnconditionalIfStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NonCaseLabelInSwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProperLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLosingExceptionInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingStaticMethodInNonInstantiatableClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidInstanceofChecksInCatchClauseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NullAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidBranchingStatementAsLastInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidMultipleUnaryOperatorsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDecimalLiteralsInBigDecimalConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFieldNameMatchingMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedNullCheckInEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontUseFloatTypeForLoopIndicesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DataflowAnomalyAnalysisTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptySynchronizedBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CheckSkipResultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingOctalValuesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InstantiationToGetClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFieldNameMatchingTypeNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementNotInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessOperationOnImmutableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotCallSystemExitTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingNPETest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousOctalEscapeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SingletonClassReturningNewInstanceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousHashcodeMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingBreakInSwitchTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConstructorCallsOverridableMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SignatureDeclareThrowsExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThrowingNullPointerExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AbstractClassWithoutAnyMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseObjectForClearerAPITest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExceptionAsFlowControlTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SwitchDensityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUncheckedExceptionsInSignaturesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessOverridingMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifiedTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassWithOnlyPrivateConstructorsShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GodClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.java.metrics.MetricsHook;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {    @Override    protected Rule reinitializeRule(Rule rule) {        MetricsHook.reset();        return rule;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotExtendJavaLangErrorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CouplingBetweenObjectsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseUtilityClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidRethrowingExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ImmutableFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThrowingRawExceptionTypesTest extends PmdRuleTst {    public static class Throwable extends java.lang.Throwable {        private static final long serialVersionUID = 1798165250043760600L;    }    public static class Exception extends java.lang.Throwable {        private static final long serialVersionUID = -2518308549741147689L;    }    public static class RuntimeException extends java.lang.Throwable {        private static final long serialVersionUID = 6341520923058239682L;    }    public static class Error extends java.lang.Throwable {        private static final long serialVersionUID = -6965602141393320558L;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DataClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyConditionalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FinalFieldCouldBeStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.java.metrics.MetricsHook;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NPathComplexityTest extends PmdRuleTst {    @Override    protected Rule reinitializeRule(Rule rule) {        MetricsHook.reset();        return rule;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import java.io.StringReader;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StdCyclomaticComplexityTest extends PmdRuleTst {    /**     * Make sure the entry stack is empty, if show classes complexity is     * disabled.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1501/">bug #1501</a>     */    @Test    public void entryStackMustBeEmpty() {        StdCyclomaticComplexityRule rule = new StdCyclomaticComplexityRule();        rule.setProperty(StdCyclomaticComplexityRule.SHOW_CLASSES_COMPLEXITY_DESCRIPTOR, Boolean.FALSE);        RuleContext ctx = new RuleContext();        LanguageVersion javaLanguageVersion = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8");        ParserOptions parserOptions = javaLanguageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = javaLanguageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse("test", new StringReader("public class SampleClass {}"));        rule.apply(Arrays.asList(node), ctx);        Assert.assertTrue(rule.entryStack.isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SingularFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanReturnsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingGenericExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LawOfDemeterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LogicInversionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanExpressionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.java.metrics.MetricsHook;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssCountTest extends PmdRuleTst {    @Override    protected Rule reinitializeRule(Rule rule) {        MetricsHook.reset();        return rule;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ModifiedCyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThrowingNewInstanceOfSameExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LoosePackageCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AppendCharacterWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingShortTypeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OptimizableToArrayCallTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseArrayListInsteadOfVectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFileStreamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BigIntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsecutiveAppendsShouldReuseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidArrayLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyStartsWithTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AddEmptyStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidInstantiatingObjectsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ByteInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessStringValueOfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsecutiveLiteralAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringToStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RedundantFieldInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseArraysAsListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InefficientStringBufferingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InefficientEmptyStringCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooFewBranchesForASwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LongInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseIndexOfCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InsufficientStringBufferDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BooleanInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryWrapperObjectCreationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseStringBufferLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseStringBufferForStringAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentRequiredTest extends PmdRuleTst {    @Test    public void allCommentTypesIgnored() {        CommentRequiredRule rule = new CommentRequiredRule();        assertNull("By default, the rule should be functional", rule.dysfunctionReason());        List<PropertyDescriptor<?>> propertyDescriptors = getProperties(rule);        // remove  deprecated properties        for (Iterator<PropertyDescriptor<?>> it = propertyDescriptors.iterator(); it.hasNext();) {            PropertyDescriptor<?> property = it.next();            if (property.description().startsWith("Deprecated!")) {                it.remove();            }        }        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Ignored");        }        assertNotNull("All properties are ignored, rule should be dysfunctional", rule.dysfunctionReason());        // now, try out combinations: only one of the properties is required.        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Required");            assertNull("The property " + property.name() + " is set to required, the rule should be functional.",                rule.dysfunctionReason());            setPropertyValue(rule, property, "Ignored");        }    }    private static List<PropertyDescriptor<?>> getProperties(Rule rule) {        List<PropertyDescriptor<?>> result = new ArrayList<>();        for (PropertyDescriptor<?> property : rule.getPropertyDescriptors()) {            if (property != Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR                    && property != Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) {                result.add(property);            }        }        return result;    }    private static <T> void setPropertyValue(Rule rule, PropertyDescriptor<T> property, String value) {        rule.setProperty(property, property.valueFrom(value));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentSizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentContentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UncommentedEmptyMethodBodyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UncommentedEmptyConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import static org.junit.Assert.assertEquals;import java.io.Reader;import java.io.StringReader;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.FormalComment;import net.sourceforge.pmd.lang.java.ast.MultiLineComment;import net.sourceforge.pmd.lang.java.ast.Token;public class AbstractCommentRuleTest {    private AbstractCommentRule testSubject = new AbstractCommentRule() {    };    /**     * Blank lines in comments should not raise an exception. See bug #1048.     */    @Test    public void testFilteredCommentIn() {        Token token = new Token();        token.image = "/* multi line comment with blank lines\n\n\n */";        String filtered = testSubject.filteredCommentIn(new MultiLineComment(token));        assertEquals("multi line comment with blank lines", filtered);        token.image = "/** a formal comment with blank lines\n\n\n */";        filtered = testSubject.filteredCommentIn(new FormalComment(token));        assertEquals("a formal comment with blank lines", filtered);    }    @Test    public void testTagsIndicesIn() {        String comment = "    /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "";        List<Integer> indices = testSubject.tagsIndicesIn(comment);        Assert.assertEquals(2, indices.size());        Assert.assertEquals(79, indices.get(0).intValue());        Assert.assertEquals(123, indices.get(1).intValue());    }    @Test    public void testCommentAssignments() {        LanguageVersionHandler handler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8")                .getLanguageVersionHandler();        Reader source = new StringReader("public class Foo {" + "     /** Comment 1 */\n"                + "        public void method1() {}\n" + "    \n" + "        /** Comment 2 */\n" + "    \n"                + "        /** Comment 3 */\n" + "        public void method2() {}" + "}");        Node node = handler.getParser(handler.getDefaultParserOptions()).parse("test", source);        testSubject.assignCommentsToDeclarations((ASTCompilationUnit) node);        List<ASTMethodDeclaration> methods = node.findDescendantsOfType(ASTMethodDeclaration.class);        Assert.assertEquals("/** Comment 1 */", methods.get(0).comment().getImage());        Assert.assertEquals("/** Comment 3 */", methods.get(1).comment().getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryfullyqualifiedname;public class TestClass {    protected class SomeInnerClass {        public void alsoDoSomething() {            System.out.println("alsoDoSomething");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SuspiciousConstantFieldNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MDBAndSessionBeanNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalHomeNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ControlStatementBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyStaticImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentDefaultAccessModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OnlyOneReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDollarSignsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PrematureDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingNativeCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DefaultPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExtendsObjectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperInConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopShouldBeWhileLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseDiamondOperatorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryFullyQualifiedNameTest extends PmdRuleTst {    // Do not delete these two enums - it is needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1436 UnnecessaryFullyQualifiedName false positive on clashing static    // imports with enums    public enum ENUM1 {        A, B;    }    public enum ENUM2 {        C, D;    }    // Do not delete these two classes - it is needed for a test case    // see: /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1546 part 1 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    // #1546 part 2 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    public static class PhonyMockito {        public static <T> T mock(Class<T> clazz) {            return null;        }    }    public static class PhonyPowerMockito {        public static <T> T mock(Class<T> clazz) {            return null;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldDeclarationsShouldBeAtStartOfClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryAnnotationValueElementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseShortArrayInitializerTest extends PmdRuleTst {  // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFinalLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RemoteInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessQualifiedThisTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IdenticalCatchBranchesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DuplicateImportsTest extends PmdRuleTst {    /**     * This is just for testing DuplicateImports for static imports and     * disambiguation.     */    // Do not delete this method, its needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/DuplicateImports.xml    // #1306 False positive on duplicate when using static imports    public static void assertTrue(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessParenthesesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidProtectedFieldInFinalClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidProtectedMethodInFinalClassNotExtendingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyMethodInAbstractClassShouldBeAbstractTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GenericsNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LongVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PackageCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontImportJavaLangTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AbstractNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AtLeastOneConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseUnderscoresInNumericLiteralsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalInterfaceSessionNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidPrefixingMethodParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RemoteSessionInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LinguisticNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MIsLeadingVariableNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryLocalBeforeReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConfusingTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BooleanGetMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodArgumentCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoubleBraceInitializationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AbstractClassWithoutAbstractMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseVarargsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitUseExpectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopCanBeForeachTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertNullInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4TestShouldUseAfterAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingOverrideTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedPrivateMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertSameInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertEqualsInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReplaceVectorWithListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DefaultLabelNotLastInSwitchStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidMessageDigestFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopVariableCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedFormalParameterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AccessorMethodGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CheckResultSetTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConstantsInInterfaceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReplaceEnumerationWithIteratorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4TestShouldUseTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidStringBufferFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ReplaceHashtableWithMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningLoopVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseTryWithResourcesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LooseCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PositionLiteralsFirstInComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PreserveStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopWithLiteralBooleanTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SystemPrintlnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedPrivateFieldTest extends PmdRuleTst {    /**     * This test will fail, as soon Lombok classes are on the test classpath.     * The test classpath is used as auxclasspath during unit tests.     * If lombok is present, then the test case for #1952 will never fail     * and won't reproduce the false-negative case anymore.     */    @Test    public void makeSureLombokIsNotOnClasspath() {        try {            Class.forName("lombok.Value");            Assert.fail();        } catch (ClassNotFoundException e) {            // this is ok        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingHardCodedIPTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ArrayIsStoredDirectlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitTestsShouldIncludeAssertTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertTrueInsteadOfAssertEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseCollectionIsEmptyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitTestContainsTooManyAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4SuitesShouldUseSuiteAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GuardLogStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PositionLiteralsFirstInCaseInsensitiveComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnit4TestShouldUseBeforeAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AccessorClassGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidPrintStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodReturnsInternalArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SwitchStmtsShouldHaveDefaultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseConcurrentHashMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnsynchronizedStaticFormatterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NonThreadSafeSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingVolatileTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontCallThreadRunTest extends PmdRuleTst {    // Used by DontCallThreadRun test cases    public static class TestThread extends Thread {        @Override        public void run() {            System.out.println("test");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoubleCheckedLockingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSynchronizedAtMethodLevelTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThreadGroupTest extends PmdRuleTst {    // Used by AvoidThreadGroup test cases    public static class ThreadGroup {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnsynchronizedStaticDateFormatterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseNotifyAllInsteadOfNotifyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotUseThreadsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.java.rule.codestyle.DuplicateImportsRule;import net.sourceforge.pmd.lang.java.rule.internal.JavaRuleViolationFactory;import net.sourceforge.pmd.lang.rule.RuleViolationFactory;/** * @author guofei * */public class JavaRuleViolationFactoryTest {    @Test    public void messageWithSingleBrace() {        RuleViolationFactory factory = JavaRuleViolationFactory.INSTANCE;        factory.addViolation(new RuleContext(), new DuplicateImportsRule(), null, "message with \"'{'\"", null);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.StringReader;import java.util.HashMap;import java.util.Iterator;import java.util.List;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.JaxenXPathRuleQuery;import net.sourceforge.pmd.lang.rule.xpath.SaxonXPathRuleQuery;import net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.StringMultiProperty;import net.sourceforge.pmd.properties.StringProperty;import net.sourceforge.pmd.testframework.RuleTst;/** * @author daniels */public class XPathRuleTest extends RuleTst {    XPathRule rule;    @Before    public void setUp() {        rule = new XPathRule();        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        rule.setMessage("XPath Rule Failed");    }    @Test    public void testPluginname() throws Exception {        rule.setXPath("//VariableDeclaratorId[string-length(@Image) < 3]");        rule.setMessage("{0}");        Report report = getReportForTestString(rule, TEST1);        RuleViolation rv = report.iterator().next();        assertEquals("a", rv.getDescription());    }    @Test    public void testXPathMultiProperty() throws Exception {        rule.setXPath("//VariableDeclaratorId[@Image=$forbiddenNames]");        rule.setMessage("Avoid vars");        rule.setVersion(XPathRuleQuery.XPATH_2_0);        StringMultiProperty varDescriptor            = StringMultiProperty.named("forbiddenNames")                                 .desc("Forbidden names")                                 .defaultValues("forbid1", "forbid2")                                 .delim('$')                                 .build();        rule.definePropertyDescriptor(varDescriptor);        Report report = getReportForTestString(rule, TEST3);        Iterator<RuleViolation> rv = report.iterator();        int i = 0;        for (; rv.hasNext(); ++i) {            rv.next();        }        assertEquals(2, i);    }    @Test    public void testVariables() throws Exception {        rule.setXPath("//VariableDeclaratorId[@Image=$var]");        rule.setMessage("Avoid vars");        StringProperty varDescriptor = new StringProperty("var", "Test var", null, 1.0f);        rule.definePropertyDescriptor(varDescriptor);        rule.setProperty(varDescriptor, "fiddle");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.iterator().next();        assertEquals(3, rv.getBeginLine());    }    @Test    public void testFnPrefixOnSaxon() throws Exception {        rule.setXPath("//VariableDeclaratorId[fn:matches(@Image, 'fiddle')]");        rule.setVersion(XPathRuleQuery.XPATH_2_0);        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.iterator().next();        assertEquals(3, rv.getBeginLine());    }    @Test    public void testNoFnPrefixOnSaxon() throws Exception {        rule.setXPath("//VariableDeclaratorId[matches(@Image, 'fiddle')]");        rule.setVersion(XPathRuleQuery.XPATH_2_0);        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.iterator().next();        assertEquals(3, rv.getBeginLine());    }    /**     * Test for problem reported in bug #1219 PrimarySuffix/@Image does not work     * in some cases in xpath 2.0     *      * @throws Exception     *             any error     */    @Test    public void testImageOfPrimarySuffix() throws Exception {        final String SUFFIX = "import java.io.File;\n" + "\n" + "public class TestSuffix {\n"                + "    public static void main(String args[]) {\n" + "        new File(\"subdirectory\").list();\n"                + "    }\n" + "}";        LanguageVersion language = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = language.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = language.getLanguageVersionHandler().getParser(parserOptions);        ASTCompilationUnit cu = (ASTCompilationUnit) parser.parse("test", new StringReader(SUFFIX));        RuleContext ruleContext = new RuleContext();        ruleContext.setLanguageVersion(language);        String xpath = "//PrimarySuffix[@Image='list']";        // XPATH version 1.0        XPathRuleQuery xpathRuleQuery = new JaxenXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_1_0);        List<Node> nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(1, nodes.size());        // XPATH version 1.0 Compatibility        xpathRuleQuery = new SaxonXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_1_0_COMPATIBILITY);        nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(1, nodes.size());        // XPATH version 2.0        xpathRuleQuery = new SaxonXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_2_0);        nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(1, nodes.size());    }    /**     * Following sibling check: See https://sourceforge.net/p/pmd/bugs/1209/     *      * @throws Exception     *             any error     */    @Test    public void testFollowingSibling() throws Exception {        final String SOURCE = "public class dummy {\n" + "  public String toString() {\n"                + "    String test = \"bad example\";\n" + "    test = \"a\";\n" + "    return test;\n" + "  }\n" + "}";        LanguageVersion language = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = language.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = language.getLanguageVersionHandler().getParser(parserOptions);        ASTCompilationUnit cu = (ASTCompilationUnit) parser.parse("test", new StringReader(SOURCE));        RuleContext ruleContext = new RuleContext();        ruleContext.setLanguageVersion(language);        String xpath = "//Block/BlockStatement/following-sibling::BlockStatement";        // XPATH version 1.0        XPathRuleQuery xpathRuleQuery = new JaxenXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_1_0);        List<Node> nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(2, nodes.size());        assertEquals(4, nodes.get(0).getBeginLine());        assertEquals(5, nodes.get(1).getBeginLine());        // XPATH version 2.0        xpathRuleQuery = new SaxonXPathRuleQuery();        xpathRuleQuery.setXPath(xpath);        xpathRuleQuery.setProperties(new HashMap<PropertyDescriptor<?>, Object>());        xpathRuleQuery.setVersion(XPathRuleQuery.XPATH_2_0);        nodes = xpathRuleQuery.evaluate(cu, ruleContext);        assertEquals(2, nodes.size());        assertEquals(4, nodes.get(0).getBeginLine());        assertEquals(5, nodes.get(1).getBeginLine());    }    private static Report getReportForTestString(Rule r, String test) throws PMDException {        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFile(new File("n/a"));        RuleSet rules = new RuleSetFactory().createSingleRuleRuleSet(r);        p.getSourceCodeProcessor().processSourceCode(new StringReader(test), new RuleSets(rules), ctx);        return report;    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " int a;" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " int faddle;" + PMD.EOL + " int fiddle;"            + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " int forbid1; int forbid2; int forbid1$forbid2;" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.Assert.assertEquals;import java.io.StringReader;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.symboltable.ScopeAndDeclarationFinder;/** * @author Philip Graf */public class JavaRuleViolationTest {    /**     * Verifies that {@link JavaRuleViolation} sets the variable name for an     * {@link ASTFormalParameter} node.     */    @Test    public void testASTFormalParameterVariableName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        final ASTFormalParameter node = ast.getFirstDescendantOfType(ASTFormalParameter.class);        final RuleContext context = new RuleContext();        final JavaRuleViolation violation = new JavaRuleViolation(null, context, node, null);        assertEquals("x", violation.getVariableName());    }    private ASTCompilationUnit parse(final String code) {        final LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        final ParserOptions options = languageVersionHandler.getDefaultParserOptions();        final ASTCompilationUnit ast = (ASTCompilationUnit) languageVersionHandler.getParser(options).parse(null,                new StringReader(code));        // set scope of AST nodes        ast.jjtAccept(new ScopeAndDeclarationFinder(), null);        return ast;    }    /**     * Tests that the method name is taken correctly from the given node.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1250/">#1250</a>     */    @Test    public void testMethodName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        final RuleContext context = new RuleContext();        final JavaRuleViolation violation = new JavaRuleViolation(null, context, md, null);        assertEquals("bar", violation.getMethodName());    }    /**     * Tests that the enum name is taken correctly from the given node.     */    @Test    public void testEnumName() {        ASTCompilationUnit ast = parse("enum Foo {FOO; void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        final RuleContext context = new RuleContext();        final JavaRuleViolation violation = new JavaRuleViolation(null, context, md, null);        assertEquals("Foo", violation.getClassName());    }    /**     * Tests that the class name is taken correctly, even if the node is outside     * of a class scope, e.g. a import declaration.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1529/">#1529</a>     */    @Test    public void testPackageAndClassName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndEnumName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public enum FooE { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("FooE", violation.getClassName());    }    @Test    public void testDefaultPackageAndClassName() {        ASTCompilationUnit ast = parse("import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndMultipleClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { } public class Bar { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Bar", violation.getClassName());    }    @Test    public void testPackageAndPackagePrivateClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        JavaRuleViolation violation = new JavaRuleViolation(null, new RuleContext(), importNode, null);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    /**     * Test that the name of the inner class is taken correctly.     */    @Test    public void testInnerClass() {        ASTCompilationUnit ast = parse("class Foo { class Bar { } }");        List<ASTClassOrInterfaceDeclaration> classes = ast.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(2, classes.size());        JavaRuleViolation fooViolation = new JavaRuleViolation(null, new RuleContext(), classes.get(0), null);        assertEquals("Foo", fooViolation.getClassName());        JavaRuleViolation barViolation = new JavaRuleViolation(null, new RuleContext(), classes.get(1), null);        assertEquals("Foo$Bar", barViolation.getClassName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTPrimarySuffixTest {    @Test    public void testArrayDereference() {        Set<ASTPrimarySuffix> ops = getNodes(ASTPrimarySuffix.class, TEST1);        assertTrue(ops.iterator().next().isArrayDereference());    }    @Test    public void testArguments() {        Set<ASTPrimarySuffix> ops = getNodes(ASTPrimarySuffix.class, TEST2);        assertTrue(ops.iterator().next().isArguments());    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + "  {x[0] = 2;}" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + "  {foo(a);}" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTLiteralTest {    @Test    public void testIsStringLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST1);        assertTrue((literals.iterator().next()).isStringLiteral());    }    @Test    public void testIsNotStringLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST2);        assertFalse((literals.iterator().next()).isStringLiteral());    }    @Test    public void testIsIntIntLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST3);        assertTrue((literals.iterator().next()).isIntLiteral());    }    @Test    public void testIsIntLongLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST4);        assertTrue((literals.iterator().next()).isLongLiteral());    }    @Test    public void testIsFloatFloatLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST5);        assertTrue((literals.iterator().next()).isFloatLiteral());    }    @Test    public void testIsFloatDoubleLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST6);        assertTrue((literals.iterator().next()).isDoubleLiteral());    }    @Test    public void testIsCharLiteral() {        Set<ASTLiteral> literals = getNodes(ASTLiteral.class, TEST7);        assertTrue((literals.iterator().next()).isCharLiteral());    }    @Test    public void testIntValueParsing() {        ASTLiteral literal = new ASTLiteral(1);        literal.setIntLiteral();        literal.setImage("1___234");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(1___234, literal.getValueAsInt());    }        @Test    public void testIntValueParsingBinary() {        ASTLiteral literal = new ASTLiteral(1);        literal.setIntLiteral();        literal.setImage("0b0000_0010");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(0b0000_0010, literal.getValueAsInt());    }        @Test    public void testIntValueParsingNegativeHexa() {        ASTLiteral literal = new ASTLiteral(1);        literal.setIntLiteral();        literal.setImage("-0X0000_000f");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(-0X0000_000f, literal.getValueAsInt());    }        @Test    public void testFloatValueParsingNegative() {        ASTLiteral literal = new ASTLiteral(1);        literal.setFloatLiteral();        literal.setImage("-3_456.123_456");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals(-3_456.123_456f, literal.getValueAsFloat(), 0);    }        @Test    public void testStringUnicodeEscapesNotEscaped() {        ASTLiteral literal = new ASTLiteral(1);        literal.setStringLiteral();        literal.setImage("abcüabc");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(7);        assertEquals("abcüabc", literal.getEscapedStringLiteral());        assertEquals("abcüabc", literal.getImage());    }    @Test    public void testStringUnicodeEscapesInvalid() {        ASTLiteral literal = new ASTLiteral(1);        literal.setStringLiteral();        literal.setImage("abc\\uXYZAabc");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(12);        assertEquals("abc\\uXYZAabc", literal.getEscapedStringLiteral());        assertEquals("abc\\uXYZAabc", literal.getImage());    }    @Test    public void testStringUnicodeEscapesValid() {        ASTLiteral literal = new ASTLiteral(1);        literal.setStringLiteral();        literal.setImage("abc\u1234abc");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(12);        assertEquals("abc\\u1234abc", literal.getEscapedStringLiteral());        assertEquals("abcሴabc", literal.getImage());    }    @Test    public void testCharacterUnicodeEscapesValid() {        ASTLiteral literal = new ASTLiteral(1);        literal.setCharLiteral();        literal.setImage("\u0030");        literal.testingOnlySetBeginColumn(1);        literal.testingOnlySetEndColumn(6);        assertEquals("\\u0030", literal.getEscapedStringLiteral());        assertEquals("0", literal.getImage());    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + "  String x = \"foo\";" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + "  int x = 42;" + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + "  int x = 42;" + PMD.EOL + "}";    private static final String TEST4 = "public class Foo {" + PMD.EOL + "  long x = 42L;" + PMD.EOL + "}";    private static final String TEST5 = "public class Foo {" + PMD.EOL + "  float x = 3.14159f;" + PMD.EOL + "}";    private static final String TEST6 = "public class Foo {" + PMD.EOL + "  double x = 3.14159;" + PMD.EOL + "}";    private static final String TEST7 = "public class Foo {" + PMD.EOL + "  char x = 'x';" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import java.util.Set;import org.junit.Test;public class ClassDeclTest {    @Test    public void testPublic() {        String[] access = { "public" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, false, false);    }    @Test    public void testAbstract() {        String[] access = { "abstract" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, true, false, false);    }    @Test    public void testFinal() {        String[] access = { "final" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, true, false);    }    @Test    public void testStrict() {        String[] access = { "strictfp" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, false, true);    }    @Test    public void testPublicFinal() {        String[] access = { "public", "final" };        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, true, false);    }    public void verifyFlags(ASTClassOrInterfaceDeclaration acd, boolean bPublic, boolean bAbstract, boolean bFinal,            boolean bStrict) {        assertEquals("Public: ", bPublic, acd.isPublic());        assertEquals("Abstract: ", bAbstract, acd.isAbstract());        assertEquals("Final: ", bFinal, acd.isFinal());        assertEquals("Strict: ", bStrict, acd.isStrictfp());    }    public ASTClassOrInterfaceDeclaration getClassDecl(String[] access) {        String javaCode = "";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " class Test { } ";        Set<ASTClassOrInterfaceDeclaration> classes = getNodes(ASTClassOrInterfaceDeclaration.class, javaCode);        assertEquals("Wrong number of classes", 1, classes.size());        return classes.iterator().next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;public class FieldDeclTest {    public String makeAccessJavaCode(String[] access) {        String result = "public class Test { ";        for (int i = 0; i < access.length; i++) {            result += access[i] + " ";        }        return result + " int j;  }";    }    public ASTFieldDeclaration getFieldDecl(String[] access) {        Set<ASTFieldDeclaration> fields = getNodes(ASTFieldDeclaration.class, makeAccessJavaCode(access));        assertEquals("Wrong number of fields", 1, fields.size());        return fields.iterator().next();    }    @Test    public void testPublic() {        String[] access = { "public" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be public.", afd.isPublic());    }    @Test    public void testProtected() {        String[] access = { "protected" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be protected.", afd.isProtected());    }    @Test    public void testPrivate() {        String[] access = { "private" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());    }    @Test    public void testStatic() {        String[] access = { "private", "static" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be static.", afd.isStatic());        assertTrue("Expecting field to be private.", afd.isPrivate());    }    @Test    public void testFinal() {        String[] access = { "public", "final" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be final.", afd.isFinal());        assertTrue("Expecting field to be public.", afd.isPublic());    }    @Test    public void testTransient() {        String[] access = { "private", "transient" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());        assertTrue("Expecting field to be transient.", afd.isTransient());    }    @Test    public void testVolatile() {        String[] access = { "private", "volatile" };        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be volatile.", afd.isVolatile());        assertTrue("Expecting field to be private.", afd.isPrivate());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;public class ASTBlockStatementTest {    @Test    public void testIsAllocation() {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAllocationExpression(1), 0);        assertTrue(bs.isAllocation());    }    @Test    public void testIsAllocation2() {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAssertStatement(1), 0);        assertFalse(bs.isAllocation());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;public class MethodDeclTest {    @Test    public void testPublic() {        String[] access = { "public" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testPrivate() {        String[] access = { "private" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be private.", amd.isPrivate());    }    @Test    public void testProtected() {        String[] access = { "protected" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be protected.", amd.isProtected());    }    @Test    public void testFinal() {        String[] access = { "public", "final" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be final.", amd.isFinal());        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testSynchronized() {        String[] access = { "public", "synchronized" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be synchronized.", amd.isSynchronized());        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testAbstract() {        String[] access = { "public", "abstract" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be abstract.", amd.isAbstract());        assertTrue("Expecting method to be public.", amd.isPublic());    }    @Test    public void testNative() {        String[] access = { "private", "native" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be native.", amd.isNative());        assertTrue("Expecting method to be private.", amd.isPrivate());    }    @Test    public void testStrict() {        String[] access = { "public", "strictfp" };        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be strict.", amd.isStrictfp());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public ASTMethodDeclaration getMethodDecl(String[] access) {        String javaCode = "public class Test { ";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " void stuff() { } }";        Set<ASTMethodDeclaration> methods = getNodes(ASTMethodDeclaration.class, javaCode);        assertEquals("Wrong number of methods", 1, methods.size());        return methods.iterator().next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class ASTImportDeclarationTest {    @Test    public void testImportOnDemand() {        Set<ASTImportDeclaration> ops = getNodes(ASTImportDeclaration.class, TEST1);        assertTrue(ops.iterator().next().isImportOnDemand());    }    @Test    public void testGetImportedNameNode() {        ASTImportDeclaration i = getNodes(ASTImportDeclaration.class, TEST2).iterator().next();        assertEquals("foo.bar.Baz", i.getImportedName());    }    @Test    public void testStaticImport() {        Set<ASTImportDeclaration> ops = getNodes(ASTImportDeclaration.class, TEST3);        ASTImportDeclaration i = ops.iterator().next();        assertTrue(i.isStatic());    }    @Test(expected = ParseException.class)    public void testStaticImportFailsWithJDK14() {        getNodes(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), ASTImportDeclaration.class,                TEST3);    }    private static final String TEST1 = "import foo.bar.*;" + PMD.EOL + "public class Foo {}";    private static final String TEST2 = "import foo.bar.Baz;" + PMD.EOL + "public class Foo {}";    private static final String TEST3 = "import static foo.bar.Baz;" + PMD.EOL + "public class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class ASTAnnotationTest {    @Test    public void testAnnotationSucceedsWithDefaultMode() {        getNodes(ASTAnnotation.class, TEST1);    }    @Test(expected = ParseException.class)    public void testAnnotationFailsWithJDK14() {        getNodes(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), ASTAnnotation.class, TEST1);    }    @Test    public void testAnnotationSucceedsWithJDK15() {        getNodes(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"), ASTAnnotation.class, TEST1);    }    private static final String TEST1 = "public class Foo extends Buz {" + PMD.EOL + " @Override" + PMD.EOL            + " void bar() {" + PMD.EOL + "  // overrides a superclass method" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava18;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTVariableDeclaratorIdTest {    @Test    public void testIsExceptionBlockParameter() {        ASTCompilationUnit acu = getNodes(ASTCompilationUnit.class, EXCEPTION_PARAMETER).iterator().next();        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(id.isExceptionBlockParameter());    }    @Test    public void testTypeNameNode() {        ASTCompilationUnit acu = getNodes(ASTCompilationUnit.class, TYPE_NAME_NODE).iterator().next();        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode().jjtGetChild(0);        assertEquals("String", name.getImage());    }    @Test    public void testAnnotations() {        ASTCompilationUnit acu = getNodes(ASTCompilationUnit.class, TEST_ANNOTATIONS).iterator().next();        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode().jjtGetChild(0);        assertEquals("String", name.getImage());    }    @Test    public void testLambdaWithType() throws Exception {        ASTCompilationUnit acu = parseJava18(TEST_LAMBDA_WITH_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertEquals("File", f.getTypeNode().getTypeImage());        assertEquals("File", f.getTypeNameNode().jjtGetChild(0).getImage());    }    @Test    public void testLambdaWithoutType() throws Exception {        ASTCompilationUnit acu = parseJava18(TEST_LAMBDA_WITHOUT_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertNull(f.getTypeNode());        assertNull(f.getTypeNameNode());    }    private static final String TYPE_NAME_NODE = "public class Test {" + PMD.EOL + "  private String bar;" + PMD.EOL            + "}";    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    private static final String TEST_ANNOTATIONS = "public class Foo {" + PMD.EOL            + "    public void bar(@A1 @A2 String s) {}" + PMD.EOL + "}";    private static final String TEST_LAMBDA_WITH_TYPE = "public class Foo {\n" + "    public void bar() {\n"            + "        FileFilter java = (File f) -> f.getName().endsWith(\".java\");\n" + "    }\n" + "}\n";    private static final String TEST_LAMBDA_WITHOUT_TYPE = "public class Foo {\n" + "    public void bar() {\n"            + "        FileFilter java2 = f -> f.getName().endsWith(\".java\");\n" + "    }\n" + "}\n";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ASTVariableDeclaratorIdTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava9;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Test;public class ASTModuleDeclarationTest {    private static String loadSource(String name) {        try {            return IOUtils.toString(ASTModuleDeclarationTest.class.getResourceAsStream("jdkversiontests/" + name),                    StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Test    public final void jdk9ModuleInfo() {        ASTCompilationUnit ast = parseJava9(loadSource("jdk9_module_info.java"));        List<ASTModuleDeclaration> modules = ast.findDescendantsOfType(ASTModuleDeclaration.class);        assertEquals(1, modules.size());        ASTModuleDeclaration module = modules.get(0);        assertTrue(module.isOpen());        assertEquals("com.example.foo", module.getImage());        assertEquals(7, module.jjtGetNumChildren());        List<ASTModuleDirective> directives = module.findChildrenOfType(ASTModuleDirective.class);        assertEquals(7, directives.size());                // requires com.example.foo.http;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(0).getType());        assertNull(directives.get(0).getRequiresModifier());        assertEquals("com.example.foo.http", directives.get(0).getFirstChildOfType(ASTModuleName.class).getImage());        // requires java.logging;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(1).getType());        assertNull(directives.get(1).getRequiresModifier());        assertEquals("java.logging", directives.get(1).getFirstChildOfType(ASTModuleName.class).getImage());        // requires transitive com.example.foo.network;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(2).getType());        assertEquals(ASTModuleDirective.RequiresModifier.TRANSITIVE.name(), directives.get(2).getRequiresModifier());        assertEquals("com.example.foo.network", directives.get(2).getFirstChildOfType(ASTModuleName.class).getImage());        // exports com.example.foo.bar;        assertEquals(ASTModuleDirective.DirectiveType.EXPORTS.name(), directives.get(3).getType());        assertNull(directives.get(3).getRequiresModifier());        assertEquals("com.example.foo.bar", directives.get(3).getFirstChildOfType(ASTName.class).getImage());        // exports com.example.foo.internal to com.example.foo.probe;        assertEquals(ASTModuleDirective.DirectiveType.EXPORTS.name(), directives.get(4).getType());        assertNull(directives.get(4).getRequiresModifier());        assertEquals("com.example.foo.internal", directives.get(4).getFirstChildOfType(ASTName.class).getImage());        assertEquals("com.example.foo.probe", directives.get(4).getFirstChildOfType(ASTModuleName.class).getImage());        // uses com.example.foo.spi.Intf;        assertEquals(ASTModuleDirective.DirectiveType.USES.name(), directives.get(5).getType());        assertNull(directives.get(5).getRequiresModifier());        assertEquals("com.example.foo.spi.Intf", directives.get(5).getFirstChildOfType(ASTName.class).getImage());        // provides com.example.foo.spi.Intf with com.example.foo.Impl;        assertEquals(ASTModuleDirective.DirectiveType.PROVIDES.name(), directives.get(6).getType());        assertNull(directives.get(6).getRequiresModifier());        assertEquals("com.example.foo.spi.Intf", directives.get(6).getFirstChildOfType(ASTName.class).getImage());        assertEquals("com.example.foo.Impl", directives.get(6).findChildrenOfType(ASTName.class).get(1).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava14;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava15;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava17;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava18;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.fail;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.List;import java.util.Map;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class ParserCornersTest {    /**     * #1107 PMD 5.0.4 couldn't parse call of parent outer java class method     * from inner class.     */    @Test    public void testInnerOuterClass() {        parseJava17("/**\n" + " * @author azagorulko\n" + " *\n" + " */\n"                + "public class TestInnerClassCallsOuterParent {\n" + "\n" + "    public void test() {\n"                + "        new Runnable() {\n" + "            @Override\n" + "            public void run() {\n"                + "                TestInnerClassCallsOuterParent.super.toString();\n" + "            }\n"                + "        };\n" + "    }\n" + "}\n");    }        /**     * #888 PMD 6.0.0 can't parse valid <> under 1.8.     */    @Test    public void testDiamondUsageJava8() {        parseJava18("public class PMDExceptionTest {\n"                + "  private Component makeUI() {\n"                + "    String[] model = {\"123456\", \"7890\"};\n"                + "    JComboBox<String> comboBox = new JComboBox<>(model);\n"                + "    comboBox.setEditable(true);\n"                + "    comboBox.setEditor(new BasicComboBoxEditor() {\n"                + "      private Component editorComponent;\n"                + "      @Override public Component getEditorComponent() {\n"                + "        if (editorComponent == null) {\n"                + "          JTextField tc = (JTextField) super.getEditorComponent();\n"                + "          editorComponent = new JLayer<>(tc, new ValidationLayerUI<>());\n"                + "        }\n"                + "        return editorComponent;\n"                + "      }\n"                + "    });\n"                + "    JPanel p = new JPanel();\n"                + "    p.add(comboBox);\n"                + "    return p;\n"                + "  }\n"                + "}");    }    @Test    public final void testGetFirstASTNameImageNull() {        parseJava14(ABSTRACT_METHOD_LEVEL_CLASS_DECL);    }    @Test    public final void testCastLookaheadProblem() {        parseJava14(CAST_LOOKAHEAD_PROBLEM);    }    /**     * Tests a specific generic notation for calling methods. See:     * https://jira.codehaus.org/browse/MPMD-139     */    @Test    public void testGenericsProblem() {        parseJava15(GENERICS_PROBLEM);        parseJava17(GENERICS_PROBLEM);    }    @Test    public void testParsersCases15() {        String test15 = readAsString("/net/sourceforge/pmd/ast/ParserCornerCases.java");        parseJava15(test15);    }    @Test    public void testParsersCases17() {        String test17 = readAsString("/net/sourceforge/pmd/ast/ParserCornerCases17.java");        parseJava17(test17);    }    @Test    public void testParsersCases18() throws Exception {        String test18 = readAsString("/net/sourceforge/pmd/ast/ParserCornerCases18.java");        ASTCompilationUnit cu = parseJava18(test18);        Assert.assertEquals(21, cu.findChildNodesWithXPath("//FormalParameter").size());        Assert.assertEquals(4,                cu.findChildNodesWithXPath("//FormalParameter[@ExplicitReceiverParameter='true']").size());        Assert.assertEquals(17,                cu.findChildNodesWithXPath("//FormalParameter[@ExplicitReceiverParameter='false']").size());    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1333/     */    @Test    public void testLambdaBug1333() {        parseJava18("final class Bug1333 {\n"                + "    private static final Logger LOG = LoggerFactory.getLogger(Foo.class);\n" + "\n"                + "    public void deleteDirectoriesByNamePattern() {\n"                + "        delete(path -> deleteDirectory(path));\n" + "    }\n" + "\n"                + "    private void delete(Consumer<? super String> consumer) {\n"                + "        LOG.debug(consumer.toString());\n" + "    }\n" + "\n"                + "    private void deleteDirectory(String path) {\n" + "        LOG.debug(path);\n" + "    }\n" + "}");    }    @Test    public void testLambdaBug1470() {        String code = readAsString("LambdaBug1470.java");        parseJava18(code);    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1355/     */    @Test    public void emptyFileJustComment() {        parseJava18("// just a comment");    }    @Test    public void testMultipleExceptionCatching() {        String code = "public class Foo { public void bar() { "                + "try { System.out.println(); } catch (RuntimeException | IOException e) {} } }";        try {            parseJava15(code);            fail("Expected exception");        } catch (ParseException e) {            assertEquals(                    "Line 1, Column 94: Cannot catch multiple exceptions when running in JDK inferior to 1.7 mode!",                    e.getMessage());        }        try {            parseJava17(code);            // no exception expected        } catch (ParseException e) {            fail();        }    }    @Test    public void testBug1429ParseError() {        String c = readAsString("Bug1429.java");        parseJava18(c);    }    @Test    public void testBug1530ParseError() {        String c = readAsString("Bug1530.java");        parseJava18(c);    }        @Test    public void testGitHubBug207() {        String c = readAsString("GitHubBug207.java");        parseJava18(c);    }    @Test    public void testBug206() throws Exception {        String code = "public @interface Foo {" + PMD.EOL            + "static final ThreadLocal<Interner<Integer>> interner =" + PMD.EOL            + "    ThreadLocal.withInitial(Interners::newStrongInterner);" + PMD.EOL            + "}";        parseJava18(code);    }    @Test    public void testGitHubBug208ParseError() {        String c = readAsString("GitHubBug208.java");        parseJava15(c);    }        @Test    public void testGitHubBug257NonExistingCast() throws Exception {        String code = "public class Test {" + PMD.EOL                + "     public static void main(String[] args) {" + PMD.EOL                + "         double a = 4.0;" + PMD.EOL                + "         double b = 2.0;" + PMD.EOL                + "         double result = Math.sqrt((a)   - b);" + PMD.EOL                + "         System.out.println(result);" + PMD.EOL                + "     }" + PMD.EOL                + "}";        ASTCompilationUnit compilationUnit = parseJava15(code);        assertEquals("A cast was found when none expected", 0, compilationUnit.findDescendantsOfType(ASTCastExpression.class).size());    }    @Test    public void testGitHubBug309() throws Exception {        String code = readAsString("GitHubBug309.java");        ASTCompilationUnit compilationUnit = parseJava18(code);        assertNotNull(compilationUnit);    }    /**     * This triggered bug #1484 UnusedLocalVariable - false positive -     * parenthesis     *      * @throws Exception     */    @Test    public void stringConcatentationShouldNotBeCast() throws Exception {        String code = "public class Test {\n" + "    public static void main(String[] args) {\n"                + "        System.out.println(\"X\" + (args) + \"Y\");\n" + "    }\n" + "}";        ASTCompilationUnit cu = parseJava18(code);        Assert.assertEquals(0, cu.findDescendantsOfType(ASTCastExpression.class).size());    }    /**     * Empty statements should be allowed.     * @throws Exception     * @see <a href="https://github.com/pmd/pmd/issues/378">github issue 378</a>     */    @Test    public void testParseEmptyStatements() throws Exception {        String code = "import a;;import b; public class Foo {}";        ASTCompilationUnit cu = parseJava18(code);        assertNotNull(cu);        Assert.assertEquals(ASTEmptyStatement.class, cu.jjtGetChild(1).getClass());        String code2 = "package c;; import a; import b; public class Foo {}";        ASTCompilationUnit cu2 = parseJava18(code2);        assertNotNull(cu2);        Assert.assertEquals(ASTEmptyStatement.class, cu2.jjtGetChild(1).getClass());        String code3 = "package c; import a; import b; public class Foo {};";        ASTCompilationUnit cu3 = parseJava18(code3);        assertNotNull(cu3);        Assert.assertEquals(ASTEmptyStatement.class, cu3.jjtGetChild(4).getClass());    }    @Test    public void testMethodReferenceConfused() throws Exception {        String code = readAsString("MethodReferenceConfused.java");        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10", code);        Assert.assertNotNull(compilationUnit);        ASTBlock firstBlock = compilationUnit.getFirstDescendantOfType(ASTBlock.class);        Map<NameDeclaration, List<NameOccurrence>> declarations = firstBlock.getScope().getDeclarations();        boolean foundVariable = false;        for (Map.Entry<NameDeclaration, List<NameOccurrence>> declaration : declarations.entrySet()) {            String varName = declaration.getKey().getImage();            if ("someVarNameSameAsMethodReference".equals(varName)) {                foundVariable = true;                Assert.assertTrue("no usages expected", declaration.getValue().isEmpty());            } else if ("someObject".equals(varName)) {                Assert.assertEquals("1 usage expected", 1, declaration.getValue().size());                Assert.assertEquals(6, declaration.getValue().get(0).getLocation().getBeginLine());            }        }        Assert.assertTrue("Test setup wrong - variable 'someVarNameSameAsMethodReference' not found anymore!", foundVariable);    }    @Test    public void testSwitchWithFallthrough() throws Exception {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("11", readAsString("SwitchWithFallthrough.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertEquals(2, switchStatement.findChildrenOfType(ASTSwitchLabel.class).size());    }    @Test    public void testSwitchStatements() throws Exception {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("11", readAsString("SwitchStatements.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertEquals(2, switchStatement.findChildrenOfType(ASTSwitchLabel.class).size());    }    private String readAsString(String resource) {        try (InputStream in = ParserCornersTest.class.getResourceAsStream(resource)) {            return IOUtils.toString(in, StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    private static final String GENERICS_PROBLEM = "public class Test {" + PMD.EOL + " public void test() {" + PMD.EOL            + "   String o = super.<String> doStuff(\"\");" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String ABSTRACT_METHOD_LEVEL_CLASS_DECL = "public class Test {" + PMD.EOL + "  void bar() {"            + PMD.EOL + "   abstract class X { public abstract void f(); }" + PMD.EOL            + "   class Y extends X { public void f() {" + PMD.EOL + "    new Y().f();" + PMD.EOL + "   }}" + PMD.EOL            + "  }" + PMD.EOL + "}";    private static final String CAST_LOOKAHEAD_PROBLEM = "public class BadClass {" + PMD.EOL + "  public Class foo() {"            + PMD.EOL + "    return (byte[].class);" + PMD.EOL + "  }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava14;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTLocalVariableDeclarationTest {    @Test    public void testSingleDimArray() {        ASTCompilationUnit cu = parseJava14(TEST1);        ASTLocalVariableDeclaration node = cu.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(1, node.getArrayDepth());    }    @Test    public void testMultDimArray() {        ASTCompilationUnit cu = parseJava14(TEST2);        ASTLocalVariableDeclaration node = cu.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(2, node.getArrayDepth());    }    @Test    public void testMultDimArraySplitBraces() {        ASTCompilationUnit cu = parseJava14(TEST3);        ASTLocalVariableDeclaration node = cu.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " void bar() {int x[] = null;}" + PMD.EOL + "}";    private static final String TEST2 = "class Foo {" + PMD.EOL + " void bar() {int x[][] = null;}" + PMD.EOL + "}";    private static final String TEST3 = "class Foo {" + PMD.EOL + " void bar() {int[] x[][] = null;}" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import org.junit.Test;import net.sourceforge.pmd.PMD;/** * Created on Jan 19, 2005  * @author mgriffa */public class ASTThrowStatementTest {    @Test    public final void testGetFirstASTNameImageNull() {        ASTThrowStatement t = getNodes(ASTThrowStatement.class, NULL_NAME).iterator().next();        assertNull(t.getFirstClassOrInterfaceTypeImage());    }    @Test    public final void testGetFirstASTNameImageNew() {        ASTThrowStatement t = getNodes(ASTThrowStatement.class, OK_NAME).iterator().next();        assertEquals("FooException", t.getFirstClassOrInterfaceTypeImage());    }    private static final String NULL_NAME = "public class Test {" + PMD.EOL + "  void bar() {" + PMD.EOL + "   throw e;"            + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String OK_NAME = "public class Test {" + PMD.EOL + "  void bar() {" + PMD.EOL            + "   throw new FooException();" + PMD.EOL + "  }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava14;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava15;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.ast.testdata.InterfaceWithNestedClass;public class ASTFieldDeclarationTest {    @Test    public void testIsArray() {        ASTCompilationUnit cu = parseJava14(TEST1);        Dimensionable node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertTrue(node.isArray());        assertEquals(1, node.getArrayDepth());    }    @Test    public void testMultiDimensionalArray() {        ASTCompilationUnit cu = parseJava14(TEST2);        Dimensionable node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    @Test    public void testIsSyntacticallyPublic() {        ASTCompilationUnit cu = parseJava14(TEST3);        ASTFieldDeclaration node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isSyntacticallyPublic());        assertFalse(node.isPackagePrivate());        assertFalse(node.isPrivate());        assertFalse(node.isProtected());        assertTrue(node.isFinal());        assertTrue(node.isStatic());        assertTrue(node.isPublic());    }    @Test    public void testWithEnum() {        ASTCompilationUnit cu = parseJava15(TEST4);        ASTFieldDeclaration node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isInterfaceMember());    }    @Test    public void testWithAnnotation() {        ASTCompilationUnit cu = parseJava15(TEST5);        ASTFieldDeclaration node = cu.findDescendantsOfType(ASTFieldDeclaration.class).get(0);        assertFalse(node.isInterfaceMember());        assertTrue(node.isAnnotationMember());    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " String[] foo;" + PMD.EOL + "}";    private static final String TEST2 = "class Foo {" + PMD.EOL + " String[][][] foo;" + PMD.EOL + "}";    private static final String TEST3 = "interface Foo {" + PMD.EOL + " int BAR = 6;" + PMD.EOL + "}";    private static final String TEST4 = "public enum Foo {" + PMD.EOL + " FOO(1);" + PMD.EOL + " private int x;"            + PMD.EOL + "}";    private static final String TEST5 = "public @interface Foo {" + PMD.EOL + " int BAR = 6;" + PMD.EOL + "}";    @Test    public void testGetVariableName() {        int id = 0;        ASTFieldDeclaration n = new ASTFieldDeclaration(id++);        ASTType t = new ASTType(id++);        ASTVariableDeclarator decl = new ASTVariableDeclarator(id++);        ASTVariableDeclaratorId declid = new ASTVariableDeclaratorId(id++);        n.jjtAddChild(t, 0);        t.jjtAddChild(decl, 0);        decl.jjtAddChild(declid, 0);        declid.setImage("foo");        assertEquals("foo", n.getVariableName());    }    @Test    public void testPrivateFieldInNestedClassInsideInterface() {        ASTCompilationUnit cu = ParserTstUtil.parseJava10(InterfaceWithNestedClass.class);        List<ASTFieldDeclaration> fields = cu.findDescendantsOfType(ASTFieldDeclaration.class, true);        assertEquals(2, fields.size());        assertEquals("MAPPING", fields.get(0).getFirstDescendantOfType(ASTVariableDeclaratorId.class).getImage());        assertTrue(fields.get(0).isPublic());        assertFalse(fields.get(0).isPrivate());        assertEquals("serialVersionUID", fields.get(1).getFirstDescendantOfType(ASTVariableDeclaratorId.class).getImage());        assertFalse(fields.get(1).isPublic());        assertTrue(fields.get(1).isPrivate());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ParserTstUtil;/** * @author Clément Fournier * @since 6.1.0 */public class ASTClassOrInterfaceDeclarationTest {    private static final String LOCAL_CLASS_IN_METHOD            = "class Foo { void bar() { class Local {}}}";    private static final String NESTED_CLASS_IS_NOT_LOCAL            = "class Foo { class Nested {} void bar() {}}";    private static final String LOCAL_CLASS_IN_INITIALIZER            = "class Foo { { class Local {} } }";    private static final String LOCAL_CLASS_WITH_MODIFIERS            = "class Foo { { abstract class Local {} } }";    private static final String LOCAL_CLASS_WITH_MIXED_MODIFIER_ANNOTATIONS            = "class Foo { { final @F class Local {} } }";    private static final String LOCAL_CHILDREN_ARE_NOT_ALWAYS_LOCAL            = "class Foo { { class Local { class Nested {} void bar() {class Local2 {}}}}}";    @Test    public void testLocalInMethod() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, LOCAL_CLASS_IN_METHOD);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());    }    @Test    public void testLocalInInitializer() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, LOCAL_CLASS_IN_INITIALIZER);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());    }    @Test    public void testLocalAbstractClass() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, LOCAL_CLASS_WITH_MODIFIERS);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());        assertTrue("Local class should preserve its modifiers", classes.get(1).isAbstract());    }    @Test    public void testLocalClassWithMixedModifiers() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, LOCAL_CLASS_WITH_MIXED_MODIFIER_ANNOTATIONS);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());        assertTrue("Local class should preserve its modifiers", classes.get(1).isFinal());    }    @Test    public void testLocalClassVisibility() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, LOCAL_CLASS_WITH_MODIFIERS);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertTrue("Local class false-negative", classes.get(1).isLocal());        assertFalse("Local class is not public", classes.get(1).isPublic());        assertFalse("Local class is not private", classes.get(1).isPrivate());        assertFalse("Local class is not protected", classes.get(1).isProtected());        assertFalse("Local class is not package-private", classes.get(1).isPackagePrivate());    }    @Test    public void testNestedClassIsNotLocal() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, NESTED_CLASS_IS_NOT_LOCAL);        assertTrue(classes.size() == 2);        assertFalse("Local class false-positive", classes.get(0).isLocal());        assertFalse("Local class false-positive", classes.get(1).isLocal());    }    @Test    public void testLocalChildrenAreNotAlwaysLocal() {        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, LOCAL_CHILDREN_ARE_NOT_ALWAYS_LOCAL);        assertTrue(classes.size() == 4);        assertFalse("Local class false-positive", classes.get(0).isLocal()); // class Foo        assertTrue("Local class false-negative", classes.get(1).isLocal());  // class Local        assertFalse("Local class false-positive", classes.get(2).isLocal()); // class Nested        assertTrue("Local class false-negative", classes.get(3).isLocal());  // class Local2    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.ParserTstUtil;public class Java12Test {    private static String loadSource(String name) {        try {            return IOUtils.toString(Java12Test.class.getResourceAsStream("jdkversiontests/java12/" + name),                    StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Test(expected = ParseException.class)    public void testMultipleCaseLabelsJava11() {        ParserTstUtil.parseAndTypeResolveJava("11", loadSource("MultipleCaseLabels.java"));    }    @Test    public void testMultipleCaseLabels() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("12-preview",                loadSource("MultipleCaseLabels.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertTrue(switchStatement.jjtGetChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatement.jjtGetChild(1) instanceof ASTSwitchLabel);        ASTSwitchLabel switchLabel = switchStatement.getFirstChildOfType(ASTSwitchLabel.class);        Assert.assertEquals(3, switchLabel.findChildrenOfType(ASTExpression.class).size());    }    @Test(expected = ParseException.class)    public void testSwitchRulesJava11() {        ParserTstUtil.parseAndTypeResolveJava("11", loadSource("SwitchRules.java"));    }    @Test    public void testSwitchRules() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("12-preview",                loadSource("SwitchRules.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertTrue(switchStatement.jjtGetChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatement.jjtGetChild(1) instanceof ASTSwitchLabeledExpression);        ASTSwitchLabeledExpression switchLabeledExpression = (ASTSwitchLabeledExpression) switchStatement.jjtGetChild(1);        Assert.assertEquals(2, switchLabeledExpression.jjtGetNumChildren());        Assert.assertTrue(switchLabeledExpression.jjtGetChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledExpression.jjtGetChild(1) instanceof ASTExpression);        ASTSwitchLabeledBlock switchLabeledBlock = (ASTSwitchLabeledBlock) switchStatement.jjtGetChild(4);        Assert.assertEquals(2, switchLabeledBlock.jjtGetNumChildren());        Assert.assertTrue(switchLabeledBlock.jjtGetChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledBlock.jjtGetChild(1) instanceof ASTBlock);        ASTSwitchLabeledThrowStatement switchLabeledThrowStatement = (ASTSwitchLabeledThrowStatement) switchStatement.jjtGetChild(5);        Assert.assertEquals(2, switchLabeledThrowStatement.jjtGetNumChildren());        Assert.assertTrue(switchLabeledThrowStatement.jjtGetChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledThrowStatement.jjtGetChild(1) instanceof ASTThrowStatement);    }    @Test(expected = ParseException.class)    public void testSwitchExpressionsJava11() {        ParserTstUtil.parseAndTypeResolveJava("11", loadSource("SwitchExpressions.java"));    }    @Test    public void testSwitchExpressions() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("12-preview",                loadSource("SwitchExpressions.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchExpression switchExpression = compilationUnit.getFirstDescendantOfType(ASTSwitchExpression.class);        Assert.assertEquals(6, switchExpression.jjtGetNumChildren());        Assert.assertTrue(switchExpression.jjtGetChild(0) instanceof ASTExpression);        Assert.assertEquals(5, switchExpression.findChildrenOfType(ASTSwitchLabeledRule.class).size());        ASTLocalVariableDeclaration localVar = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(1);        ASTVariableDeclarator localVarDecl = localVar.getFirstChildOfType(ASTVariableDeclarator.class);        Assert.assertEquals(Integer.TYPE, localVarDecl.getType());        Assert.assertEquals(Integer.TYPE, switchExpression.getType());    }    @Test    public void testSwitchExpressionsBreak() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("12-preview",                loadSource("SwitchExpressionsBreak.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchExpression switchExpression = compilationUnit.getFirstDescendantOfType(ASTSwitchExpression.class);        Assert.assertEquals(11, switchExpression.jjtGetNumChildren());        Assert.assertTrue(switchExpression.jjtGetChild(0) instanceof ASTExpression);        Assert.assertEquals(5, switchExpression.findChildrenOfType(ASTSwitchLabel.class).size());        ASTBreakStatement breakStatement = switchExpression.getFirstDescendantOfType(ASTBreakStatement.class);        Assert.assertEquals("SwitchExpressionsBreak.SIX", breakStatement.getImage());        Assert.assertTrue(breakStatement.jjtGetChild(0) instanceof ASTExpression);        ASTLocalVariableDeclaration localVar = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(1);        ASTVariableDeclarator localVarDecl = localVar.getFirstChildOfType(ASTVariableDeclarator.class);        Assert.assertEquals(Integer.TYPE, localVarDecl.getType());        Assert.assertEquals(Integer.TYPE, switchExpression.getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTInitializerTest {    @Test    public void testDontCrashOnBlockStatement() {        getNodes(ASTInitializer.class, TEST1);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " {" + PMD.EOL + "   x = 5;" + PMD.EOL + " }"            + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.typeresolution.testdata.java8.UsesJavaStreams;import net.sourceforge.pmd.typeresolution.testdata.java8.UsesRepeatableAnnotations;public class Java8Test {    @Test    public void interfaceMethodShouldBeParseable() {        ParserTstUtil.parseJava18(UsesJavaStreams.class);    }    @Test    public void repeatableAnnotationsMethodShouldBeParseable() {        ParserTstUtil.parseJava18(UsesRepeatableAnnotations.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;public class AccessNodeTest {    public static class MyAccessNode extends AbstractJavaAccessNode {        public MyAccessNode(int i) {            super(i);        }        public MyAccessNode(JavaParser parser, int i) {            super(parser, i);        }    }    @Test    public void testModifiersOnClassDecl() {        Set<ASTClassOrInterfaceDeclaration> ops = getNodes(ASTClassOrInterfaceDeclaration.class, TEST1);        assertTrue(ops.iterator().next().isPublic());    }    private static final String TEST1 = "public class Foo {}";    @Test    public void testStatic() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not static.", node.isStatic());        node.setStatic(true);        assertTrue("Node set to static, not static.", node.isStatic());    }    @Test    public void testPublic() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not public.", node.isPublic());        node.setPublic(true);        assertTrue("Node set to public, not public.", node.isPublic());    }    @Test    public void testProtected() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not protected.", node.isProtected());        node.setProtected(true);        assertTrue("Node set to protected, not protected.", node.isProtected());    }    @Test    public void testPrivate() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not private.", node.isPrivate());        node.setPrivate(true);        assertTrue("Node set to private, not private.", node.isPrivate());    }    @Test    public void testFinal() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not final.", node.isFinal());        node.setFinal(true);        assertTrue("Node set to final, not final.", node.isFinal());    }    @Test    public void testSynchronized() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not synchronized.", node.isSynchronized());        node.setSynchronized(true);        assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());    }    @Test    public void testVolatile() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not volatile.", node.isVolatile());        node.setVolatile(true);        assertTrue("Node set to volatile, not volatile.", node.isVolatile());    }    @Test    public void testTransient() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not transient.", node.isTransient());        node.setTransient(true);        assertTrue("Node set to transient, not transient.", node.isTransient());    }    @Test    public void testNative() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not native.", node.isNative());        node.setNative(true);        assertTrue("Node set to native, not native.", node.isNative());    }    @Test    public void testAbstract() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not abstract.", node.isAbstract());        node.setAbstract(true);        assertTrue("Node set to abstract, not abstract.", node.isAbstract());    }    @Test    public void testStrict() {        AccessNode node = new MyAccessNode(1);        assertFalse("Node should default to not strict.", node.isStrictfp());        node.setStrictfp(true);        assertTrue("Node set to strict, not strict.", node.isStrictfp());    }    @Test    public void testPackagePrivate() {        AccessNode node = new MyAccessNode(1);        assertTrue("Node should default to package private.", node.isPackagePrivate());        node.setPrivate(true);        assertFalse("Node set to private, still package private.", node.isPackagePrivate());        node = new MyAccessNode(1);        node.setPublic(true);        assertFalse("Node set to public, still package private.", node.isPackagePrivate());        node = new MyAccessNode(1);        node.setProtected(true);        assertFalse("Node set to protected, still package private.", node.isPackagePrivate());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTPackageDeclarationTest {    private static final String PACKAGE_INFO_ANNOTATED = "@Deprecated" + PMD.EOL + "package net.sourceforge.pmd.foobar;"            + PMD.EOL;    /**     * Regression test for bug 3524607.     */    @Test    public void testPackageName() {        Set<ASTPackageDeclaration> nodes = getNodes(ASTPackageDeclaration.class, PACKAGE_INFO_ANNOTATED);        assertEquals(1, nodes.size());        ASTPackageDeclaration packageNode = nodes.iterator().next();        assertEquals("net.sourceforge.pmd.foobar", packageNode.getPackageNameImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava14;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.PMD;public class EncodingTest {    @Test    public void testDecodingOfUTF8() throws Exception {        ASTCompilationUnit acu = parseJava14(TEST_UTF8);        String methodName = acu.findDescendantsOfType(ASTMethodDeclarator.class).get(0).getImage();        assertEquals("é", methodName);    }    private static final String TEST_UTF8 = "class Foo {" + PMD.EOL + "  void é() {}" + PMD.EOL + "  void fiddle() {}"            + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import java.io.FileInputStream;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;public class Java10Test {    private static String loadSource(String name) {        try {            return IOUtils.toString(Java10Test.class.getResourceAsStream("jdkversiontests/java10/" + name),                    StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Test    public void testLocalVarInferenceBeforeJava10() {        // note, it can be parsed, but we'll have a ReferenceType of "var"        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("9",                loadSource("LocalVariableTypeInference.java"));        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        // first: var list = new ArrayList<String>();        ASTType type = localVars.get(0).getFirstChildOfType(ASTType.class);        assertEquals("var", type.getTypeImage());        assertEquals(1, type.jjtGetNumChildren());        ASTReferenceType referenceType = type.getFirstChildOfType(ASTReferenceType.class);        assertNotNull(referenceType);        assertEquals(1, referenceType.jjtGetNumChildren());        ASTClassOrInterfaceType classType = referenceType.getFirstChildOfType(ASTClassOrInterfaceType.class);        assertNotNull(classType);        assertEquals("var", classType.getImage());        // in that case, we don't have a class named "var", so the type will be null        assertNull(classType.getType());        assertNull(type.getType());        // check the type of the variable initializer's expression        ASTExpression initExpression = localVars.get(0)                .getFirstChildOfType(ASTVariableDeclarator.class)                .getFirstChildOfType(ASTVariableInitializer.class)                .getFirstChildOfType(ASTExpression.class);        assertSame("type should be ArrayList", ArrayList.class, initExpression.getType());    }    @Test    public void testLocalVarInferenceCanBeParsedJava10() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInference.java"));        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        // first: var list = new ArrayList<String>();        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be ArrayList", ArrayList.class, varDecl.getType());        assertEquals("type should be ArrayList<String>", JavaTypeDefinition.forClass(ArrayList.class, JavaTypeDefinition.forClass(String.class)),                varDecl.getTypeDefinition());        ASTVariableDeclaratorId varId = varDecl.getFirstChildOfType(ASTVariableDeclaratorId.class);        assertEquals("type should be equal", varDecl.getTypeDefinition(), varId.getTypeDefinition());        // second: var stream = list.stream();        assertNull(localVars.get(1).getTypeNode());        //ASTVariableDeclarator varDecl2 = localVars.get(1).getFirstChildOfType(ASTVariableDeclarator.class);        // TODO: return type of method call is unknown        // assertEquals("type should be Stream<String>", JavaTypeDefinition.forClass(Stream.class, JavaTypeDefinition.forClass(String.class)),        //         varDecl2.getTypeDefinition());        // third: var s = "Java 10";        assertNull(localVars.get(2).getTypeNode());        ASTVariableDeclarator varDecl3 = localVars.get(2).getFirstChildOfType(ASTVariableDeclarator.class);        assertEquals("type should be String", JavaTypeDefinition.forClass(String.class), varDecl3.getTypeDefinition());        ASTArgumentList argumentList = compilationUnit.getFirstDescendantOfType(ASTArgumentList.class);        ASTExpression expression3 = argumentList.getFirstChildOfType(ASTExpression.class);        assertEquals("type should be String", JavaTypeDefinition.forClass(String.class), expression3.getTypeDefinition());    }    @Test    public void testForLoopWithVar() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInferenceForLoop.java"));        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be int", Integer.TYPE, varDecl.getType());    }    @Test    public void testForLoopEnhancedWithVar() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInferenceForLoopEnhanced.java"));        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be String", String.class, varDecl.getType());    }    @Test    public void testForLoopEnhancedWithVar2() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInferenceForLoopEnhanced2.java"));        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(4, localVars.size());        assertNull(localVars.get(1).getTypeNode());        ASTVariableDeclarator varDecl2 = localVars.get(1).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be String", String.class, varDecl2.getType());        ASTVariableDeclaratorId varId2 = varDecl2.getFirstChildOfType(ASTVariableDeclaratorId.class);        assertSame("type should be String", String.class, varId2.getType());        assertNull(localVars.get(3).getTypeNode());        ASTVariableDeclarator varDecl4 = localVars.get(3).getFirstChildOfType(ASTVariableDeclarator.class);        assertSame("type should be int", Integer.TYPE, varDecl4.getType());    }    @Test    public void testTryWithResourcesWithVar() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInferenceTryWithResources.java"));        List<ASTResource> resources = compilationUnit.findDescendantsOfType(ASTResource.class);        assertEquals(1, resources.size());        assertNull(resources.get(0).getTypeNode());        ASTVariableDeclaratorId varId = resources.get(0).getVariableDeclaratorId();        assertSame("type should be FileInputStream", FileInputStream.class, varId.getType());    }    @Test    public void testTypeResNullPointer() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInference_typeres.java"));        Assert.assertNotNull(compilationUnit);    }    @Test    public void testVarAsIdentifier() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInference_varAsIdentifier.java"));        Assert.assertNotNull(compilationUnit);    }    @Test(expected = ParseException.class)    public void testVarAsTypeIdentifier() {        ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInference_varAsTypeIdentifier.java"));    }    @Test(expected = ParseException.class)    public void testVarAsAnnotationName() {        ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInference_varAsAnnotationName.java"));    }    @Test(expected = ParseException.class)    public void testVarAsEnumName() {        ParserTstUtil.parseAndTypeResolveJava("10",                loadSource("LocalVariableTypeInference_varAsEnumName.java"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;public class CommentTest {    @Test    public void testMultiLinesInSingleLine() {        String comment = "/* single line. */";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInSingleLineSimple() {        String comment = "// single line.";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInSingleLineFormal() {        String comment = "/** single line. */";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInMultiLine() {        String comment =                  "/*\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineCrLf() {        String comment =                  "/*\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineFormal() {        String comment =                  "/**\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineFormalCrLf() {        String comment =                  "/**\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineNoAsteriskEmpty() {        String comment =                  "/**\n"                + " * line 1\n"                + "line 2\n"                + "\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    private String filter(String comment) {        Token t = new Token();        t.image = comment;        Comment node = new Comment(t) {            @Override            public String getXPathNodeName() {                return "DummyComment";            }        };        return node.getFilteredComment();    }    private int lineCount(String filtered) {        return StringUtils.countMatches(filtered, PMD.EOL) + 1;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Test;public class CommentUtilTest {    @Test    public void testFindJavaDocTags() {        String formalComment =                  "/**\n"                + " * @see something\n"                + " * @author Author1\n"                + " * @author Author2\n"                + " * @param parm1 description\n"                + " */\n";        Map<String, Integer> javadocTagsIn = CommentUtil.javadocTagsIn(formalComment);        Assert.assertEquals(3, javadocTagsIn.size());        Assert.assertEquals(7, javadocTagsIn.get("see").intValue());        Assert.assertEquals("@see", formalComment.substring(7, 7 + 4));        Assert.assertEquals("@author", formalComment.substring(javadocTagsIn.get("author"),                javadocTagsIn.get("author") + "author".length() + 1));    }    @Test    public void testFindJavaDocTagsEmpty() {        Map<String, Integer> javadocTagsIn = CommentUtil.javadocTagsIn("");        Assert.assertEquals(0, javadocTagsIn.size());    }    @Test    public void testFindJavaDocTagsNull() {        Map<String, Integer> javadocTagsIn = CommentUtil.javadocTagsIn(null);        Assert.assertEquals(0, javadocTagsIn.size());    }    @Test    public void testMultiLinesInSingleLine() {        String comment = "/* single line. */";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(1, lines.size());        Assert.assertEquals("single line.", lines.get(0));    }    @Test    public void testMultiLinesInSingleLineSimple() {        String comment = "// single line.";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(1, lines.size());        Assert.assertEquals("single line.", lines.get(0));    }    @Test    public void testMultiLinesInSingleLineFormal() {        String comment = "/** single line. */";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(1, lines.size());        Assert.assertEquals("single line.", lines.get(0));    }    @Test    public void testMultiLinesInMultiLine() {        String comment =                  "/*\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineCrLf() {        String comment =                  "/*\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineFormal() {        String comment =                  "/**\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineFormalCrLf() {        String comment =                  "/**\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testMultiLinesInMultiLineNoAsteriskEmpty() {        String comment =                  "/**\n"                + " * line 1\n"                + "line 2\n"                + "\n"                + " */\n";        List<String> lines = CommentUtil.multiLinesIn(comment);        Assert.assertEquals(2, lines.size());        Assert.assertEquals("line 1", lines.get(0));        Assert.assertEquals("line 2", lines.get(1));    }    @Test    public void testTrim() {        List<String> lines = Arrays.asList("", "a", "", "");        List<String> trimmed = CommentUtil.trim(lines);        Assert.assertEquals(1, trimmed.size());        Assert.assertEquals("a", trimmed.get(0));    }    @Test    public void testTrimNotMiddle() {        List<String> lines = Arrays.asList("a", "b", "", "c");        List<String> trimmed = CommentUtil.trim(lines);        Assert.assertEquals(4, trimmed.size());        Assert.assertEquals("a", trimmed.get(0));        Assert.assertEquals("b", trimmed.get(1));        Assert.assertEquals("", trimmed.get(2));        Assert.assertEquals("c", trimmed.get(3));    }    @Test    public void testTrimEmpty() {        List<String> trimmed = CommentUtil.trim(new ArrayList<String>());        Assert.assertEquals(0, trimmed.size());    }    @Test    public void testTrimNull() {        List<String> trimmed = CommentUtil.trim(null);        Assert.assertEquals(0, trimmed.size());    }    @Test    public void testWordAfter() {        String wordAfter = CommentUtil.wordAfter("@param param1 Description", "@param".length());        Assert.assertEquals("param1", wordAfter);    }    @Test    public void testWordAfterPositionOutOfBounds() {        String wordAfter = CommentUtil.wordAfter("@param param1 Description", Integer.MAX_VALUE);        Assert.assertNull(wordAfter);    }    @Test    public void testWordAfterNull() {        String wordAfter = CommentUtil.wordAfter(null, 0);        Assert.assertNull(wordAfter);    }    @Test    public void testJavadocAfter() {        String javadocContentAfter = CommentUtil.javadocContentAfter("@param param1 The Description\n",                "@param param1".length());        Assert.assertEquals("The Description", javadocContentAfter);    }    @Test    public void testJavadocAfterOutOfBounds() {        String javadocContentAfter = CommentUtil.javadocContentAfter("@param param1 The Description\n",                Integer.MAX_VALUE);        Assert.assertNull(javadocContentAfter);    }    @Test    public void testJavadocAfterNull() {        String javadocContentAfter = CommentUtil.javadocContentAfter(null, 0);        Assert.assertNull(javadocContentAfter);    }    @Test    public void testJavadoc() {        String comment = "    /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "";        List<String> lines = CommentUtil.multiLinesIn(comment);        lines = CommentUtil.trim(lines);        for (String line : lines) {            Map<String, Integer> tags = CommentUtil.javadocTagsIn(line);            for (String tag : tags.keySet()) {                int pos = tags.get(tag) + tag.length() + 1;                String wordAfter = CommentUtil.wordAfter(line, pos);                pos = pos + wordAfter.length() + 1;                String description = CommentUtil.javadocContentAfter(line, pos);                if ("param".equals(tag)) {                    Assert.assertEquals("node", wordAfter); // the parameter name                    Assert.assertEquals("The node to check", description);                } else if ("return".equals(tag)) {                    Assert.assertEquals("True", wordAfter);                    Assert.assertEquals("if the metric can be computed", description);                }            }        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.ParserTstUtil;public class Java13Test {    private static String loadSource(String name) {        try {            return IOUtils.toString(Java13Test.class.getResourceAsStream("jdkversiontests/java13/" + name),                                    StandardCharsets.UTF_8)                .replaceAll("\\R", "\n"); // normalize line separators to \n        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Test    public void testSwitchExpressions() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("13-preview",                loadSource("SwitchExpressions.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchExpression switchExpression = compilationUnit.getFirstDescendantOfType(ASTSwitchExpression.class);        Assert.assertEquals(4, switchExpression.jjtGetNumChildren());        Assert.assertTrue(switchExpression.jjtGetChild(0) instanceof ASTExpression);        Assert.assertEquals(3, switchExpression.findChildrenOfType(ASTSwitchLabeledRule.class).size());        Assert.assertEquals(1, switchExpression.findChildrenOfType(ASTSwitchLabeledBlock.class).size());        Assert.assertEquals(1, switchExpression.findDescendantsOfType(ASTYieldStatement.class).size());        ASTYieldStatement yieldStatement = switchExpression.getFirstDescendantOfType(ASTYieldStatement.class);        Assert.assertEquals(Integer.TYPE, yieldStatement.getType());    }    @Test    public void testSwitchExpressionsYield() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("13-preview",                loadSource("SwitchExpressionsYield.java"));        Assert.assertNotNull(compilationUnit);        ASTSwitchExpression switchExpression = compilationUnit.getFirstDescendantOfType(ASTSwitchExpression.class);        Assert.assertEquals(11, switchExpression.jjtGetNumChildren());        Assert.assertTrue(switchExpression.jjtGetChild(0) instanceof ASTExpression);        Assert.assertEquals(5, switchExpression.findChildrenOfType(ASTSwitchLabel.class).size());        ASTYieldStatement yieldStatement = switchExpression.getFirstDescendantOfType(ASTYieldStatement.class);        Assert.assertEquals("SwitchExpressionsBreak.SIX", yieldStatement.getImage());        Assert.assertTrue(yieldStatement.jjtGetChild(0) instanceof ASTExpression);        ASTLocalVariableDeclaration localVar = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class)                .get(1);        ASTVariableDeclarator localVarDecl = localVar.getFirstChildOfType(ASTVariableDeclarator.class);        Assert.assertEquals(Integer.TYPE, localVarDecl.getType());        Assert.assertEquals(Integer.TYPE, switchExpression.getType());    }    @Test(expected = ParseException.class)    public void testSwitchExpressionsBeforeJava13() {        ParserTstUtil.parseAndTypeResolveJava("12", loadSource("SwitchExpressions.java"));    }    @Test    public void testTextBlocks() {        ASTCompilationUnit compilationUnit = ParserTstUtil.parseAndTypeResolveJava("13-preview", loadSource("TextBlocks.java"));        Assert.assertNotNull(compilationUnit);        List<ASTLiteral> literals = compilationUnit.findDescendantsOfType(ASTLiteral.class);        Assert.assertEquals(10, literals.size());        for (int i = 0; i < 8; i++) {            ASTLiteral literal = literals.get(i);            Assert.assertTrue(literal.isTextBlock());        }        Assert.assertEquals("\"\"\"\n"                                + "                <html>\n"                                + "                    <body>\n"                                + "                        <p>Hello, world</p>\n"                                + "                    </body>\n"                                + "                </html>\n"                                + "                \"\"\"",                            literals.get(0).getImage());        Assert.assertFalse(literals.get(8).isTextBlock());        Assert.assertTrue(literals.get(9).isTextBlock());    }    @Test(expected = ParseException.class)    public void testTextBlocksBeforeJava13() {        ParserTstUtil.parseAndTypeResolveJava("12", loadSource("TextBlocks.java"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTBooleanLiteralTest {    @Test    public void testTrue() {        Set<ASTBooleanLiteral> ops = getNodes(ASTBooleanLiteral.class, TEST1);        ASTBooleanLiteral b = ops.iterator().next();        assertTrue(b.isTrue());    }    @Test    public void testFalse() {        Set<ASTBooleanLiteral> ops = getNodes(ASTBooleanLiteral.class, TEST2);        ASTBooleanLiteral b = ops.iterator().next();        assertFalse(b.isTrue());    }    private static final String TEST1 = "class Foo { " + PMD.EOL + " boolean bar = true; " + PMD.EOL + "} ";    private static final String TEST2 = "class Foo { " + PMD.EOL + " boolean bar = false; " + PMD.EOL + "} ";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Assert;import org.junit.Test;public class FormalCommentTest {    @Test    public void testJavadocTagsAsChildren() {        String comment = "    /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "";        Token token = new Token();        token.image = comment;        FormalComment commentNode = new FormalComment(token);        Assert.assertEquals(2, commentNode.jjtGetNumChildren());        JavadocElement paramTag = (JavadocElement) commentNode.jjtGetChild(0);        Assert.assertEquals("param", paramTag.tag().label);        JavadocElement returnTag = (JavadocElement) commentNode.jjtGetChild(1);        Assert.assertEquals("return", returnTag.tag().label);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTSwitchLabelTest {    @Test    public void testDefaultOff() {        Set<ASTSwitchLabel> ops = getNodes(ASTSwitchLabel.class, TEST1);        assertFalse(ops.iterator().next().isDefault());    }    @Test    public void testDefaultSet() {        Set<ASTSwitchLabel> ops = getNodes(ASTSwitchLabel.class, TEST2);        assertTrue(ops.iterator().next().isDefault());    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  switch (x) {"            + PMD.EOL + "   case 1: y = 2;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  switch (x) {"            + PMD.EOL + "   default: y = 2;" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava14;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.util.Iterator;import java.util.List;import java.util.Set;import org.jaxen.JaxenException;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.ast.Node;public class SimpleNodeTest {    @Test    public void testMethodDiffLines() {        Set<ASTMethodDeclaration> methods = getNodes(ASTMethodDeclaration.class, METHOD_DIFF_LINES);        verifyNode(methods.iterator().next(), 2, 9, 4, 2);    }    @Test    public void testMethodSameLine() {        Set<ASTMethodDeclaration> methods = getNodes(ASTMethodDeclaration.class, METHOD_SAME_LINE);        verifyNode(methods.iterator().next(), 2, 9, 2, 21);    }    @Test    public void testNoLookahead() {        String code = NO_LOOKAHEAD; // 1, 8 -> 1, 20        Set<ASTClassOrInterfaceDeclaration> uCD = getNodes(ASTClassOrInterfaceDeclaration.class, code);        verifyNode(uCD.iterator().next(), 1, 8, 1, 20);    }    @Test    public void testHasExplicitExtends() {        String code = HAS_EXPLICIT_EXTENDS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertTrue(ucd.jjtGetChild(0) instanceof ASTExtendsList);    }    @Test    public void testNoExplicitExtends() {        String code = NO_EXPLICIT_EXTENDS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertFalse(ucd.jjtGetChild(0) instanceof ASTExtendsList);    }    @Test    public void testHasExplicitImplements() {        String code = HAS_EXPLICIT_IMPLEMENTS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertTrue(ucd.jjtGetChild(0) instanceof ASTImplementsList);    }    @Test    public void testNoExplicitImplements() {        String code = NO_EXPLICIT_IMPLEMENTS;        ASTClassOrInterfaceDeclaration ucd = getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next();        assertFalse(ucd.jjtGetChild(0) instanceof ASTImplementsList);    }    @Test    public void testColumnsOnQualifiedName() {        Set<ASTName> name = getNodes(ASTName.class, QUALIFIED_NAME);        Iterator<ASTName> i = name.iterator();        while (i.hasNext()) {            Node node = i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 1, 19);            }        }    }    @Test    public void testLineNumbersForNameSplitOverTwoLines() {        Set<ASTName> name = getNodes(ASTName.class, BROKEN_LINE_IN_NAME);        Iterator<ASTName> i = name.iterator();        while (i.hasNext()) {            Node node = i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 2, 4);            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 18);            }        }    }    @Test    public void testLineNumbersAreSetOnAllSiblings() {        for (ASTBlock b : getNodes(ASTBlock.class, LINE_NUMBERS_ON_SIBLINGS)) {            assertTrue(b.getBeginLine() > 0);        }        for (ASTVariableInitializer b : getNodes(ASTVariableInitializer.class, LINE_NUMBERS_ON_SIBLINGS)) {            assertTrue(b.getBeginLine() > 0);        }        for (ASTExpression b : getNodes(ASTExpression.class, LINE_NUMBERS_ON_SIBLINGS)) {            assertTrue(b.getBeginLine() > 0);        }    }    @Test    public void testFindDescendantsOfType() {        ASTBlock block = new ASTBlock(2);        block.jjtAddChild(new ASTReturnStatement(1), 0);        assertEquals(1, block.findDescendantsOfType(ASTReturnStatement.class).size());    }    @Test    public void testFindDescendantsOfTypeMultiple() {        ASTBlock block = new ASTBlock(1);        block.jjtAddChild(new ASTBlockStatement(2), 0);        block.jjtAddChild(new ASTBlockStatement(3), 1);        List<ASTBlockStatement> nodes = block.findDescendantsOfType(ASTBlockStatement.class);        assertEquals(2, nodes.size());    }    @Test    public void testFindDescendantsOfTypeRecurse() {        ASTBlock block = new ASTBlock(1);        ASTBlock childBlock = new ASTBlock(2);        block.jjtAddChild(childBlock, 0);        childBlock.jjtAddChild(new ASTMethodDeclaration(3), 0);        List<ASTMethodDeclaration> nodes = block.findDescendantsOfType(ASTMethodDeclaration.class);        assertEquals(1, nodes.size());    }    @Test    public void testGetFirstChild() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstDescendantOfType(ASTStatement.class);        assertNotNull(n);        assertTrue(n instanceof ASTStatement);        assertEquals(x, n);    }    @Test    public void testGetFirstChildNested() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        x.jjtAddChild(x1, 0);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstDescendantOfType(ASTAssignmentOperator.class);        assertNotNull(n);        assertTrue(n instanceof ASTAssignmentOperator);        assertEquals(x1, n);    }    @Test    public void testGetFirstChildNestedDeeper() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        ASTName x2 = new ASTName(5);        x.jjtAddChild(x1, 0);        x1.jjtAddChild(x2, 0);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstDescendantOfType(ASTName.class);        assertNotNull(n);        assertTrue(n instanceof ASTName);        assertEquals(x2, n);    }    @Test    public void testParentMethods() {        ASTCompilationUnit u = parseJava14(TEST1);        ASTMethodDeclarator d = u.getFirstDescendantOfType(ASTMethodDeclarator.class);        assertSame("getFirstParentOfType ASTMethodDeclaration", d.jjtGetParent(),                d.getFirstParentOfType(ASTMethodDeclaration.class));        assertNull("getFirstParentOfType ASTName", d.getFirstParentOfType(ASTName.class));        assertSame("getNthParent 1", d.jjtGetParent(), d.getNthParent(1));        assertSame("getNthParent 2", d.jjtGetParent().jjtGetParent(), d.getNthParent(2));        assertSame("getNthParent 6", u, d.getNthParent(6));        assertNull("getNthParent 7", d.getNthParent(7));        assertNull("getNthParent 8", d.getNthParent(8));    }    private static final String TEST1 = "public class Test {" + PMD.EOL + "  void bar(String s) {" + PMD.EOL            + "   s = s.toLowerCase();" + PMD.EOL + "  }" + PMD.EOL + "}";    @Ignore    @Test    public void testContainsNoInner() {        ASTCompilationUnit c = getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER).iterator().next();        List<ASTFieldDeclaration> res = c.findDescendantsOfType(ASTFieldDeclaration.class);        assertTrue(res.isEmpty());        /*         * String expectedXml =         * "<CompilationUnit BeginColumn=\"1\" BeginLine=\"5\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<TypeDeclaration BeginColumn=\"1\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"8\" BeginLine=\"1\" EndColumn=\"1\" "         * +         * "EndLine=\"5\" Final=\"false\" Image=\"Test\" Interface=\"false\" Native=\"false\" Nested=\"false\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">"         * +         * "<ClassOrInterfaceBody BeginColumn=\"19\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"3\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">"         * +         * "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"10\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\" Final=\"false\" "         * +         * "Image=\"Inner\" Interface=\"false\" Native=\"false\" Nested=\"true\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" "         * +         * "Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">"         * +         * "<ClassOrInterfaceBody BeginColumn=\"22\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">"         * +         * "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\">"         * +         * "<FieldDeclaration Abstract=\"false\" Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\" Final=\"false\" Native=\"false\" PackagePrivate=\"true\" Private=\"false\" Protected=\"false\" Public=\"false\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" VariableName=\"foo\" Volatile=\"false\"><Type Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"6\" EndLine=\"3\">"         * +         * "<PrimitiveType Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" Boolean=\"false\" EndColumn=\"6\" EndLine=\"3\" Image=\"int\"/>"         * + "</Type>" +         * "<VariableDeclarator BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\">"         * +         * "<VariableDeclaratorId Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\" ExceptionBlockParameter=\"false\" Image=\"foo\"/>"         * +         * "</VariableDeclarator></FieldDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody>"         * +         * "</ClassOrInterfaceDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody></ClassOrInterfaceDeclaration>"         * + "</TypeDeclaration></CompilationUnit>"; assertEquals( expectedXml,         * getXmlString( c ) );         */ }    @Test    public void testContainsNoInnerWithAnonInner() {        ASTCompilationUnit c = getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER_WITH_ANON_INNER).iterator().next();        List<ASTFieldDeclaration> res = c.findDescendantsOfType(ASTFieldDeclaration.class);        assertTrue(res.isEmpty());    }    @Test    public void testContainsChildOfType() {        ASTClassOrInterfaceDeclaration c = getNodes(ASTClassOrInterfaceDeclaration.class, CONTAINS_CHILDREN_OF_TYPE)                .iterator().next();        assertTrue(c.hasDescendantOfType(ASTFieldDeclaration.class));    }    @Test    public void testXPathNodeSelect() throws JaxenException {        ASTClassOrInterfaceDeclaration c = getNodes(ASTClassOrInterfaceDeclaration.class, TEST_XPATH).iterator().next();        List<Node> nodes = c.findChildNodesWithXPath("//FieldDeclaration");        assertEquals(2, nodes.size());        assertTrue(nodes.get(0) instanceof ASTFieldDeclaration);        assertTrue(c.hasDescendantMatchingXPath("//FieldDeclaration"));        assertFalse(c.hasDescendantMatchingXPath("//MethodDeclaration"));    }    @Test    public void testUserData() {        ASTClassOrInterfaceDeclaration c = getNodes(ASTClassOrInterfaceDeclaration.class, HAS_EXPLICIT_EXTENDS)                .iterator().next();        assertNull(c.getUserData());        c.setUserData("foo");        assertEquals("foo", c.getUserData());        c.setUserData(null);        assertNull(c.getUserData());    }    private void verifyNode(Node node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Unexpected beginning line: ", beginLine, node.getBeginLine());        assertEquals("Unexpected beginning column: ", beginCol, node.getBeginColumn());        assertEquals("Unexpected ending line:", endLine, node.getEndLine());        assertEquals("Unexpected ending column:", endCol, node.getEndColumn());    }    private static final String HAS_EXPLICIT_EXTENDS = "public class Test extends Foo {}";    private static final String NO_EXPLICIT_EXTENDS = "public class Test {}";    private static final String HAS_EXPLICIT_IMPLEMENTS = "public class Test implements Foo {}";    private static final String NO_EXPLICIT_IMPLEMENTS = "public class Test {}";    private static final String METHOD_SAME_LINE = "public class Test {" + PMD.EOL + " public void foo() {}" + PMD.EOL            + "}";    private static final String QUALIFIED_NAME = "import java.io.File;" + PMD.EOL + "public class Foo{}";    private static final String BROKEN_LINE_IN_NAME = "import java.io." + PMD.EOL + "File;" + PMD.EOL            + "public class Foo{}";    private static final String LINE_NUMBERS_ON_SIBLINGS = "public class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL            + "  try {" + PMD.EOL + "  } catch (Exception1 e) {" + PMD.EOL + "   int x =2;" + PMD.EOL + "  }" + PMD.EOL            + " if (x != null) {}" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String NO_LOOKAHEAD = "public class Foo { }";    private static final String METHOD_DIFF_LINES = "public class Test {" + PMD.EOL + " public void foo() {" + PMD.EOL            + "  int x;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String CONTAINS_CHILDREN_OF_TYPE = "public class Test {" + PMD.EOL + "  int x;" + PMD.EOL            + "}";    private static final String CONTAINS_NO_INNER = "public class Test {" + PMD.EOL + "  public class Inner {" + PMD.EOL            + "   int foo;" + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String CONTAINS_NO_INNER_WITH_ANON_INNER = "public class Test {" + PMD.EOL + "  void bar() {"            + PMD.EOL + "   foo(new Fuz() { int x = 2;});" + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String TEST_XPATH = "public class Test {" + PMD.EOL + "  int x = 2;" + PMD.EOL            + "  int y = 42;" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava13;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava14;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava15;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava17;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava18;import static net.sourceforge.pmd.lang.java.ParserTstUtil.parseJava9;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Test;public class JDKVersionTest {    private static String loadSource(String name) {        try {            return IOUtils.toString(JDKVersionTest.class.getResourceAsStream("jdkversiontests/" + name),                    StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    // enum keyword/identifier    @Test(expected = ParseException.class)    public void testEnumAsKeywordShouldFailWith14() {        parseJava15(loadSource("jdk14_enum.java"));    }    @Test    public void testEnumAsIdentifierShouldPassWith14() {        parseJava14(loadSource("jdk14_enum.java"));    }    @Test    public void testEnumAsKeywordShouldPassWith15() {        parseJava15(loadSource("jdk15_enum.java"));    }    @Test(expected = ParseException.class)    public void testEnumAsIdentifierShouldFailWith15() {        parseJava15(loadSource("jdk14_enum.java"));    }    // enum keyword/identifier    // assert keyword/identifier    @Test    public void testAssertAsKeywordVariantsSucceedWith14() {        parseJava14(loadSource("assert_test1.java"));        parseJava14(loadSource("assert_test2.java"));        parseJava14(loadSource("assert_test3.java"));        parseJava14(loadSource("assert_test4.java"));    }    @Test(expected = ParseException.class)    public void testAssertAsVariableDeclIdentifierFailsWith14() {        parseJava14(loadSource("assert_test5.java"));    }    @Test(expected = ParseException.class)    public void testAssertAsMethodNameIdentifierFailsWith14() {        parseJava14(loadSource("assert_test7.java"));    }    @Test    public void testAssertAsIdentifierSucceedsWith13() {        parseJava13(loadSource("assert_test5.java"));    }    @Test(expected = ParseException.class)    public void testAssertAsKeywordFailsWith13() {        parseJava13(loadSource("assert_test6.java"));    }    // assert keyword/identifier    @Test    public void testVarargsShouldPassWith15() {        parseJava15(loadSource("jdk15_varargs.java"));    }    @Test(expected = ParseException.class)    public void testVarargsShouldFailWith14() {        parseJava14(loadSource("jdk15_varargs.java"));    }    @Test    public void testJDK15ForLoopSyntaxShouldPassWith15() {        parseJava15(loadSource("jdk15_forloop.java"));    }    @Test    public void testJDK15ForLoopSyntaxWithModifiers() {        parseJava15(loadSource("jdk15_forloop_with_modifier.java"));    }    @Test(expected = ParseException.class)    public void testJDK15ForLoopShouldFailWith14() {        parseJava14(loadSource("jdk15_forloop.java"));    }    @Test    public void testJDK15GenericsSyntaxShouldPassWith15() {        parseJava15(loadSource("jdk15_generics.java"));    }    @Test    public void testVariousParserBugs() {        parseJava15(loadSource("fields_bug.java"));        parseJava15(loadSource("gt_bug.java"));        parseJava15(loadSource("annotations_bug.java"));        parseJava15(loadSource("constant_field_in_annotation_bug.java"));        parseJava15(loadSource("generic_in_field.java"));    }    @Test    public void testNestedClassInMethodBug() {        parseJava15(loadSource("inner_bug.java"));        parseJava15(loadSource("inner_bug2.java"));    }    @Test    public void testGenericsInMethodCall() {        parseJava15(loadSource("generic_in_method_call.java"));    }    @Test    public void testGenericINAnnotation() {        parseJava15(loadSource("generic_in_annotation.java"));    }    @Test    public void testGenericReturnType() {        parseJava15(loadSource("generic_return_type.java"));    }    @Test    public void testMultipleGenerics() {        // See java/lang/concurrent/CopyOnWriteArraySet        parseJava15(loadSource("funky_generics.java"));        // See java/lang/concurrent/ConcurrentHashMap        parseJava15(loadSource("multiple_generics.java"));    }    @Test    public void testAnnotatedParams() {        parseJava15(loadSource("annotated_params.java"));    }    @Test    public void testAnnotatedLocals() {        parseJava15(loadSource("annotated_locals.java"));    }    @Test    public void testAssertAsIdentifierSucceedsWith13Test2() {        parseJava13(loadSource("assert_test5_a.java"));    }    @Test    public final void testBinaryAndUnderscoresInNumericalLiterals() {        parseJava17(loadSource("jdk17_numerical_literals.java"));    }    @Test    public final void testStringInSwitch() {        parseJava17(loadSource("jdk17_string_in_switch.java"));    }    @Test    public final void testGenericDiamond() {        parseJava17(loadSource("jdk17_generic_diamond.java"));    }    @Test    public final void testTryWithResources() {        parseJava17(loadSource("jdk17_try_with_resources.java"));    }    @Test    public final void testTryWithResourcesSemi() {        parseJava17(loadSource("jdk17_try_with_resources_semi.java"));    }    @Test    public final void testTryWithResourcesMulti() {        parseJava17(loadSource("jdk17_try_with_resources_multi.java"));    }    @Test    public final void testTryWithResourcesWithAnnotations() {        parseJava17(loadSource("jdk17_try_with_resources_with_annotations.java"));    }    @Test    public final void testMulticatch() {        parseJava17(loadSource("jdk17_multicatch.java"));    }    @Test    public final void testMulticatchWithAnnotations() {        parseJava17(loadSource("jdk17_multicatch_with_annotations.java"));    }    @Test(expected = ParseException.class)    public final void jdk9PrivateInterfaceMethodsInJava18() {        parseJava18(loadSource("jdk9_private_interface_methods.java"));    }    @Test    public final void testPrivateMethods() {        parseJava18("public class Foo { private void bar() { } }");    }    @Test    public final void testNestedPrivateMethods() {        parseJava18("public interface Baz { public static class Foo { private void bar() { } } }");    }    @Test    public final void jdk9PrivateInterfaceMethods() {        parseJava9(loadSource("jdk9_private_interface_methods.java"));    }    @Test    public final void jdk9InvalidIdentifierInJava18() {        parseJava18(loadSource("jdk9_invalid_identifier.java"));    }    @Test(expected = ParseException.class)    public final void jdk9InvalidIdentifier() {        parseJava9(loadSource("jdk9_invalid_identifier.java"));    }    @Test(expected = ParseException.class)    public final void jdk9AnonymousDiamondInJava8() {        parseJava18(loadSource("jdk9_anonymous_diamond.java"));    }    @Test    public final void jdk9AnonymousDiamond() {        parseJava9(loadSource("jdk9_anonymous_diamond.java"));    }    @Test(expected = ParseException.class)    public final void jdk9ModuleInfoInJava8() {        parseJava18(loadSource("jdk9_module_info.java"));    }    @Test    public final void jdk9ModuleInfo() {        parseJava9(loadSource("jdk9_module_info.java"));    }    @Test    public void testAnnotatedModule() {        parseJava9(loadSource("jdk9_module_info_with_annot.java"));    }    @Test(expected = ParseException.class)    public final void jdk9TryWithResourcesInJava8() {        parseJava18(loadSource("jdk9_try_with_resources.java"));    }    @Test    public final void jdk9TryWithResources() {        parseJava9(loadSource("jdk9_try_with_resources.java"));    }    @Test    public final void jdk7PrivateMethodInnerClassInterface1() {        ASTCompilationUnit acu = parseJava17(loadSource("private_method_in_inner_class_interface1.java"));        List<ASTMethodDeclaration> methods = acu.findDescendantsOfType(ASTMethodDeclaration.class, true);        assertEquals(3, methods.size());        for (ASTMethodDeclaration method : methods) {            assertFalse(method.isInterfaceMember());        }    }    @Test    public final void jdk7PrivateMethodInnerClassInterface2() {        try {            ASTCompilationUnit acu = parseJava17(loadSource("private_method_in_inner_class_interface2.java"));            fail("Expected exception");        } catch (ParseException e) {            assertTrue(e.getMessage().startsWith("Line 19"));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.qname.JavaOperationQualifiedName;import net.sourceforge.pmd.lang.java.qname.JavaTypeQualifiedName;import net.sourceforge.pmd.lang.java.qname.QualifiedNameFactory;/** * @author Clément Fournier */public class JavaQualifiedNameTest {    private <T> List<T> getNodes(Class<T> nodeType, String source) {        return ParserTstUtil.getOrderedNodes(nodeType, source);    }    @Test    public void testEmptyPackage() {        final String TEST = "class Foo {}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("Foo", qname.toString());            assertTrue(qname.getPackageList().isEmpty());            assertTrue(qname.isUnnamedPackage());            assertEquals(1, qname.getClassList().size());        }    }    @Test    public void testPackage() {        final String TEST = "package foo.bar; class Bzaz{}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class,                                                             TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Bzaz", qname.toString());            assertEquals(2, qname.getPackageList().size());            assertEquals(1, qname.getClassList().size());        }    }    @Test    public void testNestedClass() {        final String TEST = "package foo.bar; class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            switch (coid.getImage()) {            case "Foo":                assertEquals("foo.bar.Bzaz$Bor$Foo",                             qname.toString());                assertEquals(3, qname.getClassList().size());                break;            default:                break;            }        }    }    @Test    public void testNestedEnum() {        final String TEST = "package foo.bar; class Foo { enum Bzaz{HOO;}}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Foo$Bzaz", qname.toString());            assertEquals(2, qname.getPackageList().size());            assertEquals(2, qname.getClassList().size());        }    }    @Test    public void testEnum() {        final String TEST = "package foo.bar; enum Bzaz{HOO;}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Bzaz", qname.toString());            assertEquals(2, qname.getPackageList().size());            assertEquals(1, qname.getClassList().size());        }    }    @Test    public void testEnumMethodMember() {        final String TEST = "package foo.bar; enum Bzaz{HOO; void foo(){}}";        List<ASTMethodDeclaration> nodes = getNodes(ASTMethodDeclaration.class, TEST);        for (ASTMethodDeclaration coid : nodes) {            JavaOperationQualifiedName qname = coid.getQualifiedName();            assertEquals("foo.bar.Bzaz#foo()", qname.toString());            assertEquals(2, qname.getClassName().getPackageList().size());            assertEquals(1, qname.getClassName().getClassList().size());            assertEquals("foo()", qname.getOperation());        }    }    @Test    public void testNestedEmptyPackage() {        final String TEST = "class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            JavaTypeQualifiedName qname = coid.getQualifiedName();            switch (coid.getImage()) {            case "Foo":                assertEquals("Bzaz$Bor$Foo",                             qname.toString());                assertTrue(qname.getPackageList().isEmpty());                assertTrue(qname.isUnnamedPackage());                assertEquals(3, qname.getClassList().size());                break;            default:                break;            }        }    }    @Test    public void testMethod() {        final String TEST = "package bar; class Bzaz{ public void foo(){}}";        List<ASTMethodDeclaration> nodes = getNodes(ASTMethodDeclaration.class, TEST);        for (ASTMethodDeclaration declaration : nodes) {            JavaOperationQualifiedName qname = declaration.getQualifiedName();            assertEquals("bar.Bzaz#foo()", qname.toString());            assertNotNull(qname.getOperation());            assertEquals("foo()", qname.getOperation());        }    }    @Test    public void testConstructor() {        final String TEST = "package bar; class Bzaz{ public Bzaz(){}}";        List<ASTConstructorDeclaration> nodes = getNodes(ASTConstructorDeclaration.class, TEST);        for (ASTConstructorDeclaration declaration : nodes) {            JavaOperationQualifiedName qname = declaration.getQualifiedName();            assertEquals("bar.Bzaz#Bzaz()",                         qname.toString());            assertNotNull(qname.getOperation());            assertEquals("Bzaz()", qname.getOperation());        }    }    @Test    public void testConstructorWithParams() {        final String TEST = "package bar; class Bzaz{ public Bzaz(int j, String k){}}";        List<ASTConstructorDeclaration> nodes = getNodes(ASTConstructorDeclaration.class, TEST);        for (ASTConstructorDeclaration declaration : nodes) {            JavaOperationQualifiedName qname = declaration.getQualifiedName();            assertEquals("bar.Bzaz#Bzaz(int, String)", qname.toString());            assertNotNull(qname.getOperation());            assertEquals("Bzaz(int, String)", qname.getOperation());        }    }    @Test    public void testConstructorOverload() {        final String TEST = "package bar; class Bzaz{ public Bzaz(int j) {} public Bzaz(int j, String k){}}";        List<ASTConstructorDeclaration> nodes = getNodes(ASTConstructorDeclaration.class,                                                        TEST);        ASTConstructorDeclaration[] arr = nodes.toArray(new ASTConstructorDeclaration[2]);        assertNotEquals(arr[0].getQualifiedName(), arr[1].getQualifiedName());    }    @Test    public void testMethodOverload() {        final String TEST = "package bar; class Bzaz{ public void foo(String j) {} "                + "public void foo(int j){} public void foo(double k){}}";        List<ASTMethodDeclaration> nodes = getNodes(ASTMethodDeclaration.class, TEST);        ASTMethodDeclaration[] arr = nodes.toArray(new ASTMethodDeclaration[3]);        assertNotEquals(arr[0].getQualifiedName(), arr[1].getQualifiedName());        assertNotEquals(arr[1].getQualifiedName(), arr[2].getQualifiedName());    }    @Test    public void testParseClass() {        JavaTypeQualifiedName outer = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz");        JavaTypeQualifiedName nested = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz$Bolg");        assertEquals(1, outer.getClassList().size());        assertEquals("Bzaz", outer.getClassList().get(0));        assertEquals(2, nested.getClassList().size());        assertEquals("Bzaz", nested.getClassList().get(0));        assertEquals("Bolg", nested.getClassList().get(1));    }    @Test    public void testParsePackages() {        JavaTypeQualifiedName packs = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz$Bolg");        JavaTypeQualifiedName nopacks = (JavaTypeQualifiedName) QualifiedNameFactory.ofString("Bzaz");        assertNotNull(packs.getPackageList());        assertEquals("foo", packs.getPackageList().get(0));        assertEquals("bar", packs.getPackageList().get(1));        assertTrue(nopacks.getPackageList().isEmpty());    }    @Test    public void testParseOperation() {        JavaOperationQualifiedName noparams = (JavaOperationQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz$Bolg#bar()");        JavaOperationQualifiedName params = (JavaOperationQualifiedName) QualifiedNameFactory.ofString("foo.bar.Bzaz#bar(String, int)");        assertEquals("bar()", noparams.getOperation());        assertEquals("bar(String, int)", params.getOperation());    }    @Test    public void testParseLocalClasses() {        final String SIMPLE = "foo.bar.Bzaz$1Local";        final String NESTED = "foo.Bar$1Local$Nested";        JavaTypeQualifiedName simple = (JavaTypeQualifiedName) QualifiedNameFactory.ofString(SIMPLE);        JavaTypeQualifiedName nested = (JavaTypeQualifiedName) QualifiedNameFactory.ofString(NESTED);        assertNotNull(simple);        assertTrue(simple.isLocalClass());        assertFalse(simple.isAnonymousClass());        assertNotNull(nested);        assertFalse(nested.isLocalClass());        assertFalse(simple.isAnonymousClass());        assertEquals(SIMPLE, simple.toString());        assertEquals(NESTED, nested.toString());    }    @Test    public void testParseAnonymousClass() {        final String SIMPLE = "Bzaz$12$13";        JavaTypeQualifiedName simple = (JavaTypeQualifiedName) QualifiedNameFactory.ofString(SIMPLE);        assertNotNull(simple);        assertTrue(simple.isAnonymousClass());        assertFalse(simple.isLocalClass());        assertEquals("12", simple.getClassList().get(1));        assertEquals("13", simple.getClassList().get(2));        assertEquals(SIMPLE, simple.toString());    }    @Test    public void testParseLambdaName() {        final String IN_LAMBDA = "foo.bar.Bzaz$1Local#lambda$null$12";        final String STATIC = "foo.bar.Bzaz#lambda$static$12";        final String NEW = "foo.bar.Bzaz#lambda$new$1";        final String IN_METHOD = "Bzaz#lambda$myMethod$4";        for (String s : Arrays.asList(IN_LAMBDA, STATIC, NEW, IN_METHOD)) {            JavaOperationQualifiedName qname = (JavaOperationQualifiedName) QualifiedNameFactory.ofString(s);            assertNotNull(qname);            assertTrue(qname.isLambda());            assertEquals(s, qname.toString());            assertEquals(qname, QualifiedNameFactory.ofString(qname.toString()));        }    }    @Test    public void testParseLambdaInEnumConstant() {        final String LAMBA_IN_ENUM_CONSTANT = "package foo; import java.util.function.Function; enum Bar { CONST(e -> e); Bar(Function<Object,Object> o) {} }";        final String QNAME = "foo.Bar#lambda$static$0";        ASTLambdaExpression node = getNodes(ASTLambdaExpression.class, LAMBA_IN_ENUM_CONSTANT).get(0);        assertNotNull(node);        assertEquals(QualifiedNameFactory.ofString(QNAME), node.getQualifiedName());    }    @Test    public void testParseMalformed() {        assertNull(QualifiedNameFactory.ofString(".foo.bar.Bzaz"));        assertNull(QualifiedNameFactory.ofString("foo.bar."));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#foo"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz()"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#foo(String,)"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#foo(String , int)"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#lambda$static$23(String)"));        assertNull(QualifiedNameFactory.ofString("foo.bar.Bzaz#lambda$static$"));    }    @Test    public void testSimpleLocalClass() {        final String TEST = "package bar; class Boron { public void foo(String j) { class Local {} } }";        List<ASTClassOrInterfaceDeclaration> classes                = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, TEST);        JavaQualifiedName qname = QualifiedNameFactory.ofString("bar.Boron$1Local");        assertEquals(qname, classes.get(1).getQualifiedName());    }    @Test    public void testLocalClassNameClash() {        final String TEST = "package bar; class Bzaz{ void foo() { class Local {} } {// initializer\n class Local {}}}";        List<ASTClassOrInterfaceDeclaration> classes                = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertNotEquals(classes.get(1).getQualifiedName(), classes.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("bar.Bzaz$1Local"), classes.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("bar.Bzaz$2Local"), classes.get(2).getQualifiedName());    }    @Test    public void testLocalClassDeepNesting() {        final String TEST                = "class Bzaz{ void foo() { "                + "  class Local { "                + "    class Nested {"                + "      {"                + "        class InnerLocal{}"                + "      }"                + "    }"                + "  }"                + "}}";        List<ASTClassOrInterfaceDeclaration> classes                = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertNotEquals(classes.get(1).getQualifiedName(), classes.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local"), classes.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local$Nested"), classes.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local$Nested$1InnerLocal"), classes.get(3).getQualifiedName());    }    @Test    public void testAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() { "                + "  new Runnable() {"                + "      public void run() {}"                + "  };"                + "}}";        List<ASTAllocationExpression> classes = ParserTstUtil.getOrderedNodes(ASTAllocationExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz$1"), classes.get(0).getQualifiedName());        assertFalse(classes.get(0).getQualifiedName().isLocalClass());        assertTrue(classes.get(0).getQualifiedName().isAnonymousClass());        assertTrue("1".equals(classes.get(0).getQualifiedName().getClassSimpleName()));    }    @Test    public void testMultipleAnonymousClasses() {        final String TEST                = "class Bzaz{ void foo() { "                + "  new Runnable() {"                + "      public void run() {}"                + "  };"                + "  new Runnable() {"                + "      public void run() {}"                + "  };"                + "}}";        List<ASTAllocationExpression> classes = ParserTstUtil.getOrderedNodes(ASTAllocationExpression.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals(QualifiedNameFactory.ofString("Bzaz$1"), classes.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$2"), classes.get(1).getQualifiedName());    }    @Test    public void testNestedAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() {"                + "  new Runnable() {"                + "    public void run() {"                + "      new Runnable() {"                + "        public void run() {}"                + "      };"                + "    }"                + "  };"                + "}}";        List<ASTAllocationExpression> classes = ParserTstUtil.getOrderedNodes(ASTAllocationExpression.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals(QualifiedNameFactory.ofString("Bzaz$1"), classes.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1$1"), classes.get(1).getQualifiedName());    }    @Test    public void testLocalInAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() {"                + "  new Runnable() {"                + "    public void run() {"                + "      class FooRunnable {}"                + "    }"                + "  };"                + "}}";        List<ASTClassOrInterfaceDeclaration> classes = ParserTstUtil.getOrderedNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertTrue(classes.get(1).isLocal());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1$1FooRunnable"), classes.get(1).getQualifiedName());    }    @Test    public void testLambdaInStaticInitializer() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  static {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$0"), lambdas.get(0).getQualifiedName());    }    @Test    public void testLambdaInInitializerAndConstructor() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public Bzaz() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$1"), lambdas.get(1).getQualifiedName());    }    @Test    public void testLambdaField() {        final String TEST                = "import java.util.function.*;"                + "public class Bzaz { "                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     public static Consumer<String> k = s -> {"                + "         System.out.println(s);"                + "     };"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$1"), lambdas.get(1).getQualifiedName());    }    @Test    public void testLambdaInterfaceField() {        final String TEST                = "import java.util.function.*;"                + "public interface Bzaz { "                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     public static Consumer<String> k = s -> {"                + "         System.out.println(s);"                + "     };"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$1"), lambdas.get(1).getQualifiedName());    }    @Test    public void testLambdaLocalClassField() {        final String TEST                = "import java.util.function.*;"                + "public class Bzaz { "                + "  public void boo() {"                + "     class Local {"                + "         Consumer<String> l = s -> {"                + "             System.out.println(s);"                + "         };"                + "     }"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz$1Local#lambda$Local$0"), lambdas.get(0).getQualifiedName());    }    @Test    public void testLambdaAnonymousClassField() {        final String TEST                = "import java.util.function.*;"                + "public class Bzaz { "                + "  public void boo() {"                + "     new Anonymous() {"                + "         Consumer<String> l = s -> {"                + "             System.out.println(s);"                + "         };"                + "     };"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz$1#lambda$$0"), lambdas.get(0).getQualifiedName());        // This is here because of a bug with the regex parsing, which failed on "Bzaz$1#lambda$$0"        // because the second segment of the lambda name was the empty string        assertTrue(lambdas.get(0).getQualifiedName().isLambda());        assertEquals("lambda$$0", lambdas.get(0).getQualifiedName().getOperation());        assertEquals(2, lambdas.get(0).getQualifiedName().getClassName().getClassList().size());    }    @Test    public void testLambdasInMethod() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  public void bar() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public void fooBar() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public void gollum() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$bar$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$fooBar$1"), lambdas.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$gollum$2"), lambdas.get(2).getQualifiedName());    }    @Test    public void testLambdaCounterBelongsToClass() {        final String TEST                = "import java.util.function.*;"                + "class Bzaz{ "                + "  static {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public Bzaz() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "  }"                + "  public void gollum() {"                + "     Consumer<String> l = s -> {"                + "         System.out.println(s);"                + "     };"                + "     l.accept(\"foo\");"                + "     new Runnable() {"                + "       public void run() {"                + "         Runnable r = () -> {};"                + "         r.run();"                + "       }"                + "     }.run();"                + "  }"                + "}";        List<ASTLambdaExpression> lambdas = ParserTstUtil.getOrderedNodes(ASTLambdaExpression.class, TEST);        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$static$0"), lambdas.get(0).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$new$1"), lambdas.get(1).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz#lambda$gollum$2"), lambdas.get(2).getQualifiedName());        assertEquals(QualifiedNameFactory.ofString("Bzaz$1#lambda$run$0"), lambdas.get(3).getQualifiedName()); // counter starts over for anon class        // This is here because of a bug with the regex parsing, which caused "Bzaz$1#lambda$run$0"        // to be parsed as        // * classes == List("Bzaz", "#lambda", "run", "0").reverse()        // * localIndices == List(-1, 1, -1, -1)        // * operation == null        assertTrue(lambdas.get(3).getQualifiedName().isLambda());        assertEquals("lambda$run$0", lambdas.get(3).getQualifiedName().getOperation());        assertEquals(2, lambdas.get(3).getQualifiedName().getClassName().getClassList().size());    }    @Test    public void testGetType() {        JavaTypeQualifiedName qname = QualifiedNameFactory.ofClass(ASTAdditiveExpression.class);        assertEquals(qname.getType(), ASTAdditiveExpression.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;public class ASTAssignmentOperatorTest {    @Test    public void testSimpleAssignmentRecognized() {        Set<ASTAssignmentOperator> ops = getNodes(ASTAssignmentOperator.class, TEST1);        assertFalse((ops.iterator().next()).isCompound());    }    @Test    public void testCompoundAssignmentPlusRecognized() {        Set<ASTAssignmentOperator> ops = getNodes(ASTAssignmentOperator.class, TEST2);        assertTrue((ops.iterator().next()).isCompound());    }    @Test    public void testCompoundAssignmentMultRecognized() {        Set<ASTAssignmentOperator> ops = getNodes(ASTAssignmentOperator.class, TEST3);        assertTrue((ops.iterator().next()).isCompound());    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x;"            + PMD.EOL + "  x=2;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x;"            + PMD.EOL + "  x += 2;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " void bar() {" + PMD.EOL + "  int x;"            + PMD.EOL + "  x *= 2;" + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.lang.java.ParserTstUtil.getNodes;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Iterator;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class ASTFormalParameterTest {    @Test    public void testVarargs() {        int nrOfVarArgs = 0;        int nrOfNoVarArgs = 0;        Set<ASTFormalParameter> ops = getNodes(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"),                ASTFormalParameter.class, TEST1);        for (Iterator<ASTFormalParameter> iter = ops.iterator(); iter.hasNext();) {            ASTFormalParameter b = iter.next();            ASTVariableDeclaratorId variableDeclId = b.getFirstDescendantOfType(ASTVariableDeclaratorId.class);            if (!"x".equals(variableDeclId.getImage())) {                assertTrue(b.isVarargs());                nrOfVarArgs++;            } else {                assertFalse(b.isVarargs());                nrOfNoVarArgs++;            }        }        // Ensure that both possibilities are tested        assertEquals(1, nrOfVarArgs);        assertEquals(1, nrOfNoVarArgs);    }    private static final String TEST1 = "class Foo {" + PMD.EOL + " void bar(int x, int... others) {}" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RulePriority;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.util.ResourceLoader;public class PMD5RulesetTest {    @Test    public void loadRuleset() throws Exception {        RuleSetFactory ruleSetFactory = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, true);        RuleSet ruleset = ruleSetFactory.createRuleSet("net/sourceforge/pmd/lang/java/pmd5ruleset.xml");        Assert.assertNotNull(ruleset);        Assert.assertNull(ruleset.getRuleByName("GuardLogStatementJavaUtil"));        Assert.assertNull(ruleset.getRuleByName("GuardLogStatement"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import java.util.logging.Handler;import java.util.logging.LogRecord;import java.util.logging.Logger;import org.junit.After;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import net.sourceforge.pmd.RulePriority;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.util.ResourceLoader;public class QuickstartRulesetTest {    @Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    @After    public void cleanup() {        Handler[] handlers = Logger.getLogger(RuleSetFactory.class.getName()).getHandlers();        for (Handler handler : handlers) {            Logger.getLogger(RuleSetFactory.class.getName()).removeHandler(handler);        }    }    @Test    public void noDeprecations() throws RuleSetNotFoundException {        Logger.getLogger(RuleSetFactory.class.getName()).addHandler(new Handler() {            @Override            public void publish(LogRecord record) {                Assert.fail("No Logging expected: " + record.getMessage());            }            @Override            public void flush() {            }            @Override            public void close() throws SecurityException {            }        });        RuleSetFactory ruleSetFactory = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, false);        RuleSet quickstart = ruleSetFactory.createRuleSet("rulesets/java/quickstart.xml");        Assert.assertFalse(quickstart.getRules().isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;import net.sourceforge.pmd.testframework.RuleTst;public class SuppressWarningsTest extends RuleTst {    private static class BarRule extends AbstractJavaRule {        @Override        public Object visit(ASTCompilationUnit cu, Object ctx) {            // Convoluted rule to make sure the violation is reported for the            // ASTCompilationUnit node            for (ASTClassOrInterfaceDeclaration c : cu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class)) {                if (c.getImage().equalsIgnoreCase("bar")) {                    addViolation(ctx, cu);                }            }            return super.visit(cu, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    public void testClassLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST1, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());        runTestFromString(TEST2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testInheritedSuppression() {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testMethodLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST4, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testConstructorLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST5, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testFieldLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST6, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testParameterLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST7, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testLocalVariableLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST8, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppression() {        Report rpt = new Report();        runTestFromString(TEST9, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionValue1() {        Report rpt = new Report();        runTestFromString(TEST9_VALUE1, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionValue2() {        Report rpt = new Report();        runTestFromString(TEST9_VALUE2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionValue3() {        Report rpt = new Report();        runTestFromString(TEST9_VALUE3, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionMulitpleValues1() {        Report rpt = new Report();        runTestFromString(TEST9_MULTIPLE_VALUES_1, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testSpecificSuppressionMulitpleValues2() {        Report rpt = new Report();        runTestFromString(TEST9_MULTIPLE_VALUES_2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testNoSuppressionBlank() {        Report rpt = new Report();        runTestFromString(TEST10, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(2, rpt.size());    }    @Test    public void testNoSuppressionSomethingElseS() {        Report rpt = new Report();        runTestFromString(TEST11, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(2, rpt.size());    }    @Test    public void testSuppressAll() {        Report rpt = new Report();        runTestFromString(TEST12, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    @Test    public void testSpecificSuppressionAtTopLevel() {        Report rpt = new Report();        runTestFromString(TEST13, new BarRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals(0, rpt.size());    }    private static final String TEST1 = "@SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST2 = "@SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {" + PMD.EOL            + " void bar() {" + PMD.EOL + "  int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST3 = "public class Baz {" + PMD.EOL + " @SuppressWarnings(\"PMD\")" + PMD.EOL            + " public class Bar {" + PMD.EOL + "  void bar() {" + PMD.EOL + "   int foo;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "public class Foo {" + PMD.EOL + " @SuppressWarnings(\"PMD\")" + PMD.EOL            + " void bar() {" + PMD.EOL + "  int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST5 = "public class Bar {" + PMD.EOL + " @SuppressWarnings(\"PMD\")" + PMD.EOL            + " public Bar() {" + PMD.EOL + "  int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST6 = "public class Bar {" + PMD.EOL + " @SuppressWarnings(\"PMD\")" + PMD.EOL            + " int foo;" + PMD.EOL + " void bar() {" + PMD.EOL + "  int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST7 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL            + " void bar(@SuppressWarnings(\"PMD\") int foo) {}" + PMD.EOL + "}";    private static final String TEST8 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings(\"PMD\") int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings(\"PMD.NoFoo\") int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_VALUE1 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings(value = \"PMD.NoFoo\") int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_VALUE2 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings({\"PMD.NoFoo\"}) int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_VALUE3 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings(value = {\"PMD.NoFoo\"}) int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_MULTIPLE_VALUES_1 = "@SuppressWarnings({\"PMD.NoFoo\", \"PMD.NoBar\"})" + PMD.EOL            + "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {" + PMD.EOL + "  int foo;"            + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_MULTIPLE_VALUES_2 = "@SuppressWarnings(value = {\"PMD.NoFoo\", \"PMD.NoBar\"})"            + PMD.EOL + "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {" + PMD.EOL            + "  int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST10 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings(\"\") int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST11 = "public class Bar {" + PMD.EOL + " int foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings(\"SomethingElse\") int foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST12 = "public class Bar {" + PMD.EOL + " @SuppressWarnings(\"all\") int foo;"            + PMD.EOL + "}";    private static final String TEST13 = "@SuppressWarnings(\"PMD.NoBar\")" + PMD.EOL + "public class Bar {" + PMD.EOL            + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.util.regex.Pattern;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;/** * Unit test for {@link CPDCommandLineInterface}. * */public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    /**     * Test ignore identifiers argument.     */    @Test    public void testIgnoreIdentifiers() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 7 line (36 tokens) duplication"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * Test ignore identifiers argument with failOnViolation=false     */    @Test    public void testIgnoreIdentifiersFailOnViolationFalse() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--failOnViolation",                "false");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 7 line (36 tokens) duplication"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * Test excludes option.     */    @Test    public void testExcludes() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--ignore-identifiers", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--exclude",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/File2.java");        String out = getOutput();        Assert.assertFalse(out.contains("Found a 7 line (34 tokens) duplication"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * #1144 CPD encoding argument has no effect     */    @Test    public void testEncodingOption() throws Exception {        String origEncoding = System.getProperty("file.encoding");        // set the default encoding under Windows        System.setProperty("file.encoding", "Cp1252");        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--format", "xml",                // request UTF-8 for CPD                "--encoding", "UTF-8");        // reset default encoding        System.setProperty("file.encoding", origEncoding);        String out = getOutput();        Assert.assertTrue(out.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));        Assert.assertTrue(Pattern.compile("System\\.out\\.println\\([ij] \\+ \"ä\"\\);").matcher(out).find());        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1178/     *      * @throws IOException     *             any error     */    @Test    public void testBrokenAndValidFile() throws IOException {        runCPD("--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/badandgood/", "--format", "text", "--skip-lexical-errors");        String out = getOutput();        Assert.assertTrue(                Pattern.compile("Skipping .*?BadFile\\.java\\. Reason: Lexical error in file").matcher(out).find());        Assert.assertTrue(out.contains("Found a 5 line (13 tokens) duplication"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    @Test    public void testFormatXmlWithoutEncoding() throws Exception {        runCPD("--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--format", "xml");        String out = getOutput();        Assert.assertTrue(out.contains("<duplication lines=\"3\" tokens=\"10\">"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    @Test    public void testCSVFormat() throws Exception {        runCPD("--minimum-tokens", "100", "--files", "src/test/resources/net/sourceforge/pmd/cpd/badandgood/",                "--language", "c", "--format", "csv");        String out = getOutput();        Assert.assertFalse(out.contains("Couldn't instantiate renderer"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.JavaParserConstants;public class JavaTokensTokenizerTest {    @Test    public void test1() throws IOException {        Tokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("public class Foo {}"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());        assertEquals("public class Foo {}", sourceCode.getSlice(1, 1));    }    @Test    public void testCommentsIgnored() throws IOException {        Tokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(                new SourceCode.StringCodeLoader("public class Foo { // class Bar */ \n }"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    @Test    public void test2() throws IOException {        Tokenizer t = new JavaTokenizer();        String data = "public class Foo {" + PMD.EOL + "public void bar() {}" + PMD.EOL + "public void buz() {}"                + PMD.EOL + "}";        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(data));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals("public class Foo {" + PMD.EOL + "public void bar() {}", sourceCode.getSlice(1, 2));    }    @Test    public void testDiscardSemicolons() throws IOException {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("public class Foo {private int x;}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(9, tokens.size());    }    @Test    public void testDiscardImports() throws IOException {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(                new SourceCode.StringCodeLoader("import java.io.File;" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    @Test    public void testDiscardPkgStmts() throws IOException {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(                new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    @Test    public void testDiscardSimpleOneLineAnnotation() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "package foo.bar.baz;" + PMD.EOL + "@MyAnnotation" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    @Test    public void testIgnoreComments() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "/*****" + PMD.EOL + " * ugh" + PMD.EOL + " *****/" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    @Test    public void testDiscardOneLineAnnotationWithParams() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "package foo.bar.baz;" + PMD.EOL + "@ MyAnnotation (\"ugh\")" + PMD.EOL + "@NamedQueries({" + PMD.EOL                        + "@NamedQuery(" + PMD.EOL + ")})" + PMD.EOL + "public class Foo {" + PMD.EOL + "}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(6, tokens.size());    }    @Test    public void testIgnoreBetweenSpecialComments() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "// CPD-OFF" + PMD.EOL + "// CPD-OFF" + PMD.EOL                + "@ MyAnnotation (\"ugh\")" + PMD.EOL + "@NamedQueries({" + PMD.EOL + "@NamedQuery(" + PMD.EOL + ")})"                + PMD.EOL + "public class Foo {" + "// CPD-ON" + PMD.EOL                + "}"        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(2, tokens.size()); // 2 tokens: "}" + EOF    }    @Test    public void testIgnoreBetweenSpecialCommentsMultiple() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "// CPD-OFF" + PMD.EOL + "// another irrelevant comment" + PMD.EOL                + "@ MyAnnotation (\"ugh\")" + PMD.EOL + "@NamedQueries({" + PMD.EOL + "@NamedQuery(" + PMD.EOL + ")})"                + PMD.EOL + "public class Foo {" + "// CPD-ON" + PMD.EOL                + "}"        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(2, tokens.size()); // 2 tokens: "}" + EOF    }    @Test    public void testIgnoreBetweenSpecialCommentsMultiline() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "/* " + PMD.EOL + " * CPD-OFF" + PMD.EOL + "*/" + PMD.EOL                + "@ MyAnnotation (\"ugh\")" + PMD.EOL + "@NamedQueries({" + PMD.EOL + "@NamedQuery(" + PMD.EOL + ")})"                + PMD.EOL + "public class Foo {" + PMD.EOL                + "/* " + PMD.EOL + " * CPD-ON" + PMD.EOL + "*/" + PMD.EOL                + "}"        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(2, tokens.size()); // 2 tokens: "}" + EOF    }    @Test    public void testIgnoreBetweenSpecialAnnotation() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "@SuppressWarnings({\"woof\",\"CPD-START\"})" + PMD.EOL + "@SuppressWarnings(\"CPD-START\")" + PMD.EOL                + "@ MyAnnotation (\"ugh\")" + PMD.EOL + "@NamedQueries({" + PMD.EOL + "@NamedQuery(" + PMD.EOL + ")})"                + PMD.EOL + "public class Foo {}" + "@SuppressWarnings({\"ugh\",\"CPD-END\"})" + PMD.EOL        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(10, tokens.size());    }    @Test    public void testIgnoreBetweenSpecialAnnotationAndIgnoreAnnotations() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "@SuppressWarnings({\"woof\",\"CPD-START\"})" + PMD.EOL + "@SuppressWarnings(\"CPD-START\")" + PMD.EOL                + "@ MyAnnotation (\"ugh\")" + PMD.EOL + "@NamedQueries({" + PMD.EOL + "@NamedQuery(" + PMD.EOL + ")})"                + PMD.EOL + "public class Foo {}" + PMD.EOL + "@SuppressWarnings({\"ugh\",\"CPD-END\"})" + PMD.EOL        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        assertEquals(1, tokens.size());    }    @Test    public void testIgnoreIdentifiersDontAffectConstructors() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        t.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL                + "public class Foo extends Bar {" + PMD.EOL + "private Foo notAConstructor;" + PMD.EOL                + "public Foo(int i) { super(i); }" + PMD.EOL + "private Foo(int i, String s) { super(i, s); }"                + PMD.EOL + "/* default */ Foo(int i, String s, Object o) { super(i, s, o); }" + PMD.EOL                + "private static class Inner {" + PMD.EOL + "Inner() { System.out.println(\"Guess who?\"); }" + PMD.EOL                + "}" + PMD.EOL + "}" + PMD.EOL        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        List<TokenEntry> tokenList = tokens.getTokens();        // Member variable of type Foo        assertEquals(String.valueOf(JavaParserConstants.IDENTIFIER), tokenList.get(7).toString());        // Public constructor        assertEquals("Foo", tokenList.get(10).toString());        // Private constructor        assertEquals("Foo", tokenList.get(22).toString());        // Package-private constructor        assertEquals("Foo", tokenList.get(38).toString());        // Inner class constructor        assertEquals("Inner", tokenList.get(64).toString());    }    @Test    public void testIgnoreIdentifiersHandlesEnums() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        t.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "package foo.bar.baz;" + PMD.EOL + "public enum Foo {" + PMD.EOL + "BAR(1)," + PMD.EOL + "BAZ(2);"                        + PMD.EOL + "Foo(int val) {" + PMD.EOL + "}" + PMD.EOL + "}" + PMD.EOL        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        List<TokenEntry> tokenList = tokens.getTokens();        // Enum member        assertEquals(String.valueOf(JavaParserConstants.IDENTIFIER), tokenList.get(4).toString());        assertEquals(String.valueOf(JavaParserConstants.IDENTIFIER), tokenList.get(9).toString());        // Enum constructor        assertEquals("Foo", tokenList.get(13).toString());    }    @Test    public void testIgnoreIdentifiersWithClassKeyword() throws IOException {        JavaTokenizer t = new JavaTokenizer();        t.setIgnoreAnnotations(false);        t.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "package foo.bar.baz;" + PMD.EOL + "public class Foo {" + PMD.EOL + "Foo() {" + PMD.EOL                        + "}" + PMD.EOL + "public void bar() {" + PMD.EOL + "Bar.baz(Foo.class, () -> {});"                        + PMD.EOL + "}" + PMD.EOL + "}" + PMD.EOL        ));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        TokenEntry.getEOF();        List<TokenEntry> tokenList = tokens.getTokens();        // Class constructor        assertEquals("Foo", tokenList.get(4).toString());        assertEquals(String.valueOf(JavaParserConstants.IDENTIFIER), tokenList.get(11).toString());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.io.IOException;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.PMD;public class MatchAlgorithmTest {    private static final String LINE_1 = "public class Foo { ";    private static final String LINE_2 = " public void bar() {";    private static final String LINE_3 = "  System.out.println(\"hello\");";    private static final String LINE_4 = "  System.out.println(\"hello\");";    private static final String LINE_5 = "  int i = 5";    private static final String LINE_6 = "  System.out.print(\"hello\");";    private static final String LINE_7 = " }";    private static final String LINE_8 = "}";    private static String getSampleCode() {        return LINE_1 + PMD.EOL + LINE_2 + PMD.EOL + LINE_3 + PMD.EOL + LINE_4 + PMD.EOL + LINE_5 + PMD.EOL + LINE_6                + PMD.EOL + LINE_7 + PMD.EOL + LINE_8;    }    @Test    public void testSimple() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(41, tokens.size());        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        Mark mark1 = marks.next();        Mark mark2 = marks.next();        assertFalse(marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals("Foo.java", mark1.getFilename());        assertEquals(LINE_3, mark1.getSourceCodeSlice());        assertEquals(4, mark2.getBeginLine());        assertEquals("Foo.java", mark2.getFilename());        assertEquals(LINE_4, mark2.getSourceCodeSlice());    }    @Test    public void testIgnore() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        tokenizer.setIgnoreLiterals(true);        tokenizer.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        marks.next();        marks.next();        marks.next();        assertFalse(marks.hasNext());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.lang.reflect.Field;import java.nio.charset.Charset;import java.util.Locale;import java.util.Objects;import org.apache.commons.io.FileUtils;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.ExternalResource;import org.junit.rules.TestRule;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testNoFormattersValidation() {        executeTarget("testNoFormattersValidation");        assertOutputContaining("Fields should be declared at the top of the class");    }    @Test    public void testNestedRuleset() {        executeTarget("testNestedRuleset");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testFormatterWithProperties() {        executeTarget("testFormatterWithProperties");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");        assertOutputContaining("link_prefix");        assertOutputContaining("line_prefix");    }    @Test    public void testAbstractNames() {        executeTarget("testAbstractNames");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testAbstractNamesInNestedRuleset() {        executeTarget("testAbstractNamesInNestedRuleset");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testCommaInRulesetfiles() {        executeTarget("testCommaInRulesetfiles");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testRelativeRulesets() {        executeTarget("testRelativeRulesets");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testRelativeRulesetsInRulesetfiles() {        executeTarget("testRelativeRulesetsInRulesetfiles");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at");    }    @Test    public void testExplicitRuleInRuleSet() {        executeTarget("testExplicitRuleInRuleSet");        assertOutputContaining("Avoid really long methods");    }    @Test    public void testClasspath() {        executeTarget("testClasspath");    }    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @Rule    public final TestRule restoreLocale = new ExternalResource() {        private Locale originalLocale;        @Override        protected void before() throws Throwable {            originalLocale = Locale.getDefault();        }        @Override        protected void after() {            Locale.setDefault(originalLocale);        }    };    // See http://stackoverflow.com/questions/361975/setting-the-default-java-character-encoding and http://stackoverflow.com/a/14987992/1169968    private static void setDefaultCharset(String charsetName) {        try {            System.setProperty("file.encoding", charsetName);            Field charset = Charset.class.getDeclaredField("defaultCharset");            charset.setAccessible(true);            charset.set(null, null);            Objects.requireNonNull(Charset.defaultCharset());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    @Rule    public final TestRule restoreDefaultCharset = new ExternalResource() {        private Charset defaultCharset;        @Override        protected void before() throws Throwable {            defaultCharset = Charset.defaultCharset();        }        @Override        protected void after() {            setDefaultCharset(defaultCharset.name());        }    };    @Test    public void testFormatterEncodingWithXML() throws Exception {        Locale.setDefault(Locale.FRENCH);        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXML");        String report = FileUtils.readFileToString(currentTempFile(), "UTF-8");        assertTrue(report.contains("unusedVariableWithÜmlaut"));    }    @Test    public void testFormatterEncodingWithXMLConsole() {        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXMLConsole");        String report = buildRule.getOutput();        assertTrue(report.startsWith("<?xml version=\"1.0\" encoding=\"windows-1252\"?>"));        assertTrue(report.contains("unusedVariableWith&#xdc;mlaut"));    }    @Test    public void testMissingCacheLocation() {        executeTarget("testMissingCacheLocation");        assertOutputContaining("Avoid really long methods");        assertContains(buildRule.getLog(), "This analysis could be faster");    }    @Test    public void testAnalysisCache() {        executeTarget("testAnalysisCache");        assertOutputContaining("Avoid really long methods");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertTrue(currentTempFile().exists());    }    @Test    public void testDisableIncrementalAnalysis() {        executeTarget("testDisableIncrementalAnalysis");        assertOutputContaining("Avoid really long methods");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertFalse(currentTempFile().exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;import net.sourceforge.pmd.testframework.TestDescriptor;public class RegexpAcceptanceTest extends SimpleAggregatorTst {    private static final String XPATH = "//ClassOrInterfaceDeclaration[matches(@Image, 'F?o')]";    @Override    protected void setUp() {        // not registering any rule    }    @Test    public void testSimple() {        Rule r = new XPathRule(XPATH);        r.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        r.setMessage("");        TestDescriptor[] testDescriptors = extractTestsFromXml(r, "RegexpAcceptance");        for (TestDescriptor testDescriptor : testDescriptors) {            testDescriptor.setReinitializeRule(false);        }        runTests(testDescriptors);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertSame;import static org.junit.Assert.fail;import java.util.Iterator;import java.util.List;import org.jaxen.BaseXPath;import org.jaxen.JaxenException;import org.jaxen.UnsupportedAxisException;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.xpath.DocumentNavigator;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.ASTStatement;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;import net.sourceforge.pmd.testframework.RuleTst;public class DocumentNavigatorTest extends RuleTst {    private TestRule rule;    private class TestRule extends AbstractJavaRule {        private Node compilationUnit;        private Node importDeclaration;        private Node statement;        private Node primaryPrefix;        private Node primaryExpression;        /**         * @see net.sourceforge.pmd.lang.java.ast.JavaParserVisitor#visit(ASTCompilationUnit,         *      Object)         */        public Object visit(ASTCompilationUnit node, Object data) {            this.compilationUnit = node;            return super.visit(node, data);        }        public Object visit(ASTImportDeclaration node, Object data) {            this.importDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTStatement node, Object data) {            this.statement = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryPrefix node, Object data) {            this.primaryPrefix = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryExpression node, Object data) {            this.primaryExpression = node;            return super.visit(node, data);        }    }    @Before    public void setUp() {        try {            rule = new TestRule();            runTestFromString(TEST, rule, new Report(),                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion());        } catch (Throwable xx) {            xx.printStackTrace();            fail();        }    }    @Test    public void testChildAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getChildAxisIterator(rule.compilationUnit);        assertSame(rule.compilationUnit.jjtGetChild(0), iter.next());        assertSame(rule.compilationUnit.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testParentAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getParentAxisIterator(rule.importDeclaration);        assertSame(rule.importDeclaration.jjtGetParent(), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testParentAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getParentAxisIterator(rule.compilationUnit);        assertFalse(iter.hasNext());    }    @Test    public void testDescendantAxisIterator() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator<?> iter = nav.getDescendantAxisIterator(rule.statement);        Node statementExpression = rule.statement.jjtGetChild(0);        assertSame(statementExpression, iter.next());        Node primaryExpression = statementExpression.jjtGetChild(0);        assertSame(primaryExpression, iter.next());        Node primaryPrefix = primaryExpression.jjtGetChild(0);        assertSame(primaryPrefix, iter.next());        Node primarySuffix = primaryExpression.jjtGetChild(1);        // assertSame(primarySuffix, iter.next());        Node name = primaryPrefix.jjtGetChild(0);        // assertSame(name, iter.next());        Node arguments = primarySuffix.jjtGetChild(0);        // assertSame(arguments, iter.next());        // assertFalse(iter.hasNext());    }    @Test    public void testDescendantAxisIterator2() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator<?> iter = nav.getDescendantAxisIterator(rule.primaryPrefix);        Node name = rule.primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testFollowingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertSame(rule.primaryExpression.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testFollowingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertFalse(iter.hasNext());    }    @Test    public void testPrecedingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertSame(rule.primaryExpression.jjtGetChild(0), iter.next());        assertFalse(iter.hasNext());    }    @Test    public void testPrecedingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator<Node> iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertFalse(iter.hasNext());    }    @Test    public void testXPath() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List<?> matches = xPath.selectNodes(rule.statement);        assertEquals(6, matches.size());    }    @Test    public void testXPath2() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List<?> matches = xPath.selectNodes(rule.importDeclaration);        assertEquals(1, matches.size());    }    public static final String TEST = "import java.io.*;" + PMD.EOL + "public class Foo {" + PMD.EOL + " public Foo() {"            + PMD.EOL + "  try {" + PMD.EOL + "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL            + "  } catch (Exception e) {}" + PMD.EOL + "  try {" + PMD.EOL            + "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL + "  } catch (Exception e) {" + PMD.EOL            + "   e.printStackTrace();" + PMD.EOL + "   // this shouldn't show up on the report" + PMD.EOL + "  }"            + PMD.EOL + " }" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution.typedefinition;import java.util.ArrayList;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;public class JavaTypeDefinitionSimpleTest {    /**     * Tests the raw type {@code ArrayList}.     */    @Test    public void arrayListWithoutBoundGenerics() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(ArrayList.class);        Assert.assertTrue(typeDef.isGeneric());        Assert.assertTrue(typeDef.isRawType());        Assert.assertEquals(1, typeDef.getTypeParameterCount());        JavaTypeDefinition genericType = typeDef.getGenericType(0);        Assert.assertFalse(genericType.isGeneric());        Assert.assertEquals(Object.class, genericType.getType());    }    /**     * Tests the type {@code ArrayList<String>}.     */    @Test    public void arrayListOfString() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(ArrayList.class, JavaTypeDefinition.forClass(String.class));        Assert.assertTrue(typeDef.isGeneric());        Assert.assertEquals(1, typeDef.getTypeParameterCount());        Assert.assertTrue(typeDef.isClassOrInterface());        Assert.assertFalse(typeDef.isArrayType());        JavaTypeDefinition genericType = typeDef.getGenericType(0);        Assert.assertFalse(genericType.isGeneric());        Assert.assertEquals(String.class, genericType.getType());        JavaTypeDefinition genericTypeByName = typeDef.getGenericType("E");        Assert.assertEquals(String.class, genericTypeByName.getType());    }    @Test    public void array() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(String[].class);        Assert.assertFalse(typeDef.isGeneric());        Assert.assertTrue(typeDef.isArrayType());        Assert.assertFalse(typeDef.isClassOrInterface());        Assert.assertEquals(String.class, typeDef.getElementType().getType());        Assert.assertFalse(typeDef.isPrimitive());    }    @Test    public void primitive() {        JavaTypeDefinition typeDef = JavaTypeDefinition.forClass(int.class);        Assert.assertTrue(typeDef.isPrimitive());        Assert.assertFalse(typeDef.isClassOrInterface());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.CONTAINS;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.EQUALITY;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.LOOSE_INVOCATION;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.SUBTYPE;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Bound;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.BoundOrConstraint;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Constraint;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.TypeInferenceResolver;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Variable;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA2;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther2;public class TypeInferenceTest {    private JavaTypeDefinition number = JavaTypeDefinition.forClass(Number.class);    private JavaTypeDefinition integer = JavaTypeDefinition.forClass(Integer.class);    private JavaTypeDefinition primitiveInt = JavaTypeDefinition.forClass(int.class);    private JavaTypeDefinition generic = JavaTypeDefinition.forClass(Map.class, number, integer);    private Variable alpha = new Variable();    private Variable beta = new Variable();    private JavaTypeDefinition s = JavaTypeDefinition.forClass(int.class);    private JavaTypeDefinition t = JavaTypeDefinition.forClass(double.class);    @Test    public void testEqualityReduceProperVsProper() {        // If S and T are proper types, the constraint reduces to true if S is the same as T (§4.3.4), and false        // otherwise.        assertTrue(new Constraint(number, number, EQUALITY).reduce().isEmpty());        assertNull(new Constraint(number, integer, EQUALITY).reduce());        // Otherwise, if S or T is the null type, the constraint reduces to false. TODO    }    @Test    public void testEqualityReduceVariableVsNotPrimitive() {        // Otherwise, if S is an inference variable, α, and T is not a primitive type, the constraint reduces to        // the bound α = T.        List<BoundOrConstraint> result = new Constraint(alpha, number, EQUALITY).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, number, EQUALITY, Bound.class);    }    @Test    public void testEqualityReduceNotPrimitiveVsVariable() {        // Otherwise, if T is an inference variable, α, and S is not a primitive type, the constraint reduces        // to the bound S = α.        List<BoundOrConstraint> result = new Constraint(number, alpha, EQUALITY).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, alpha, EQUALITY, Bound.class);        result = new Constraint(alpha, beta, EQUALITY).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, beta, EQUALITY, Bound.class);    }    @Test    public void testEqualityReduceSameErasure() {        // Otherwise, if S and T are class or interface types with the same erasure, where S has type        // arguments B1, ..., Bn and T has type arguments A1, ..., An, the constraint reduces to the        // following new constraints: for all i (1 ≤ i ≤ n), ‹Bi = Ai›.        List<BoundOrConstraint> result = new Constraint(generic, generic, EQUALITY).reduce();        assertEquals(2, result.size());        testBoundOrConstraint(result.get(0), number, number, EQUALITY, Constraint.class);        testBoundOrConstraint(result.get(1), integer, integer, EQUALITY, Constraint.class);    }    @Test    public void testEqualityReduceArrayTypes() {        // Otherwise, if S and T are array types, S'[] and T'[], the constraint reduces to ‹S' = T'›.        List<BoundOrConstraint> result = new Constraint(JavaTypeDefinition.forClass(Number[].class),                                                        JavaTypeDefinition.forClass(Integer[].class), EQUALITY)                .reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, integer, EQUALITY, Constraint.class);    }    @Test    public void testSubtypeReduceProperVsProper() {        // A constraint formula of the form ‹S <: T› is reduced as follows:        // If S and T are proper types, the constraint reduces to true if S is a subtype of T (§4.10),        // and false otherwise.        List<BoundOrConstraint> result = new Constraint(integer, number, SUBTYPE).reduce();        assertEquals(0, result.size());        result = new Constraint(number, integer, SUBTYPE).reduce();        assertNull(result);        // Otherwise, if S is the null type, the constraint reduces to true. TODO        // Otherwise, if T is the null type, the constraint reduces to false. TODO    }    @Test    public void testSubtypeReduceVariableVsAny() {        // Otherwise, if S is an inference variable, α, the constraint reduces to the bound α <: T.        List<BoundOrConstraint> result = new Constraint(alpha, integer, SUBTYPE).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, integer, SUBTYPE, Bound.class);    }    @Test    public void testSubtypeReduceAnyVsVariable() {        // Otherwise, if T is an inference variable, α, the constraint reduces to the bound S <: α.        List<BoundOrConstraint> result = new Constraint(integer, alpha, SUBTYPE).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), integer, alpha, SUBTYPE, Bound.class);        result = new Constraint(alpha, beta, SUBTYPE).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, beta, SUBTYPE, Bound.class);    }    @Test    public void testLooseInvocationProperVsProper() {        // A constraint formula of the form ‹S → T› is reduced as follows:        // If S and T are proper types, the constraint reduces to true if S is compatible in a loose invocation        // context with T (§5.3), and false otherwise.        List<BoundOrConstraint> result = new Constraint(number, integer, LOOSE_INVOCATION).reduce();        assertNull(result);        result = new Constraint(integer, number, LOOSE_INVOCATION).reduce();        assertEquals(0, result.size());    }    @Test    public void testLooseInvocationLeftBoxing() {        // Otherwise, if S is a primitive type, let S' be the result of applying boxing conversion (§5.1.7) to S.        // Then the constraint reduces to ‹S' → T›.        List<BoundOrConstraint> result = new Constraint(primitiveInt, number, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), integer, number, LOOSE_INVOCATION, Constraint.class);    }    @Test    public void testLooseInvocationRightBoxing() {        // Otherwise, if T is a primitive type, let T' be the result of applying boxing conversion (§5.1.7) to T.        // Then the constraint reduces to ‹S = T'›.        List<BoundOrConstraint> result = new Constraint(number, primitiveInt, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, integer, EQUALITY, Constraint.class);        // Otherwise, if T is a parameterized type of the form G<T1, ..., Tn>, and there exists no type of the        // form G<...> that is a supertype of S, but the raw type G is a supertype of S, then the constraint        // reduces to true. TODO        // Otherwise, if T is an array type of the form G<T1, ..., Tn>[]k, and there exists no type of the form        // G<...>[]k that is a supertype of S, but the raw type G[]k is a supertype of S, then the constraint        // reduces to true. (The notation []k indicates an array type of k dimensions.) TODO    }    @Test    public void testLooseInvocationAnythingElse() {        // Otherwise, the constraint reduces to ‹S<:T›.        List<BoundOrConstraint> result = new Constraint(number, alpha, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, alpha, SUBTYPE, Constraint.class);        result = new Constraint(alpha, number, LOOSE_INVOCATION).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), alpha, number, SUBTYPE, Constraint.class);    }    @Test    public void testContainmentReduceTypeVsType() {        // A constraint formula of the form ‹S <= T›, where S and T are type arguments (§4.5.1), is reduced as        // follows:        // If T is a type: // If S is a type, the constraint reduces to ‹S = T›.        List<BoundOrConstraint> result = new Constraint(number, integer, CONTAINS).reduce();        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), number, integer, EQUALITY, Constraint.class);        // If T is a type: // If S is a wildcard, the constraint reduces to false. TODO        // If T is a wildcard of the form ?, the constraint reduces to true. TODO        // If T is a wildcard of the form ? extends T': TODO        // If T is a wildcard of the form ? super T': TODO    }    @Test    public void testIncorporationEqualityAndEquality() {        List<Constraint> result;        // ### Original rule 1. : α = S and α = T imply ‹S = T›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(alpha, t, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);        // α = S and T = α imply ‹S = T›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(t, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);        // S = α and α = T imply ‹S = T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(alpha, t, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);        // S = α and T = α imply ‹S = T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(t, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, EQUALITY, Constraint.class);    }    @Test    public void testIncorporationEqualityAndSubtypeLeftVariable() {        List<Constraint> result;        // ### Original rule 2. : α = S and α <: T imply ‹S <: T›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(alpha, t, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // S = α and α <: T imply ‹S <: T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(alpha, t, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // α <: T and α = S imply ‹S <: T›        result = incorporationResult(new Bound(alpha, t, SUBTYPE), new Bound(alpha, s, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // α <: T and S = α imply ‹S <: T›        result = incorporationResult(new Bound(alpha, t, SUBTYPE), new Bound(s, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);    }    @Test    public void testIncorporationEqualityAndSubtypeRightVariable() {        List<Constraint> result;        // ### Original rule 3. : α = S and T <: α imply ‹T <: S›        result = incorporationResult(new Bound(alpha, s, EQUALITY), new Bound(t, alpha, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);        // S = α and T <: α imply ‹T <: S›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(t, alpha, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);        // T <: α and α = S imply ‹T <: S›        result = incorporationResult(new Bound(t, alpha, SUBTYPE), new Bound(alpha, s, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);        // T <: α and S = α imply ‹T <: S›        result = incorporationResult(new Bound(t, alpha, SUBTYPE), new Bound(s, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), t, s, SUBTYPE, Constraint.class);    }    @Test    public void testIncorporationSubtypeAndSubtype() {        List<Constraint> result;        // ### Original rule 4. : S <: α and α <: T imply ‹S <: T›        result = incorporationResult(new Bound(s, alpha, EQUALITY), new Bound(alpha, t, SUBTYPE));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);        // α <: T and S <: α imply ‹S <: T›        result = incorporationResult(new Bound(alpha, t, SUBTYPE), new Bound(s, alpha, EQUALITY));        assertEquals(1, result.size());        testBoundOrConstraint(result.get(0), s, t, SUBTYPE, Constraint.class);    }    @Test    public void testErasedCandidateSet() {        List<JavaTypeDefinition> types = new ArrayList<>();        types.add(JavaTypeDefinition.forClass(List.class));        types.add(JavaTypeDefinition.forClass(Set.class));        Set<Class<?>> erasedCandidate = TypeInferenceResolver.getErasedCandidateSet(types);        assertEquals(3, erasedCandidate.size());        assertTrue(erasedCandidate.contains(Object.class));        assertTrue(erasedCandidate.contains(Collection.class));        assertTrue(erasedCandidate.contains(Iterable.class));        Set<Class<?>> emptySet = TypeInferenceResolver.getErasedCandidateSet(Collections.<JavaTypeDefinition>emptyList());        assertNotNull(emptySet);        assertEquals(0, emptySet.size());    }    @Test    public void testMinimalErasedCandidateSet() {        Set<Class<?>> minimalSet = TypeInferenceResolver.getMinimalErasedCandidateSet(                JavaTypeDefinition.forClass(List.class).getErasedSuperTypeSet());        assertEquals(1, minimalSet.size());        assertTrue(minimalSet.contains(List.class));    }    @Test    public void testLeastUpperBound() {        List<JavaTypeDefinition> lowerBounds = new ArrayList<>();        lowerBounds.add(JavaTypeDefinition.forClass(SuperClassA.class));        lowerBounds.add(JavaTypeDefinition.forClass(SuperClassAOther.class));        lowerBounds.add(JavaTypeDefinition.forClass(SuperClassAOther2.class));        assertEquals(JavaTypeDefinition.forClass(SuperClassA2.class), TypeInferenceResolver.lub(lowerBounds));    }    @Test    public void testResolution() {        List<Bound> bounds = new ArrayList<>();        bounds.add(new Bound(JavaTypeDefinition.forClass(SuperClassA.class), alpha, SUBTYPE));        bounds.add(new Bound(JavaTypeDefinition.forClass(SuperClassAOther.class), alpha, SUBTYPE));        Map<Variable, JavaTypeDefinition> result = TypeInferenceResolver.resolveVariables(bounds);        assertEquals(1, result.size());        assertEquals(JavaTypeDefinition.forClass(SuperClassA2.class), result.get(alpha));    }    private List<Constraint> incorporationResult(Bound firstBound, Bound secondBound) {        List<Bound> current = new ArrayList<>();        List<Bound> newBounds = new ArrayList<>();        current.add(firstBound);        newBounds.add(secondBound);        return TypeInferenceResolver.incorporateBounds(current, newBounds);    }    private void testBoundOrConstraint(BoundOrConstraint val, JavaTypeDefinition left, JavaTypeDefinition right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftProper());        assertEquals(right, val.rightProper());        assertEquals(rule, val.ruleType());    }    private void testBoundOrConstraint(BoundOrConstraint val, JavaTypeDefinition left, Variable right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftProper());        assertEquals(right, val.rightVariable());        assertEquals(rule, val.ruleType());    }    private void testBoundOrConstraint(BoundOrConstraint val, Variable left, JavaTypeDefinition right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftVariable());        assertEquals(right, val.rightProper());        assertEquals(rule, val.ruleType());    }    private void testBoundOrConstraint(BoundOrConstraint val, Variable left, Variable right,                                       InferenceRuleType rule, Class<? extends BoundOrConstraint> type) {        assertSame(type, val.getClass());        assertEquals(left, val.leftVariable());        assertEquals(right, val.rightVariable());        assertEquals(rule, val.ruleType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.fail;import java.util.Map;import org.junit.Before;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader;public class PMDASMClassLoaderTest {    private PMDASMClassLoader cl;    @Before    public void setUp() throws Exception {        cl = PMDASMClassLoader.getInstance(getClass().getClassLoader());    }    @Test    public void testLoadClassWithImportOnDemand() throws Exception {        String className = "net.sourceforge.pmd.typeresolution.ClassWithImportOnDemand";        Class<?> clazz = cl.loadClass(className);        assertNotNull(clazz);        Map<String, String> imports = cl.getImportedClasses(className);        assertNotNull(imports);        assertEquals("java.util.List", imports.get("List"));        assertEquals("java.util.ArrayList", imports.get("ArrayList"));        assertEquals("java.lang.Object", imports.get("Object"));        assertEquals("net.sourceforge.pmd.typeresolution.ClassWithImportOnDemand",                imports.get("ClassWithImportOnDemand"));    }    @Test    public void testClassWithImportInnerOnDemand() throws Exception {        String className = "net.sourceforge.pmd.typeresolution.ClassWithImportInnerOnDemand";        Class<?> clazz = cl.loadClass(className);        assertNotNull(clazz);        Map<String, String> imports = cl.getImportedClasses(className);        assertNotNull(imports);        assertEquals("java.util.Iterator", imports.get("Iterator"));        assertEquals("java.util.Map", imports.get("Map"));        assertEquals("java.util.Set", imports.get("Set"));        assertEquals("java.util.Map$Entry", imports.get("Entry"));        assertEquals("java.util.Map$Entry", imports.get("Map$Entry"));        assertEquals("java.lang.Object", imports.get("Object"));        assertEquals("java.util.StringTokenizer", imports.get("StringTokenizer"));        assertEquals("net.sourceforge.pmd.typeresolution.ClassWithImportInnerOnDemand",                imports.get("ClassWithImportInnerOnDemand"));    }    /**     * Unit test for bug 3546093.     *     * @throws Exception     *             any error     */    @Test    public void testCachingOfNotFoundClasses() throws Exception {        MockedClassLoader mockedClassloader = new MockedClassLoader();        PMDASMClassLoader cl = PMDASMClassLoader.getInstance(mockedClassloader);        String notExistingClassname = "that.clazz.doesnot.Exist";        try {            cl.loadClass(notExistingClassname);            fail();        } catch (ClassNotFoundException e) {            // expected        }        try {            cl.loadClass(notExistingClassname);            fail();        } catch (ClassNotFoundException e) {            // expected        }        assertEquals(1, mockedClassloader.findClassCalls);    }    private static class MockedClassLoader extends ClassLoader {        int findClassCalls = 0;        @Override        protected Class<?> findClass(String name) throws ClassNotFoundException {            findClassCalls++;            return super.findClass(name);        }    }    /**     * With this test you can verify, how much memory could be consumed by the     * dontBother cache.     *      * @throws Exception     *             any error     */    @Ignore    @Test    public void testCachingMemoryConsumption() throws Exception {        MockedClassLoader mockedClassLoader = new MockedClassLoader();        PMDASMClassLoader cl = PMDASMClassLoader.getInstance(mockedClassLoader);        Runtime runtime = Runtime.getRuntime();        System.gc();        long usedBytesBefore = runtime.totalMemory() - runtime.freeMemory();        for (long i = 0; i < 3000; i++) {            try {                cl.loadClass("com.very.long.package.name.and.structure.MyClass" + i);            } catch (ClassNotFoundException e) {                // expected            }        }        long usedBytesAfter = runtime.totalMemory() - runtime.freeMemory();        System.out.println((usedBytesAfter - usedBytesBefore) / (1024.0 * 1024.0) + " mb needed");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static org.junit.Assert.assertSame;import org.junit.Test;import net.sourceforge.pmd.lang.java.typeresolution.MethodTypeResolution;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;public class MethodTypeResolutionTest {    @Test    public void testBoxingRules() {        assertSame(Boolean.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(boolean.class)).getType());        assertSame(Double.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(double.class)).getType());        assertSame(Float.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(float.class)).getType());        assertSame(Long.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(long.class)).getType());        assertSame(Integer.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(int.class)).getType());        assertSame(Character.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(char.class)).getType());        assertSame(Short.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(short.class)).getType());        assertSame(Byte.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(byte.class)).getType());        assertSame(Void.class, MethodTypeResolution.boxPrimitive(JavaTypeDefinition.forClass(void.class)).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.jaxen.JaxenException;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode;import net.sourceforge.pmd.typeresolution.testdata.java8.SuperClass;import net.sourceforge.pmd.typeresolution.testdata.java8.SuperExpression;import net.sourceforge.pmd.typeresolution.testdata.java8.ThisExpression;public class ClassTypeResolverJava8Test {    @Test    public void testThisExpression() throws JaxenException {        ASTCompilationUnit acu = parseAndTypeResolveForClass18(ThisExpression.class);        List<ASTPrimaryExpression> expressions = convertList(                acu.findChildNodesWithXPath("//VariableInitializer/Expression/PrimaryExpression"),                ASTPrimaryExpression.class);        List<ASTPrimaryPrefix> prefixes = convertList(                acu.findChildNodesWithXPath("//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix"),                ASTPrimaryPrefix.class);        int index = 0;        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.PrimaryThisInterface.class, expressions.get(index).getType());        assertEquals(ThisExpression.PrimaryThisInterface.class, prefixes.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());        assertEquals("All expressions not tested", index, prefixes.size());    }    @Test    public void testSuperExpression() throws JaxenException {        ASTCompilationUnit acu = parseAndTypeResolveForClass18(SuperExpression.class);        List<AbstractJavaTypeNode> expressions = convertList(                acu.findChildNodesWithXPath("//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix"),                AbstractJavaTypeNode.class);        int index = 0;        assertEquals(SuperClass.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    private static <T> List<T> convertList(List<Node> nodes, Class<T> target) {        List<T> converted = new ArrayList<>();        for (Node n : nodes) {            converted.add(target.cast(n));        }        return converted;    }    private ASTCompilationUnit parseAndTypeResolveForClass18(Class<?> clazz) {        String source = ParserTstUtil.getSourceFromClass(clazz);        return ParserTstUtil.parseAndTypeResolveJava("1.8", source);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.typeresolution;import static junit.framework.TestCase.assertTrue;import static net.sourceforge.pmd.lang.java.ParserTstUtil.selectNodes;import static net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition.forClass;import static net.sourceforge.pmd.lang.java.typeresolution.typedefinition.TypeDefinitionType.LOWER_WILDCARD;import static net.sourceforge.pmd.lang.java.typeresolution.typedefinition.TypeDefinitionType.UPPER_WILDCARD;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.LOOSE_INVOCATION;import static net.sourceforge.pmd.lang.java.typeresolution.typeinference.InferenceRuleType.SUBTYPE;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import java.io.StringReader;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collection;import java.util.Comparator;import java.util.HashSet;import java.util.List;import java.util.Objects;import java.util.Set;import java.util.StringTokenizer;import org.jaxen.JaxenException;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.ParserTstUtil;import net.sourceforge.pmd.lang.java.ast.ASTAllocationExpression;import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;import net.sourceforge.pmd.lang.java.ast.ASTBooleanLiteral;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBodyDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTEnumConstant;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTLiteral;import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTNullLiteral;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;import net.sourceforge.pmd.lang.java.ast.ASTReferenceType;import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;import net.sourceforge.pmd.lang.java.ast.ASTType;import net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.AbstractJavaNode;import net.sourceforge.pmd.lang.java.ast.AbstractJavaTypeNode;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;import net.sourceforge.pmd.lang.java.typeresolution.ClassTypeResolver;import net.sourceforge.pmd.lang.java.typeresolution.MethodType;import net.sourceforge.pmd.lang.java.typeresolution.MethodTypeResolution;import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Bound;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Constraint;import net.sourceforge.pmd.lang.java.typeresolution.typeinference.Variable;import net.sourceforge.pmd.typeresolution.testdata.AbstractReturnTypeUseCase;import net.sourceforge.pmd.typeresolution.testdata.AnonymousClassFromInterface;import net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass;import net.sourceforge.pmd.typeresolution.testdata.AnoymousExtendingObject;import net.sourceforge.pmd.typeresolution.testdata.ArrayAccess;import net.sourceforge.pmd.typeresolution.testdata.ArrayListFound;import net.sourceforge.pmd.typeresolution.testdata.ArrayTypes;import net.sourceforge.pmd.typeresolution.testdata.ArrayVariableDeclaration;import net.sourceforge.pmd.typeresolution.testdata.DefaultJavaLangImport;import net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass;import net.sourceforge.pmd.typeresolution.testdata.ExtraTopLevelClass;import net.sourceforge.pmd.typeresolution.testdata.FieldAccess;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericBounds;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericNested;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericParameter;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericRaw;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessGenericSimple;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessNested;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessPrimaryGenericSimple;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessShadow;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessStatic;import net.sourceforge.pmd.typeresolution.testdata.FieldAccessSuper;import net.sourceforge.pmd.typeresolution.testdata.GenericMethodsImplicit;import net.sourceforge.pmd.typeresolution.testdata.GenericsArrays;import net.sourceforge.pmd.typeresolution.testdata.InnerClass;import net.sourceforge.pmd.typeresolution.testdata.JavaTypeDefinitionToStringNPE;import net.sourceforge.pmd.typeresolution.testdata.Literals;import net.sourceforge.pmd.typeresolution.testdata.LocalGenericClass;import net.sourceforge.pmd.typeresolution.testdata.MethodAccessibility;import net.sourceforge.pmd.typeresolution.testdata.MethodCallExpressionTypes;import net.sourceforge.pmd.typeresolution.testdata.MethodFirstPhase;import net.sourceforge.pmd.typeresolution.testdata.MethodGenericExplicit;import net.sourceforge.pmd.typeresolution.testdata.MethodGenericParam;import net.sourceforge.pmd.typeresolution.testdata.MethodMostSpecific;import net.sourceforge.pmd.typeresolution.testdata.MethodPotentialApplicability;import net.sourceforge.pmd.typeresolution.testdata.MethodSecondPhase;import net.sourceforge.pmd.typeresolution.testdata.MethodStaticAccess;import net.sourceforge.pmd.typeresolution.testdata.MethodThirdPhase;import net.sourceforge.pmd.typeresolution.testdata.NestedAllocationExpressions;import net.sourceforge.pmd.typeresolution.testdata.NestedAnonymousClass;import net.sourceforge.pmd.typeresolution.testdata.Operators;import net.sourceforge.pmd.typeresolution.testdata.OverloadedMethodsUsage;import net.sourceforge.pmd.typeresolution.testdata.PmdStackOverflow;import net.sourceforge.pmd.typeresolution.testdata.Promotion;import net.sourceforge.pmd.typeresolution.testdata.SubTypeUsage;import net.sourceforge.pmd.typeresolution.testdata.SuperExpression;import net.sourceforge.pmd.typeresolution.testdata.ThisExpression;import net.sourceforge.pmd.typeresolution.testdata.VarArgsMethodUseCase;import net.sourceforge.pmd.typeresolution.testdata.VarargsAsFixedArity;import net.sourceforge.pmd.typeresolution.testdata.VarargsZeroArity;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.Converter;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.GenericClass;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.JavaTypeDefinitionEquals;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.StaticMembers;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassA2;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassAOther2;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassB;import net.sourceforge.pmd.typeresolution.testdata.dummytypes.SuperClassB2;// TODO split that classpublic class ClassTypeResolverTest {    @Test    public void stackOverflowTest() {        // See #831 https://github.com/pmd/pmd/issues/831 - [java] StackOverflow in JavaTypeDefinitionSimple.toString        parseAndTypeResolveForClass15(PmdStackOverflow.class);    }    @Test    public void testClassNameExists() {        ClassTypeResolver classTypeResolver = new ClassTypeResolver();        assertEquals(true, classTypeResolver.classNameExists("java.lang.System"));        assertEquals(false, classTypeResolver.classNameExists("im.sure.that.this.does.not.Exist"));        assertEquals(true, classTypeResolver.classNameExists("java.awt.List"));    }    @Test    public void acceptanceTest() {        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ArrayListFound.class);        assertEquals(ArrayListFound.class, acu.getFirstDescendantOfType(ASTTypeDeclaration.class).getType());        assertEquals(ArrayListFound.class,                     acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());        ASTImportDeclaration id = acu.getFirstDescendantOfType(ASTImportDeclaration.class);        assertEquals("java.util", id.getPackage().getName());        assertEquals(ArrayList.class, id.getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTReferenceType.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTType.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTVariableDeclarator.class).getType());        assertEquals(ArrayList.class, acu.getFirstDescendantOfType(ASTFieldDeclaration.class).getType());        acu = parseAndTypeResolveForClass15(DefaultJavaLangImport.class);        assertEquals(String.class, acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType());        assertEquals(Override.class, acu.findDescendantsOfType(ASTName.class).get(1).getType());    }    /**     * See bug #1138 Anonymous inner class in enum causes NPE     */    @Test    public void testEnumAnonymousInnerClass() {        ASTCompilationUnit acu = parseAndTypeResolveForClass15(EnumWithAnonymousInnerClass.class);        // try it in jshell, an enum constant with a body is compiled to an anonymous class,        // the counter is shared with other anonymous classes of the enum        Class<?> enumAnon = acu.getFirstDescendantOfType(ASTEnumConstant.class).getQualifiedName().getType();        assertEquals("net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$1", enumAnon.getName());        Class<?> inner = acu.getFirstDescendantOfType(ASTAllocationExpression.class)                            .getFirstDescendantOfType(ASTClassOrInterfaceType.class).getType();        assertEquals("net.sourceforge.pmd.typeresolution.testdata.EnumWithAnonymousInnerClass$2", inner.getName());    }    /**     * See bug #899 toString causes NPE     */    @Test    public void testNPEInJavaTypeDefinitionToString() {        // Just parsing this file throws a NPE        parseAndTypeResolveForClass(JavaTypeDefinitionToStringNPE.class, "1.8");    }    @Test    public void testExtraTopLevelClass() throws ClassNotFoundException {        ASTCompilationUnit acu = parseAndTypeResolveForClass15(ExtraTopLevelClass.class);        Class<?> theExtraTopLevelClass = Class                .forName("net.sourceforge.pmd.typeresolution.testdata.TheExtraTopLevelClass");        // First class        ASTTypeDeclaration typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(1);        assertEquals(ExtraTopLevelClass.class, typeDeclaration.getType());        assertEquals(ExtraTopLevelClass.class,                     typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());        // Second class        typeDeclaration = (ASTTypeDeclaration) acu.jjtGetChild(2);        assertEquals(theExtraTopLevelClass, typeDeclaration.getType());        assertEquals(theExtraTopLevelClass,                     typeDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());    }    @Test    public void testInnerClass() throws ClassNotFoundException {        ASTCompilationUnit acu = parseAndTypeResolveForClass15(InnerClass.class);        Class<?> theInnerClass = Class.forName("net.sourceforge.pmd.typeresolution.testdata.InnerClass$TheInnerClass");        // Outer class        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);        assertEquals(InnerClass.class, typeDeclaration.getType());        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(InnerClass.class, outerClassDeclaration.getType());        // Inner class        assertEquals(theInnerClass,                     outerClassDeclaration.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getType());        // Method parameter as inner class        ASTFormalParameter formalParameter = typeDeclaration.getFirstDescendantOfType(ASTFormalParameter.class);        assertEquals(theInnerClass, formalParameter.getType());    }    /**     * If we don't have the auxclasspath, we might not find the inner class. In     * that case, we'll need to search by name for a match.     *     * @throws Exception     */    @Test    public void testInnerClassNotCompiled() throws Exception {        Node acu = parseAndTypeResolveForString("public class TestInnerClass {\n" + "    public void foo() {\n"                                                        + "        Statement statement = new Statement();\n" + "    "                                                        + "}\n" + "    static class Statement {\n"                                                        + "    }\n"                                                        + "}", "1.8");        ASTClassOrInterfaceType statement = acu.getFirstDescendantOfType(ASTClassOrInterfaceType.class);        Assert.assertTrue(statement.isReferenceToClassSameCompilationUnit());    }    @Test    public void testAnonymousClassFromInterface() throws Exception {        Node acu = parseAndTypeResolveForClass(AnonymousClassFromInterface.class, "1.8");        ASTAllocationExpression allocationExpression = acu.getFirstDescendantOfType(ASTAllocationExpression.class);        TypeNode child = (TypeNode) allocationExpression.jjtGetChild(0);        Assert.assertTrue(Comparator.class.isAssignableFrom(child.getType()));        Assert.assertSame(Integer.class, child.getTypeDefinition().getGenericType(0).getType());    }    @Test    public void testNestedAnonymousClass() throws Exception {        Node acu = parseAndTypeResolveForClass(NestedAnonymousClass.class, "1.8");        ASTAllocationExpression allocationExpression = acu.getFirstDescendantOfType(ASTAllocationExpression.class);        ASTAllocationExpression nestedAllocation                = allocationExpression.getFirstDescendantOfType(ASTClassOrInterfaceBodyDeclaration.class) // get the declaration (boundary)                                      .getFirstDescendantOfType(ASTAllocationExpression.class); // and dive for the nested allocation        TypeNode child = (TypeNode) nestedAllocation.jjtGetChild(0);        Assert.assertTrue(Converter.class.isAssignableFrom(child.getType()));        Assert.assertSame(String.class, child.getTypeDefinition().getGenericType(0).getType());    }    @Test    public void testAnonymousExtendingObject() throws Exception {        Node acu = parseAndTypeResolveForClass(AnoymousExtendingObject.class, "1.8");        ASTAllocationExpression allocationExpression = acu.getFirstDescendantOfType(ASTAllocationExpression.class);        TypeNode child = (TypeNode) allocationExpression.jjtGetChild(0);        Assert.assertTrue(Object.class.isAssignableFrom(child.getType()));    }    @Test    public void testAnonymousInnerClass() throws ClassNotFoundException {        ASTCompilationUnit acu = parseAndTypeResolveForClass15(AnonymousInnerClass.class);        Class<?> theAnonymousInnerClass = Class                .forName("net.sourceforge.pmd.typeresolution.testdata.AnonymousInnerClass$1");        // Outer class        ASTTypeDeclaration typeDeclaration = acu.getFirstDescendantOfType(ASTTypeDeclaration.class);        assertEquals(AnonymousInnerClass.class, typeDeclaration.getType());        ASTClassOrInterfaceDeclaration outerClassDeclaration = typeDeclaration                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(AnonymousInnerClass.class, outerClassDeclaration.getType());        // Anonymous Inner class        assertEquals(theAnonymousInnerClass,                     outerClassDeclaration.getFirstDescendantOfType(ASTAllocationExpression.class).getType());    }    @Test    public void testLiterals() throws JaxenException {        List<ASTLiteral> literals = selectNodes(Literals.class, ASTLiteral.class);        int index = 0;        // String s = "s";        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(String.class, literals.get(index++).getType());        // boolean boolean1 = false;        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());        assertEquals(Boolean.TYPE, literals.get(index++).getType());        // boolean boolean2 = true;        assertEquals(Boolean.TYPE, literals.get(index).getFirstDescendantOfType(ASTBooleanLiteral.class).getType());        assertEquals(Boolean.TYPE, literals.get(index++).getType());        // Object obj = null;        assertNull(literals.get(index).getFirstDescendantOfType(ASTNullLiteral.class).getType());        assertNull(literals.get(index++).getType());        // byte byte1 = 0;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // byte byte2 = 0x0F;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // byte byte3 = -007;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // short short1 = 0;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // short short2 = 0x0F;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // short short3 = -007;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char1 = 0;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char2 = 0x0F;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char3 = 007;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // char char4 = 'a';        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // int int1 = 0;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // int int2 = 0x0F;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // int int3 = -007;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // int int4 = 'a';        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // long long1 = 0;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // long long2 = 0x0F;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // long long3 = -007;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // long long4 = 0L;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Long.TYPE, literals.get(index++).getType());        // long long5 = 0x0Fl;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Long.TYPE, literals.get(index++).getType());        // long long6 = -007L;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Long.TYPE, literals.get(index++).getType());        // long long7 = 'a';        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // float float1 = 0.0f;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Float.TYPE, literals.get(index++).getType());        // float float2 = -10e+01f;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Float.TYPE, literals.get(index++).getType());        // float float3 = 0x08.08p3f;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Float.TYPE, literals.get(index++).getType());        // float float4 = 0xFF;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // float float5 = 'a';        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // double double1 = 0.0;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Double.TYPE, literals.get(index++).getType());        // double double2 = -10e+01;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Double.TYPE, literals.get(index++).getType());        // double double3 = 0x08.08p3;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Double.TYPE, literals.get(index++).getType());        // double double4 = 0xFF;        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Integer.TYPE, literals.get(index++).getType());        // double double5 = 'a';        assertEquals(0, literals.get(index).jjtGetNumChildren());        assertEquals(Character.TYPE, literals.get(index++).getType());        // Make sure we got them all.        assertEquals("All literals not tested", index, literals.size());    }    @Test    public void testUnaryNumericPromotion() throws JaxenException {        List<ASTExpression> expressions = selectNodes(Promotion.class, ASTExpression.class,                                                      "//Block[preceding-sibling::MethodDeclarator[@Image = "                                                              + "'unaryNumericPromotion']]//Expression[UnaryExpression]");        int index = 0;        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryNumericPromotion() throws JaxenException {        List<ASTExpression> expressions = selectNodes(Promotion.class, ASTExpression.class,                                                      "//Block[preceding-sibling::MethodDeclarator[@Image = "                                                              + "'binaryNumericPromotion']]//Expression[AdditiveExpression]");        int index = 0;        // LHS = byte        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = short        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = char        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = int        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = long        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = float        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Float.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // LHS = double        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryStringPromotion() throws JaxenException {        List<ASTExpression> expressions = selectNodes(Promotion.class, ASTExpression.class,                                                      "//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryStringPromotion']]//Expression");        int index = 0;        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        assertEquals(String.class, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testUnaryLogicalOperators() throws JaxenException {        List<ASTExpression> expressions = selectNodes(Operators.class, ASTExpression.class,                                                      "//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryLogicalOperators']]//Expression");        int index = 0;        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryLogicalOperators() throws JaxenException {        List<ASTExpression> expressions = selectNodes(Operators.class, ASTExpression.class,                                                      "//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryLogicalOperators']]//Expression");        int index = 0;        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        assertEquals(Boolean.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testUnaryNumericOperators() throws JaxenException {        List<TypeNode> expressions = selectNodes(Operators.class, TypeNode.class,                                               "//Block[preceding-sibling::MethodDeclarator[@Image = 'unaryNumericOperators']]"                                                       + "//*[self::Expression or self::PostfixExpression or self::PreIncrementExpression or self::PreDecrementExpression]");        int index = 0;        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        assertEquals(Double.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBinaryNumericOperators() throws JaxenException {        List<ASTExpression> expressions = selectNodes(Operators.class, ASTExpression.class,                                                      "//Block[preceding-sibling::MethodDeclarator[@Image = 'binaryNumericOperators']]//Expression");        int index = 0;        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        assertEquals(Integer.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testAssignmentOperators() throws JaxenException {        List<ASTStatementExpression> expressions = selectNodes(Operators.class, ASTStatementExpression.class,                                                               "//Block[preceding-sibling::MethodDeclarator[@Image = "                                                                       + "'assignmentOperators']]//StatementExpression");        int index = 0;        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        assertEquals(Long.TYPE, expressions.get(index++).getType());        // Make sure we got them all.        assertEquals("All expressions not tested", index, expressions.size());    }    /**     * The type should be filled also on the ASTVariableDeclaratorId node, not     * only on the variable name declaration.     */    @Test    public void testFullyQualifiedType() {        String source = "public class Foo {\n" + "    public void bar() {\n"                + "        java.util.StringTokenizer st = new StringTokenizer(\"a.b.c.d\", \".\");\n"                + "        while (st.hasMoreTokens()) {\n" + "            System.out.println(st.nextToken());\n"                + "        }\n" + "    }\n" + "}";        ASTCompilationUnit acu = parseAndTypeResolveForString(source, "1.5");        List<ASTName> names = acu.findDescendantsOfType(ASTName.class);        ASTName theStringTokenizer = null;        for (ASTName name : names) {            if (name.hasImageEqualTo("st.hasMoreTokens")) {                theStringTokenizer = name;                break;            }        }        Assert.assertNotNull(theStringTokenizer);        VariableNameDeclaration declaration = (VariableNameDeclaration) theStringTokenizer.getNameDeclaration();        Assert.assertNotNull(declaration);        Assert.assertEquals("java.util.StringTokenizer", declaration.getTypeImage());        Assert.assertNotNull(declaration.getType());        Assert.assertSame(StringTokenizer.class, declaration.getType());        ASTVariableDeclaratorId id = (ASTVariableDeclaratorId) declaration.getNode();        Assert.assertNotNull(id.getType());        Assert.assertSame(StringTokenizer.class, id.getType());    }    @Test    public void testThisExpression() {        ASTCompilationUnit compilationUnit = parseAndTypeResolveForClass15(ThisExpression.class);        // need to cross borders, to find expressions of the nested classes        List<ASTPrimaryExpression> expressions = compilationUnit.findDescendantsOfType(ASTPrimaryExpression.class, true);        List<ASTPrimaryPrefix> prefixes = compilationUnit.findDescendantsOfType(ASTPrimaryPrefix.class, true);        int index = 0;        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index++).getType());        assertEquals(ThisExpression.ThisExprNested.class, expressions.get(index).getType());        assertEquals(ThisExpression.ThisExprNested.class, prefixes.get(index++).getType());        // Qualified this        assertEquals(ThisExpression.class, expressions.get(index).getType());        assertEquals(ThisExpression.class, prefixes.get(index).getType());        assertEquals(ThisExpression.class, ((TypeNode) expressions.get(index++).jjtGetChild(1)).getType());        assertEquals(ThisExpression.ThisExprStaticNested.class, expressions.get(index).getType());        assertEquals(ThisExpression.ThisExprStaticNested.class, prefixes.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());        assertEquals("All expressions not tested", index, prefixes.size());    }    @Test    public void testSuperExpression() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(SuperExpression.class, AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix");        int index = 0;        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperClassA.class, expressions.get(index++).getType());        assertEquals(SuperExpression.class, ((TypeNode) expressions.get(index).jjtGetParent().jjtGetChild(0))                .getType());        assertEquals(SuperClassA.class, ((TypeNode) expressions.get(index++).jjtGetParent().jjtGetChild(1)).getType());        assertEquals(SuperExpression.class, expressions.get(index++).getType());        assertEquals(SuperExpression.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testArrayTypes() throws JaxenException {        // We must not select the expression in the dimensions        List<ASTExpression> expressions = selectNodes(ArrayTypes.class, ASTExpression.class, "//VariableInitializer/Expression");        int index = 0;        // int[] a = new int[1];        //           ----------        assertEquals(int[].class, expressions.get(index++).getType());        // Object[][] b = new Object[1][0];        //                ----------------        assertEquals(Object[][].class, expressions.get(index++).getType());        // ArrayTypes[][][] c = new ArrayTypes[][][] { new ArrayTypes[1][2] };        //                      ---------------------------------------------        assertEquals(ArrayTypes[][][].class, expressions.get(index++).getType());        // ArrayTypes[][][] c = new ArrayTypes[][][] { new ArrayTypes[1][2] };        //                                             --------------------        assertEquals(ArrayTypes[][].class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testArrayAccess() throws JaxenException {        List<ASTExpression> expressions = selectNodes(ArrayAccess.class, ASTExpression.class, "//VariableInitializer/Expression");        int index = 1;        // int aElement = a[0];        assertEquals(int.class, expressions.get(index).getType());        index += 2;        // Object bElement = b[0][0];        assertEquals(Object.class, expressions.get(index).getType());        index += 3;        // ArrayAccess cElement = c[0][0][0];        assertEquals(ArrayAccess.class, expressions.get(index).getType());    }    @Test    public void testReferenceType() {        List<ASTReferenceType> referenceTypes = selectNodes(ArrayTypes.class, ASTReferenceType.class);        int index = 0;        // int[] a = new int[1];        // -----        assertEquals(int[].class, referenceTypes.get(index++).getType());        // Object[][] b = new Object[1][0];        // ----------        assertEquals(Object[][].class, referenceTypes.get(index++).getType());        // ArrayTypes[][][] c = new ArrayTypes[][][] { ... };        // ----------------        assertEquals(ArrayTypes[][][].class, referenceTypes.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, referenceTypes.size());    }    @Test    public void testHeterogeneousArrayFieldDeclaration() throws JaxenException {        List<ASTFieldDeclaration> fields = selectNodes(ArrayVariableDeclaration.class, ASTFieldDeclaration.class);        List<ASTLocalVariableDeclaration> locals = selectNodes(ArrayVariableDeclaration.class, ASTLocalVariableDeclaration.class);        // public int[] a, b[];        testPrimitiveTypeFieldDecl(fields.get(0));        testPrimitiveTypeFieldDecl(locals.get(0));        // public String[] c, d[];        testRefTypeFieldDecl(fields.get(1));        testRefTypeFieldDecl(locals.get(1));    }    // subtest    private void testPrimitiveTypeFieldDecl(Node declaration) throws JaxenException {        // public int[] a, b[];        ASTReferenceType typeNode = declaration.getFirstChildOfType(ASTType.class).getFirstChildOfType(ASTReferenceType.class);        assertNotNull(typeNode);        assertTrue(typeNode.isArray());        assertEquals(1, typeNode.getArrayDepth());        assertEquals("int", typeNode.getFirstChildOfType(ASTPrimitiveType.class).getImage());        ASTVariableDeclaratorId aID = declaration.getFirstChildOfType(ASTVariableDeclarator.class).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(aID);        assertEquals("a", aID.getImage());        assertFalse(aID.isArray());        assertEquals(0, aID.getArrayDepth());        assertEquals(int[].class, aID.getType());        ASTVariableDeclaratorId bID = declaration.findChildrenOfType(ASTVariableDeclarator.class).get(1).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(bID);        assertEquals("b", bID.getImage());        assertTrue(bID.isArray());        assertEquals(1, bID.getArrayDepth());        assertEquals(int[][].class, bID.getType());    }    // subtest    private void testRefTypeFieldDecl(Node declaration) throws JaxenException {        // public String[] c, d[];        ASTReferenceType typeNode = declaration.getFirstChildOfType(ASTType.class).getFirstChildOfType(ASTReferenceType.class);        assertNotNull(typeNode);        assertTrue(typeNode.isArray());        assertEquals(1, typeNode.getArrayDepth());        assertEquals("String", typeNode.getFirstChildOfType(ASTClassOrInterfaceType.class).getImage());        ASTVariableDeclaratorId cID = declaration.getFirstChildOfType(ASTVariableDeclarator.class).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(cID);        assertEquals("c", cID.getImage());        assertFalse(cID.isArray());        assertEquals(0, cID.getArrayDepth());        assertEquals(String[].class, cID.getType());        ASTVariableDeclaratorId dID = declaration.findChildrenOfType(ASTVariableDeclarator.class).get(1).getFirstChildOfType(ASTVariableDeclaratorId.class);        assertNotNull(dID);        assertEquals("d", dID.getImage());        assertTrue(dID.isArray());        assertEquals(1, dID.getArrayDepth());        assertEquals(String[][].class, dID.getType());    }    @Test    public void testFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccess.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // param.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // local.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // f.f.f.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // (this).f.f.field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(FieldAccess.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccess.class, getChildType(expressions.get(index), 1));        assertEquals(FieldAccess.class, getChildType(expressions.get(index), 2));        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 3));        // field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessNested() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessNested.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // field = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // a = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 0));        // net.sourceforge.pmd.typeresolution.javasymbols.testdata.FieldAccessNested.Nested.this.a = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // FieldAccessNested.Nested.this.a = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccessNested.Nested.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessShadow() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessShadow.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // field = "shadow";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // this.field = new Integer(10);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(FieldAccessShadow.class, getChildType(expressions.get(index), 0));        assertEquals(Integer.class, getChildType(expressions.get(index++), 1));        // (this).field = new Integer(10);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(FieldAccessShadow.class, getChildType(expressions.get(index), 0));        assertEquals(Integer.class, getChildType(expressions.get(index++), 1));        // s2 = new SuperClassB2();        assertEquals(SuperClassB2.class, expressions.get(index).getType());        assertEquals(SuperClassB2.class, getChildType(expressions.get(index++), 0));        // privateShadow = 10;        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessSuper() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessSuper.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 0));        // (this).s.s2 = new SuperClassA2();        assertEquals(SuperClassA2.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA2.class, getChildType(expressions.get(index++), 2));        // s.s.s2 = new SuperClassA2();        assertEquals(SuperClassA2.class, expressions.get(index).getType());        assertEquals(SuperClassA2.class, getChildType(expressions.get(index++), 0));        // super.s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 1));        // net.sourceforge.pmd.typeresolution.javasymbols.testdata.FieldAccessSuper.this.s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 0));        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 0));        // bs = new SuperClassB();        assertEquals(SuperClassB.class, expressions.get(index).getType());        assertEquals(SuperClassB.class, getChildType(expressions.get(index++), 0));        // FieldAccessSuper.Nested.super.bs = new SuperClassB();        assertEquals(SuperClassB.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.Nested.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassB.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassB.class, getChildType(expressions.get(index++), 2));        // FieldAccessSuper.super.s = new SuperClassA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(FieldAccessSuper.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 1));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testBoundsGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericBounds.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // superGeneric.first = ""; // ? super String        assertEquals(forClass(LOWER_WILDCARD, String.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(LOWER_WILDCARD, String.class), getChildTypeDef(expressions.get(index++), 0));        // superGeneric.second = null; // ?        assertEquals(forClass(UPPER_WILDCARD, Object.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, Object.class), getChildTypeDef(expressions.get(index++), 0));        // inheritedSuperGeneric.first = ""; // ? super String        assertEquals(forClass(LOWER_WILDCARD, String.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(LOWER_WILDCARD, String.class), getChildTypeDef(expressions.get(index++), 0));        // inheritedSuperGeneric.second = null; // ?        assertEquals(forClass(UPPER_WILDCARD, Object.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, Object.class), getChildTypeDef(expressions.get(index++), 0));        // upperBound.first = null; // ? extends Number        assertEquals(forClass(UPPER_WILDCARD, Number.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, Number.class), getChildTypeDef(expressions.get(index++), 0));        // inheritedUpperBound.first = null; // ? extends String        assertEquals(forClass(UPPER_WILDCARD, String.class), expressions.get(index).getTypeDefinition());        assertEquals(forClass(UPPER_WILDCARD, String.class), getChildTypeDef(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testParameterGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericParameter.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // classGeneric = null; // Double        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        // localGeneric = null; // Character        assertEquals(Character.class, expressions.get(index).getType());        assertEquals(Character.class, getChildType(expressions.get(index++), 0));        // parameterGeneric.second.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // localGeneric = null; // Number        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testSimpleGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericSimple.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // genericField.first = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // genericField.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        //genericTypeArg.second.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        // param.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // local.second = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // param.generic.first = new Character('c');        assertEquals(Character.class, expressions.get(index).getType());        assertEquals(Character.class, getChildType(expressions.get(index++), 0));        // local.generic.second = new Float(0);        assertEquals(Float.class, expressions.get(index).getType());        assertEquals(Float.class, getChildType(expressions.get(index++), 0));        // genericField.generic.generic.generic.first = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 0));        // fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // fieldB.generic.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // fieldAcc.fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testRawGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericRaw.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // rawGeneric.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // rawGeneric.third = new Object();        assertEquals(Object.class, expressions.get(index).getType());        assertEquals(Object.class, getChildType(expressions.get(index++), 0));        // rawGeneric.fourth.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // rawGeneric.rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.third = new Object();        assertEquals(Object.class, expressions.get(index).getType());        assertEquals(Object.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.fourth.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.first = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.third = new Object();        assertEquals(Object.class, expressions.get(index).getType());        assertEquals(Object.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.fourth.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.rawGeneric.second = new Integer(0);        assertEquals(Integer.class, expressions.get(index).getType());        assertEquals(Integer.class, getChildType(expressions.get(index++), 0));        // bug #471        // rawGeneric.fifth = new GenericClass();        assertEquals(GenericClass.class, expressions.get(index).getType());        assertEquals(GenericClass.class, getChildType(expressions.get(index++), 0));        // inheritedRawGeneric.fifth = new GenericClass();        assertEquals(GenericClass.class, expressions.get(index).getType());        assertEquals(GenericClass.class, getChildType(expressions.get(index++), 0));        // parameterRawGeneric.fifth = new GenericClass();        assertEquals(GenericClass.class, expressions.get(index).getType());        assertEquals(GenericClass.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testPrimarySimpleGenericFieldAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessPrimaryGenericSimple.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // this.genericField.first = "";        assertEquals(String.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 1, String.class, Double.class);        assertEquals(String.class, getChildType(expressions.get(index++), 2));        // (this).genericField.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 1, String.class, Double.class);        assertEquals(Double.class, getChildType(expressions.get(index++), 2));        // this.genericTypeArg.second.second = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 2, Number.class, Double.class);        assertEquals(Double.class, getChildType(expressions.get(index++), 3));        // (this).genericField.generic.generic.generic.first = new Double(0);        assertEquals(Double.class, expressions.get(index).getType());        assertEquals(Double.class, getChildType(expressions.get(index++), 5));        // (this).fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 1));        // this.fieldB.generic.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 3));        // super.fieldA = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertChildTypeArgsEqualTo(expressions.get(index), 0, Long.class);        assertEquals(Long.class, getChildType(expressions.get(index++), 1));        // super.fieldB.generic.second = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 3));        // this.field.first = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessGenericNested() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessGenericNested.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // n.field = null;        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // n.generic.first = null;        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testFieldAccessStatic() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(FieldAccessStatic.class, AbstractJavaTypeNode.class,                                                             "//StatementExpression/PrimaryExpression");        int index = 0;        // staticPrimitive = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // staticGeneric.first = new Long(0);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // StaticMembers.staticPrimitive = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // net.sourceforge.pmd.typeresolution.javasymbols.testdata.dummytypes.StaticMembers.staticPrimitive = 10;        assertEquals(Integer.TYPE, expressions.get(index).getType());        assertEquals(Integer.TYPE, getChildType(expressions.get(index++), 0));        // net.sourceforge.pmd.typeresolution.javasymbols.testdata.dummytypes.StaticMembers        //       .staticGeneric.generic.second = new Long(10);        assertEquals(Long.class, expressions.get(index).getType());        assertEquals(Long.class, getChildType(expressions.get(index++), 0));        // staticPrimitive = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // staticChar = 3.1; // it's a double        assertEquals(Double.TYPE, expressions.get(index).getType());        assertEquals(Double.TYPE, getChildType(expressions.get(index++), 0));        // FieldAccessStatic.Nested.staticPrimitive = "";        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index++), 0));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodPotentialApplicability() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodPotentialApplicability.class, AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int a = vararg("");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // int b = vararg("", 10);        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // String c = notVararg(0, 0);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Number d = noArguments();        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index), 0));        assertEquals(Number.class, getChildType(expressions.get(index++), 1));        // Number e = field.noArguments();        assertEquals(Number.class, expressions.get(index).getType());        assertEquals(Number.class, getChildType(expressions.get(index), 0));        assertEquals(Number.class, getChildType(expressions.get(index++), 1));        // int f = this.vararg("");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 1));        assertEquals(int.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodAccessibility() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodAccessibility.class, AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // SuperClassA a = inheritedA();        assertEquals(SuperClassA.class, expressions.get(index).getType());        assertEquals(SuperClassA.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA.class, getChildType(expressions.get(index++), 1));        // SuperClassB b = inheritedB();        assertEquals(SuperClassB.class, expressions.get(index).getType());        assertEquals(SuperClassB.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassB.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodFirstPhase() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodFirstPhase.class, "1.8", AbstractJavaTypeNode.class,                                                             "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int a = subtype(10, 'a', "");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // Exception b = vararg((Object) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // Set<String> set = new HashSet<>();        assertEquals(HashSet.class, expressions.get(index++).getType());        // List<String> myList = new ArrayList<>();        assertEquals(ArrayList.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodMostSpecific() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodMostSpecific.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // String a = moreSpecific((Number) null, (AbstractCollection) null);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Exception b = moreSpecific((Integer) null, (AbstractList) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int c = moreSpecific((Double) null, (RoleList) null);        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodSecondPhase() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodSecondPhase.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // String a = boxing(10, "");        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Exception b = boxing('a', "");        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int c = boxing(10L, "");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // String d = unboxing("", (Integer) null);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Exception e = unboxing("", (Character) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int f = unboxing("", (Byte) null);        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodThirdPhase() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodThirdPhase.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // Exception a = vararg(10, (Number) null, (Number) null);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // Exception b = vararg(10);        assertEquals(Exception.class, expressions.get(index).getType());        assertEquals(Exception.class, getChildType(expressions.get(index), 0));        assertEquals(Exception.class, getChildType(expressions.get(index++), 1));        // int c = vararg(10, "", "", "");        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // String d = mostSpecific(10, 10, 10);        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 0));        assertEquals(String.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodStaticAccess() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodStaticAccess.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int a = primitiveStaticMethod();        assertEquals(int.class, expressions.get(index).getType());        assertEquals(int.class, getChildType(expressions.get(index), 0));        assertEquals(int.class, getChildType(expressions.get(index++), 1));        // StaticMembers b = staticInstanceMethod();        assertEquals(StaticMembers.class, expressions.get(index).getType());        assertEquals(StaticMembers.class, getChildType(expressions.get(index), 0));        assertEquals(StaticMembers.class, getChildType(expressions.get(index++), 1));        // int c = StaticMembers.primitiveStaticMethod();        assertEquals(int.class, expressions.get(index).getType());        assertEquals(StaticMembers.class, getChildType(expressions.get(index), 0)); // PrimaryPrefix        assertEquals(int.class, getChildType(expressions.get(index++), 1)); // PrimarySuffix        // String c = MethodStaticAccess.Nested.primitiveStaticMethod();        assertEquals(String.class, expressions.get(index).getType());        assertEquals(MethodStaticAccess.Nested.class, getChildType(expressions.get(index), 0)); // PrimaryPrefix        assertEquals(String.class, getChildType(expressions.get(index++), 1)); // PrimarySuffix        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodGenericExplicit() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(MethodGenericExplicit.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // String s = this.<String>foo();        assertEquals(String.class, expressions.get(index).getType());        assertEquals(String.class, getChildType(expressions.get(index), 1));        assertEquals(String.class, getChildType(expressions.get(index++), 2));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testGenericArrays() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(GenericsArrays.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // List<String> var = Arrays.asList(params);        AbstractJavaTypeNode expression = expressions.get(index++);        // TODO : Type inference is still incomplete, we fail to detect the return type of the method        //assertEquals(List.class, expression.getTypeDefinition().getType());        //assertEquals(String.class, expression.getTypeDefinition().getGenericType(0).getType());        // List<String> var2 = Arrays.<String>asList(params);        AbstractJavaTypeNode expression2 = expressions.get(index++);        assertEquals(List.class, expression2.getTypeDefinition().getType());        assertEquals(String.class, expression2.getTypeDefinition().getGenericType(0).getType());        // List<String[]> var3 = Arrays.<String[]>asList(params);        AbstractJavaTypeNode expression3 = expressions.get(index++);        assertEquals(List.class, expression3.getTypeDefinition().getType());        assertEquals(String[].class, expression3.getTypeDefinition().getGenericType(0).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodTypeInference() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(GenericMethodsImplicit.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // SuperClassA2 a = bar((SuperClassA) null, (SuperClassAOther) null, null, (SuperClassAOther2) null);        assertEquals(SuperClassA2.class, expressions.get(index).getType());        assertEquals(SuperClassA2.class, getChildType(expressions.get(index), 0));        assertEquals(SuperClassA2.class, getChildType(expressions.get(index++), 1));        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodTypeInferenceVarargsZeroArity() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(VarargsZeroArity.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int var = aMethod();        assertEquals(int.class, expressions.get(index++).getType());        //String var2 = aMethod("");        assertEquals(String.class, expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testMethodTypeInferenceVarargsAsFixedArity() throws JaxenException {        List<AbstractJavaTypeNode> expressions = selectNodes(VarargsAsFixedArity.class, AbstractJavaTypeNode.class, "//VariableInitializer/Expression/PrimaryExpression");        int index = 0;        // int var = aMethod("");        assertEquals(int.class, expressions.get(index++).getType());        // String var2 = aMethod();        assertEquals(String.class, expressions.get(index++).getType());        // String var3 = aMethod("", "");        assertEquals(String.class, expressions.get(index++).getType());        // String var4 = aMethod(new Object[] { null });        assertEquals(String.class, expressions.get(index++).getType());        // null literal has null type        assertNull(expressions.get(index++).getType());        // Make sure we got them all        assertEquals("All expressions not tested", index, expressions.size());    }    @Test    public void testJavaTypeDefinitionEquals() {        JavaTypeDefinition a = forClass(Integer.class);        JavaTypeDefinition b = forClass(Integer.class);        // test non-generic types        assertEquals(a, b);        assertNotEquals(a, null);        // test generic arg equality        b = forClass(List.class, a);        a = forClass(List.class, a);        assertEquals(a, b);        a = forClass(List.class, forClass(String.class));        assertNotEquals(a, b);        assertNotEquals(b, a);        // test raw vs proper, proper vs raw        a = forClass(JavaTypeDefinitionEquals.class);        b = forClass(JavaTypeDefinitionEquals.class,                     forClass(List.class, a));        assertEquals(a, b);        assertEquals(b, a);    }    @Test    public void testJavaTypeDefinitionGetSuperTypeSet() {        JavaTypeDefinition originalTypeDef = forClass(List.class,                                                      forClass(Integer.class));        Set<JavaTypeDefinition> set = originalTypeDef.getSuperTypeSet();        assertEquals(set.size(), 4);        assertTrue(set.contains(forClass(Object.class)));        assertTrue(set.contains(originalTypeDef));        assertTrue(set.contains(forClass(Collection.class,                                         forClass(Integer.class))));        assertTrue(set.contains(forClass(Iterable.class,                                         forClass(Integer.class))));    }    @Test    public void testJavaTypeDefinitionGetErasedSuperTypeSet() {        JavaTypeDefinition originalTypeDef = forClass(List.class,                                                      forClass(Integer.class));        Set<Class<?>> set = originalTypeDef.getErasedSuperTypeSet();        assertEquals(set.size(), 4);        assertTrue(set.contains(Object.class));        assertTrue(set.contains(Collection.class));        assertTrue(set.contains(Iterable.class));        assertTrue(set.contains(List.class));    }    @Test    public void testMethodInitialBounds() throws NoSuchMethodException {        JavaTypeDefinition context = forClass(GenericMethodsImplicit.class,                                              forClass(Thread.class));        List<Variable> variables = new ArrayList<>();        List<Bound> initialBounds = new ArrayList<>();        Method method = GenericMethodsImplicit.class.getMethod("foo");        MethodTypeResolution.produceInitialBounds(method, context, variables, initialBounds);        assertEquals(initialBounds.size(), 6);        // A        assertTrue(initialBounds.contains(new Bound(variables.get(0),                                                    forClass(Object.class), SUBTYPE)));        // B        assertTrue(initialBounds.contains(new Bound(variables.get(1),                                                    forClass(Number.class), SUBTYPE)));        assertTrue(initialBounds.contains(new Bound(variables.get(1),                                                    forClass(Runnable.class), SUBTYPE)));        // C        assertTrue(initialBounds.contains(new Bound(variables.get(2), variables.get(3), SUBTYPE)));        assertTrue(initialBounds.contains(new Bound(variables.get(2),                                                    forClass(Object.class), SUBTYPE)));        // D        assertTrue(initialBounds.contains(new Bound(variables.get(3),                                                    forClass(Thread.class), SUBTYPE)));    }    @Test    public void testMethodInitialConstraints() throws NoSuchMethodException, JaxenException {        List<AbstractJavaNode> expressions = selectNodes(GenericMethodsImplicit.class, AbstractJavaNode.class, "//ArgumentList");        List<Variable> variables = new ArrayList<>();        for (int i = 0; i < 2; ++i) {            variables.add(new Variable());        }        Method method = GenericMethodsImplicit.class.getMethod("bar", Object.class, Object.class,                                                               Integer.class, Object.class);        ASTArgumentList argList = (ASTArgumentList) expressions.get(0);        List<Constraint> constraints = MethodTypeResolution.produceInitialConstraints(method, argList, variables);        assertEquals(constraints.size(), 3);        // A        assertTrue(constraints.contains(new Constraint(forClass(SuperClassA.class),                                                       variables.get(0), LOOSE_INVOCATION)));        assertTrue(constraints.contains(new Constraint(forClass(SuperClassAOther.class),                                                       variables.get(0),                                                       LOOSE_INVOCATION)));        // B        assertTrue(constraints.contains(new Constraint(forClass(SuperClassAOther2.class),                                                       variables.get(1),                                                       LOOSE_INVOCATION)));    }    @Test    public void testMethodParameterization() throws NoSuchMethodException {        ASTArgumentList argList = selectNodes(GenericMethodsImplicit.class, ASTArgumentList.class).get(0);        JavaTypeDefinition context = forClass(GenericMethodsImplicit.class, forClass(Thread.class));        Method method = GenericMethodsImplicit.class.getMethod("bar", Object.class, Object.class,                                                               Integer.class, Object.class);        MethodType inferedMethod = MethodTypeResolution.parameterizeInvocation(context, method, argList);        assertEquals(inferedMethod.getParameterTypes().get(0),                     forClass(SuperClassA2.class));        assertEquals(inferedMethod.getParameterTypes().get(1),                     forClass(SuperClassA2.class));        assertEquals(inferedMethod.getParameterTypes().get(2),                     forClass(Integer.class));        assertEquals(inferedMethod.getParameterTypes().get(3),                     forClass(SuperClassAOther2.class));    }    @Test    public void testNestedAllocationExpressions() {        ASTCompilationUnit acu = parseAndTypeResolveForClass15(NestedAllocationExpressions.class);        List<ASTAllocationExpression> allocs = acu.findDescendantsOfType(ASTAllocationExpression.class);        assertFalse(allocs.get(0).isAnonymousClass());        assertEquals(Thread.class, allocs.get(0).getType());        assertTrue(allocs.get(1).isAnonymousClass());        // FUTURE 1.8 use Class.getTypeName() instead of toString        assertTrue(allocs.get(1).getType().toString().endsWith("NestedAllocationExpressions$1"));    }    @Test    public void testAnnotatedTypeParams() {        parseAndTypeResolveForString("public class Foo { public static <T extends @NonNull Enum<?>> T getEnum() { return null; } }", "1.8");    }    @Test    public void testMethodOverrides() throws Exception {        parseAndTypeResolveForClass(SubTypeUsage.class, "1.8");    }    @Test    public void testMethodWildcardParam() throws Exception {        parseAndTypeResolveForClass(MethodGenericParam.class, "1.8");    }    @Test    public void testAbstractMethodReturnType() throws Exception {        parseAndTypeResolveForClass(AbstractReturnTypeUseCase.class, "1.8");    }    @Test    public void testMethodOverloaded() throws Exception {        parseAndTypeResolveForClass(OverloadedMethodsUsage.class, "1.8");    }    @Test    public void testVarArgsMethodUseCase() throws Exception {        parseAndTypeResolveForClass(VarArgsMethodUseCase.class, "1.8");    }    @Test    public void testLocalGenericClass() throws Exception {        parseAndTypeResolveForClass(LocalGenericClass.class, "9");    }    @Test    public void testMethodCallExpressionTypes() throws Exception {        ASTCompilationUnit cu = parseAndTypeResolveForClass(MethodCallExpressionTypes.class, "11");        ASTPrimaryExpression expr = cu.getFirstDescendantOfType(ASTPrimaryExpression.class);        assertEquals(forClass(String.class), expr.getTypeDefinition());        assertEquals(forClass(Objects.class), expr.getFirstChildOfType(ASTPrimaryPrefix.class).getTypeDefinition());    }    private JavaTypeDefinition getChildTypeDef(Node node, int childIndex) {        return ((TypeNode) node.jjtGetChild(childIndex)).getTypeDefinition();    }    private Class<?> getChildType(Node node, int childIndex) {        return ((TypeNode) node.jjtGetChild(childIndex)).getType();    }    private ASTCompilationUnit parseAndTypeResolveForClass15(Class<?> clazz) {        return parseAndTypeResolveForClass(clazz, "1.5");    }    // Note: If you're using Eclipse or some other IDE to run this test, you    // _must_ have the src/test/java folder in    // the classpath. Normally the IDE doesn't put source directories themselves    // directly in the classpath, only    // the output directories are in the classpath.    private ASTCompilationUnit parseAndTypeResolveForClass(Class<?> clazz, String version) {        return parseAndTypeResolveForString(ParserTstUtil.getSourceFromClass(clazz), version);    }    private ASTCompilationUnit parseAndTypeResolveForString(String source, String version) {        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(JavaLanguageModule.NAME)                                                                        .getVersion(version).getLanguageVersionHandler();        ASTCompilationUnit acu = (ASTCompilationUnit) languageVersionHandler                .getParser(languageVersionHandler.getDefaultParserOptions()).parse(null, new StringReader(source));        languageVersionHandler.getQualifiedNameResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);        languageVersionHandler.getSymbolFacade().start(acu);        languageVersionHandler.getTypeResolutionFacade(ClassTypeResolverTest.class.getClassLoader()).start(acu);        return acu;    }    private void assertChildTypeArgsEqualTo(Node node, int childIndex, Class<?>... classes) {        JavaTypeDefinition typeDef = ((TypeNode) node.jjtGetChild(childIndex)).getTypeDefinition();        for (int index = 0; index < classes.length; ++index) {            assertSame(classes[index], typeDef.getGenericType(index).getType());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.util.regex.Pattern;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.util.FileUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CLITest extends BaseCLITest {    @Test    public void minimalArgs() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/bestpractices.xml,category/java/design.xml", };        runTest(args, "minimalArgs");    }    @Test    public void minimumPriority() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-min", "1", };        runTest(args, "minimumPriority");    }    @Test    public void usingDebug() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-debug", };        runTest(args, "minimalArgsWithDebug");    }    @Test    public void changeJavaVersion() throws IOException {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-version", "1.5", "-language",            "java", "-debug", };        String resultFilename = runTest(args, "chgJavaVersion");        assertTrue("Invalid Java version",                FileUtil.findPatternInFile(new File(resultFilename), "Using Java version: Java 1.5"));    }    @Test    public void exitStatusNoViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", };        runTest(args, "exitStatusNoViolations");    }    @Test    public void exitStatusWithViolations() throws IOException {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/errorprone.xml", };        String resultFilename = runTest(args, "exitStatusWithViolations", 4);        assertTrue(FileUtil.findPatternInFile(new File(resultFilename), "Avoid empty if"));    }    @Test    public void exitStatusWithViolationsAndWithoutFailOnViolations() throws IOException {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/errorprone.xml", "-failOnViolation", "false", };        String resultFilename = runTest(args, "exitStatusWithViolationsAndWithoutFailOnViolations", 0);        assertTrue(FileUtil.findPatternInFile(new File(resultFilename), "Avoid empty if"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRuleset() throws Exception {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename),                "Can't find resource 'category/java/designn.xml' for rule 'null'." + "  Make sure the resource is a valid file"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulesetWithRulename() throws Exception {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml/UseCollectionIsEmpty", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename),                "Can't find resource 'category/java/designn.xml' for rule " + "'UseCollectionIsEmpty'."));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulename() throws Exception {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml/ThisRuleDoesNotExist", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename), Pattern                .quote("No rules found. Maybe you mispelled a rule name?" + " (category/java/design.xml/ThisRuleDoesNotExist)")));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on Java file with default options.     */    @Test    public void testJavaFileUsingDefaults() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals("LanguageVersion must be Java 13 !",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13"), languageVersion);    }    /**     * Test on Java file with Java version set to 1.4.     */    @Test    public void testJavaFileUsing14() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        discoverer.setDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"));        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals("LanguageVersion must be Java 1.4!",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), languageVersion);    }    @Test    public void testLanguageVersionDiscoverer() {        PMDConfiguration configuration = new PMDConfiguration();        LanguageVersionDiscoverer languageVersionDiscoverer = configuration.getLanguageVersionDiscoverer();        assertEquals("Default Java version", LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13"),                languageVersionDiscoverer                        .getDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)));        configuration                .setDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals("Modified Java version", LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"),                languageVersionDiscoverer                        .getDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection data() {        return Arrays.asList(new Object[][] {            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.3",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.3"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.4",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.5",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.6",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.6"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.7",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.7"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.8",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "9",                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("9"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "10",                        LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("10"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "11",                            LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("11"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12",                                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("12"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12-preview",                                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("12-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13",                                        LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13-preview",                                            LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13-preview"), },            // this one won't be found: case sensitive!            { "JAVA", "JAVA", "1.7", null, }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.testframework.RuleTst;public class ReportTest extends RuleTst {    private LanguageVersion defaultLanguage = LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion();    @Test    public void testBasic() {        Report r = new Report();        runTestFromString(TEST1, new FooRule(), r, defaultLanguage);        assertFalse(r.isEmpty());    }    @Test    public void testExclusionsInReportWithRuleViolationSuppressRegex() {        Report rpt = new Report();        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR, ".*No Foo.*");        runTestFromString(TEST1, rule, rpt, defaultLanguage);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithRuleViolationSuppressXPath() {        Report rpt = new Report();        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR, ".[@Image = 'Foo']");        runTestFromString(TEST1, rule, rpt, defaultLanguage);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithAnnotations() {        Report rpt = new Report();        runTestFromString(TEST2, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithAnnotationsFullName() {        Report rpt = new Report();        runTestFromString(TEST2_FULL, new FooRule(), rpt,                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    @Test    public void testExclusionsInReportWithNOPMD() {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt, defaultLanguage);        assertTrue(rpt.isEmpty());        assertEquals(1, rpt.getSuppressedRuleViolations().size());    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "@SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST2_FULL = "@java.lang.SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST3 = "public class Foo {} // NOPMD";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertNull;import org.junit.Test;/** * Test java's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    @Test    public void testExclusionOfUselessParantheses() throws RuleSetNotFoundException {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"category/java/codestyle.xml\">\n"                        + "    <exclude name=\"UselessParentheses\"/>\n" + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        Rule rule = ruleset.getRuleByName("UselessParentheses");        assertNull(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.StringReader;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.testframework.RuleTst;import net.sourceforge.pmd.testframework.TestDescriptor;public class ExcludeLinesTest extends RuleTst {    private Rule rule;    @Before    public void setUp() {        rule = findRule("java-unusedcode", "UnusedLocalVariable");    }    @Test    public void testAcceptance() {        runTest(new TestDescriptor(TEST1, "NOPMD should work", 0, rule));        runTest(new TestDescriptor(TEST2, "Should fail without exclude marker", 1, rule));    }    @Test    public void testAlternateMarker() throws Exception {        PMD p = new PMD();        p.getConfiguration().setSuppressMarker("FOOBAR");        RuleContext ctx = new RuleContext();        Report r = new Report();        ctx.setReport(r);        ctx.setSourceCodeFile(new File("n/a"));        ctx.setLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getDefaultVersion());        RuleSet rules = new RuleSetFactory().createSingleRuleRuleSet(rule);        p.getSourceCodeProcessor().processSourceCode(new StringReader(TEST3), new RuleSets(rules), ctx);        assertTrue(r.isEmpty());        assertEquals(r.getSuppressedRuleViolations().size(), 1);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x; //NOPMD "            + PMD.EOL + " } " + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x;"            + PMD.EOL + " } " + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  int x; // FOOBAR" + PMD.EOL + " } " + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoUnsanitizedJSPExpressionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IframeMissingSrcAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JspEncodingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoScriptletsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineStyleInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoLongScriptsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineScriptTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DuplicateJspImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontNestJsfInJstlIterationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoHtmlCommentsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoJspForwardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoClassAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import java.util.Set;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;/** * Test parsing of a JSP in document style, by checking the generated AST. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be * */public class JspDocStyleTest extends AbstractJspNodesTst {    /**     * Smoke test for JSP parser.     */    @Test    public void testSimplestJsp() {        assertNumberOfNodes(ASTElement.class, TEST_SIMPLEST_HTML, 1);    }    /**     * Test the information on a Element and Attribute.     */    @Test    public void testElementAttributeAndNamespace() {        Set<JspNode> nodes = getNodes(null, TEST_ELEMENT_AND_NAMESPACE);        Set<ASTElement> elementNodes = getNodesOfType(ASTElement.class, nodes);        assertEquals("One element node expected!", 1, elementNodes.size());        ASTElement element = elementNodes.iterator().next();        assertEquals("Correct name expected!", "h:html", element.getName());        assertEquals("Has namespace prefix!", true, element.isHasNamespacePrefix());        assertEquals("Element is empty!", true, element.isEmpty());        assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "html", element.getLocalName());        Set<ASTAttribute> attributeNodes = getNodesOfType(ASTAttribute.class, nodes);        assertEquals("One attribute node expected!", 1, attributeNodes.size());        ASTAttribute attribute = attributeNodes.iterator().next();        assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());        assertEquals("Has namespace prefix!", true, attribute.isHasNamespacePrefix());        assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix", attribute.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    public void testAttributeValueContainingHash() {        Set<JspNode> nodes = getNodes(null, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        Set<ASTAttribute> attributes = getNodesOfType(ASTAttribute.class, nodes);        assertEquals("Three attributes expected!", 3, attributes.size());        List<ASTAttribute> attrsList = new ArrayList<>(attributes);        Collections.sort(attrsList, new Comparator<ASTAttribute>() {            public int compare(ASTAttribute arg0, ASTAttribute arg1) {                return arg0.getName().compareTo(arg1.getName());            }        });        ASTAttribute attr = attrsList.get(0);        assertEquals("Correct attribute name expected!", "foo", attr.getName());        assertEquals("Correct attribute value expected!", "CREATE",                attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());        attr = attrsList.get(1);        assertEquals("Correct attribute name expected!", "href", attr.getName());        assertEquals("Correct attribute value expected!", "#",                attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());        attr = attrsList.get(2);        assertEquals("Correct attribute name expected!", "something", attr.getName());        assertEquals("Correct attribute value expected!", "#yes#",                attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());    }    /**     * Test correct parsing of CDATA.     */    @Test    public void testCData() {        Set<ASTCData> cdataNodes = getNodes(ASTCData.class, TEST_CDATA);        assertEquals("One CDATA node expected!", 1, cdataNodes.size());        ASTCData cdata = cdataNodes.iterator().next();        assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());    }    /**     * Test parsing of Doctype declaration.     */    @Test    public void testDoctype() {        Set<JspNode> nodes = getNodes(null, TEST_DOCTYPE);        Set<ASTDoctypeDeclaration> docTypeDeclarations = getNodesOfType(ASTDoctypeDeclaration.class, nodes);        assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());        Set<ASTDoctypeExternalId> externalIds = getNodesOfType(ASTDoctypeExternalId.class, nodes);        assertEquals("One doctype external id expected!", 1, externalIds.size());        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());        assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",                externalId.getUri());    }    /**     * Test parsing of a XML comment.     *     */    @Test    public void testComment() {        Set<ASTCommentTag> comments = getNodes(ASTCommentTag.class, TEST_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTCommentTag comment = comments.iterator().next();        assertEquals("Correct comment content expected!", "comment", comment.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScript() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Correct script content expected!", "Script!", script.getImage());    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be valid     * html but it is likely to appear in .JSP files.     */    @Test    public void testImportHtmlScript() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttributeValue> value = script.findDescendantsOfType(ASTAttributeValue.class);        assertEquals("filename.js", value.get(0).getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScriptWithAttribute() {        Set<ASTHtmlScript> scripts = getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Correct script content expected!", "Script!", script.getImage());        List<ASTAttributeValue> attrs = script.findDescendantsOfType(ASTAttributeValue.class);        assertTrue("text/javascript".equals(attrs.get(0).getImage()));    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    public void testComplexHtmlScript() {        Set<ASTHtmlScript> script = getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals("One script expected!", 1, script.size());        ASTHtmlScript next = script.iterator().next();        assertTrue(next.getImage().contains("<!--"));        Set<ASTCommentTag> comments = getNodes(ASTCommentTag.class, TEST_COMPLEX_SCRIPT);        assertEquals("One comment expected!", 1, comments.size());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testInlineCss() {        Set<ASTElement> scripts = getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals("Three elements expected!", 3, scripts.size());    }    /**     * Test parsing of HTML text within element.     */    @Test    public void testTextInTag() {        Set<ASTText> scripts = getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals("One text chunk expected!", 1, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    public void noSpacesBetweenTags() {        Set<ASTElement> scripts = getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals("Two tags expected!", 2, scripts.size());        List<ASTElement> elmts = sortNodesByName(scripts);        Iterator<ASTElement> iterator = elmts.iterator();        ASTElement script = iterator.next();        assertEquals("Correct content expected!", "a", script.getName());        script = iterator.next();        assertEquals("Correct content expected!", "b", script.getName());    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    public void unclosedTagsWithDollar() {        Set<ASTText> scripts = getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " $ ", script.getImage());    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    public void unclosedTagsWithELWithin() {        Set<ASTElExpression> scripts = getNodes(ASTElExpression.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals("Two EL expressions expected!", 2, scripts.size());        List<ASTElExpression> exprs = sortByImage(scripts);        Iterator<ASTElExpression> iterator = exprs.iterator();        ASTElExpression script = iterator.next();        assertEquals("Correct content expected!", "expr1", script.getImage());        script = iterator.next();        assertEquals("Correct content expected!", "expr2", script.getImage());    }    /**     * Make sure mixed expressions don't confuse the parser     */    @Test    public void mixedExpressions() {        Set<ASTJspExpression> exprs = getNodes(ASTJspExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("One JSP expression expected!", 1, exprs.size());        assertEquals("Image of expression should be \"expr\"", "expr", exprs.iterator().next().getImage());        Set<ASTElExpression> els = getNodes(ASTElExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("Two EL expression expected!", 2, els.size());        assertEquals("Image of el should be \"expr\"", "expr", els.iterator().next().getImage());        Set<ASTUnparsedText> unparsedtexts = getNodes(ASTUnparsedText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        List<ASTUnparsedText> sortedUnparsedTxts = sortByImage(unparsedtexts);        assertEquals("Two unparsed texts expected!", 2, sortedUnparsedTxts.size());        Iterator<ASTUnparsedText> iterator = sortedUnparsedTxts.iterator();        assertEquals("Image of text should be \"\\${expr}\"", " \\${expr} ", iterator.next().getImage());        assertEquals("Image of text should be \" aaa \"", " aaa ", iterator.next().getImage());        // ASTText should contain the text between two tags.        Set<ASTText> texts = getNodes(ASTText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        List<ASTText> sortedTxts = sortByImage(texts);        assertEquals("Two regular texts expected!", 2, sortedTxts.size());        Iterator<ASTText> iterator2 = sortedTxts.iterator();        assertEquals("Image of text should be \"\\${expr}\"", " \\${expr} ", iterator2.next().getImage());        assertEquals("Image of text should be all text between two nodes" + " \"  aaa ${expr}#{expr} \"",                " aaa ${expr}#{expr}", iterator2.next().getImage());    }    /**     * Make sure JSP expressions are properly detected when they are next to     * unclosed tags.     */    @Test    public void unclosedTagsWithJspExpressionWithin() {        Set<ASTJspExpression> scripts = getNodes(ASTJspExpression.class, TEST_TAGS_WITH_EXPRESSION_WITHIN);        assertEquals("Two JSP expressions expected!", 2, scripts.size());        ASTJspExpression script = scripts.iterator().next();        assertEquals("Correct content expected!", "expr", script.getImage());    }    /**     * A dangling unopened ( just &lt;/closed&gt; ) tag should not influence the     * parsing.     */    @Test    @Ignore // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    public void textBetweenUnopenedTag() {        Set<ASTText> scripts = getNodes(ASTText.class, TEST_TEXT_WITH_UNOPENED_TAG);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", "$", script.getImage());    }    /**     * Parser should be able to handle documents which start or end with     * unparsed text     */    @Test    @Ignore // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    public void textMultipleClosingTags() {        Set<ASTText> scripts = getNodes(ASTText.class, TEST_MULTIPLE_CLOSING_TAGS);        assertEquals("Four text chunks expected!", 4, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void textAfterOpenAndClosedTag() {        Set<ASTElement> nodes = getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two elements expected!", 2, nodes.size());        List<ASTElement> elmts = sortNodesByName(nodes);        assertEquals("First element should be a", "a", elmts.get(0).getName());        assertFalse("first element should be closed", elmts.get(0).isUnclosed());        assertEquals("Second element should be b", "b", elmts.get(1).getName());        assertTrue("Second element should not be closed", elmts.get(1).isUnclosed());        Set<ASTText> text = getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two text chunks expected!", 2, text.size());    }    @Test    public void quoteEL() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "${something}", attr.getImage());    }    @Test    public void quoteExpression() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_QUOTE_EXPRESSION);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something%>", attr.getImage());    }    @Test    @Ignore // tags contain quotes and break attribute parsing    public void quoteTagInAttribute() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<bean:write name=\"x\" property=\"z\">",                attr.getImage());    }    /**     * smoke test for a non-quoted attribute value     */    @Test    public void noQuoteAttrValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "yes|", attr.getImage());    }    /**     * tests whether JSP el is properly detected as attribute value     */    @Test    public void noQuoteAttrWithJspEL() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr2 = iterator.next();        if ("url".equals(attr2.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr2 = iterator.next();        }        assertEquals("Expected to detect proper value for EL in attribute!", "${something}", attr2.getImage());    }    /**     * tests whether parse correctly detects presence of JSP expression &lt;%= %&gt;     * within an non-quoted attribute value     */    @Test    public void noQuoteAttrWithJspExpression() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EXPRESSION);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something%>", attr.getImage());    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    public void noQuoteAttrEmpty() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_EMPTY_ATTR);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", "", attr.getImage());    }    /**     * tests whether parse correctly interprets an cr lf instead of an attribute     */    @Test    public void noQuoteAttrCrLf() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_CR_LF_ATTR);        assertEquals("One attribute expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", "\r\n", attr.getImage());    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    public void noQuoteAttrTab() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAB_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        assertEquals("Expected to detect proper value for attribute!", "\t", attr.getImage());    }    /**     * tests whether parse does not fail in the presence of unclosed JSP     * expression &lt;%= within an non-quoted attribute value     */    @Test    public void noQuoteAttrWithMalformedJspExpression() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something", attr.getImage());    }    /**     * test a no quote attribute value which contains a scriptlet &lt;% %&gt; within     * its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithScriptletInValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a no quote attribute value can contain a tag (e.g.     * attr=&lt;bean:write property="value" /&gt;)     *      */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithBeanWriteTagAsValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a quote attribute value can contain a tag (e.g.     * attr="&lt;bean:write property="value" /&gt;" ) Not sure if it's legal JSP code     * but most JSP engine accept and properly treat this value at runtime     */    @Test    @Ignore // nice test for future development    public void quoteAttrWithBeanWriteTagAsValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a no quote attribute value which contains the EL dollar sign $     * within its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithDollarSignInValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_DOLLAR);        assertEquals("One attribute expected!", 2, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "${something", attr.getImage());    }    /**     * test a no quote attribute value which contains the EL sharp sign # within     * its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithSharpSymbolInValue() {        Set<ASTAttributeValue> attributes = getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_HASH);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "#{something", attr.getImage());    }    @Test    public void unclosedTag() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be sorted tag:if", "tag:if", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());    }    @Test    public void unclosedTagAndNoQuotesForAttribute() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_NO_QUOTE_ATTR);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be sorted tag:if", "tag:if", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());    }    @Test    public void unclosedTagMultipleLevels() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("3 tags expected", 3, elements.size());        assertEquals("First element should be sorted tag:someTag", "tag:someTag", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertEquals("Third element should be tag:x", "tag:x", sortedElmnts.get(2).getName());        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        assertFalse(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    public void nestedEmptyTags() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Third element should be html", "html", sortedElmnts.get(3).getName());        // a1        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2        assertTrue(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());        // html        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt; &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    public void nestedMultipleTags() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 6, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be a3", "a3", sortedElmnts.get(2).getName());        assertEquals("Forth element should be a4", "a4", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be b", "b", sortedElmnts.get(4).getName());        assertEquals("Sixth element should be html", "html", sortedElmnts.get(5).getName());        // a1 not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2 not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // a3 empty and not closed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // a4 empty but closed        assertTrue(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());        // b empty but closed        assertTrue(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());        // html not empty and closed        assertFalse(sortedElmnts.get(5).isEmpty());        assertFalse(sortedElmnts.get(5).isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt; .      * Here x is the first tag to be closed thus rendering the next close of a (&lt;/a&gt;)     * to be disregarded.      */    @Test    public void unclosedParentTagClosedBeforeChild() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt; An unmatched closing of 'z' appears     * randomly in the document. This should be disregarded and structure of     * children and parents should not be influenced. in other words &lt;/a&gt; should     * close the first &lt;a&gt; tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    public void unmatchedTagDoesNotInfluenceStructure() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a is not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This     * should be disregarded and structure of children and parents should not be influenced.     * Also un unclosed &lt;a&gt; tag appears at the start of the document     */    @Test    public void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("5 tags expected", 5, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be a", "a", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be b", "b", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be x", "x", sortedElmnts.get(4).getName());        // first a is empty and unclosed        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // second a not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(3).isEmpty());        assertTrue(sortedElmnts.get(3).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());    }    /**     * {@link #TEST_UNCLOSED_END_OF_DOC}     * &lt;tag:x&gt; &lt;tag:y&gt;      * Tests whether parser breaks on no closed tags at all     */    // This is yet to be improved. If a closing tag does not    // exist no tags will be marked as empty :(    @Ignore    @Test    public void unclosedEndOfDoc() {        Set<ASTElement> elements = getNodes(ASTElement.class, TEST_UNCLOSED_END_OF_DOC);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be 'tag:x'", "tag:x", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:y", "tag:y", sortedElmnts.get(1).getName());        // b        // assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());    }    /**     * will sort the AST element in list in alphabetical order and if tag name     * is the same it will sort against o1.getBeginColumn() +""+     * o1.getBeginLine(). so first criteria is the name, then the second is the     * column +""+line string.     *      * @param elements     * @return     */    private List<ASTElement> sortNodesByName(Set<ASTElement> elements) {        List<ASTElement> list = new ArrayList<>();        list.addAll(elements);        Collections.sort(list, new Comparator<ASTElement>() {            public int compare(ASTElement o1, ASTElement o2) {                if (o1.getName() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getName() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getName().equals(o2.getName())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getName().compareTo(o2.getName());            }        });        return list;    }    /**     * will sort the AST node by the image name.     *      * @param elements     * @return     */    private <T extends Node> List<T> sortByImage(Set<T> elements) {        List<T> list = new ArrayList<>();        list.addAll(elements);        Collections.sort(list, new Comparator<Node>() {            public int compare(Node o1, Node o2) {                if (o1.getImage() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getImage() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getImage().equals(o2.getImage())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getImage().compareTo(o2.getImage());            }        });        return list;    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_COMMENT = "<html><!-- comment --></html>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" type=\"text/javascript\"/></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>#{expr1}<b>${expr2}</a>";    private static final String TEST_TAGS_WITH_MIXED_EXPRESSIONS = "<a> aaa ${expr} #{expr} <%=expr%> <b> \\${expr} </a>";    private static final String TEST_TAGS_WITH_EXPRESSION_WITHIN = "<a> <%=expr%> <b> <%=expr%> </a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_TEXT_WITH_UNOPENED_TAG = "<a> some text </b> some text </a>";    private static final String TEST_MULTIPLE_CLOSING_TAGS = "<a> some text </b> </b> </b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"${something}\" > </tag:if>";    private static final String TEST_QUOTE_EXPRESSION = "<tag:if something=\"<%=something%>\" >  </tag:if>";    private static final String TEST_QUOTE_TAG_IN_ATTR = "<tag:if something=\"<bean:write name=\"x\" property=\"z\">\" >  "            + "<a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR = "<tag:if something=yes| > </tag:if>";    private static final String TEST_NO_QUOTE_EMPTY_ATTR = "<tag:if something= >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAG_IN_ATTR = "<tag:if something=<bean:write name=\"x\" property=\"z\"> >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_CR_LF_ATTR = "<tag:if something=\r\n >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAB_ATTR = "<tag:if something=\t >   </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<tag:if something=${something} >  <a href=url >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EXPRESSION = "<tag:if something=<%=something%> >  </tag:if>";    /**     * same as {@link #TEST_NO_QUOTE_ATTR_WITH_EXPRESSION} only expression is     * not properly closed     */    private static final String TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR = "<tag:if something=<%=something >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET = "<tag:if something=<% String a = \"1\";%>x >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_DOLLAR = "<tag:if something=${something >  <a href=${ >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_HASH = "<tag:if something=#{something >  <a href=#{url} >foo</a> </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if someting=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag someting=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_END_OF_DOC = "<tag:x> <tag:y>";    private static final String TEST_UNCLOSED_NO_QUOTE_ATTR = "<tag:someTag> <tag:if someting=x > </tag:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Set;import org.junit.Test;public class JspPageStyleTest extends AbstractJspNodesTst {    /**     * Test parsing of a JSP comment.     */    @Test    public void testComment() {        Set<ASTJspComment> comments = getNodes(ASTJspComment.class, JSP_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTJspComment comment = comments.iterator().next();        assertEquals("Correct comment content expected!", "some comment", comment.getImage());    }    /**     * Test parsing a JSP directive.     */    @Test    public void testDirective() {        Set<JspNode> nodes = getNodes(null, JSP_DIRECTIVE);        Set<ASTJspDirective> directives = getNodesOfType(ASTJspDirective.class, nodes);        assertEquals("One directive expected!", 1, directives.size());        ASTJspDirective directive = directives.iterator().next();        assertEquals("Correct directive name expected!", "page", directive.getName());        Set<ASTJspDirectiveAttribute> directiveAttrs = getNodesOfType(ASTJspDirectiveAttribute.class, nodes);        assertEquals("Two directive attributes expected!", 2, directiveAttrs.size());        List<ASTJspDirectiveAttribute> attrsList = new ArrayList<>(directiveAttrs);        Collections.sort(attrsList, new Comparator<ASTJspDirectiveAttribute>() {            public int compare(ASTJspDirectiveAttribute arg0, ASTJspDirectiveAttribute arg1) {                return arg0.getName().compareTo(arg1.getName());            }        });        ASTJspDirectiveAttribute attr = attrsList.get(0);        assertEquals("Correct directive attribute name expected!", "language", attr.getName());        assertEquals("Correct directive attribute value expected!", "java", attr.getValue());        attr = attrsList.get(1);        assertEquals("Correct directive attribute name expected!", "session", attr.getName());        assertEquals("Correct directive attribute value expected!", "true", attr.getValue());    }    /**     * Test parsing of a JSP declaration.     */    @Test    public void testDeclaration() {        Set<ASTJspDeclaration> declarations = getNodes(ASTJspDeclaration.class, JSP_DECLARATION);        assertEquals("One declaration expected!", 1, declarations.size());        ASTJspDeclaration declaration = declarations.iterator().next();        assertEquals("Correct declaration content expected!", "String someString = \"s\";", declaration.getImage());    }    /**     * Test parsing of a JSP scriptlet.     */    @Test    public void testScriptlet() {        Set<ASTJspScriptlet> scriptlets = getNodes(ASTJspScriptlet.class, JSP_SCRIPTLET);        assertEquals("One scriptlet expected!", 1, scriptlets.size());        ASTJspScriptlet scriptlet = scriptlets.iterator().next();        assertEquals("Correct scriptlet content expected!", "someString = someString + \"suffix\";",                scriptlet.getImage());    }    /**     * Test parsing of a JSP expression.     */    @Test    public void testExpression() {        Set<ASTJspExpression> expressions = getNodes(ASTJspExpression.class, JSP_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "someString", expression.getImage());    }    /**     * Test parsing of a JSP expression in an attribute.     */    @Test    public void testExpressionInAttribute() {        Set<ASTJspExpressionInAttribute> expressions = getNodes(ASTJspExpressionInAttribute.class,                JSP_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpressionInAttribute expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "style.getClass()", expression.getImage());    }    /**     * Test parsing of a EL expression.     */    @Test    public void testElExpression() {        Set<ASTElExpression> expressions = getNodes(ASTElExpression.class, JSP_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "myBean.get(\"${ World }\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testElExpressionInAttribute() {        Set<ASTElExpression> expressions = getNodes(ASTElExpression.class, JSP_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "myValidator.find(\"'jsp'\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testJsfValueBinding() {        Set<ASTValueBinding> valueBindings = getNodes(ASTValueBinding.class, JSF_VALUE_BINDING);        assertEquals("One value binding expected!", 1, valueBindings.size());        ASTValueBinding valueBinding = valueBindings.iterator().next();        assertEquals("Correct expression content expected!", "myValidator.find(\"'jsf'\")", valueBinding.getImage());    }    private static final String JSP_COMMENT = "<html> <%-- some comment --%> </html>";    private static final String JSP_DIRECTIVE = "<html> <%@ page language=\"java\" session='true'%> </html>";    private static final String JSP_DECLARATION = "<html><%! String someString = \"s\"; %></html>";    private static final String JSP_SCRIPTLET = "<html> <% someString = someString + \"suffix\"; %> </html>";    private static final String JSP_EXPRESSION = "<html><head><title> <%= someString %> </title></head></html>";    private static final String JSP_EXPRESSION_IN_ATTRIBUTE = "<html> <body> <p class='<%= style.getClass() %>'> Hello </p> </body> </html>";    private static final String JSP_EL_EXPRESSION = "<html><title>Hello ${myBean.get(\"${ World }\") } .jsp</title></html>";    private static final String JSP_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').${myValidator.find(\"'jsp'\")}\" /> </html>";    private static final String JSF_VALUE_BINDING = "<html> <body> <p class='#{myValidator.find(\"'jsf'\")}'> Hello </p> </body> </html>";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(JspPageStyleTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import java.io.StringReader;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.testframework.RuleTst;public class XPathJspRuleTest extends RuleTst {    /**     * Test matching a XPath expression against a JSP source.     * @throws PMDException      */    @Test    public void testExpressionMatching() throws PMDException {        Rule rule = new XPathRule(XPATH_EXPRESSION);        rule.setMessage("Test");        rule.setLanguage(LanguageRegistry.getLanguage(JspLanguageModule.NAME));        RuleSet rules = new RuleSetFactory().createSingleRuleRuleSet(rule);        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        ctx.setLanguageVersion(LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion());        PMD p = new PMD();        p.getSourceCodeProcessor().processSourceCode(new StringReader(MATCH), new RuleSets(rules), ctx);        assertEquals("One violation expected!", 1, report.size());        RuleViolation rv = report.iterator().next();        assertEquals(1, rv.getBeginLine());    }    private static final String MATCH = "<html><hr/></html>";    private static final String XPATH_EXPRESSION = "//Element [@Name='hr']";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @Before    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *      */    @Test    public void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp;import java.io.File;import java.io.StringReader;import java.nio.file.Paths;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for JSP parsing. * */public class JspParserTest {    /**     * Verifies bug #939 Jsp parser fails on $     */    @Test    public void testParseDollar() {        Node node = parse(                "<span class=\"CostUnit\">$</span><span class=\"CostMain\">129</span><span class=\"CostFrac\">.00</span>");        Assert.assertNotNull(node);    }    @Test    public void testParseELAttribute() {        Node node = parse(                "<div ${something ? 'class=\"red\"' : ''}> Div content here.</div>");        Assert.assertNotNull(node);    }    @Test    public void testParseELAttributeValue() {        Node node = parse(                "<div class=\"${something == 0 ? 'zero_something' : something == 1 ? 'one_something' : 'other_something'}\">Div content here.</div>");        Assert.assertNotNull(node);    }    /**     * Verifies bug #311 Jsp parser fails on boolean attribute     */    @Test    public void testParseBooleanAttribute() {        Node node = parse(                "<label><input type='checkbox' checked name=cheese disabled=''> Cheese</label>");        Assert.assertNotNull(node);    }    @Test    public void testParseJsp() {        testInternalJspFile(Paths.get("sample.jsp").toFile());        testInternalJspFile(Paths.get("sample.jspx").toFile());    }    @Test    public void testParseTag() {        testInternalJspFile(Paths.get("sample.tag").toFile());    }    @Test(expected = AssertionError.class)    public void testParseWrong() {        testInternalJspFile(Paths.get("sample.xxx").toFile());    }    private void testInternalJspFile(File jspFile) {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(jspFile);        Assert.assertEquals("LanguageVersion must be JSP!",                LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), languageVersion);    }    private Node parse(String code) {        LanguageVersionHandler jspLang = LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion()                .getLanguageVersionHandler();        Parser parser = jspLang.getParser(jspLang.getDefaultParserOptions());        Node node = parser.parse(null, new StringReader(code));        return node;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.jsp.ast.JspParserConstants;public class JSPTokenizerTest {    @Test    public void scriptletWithString() throws Exception {        JSPTokenizer tokenizer = new JSPTokenizer();        Tokens tokenEntries = new Tokens();        String code = IOUtils.toString(JSPTokenizerTest.class.getResourceAsStream("scriptletWithString.jsp"),                StandardCharsets.UTF_8);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(code));        tokenizer.tokenize(sourceCode, tokenEntries);        int[] expectedTokens = new int[] {            JspParserConstants.JSP_COMMENT_START,            JspParserConstants.JSP_COMMENT_CONTENT,            JspParserConstants.JSP_COMMENT_END,            JspParserConstants.JSP_SCRIPTLET_START,            JspParserConstants.JSP_SCRIPTLET,            JspParserConstants.JSP_SCRIPTLET_END,            JspParserConstants.JSP_SCRIPTLET_START,            JspParserConstants.JSP_SCRIPTLET,            JspParserConstants.JSP_SCRIPTLET_END,            JspParserConstants.EOF,        };        Assert.assertEquals(expectedTokens.length, tokenEntries.getTokens().size());        for (int i = 0; i < expectedTokens.length - 1; i++) {            Assert.assertEquals(String.valueOf(expectedTokens[i]), tokenEntries.getTokens().get(i).toString());        }        Assert.assertEquals("<JSP_SCRIPTLET>", getTokenImage(tokenEntries.getTokens().get(4)));    }    private static String getTokenImage(TokenEntry token) {        int kind = 0;        if (token != TokenEntry.EOF) {            kind = Integer.parseInt(token.toString());        }        return JspParserConstants.tokenImage[kind];    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on JSP file.     */    @Test    public void testJspFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File jspFile = new File("/path/to/MyPage.jsp");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(jspFile);        assertEquals("LanguageVersion must be JSP!",                LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { JspLanguageModule.NAME, JspLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test jsp's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;/** * @author rpelisse * */public class FortranTokenizerTest extends AbstractTokenizerTest {    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new FortranTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), "sample.for"));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(FortranTokenizerTest.class.getResourceAsStream("sample.for"), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 434;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.FileSystems;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.SystemUtils;import org.junit.Before;import org.junit.Test;import org.yaml.snakeyaml.DumperOptions;import org.yaml.snakeyaml.DumperOptions.FlowStyle;import org.yaml.snakeyaml.DumperOptions.LineBreak;import org.yaml.snakeyaml.Yaml;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;public class SidebarGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    @Before    public void setup() {        writer.reset();    }    @Test    public void testSidebar() throws IOException {        Map<Language, List<RuleSet>> rulesets = new HashMap<>();        RuleSet ruleSet1 = new RuleSetFactory().createNewRuleSet("test", "test", "bestpractices.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        RuleSet ruleSet2 = new RuleSetFactory().createNewRuleSet("test2", "test", "codestyle.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        rulesets.put(LanguageRegistry.findLanguageByTerseName("java"), Arrays.asList(ruleSet1, ruleSet2));        rulesets.put(LanguageRegistry.findLanguageByTerseName("ecmascript"), Arrays.asList(ruleSet1));        SidebarGenerator generator = new SidebarGenerator(writer, FileSystems.getDefault().getPath(".."));        List<Map<String, Object>> result = generator.generateRuleReferenceSection(rulesets);        DumperOptions options = new DumperOptions();        options.setDefaultFlowStyle(FlowStyle.BLOCK);        if (SystemUtils.IS_OS_WINDOWS) {            options.setLineBreak(LineBreak.WIN);        }        String yaml = new Yaml(options).dump(result);        String expected = MockedFileWriter.normalizeLineSeparators(                IOUtils.toString(SidebarGeneratorTest.class.getResourceAsStream("sidebar.yml"), StandardCharsets.UTF_8));        assertEquals(expected, yaml);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.FileVisitResult;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.SimpleFileVisitor;import java.nio.file.attribute.BasicFileAttributes;import java.util.Arrays;import java.util.List;import org.apache.commons.io.FilenameUtils;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.docs.MockedFileWriter.FileEntry;public class RuleDocGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    private Path root;    @Before    public void setup() throws IOException {        writer.reset();        root = Files.createTempDirectory("pmd-ruledocgenerator-test");        Files.createDirectories(root.resolve("docs/_data/sidebars"));        List<String> mockedSidebar = Arrays.asList(                "entries:",                "- title: sidebar",                "  folders:",                "  - title: 1",                "  - title: 2",                "  - title: 3",                "  - title: Rules");        Files.write(root.resolve("docs/_data/sidebars/pmd_sidebar.yml"), mockedSidebar);    }    @After    public void cleanup() throws IOException {        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {            @Override            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {                Files.delete(file);                return FileVisitResult.CONTINUE;            }            @Override            public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {                Files.delete(dir);                return FileVisitResult.CONTINUE;            }        });    }    private static String loadResource(String name) throws IOException {        return MockedFileWriter.normalizeLineSeparators(                IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name), StandardCharsets.UTF_8));    }    @Test    public void testSingleRuleset() throws RuleSetNotFoundException, IOException {        RuleDocGenerator generator = new RuleDocGenerator(writer, root);        RuleSetFactory rsf = new RuleSetFactory();        RuleSet ruleset = rsf.createRuleSet("rulesets/ruledoctest/sample.xml");        generator.generate(Arrays.asList(ruleset).iterator(),                Arrays.asList(                        "rulesets/ruledoctest/sample-deprecated.xml",                        "rulesets/ruledoctest/other-ruleset.xml"));        assertEquals(3, writer.getData().size());        FileEntry languageIndex = writer.getData().get(0);        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith("docs/pages/pmd/rules/java.md"));        assertEquals(loadResource("/expected/java.md"), languageIndex.getContent());        FileEntry ruleSetIndex = writer.getData().get(1);        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith("docs/pages/pmd/rules/java/sample.md"));        assertEquals(loadResource("/expected/sample.md"), ruleSetIndex.getContent());        FileEntry sidebar = writer.getData().get(2);        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith("docs/_data/sidebars/pmd_sidebar.yml"));        assertEquals(loadResource("/expected/pmd_sidebar.yml"), sidebar.getContent());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.fail;import java.nio.file.FileSystems;import java.nio.file.Path;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.apache.commons.io.FilenameUtils;import org.junit.Test;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;public class RuleSetResolverTest {    private static List<String> excludedRulesets = new ArrayList<>();    static {        excludedRulesets.add(FilenameUtils.normalize("pmd-test/src/main/resources/rulesets/dummy/basic.xml"));    }    @Test    public void resolveAllRulesets() {        Path basePath = FileSystems.getDefault().getPath(".").resolve("..").toAbsolutePath().normalize();        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);            filterRuleSets(additionalRulesets);        RuleSetFactory ruleSetFactory = new RuleSetFactory();        for (String filename : additionalRulesets) {            try {                ruleSetFactory.createRuleSet(filename);            } catch (RuntimeException | RuleSetNotFoundException e) {                fail("Couldn't load ruleset " + filename + ": " + e.getMessage());            }        }    }    private void filterRuleSets(List<String> additionalRulesets) {        Iterator<String> it = additionalRulesets.iterator();        while (it.hasNext()) {            String filename = it.next();            for (String exclusion : excludedRulesets) {                if (filename.endsWith(exclusion)) {                    it.remove();                    break;                }            }        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import java.nio.file.FileSystems;import java.util.List;import org.junit.Assert;import org.junit.Test;public class RuleTagCheckerTest {    @Test    public void testAllChecks() throws Exception {        RuleTagChecker checker = new RuleTagChecker(FileSystems.getDefault().getPath("src/test/resources/ruletagchecker"));        List<String> issues = checker.check();        Assert.assertEquals(3, issues.size());        Assert.assertEquals("ruletag-examples.md: 8: Rule tag for java/bestpractices/AvoidPrintStackTrace is not closed properly",                issues.get(0));        Assert.assertEquals("ruletag-examples.md:10: Rule java/notexistingcategory/AvoidPrintStackTrace is not found",                issues.get(1));        Assert.assertEquals("ruletag-examples.md:12: Rule java/bestpractices/NotExistingRule is not found",                issues.get(2));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.List;import org.junit.Test;public class EscapeUtilsTest {    @Test    public void testEscapeMarkdown() {        assertEquals("This is a \\\\backslash", EscapeUtils.escapeMarkdown("This is a \\backslash"));        assertEquals("This \"\\*\" is not a emphasis", EscapeUtils.escapeMarkdown("This \"*\" is not a emphasis"));        assertEquals("This \"\\*\\*\" is not a strong style", EscapeUtils.escapeMarkdown("This \"**\" is not a strong style"));        assertEquals("This \"\\[foo\\]\" does not start a link", EscapeUtils.escapeMarkdown("This \"[foo]\" does not start a link"));        assertEquals("This \"\\~bar\\~\" is not a strike-through", EscapeUtils.escapeMarkdown("This \"~bar~\" is not a strike-through"));        assertEquals("That's \"\\|\" just a bar", EscapeUtils.escapeMarkdown("That's \"|\" just a bar"));        assertEquals("This \"\\_\" is just a underscore", EscapeUtils.escapeMarkdown("This \"_\" is just a underscore"));    }    @Test    public void testEscapeHtmlWithinMarkdownSingleLine() {        assertEquals("a &lt;script&gt; tag outside of `<script>` backticks should be escaped",                EscapeUtils.escapeSingleLine("a <script> tag outside of `<script>` backticks should be escaped"));        assertEquals("a &lt;script&gt; &quot;tag&quot; outside of `<script>` backticks should be escaped &lt;multiple&gt; times `<strong>`.",                EscapeUtils.escapeSingleLine("a <script> \"tag\" outside of `<script>` backticks should be escaped <multiple> times `<strong>`."));        assertEquals("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links",                EscapeUtils.escapeSingleLine("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links"));        assertEquals("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links",                EscapeUtils.escapeSingleLine("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links"));        assertEquals("URL: <http://www.google.com> is a url without ssl",                EscapeUtils.escapeSingleLine("URL: <http://www.google.com> is a url without ssl"));        assertEquals("> this is a quote line",                EscapeUtils.escapeSingleLine("> this is a quote line"));        assertEquals("combination of URLs and backticks: <https://pmd.github.io> but `<script>` &lt;strong&gt;escaped&lt;/strong&gt;",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: <https://pmd.github.io> but `<script>` <strong>escaped</strong>"));        assertEquals("combination of URLs and backticks: `<script>` &lt;strong&gt;escaped&lt;/strong&gt; but <https://pmd.github.io>",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: `<script>` <strong>escaped</strong> but <https://pmd.github.io>"));    }    @Test    public void testEscapeHtmlWithinMarkdownBlocks() {        String text = "paragraph\n\n> quote <script>\n> quote line \"2\"\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        String expected = "paragraph\n\n> quote &lt;script&gt;\n> quote line &quot;2&quot;\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        List<String> escaped = EscapeUtils.escapeLines(Arrays.asList(text.split("\n")));        assertEquals(Arrays.asList(expected.split("\n")), escaped);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import javax.xml.transform.Source;import org.junit.Assert;import org.junit.Test;/** * * @author sturton */public class ResourceResolverTest {    /**     * Test of resolve method, of class ResourceResolver.     */    @Test    public void testResolve() throws Exception {        System.out.println("resolve");        String href = "";        String base = "";        ResourceResolver instance = new ResourceResolver();        Source expResult = null;        Source result = instance.resolve(href, base);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.File;import java.io.FileOutputStream;import java.io.PrintStream;import java.util.Map.Entry;import java.util.Properties;import java.util.ResourceBundle;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;/** * * @author sturton */public class DBTypeTest {    private File absoluteFile;    private Properties testProperties;    private Properties includeProperties;    @Before    public void setUp() throws Exception {        testProperties = new Properties();        testProperties.put("prop1", "value1");        testProperties.put("prop2", "value2");        testProperties.put("prop3", "value3");        includeProperties = new Properties();        includeProperties.putAll(testProperties);        includeProperties.put("prop3", "include3");        absoluteFile = File.createTempFile("dbtypetest", ".properties");        try (FileOutputStream fileOutputStream = new FileOutputStream(absoluteFile);             PrintStream printStream = new PrintStream(fileOutputStream)) {            for (Entry<?, ?> entry : testProperties.entrySet()) {                printStream.printf("%s=%s\n", entry.getKey(), entry.getValue());            }        }    }    @After    public void tearDown() throws Exception {        testProperties = null;        absoluteFile.delete();    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetPropertiesFromFile() throws Exception {        System.out.println("getPropertiesFromFile");        DBType instance = new DBType(absoluteFile.getAbsolutePath());        Properties expResult = testProperties;        Properties result = instance.getProperties();        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetProperties() throws Exception {        System.out.println("testGetProperties");        DBType instance = new DBType("test");        Properties expResult = testProperties;        System.out.println("testGetProperties: expected results " + testProperties);        Properties result = instance.getProperties();        System.out.println("testGetProperties: actual results " + result);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetIncludeProperties() throws Exception {        System.out.println("testGetIncludeProperties");        DBType instance = new DBType("include");        Properties expResult = includeProperties;        System.out.println("testGetIncludeProperties: expected results " + includeProperties);        Properties result = instance.getProperties();        System.out.println("testGetIncludeProperties: actual results " + result);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getResourceBundleAsProperties method, of class DBType.     */    @Test    public void testAsProperties() {        System.out.println("asProperties");        ResourceBundle bundle = ResourceBundle.getBundle(DBType.class.getPackage().getName() + ".test");        Properties expResult = testProperties;        Properties result = DBType.getResourceBundleAsProperties(bundle);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.InputStream;import org.junit.Assert;import org.junit.Test;/** * * @author sturton */public class ResourceLoaderTest {    /**     * Test of getResourceStream method, of class ResourceLoader.     */    @Test    public void testGetResourceStream() throws Exception {        System.out.println("getResourceStream");        String path = "";        ResourceLoader instance = new ResourceLoader();        InputStream expResult = null;        InputStream result = instance.getResourceStream(path);        Assert.assertNotNull(result);        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.Assert.assertEquals;import java.net.URI;import java.net.URISyntaxException;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;/** * * @author sturton */public class DBURITest {    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    /*     * Expected values from testdefaults.properties     */    static final String C_DEFAULT_USER = "scott";    static final String C_DEFAULT_PASSWORD = "tiger";    static final String C_DEFAULT_LANGUAGES = "java,plsql";    static final String C_DEFAULT_SCHEMAS = "scott,system";    static final String C_DEFAULT_SOURCE_CODE_TYPES = "table,view";    static final String C_DEFAULT_SOURCE_CODE_NAMES = "emp,dept";    static final String C_DEFAULT_CHARACTERSET = "utf8";    /**     * Fully specified URI, overriding defaults in testdefaults.properties     */    static final String C_TEST_EXPLICIT = "jdbc:oracle:testdefault:system/oracle@//192.168.100.21:1521/ORCL?characterset=us7ascii&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    /*     * Expected values from testdefaults.properties, with values overridden by     * URI query parameters     */    static final String C_EXPLICIT_USER = "system";    static final String C_EXPLICIT_PASSWORD = "oracle";    static final String C_EXPLICIT_LANGUAGES = "plsql,java";    static final String C_EXPLICIT_SCHEMAS = "scott,hr,sh,system";    static final String C_EXPLICIT_SOURCE_CODE_TYPES = "procedures,functions,triggers,package,types";    static final String C_EXPLICIT_SOURCE_CODE_NAMES = "PKG_%%,PRC_%%";    static final String C_EXPLICIT_CHARACTERSET = "us7ascii";    static final String C_TEST_URI = "test?param1=x%261&param2=&param3=";    static final String C_ORACLE_OCI_1 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_OCI_2 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_OCI_3 = "jdbc:oracle:oci:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_THIN_2 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_POSTGRES_1 = "jdbc:postgresql://host/database";    static final String C_HTTP = "http://localhost:80?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static void dump(String description, URI dburi) {        System.err.printf(                "Test %s\n: isOpaque=%s, isAbsolute=%s Scheme=%s,\n SchemeSpecificPart=%s,\n Host=%s,\n Port=%s,\n Path=%s,\n Fragment=%s,\n Query=%s\n",                description, dburi.isOpaque(), dburi.isAbsolute(), dburi.getScheme(), dburi.getSchemeSpecificPart(),                dburi.getHost(), dburi.getPort(), dburi.getPath(), dburi.getFragment(), dburi.getQuery());        String query = dburi.getQuery();        if (null != query && !"".equals(query)) {            String[] params = query.split("&");            Map<String, String> map = new HashMap<>();            for (String param : params) {                String[] splits = param.split("=");                String name = splits[0];                String value = null;                if (splits.length > 1) {                    value = splits[1];                }                map.put(name, value);                System.err.printf("name=%s,value=%s\n", name, value);            }        }        // return map;    }    /**     * Test of dump method, of class DBURI.     */    @Test    public void testDump() throws URISyntaxException, Exception {        System.out.println("dump");        String description = "";        DBURI dburi = new DBURI(C_TEST_URI);        DBURI.dump(description, dburi.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getUri method, of class DBURI.     */    @Test    public void testGetUri() throws URISyntaxException, Exception {        System.out.println("getUri");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        URI expResult = new URI(C_ORACLE_OCI_1);        URI result = instance.getUri();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setUri method, of class DBURI.     */    @Test    public void testSetUri() throws URISyntaxException, Exception {        System.out.println("setUri");        URI uri = new URI(C_ORACLE_OCI_1);        DBURI instance = new DBURI(C_TEST_URI);        instance.setUri(uri);        assertEquals(uri, instance.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    public void testGetDbType() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_POSTGRES_1);        DBType expResult = new DBType("postgresql");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    public void testGetDbType2() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        DBType expResult = new DBType("oci");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDbType method, of class DBURI.     */    @Test    public void testSetDbType() throws URISyntaxException, Exception {        System.out.println("setDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        DBType dbType = new DBType("postgresql");        instance.setDbType(dbType);        assertEquals(dbType, instance.getDbType());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSchemasList method, of class DBURI.     */    @Test    public void testGetSchemasList() throws URISyntaxException, Exception {        System.out.println("getSchemasList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult;        expResult = Arrays.asList("scott,hr,sh,system".split(","));        List<String> result = instance.getSchemasList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSchemasList method, of class DBURI.     */    @Test    public void testSetSchemasList() throws URISyntaxException, Exception {        System.out.println("setSchemasList");        List<String> schemasList = Arrays.asList("scott,hr,sh,system".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSchemasList(schemasList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeTypesList method, of class DBURI.     */    @Test    public void testGetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeTypesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("procedures,functions,triggers,package,types".split(","));        List<String> result = instance.getSourceCodeTypesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeTypesList method, of class DBURI.     */    @Test    public void testSetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeTypesList");        List<String> sourcecodetypesList = Arrays.asList("procedures,functions,triggers,package,types".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeTypesList(sourcecodetypesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeNamesList method, of class DBURI.     */    @Test    public void testGetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeNamesList");        DBURI instance = new DBURI(C_ORACLE_OCI_3);        List<String> expResult = Arrays.asList("PKG_%%,PRC_%%".split(","));        List<String> result = instance.getSourceCodeNamesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeNamesList method, of class DBURI.     */    @Test    public void testSetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeNamesList");        List<String> sourceCodeNamesList = Arrays.asList("PKG_%%,TRG_%%".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSourceCodeNamesList(sourceCodeNamesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getLanguagesList method, of class DBURI.     */    @Test    public void testGetLanguagesList() throws URISyntaxException, Exception {        System.out.println("getLanguagesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("plsql,java".split(","));        List<String> result = instance.getLanguagesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setLanguagesList method, of class DBURI.     */    @Test    public void testSetLanguagesList() throws URISyntaxException, Exception {        System.out.println("setLanguagesList");        List<String> languagesList = Arrays.asList("plsql,java".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setLanguagesList(languagesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    public void testGetDriverClass() throws URISyntaxException, Exception {        System.out.println("getDriverClass");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetDriverClass: driverClass=" + result);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    public void testGetThinDriverClass() throws URISyntaxException, Exception {        System.out.println("getThinDriverClass");        DBURI instance = new DBURI(C_ORACLE_THIN_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetThinDriverClass: driverClass=" + result);        System.out.println("testGetThinDriverClass: getDbType().getProperties() follows");        System.out                .println("testGetThinDriverClass: getDbType().getProperties()=" + instance.getDbType().getProperties());        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDriverClass method, of class DBURI.     */    @Test    public void testSetDriverClass() throws URISyntaxException, Exception {        System.out.println("setDriverClass");        String driverClass = "oracle.jdbc.driver.OracleDriver";        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setDriverClass(driverClass);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getCharacterSet method, of class DBURI.     */    @Test    public void testGetCharacterSet() throws URISyntaxException, Exception {        System.out.println("getCharacterSet");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "utf8";        String result = instance.getCharacterSet();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setCharacterSet method, of class DBURI.     */    @Test    public void testSetCharacterSet() throws URISyntaxException, Exception {        System.out.println("setCharacterSet");        String characterSet = "utf8";        DBURI instance = new DBURI(C_POSTGRES_1);        instance.setCharacterSet(characterSet);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeType method, of class DBURI.     */    @Test    public void testGetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("getSourceCodeType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        int expResult = 2005; // CLOB        int result = instance.getSourceCodeType();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeType method, of class DBURI.     */    @Test    public void testSetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("setSourceCodeType");        int sourceCodeType = 5;        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeType(sourceCodeType);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubprotocol method, of class DBURI.     */    @Test    public void testGetSubprotocol() throws URISyntaxException, Exception {        System.out.println("getSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oracle";        String result = instance.getSubprotocol();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubprotocol method, of class DBURI.     */    public void testSetSubprotocol() throws URISyntaxException, Exception {        System.out.println("setSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String subprotocol = "oracle";        instance.setSubprotocol(subprotocol);        String result = instance.getSubprotocol();        assertEquals(subprotocol, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubnamePrefix method, of class DBURI.     */    @Test    public void testGetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("getSubnamePrefix");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oci";        String result = instance.getSubnamePrefix();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubnamePrefix method, of class DBURI.     */    @Test    public void testSetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("setSubnamePrefix");        String subnamePrefix = "oci8";        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSubnamePrefix(subnamePrefix);        String result = instance.getSubnamePrefix();        assertEquals(subnamePrefix, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getParameters method, of class DBURI.     */    @Test    public void testGetParameters() throws URISyntaxException, Exception {        System.out.println("getParameters");        DBURI instance = new DBURI(C_TEST_URI);        Map<String, String> expResult = new HashMap<>();        expResult.put("param1", "x&1");        expResult.put("param2", null);        expResult.put("param3", null);        Map<String, String> result = instance.getParameters();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setParameters method, of class DBURI.     */    @Test    public void testSetParameters() throws URISyntaxException, Exception {        System.out.println("setParameters");        Map<String, String> parameters = new HashMap<>();        parameters.put("param1", "x%FFF");        parameters.put("param2", "IAmParameter2");        parameters.put("param3", "IAmParameter3");        DBURI instance = new DBURI(C_TEST_URI);        instance.setParameters(parameters);        // TODO review the generated test code and remove the default call to        // fail.        assertEquals(parameters, instance.getParameters());    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultLanguagesList() throws URISyntaxException, Exception {        System.out.println("testDefaultLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_DEFAULT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default CharacterSet are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultCharacterSet() throws URISyntaxException, Exception {        System.out.println("testDefaultCharacterSet");        DBURI instance = new DBURI(C_TEST_DEFAULTS);        String result = instance.getCharacterSet();        assertEquals(C_DEFAULT_CHARACTERSET, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultSchemasList() throws URISyntaxException, Exception {        System.out.println("testDefaultSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_DEFAULT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default Source Code Types are returned if non are provided in     * the DBURI.     */    @Test    public void testDefaultSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitLanguagesList() throws URISyntaxException, Exception {        System.out.println("testExplicitLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_EXPLICIT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that CharacterSet are returned if provided in the DBURI.     */    @Test    public void testExplicitCharacterSet() throws URISyntaxException, Exception {        System.out.println("testExplicitCharacterSet");        DBURI instance = new DBURI(C_TEST_EXPLICIT);        String result = instance.getCharacterSet();        assertEquals(C_EXPLICIT_CHARACTERSET, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitSchemasList() throws URISyntaxException, Exception {        System.out.println("testExplicitSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_EXPLICIT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that Source Code Types are returned if provided in the DBURI.     */    @Test    public void testExplicitSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.IOException;import java.io.Reader;import java.net.URISyntaxException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.List;import java.util.Properties;import java.util.logging.Level;import java.util.logging.Logger;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;/** * * @author sturton */@Ignorepublic class DBMSMetadataTest {    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:scott/tiger@//192.168.100.21:5521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:scott/oracle@//192.168.100.21:1521/orcl?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_4 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_5 = "jdbc:oracle:thin:@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25&amp;user=system&amp;password=oracle";    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    private DBURI dbURI;    private DBURI dbURI4;    private DBURI dbURI5;    private DBURI dbURIDefault;    public DBMSMetadataTest() throws URISyntaxException, Exception {        dbURI = new DBURI(C_ORACLE_THIN_3);        dbURI4 = new DBURI(C_ORACLE_THIN_4);        dbURI5 = new DBURI(C_ORACLE_THIN_5);        dbURIDefault = new DBURI(C_TEST_DEFAULTS);    }    /**     * Convert Readers to Strings for eay output and comparison.     */    private static String getStringFromReader(Reader reader) throws IOException {        StringBuilder stringBuilder = new StringBuilder(1024);        char[] charArray = new char[1024];        int readChars;        while ((readChars = reader.read(charArray)) > 0) {            System.out.println("Reader.read(CharArray)==" + readChars);            stringBuilder.append(charArray, 0, readChars);        }        reader.close();        return stringBuilder.toString();    }    /**     * Dump ResultSet     */    private static void dumpResultSet(ResultSet resultSet, String description) {        try {            ResultSetMetaData metaData = resultSet.getMetaData();            int columnCount = metaData.getColumnCount();            System.out.format("ResultSet \"%s\" has %d columns and contains ...\n[", description, columnCount);            /*             * Walk through the column names, writing out a header line             */            for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                System.out.format("%s%s", ((columnNumber > 1) ? "," : ""), metaData.getColumnName(columnNumber));            }            System.out.format("\n");            // Output each row            while (resultSet.next()) {                /*                 * Walk through the columns of this row, writing out a row line                 */                for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                    System.out.format("%s%s", ((columnNumber > 0) ? "," : ""), resultSet.getString(columnNumber));                }                System.out.format("\n");            }        } catch (SQLException ex) {            Logger.getLogger(DBMSMetadataTest.class.getName()).log(Level.SEVERE, null, ex);        }        System.out.format("...\n]\n");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @org.junit.Test    public void testGetConnection() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(dbURI.getURL()).connect(dbURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @Test    public void testGetConnectionWithConnectionParameters() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI5.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI5.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI5.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.putAll(dbURI5.getParameters());        Connection expResult = DriverManager.getDriver(dbURI5.getURL()).connect(dbURI5.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI5);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCode method, of class DBMSMetadata.     */    @Test    public void testGetSourceCode() throws Exception {        System.out.println("getSourceCode");        // String objectType = "PACKAGE";        // String name = "DBMS_REPCAT_AUTH";        // String schema = "SYSTEM";        String objectType = "TABLE";        String name = "EMP";        String schema = "SCOTT";        System.out.println("dbURI.driverClass==" + dbURI.getDriverClass());        System.out.println("dbURI.URL==" + dbURI.getURL());        System.out.println("dbURI.getDBType.getProperties()==" + dbURI.getDbType().getProperties());        System.out.println("dbURI.getDBType.getSourceCodeReturnType()==" + dbURI.getDbType().getSourceCodeReturnType());        System.out.println("dbURI.getDBType.getProperties()=="                + dbURI.getDbType().getProperties().getProperty("getSourceCodeStatement"));        DBMSMetadata instance = new DBMSMetadata(dbURI);        Reader expResult = null;        Reader result = instance.getSourceCode(objectType, name, schema);        /*         * StringBuilder stringBuilder = new StringBuilder(1024); char[]         * charArray = new char[1024]; int readChars = 0; while(( readChars =         * result.read(charArray)) > 0 ) {         * System.out.println("Reader.read(CharArray)=="+readChars);         * stringBuilder.append(charArray, 0, readChars); } result.close();         *         * System.out.println("getSourceCode()==\""+stringBuilder.toString()+         * "\"" );         *         * assertTrue(stringBuilder.toString().startsWith("\n  CREATE "));         */        String resultString = getStringFromReader(result);        System.out.println("getSourceCode()==\"" + resultString);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    public void testGetSchemas() throws Exception {        System.out.println("getSchemas");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        ResultSet allSchemas = result.getMetaData().getSchemas();        dumpResultSet(allSchemas, "All Schemas");        ResultSet allCatalogues = result.getMetaData().getCatalogs();        dumpResultSet(allCatalogues, "All Catalogues");        String catalog = null;        String schemasPattern = "PHPDEMO";        String tablesPattern = null;        String proceduresPattern = null;        // Not until Java6 ResultSet matchedSchemas =        // result.getMetaData().getSchemas(catalog, schemasPattern) ;        // Not until Java6 dumpResultSet (matchedSchemas, "Matched Schemas") ;        ResultSet matchedTables = result.getMetaData().getTables(catalog, schemasPattern, tablesPattern, null);        dumpResultSet(matchedTables, "Matched Tables");        ResultSet matchedProcedures = result.getMetaData().getProcedures(catalog, schemasPattern, proceduresPattern);        dumpResultSet(matchedProcedures, "Matched Procedures");        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    public void testGetSourceObjectList() throws Exception {        System.out.println("getConnection");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        List<SourceObject> sourceObjectList = instance.getSourceObjectList();        Assert.assertNotNull(sourceObjectList);        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());        System.out.printf("sourceObjectList ...\n");        for (SourceObject sourceObject : sourceObjectList) {            System.out.printf("sourceObject=%s\n", sourceObject);            System.out.printf("sourceCode=[%s]\n", getStringFromReader(instance.getSourceCode(sourceObject)));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.filter;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;public class RegexStringFilterTest {    @Test    public void testFilterAbsoluteWithExtension() {        String pattern = "C:/workspace/project/X.java";        verifyFilterFalse("same relative path w/ extension", pattern, "X.java");        verifyFilterFalse("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterTrue("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterFalse("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testFilterAbsoluteWithoutExtension() {        String pattern = "C:/workspace/project/X";        verifyFilterFalse("same relative path w/ extension", pattern, "X.java");        verifyFilterFalse("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterFalse("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterTrue("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testFilterRelativeWithExtension() {        String pattern = ".*X.java";        verifyFilterTrue("same relative path w/ extension", pattern, "X.java");        verifyFilterFalse("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterTrue("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterFalse("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testFilterRelativeWithoutExtension() {        String pattern = ".*X";        verifyFilterFalse("same relative path w/ extension", pattern, "X.java");        verifyFilterTrue("same relative path w/o extension", pattern, "X");        verifyFilterFalse("different relative path w/ extension", pattern, "Y.java");        verifyFilterFalse("different relative path w/o extension", pattern, "Y");        verifyFilterFalse("same absolute path w/ extension", pattern, "C:/workspace/project/X.java");        verifyFilterTrue("same absolute path w/o extension", pattern, "C:/workspace/project/X");        verifyFilterFalse("different absolute path w/ extension", pattern, "C:/workspace/project/Y.java");        verifyFilterFalse("different absolute path w/o extension", pattern, "C:/workspace/project/Y");    }    @Test    public void testEndsWith() {        // These patterns cannot be optimized to use String.endsWith        verifyEndsWith("no literal path", ".*", null);        verifyEndsWith("not ends with", "x", null);        verifyEndsWith("glob on end", ".*XXX.*", null);        verifyEndsWith("special character \\", ".*X\\Y", null);        verifyEndsWith("special character [", ".*X[Y", null);        verifyEndsWith("special character (", ".*X(Y", null);        verifyEndsWith("special character *", ".*X*Y", null);        verifyEndsWith("special character ?", ".*X?Y", null);        verifyEndsWith("special character +", ".*X+Y", null);        verifyEndsWith("special character |", ".*X|Y", null);        verifyEndsWith("special character {", ".*X{Y", null);        verifyEndsWith("special character $", ".*X$Y", null);        verifyEndsWith("too many .", ".*X.Y.java", null);        // These patterns can be optimized to use String.endsWith        verifyEndsWith("unescaped .", ".*X.java", "X.java");        verifyEndsWith("escaped .", ".*X\\.java", "X.java");        verifyEndsWith("no extension", ".*X", "X");        verifyEndsWith("begin anchor, unescaped .", "^.*X.java", "X.java");        verifyEndsWith("begin anchor, escaped .", "^.*X\\.java", "X.java");        verifyEndsWith("begin anchor, no extension", "^.*X", "X");        verifyEndsWith("end anchor, unescaped .", ".*X.java$", "X.java");        verifyEndsWith("end anchor, escaped .", ".*X\\.java$", "X.java");        verifyEndsWith("end anchor, no extension", ".*X$", "X");        verifyEndsWith("begin and end anchors, unescaped .", "^.*X.java$", "X.java");        verifyEndsWith("begin and end anchors, escaped .", "^.*X\\.java$", "X.java");        verifyEndsWith("begin and end anchors, no extension", "^.*X$", "X");    }    private static void verifyFilterTrue(final String message, final String pattern, final String file) {        assertTrue("filter: " + message, new RegexStringFilter(pattern).filter(file));    }    private static void verifyFilterFalse(final String message, final String pattern, final String file) {        assertFalse("filter: " + message, new RegexStringFilter(pattern).filter(file));    }    private static void verifyEndsWith(final String message, final String pattern, final String endsWith) {        assertEquals("endsWith: " + message, endsWith, new RegexStringFilter(pattern).getEndsWith());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(RegexStringFilterTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.datasource;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.IOException;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class FileDataSourceTest {        @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();        private static final String SOMEFILE_DIR = "path/";    private static final String SOMEFILE_TXT = "somefile.txt";    private static final String SOMEFILE_TXT_FULL_PATH = SOMEFILE_DIR + SOMEFILE_TXT;        private FileDataSource ds;    private File someFile;    private File someFolder;        @Before    public void setup() throws IOException {        someFolder = tempFolder.newFolder(SOMEFILE_DIR);        someFile = tempFolder.newFile(SOMEFILE_TXT_FULL_PATH);        ds = new FileDataSource(someFile);    }        @Test    public void testShortNamesSingleFile() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFile.getAbsolutePath()));    }        @Test    public void testShortNamesSingleDir() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFolder.getAbsolutePath()));    }        @Test    public void testShortNamesNullBase() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, null));    }        @Test    public void testShortNamesCommaSeparatedDirs() {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }        @Test    public void testShortNamesCommaSeparatedFiles() {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }        @Test    public void testShortNamesCommaSeparatedMixed() {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }        @Test    public void testLongNamesSingleFile() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFile.getAbsolutePath()));    }        @Test    public void testLongNamesSingleDir() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFolder.getAbsolutePath()));    }        @Test    public void testLongNamesNullBase() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, null));    }        @Test    public void testLongNamesCommaSeparatedDirs() throws IOException {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }        @Test    public void testLongNamesCommaSeparatedFiles() throws IOException {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }        @Test    public void testLongNamesCommaSeparatedMixed() throws IOException {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.NoSuchElementException;import org.junit.Before;import org.junit.Test;public class CompoundListTest {    private List<String> l1;    private List<String> l2;    private Iterator<String> iterator;    @Before    public void setUp() {        l1 = new ArrayList<>();        l1.add("1");        l1.add("2");        l2 = new ArrayList<>();        l2.add("3");        l2.add("4");        iterator = new CompoundIterator<>(l1.iterator(), l2.iterator());    }    @Test    public void testHappyPath() {        assertTrue(iterator.hasNext());        assertEquals("1", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("2", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("3", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("4", iterator.next());        assertFalse(iterator.hasNext());        assertEquals(2, l1.size());        assertEquals(2, l2.size());    }    @Test    public void testHappyPathRemove() {        assertTrue(iterator.hasNext());        assertEquals("1", iterator.next());        iterator.remove();        assertTrue(iterator.hasNext());        assertEquals("2", iterator.next());        assertTrue(iterator.hasNext());        assertEquals("3", iterator.next());        iterator.remove();        assertTrue(iterator.hasNext());        assertEquals("4", iterator.next());        assertFalse(iterator.hasNext());        assertEquals(1, l1.size());        assertEquals("2", l1.get(0));        assertEquals(1, l2.size());        assertEquals("4", l2.get(0));    }    @Test    public void testEmpty() {        Iterator<?> iterator = new CompoundIterator();        assertFalse(iterator.hasNext());    }    @Test(expected = NoSuchElementException.class)    public void testEmptyBadNext() {        Iterator<?> iterator = new CompoundIterator();        iterator.next();    }    @Test(expected = IllegalStateException.class)    public void testEmptyBadRemove() {        Iterator<?> iterator = new CompoundIterator();        iterator.remove();    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(CompoundListTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.fail;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Test;/** * Evaluates all major functionality of the TypeMap class. * * @author Brian Remedios */public class TypeMapTest {    @Test    public void testAddClassOfQ() {        TypeMap map = new TypeMap(2);        map.add(List.class);        try {            map.add(java.awt.List.class);        } catch (IllegalArgumentException ex) {            return; // caught ok        }        fail("Uncaught error inserting type with same root names");    }    @Test    public void testContainsClassOfQ() {        TypeMap map = new TypeMap(2);        map.add(String.class);        map.add(List.class);        Assert.assertTrue(map.contains(String.class));        Assert.assertTrue(map.contains(List.class));        Assert.assertFalse(map.contains(Map.class));    }    @Test    public void testContainsString() {        TypeMap map = new TypeMap(2);        map.add(String.class);        map.add(List.class);        Assert.assertTrue(map.contains("String"));        Assert.assertTrue(map.contains("java.lang.String"));    }    @Test    public void testTypeFor() {        TypeMap map = new TypeMap(2);        map.add(String.class);        map.add(List.class);        Assert.assertTrue(map.typeFor("String") == String.class);        Assert.assertTrue(map.typeFor("java.lang.String") == String.class);        Assert.assertTrue(map.typeFor("List") == List.class);        Assert.assertTrue(map.typeFor("java.util.List") == List.class);    }    @Test    public void testSize() {        TypeMap map = new TypeMap(4);        map.add(String.class);        map.add(HashMap.class);        map.add(Integer.class);        Assert.assertTrue(map.size() == 6);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.assertEquals;import java.util.Collection;import org.junit.Test;import net.sourceforge.pmd.ReadableDurationTest;/** * * @author Brian Remedios */public class DateTimeUtilTest {    @Test    public void testConversions() {        Collection<Object[]> stringNumberPairs = ReadableDurationTest.data();        for (Object[] stringAndNumber : stringNumberPairs) {            String result = (String) stringAndNumber[0];            Integer milliseconds = (Integer) stringAndNumber[1];            assertEquals(result, DateTimeUtil.asHoursMinutesSeconds(milliseconds));        }    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(DateTimeUtilTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.assertEquals;import org.junit.Test;public class StringUtilTest {    @Test    public void testReplaceWithOneChar() {        assertEquals("faa", StringUtil.replaceString("foo", 'o', "a"));    }    @Test    public void testReplaceWithMultipleChars() {        assertEquals("faaaa", StringUtil.replaceString("foo", 'o', "aa"));    }    @Test    public void testReplaceStringWithString() {        assertEquals("foo]]&gt;bar", StringUtil.replaceString("foo]]>bar", "]]>", "]]&gt;"));    }    @Test    public void testReplaceStringWithString2() {        assertEquals("replaceString didn't work with a >", "foobar",                StringUtil.replaceString("foobar", "]]>", "]]&gt;"));    }    @Test    public void testReplaceWithNull() {        assertEquals("replaceString didn't work with a char", "f", StringUtil.replaceString("foo", 'o', null));    }    /**     * Usually you would set the system property     * "net.sourceforge.pmd.supportUTF8" to either "no" or "yes", to switch UTF8     * support.     *     * e.g.     * <code>System.setProperty("net.sourceforge.pmd.supportUTF8","yes");</code>     */    @Test    public void testUTF8NotSupported() {        StringBuilder sb = new StringBuilder();        String test = "é";        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#xe9;", sb.toString());    }    @Test    public void testUTF8NotSupportedSurrogates() {        // D8 34 DD 1E -> U+1D11E        StringBuilder sb = new StringBuilder();        String test = new String(new char[] {0xd834, 0xdd1e});        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#x1d11e;", sb.toString());    }    @Test    public void testUTF8Supported() {        StringBuilder sb = new StringBuilder();        String test = "é";        StringUtil.appendXmlEscaped(sb, test, true);        assertEquals("é", sb.toString());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(StringUtilTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.internal.util;import static java.util.Collections.emptyIterator;import static org.hamcrest.collection.IsIterableContainingInOrder.contains;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertThat;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.NoSuchElementException;import java.util.Objects;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;public class IteratorUtilTest {    @Rule    public ExpectedException exception = ExpectedException.none();    @Test    public void testAnyMatchPos() {        Iterator<String> iter = iterOf("a", "b", "cd");        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    public void testAnyMatchNeg() {        Iterator<String> iter = iterOf("a", "b", "");        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    public void testAnyMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    public void testAllMatchPos() {        Iterator<String> iter = iterOf("ap", "bcd", "cd");        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    public void testAllMatchNeg() {        Iterator<String> iter = iterOf("a", "bcd", "");        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    public void testAllMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    public void testNoneMatchPos() {        Iterator<String> iter = iterOf("ap", "bcd", "cd");        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertTrue(match);    }    @Test    public void testNoneMatchNeg() {        Iterator<String> iter = iterOf("a", "bcd", "");        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertFalse(match);    }    @Test    public void testNoneMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertTrue(match);    }    @Test    public void testFlatmap() {        Iterator<String> iter = iterOf("ab", "cd", "e", "", "f");        Function<String, Iterator<String>> fun = s -> s.chars().mapToObj(i -> (char) i).map(String::valueOf).iterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertThat(() -> mapped, contains("a", "b", "c", "d", "e", "f"));    }    @Test    public void testFlatmapEmpty() {        Iterator<String> iter = emptyIterator();        Function<String, Iterator<String>> fun = s -> s.chars().mapToObj(i -> (char) i).map(String::valueOf).iterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    public void testFlatmapEmpty2() {        Iterator<String> iter = iterOf("ab", "cd", "e", "", "f");        Function<String, Iterator<String>> fun = s -> emptyIterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    public void testFlatmapIsLazy() {        Iterator<String> iter = iterOf("a", "b");        Function<String, Iterator<String>> fun = s -> {            if (s.equals("a")) {                return iterOf("a");            } else {                throw new AssertionError("This statement shouldn't be reached");            }        };        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertTrue(mapped.hasNext());        assertEquals("a", mapped.next());        exception.expect(AssertionError.class);        assertTrue(mapped.hasNext());    }    @Test    public void testMapNotNull() {        Iterator<String> iter = iterOf("ab", "cdde", "e", "", "f", "fe");        Function<String, Integer> fun = s -> s.length() < 2 ? null : s.length();        Iterator<Integer> mapped = IteratorUtil.mapNotNull(iter, fun);        assertThat(() -> mapped, contains(2, 4, 2));    }    @Test    public void testMapNotNullEmpty() {        Iterator<String> iter = emptyIterator();        Function<String, Integer> fun = s -> s.length() < 2 ? null : s.length();        Iterator<Integer> mapped = IteratorUtil.mapNotNull(iter, fun);        assertExhausted(mapped);    }    @Test    public void testMapNotNullEmpty2() {        Iterator<String> iter = iterOf("a", "b");        Function<String, Iterator<String>> fun = s -> null;        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    public void testFilterNotNull() {        Iterator<String> iter = iterOf("ab", null, "e", null, "", "fe");        Iterator<String> mapped = IteratorUtil.filterNotNull(iter);        assertThat(() -> mapped, contains("ab", "e", "", "fe"));        assertExhausted(iter);    }    @Test    public void testDistinct() {        Iterator<String> iter = iterOf("ab", null, "e", null, "fe", "ab", "c");        Iterator<String> mapped = IteratorUtil.distinct(iter);        assertThat(() -> mapped, contains("ab", null, "e", "fe", "c"));        assertExhausted(iter);    }    @Test    public void testTakeWhile() {        Iterator<String> iter = iterOf("ab", "null", "e", null, "", "fe");        Predicate<String> predicate = Objects::nonNull;        Iterator<String> mapped = IteratorUtil.takeWhile(iter, predicate);        assertThat(() -> mapped, contains("ab", "null", "e"));        assertExhausted(mapped);    }    @Test    public void testPeek() {        Iterator<String> iter = iterOf("ab", null, "c");        List<String> seen = new ArrayList<>();        Consumer<String> action = seen::add;        Iterator<String> mapped = IteratorUtil.peek(iter, action);        assertEquals("ab", mapped.next());        assertThat(seen, contains("ab"));        assertNull(mapped.next());        assertThat(seen, contains("ab", null));        assertEquals("c", mapped.next());        assertThat(seen, contains("ab", null, "c"));        assertExhausted(mapped);    }    @Test    public void testTakeNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        exception.expect(IllegalArgumentException.class);        IteratorUtil.take(iter, -5);    }    @Test    public void testTake0() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 0);        assertExhausted(mapped);    }    @Test    public void testTake() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 1);        assertThat(() -> mapped, contains("a"));        assertExhausted(mapped);    }    @Test    public void testTakeOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 12);        assertThat(() -> mapped, contains("a", "b", "c"));        assertExhausted(mapped);    }    @Test    public void testDropNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        exception.expect(IllegalArgumentException.class);        IteratorUtil.advance(iter, -5);    }    @Test    public void testDrop0() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 0);        assertThat(() -> mapped, contains("a", "b", "c"));        assertExhausted(mapped);    }    @Test    public void testDrop() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 1);        assertThat(() -> mapped, contains("b", "c"));        assertExhausted(mapped);    }    @Test    public void testDropOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 12);        assertExhausted(mapped);    }    @Test    public void testGetNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        exception.expect(IllegalArgumentException.class);        IteratorUtil.getNth(iter, -5);    }    @Test    public void testGet0() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 0);        assertEquals("a", elt);    }    @Test    public void testGetNth() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 1);        assertEquals("b", elt);    }    @Test    public void testGetOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 12);        assertNull(elt);    }    @Test    public void testLast() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.last(iter);        assertEquals("c", elt);        assertExhausted(iter);    }    @Test    public void testLastEmpty() {        Iterator<String> iter = emptyIterator();        String elt = IteratorUtil.last(iter);        assertNull(elt);    }    @Test    public void testCount() {        Iterator<String> iter = iterOf("a", "b", "c");        int size = IteratorUtil.count(iter);        assertEquals(size, 3);        assertExhausted(iter);    }    @Test    public void testCountEmpty() {        Iterator<String> iter = emptyIterator();        int size = IteratorUtil.count(iter);        assertEquals(size, 0);    }    @Test    public void testToList() {        Iterator<String> iter = iterOf("a", "b", "c");        List<String> lst = IteratorUtil.toList(iter);        assertEquals(lst, listOf("a", "b", "c"));        assertExhausted(iter);    }    @Test    public void testAsReversed() {        List<String> iter = listOf("a", "b", "c");        Iterable<String> mapped = IteratorUtil.asReversed(iter);        assertThat(mapped, contains("c", "b", "a"));    }    @Test    public void testAsReversedIsRepeatable() {        List<String> iter = listOf("a", "b", "c");        Iterable<String> mapped = IteratorUtil.asReversed(iter);        // doesn't exhaust iterator        assertThat(mapped, contains("c", "b", "a"));        assertThat(mapped, contains("c", "b", "a"));        assertThat(mapped, contains("c", "b", "a"));    }    private void assertExhausted(Iterator<?> mapped) {        assertFalse(mapped.hasNext());        exception.expect(NoSuchElementException.class);        mapped.next();    }    static <T> Iterator<T> iterOf(T... ts) {        return Arrays.asList(ts).iterator();    }    static <T> List<T> listOf(T... ts) {        return Arrays.asList(ts);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.internal;import java.io.StringReader;import java.util.Arrays;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.AstProcessingStage;import net.sourceforge.pmd.lang.ast.DummyAstStages;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.rule.AbstractRule;public class StageDependencyTest {    private final LanguageVersion version = LanguageRegistry.findLanguageByTerseName("dummy").getVersion("1.0");    private DummyNode process(String source, RuleSets ruleSets) {        PMDConfiguration configuration = new PMDConfiguration();        return process(source, ruleSets, new RulesetStageDependencyHelper(configuration), configuration);    }    private DummyNode process(String source, RuleSets ruleSets, RulesetStageDependencyHelper helper, PMDConfiguration configuration) {        RuleContext context = new RuleContext();        Parser parser = PMD.parserFor(version, configuration);        context.setLanguageVersion(version);        RootNode rootNode = (RootNode) parser.parse("dummyfile.dummy", new StringReader(source));        helper.runLanguageSpecificStages(ruleSets, version, rootNode);        return (DummyNode) rootNode;    }    @Test    public void testSimpleDependency() throws PMDException {        DummyNode root = process("foo bar", withRules(new PredicateTestRule(DummyAstStages.FOO)));        Assert.assertTrue(DummyAstStages.FOO.hasProcessed(root));        Assert.assertFalse(DummyAstStages.BAR.hasProcessed(root));    }    @Test    public void testNoDependency() throws PMDException {        DummyNode root = process("foo bar", withRules(new PredicateTestRule()));        Assert.assertFalse(DummyAstStages.FOO.hasProcessed(root));        Assert.assertFalse(DummyAstStages.BAR.hasProcessed(root));    }    @Test    public void testDependencyUnion() throws PMDException {        DummyNode root =            process("foo bar",                    withRules(                        new PredicateTestRule(DummyAstStages.FOO),                        new PredicateTestRule(DummyAstStages.BAR)                    )            );        Assert.assertTrue(DummyAstStages.FOO.hasProcessed(root));        Assert.assertTrue(DummyAstStages.BAR.hasProcessed(root));    }    @Test    public void testTransitiveDependency() throws PMDException {        DummyNode root = process("foo bar", withRules(new PredicateTestRule(DummyAstStages.RUNS_FOO)));        Assert.assertTrue(DummyAstStages.FOO.hasProcessed(root));        Assert.assertFalse(DummyAstStages.BAR.hasProcessed(root));        Assert.assertTrue(DummyAstStages.RUNS_FOO.hasProcessed(root));    }    @Test    public void testNoRecomputation() throws PMDException {        PMDConfiguration configuration = new PMDConfiguration();        RulesetStageDependencyHelper helper = new RulesetStageDependencyHelper(configuration);        RuleSets ruleSets = withRules(new PredicateTestRule(DummyAstStages.RUNS_FOO));        List<AstProcessingStage<?>> stages1 = helper.testOnlyGetDependencies(ruleSets, version);        process("foo bar", ruleSets);        List<AstProcessingStage<?>> stages2 = helper.testOnlyGetDependencies(ruleSets, version);        Assert.assertSame(stages1, stages2);    }    @Test    public void testDependencyOrdering() throws PMDException {        PMDConfiguration configuration = new PMDConfiguration();        RulesetStageDependencyHelper helper = new RulesetStageDependencyHelper(configuration);        RuleSets ruleSets = withRules(            new PredicateTestRule(DummyAstStages.FOO),            new PredicateTestRule(DummyAstStages.BAR)        );        RuleSets ruleSets2 = withRules(            new PredicateTestRule(DummyAstStages.BAR),            new PredicateTestRule(DummyAstStages.FOO)        );        List<AstProcessingStage<?>> stages1 = helper.testOnlyGetDependencies(ruleSets, version);        List<AstProcessingStage<?>> stages2 = helper.testOnlyGetDependencies(ruleSets2, version);        Assert.assertNotSame(stages1, stages2);        Assert.assertEquals(stages1, stages2);    }    private static RuleSets withRules(Rule r, Rule... rs) {        RuleSets ruleSets = new RuleSets(new RuleSetFactory().createSingleRuleRuleSet(r));        for (Rule rule : rs) {            ruleSets.addRuleSet(new RuleSetFactory().createSingleRuleRuleSet(rule));        }        return ruleSets;    }    private static class PredicateTestRule extends AbstractRule {        private final List<DummyAstStages> dependencies;        PredicateTestRule(DummyAstStages... dependencies) {            this.dependencies = Arrays.asList(dependencies);        }        @Override        public Language getLanguage() {            return LanguageRegistry.findLanguageByTerseName("dummy");        }        @Override        public boolean dependsOn(AstProcessingStage<?> stage) {            return dependencies.contains(stage);        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {        }        @Override        public int hashCode() {            return 0;        }        @Override        public boolean equals(Object o) {            return this == o;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.processor;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.ThreadSafeReportListener;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.renderers.AbstractAccumulatingRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.util.datasource.DataSource;import net.sourceforge.pmd.util.datasource.internal.AbstractDataSource;public class MultiThreadProcessorTest {    private RuleContext ctx;    private MultiThreadProcessor processor;    private RuleSetFactory ruleSetFactory;    private List<DataSource> files;    private SimpleReportListener reportListener;        public void setUpForTest(final String ruleset) {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setRuleSets(ruleset);        configuration.setThreads(2);        files = new ArrayList<>();        files.add(new StringDataSource("file1-violation.dummy", "ABC"));        files.add(new StringDataSource("file2-foo.dummy", "DEF"));        reportListener = new SimpleReportListener();        ctx = new RuleContext();        ctx.getReport().addListener(reportListener);        processor = new MultiThreadProcessor(configuration);        ruleSetFactory = new RuleSetFactory();    }        @Test    public void testRulesDysnfunctionalLog() throws IOException {        setUpForTest("rulesets/MultiThreadProcessorTest/dysfunctional.xml");        final SimpleRenderer renderer = new SimpleRenderer(null, null);        renderer.start();        processor.processFiles(ruleSetFactory, files, ctx, Collections.<Renderer>singletonList(renderer));        renderer.end();        final Iterator<ConfigurationError> configErrors = renderer.getReport().configErrors();        final ConfigurationError error = configErrors.next();                Assert.assertEquals("Dysfunctional rule message not present",                DysfunctionalRule.DYSFUNCTIONAL_RULE_REASON, error.issue());        Assert.assertEquals("Dysfunctional rule is wrong",                DysfunctionalRule.class, error.rule().getClass());        Assert.assertFalse("More configuration errors found than expected", configErrors.hasNext());    }        @Test    public void testRulesThreadSafety() {        setUpForTest("rulesets/MultiThreadProcessorTest/basic.xml");        processor.processFiles(ruleSetFactory, files, ctx, Collections.<Renderer>emptyList());        // if the rule is not executed, then maybe a        // ConcurrentModificationException happened        Assert.assertEquals("Test rule has not been executed", 2, NotThreadSafeRule.count.get());        // if the violation is not reported, then the rule instances have been        // shared between the threads        Assert.assertEquals("Missing violation", 1, reportListener.violations.get());    }    private static class StringDataSource extends AbstractDataSource {        private final String data;        private final String name;        StringDataSource(String name, String data) {            this.name = name;            this.data = data;        }        @Override        public InputStream getInputStream() throws IOException {            return new ByteArrayInputStream(data.getBytes("UTF-8"));        }        @Override        public String getNiceFileName(boolean shortNames, String inputFileName) {            return name;        }    }    public static class NotThreadSafeRule extends AbstractRule {        public static AtomicInteger count = new AtomicInteger(0);        private boolean hasViolation; // this variable will be overridden        // between the threads        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            count.incrementAndGet();            if (ctx.getSourceCodeFilename().contains("violation")) {                hasViolation = true;            } else {                letTheOtherThreadRun(10);                hasViolation = false;            }            letTheOtherThreadRun(100);            if (hasViolation) {                addViolation(ctx, nodes.get(0));            }        }        private void letTheOtherThreadRun(int millis) {            try {                Thread.yield();                Thread.sleep(millis);            } catch (InterruptedException e) {                // ignored            }        }    }        public static class DysfunctionalRule extends AbstractRule {        public static final String DYSFUNCTIONAL_RULE_REASON = "dysfunctional rule is dysfunctional";        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            // noop        }                @Override        public String dysfunctionReason() {            return DYSFUNCTIONAL_RULE_REASON;        }    }    private static class SimpleReportListener implements ThreadSafeReportListener {        public AtomicInteger violations = new AtomicInteger(0);        @Override        public void ruleViolationAdded(RuleViolation ruleViolation) {            violations.incrementAndGet();        }    }        private static class SimpleRenderer extends AbstractAccumulatingRenderer {        /* default */ SimpleRenderer(String name, String description) {            super(name, description);        }        @Override        public String defaultFileExtension() {            return null;        }        @Override        public void end() throws IOException {        }                public Report getReport() {            return report;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.document;import static org.junit.Assert.assertEquals;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class DocumentFileTest {    private static final String FILE_PATH = "psvm.java";    @Rule    public TemporaryFolder temporaryFolder = new TemporaryFolder();    private File temporaryFile;    @Before    public void setUpTemporaryFiles() throws IOException {        temporaryFile = temporaryFolder.newFile(FILE_PATH);    }    @Test    public void insertAtStartOfTheFileShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void shouldPreserveNewlines() throws IOException {        final String testFileContent = IOUtils.toString(                DocumentFileTest.class.getResource("ShouldPreserveNewlines.java"), StandardCharsets.UTF_8);        writeContentToTemporaryFile(testFileContent);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public " + testFileContent, actualContent);        }    }    private byte[] readAllBytes(final FileInputStream stream) throws IOException {        final int defaultBufferSize = 8192;        final int maxBufferSize = Integer.MAX_VALUE - 8;        byte[] buf = new byte[defaultBufferSize];        int capacity = buf.length;        int nread = 0;        int n;        while (true) {            // read to EOF which may read more or less than initial buffer size            while ((n = stream.read(buf, nread, capacity - nread)) > 0) {                nread += n;            }            // if the last call to read returned -1, then we're done            if (n < 0) {                break;            }            // need to allocate a larger buffer            if (capacity <= maxBufferSize - capacity) {                capacity = capacity << 1;            } else {                if (capacity == maxBufferSize) {                    throw new OutOfMemoryError("Required array size too large");                }                capacity = maxBufferSize;            }            buf = Arrays.copyOf(buf, capacity);        }        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);    }    @Test    public void insertVariousTokensIntoTheFileShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.insert(0, 17, "final ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(final String[] args) {}", actualContent);        }    }    @Test    public void insertAtTheEndOfTheFileShouldSucceed() throws IOException {        final String code = "public static void main(String[] args)";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, code.length(), "{}");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args){}", actualContent);        }    }    @Test    public void removeTokenShouldSucceed() throws IOException {        final String code = "public static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.delete(new RegionByLineImp(0, 0, 24, 30));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndRemoveTokensShouldSucceed() throws IOException {        final String code = "static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.delete(new RegionByLineImp(0, 0, 17, 23));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndDeleteVariousTokensShouldSucceed() throws IOException {        final String code = "void main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.insert(0, 0, "static ");            documentFile.delete(new RegionByLineImp(0, 0, 0, 4));            documentFile.insert(0, 10, "final ");            documentFile.delete(new RegionByLineImp(0, 0, 25, 28));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static  main(final String[] args) ", actualContent);        }    }    @Test    public void replaceATokenShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.replace(new RegionByLineImp(0, 0, 0, 3), "void");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void main(String[] args) {}", actualContent);        }    }    @Test    public void replaceVariousTokensShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.replace(new RegionByLineImp(0, 0, 0, "int".length()), "void");            documentFile.replace(new RegionByLineImp(0, 0, 4, 4 + "main".length()), "foo");            documentFile.replace(new RegionByLineImp(0, 0, 9, 9 + "String".length()), "CharSequence");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void foo(CharSequence[] args) {}", actualContent);        }    }    @Test    public void insertDeleteAndReplaceVariousTokensShouldSucceed() throws IOException {        final String code = "static int main(CharSequence[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public");            documentFile.delete(new RegionByLineImp(0, 0, 0, 6));            documentFile.replace(new RegionByLineImp(0, 0, 7, 7 + "int".length()), "void");            documentFile.insert(0, 16, "final ");            documentFile.replace(new RegionByLineImp(0, 0, 16, 16 + "CharSequence".length()), "String");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public void main(final String[] args) {}", actualContent);        }    }    @Test    public void lineToOffsetMappingWithLineFeedShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + '\n'                + "int var;" + '\n'                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(40);        expectedLineToOffset.add(49);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    @Test    public void lineToOffsetMappingWithCarriageReturnFeedLineFeedShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + "\r\n"                + "int var;" + "\r\n"                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(41);        expectedLineToOffset.add(51);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    @Test    public void lineToOffsetMappingWithMixedLineSeparatorsShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + "\r\n"                + "int var;" + "\n"                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(41);        expectedLineToOffset.add(50);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    private void writeContentToTemporaryFile(final String content) throws IOException {        try (BufferedWriter writer = Files.newBufferedWriter(temporaryFile.toPath(), StandardCharsets.UTF_8)) {            writer.write(content);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.document;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.Collections;import java.util.LinkedList;import java.util.List;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class DocumentOperationsApplierForNonOverlappingRegionsWithDocumentFileTest {    private static final String FILE_PATH = "psvm.java";    @Rule    public TemporaryFolder temporaryFolder = new TemporaryFolder();    private File temporaryFile;    private DocumentOperationsApplierForNonOverlappingRegions applier;    @Before    public void setUpTemporaryFiles() throws IOException {        temporaryFile = temporaryFolder.newFile(FILE_PATH);    }    @Test    public void insertAtStartOfTheDocumentShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    private byte[] readAllBytes(final FileInputStream stream) throws IOException {        final int defaultBufferSize = 8192;        final int maxBufferSize = Integer.MAX_VALUE - 8;        byte[] buf = new byte[defaultBufferSize];        int capacity = buf.length;        int nread = 0;        int n;        while (true) {            // read to EOF which may read more or less than initial buffer size            while ((n = stream.read(buf, nread, capacity - nread)) > 0) {                nread += n;            }            // if the last call to read returned -1, then we're done            if (n < 0) {                break;            }            // need to allocate a larger buffer            if (capacity <= maxBufferSize - capacity) {                capacity = capacity << 1;            } else {                if (capacity == maxBufferSize) {                    throw new OutOfMemoryError("Required array size too large");                }                capacity = maxBufferSize;            }            buf = Arrays.copyOf(buf, capacity);        }        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);    }    @Test    public void removeTokenShouldSucceed() throws IOException {        writeContentToTemporaryFile("public static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 7, 13));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public  void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndRemoveTokensShouldSucceed() throws IOException {        final String code = "static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 17, 23));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndDeleteVariousTokensShouldSucceed() throws IOException {        final String code = "void main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "static "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 0, 4));            applier.addDocumentOperation(new InsertDocumentOperation(0, 10, "final "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 25, 27));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static  main(final String[] args) ", actualContent);        }    }    @Test    public void replaceATokenShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new ReplaceDocumentOperation(0, 0, 0, "int".length(), "void"));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void main(String[] args) {}", actualContent);        }    }    @Test    public void replaceVariousTokensShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        final List<DocumentOperation> documentOperations = new LinkedList<>();        documentOperations.add(new ReplaceDocumentOperation(0, 0, 0, "int".length(), "void"));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 4, 4 + "main".length(), "foo"));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 9, 9 + "String".length(), "CharSequence"));        shuffleAndApplyOperations(documentOperations);        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void foo(CharSequence[] args) {}", actualContent);        }    }    private void shuffleAndApplyOperations(List<DocumentOperation> documentOperations) throws IOException {        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            Collections.shuffle(documentOperations);            for (final DocumentOperation operation : documentOperations) {                applier.addDocumentOperation(operation);            }            applier.apply();        }    }    @Test    public void insertDeleteAndReplaceVariousTokensShouldSucceed() throws IOException {        final String code = "static int main(CharSequence[] args) {}";        writeContentToTemporaryFile(code);        final List<DocumentOperation> documentOperations = new LinkedList<>();        documentOperations.add(new InsertDocumentOperation(0, 0, "public"));        documentOperations.add(new DeleteDocumentOperation(0, 0, 0, 6));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 7, 7 + "int".length(), "void"));        documentOperations.add(new InsertDocumentOperation(0, 16, "final "));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 16, 16 + "CharSequence".length(), "String"));        shuffleAndApplyOperations(documentOperations);        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public void main(final String[] args) {}", actualContent);        }    }    private void writeContentToTemporaryFile(final String content) throws IOException {        try (FileWriter writer = new FileWriter(temporaryFile)) {            writer.write(content);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Collections;import java.util.List;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TemporaryFolder;import org.mockito.Mockito;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.Language;public class FileAnalysisCacheTest {        @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();        @Rule    public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();        private File unexistingCacheFile;    private File newCacheFile;    private File emptyCacheFile;        private File sourceFile;        @Before    public void setUp() throws IOException {        unexistingCacheFile = new File(tempFolder.getRoot(), "non-existing-file.cache");        newCacheFile = new File(tempFolder.getRoot(), "pmd-analysis.cache");        emptyCacheFile = tempFolder.newFile();        sourceFile = tempFolder.newFile("Source.java");    }    @Test    public void testLoadFromNonExistingFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        assertNotNull("Cache creation from non existing file failed.", cache);    }        @Test    public void testLoadFromEmptyFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        assertNotNull("Cache creation from empty file failed.", cache);    }        @Test    public void testLoadFromDirectoryShouldntThrow() throws IOException {        new FileAnalysisCache(tempFolder.getRoot());    }        @Test    public void testLoadFromUnreadableFileShouldntThrow() throws IOException {        emptyCacheFile.setReadable(false);        new FileAnalysisCache(emptyCacheFile);    }    @Test    public void testStoreCreatesFile() {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        cache.persist();        assertTrue("Cache file doesn't exist after store", unexistingCacheFile.exists());    }    @Test    public void testStoreOnUnwritableFileShouldntThrow() {        emptyCacheFile.setWritable(false);        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        cache.persist();    }    @Test    public void testStorePersistsFilesWithViolations() {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        cache.isUpToDate(sourceFile);        final RuleViolation rv = mock(RuleViolation.class);        when(rv.getFilename()).thenReturn(sourceFile.getPath());        final net.sourceforge.pmd.Rule rule = mock(net.sourceforge.pmd.Rule.class, Mockito.RETURNS_SMART_NULLS);        when(rule.getLanguage()).thenReturn(mock(Language.class));        when(rv.getRule()).thenReturn(rule);        cache.ruleViolationAdded(rv);        cache.persist();        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        assertTrue("Cache believes unmodified file with violations is not up to date",                reloadedCache.isUpToDate(sourceFile));                final List<RuleViolation> cachedViolations = reloadedCache.getCachedViolations(sourceFile);        assertEquals("Cached rule violations count mismatch", 1, cachedViolations.size());    }    @Test    public void testCacheValidityWithNoChanges() {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date without ruleset / classpath changes",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testRulesetChangeInvalidatesCache() {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(rs.getChecksum()).thenReturn(1L);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes unmodified file is up to date after ruleset changed",                reloadedCache.isUpToDate(sourceFile));    }        @Test    public void testAuxClasspathNonExistingAuxclasspathEntriesIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { new File(tempFolder.getRoot(), "non-existing-dir").toURI().toURL(), });                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                final FileAnalysisCache analysisCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] {});        analysisCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date after non-existing auxclasspath entry removed",                analysisCache.isUpToDate(sourceFile));    }        @Test    public void testAuxClasspathChangeWithoutDFAorTypeResolutionDoesNotInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] { tempFolder.newFile().toURI().toURL(), });        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date after auxclasspath changed when no rule cares",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        final File classpathFile = tempFolder.newFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });                // Make sure the auxclasspath file is not empty        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());                final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.isDfa()).thenReturn(true);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes unmodified file is up to date after auxclasspath changed",                reloadedCache.isUpToDate(sourceFile));    }        @Test    public void testAuxClasspathJarContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);                final File classpathFile = tempFolder.newFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });                final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.isDfa()).thenReturn(true);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                // Edit the auxclasspath referenced file        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when a auxclasspath file changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testClasspathNonExistingEntryIsIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);                System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator                + tempFolder.getRoot().getAbsolutePath() + File.separator + "non-existing-dir");                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        try {            reloadedCache.checkValidity(rs, cl);        } catch (final Exception e) {            fail("Validity check failed when classpath includes non-existing directories");        }    }        @Test    public void testClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);                final File classpathFile = tempFolder.newFile();                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                // Edit the classpath referenced file        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }        @Test    public void testClasspathContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);                final File classpathFile = tempFolder.newFile();                // Add a file to classpath        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());                setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);                // Change the file's contents        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some other text".getBytes());                final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when a classpath file changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testWildcardClasspath() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Prepare two jar files        final File classpathJar1 = tempFolder.newFile("mylib1.jar");        Files.write(classpathJar1.toPath(), "content of mylib1.jar".getBytes(StandardCharsets.UTF_8));        final File classpathJar2 = tempFolder.newFile("mylib2.jar");        Files.write(classpathJar2.toPath(), "content of mylib2.jar".getBytes(StandardCharsets.UTF_8));        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.getRoot().getAbsolutePath() + "/*");        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testWildcardClasspathContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        // Prepare two jar files        final File classpathJar1 = tempFolder.newFile("mylib1.jar");        Files.write(classpathJar1.toPath(), "content of mylib1.jar".getBytes(StandardCharsets.UTF_8));        final File classpathJar2 = tempFolder.newFile("mylib2.jar");        Files.write(classpathJar2.toPath(), "content of mylib2.jar".getBytes(StandardCharsets.UTF_8));        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.getRoot().getAbsolutePath() + "/*");        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Change one file's contents        Files.write(Paths.get(classpathJar2.getAbsolutePath()), "some other text".getBytes(StandardCharsets.UTF_8));        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testUnknownFileIsNotUpToDate() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse("Cache believes an unknown file is up to date",                cache.isUpToDate(sourceFile));    }    @Test    public void testFileIsUpToDate() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);                final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertTrue("Cache believes a known, unchanged file is not up to date",                cache.isUpToDate(sourceFile));    }        @Test    public void testFileIsNotUpToDateWhenEdited() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);                // Edit the file        Files.write(Paths.get(sourceFile.getAbsolutePath()), "some text".getBytes());                final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse("Cache believes a known, changed file is up to date",                cache.isUpToDate(sourceFile));    }    private void setupCacheWithFiles(final File cacheFile, final RuleSets ruleSets,            final ClassLoader classLoader, final File... files) {        // Setup a cache file with an entry for an empty Source.java with no violations        final FileAnalysisCache cache = new FileAnalysisCache(cacheFile);        cache.checkValidity(ruleSets, classLoader);                for (final File f : files) {            cache.isUpToDate(f);        }        cache.persist();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.dfa.report;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import org.junit.Test;import net.sourceforge.pmd.RuleViolation;/** * @author Philip Graf */public final class ViolationNodeTest {    /**     * Verifies that two violations nodes with equal     * {@code filename, beginLine, endLine, beginColumn, endColumn} and     * {@code variableName} are equal.     */    @Test    public void testEqualsNodeWithTwoEqualViolations() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        assertTrue("Two equal violations should result in equal nodes", node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code filename} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentFilename() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Bar.java", 1, 1, 5, 15, "");        assertFalse("Two violations with different filename should result in not equal nodes", node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code beginLine} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentBeginLine() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 2, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 2, 2, 5, 15, "");        assertFalse("Two violations with different beginLine should result in not equal nodes",                node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code endLine} are not     * equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentEndLine() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 2, 5, 15, "");        assertFalse("Two violations with different endLine should result in not equal nodes", node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code beginColumn} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentBeginColumn() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 7, 15, "");        assertFalse("Two violations with different beginColumn should result in not equal nodes",                node1.equalsNode(node2));    }    /**     * Verifies that two violations nodes with different {@code endColumn} are     * not equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentEndColumn() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 5, 17, "");        assertFalse("Two violations with different end column should result in not equal nodes",                node1.equalsNode(node2));    }    /**     * Verifies that two violations with different {@code variableName} are not     * equal.     */    @Test    public void testEqualsNodeWithTwoDifferentViolationsDifferentVariableName() {        final ViolationNode node1 = createViolationNode("Foo.java", 1, 1, 5, 15, "a");        final ViolationNode node2 = createViolationNode("Foo.java", 1, 1, 5, 15, "b");        assertFalse("Two violations with different variableName should result in not equal nodes",                node1.equalsNode(node2));    }    private ViolationNode createViolationNode(final String filename, final int beginLine, final int endLine,            final int beginColumn, final int endColumn, final String variableName) {        final RuleViolation violation = mock(RuleViolation.class);        when(violation.getFilename()).thenReturn(filename);        when(violation.getBeginLine()).thenReturn(beginLine);        when(violation.getEndLine()).thenReturn(endLine);        when(violation.getBeginColumn()).thenReturn(beginColumn);        when(violation.getEndColumn()).thenReturn(endColumn);        when(violation.getVariableName()).thenReturn(variableName);        return new ViolationNode(violation);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.symboltable;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.util.SearchFunction;public class ApplierTest {    private static class MyFunction implements SearchFunction<Object> {        private int numCallbacks = 0;        private final int maxCallbacks;        MyFunction(int maxCallbacks) {            this.maxCallbacks = maxCallbacks;        }        @Override        public boolean applyTo(Object o) {            this.numCallbacks++;            return numCallbacks < maxCallbacks;        }        public int getNumCallbacks() {            return this.numCallbacks;        }    }    @Test    public void testSimple() {        MyFunction f = new MyFunction(Integer.MAX_VALUE);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(l.size(), f.getNumCallbacks());    }    @Test    public void testLimit() {        MyFunction f = new MyFunction(2);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(2, f.getNumCallbacks());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ApplierTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.saxon;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.saxon.DocumentNode;import net.sourceforge.pmd.lang.ast.xpath.saxon.ElementNode;public class ElementNodeTest {    @Test    public void testCompareOrder() {        DummyNode node = new DummyNode(1, false, "dummy");        DummyNode foo1 = new DummyNode(2, false, "foo");        foo1.testingOnlySetBeginLine(1);        DummyNode foo2 = new DummyNode(2, false, "foo");        foo2.testingOnlySetBeginLine(2);        node.jjtAddChild(foo1, 0);        node.jjtAddChild(foo2, 1);        DocumentNode document = new DocumentNode(node);        ElementNode elementFoo1 = document.nodeToElementNode.get(foo1);        ElementNode elementFoo2 = document.nodeToElementNode.get(foo2);        Assert.assertFalse(elementFoo1.isSameNodeInfo(elementFoo2));        Assert.assertFalse(elementFoo2.isSameNodeInfo(elementFoo1));        Assert.assertTrue(elementFoo1.compareOrder(elementFoo2) < 0);        Assert.assertTrue(elementFoo2.compareOrder(elementFoo1) > 0);        Assert.assertEquals(0, elementFoo1.compareOrder(elementFoo1));    }    @Test    public void testCompareOrderSamePosition() {        DummyNode node = new DummyNode(1, false, "dummy");        DummyNode foo1 = new DummyNode(2, false, "foo");        foo1.testingOnlySetBeginLine(1);        foo1.testingOnlySetBeginColumn(1);        DummyNode foo2 = new DummyNode(2, false, "foo");        foo2.testingOnlySetBeginLine(1);        foo2.testingOnlySetBeginColumn(1);        node.jjtAddChild(foo1, 0);        node.jjtAddChild(foo2, 1);        DocumentNode document = new DocumentNode(node);        ElementNode elementFoo1 = document.nodeToElementNode.get(foo1);        ElementNode elementFoo2 = document.nodeToElementNode.get(foo2);        Assert.assertFalse(elementFoo1.isSameNodeInfo(elementFoo2));        Assert.assertFalse(elementFoo2.isSameNodeInfo(elementFoo1));        Assert.assertTrue(elementFoo1.compareOrder(elementFoo2) < 0);        Assert.assertTrue(elementFoo2.compareOrder(elementFoo1) > 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath;import java.util.Collections;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.properties.PropertyDescriptor;public class SaxonXPathRuleQueryTest {    @Test    public void testListAttribute() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        assertQuery(1, "//dummyNode[@List = \"A\"]", dummy);        assertQuery(1, "//dummyNode[@List = \"B\"]", dummy);        assertQuery(0, "//dummyNode[@List = \"C\"]", dummy);        assertQuery(1, "//dummyNode[@Enum = \"FOO\"]", dummy);        assertQuery(0, "//dummyNode[@Enum = \"BAR\"]", dummy);        assertQuery(1, "//dummyNode[@EnumList = \"FOO\"]", dummy);        assertQuery(1, "//dummyNode[@EnumList = \"BAR\"]", dummy);        assertQuery(1, "//dummyNode[@EnumList = (\"FOO\", \"BAR\")]", dummy);        assertQuery(0, "//dummyNode[@EmptyList = (\"A\")]", dummy);    }    private static void assertQuery(int resultSize, String xpath, Node node) {        SaxonXPathRuleQuery query = createQuery(xpath);        List<Node> result = query.evaluate(node, new RuleContext());        Assert.assertEquals(resultSize, result.size());    }    private static SaxonXPathRuleQuery createQuery(String xpath) {        SaxonXPathRuleQuery query = new SaxonXPathRuleQuery();        query.setVersion("2.0");        query.setProperties(Collections.<PropertyDescriptor<?>, Object>emptyMap());        query.setXPath(xpath);        return query;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath;import java.util.Collections;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.properties.PropertyDescriptor;public class JaxenXPathRuleQueryTest {    @Test    public void testListAttribute() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum(1);        assertQuery(1, "//dummyNode[@SimpleAtt = \"foo\"]", dummy);        assertQuery(1, "//dummyNode[@Enum = \"FOO\"]", dummy);        assertQuery(0, "//dummyNode[@Enum = \"BAR\"]", dummy);        // queries with lists are not supported with xpath 1.0        assertQuery(0, "//dummyNode[@List = \"[A, B]\"]", dummy);        assertQuery(0, "//dummyNode[contains(@List, \"B\")]", dummy);        assertQuery(0, "//dummyNode[@List = \"C\"]", dummy);        assertQuery(0, "//dummyNode[@EnumList = \"[FOO, BAR]\"]", dummy);        assertQuery(0, "//dummyNode[contains(@EnumList, \"BAR\")]", dummy);        assertQuery(0, "//dummyNode[@EmptyList = \"A\"]", dummy);    }    private static void assertQuery(int resultSize, String xpath, Node node) {        JaxenXPathRuleQuery query = createQuery(xpath);        RuleContext data = new RuleContext();        data.setLanguageVersion(LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion());        List<Node> result = query.evaluate(node, data);        Assert.assertEquals(resultSize, result.size());    }    private static JaxenXPathRuleQuery createQuery(String xpath) {        JaxenXPathRuleQuery query = new JaxenXPathRuleQuery();        query.setVersion("1.0");        query.setProperties(Collections.<PropertyDescriptor<?>, Object>emptyMap());        query.setXPath(xpath);        return query;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import org.junit.Assert;import org.junit.Test;public class XPathRuleTest {    /**     * It's easy to forget the attribute "typeResolution=true" when     * defining XPath rules in xml. Therefore we by default enable     * typeresolution. For Java rules, type resolution was enabled by     * default long time ago.     *      * @see <a href="https://github.com/pmd/pmd/issues/2048">#2048 [core] Enable type resolution by default for XPath rules</a>     */    @Test    public void typeResolutionShouldBeEnabledByDefault() {        XPathRule rule = new XPathRule();        Assert.assertTrue(rule.isTypeResolution());        XPathRule rule2 = new XPathRule(".");        Assert.assertTrue(rule2.isTypeResolution());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import java.util.List;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;public class DefaultRuleViolationFactoryTest {    private RuleContext ruleContext;    private RuleViolationFactory factory = DefaultRuleViolationFactory.defaultInstance();    private static class TestRule extends AbstractRule {        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {            throw new UnsupportedOperationException("not implemented");        }    }    @Before    public void setup() {        ruleContext = new RuleContext();    }    @Test    public void testMessage() {        factory.addViolation(ruleContext, new TestRule(), null, "message with \"'{'\"", null);        RuleViolation violation = ruleContext.getReport().iterator().next();        Assert.assertEquals("message with \"{\"", violation.getDescription());    }    @Test    public void testMessageArgs() {        factory.addViolation(ruleContext, new TestRule(), null, "message with 1 argument: \"{0}\"", new Object[] {"testarg1"});        RuleViolation violation = ruleContext.getReport().iterator().next();        Assert.assertEquals("message with 1 argument: \"testarg1\"", violation.getDescription());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.internal;import static junit.framework.TestCase.assertEquals;import static net.sourceforge.pmd.lang.ast.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.DummyTreeUtil.tree;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.function.Predicate;import java.util.stream.Collectors;import java.util.stream.Stream;import org.junit.Assert;import org.junit.Assume;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;/** * Asserts invariants independent of the NodeStream implementation. Error * messages are not great but coverage is. */@RunWith(Parameterized.class)public class NodeStreamBlanketTest<T extends Node> {    private static final List<Node> ASTS = Arrays.asList(        tree(            () ->                node(                    node(                        node(),                        node(                            node()                        ),                        node(),                        node()                    ),                    node()                )        ),        tree(            () ->                node(                    node(),                    node(),                    node(                        node()                    ),                    node()                )        )    );    private final NodeStream<T> stream;    public NodeStreamBlanketTest(NodeStream<T> stream) {        this.stream = stream;    }    @Test    public void testToListConsistency() {        List<T> toList = stream.toList();        List<T> collected = stream.collect(Collectors.toList());        List<T> fromStream = stream.toStream().collect(Collectors.toList());        List<T> cached = stream.cached().toList();        assertEquals(toList, collected);        assertEquals(toList, fromStream);        assertEquals(toList, cached);    }    @Test    public void testToListSize() {        List<T> toList = stream.toList();        assertEquals(toList.size(), stream.count());    }    @Test    public void testLast() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("last() == toList().last()", it -> it.last() == it.toList().get(it.count() - 1))        );    }    @Test    public void testFirst() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("first() == toList().get(0)", it -> it.first() == it.toList().get(0))        );    }    @Test    public void testDrop() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("drop(0) == this", it -> it.drop(0) == it),            prop("drop(1).count() == count() - 1", it -> it.drop(1).count() == it.count() - 1),            prop("drop(1).toList() == toList().tail()", it -> it.drop(1).toList().equals(tail(it.toList())))        );    }    @Test    public void testDropMoreThan1() {        assertImplication(            stream,            prop("count() > 1", it -> it.count() > 1),            prop("drop(2).toList() == toList().tail().tail()", it -> it.drop(2).toList().equals(tail(tail(it.toList()))))        );    }    @Test    public void testTake() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("it.take(0).count() == 0", it -> it.take(0).count() == 0),            prop("it.take(1).count() == 1", it -> it.take(1).count() == 1),            prop("it.take(it.count()).count() == it.count()", it -> it.take(it.count()).count() == it.count())        );    }    @Test    public void testEmpty() {        assertEquivalence(            stream,            prop("isEmpty", NodeStream::isEmpty),            prop("!nonEmpty", it -> !it.nonEmpty()),            prop("last() == null", it -> it.last() == null),            prop("first() == null", it -> it.first() == null),            prop("first(_ -> true) == null", it -> it.first(i -> true) == null),            prop("first(Node.class) == null", it -> it.first(Node.class) == null),            prop("count() == 0", it -> it.count() == 0),            prop("any(_) == false", it -> !it.any(i -> true)),            prop("all(_) == true", it -> it.all(i -> false)),            prop("none(_) == true", it -> it.none(i -> true))        );    }    @Parameterized.Parameters(name = "{index} On {0}")    public static Collection<?> primeNumbers() {        return ASTS.stream().flatMap(            root -> Stream.of(                root.asStream(),                root.children().first().asStream(),                NodeStream.empty()            )        ).flatMap(            // add some transformations on each of them            stream -> Stream.of(                stream,                stream.drop(1),                stream.take(2),                stream.filter(n -> !n.getImage().isEmpty()),                stream.descendants(),                stream.ancestors(),                stream.ancestorsOrSelf(),                stream.followingSiblings(),                stream.precedingSiblings(),                stream.descendantsOrSelf(),                stream.children(),                stream.children().filter(c -> c.getImage().equals("0")),                stream.children(DummyNode.class)            )        ).flatMap(            // add some transformations on each of them            stream -> Stream.of(                stream,                stream.filterIs(DummyNode.class),                stream.filter(n -> !n.getImage().isEmpty()),                stream.cached()            )        ).collect(Collectors.toCollection(ArrayList::new));    }    @SafeVarargs    private static <T> void assertEquivalence(T input, Prop<? super T>... properties) {        for (Prop<? super T> prop1 : properties) {            for (Prop<? super T> prop2 : properties) {                boolean p1 = prop1.test(input);                Assert.assertEquals(                    "Expected (" + prop1.description + ") === (" + prop2.description                        + "), but the LHS was " + p1 + " and the RHS was " + !p1,                    p1, prop2.test(input)                );            }        }    }    @SafeVarargs    private static <T> void assertImplication(T input, Prop<? super T> precond, Prop<? super T>... properties) {        Assume.assumeTrue(precond.test(input));        for (Prop<? super T> prop2 : properties) {            Assert.assertTrue(                "Expected (" + precond.description + ") to entail (" + prop2.description                    + "), but the latter was false",                prop2.test(input)            );        }    }    static <T> Prop<T> prop(String desc, Predicate<? super T> pred) {        return new Prop<>(pred, desc);    }    static <T> List<T> tail(List<T> ts) {        return ts.subList(1, ts.size());    }    static class Prop<T> {        final Predicate<? super T> property;        final String description;        Prop(Predicate<? super T> property, String description) {            this.property = property;            this.description = description;        }        boolean test(T t) {            return property.test(t);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.internal;import static net.sourceforge.pmd.lang.ast.DummyTreeUtil.followPath;import static net.sourceforge.pmd.lang.ast.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.DummyTreeUtil.pathsOf;import static net.sourceforge.pmd.lang.ast.DummyTreeUtil.tree;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.collection.IsIterableContainingInOrder.contains;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertThat;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.Optional;import org.apache.commons.lang3.mutable.MutableInt;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;/** * @author Clément Fournier */public class NodeStreamTest {    private final DummyNode tree1 = tree(        () ->            node(// ""                  node(// 0                        node(), // 00                        node(// 01                                node(), // 010                                node(), // 011                                node(), // 012                                node()  // 013                        )                  ),                  node() // 1            )    );    private final DummyNode tree2 = tree(        () ->            node(                node(),                node(),                node(                    node()                ),                node()            )    );    @Test    public void testStreamConstructionIsNullSafe() {        assertTrue(NodeStream.of((Node) null).isEmpty());        assertThat(NodeStream.of(null, null, tree1).count(), equalTo(1));        assertThat(NodeStream.fromIterable(Arrays.asList(tree1, null, null)).count(), equalTo(1));        assertThat(NodeStream.ofOptional(Optional.empty()).count(), equalTo(0));    }    @Test    public void testMapIsNullSafe() {        assertTrue(tree1.descendantsOrSelf().map(n -> null).isEmpty());    }    @Test    public void testFlatMapIsNullSafe() {        assertTrue(tree1.descendantsOrSelf().flatMap(n -> null).isEmpty());    }    @Test    public void testChildrenStream() {        assertThat(pathsOf(tree1.children()), contains("0", "1"));        assertThat(pathsOf(tree1.asStream().children()), contains("0", "1"));    }    @Test    public void testDescendantStream() {        assertThat(pathsOf(tree1.descendants()), contains("0", "00", "01", "010", "011", "012", "013", "1"));        assertThat(pathsOf(tree1.asStream().descendants()), contains("0", "00", "01", "010", "011", "012", "013", "1"));    }    @Test    public void testSingletonStream() {        assertThat(pathsOf(tree1.asStream()), contains(""));        assertThat(pathsOf(NodeStream.of(tree1)), contains(""));    }    @Test    public void testTreeStream() {        assertThat(pathsOf(tree1.descendantsOrSelf()), contains("", "0", "00", "01", "010", "011", "012", "013", "1"));        assertThat(pathsOf(NodeStream.of(tree1).descendantsOrSelf()), contains("", "0", "00", "01", "010", "011", "012", "013", "1"));    }    @Test    public void testAncestors() {        // 010        Node node = tree1.children().children().children().first();        assertEquals("010", node.getImage());        assertThat(pathsOf(node.ancestors()), contains("01", "0", ""));        assertThat(pathsOf(node.ancestorsOrSelf()), contains("010", "01", "0", ""));        assertEquals("01", node.getNthParent(1).getImage());        assertEquals("0", node.getNthParent(2).getImage());        assertEquals("", node.getNthParent(3).getImage());        assertNull(node.getNthParent(4));    }    @Test    public void testFollowingSiblings() {        assertThat(pathsOf(followPath(tree2, "2").asStream().followingSiblings()), contains("3"));        assertThat(pathsOf(followPath(tree2, "0").asStream().followingSiblings()), contains("1", "2", "3"));        assertTrue(pathsOf(followPath(tree2, "3").asStream().followingSiblings()).isEmpty());    }    @Test    public void testPrecedingSiblings() {        assertThat(pathsOf(followPath(tree2, "2").asStream().precedingSiblings()), contains("0", "1"));        assertThat(pathsOf(followPath(tree2, "3").asStream().precedingSiblings()), contains("0", "1", "2"));        assertTrue(pathsOf(followPath(tree2, "0").asStream().precedingSiblings()).isEmpty());    }    @Test    public void testRootSiblings() {        assertTrue(tree2.asStream().precedingSiblings().isEmpty());        assertTrue(tree2.asStream().followingSiblings().isEmpty());    }    @Test    public void testAncestorStream() {        assertThat(pathsOf(followPath(tree1, "01").ancestors()), contains("0", ""));        assertThat(pathsOf(followPath(tree1, "01").asStream().ancestors()), contains("0", ""));    }    @Test    public void testParentStream() {        assertThat(pathsOf(followPath(tree1, "01").asStream().parents()), contains("0"));    }    @Test    public void testAncestorStreamUnion() {        assertThat(pathsOf(NodeStream.union(followPath(tree1, "01").ancestors(),                                            tree2.children().ancestors())), contains("0", "", "", "", "", ""));    }    @Test    public void testDistinct() {        assertThat(pathsOf(NodeStream.union(followPath(tree1, "01").ancestors(),                                            tree2.children().ancestors()).distinct()), contains("0", "", "")); // roots of both trees    }    @Test    public void testGet() {        // ("0", "00", "01", "010", "011", "012", "013", "1")        NodeStream<Node> stream = tree1.descendants();        assertEquals("0", stream.get(0).getImage());        assertEquals("00", stream.get(1).getImage());        assertEquals("010", stream.get(3).getImage());        assertEquals("011", stream.get(4).getImage());        assertNull(stream.get(8));    }    @Test    public void testNodeStreamsCanBeIteratedSeveralTimes() {        NodeStream<Node> stream = tree1.descendants();        assertThat(stream.count(), equalTo(8));        assertThat(stream.count(), equalTo(8));        assertThat(pathsOf(stream), contains("0", "00", "01", "010", "011", "012", "013", "1"));        assertThat(pathsOf(stream.filter(n -> n.jjtGetNumChildren() == 0)),                   contains("00", "010", "011", "012", "013", "1"));    }    @Test    public void testNodeStreamPipelineIsLazy() {        MutableInt numEvals = new MutableInt();        tree1.descendants().filter(n -> {            numEvals.increment();            return true;        });        assertThat(numEvals.getValue(), equalTo(0));    }    @Test    public void testForkJoinUpstreamPipelineIsExecutedAtMostOnce() {        MutableInt numEvals = new MutableInt();        NodeStream<Node> stream =            hook(numEvals::increment, tree1.descendants())                .forkJoin(                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo("0")),                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo("1"))                );        assertThat(numEvals.getValue(), equalTo(0)); // not evaluated yet        assertThat(stream.count(), equalTo(2));        assertThat(numEvals.getValue(), equalTo(8)); // evaluated *once* every element of the upper stream        assertThat(stream.count(), equalTo(2));        assertThat(numEvals.getValue(), equalTo(8)); // not reevaluated    }    @Test    public void testCachedStreamUpstreamPipelineIsExecutedAtMostOnce() {        MutableInt upstreamEvals = new MutableInt();        MutableInt downstreamEvals = new MutableInt();        NodeStream<Node> stream =            tree1.descendants()                 .filter(n -> n.getImage().matches("0.*"))                 .take(4)                 .peek(n -> upstreamEvals.increment())                 .cached()                 .filter(n -> true)                 .peek(n -> downstreamEvals.increment());        assertThat(upstreamEvals.getValue(), equalTo(0));   // not evaluated yet        assertThat(stream.count(), equalTo(4));        assertThat(upstreamEvals.getValue(), equalTo(4));   // evaluated once        assertThat(downstreamEvals.getValue(), equalTo(4)); // evaluated once        assertThat(stream.count(), equalTo(4));        assertThat(upstreamEvals.getValue(), equalTo(4));   // upstream was not reevaluated        assertThat(downstreamEvals.getValue(), equalTo(8)); // downstream has been reevaluated    }    @Test    public void testUnionIsLazy() {        MutableInt tree1Evals = new MutableInt();        MutableInt tree2Evals = new MutableInt();        NodeStream<Node> unionStream = NodeStream.union(tree1.descendantsOrSelf().peek(n -> tree1Evals.increment()),                                                        tree2.descendantsOrSelf().peek(n -> tree2Evals.increment()));        assertThat(tree1Evals.getValue(), equalTo(0));   // not evaluated yet        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated yet        assertSame(unionStream.first(), tree1);        assertThat(tree1Evals.getValue(), equalTo(1));   // evaluated once        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated    }    @Test    public void testSomeOperationsAreLazy() {        MutableInt tree1Evals = new MutableInt();        NodeStream<Node> unionStream = tree1.descendantsOrSelf().peek(n -> tree1Evals.increment());        int i = 0;        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated yet        unionStream.first();        assertThat(tree1Evals.getValue(), equalTo(++i));    // evaluated once        unionStream.nonEmpty();        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation        unionStream.isEmpty();        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation        // those don't trigger any evaluation        unionStream.map(p -> p);        unionStream.filter(p -> true);        unionStream.append(tree2.descendantsOrSelf());        unionStream.prepend(tree2.descendantsOrSelf());        unionStream.flatMap(Node::descendantsOrSelf);        unionStream.iterator();        unionStream.cached();        unionStream.descendants();        unionStream.ancestors();        unionStream.followingSiblings();        unionStream.precedingSiblings();        unionStream.children();        unionStream.distinct();        unionStream.take(4);        unionStream.drop(4);        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated    }    @Test    public void testFollowingSiblingsNonEmpty() {        DummyNode node = followPath(tree1, "012");        NodeStream<Node> nodes = node.asStream().followingSiblings();        assertTrue(nodes instanceof SingletonNodeStream);        assertEquals("013", nodes.first().getImage());    }    @Test    public void testPrecedingSiblingsNonEmpty() {        DummyNode node = followPath(tree1, "011");        NodeStream<Node> nodes = node.asStream().precedingSiblings();        assertTrue(nodes instanceof SingletonNodeStream);        assertEquals("010", nodes.first().getImage());    }    @Test    public void testPrecedingSiblingsDrop() {        DummyNode node = followPath(tree1, "012");        NodeStream<Node> nodes = node.asStream().precedingSiblings().drop(1);        assertThat(pathsOf(nodes), contains("011"));    }    @Test    public void testFollowingSiblingsDrop() {        DummyNode node = followPath(tree1, "011");        NodeStream<Node> nodes = node.asStream().followingSiblings().drop(1);        assertThat(pathsOf(nodes), contains("013"));    }    private static <T extends Node> NodeStream<T> hook(Runnable hook, NodeStream<T> stream) {        return stream.filter(t -> {            hook.run();            return true;        });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.xpath;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import java.util.stream.Collectors;import org.junit.Test;import net.sourceforge.pmd.internal.util.IteratorUtil;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.xpath.NoAttribute.NoAttrScope;/** * @author Clément Fournier */public class NoAttributeTest {    @Test    public void testNoAttrInherited() {        Node child = new NodeNoInherited(12);        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        assertTrue(attrNames.contains("SomeInt"));        assertTrue(attrNames.contains("Child"));        // from Node        assertTrue(attrNames.contains("BeginLine"));        assertFalse(attrNames.contains("SomeLong"));        assertFalse(attrNames.contains("Image"));        assertFalse(attrNames.contains("SomeName"));    }    @Test    public void testNoAttrAll() {        assertTrue(0 < IteratorUtil.count(new NodeAllAttr(12).getXPathAttributesIterator()));        NodeNoAttrAll child = new NodeNoAttrAll(12);        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        // from Noded, so not suppressed        assertTrue(attrNames.contains("Image"));        assertFalse(attrNames.contains("MySuppressedAttr"));    }    @Test    public void testNoAttrAllIsNotInherited() {        NodeNoAttrAllChild child = new NodeNoAttrAllChild(12);        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        // suppressed because the parent has NoAttribute(scope = ALL)        assertFalse(attrNames.contains("MySuppressedAttr"));        // not suppressed because defined in the class, which has no annotation        assertTrue(attrNames.contains("NotSuppressedAttr"));    }    private static class DummyNodeParent extends DummyNode {        DummyNodeParent(int id) {            super(id);        }        DummyNodeParent(int id, boolean findBoundary) {            super(id, findBoundary);        }        public String getSomeName() {            return "Foo";        }        public int getSomeInt() {            return 42;        }        public long getSomeLong() {            return 42;        }        public long getSomeLong2() {            return 42;        }    }    @NoAttribute(scope = NoAttrScope.INHERITED)    private static class NodeNoInherited extends DummyNodeParent {        NodeNoInherited(int id) {            super(id);        }        // getSomeName is inherited and filtered out by NoAttrScope.INHERITED        // getSomeInt is inherited but overridden here, so NoAttrScope.INHERITED has no effect        // getSomeLong is inherited and overridden here,        //      and even with scope INHERITED its @NoAttribute takes precedence        // isChild overrides nothing so with INHERITED it's not filtered out        @Override        public int getSomeInt() {            return 43;        }        @NoAttribute // Notice        @Override        public long getSomeLong() {            return 43;        }        @NoAttribute(scope = NoAttrScope.INHERITED)        @Override        public String getImage() {            return super.getImage();        }        public boolean isChild() {            return true;        }    }    private static class NodeAllAttr extends DummyNodeParent {        NodeAllAttr(int id) {            super(id);        }    }    @NoAttribute(scope = NoAttrScope.ALL)    private static class NodeNoAttrAll extends DummyNodeParent {        NodeNoAttrAll(int id) {            super(id);        }        public int getMySuppressedAttr() {            return 12;        }    }    private static class NodeNoAttrAllChild extends NodeNoAttrAll {        NodeNoAttrAllChild(int id) {            super(id);        }        public int getNotSuppressedAttr() {            return 12;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.xpath;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.hamcrest.collection.IsMapContaining;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNodeWithDeprecatedAttribute;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for {@link AttributeAxisIterator} */public class AttributeAxisIteratorTest {    @Test    public void testAttributeDeprecation() {        Node dummy = new DummyNodeWithDeprecatedAttribute(2);        assertThat(toMap(new AttributeAxisIterator(dummy)), IsMapContaining.hasKey("Size"));    }    /**     * Test hasNext and next.     */    @Test    public void testAttributeAxisIterator() {        DummyNode dummyNode = new DummyNode(1);        dummyNode.testingOnlySetBeginLine(1);        dummyNode.testingOnlySetBeginColumn(1);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Map<String, Attribute> atts = toMap(it);        Assert.assertEquals(7, atts.size());        assertTrue(atts.containsKey("BeginColumn"));        assertTrue(atts.containsKey("BeginLine"));        assertTrue(atts.containsKey("FindBoundary"));        assertTrue(atts.containsKey("Image"));        assertTrue(atts.containsKey("SingleLine"));        assertTrue(atts.containsKey("EndColumn"));        assertTrue(atts.containsKey("EndLine"));    }    @Test    public void testAttributeAxisIteratorWithEnum() {        DummyNodeWithEnum dummyNode = new DummyNodeWithEnum(1);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Map<String, Attribute> atts = toMap(it);        Assert.assertEquals(8, atts.size());        assertTrue(atts.containsKey("Enum"));        assertEquals(DummyNodeWithEnum.MyEnum.FOO, atts.get("Enum").getValue());    }    @Test    public void testAttributeAxisIteratorWithList() {        DummyNodeWithList dummyNode = new DummyNodeWithList(1);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Map<String, Attribute> atts = toMap(it);        Assert.assertEquals(8, atts.size());        assertTrue(atts.containsKey("List"));        assertEquals(Arrays.asList("A", "B"), atts.get("List").getValue());        assertFalse(atts.containsKey("NodeList"));    }    private Map<String, Attribute> toMap(AttributeAxisIterator it) {        Map<String, Attribute> atts = new HashMap<>();        while (it.hasNext()) {            Attribute attribute = it.next();            atts.put(attribute.getName(), attribute);        }        return atts;    }    public static class DummyNodeWithEnum extends DummyNode {        public DummyNodeWithEnum(int id) {            super(id);        }        public enum MyEnum {            FOO, BAR        }        public MyEnum getEnum() {            return MyEnum.FOO;        }    }    public static class DummyNodeWithList extends DummyNode {        public DummyNodeWithList(int id) {            super(id);        }        public List<String> getList() {            return Arrays.asList("A", "B");        }        public List<Node> getNodeList() {            return Collections.emptyList();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.xpath;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.fail;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;/** * Unit test for {@link DocumentNavigator} */public class DocumentNavigatorTest {    @Test    public void getDocumentNode() {        DocumentNavigator nav = new DocumentNavigator();        try {            nav.getDocumentNode(null);            fail();        } catch (RuntimeException e) {            assertNotNull(e);        }        Node root = new DummyRoot();        Node n = new DummyNode(1);        root.jjtAddChild(n, 0);        n.jjtSetParent(root);        assertSame(root, nav.getDocumentNode(n));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.junit.Before;import org.junit.Test;/** * Unit test for {@link AbstractNode} tree transversal methods */public class AbstractNodeTransversalTest {    private int id;    private Node rootNode;    private int nextId() {        return id++;    }    private Node newDummyNode(boolean boundary) {        return new DummyNode(nextId(), boundary);    }    private Node addChild(final Node parent, final Node child) {        parent.jjtAddChild(child, parent.jjtGetNumChildren()); // Append child at the end        child.jjtSetParent(parent);        return parent;    }    @Before    public void setUpSampleNodeTree() {        id = 0;        rootNode = newDummyNode(false);    }    @Test    public void testBoundaryIsHonored() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));                List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class);        assertEquals(1, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());    }        @Test    public void testSearchFromBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));                List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class).get(0).findDescendantsOfType(DummyNode.class);        assertEquals(1, descendantsOfType.size());        assertFalse(descendantsOfType.get(0).isFindBoundary());    }        @Test    public void testSearchIgnoringBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));                List<DummyNode> descendantsOfType = new ArrayList<>();        rootNode.findDescendantsOfType(DummyNode.class, descendantsOfType, true);        assertEquals(2, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());        assertFalse(descendantsOfType.get(1).isFindBoundary());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;/** * Unit test for {@link SourceCodePositioner}. */public class SourceCodePositionerTest {    private static final String SOURCE_CODE = "abcd\ndefghi\n\njklmn\nopq";    /**     * Tests whether the lines and columns are calculated correctly.     */    @Test    public void testLineNumberFromOffset() {        SourceCodePositioner positioner = new SourceCodePositioner(SOURCE_CODE);        int offset;        offset = SOURCE_CODE.indexOf('a');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(1, positioner.columnFromOffset(1, offset));        offset = SOURCE_CODE.indexOf('b');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(1, offset));        offset = SOURCE_CODE.indexOf('e');        assertEquals(2, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(2, offset));        offset = SOURCE_CODE.indexOf('q');        assertEquals(5, positioner.lineNumberFromOffset(offset));        assertEquals(3, positioner.columnFromOffset(5, offset));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import org.jaxen.JaxenException;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.runner.RunWith;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import junitparams.JUnitParamsRunner;import junitparams.Parameters;/** * Unit test for {@link AbstractNode}. */@RunWith(JUnitParamsRunner.class)public class AbstractNodeTest {    private static final int NUM_CHILDREN = 3;    private static final int NUM_GRAND_CHILDREN = 3;    @Rule    public JavaUtilLoggingRule loggingRule = new JavaUtilLoggingRule(Attribute.class.getName());    // Note that in order to successfully run JUnitParams, we need to explicitly use `Integer` instead of `int`    private Integer[] childrenIndexes() {        return getIntRange(NUM_CHILDREN);    }    private Integer[] grandChildrenIndexes() {        return getIntRange(NUM_GRAND_CHILDREN);    }    private static Integer[] getIntRange(final int exclusiveLimit) {        final Integer[] childIndexes = new Integer[exclusiveLimit];        for (int i = 0; i < exclusiveLimit; i++) {            childIndexes[i] = i;        }        return childIndexes;    }    public Object childrenAndGrandChildrenIndexes() {        final Integer[] childrenIndexes = childrenIndexes();        final Integer[] grandChildrenIndexes = grandChildrenIndexes();        final Object[] indexes = new Object[childrenIndexes.length * grandChildrenIndexes.length];        int i = 0;        for (final int childIndex : childrenIndexes) {            for (final int grandChildIndex : grandChildrenIndexes) {                indexes[i++] = new Integer[] { childIndex, grandChildIndex };            }        }        return indexes;    }    private int id;    private Node rootNode;    private int nextId() {        return id++;    }    private Node newDummyNode() {        return new DummyNode(nextId());    }    private static Node addChild(final Node parent, final Node child) {        parent.jjtAddChild(child, parent.jjtGetNumChildren()); // Append child at the end        child.jjtSetParent(parent);        return parent;    }    @Before    public void setUpSampleNodeTree() {        id = 0;        rootNode = newDummyNode();        for (int i = 0; i < NUM_CHILDREN; i++) {            final Node child = newDummyNode();            for (int j = 0; j < NUM_GRAND_CHILDREN; j++) {                final Node grandChild = newDummyNode();                addChild(child, grandChild);            }            addChild(rootNode, child);        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method     */    @Test    @Parameters(method = "childrenIndexes")    public void testRemoveChildOfRootNode(final int childIndex) {        final Node child = rootNode.jjtGetChild(childIndex);        final Node[] grandChildren = new Node[child.jjtGetNumChildren()];        for (int i = 0; i < grandChildren.length; i++) {            final Node grandChild = child.jjtGetChild(i);            grandChildren[i] = grandChild;        }        // Do the actual removal        child.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.jjtGetNumChildren());        assertNull(child.jjtGetParent());        // The child node is expected to still have all its children and vice versa        assertEquals(NUM_GRAND_CHILDREN, child.jjtGetNumChildren());        for (final Node grandChild : grandChildren) {            assertEquals(child, grandChild.jjtGetParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * This is a border case as the root node does not have any parent.     */    @Test    public void testRemoveRootNode() {        // Check that the root node has the expected properties        final Node[] children = new Node[rootNode.jjtGetNumChildren()];        for (int i = 0; i < children.length; i++) {            final Node child = rootNode.jjtGetChild(i);            children[i] = child;        }        // Do the actual removal        rootNode.remove();        // Check that conditions have been successfully changed, i.e.,        //  the root node is expected to still have all its children and vice versa        assertEquals(NUM_CHILDREN, rootNode.jjtGetNumChildren());        assertNull(rootNode.jjtGetParent());        for (final Node aChild : children) {            assertEquals(rootNode, aChild.jjtGetParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * These are border cases as grandchildren nodes do not have any child.     */    @Test    @Parameters(method = "childrenAndGrandChildrenIndexes")    public void testRemoveGrandChildNode(final int childIndex, final int grandChildIndex) {        final Node child = rootNode.jjtGetChild(childIndex);        final Node grandChild = child.jjtGetChild(grandChildIndex);        // Do the actual removal        grandChild.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_GRAND_CHILDREN - 1, child.jjtGetNumChildren());        assertEquals(0, grandChild.jjtGetNumChildren());        assertNull(grandChild.jjtGetParent());    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     */    @Test    @Parameters(method = "childrenIndexes")    public void testRemoveRootNodeChildAtIndex(final int childIndex) {        final Node[] originalChildren = new Node[rootNode.jjtGetNumChildren()];        for (int i = 0; i < originalChildren.length; i++) {            originalChildren[i] = rootNode.jjtGetChild(i);        }        // Do the actual removal        rootNode.removeChildAtIndex(childIndex);        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.jjtGetNumChildren());        int j = 0;        for (int i = 0; i < rootNode.jjtGetNumChildren(); i++) {            if (j == childIndex) { // Skip the removed child                j++;            }            // Check that the nodes have been rightly shifted            assertEquals(originalChildren[j], rootNode.jjtGetChild(i));            // Check that the child index has been updated            assertEquals(i, rootNode.jjtGetChild(i).jjtGetChildIndex());            j++;        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * Test that invalid indexes cases are handled without exception.     */    @Test    public void testRemoveChildAtIndexWithInvalidIndex() {        try {            rootNode.removeChildAtIndex(-1);            rootNode.removeChildAtIndex(rootNode.jjtGetNumChildren());        } catch (final Exception e) {            fail("No exception was expected.");        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * This is a border case as the method invocation should do nothing.     */    @Test    @Parameters(method = "grandChildrenIndexes")    public void testRemoveChildAtIndexOnNodeWithNoChildren(final int grandChildIndex) {        // grandChild does not have any child        final Node grandChild = rootNode.jjtGetChild(grandChildIndex).jjtGetChild(grandChildIndex);        // Do the actual removal        grandChild.removeChildAtIndex(0);        // If here, no exception has been thrown        // Check that this node still does not have any children        assertEquals(0, grandChild.jjtGetNumChildren());    }    @Test    public void testDeprecatedAttributeXPathQuery() throws JaxenException {        class MyRootNode extends DummyNode implements RootNode {            private MyRootNode(int id) {                super(id);            }        }        addChild(new MyRootNode(nextId()), new DummyNodeWithDeprecatedAttribute(2)).findChildNodesWithXPath("//dummyNode[@Size=1]");        String log = loggingRule.getLog();        assertTrue(log.contains("deprecated"));        assertTrue(log.contains("attribute"));        assertTrue(log.contains("dummyNode/@Size"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;public class LanguageRegistryTest {    @Test    public void getDefaultLanguageTest() {        Language defaultLanguage = LanguageRegistry.getDefaultLanguage();        Assert.assertNotNull(defaultLanguage);        // as we don't have java language in this test, we get the first        // available language now -> DummyLanguage        Assert.assertSame(DummyLanguageModule.class, defaultLanguage.getClass());    }    @Test    public void getDefaultVersionLanguageTest() {        Language dummy = LanguageRegistry.findLanguageByTerseName("dummy");        LanguageVersion dummy12 = dummy.getVersion("1.2");        Assert.assertNotNull(dummy12);        LanguageVersion dummyDefault = dummy.getDefaultVersion();        Assert.assertNotNull(dummyDefault);        Assert.assertNotSame(dummy12, dummyDefault);    }    @Test    public void getLanguageVersionByAliasTest() {        Language dummy = LanguageRegistry.findLanguageByTerseName("dummy");        LanguageVersion dummy17 = dummy.getVersion("1.7");        Assert.assertNotNull(dummy17);        Assert.assertEquals("1.7", dummy17.getVersion());        LanguageVersion dummy7 = dummy.getVersion("7");        Assert.assertNotNull(dummy7);        Assert.assertEquals("1.7", dummy17.getVersion());        Assert.assertSame(dummy17, dummy7);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;public class BaseLanguageModuleTest {    @Test    public void testHashCodeEquals() {        Language l1 = new DummyLanguageModule();        Language l1a = new DummyLanguageModule();        Language l2 = new Dummy2LanguageModule();        Assert.assertEquals(l1.hashCode(), l1a.hashCode());        Assert.assertNotEquals(l1.hashCode(), l2.hashCode());        Assert.assertEquals(l1, l1a);        Assert.assertNotEquals(l1, l2);    }    @Test    public void testCompareTo() {        Language l1 = new DummyLanguageModule();        Language l2 = new Dummy2LanguageModule();        Assert.assertTrue(l1.compareTo(l2) < 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties.constraints;import org.junit.Assert;import org.junit.Test;public class NumericConstraintsTest {    @Test    public void testInRangeInteger() {        PropertyConstraint<Integer> constraint = NumericConstraints.inRange(1, 10);        Assert.assertTrue(constraint.test(1));        Assert.assertTrue(constraint.test(5));        Assert.assertTrue(constraint.test(10));        Assert.assertFalse(constraint.test(0));        Assert.assertFalse(constraint.test(-1));        Assert.assertFalse(constraint.test(11));        Assert.assertFalse(constraint.test(100));    }    @Test    public void testInRangeDouble() {        PropertyConstraint<Double> constraint = NumericConstraints.inRange(1.0, 10.0);        Assert.assertTrue(constraint.test(1.0));        Assert.assertTrue(constraint.test(5.5));        Assert.assertTrue(constraint.test(10.0));        Assert.assertFalse(constraint.test(0.0));        Assert.assertFalse(constraint.test(-1.0));        Assert.assertFalse(constraint.test(11.1));        Assert.assertFalse(constraint.test(100.0));    }    @Test    public void testPositive() {        PropertyConstraint<Number> constraint = NumericConstraints.positive();        Assert.assertTrue(constraint.test(1));        Assert.assertTrue(constraint.test(1.5f));        Assert.assertTrue(constraint.test(1.5d));        Assert.assertTrue(constraint.test(100));        Assert.assertFalse(constraint.test(0));        Assert.assertFalse(constraint.test(0.1f));        Assert.assertFalse(constraint.test(0.9d));        Assert.assertFalse(constraint.test(-1));        Assert.assertFalse(constraint.test(-100));        Assert.assertFalse(constraint.test(-0.1f));        Assert.assertFalse(constraint.test(-0.1d));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import java.util.regex.Pattern;/** * Since there's no RegexMultiProperty the base class is only partially implemented, * and some tests are overridden with no-op ones. * * @author Clément Fournier * @since 6.2.0 */@Deprecatedpublic class RegexPropertyTest extends AbstractPropertyDescriptorTester<Pattern> {    public RegexPropertyTest() {        super("Regex");    }    @Override    protected Pattern createValue() {        return Pattern.compile("abc++");    }    @Override    protected Pattern createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Pattern> createProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa)+").desc("the description").build();    }    @Override    protected PropertyDescriptor<Pattern> createBadProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa").desc("the description").build();    }    // The following are deliberately unimplemented, since they are only relevant to the tests of the multiproperty    @Override    protected PropertyDescriptor<List<Pattern>> createMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    protected PropertyDescriptor<List<Pattern>> createBadMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    public void testAddAttributesMulti() {    }    @Override    public void testAsDelimitedString() {    }    @Override    public void testErrorForBadMulti() {    }    @Override    public void testErrorForCorrectMulti() {    }    @Override    public void testFactoryMultiValueDefaultDelimiter() {    }    @Override    public void testFactoryMultiValueCustomDelimiter() {    }    @Override    public void testTypeMulti() {    }    @Override    public void testIsMultiValueMulti() {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Observer;import java.util.Set;/** * Evaluates the functionality of the TypeProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid Type values per * the allowable packages, and serialize/deserialize groups of types onto/from a * string buffer. * * We're using java.lang classes for 'normal' constructors and applying * java.util types as ones we expect to fail. * * @author Brian Remedios */public class TypePropertyTest extends AbstractPackagedPropertyDescriptorTester<Class> {    private static final List<Class> JAVA_LANG_CLASSES = Arrays.<Class>asList(String.class, Integer.class, Thread.class,                                                                              Object.class, Runtime.class);    private static final List<Class> JAVA_UTIL_CLASSES = Arrays.<Class>asList(HashMap.class, Map.class,                                                                              Comparator.class, Set.class,                                                                              Observer.class);    public TypePropertyTest() {        super("Class");    }    @Override    protected Class createBadValue() {        return JAVA_UTIL_CLASSES.get(randomInt(0, JAVA_UTIL_CLASSES.size()));    }    @Override    protected PropertyDescriptor<Class> createProperty() {        return new TypeProperty("testType", "Test type property", createValue(), new String[] {"java.lang"},                                1.0f);    }    @Override    protected Class createValue() {        return JAVA_LANG_CLASSES.get(randomInt(0, JAVA_LANG_CLASSES.size()));    }    @Override    protected PropertyDescriptor<List<Class>> createMultiProperty() {        return new TypeMultiProperty("testType", "Test type property", JAVA_LANG_CLASSES, new String[] {"java.lang"},                                     1.0f);    }    @Override    protected PropertyDescriptor<Class> createBadProperty() {        return new TypeProperty("testType", "Test type property", createValue(), new String[] {"java.util"},                                1.0f);    }    @Override    protected PropertyDescriptor<List<Class>> createBadMultiProperty() {        return new TypeMultiProperty("testType", "Test type property", Collections.<Class>singletonList(Set.class),                                     new String[] {"java.lang"}, 1.0f);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assume;import org.junit.Test;import net.sourceforge.pmd.properties.modules.MethodPropertyModule;import net.sourceforge.pmd.util.ClassUtil;/** * Evaluates the functionality of the MethodProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid methods per the * allowable packages, and serialize/deserialize groups of methods onto/from a * string buffer. * * We're using methods from java.lang classes for 'normal' constructors and * applying ones from java.util types as ones we expect to fail. * * @author Brian Remedios */public class MethodPropertyTest extends AbstractPackagedPropertyDescriptorTester<Method> {    private static final Method[] ALL_METHODS;    private static final String[] METHOD_SIGNATURES = {"String#indexOf(int)", "String#substring(int,int)",                                                       "java.lang.String#substring(int,int)", "Integer#parseInt(String)", "java.util.HashMap#put(Object,Object)",                                                       "HashMap#containsKey(Object)", };    static {        List<Method> allMethods = new ArrayList<>();        for (Method m : String.class.getDeclaredMethods()) {            // exclude String.resolveConstantDesc to avoid random test failure with java12            // there are two methods with the same signature available, but different return types...            if (!m.getName().equals("resolveConstantDesc")) {                allMethods.add(m);            }        }        ALL_METHODS = allMethods.toArray(new Method[0]);    }    public MethodPropertyTest() {        super("Method");    }    @Override    @Test    public void testMissingPackageNames() {        Map<PropertyDescriptorField, String> attributes = getPropertyDescriptorValues();        attributes.remove(PropertyDescriptorField.LEGAL_PACKAGES);        new MethodProperty("p", "d", ALL_METHODS[1], null, 1.0f); // no exception, null is ok        new MethodMultiProperty("p", "d", new Method[]{ALL_METHODS[2], ALL_METHODS[3]}, null, 1.0f); // no exception, null is ok    }    @Test    public void testAsStringOn() {        Method method;        for (String methodSignature : METHOD_SIGNATURES) {            method = ValueParserConstants.METHOD_PARSER.valueOf(methodSignature);            assertNotNull("Unable to identify method: " + methodSignature, method);        }    }    @Test    public void testAsMethodOn() {        Method[] methods = new Method[METHOD_SIGNATURES.length];        for (int i = 0; i < METHOD_SIGNATURES.length; i++) {            methods[i] = ValueParserConstants.METHOD_PARSER.valueOf(METHOD_SIGNATURES[i]);            assertNotNull("Unable to identify method: " + METHOD_SIGNATURES[i], methods[i]);        }        String translatedMethod;        for (int i = 0; i < methods.length; i++) {            translatedMethod = MethodPropertyModule.asString(methods[i]);            assertTrue("Translated method does not match", ClassUtil.withoutPackageName(METHOD_SIGNATURES[i])                                                                    .equals(ClassUtil.withoutPackageName(translatedMethod)));        }    }    @Override    protected Method createValue() {        return randomChoice(ALL_METHODS);    }    @Override    protected Method createBadValue() {        return randomChoice(HashMap.class.getDeclaredMethods());    }    @Override    protected PropertyDescriptor<Method> createProperty() {        return new MethodProperty("methodProperty", "asdf", ALL_METHODS[1], new String[]{"java.lang", "org.apache"},            1.0f);    }    @Override    protected PropertyDescriptor<List<Method>> createMultiProperty() {        return new MethodMultiProperty("methodProperty", "asdf", new Method[]{ALL_METHODS[2], ALL_METHODS[3]},            new String[]{"java.lang"}, 1.0f);    }    @Override    protected PropertyDescriptor<Method> createBadProperty() {        return new MethodProperty("methodProperty", "asdf", ALL_METHODS[1], new String[]{"java.util"}, 1.0f);    }    @Override    protected PropertyDescriptor<List<Method>> createBadMultiProperty() {        return new MethodMultiProperty("methodProperty", "asdf", new Method[]{ALL_METHODS[2], ALL_METHODS[3]},            new String[]{"java.util"}, 1.0f);    }    @Override    @Test    public void testFactorySingleValue() {        Assume.assumeTrue("MethodProperty cannot be built from XPath (#762)", false);    }    @Override    @Test    public void testFactoryMultiValueCustomDelimiter() {        Assume.assumeTrue("MethodProperty cannot be built from XPath (#762)", false);    }    @Override    @Test    public void testFactoryMultiValueDefaultDelimiter() {        Assume.assumeTrue("MethodProperty cannot be built from XPath (#762)", false);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.Test;/** * @author Brian Remedios */public class BooleanPropertyTest extends AbstractPropertyDescriptorTester<Boolean> {    public BooleanPropertyTest() {        super("Boolean");    }    @Override    protected Boolean createValue() {        return randomBool();    }    @Override    @Test    public void testErrorForBadSingle() {        // override, cannot create a 'bad' boolean per se    }    @Override    @Test    public void testErrorForBadMulti() {        // override, cannot create a 'bad' boolean per se    }    @Override    protected Boolean createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Boolean> createProperty() {        return new BooleanProperty("testBoolean", "Test boolean property", false, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createMultiProperty() {        return new BooleanMultiProperty("testBoolean", "Test boolean property",                                        new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createBadMultiProperty() {        return new BooleanMultiProperty("", "Test boolean property", new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<Boolean> createBadProperty() {        return new BooleanProperty("testBoolean", "", false, 1.0f);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the StringProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid strings per any * specified expressions, and serialize/deserialize groups of strings onto/from * a string buffer. * * @author Brian Remedios */public class StringPropertyTest extends AbstractPropertyDescriptorTester<String> {    private static final int MAX_STRING_LENGTH = 52;    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    public StringPropertyTest() {        super("String");    }    @Override    protected String createValue() {        return newString();    }    /**     * Method newString.     *     * @return String     */    private String newString() {        int strLength = randomInt(1, MAX_STRING_LENGTH);        char[] chars = new char[strLength];        for (int i = 0; i < chars.length; i++) {            chars[i] = randomCharIn(CHARSET);        }        return new String(chars);    }    /**     * Method randomCharIn.     *     * @param chars char[]     *     * @return char     */    private char randomCharIn(char[] chars) {        return randomChar(chars);    }    @Override    protected String createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<String> createProperty() {        return new StringProperty("testString", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world"}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<String> createBadProperty() {        return new StringProperty("", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createBadMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world", "a" + DELIMITER + "b"}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static org.hamcrest.Matchers.allOf;import static org.hamcrest.Matchers.hasItem;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertThat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;import org.apache.commons.lang3.StringUtils;import org.hamcrest.Matcher;import org.hamcrest.Matchers;import org.hamcrest.core.SubstringMatcher;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.properties.constraints.PropertyConstraint;/** * Mostly TODO, I'd rather implement tests on the final version of the framework. * * @author Clément Fournier * @since 7.0.0 */public class PropertyDescriptorTest {    @org.junit.Rule    public ExpectedException thrown = ExpectedException.none();    @Test    public void testConstraintViolationCausesDysfunctionalRule() {        PropertyDescriptor<Integer> intProperty = PropertyFactory.intProperty("fooProp")                                                                 .desc("hello")                                                                 .defaultValue(4)                                                                 .require(inRange(1, 10))                                                                 .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(intProperty);        rule.setProperty(intProperty, 1000);        RuleSet ruleSet = new RuleSetFactory().createSingleRuleRuleSet(rule);        List<Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    public void testConstraintViolationCausesDysfunctionalRuleMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(descriptor);        rule.setProperty(descriptor, Collections.singletonList(1000d)); // not in range        RuleSet ruleSet = new RuleSetFactory().createSingleRuleRuleSet(rule);        List<Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    public void testDefaultValueConstraintViolationCausesFailure() {        PropertyConstraint<Integer> constraint = inRange(1, 10);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                                   containsIgnoreCase(constraint.getConstraintDescription())));        PropertyFactory.intProperty("fooProp")                       .desc("hello")                       .defaultValue(1000)                       .require(constraint)                       .build();    }    @Test    public void testDefaultValueConstraintViolationCausesFailureMulti() {        PropertyConstraint<Double> constraint = inRange(1d, 10d);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                                   containsIgnoreCase(constraint.getConstraintDescription())));        PropertyFactory.doubleListProperty("fooProp")                       .desc("hello")                       .defaultValues(2., 11.) // 11. is out of range                       .requireEach(constraint)                       .build();    }    @Test    public void testNoConstraintViolationCausesIsOkMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertThat(descriptor.defaultValue(), Matchers.contains(2., 11.));    }    @Test    public void testNoConstraintViolationCausesIsOk() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValue("bazooli")                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("bazooli", descriptor.defaultValue());    }    @Test    public void testIntProperty() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        assertEquals("intProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Integer.valueOf(1), descriptor.defaultValue());        assertEquals(Integer.valueOf(5), descriptor.valueFrom("5"));        PropertyDescriptor<List<Integer>> listDescriptor = PropertyFactory.intListProperty("intListProp")                .desc("hello")                .defaultValues(1, 2)                .build();        assertEquals("intListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1, 2), listDescriptor.defaultValue());        assertEquals(Arrays.asList(5, 7), listDescriptor.valueFrom("5,7"));    }    @Test    public void testIntPropertyInvalidValue() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        thrown.expect(NumberFormatException.class);        thrown.expectMessage("not a number");        descriptor.valueFrom("not a number");    }    @Test    public void testDoubleProperty() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        assertEquals("doubleProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Double.valueOf(1.0), descriptor.defaultValue());        assertEquals(Double.valueOf(2.0), descriptor.valueFrom("2.0"));        PropertyDescriptor<List<Double>> listDescriptor = PropertyFactory.doubleListProperty("doubleListProp")                .desc("hello")                .defaultValues(1.0, 2.0)                .build();        assertEquals("doubleListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1.0, 2.0), listDescriptor.defaultValue());        assertEquals(Arrays.asList(2.0, 3.0), listDescriptor.valueFrom("2.0,3.0"));    }    @Test    public void testDoublePropertyInvalidValue() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        thrown.expect(NumberFormatException.class);        thrown.expectMessage("this is not a number");        descriptor.valueFrom("this is not a number");    }    @Test    public void testStringProperty() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("stringProp")                .desc("hello")                .defaultValue("default value")                .build();        assertEquals("stringProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("default value", descriptor.defaultValue());        assertEquals("foo", descriptor.valueFrom("foo"));        PropertyDescriptor<List<String>> listDescriptor = PropertyFactory.stringListProperty("stringListProp")                .desc("hello")                .defaultValues("v1", "v2")                .build();        assertEquals("stringListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList("v1", "v2"), listDescriptor.defaultValue());        assertEquals(Arrays.asList("foo", "bar"), listDescriptor.valueFrom("foo|bar"));    }    private enum SampleEnum { A, B, C }    private static Map<String, SampleEnum> nameMap = new LinkedHashMap<>();    static {        nameMap.put("TEST_A", SampleEnum.A);        nameMap.put("TEST_B", SampleEnum.B);        nameMap.put("TEST_C", SampleEnum.C);    }    @Test    public void testEnumProperty() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        assertEquals("enumProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(SampleEnum.B, descriptor.defaultValue());        assertEquals(SampleEnum.C, descriptor.valueFrom("TEST_C"));        PropertyDescriptor<List<SampleEnum>> listDescriptor = PropertyFactory.enumListProperty("enumListProp", nameMap)                .desc("hello")                .defaultValues(SampleEnum.A, SampleEnum.B)                .build();        assertEquals("enumListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(SampleEnum.A, SampleEnum.B), listDescriptor.defaultValue());        assertEquals(Arrays.asList(SampleEnum.B, SampleEnum.C), listDescriptor.valueFrom("TEST_B|TEST_C"));    }    @Test    public void testEnumPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(containsIgnoreCase("null value"));        PropertyFactory.enumProperty("enumProp", map);    }    @Test    public void testEnumListPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(containsIgnoreCase("null value"));        PropertyFactory.enumListProperty("enumProp", map);    }    @Test    public void testEnumPropertyInvalidValue() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage("Value was not in the set [TEST_A, TEST_B, TEST_C]");        descriptor.valueFrom("InvalidEnumValue");    }    @Test    public void testRegexProperty() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        assertEquals("regexProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("^[A-Z].*$", descriptor.defaultValue().toString());        assertEquals("[0-9]+", descriptor.valueFrom("[0-9]+").toString());    }    @Test    public void testRegexPropertyInvalidValue() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        thrown.expect(PatternSyntaxException.class);        thrown.expectMessage("Unclosed character class");        descriptor.valueFrom("[open class");    }    @Test    public void testRegexPropertyInvalidDefaultValue() {        thrown.expect(PatternSyntaxException.class);        thrown.expectMessage("Unclosed character class");        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("[open class")                .build();    }    private static Matcher<String> containsIgnoreCase(final String substring) {        return new SubstringMatcher(substring) {            @Override            protected boolean evalSubstringOf(String string) {                return StringUtils.indexOfIgnoreCase(string, substring) != -1;            }            @Override            protected String relationship() {                return "containing (ignoring case)";            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.Test;/** * Evaluates the functionality of the CharacterProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid characters, * and serialize/deserialize any default values. * * @author Brian Remedios */@Deprecatedpublic class CharacterPropertyTest extends AbstractPropertyDescriptorTester<Character> {    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    public CharacterPropertyTest() {        super("Character");    }    @Override    @Test    public void testErrorForBadSingle() {    } // not until char properties use illegal chars    @Override    @Test    public void testErrorForBadMulti() {    } // not until char properties use illegal chars    @Override    protected Character createValue() {        return randomChar(CHARSET);    }    @Override    protected Character createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Character> createProperty() {        return new CharacterProperty("testCharacter", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<Character> createBadProperty() {        return new CharacterProperty("", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createBadMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the IntegerProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of integers onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedpublic class IntegerPropertyTest extends AbstractNumericPropertyDescriptorTester<Integer> {    private static final int MIN = 1;    private static final int MAX = 12;    private static final int SHIFT = 4;    public IntegerPropertyTest() {        super("Integer");    }    /*   @Override       @Test       public void testErrorForBadSingle() {       } // not until int properties get ranges       @Override       @Test       public void testErrorForBadMulti() {       } // not until int properties get ranges   */    @Override    protected Integer createValue() {        return randomInt(MIN, MAX);    }    @Override    protected Integer createBadValue() {        return randomBool() ? randomInt(MIN - SHIFT, MIN - 1) : randomInt(MAX + 1, MAX + SHIFT);    }    protected IntegerProperty.IntegerPBuilder singleBuilder() {        return IntegerProperty.named("test").desc("foo")                              .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected IntegerMultiProperty.IntegerMultiPBuilder multiBuilder() {        return IntegerMultiProperty.named("test").desc("foo")                                   .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Integer> createProperty() {        return new IntegerProperty("testInteger", "Test integer property", MIN, MAX, MAX - 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createMultiProperty() {        return new IntegerMultiProperty("testInteger", "Test integer property", MIN, MAX,                                        new Integer[] {MIN, MIN + 1, MAX - 1, MAX}, 1.0f);    }    @Override    protected PropertyDescriptor<Integer> createBadProperty() {        return new IntegerProperty("", "Test integer property", MIN, MAX, MAX + 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createBadMultiProperty() {        return new IntegerMultiProperty("testInteger", "", MIN, MAX, new Integer[] {MIN - 1, MAX}, 1.0f);    }    @Override    protected Integer min() {        return MIN;    }    @Override    protected Integer max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the FloatProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of float values onto/from a string * buffer. * * @author Brian Remedios */public class FloatPropertyTest extends AbstractNumericPropertyDescriptorTester<Float> {    private static final float MIN = 1.0f;    private static final float MAX = 11.0f;    private static final float SHIFT = 3.0f;    public FloatPropertyTest() {        super("Float");    }    @Override    protected Float createValue() {        return randomFloat(MIN, MAX);    }    @Override    protected Float createBadValue() {        return randomBool() ? randomFloat(MIN - SHIFT, MIN) : randomFloat(MAX + 1, MAX + SHIFT);    }    @Override    protected FloatProperty.FloatPBuilder singleBuilder() {        return FloatProperty.named("test").desc("foo")                            .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected FloatMultiProperty.FloatMultiPBuilder multiBuilder() {        return FloatMultiProperty.named("test").desc("foo")                                 .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Float> createProperty() {        return new FloatProperty("testFloat", "Test float property", MIN, MAX, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", MIN, MAX,            new Float[]{6f, 9f, 1f, 2f}, 1.0f);    }    @Override    protected PropertyDescriptor<Float> createBadProperty() {        return new FloatProperty("testFloat", "Test float property", 5f, 4f, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createBadMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", 0f, 5f,            new Float[]{-1f, 0f, 1f, 2f}, 1.0f);    }    @Override    protected Float min() {        return MIN;    }    @Override    protected Float max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the DoubleProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of double values onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedpublic class DoublePropertyTest extends AbstractNumericPropertyDescriptorTester<Double> {    private static final double MIN = -10.0;    private static final double MAX = 100.0;    private static final double SHIFT = 5.0;    public DoublePropertyTest() {        super("Double");    }    @Override    protected Double createValue() {        return randomDouble(MIN, MAX);    }    @Override    protected Double createBadValue() {        return randomBool() ? randomDouble(MIN - SHIFT, MIN - 0.01) : randomDouble(MAX + 0.01, MAX + SHIFT);    }    protected DoubleProperty.DoublePBuilder singleBuilder() {        return DoubleProperty.named("test").desc("foo")                             .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected DoubleMultiProperty.DoubleMultiPBuilder multiBuilder() {        return DoubleMultiProperty.named("test").desc("foo")                                  .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Double> createProperty() {        return new DoubleProperty("testDouble", "Test double property", MIN, MAX, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {-1d, 0d, 1d, 2d}, 1.0f);    }    @Override    protected PropertyDescriptor<Double> createBadProperty() {        return new DoubleProperty("testDouble", "Test double property", MAX, MIN, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createBadMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {MIN - SHIFT, MIN, MIN + SHIFT, MAX + SHIFT}, 1.0f);    }    @Override    protected Double min() {        return MIN;    }    @Override    protected Double max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * @author Clément Fournier */@Deprecatedpublic class LongPropertyTest extends AbstractNumericPropertyDescriptorTester<Long> {    private static final long MIN = 10L;    private static final long MAX = 11000L;    private static final long SHIFT = 300L;    public LongPropertyTest() {        super("Long");    }    @Override    protected Long createValue() {        return randomLong(MIN, MAX);    }    @Override    protected Long createBadValue() {        return randomBool() ? randomLong(MIN - SHIFT, MIN) : randomLong(MAX + 1, MAX + SHIFT);    }    @Override    protected LongProperty.LongPBuilder singleBuilder() {        return LongProperty.named("test").desc("foo")                           .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected LongMultiProperty.LongMultiPBuilder multiBuilder() {        return LongMultiProperty.named("test").desc("foo")                                .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Long> createProperty() {        return new LongProperty("testFloat", "Test float property", MIN, MAX, 90L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", MIN, MAX,            new Long[]{1000L, 10L, 100L, 20L}, 1.0f);    }    @Override    protected PropertyDescriptor<Long> createBadProperty() {        return new LongProperty("testFloat", "Test float property", 200L, -400L, 900L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createBadMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", 0L, 5L,            new Long[]{-1000L, 0L, 100L, 20L}, 1.0f);    }    @Override    protected Long min() {        return MIN;    }    @Override    protected Long max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assume;import org.junit.Test;import net.sourceforge.pmd.properties.SimpleEnumeratedPropertyTest.Foo;/** * Evaluates the functionality of the EnumeratedProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid selections, * and serialize/deserialize selection options. * * @author Brian Remedios */@Deprecatedpublic class SimpleEnumeratedPropertyTest extends AbstractPropertyDescriptorTester<Foo> {    private static final String[] KEYS = {"bar", "na", "bee", "coo"};    private static final Foo[] VALUES = {Foo.BAR, Foo.NA, Foo.BEE, Foo.COO};    private static final Map<String, Foo> MAPPINGS;    static {        Map<String, Foo> map = new HashMap<>();        map.put("bar", Foo.BAR);        map.put("na", Foo.NA);        map.put("bee", Foo.BEE);        map.put("coo", Foo.COO);        MAPPINGS = Collections.unmodifiableMap(map);    }    public SimpleEnumeratedPropertyTest() {        super("Enum");    }    @Test    public void testMappings() {        EnumeratedPropertyDescriptor<Foo, Foo> prop            = (EnumeratedPropertyDescriptor<Foo, Foo>) createProperty();        EnumeratedPropertyDescriptor<Foo, List<Foo>> multi            = (EnumeratedPropertyDescriptor<Foo, List<Foo>>) createMultiProperty();        assertEquals(MAPPINGS, prop.mappings());        assertEquals(MAPPINGS, multi.mappings());    }    @Override    protected PropertyDescriptor<Foo> createProperty() {        return new EnumeratedProperty<>("testEnumerations",                                        "Test enumerations with complex types",                                        KEYS,                                        VALUES, 0, Foo.class,                                        1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations",                                             "Test enumerations with complex types",                                             KEYS,                                             VALUES,                                             new int[] {0, 1}, Foo.class, 1.0f);    }    @Test(expected = IllegalArgumentException.class)    public void testDefaultIndexOutOfBounds() {        new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                                KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Test(expected = IllegalArgumentException.class)    public void testNoMappingForDefault() {        new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                      MAPPINGS, Collections.singletonList(Foo.IGNORED), Foo.class, 1.0f);    }    @Test    public void creationTest() {        PropertyDescriptor<Foo> prop = createProperty();        PropertyDescriptor<List<Foo>> multi = createMultiProperty();        for (Map.Entry<String, Foo> e : MAPPINGS.entrySet()) {            assertEquals(e.getValue(), prop.valueFrom(e.getKey()));            assertTrue(multi.valueFrom(e.getKey()).contains(e.getValue()));        }    }    @Override    protected Foo createValue() {        return randomChoice(VALUES);    }    @Override    protected Foo createBadValue() {        return Foo.IGNORED; // not in the set of values    }    @Override    protected PropertyDescriptor<Foo> createBadProperty() {        return new EnumeratedProperty<>("testEnumerations", "Test enumerations with simple type",                                        new String[0], VALUES, -1, Foo.class, 1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createBadMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                             KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Override    @Test    public void testFactorySingleValue() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    @Override    @Test    public void testFactoryMultiValueCustomDelimiter() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    @Override    @Test    public void testFactoryMultiValueDefaultDelimiter() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    enum Foo {        BAR, NA, BEE, COO, IGNORED    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertTrue;import org.junit.Test;public class LanguageFactoryTest {    @Test    public void testSimple() {        assertTrue(LanguageFactory.createLanguage("Cpddummy") instanceof CpddummyLanguage);        assertTrue(LanguageFactory.createLanguage("not_existing_language") instanceof AnyLanguage);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Iterator;import org.junit.Test;public class MatchTest {    @Test    public void testSimple() {        int lineCount1 = 10;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount1, codeFragment1);        int lineCount2 = 20;        String codeFragment2 = "code fragment 2";        Mark mark2 = createMark("class", "/var/Foo.java", 1, lineCount2, codeFragment2);        Match match = new Match(1, mark1, mark2);        assertEquals(1, match.getTokenCount());        // Returns the line count of the first mark        assertEquals(lineCount1, match.getLineCount());        // Returns the source code of the first mark        assertEquals(codeFragment1, match.getSourceCodeSlice());        Iterator<Mark> i = match.iterator();        Mark occurrence1 = i.next();        Mark occurrence2 = i.next();        assertFalse(i.hasNext());        assertEquals(mark1, occurrence1);        assertEquals(lineCount1, occurrence1.getLineCount());        assertEquals(codeFragment1, occurrence1.getSourceCodeSlice());        assertEquals(mark2, occurrence2);        assertEquals(lineCount2, occurrence2.getLineCount());        assertEquals(codeFragment2, occurrence2.getSourceCodeSlice());    }    @Test    public void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1),                new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MatchTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.File;import java.util.ArrayList;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.SourceCode.FileCodeLoader;public class SourceCodeTest {    private static final String BASE_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String SAMPLE_CODE = "Line 1\n" + "Line 2\n" + "Line 3\n" + "Line 4\n";    @Test    public void testSimple() throws Exception {        Tokenizer tokenizer = new AbstractTokenizer() {            {                this.stringToken = new ArrayList<>();                this.ignorableCharacter = new ArrayList<>();                this.ignorableStmt = new ArrayList<>();            }        };        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(SAMPLE_CODE, "Foo.java"));        assertEquals("Foo.java", sourceCode.getFileName());        tokenizer.tokenize(sourceCode, new Tokens());        assertEquals("Line 1", sourceCode.getSlice(1, 1));        assertEquals("Line 2", sourceCode.getSlice(2, 2));        assertEquals("Line 1" + PMD.EOL + "Line 2", sourceCode.getSlice(1, 2));    }    @Test    public void testEncodingDetectionFromBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(new File(BASE_RESOURCE_PATH + "file_with_utf8_bom.java"),                "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("UTF-8", loader.getEncoding());    }    @Test    public void testEncodingIsNotChangedWhenThereIsNoBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(                new File(BASE_RESOURCE_PATH + "file_with_ISO-8859-1_encoding.java"), "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("ISO-8859-1", loader.getEncoding());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.rules.TestRule;public class CPDCommandLineInterfaceTest {    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @Rule    public final SystemOutRule log = new SystemOutRule().enableLog();    @Test    public void testEmptyResultRendering() {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPDCommandLineInterface.main(new String[] { "--minimum-tokens", "340", "--language", "java", "--files",            "src/test/resources/net/sourceforge/pmd/cpd/files/", "--format", "xml", });        Assert.assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "\n" + "<pmd-cpd/>", log.getLog());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.HashMap;import java.util.Map;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;public class CPDConfigurationTest {    @Test    public void testRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            Renderer r = CPDConfiguration.getRendererFromString(entry.getKey(), "UTF-8");            Assert.assertNotNull(r);            Assert.assertSame(entry.getValue(), r.getClass());        }    }        @Test    public void testCPDRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            CPDRenderer r = CPDConfiguration.getCPDRendererFromString(entry.getKey(), "UTF-8");            Assert.assertNotNull(r);            Assert.assertSame(entry.getValue(), r.getClass());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import org.junit.Test;/** * @author Philippe T'Seyen */public class FileReporterTest {    @Test    public void testCreation() {        new FileReporter((String) null);        new FileReporter((File) null);    }    @Test    public void testEmptyReport() throws ReportException {        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");        assertTrue(reportFile.exists());        assertEquals(0L, reportFile.length());        assertTrue(reportFile.delete());    }    @Test    public void testReport() throws ReportException, IOException {        String testString = "first line\nsecond line";        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report(testString);        assertEquals(testString, readFile(reportFile));        assertTrue(reportFile.delete());    }    @Test(expected = ReportException.class)    public void testInvalidFile() throws ReportException {        File reportFile = new File("/invalid_folder/report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");    }    private String readFile(File file) throws IOException {        BufferedReader reader = null;        try {            reader = new BufferedReader(new FileReader(file));            StringBuffer buffer = new StringBuffer();            String line = reader.readLine();            while (line != null) {                buffer.append(line);                line = reader.readLine();                if (line != null) {                    buffer.append('\n');                }            }            return buffer.toString();        } finally {            if (reader != null) {                reader.close();            }        }    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(FileReporterTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.PMD;public class AnyTokenizerTest {    @Test    public void testMultiLineMacros() {        AnyTokenizer tokenizer = new AnyTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(TEST1));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        assertEquals(30, tokens.size());    }    private static final String TEST1 = "using System;" + PMD.EOL + "namespace HelloNameSpace {" + PMD.EOL + ""            + PMD.EOL + "    public class HelloWorld {" + PMD.EOL + "        static void Main(string[] args) {"            + PMD.EOL + "            Console.WriteLine(\"Hello World!\");" + PMD.EOL + "        }" + PMD.EOL + "    }"            + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AnyTokenizerTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;public class CSVRendererTest {    @Test    public void testLineCountPerFile() throws IOException {        CPDRenderer renderer = new CSVRenderer(true);        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "tokens,occurrences" + PMD.EOL + "75,2,48,10,/var/Foo.java,73,20,/var/Bar.java"                + PMD.EOL;        assertEquals(expectedReport, report);    }    @Test    public void testFilenameEscapes() throws IOException {        CPDRenderer renderer = new CSVRenderer();        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var,with,commas/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var,with,commas/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "lines,tokens,occurrences" + PMD.EOL                + "10,75,2,48,\"/var,with,commas/Foo.java\",73,\"/var,with,commas/Bar.java\"" + PMD.EOL;        assertEquals(expectedReport, report);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader;public class MarkTest {    @Test    public void testSimple() {        String filename = "/var/Foo.java";        int beginLine = 1;        TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1);        Mark mark = new Mark(token);        int lineCount = 10;        mark.setLineCount(lineCount);        String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MarkTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.io.FilenameUtils;import org.junit.Test;public class CPDFilelistTest {    @Test    public void testFilelist() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);                List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(FilenameUtils.getName(path));        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }    @Test    public void testFilelistMultipleLines() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist2.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);                List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(FilenameUtils.getName(path));        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;public class TokenEntryTest {    @Test    public void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(TokenEntryTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import javax.xml.parsers.DocumentBuilderFactory;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;/** * @author Philippe T'Seyen * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class XMLRendererTest {    private static final String ENCODING = (String) System.getProperties().get("file.encoding");    @Test    public void testWithNoDuplication() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList nodes = doc.getChildNodes();            Node n = nodes.item(0);            assertEquals("pmd-cpd", n.getNodeName());            assertEquals(0, doc.getElementsByTagName("duplication").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testWithOneDuplication() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList dupes = doc.getElementsByTagName("duplication");            assertEquals(1, dupes.getLength());            Node file = dupes.item(0).getFirstChild();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            if (file != null) {                assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());                file = file.getNextSibling();                while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                    file = file.getNextSibling();                }            }            if (file != null) {                assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());            }            assertEquals(1, doc.getElementsByTagName("codefragment").getLength());            assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testRenderWithMultipleMatch() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount1 = 6;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, lineCount1, codeFragment1);        Mark mark2 = createMark("void", "/var/Foo.java", 73, lineCount1, codeFragment1);        Match match1 = new Match(75, mark1, mark2);        int lineCount2 = 7;        String codeFragment2 = "code fragment 2";        Mark mark3 = createMark("void", "/var/Foo2.java", 49, lineCount2, codeFragment2);        Mark mark4 = createMark("stuff", "/var/Foo2.java", 74, lineCount2, codeFragment2);        Match match2 = new Match(76, mark3, mark4);        list.add(match1);        list.add(match2);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            assertEquals(2, doc.getElementsByTagName("duplication").getLength());            assertEquals(4, doc.getElementsByTagName("file").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testRendererEncodedPath() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        final String espaceChar = "&lt;";        Mark mark1 = createMark("public", "/var/F" + '<' + "oo.java", 48, 6, "code fragment");        Mark mark2 = createMark("void", "/var/F<oo.java", 73, 6, "code fragment");        Match match1 = new Match(75, mark1, mark2);        list.add(match1);                StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertTrue(report.contains(espaceChar));    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(XMLRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.File;import java.util.Iterator;import org.apache.commons.lang3.SystemUtils;import org.junit.Assert;import org.junit.Assume;import org.junit.Before;import org.junit.Test;/** * Unit test for {@link CPD} */public class CPDTest {    private static final String BASE_TEST_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String TARGET_TEST_RESOURCE_PATH = "target/classes/net/sourceforge/pmd/cpd/files/";    private CPD cpd;    // Symlinks are not well supported under Windows - so the tests are    // simply executed only on linux.    private boolean canTestSymLinks = SystemUtils.IS_OS_UNIX;    @Before    public void setup() throws Exception {        CPDConfiguration theConfiguration = new CPDConfiguration();        theConfiguration.setLanguage(new AnyLanguage("any"));        theConfiguration.setMinimumTileSize(10);        theConfiguration.postContruct();        cpd = new CPD(theConfiguration);    }    /**     * As java doesn't support symlinks in zip files, maven does not, too. So,     * we are creating the symlinks manually here before the test.     *     * @throws Exception     *             any error     */    private void prepareSymLinks() throws Exception {        Assume.assumeTrue("Skipping unit tests with symlinks.", canTestSymLinks);        Runtime runtime = Runtime.getRuntime();        if (!new File(TARGET_TEST_RESOURCE_PATH, "symlink-for-real-file.txt").exists()) {            runtime.exec(new String[] { "ln", "-s", BASE_TEST_RESOURCE_PATH + "real-file.txt",                TARGET_TEST_RESOURCE_PATH + "symlink-for-real-file.txt", }).waitFor();        }        if (!new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test").exists()) {            runtime.exec(new String[] { "ln", "-s", "broken-sym-link",                TARGET_TEST_RESOURCE_PATH + "this-is-a-broken-sym-link-for-test", }).waitFor();        }    }    /**     * A broken symlink (which is basically a not existing file), should be     * skipped.     *     * @throws Exception     *             any error     */    @Test    public void testFileSectionWithBrokenSymlinks() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(0);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test"));        listener.verify();    }    /**     * A file should be added only once - even if it was found twice, because of     * a sym link.     *     * @throws Exception     *             any error     */    @Test    public void testFileAddedAsSymlinkAndReal() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "real-file.txt"));        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "symlink-for-real-file.txt"));        listener.verify();    }    /**     * Add a file with a relative path - should still be added and not be     * detected as a sym link.     *     * @throws Exception     *             any error     */    @Test    public void testFileAddedWithRelativePath() throws Exception {        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "real-file.txt"));        listener.verify();    }    /**     * The order of the duplicates is dependent on the order the files are added to CPD.     * See also https://github.com/pmd/pmd/issues/1196     * @throws Exception     */    @Test    public void testFileOrderRelevance() throws Exception {        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup2.java"));        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup1.java"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        while (matches.hasNext()) {            Match match = matches.next();            // the file added first was dup2.            Assert.assertTrue(match.getFirstMark().getFilename().endsWith("dup2.java"));            Assert.assertTrue(match.getSecondMark().getFilename().endsWith("dup1.java"));        }    }    /**     * Simple listener that fails, if too many files were added and not skipped.     */    private static class NoFileAssertListener implements CPDListener {        private int expectedFilesCount;        private int files;        NoFileAssertListener(int expectedFilesCount) {            this.expectedFilesCount = expectedFilesCount;            this.files = 0;        }        @Override        public void addedFile(int fileCount, File file) {            files++;            if (files > expectedFilesCount) {                Assert.fail("File was added! - " + file);            }        }        @Override        public void phaseUpdate(int phase) {            // not needed for this test        }        public void verify() {            Assert.assertEquals("Expected " + expectedFilesCount + " files, but " + files + " have been added.",                    expectedFilesCount, files);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.fail;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.BuildFileRule;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;public class PMDTaskTest {    @Rule    public final BuildFileRule buildRule = new BuildFileRule();    @Before    public void setUp() {        buildRule.configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/pmdtasktest.xml");    }    @Test    public void testFormatterWithNoToFileAttribute() {        try {            buildRule.executeTarget("testFormatterWithNoToFileAttribute");            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals("toFile or toConsole needs to be specified in Formatter", ex.getMessage());        }    }    @Test    public void testNoRuleSets() {        try {            buildRule.executeTarget("testNoRuleSets");            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals("No rulesets specified", ex.getMessage());        }    }    @Test    public void testBasic() {        buildRule.executeTarget("testBasic");    }    @Test    public void testInvalidLanguageVersion() {        try {            buildRule.executeTarget("testInvalidLanguageVersion");            Assert.assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    buildRule.getLog());            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    ex.getMessage());        }    }    @Test    public void testWithShortFilenames() throws FileNotFoundException, IOException {        buildRule.executeTarget("testWithShortFilenames");        try (InputStream in = new FileInputStream("target/pmd-ant-test.txt")) {            String actual = IOUtils.toString(in, StandardCharsets.UTF_8);            // remove any trailing newline            actual = actual.replaceAll("\n|\r", "");            Assert.assertEquals("sample.dummy:0:\tTest Rule 2", actual);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;public class FormatterTest {    @Test    public void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.createRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.createRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.createRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.createRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            f.createRenderer();            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException be) {            assertTrue(be.getMessage().startsWith("Can't find the custom format FAIL"));        }    }    @Test    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isNoOutputSupplied());        f.setToFile(new File("foo"));        assertFalse("Formatter toFile should not be null!", f.isNoOutputSupplied());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertTrue;import java.io.File;import org.apache.tools.ant.BuildFileRule;import org.junit.Before;import org.junit.Rule;import org.junit.Test;/** * * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CPDTaskTest {    @Rule    public final BuildFileRule buildRule = new BuildFileRule();    @Before    public void setUp() {        buildRule.configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/cpdtasktest.xml");    }    @Test    public void testBasic() {        buildRule.executeTarget("testBasic");        // FIXME: This clearly needs to be improved - but I don't like to write        // test, so feel free to contribute :)        assertTrue(new File("target/cpd.ant.tests").exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.AttributeAxisIterator;public class AttributeAxisIteratorTest {    @Test(expected = UnsupportedOperationException.class)    public void testRemove() {        DummyNode n = new DummyNode(0);        n.testingOnlySetBeginColumn(1);        n.testingOnlySetBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        iter.remove();    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AttributeAxisIteratorTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import static org.junit.Assert.assertEquals;import java.lang.reflect.Method;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.xpath.Attribute;public class AttributeTest {    @Test    public void testConstructor() {        DummyNode p = new DummyNode(1);        p.testingOnlySetBeginLine(5);        Method[] methods = p.getClass().getMethods();        Method m = null;        for (int i = 0; i < methods.length; i++) {            if (methods[i].getName().equals("getBeginLine")) {                m = methods[i];                break;            }        }        Attribute a = new Attribute(p, "BeginLine", m);        assertEquals("BeginLine", a.getName());        assertEquals(5, a.getValue());        assertEquals("5", a.getStringValue());        assertEquals(p, a.getParent());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AttributeTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.jaxen;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.jaxen.Context;import org.jaxen.FunctionCallException;import org.junit.Test;import net.sourceforge.pmd.lang.ast.AbstractNode;import net.sourceforge.pmd.lang.ast.xpath.Attribute;import net.sourceforge.pmd.lang.xpath.MatchesFunction;public class MatchesFunctionTest {    public static class MyNode extends AbstractNode {        private String className;        public MyNode() {            super(1);        }        @Override        public String toString() {            return "MyNode";        }        public void setClassName(String className) {            this.className = className;        }        public String getClassName() {            return className;        }        @Override        public String getXPathNodeName() {            return "MyNode";        }    }    @Test    public void testMatch() throws FunctionCallException, NoSuchMethodException {        MyNode myNode = new MyNode();        myNode.setClassName("Foo");        assertTrue(tryRegexp(myNode, "Foo") instanceof List);    }    @Test    public void testNoMatch() throws FunctionCallException, NoSuchMethodException {        MyNode myNode = new MyNode();        myNode.setClassName("bar");        assertTrue(tryRegexp(myNode, "Foo") instanceof Boolean);        myNode.setClassName("FobboBar");        assertTrue(tryRegexp(myNode, "Foo") instanceof Boolean);    }    private Object tryRegexp(MyNode myNode, String exp) throws FunctionCallException, NoSuchMethodException {        MatchesFunction function = new MatchesFunction();        List<Object> list = new ArrayList<>();        List<Attribute> attrs = new ArrayList<>();        attrs.add(new Attribute(myNode, "matches", myNode.getClass().getMethod("getClassName", new Class[0])));        list.add(attrs);        list.add(exp);        Context c = new Context(null);        c.setNodeSet(new ArrayList<>());        return function.call(c, list);    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MatchesFunctionTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.XPathRule;public class CodeClimateRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new CodeClimateRenderer();    }    @Override    public String getExpected() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/spec/blob/master/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/spec/blob/master/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_devdocs_working_with_properties.html)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    public String getExpectedWithProperties() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/spec/blob/master/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/spec/blob/master/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_devdocs_working_with_properties.html)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "multiString | default1,default2 | multi string property\\n"                + "stringProperty | the string value\\nsecond line with 'quotes' | simple string property\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/spec/blob/master/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/spec/blob/master/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_devdocs_working_with_properties.html)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL + "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/spec/blob/master/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/spec/blob/master/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_devdocs_working_with_properties.html)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }        @Test    public void testXPathRule() throws Exception {        DummyNode node = createNode(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        Report report = new Report();        XPathRule theRule = new XPathRule();        theRule.setProperty(XPathRule.XPATH_DESCRIPTOR, "//dummyNode");                // Setup as FooRule        theRule.setDescription("desc");        theRule.setName("Foo");                report.addRuleViolation(new ParametricRuleViolation<Node>(theRule, ctx, node, "blah"));        String rendered = ReportTest.render(getRenderer(), report);                // Output should be the exact same as for non xpath rules        assertEquals(filter(getExpected()), filter(rendered));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class HTMLRendererTest extends AbstractRendererTest {    @Override    protected String getSourceCodeFilename() {        return "someFilename<br>thatNeedsEscaping.ext";    }    private String getEscapedFilename() {        return "someFilename&lt;br&gt;thatNeedsEscaping.ext";    }    @Override    public Renderer getRenderer() {        return new HTMLRenderer();    }    @Override    public String getExpected() {        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader()                + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "<tr> " + PMD.EOL                + "<td align=\"center\">2</td>" + PMD.EOL + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader()                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>file</td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }        @Override    public String getExpectedError(ConfigurationError error) {        return getHeader()                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    private String getHeader() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.RuleWithProperties;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public abstract class AbstractRendererTest {    public abstract Renderer getRenderer();    public abstract String getExpected();    public String getExpectedWithProperties() {        return getExpected();    }    public abstract String getExpectedEmpty();    public abstract String getExpectedMultiple();    public String getExpectedError(ProcessingError error) {        return "";    }    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return getExpectedError(error);    }    public String getExpectedError(ConfigurationError error) {        return "";    }    public String filter(String expected) {        return expected;    }    protected String getSourceCodeFilename() {        return "notAvailable.ext";    }    @Test(expected = NullPointerException.class)    public void testNullPassedIn() throws Exception {        getRenderer().renderFileReport(null);    }    private Report reportOneViolation() {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1));        return report;    }    private Report reportTwoViolations() {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1));        report.addRuleViolation(newRuleViolation(2));        return report;    }    protected RuleViolation newRuleViolation(int endColumn) {        DummyNode node = createNode(endColumn);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        return new ParametricRuleViolation<Node>(new FooRule(), ctx, node, "blah");    }    protected static DummyNode createNode(int endColumn) {        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        node.testingOnlySetEndLine(1);        node.testingOnlySetEndColumn(endColumn);        return node;    }    @Test    public void testRuleWithProperties() throws Exception {        DummyNode node = createNode(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        Report report = new Report();        RuleWithProperties theRule = new RuleWithProperties();        theRule.setProperty(RuleWithProperties.STRING_PROPERTY_DESCRIPTOR,                "the string value\nsecond line with \"quotes\"");        report.addRuleViolation(new ParametricRuleViolation<Node>(theRule, ctx, node, "blah"));        String rendered = ReportTest.render(getRenderer(), report);        assertEquals(filter(getExpectedWithProperties()), filter(rendered));    }    @Test    public void testRenderer() throws Exception {        Report rep = reportOneViolation();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpected()), filter(actual));    }    @Test    public void testRendererEmpty() throws Exception {        Report rep = new Report();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedEmpty()), filter(actual));    }    @Test    public void testRendererMultiple() throws Exception {        Report rep = reportTwoViolations();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedMultiple()), filter(actual));    }    @Test    public void testError() throws Exception {        Report rep = new Report();        Report.ProcessingError err = new Report.ProcessingError(new RuntimeException("Error"), "file");        rep.addError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedError(err)), filter(actual));    }    @Test    public void testErrorWithoutMessage() throws Exception {        Report rep = new Report();        Report.ProcessingError err = new Report.ProcessingError(new NullPointerException(), "file");        rep.addError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedErrorWithoutMessage(err)), filter(actual));    }    @Test    public void testConfigError() throws Exception {        Report rep = new Report();        Report.ConfigurationError err = new Report.ConfigurationError(new FooRule(), "a configuration error");        rep.addConfigError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedError(err)), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class IDEAJRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        Renderer result = new IDEAJRenderer();        result.setProperty(IDEAJRenderer.SOURCE_PATH, "");        result.setProperty(IDEAJRenderer.CLASS_AND_METHOD_NAME, "Foo <init>");        result.setProperty(IDEAJRenderer.FILE_NAME, "Foo.java");        return result;    }    @Override    public String getExpected() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL + "blah" + PMD.EOL                + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class TextPadRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new TextPadRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL + getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(TextPadRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.FileNotFoundException;import java.io.Reader;import java.io.StringReader;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class PapariTextRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        TextColorRenderer result = new TextColorRenderer() {            @Override            protected Reader getReader(String sourceFile) throws FileNotFoundException {                return new StringReader("public class Foo {}");            }        };        result.setProperty(TextColorRenderer.COLOR, "false");        return result;    }    @Override    public String getExpected() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL                + "Summary:" + PMD.EOL + PMD.EOL + " : 1" + PMD.EOL + "* warnings: 1" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + "    src:  "                + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL + "    msg:  blah" + PMD.EOL                + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL                + PMD.EOL + " : 2" + PMD.EOL + "* warnings: 2" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  RuntimeException: Error" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  NullPointerException: null" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* rule: Foo" + PMD.EOL                + "    err:  a configuration error" + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(PapariTextRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class XSLTRendererTest {    @Test    public void testDefaultStylesheet() throws Exception {        XSLTRenderer renderer = new XSLTRenderer();        Report report = new Report();        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        RuleViolation rv = new ParametricRuleViolation<Node>(new FooRule(), new RuleContext(), node,                "violation message");        report.addRuleViolation(rv);        String result = ReportTest.render(renderer, report);        Assert.assertTrue(result.contains("violation message"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class EmacsRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new EmacsRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL + getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class VBHTMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new VBHTMLRenderer();    }    @Override    public String getExpected() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL + "--></style><body><center><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL                + "<tr id=RowColor1><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.getFile() + "</font></td><td><font class=body><pre>" + error.getDetail() + "</pre></font></td></tr></table></center></body></html>" + PMD.EOL;    }        @Override    public String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Configuration problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.rule().getName() + "</font></td><td><font class=body>" + error.issue() + "</font></td></tr></table></center></body></html>" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VBHTMLRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import org.junit.Test;public class EmptyRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new EmptyRenderer();    }    // Overriding the annotation from the super class, this renderer doesn't care, so no NPE.    @Test    @Override    public void testNullPassedIn() throws Exception {        super.testNullPassedIn();    }    @Override    public String getExpected() {        return "";    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class CSVRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new CSVRenderer();    }    @Override    public String getExpected() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader();    }    @Override    public String getExpectedMultiple() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL                + "\"2\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader();    }        @Override    public String getExpectedError(ConfigurationError error) {        return getHeader();    }        private String getHeader() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(CSVRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class TextRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new TextRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + ":1:\tblah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + ":1:\tblah" + PMD.EOL                + getSourceCodeFilename() + ":1:\tblah" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "file\t-\tRuntimeException: Error" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return "file\t-\tNullPointerException: null" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "Foo\t-\ta configuration error" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.File;import java.io.StringReader;import javax.xml.parsers.DocumentBuilderFactory;import org.junit.Assert;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDVersion;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class XMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new XMLRenderer();    }    @Override    public String getExpected() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader() + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"2\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"RuntimeException: Error\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"NullPointerException: null\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader() + "<configerror rule=\"Foo\" msg=\"a configuration error\"/>"                + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String filter(String expected) {        String result = expected.replaceAll(" timestamp=\"[^\"]+\">", " timestamp=\"\">");        return result;    }    private RuleViolation createRuleViolation(String description) {        DummyNode node = new DummyNode(1);        node.testingOnlySetBeginLine(1);        node.testingOnlySetBeginColumn(1);        node.testingOnlySetEndLine(1);        node.testingOnlySetEndColumn(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        return new ParametricRuleViolation<Node>(new FooRule(), ctx, node, description);    }    private void verifyXmlEscaping(Renderer renderer, String shouldContain) throws Exception {        Report report = new Report();        String surrogatePair = "\ud801\udc1c";        String msg = "The String literal \"Tokenizer " + surrogatePair + "\" appears...";        report.addRuleViolation(createRuleViolation(msg));        String actual = ReportTest.render(renderer, report);        Assert.assertTrue(actual.contains(shouldContain));        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new InputSource(new StringReader(actual)));        NodeList violations = doc.getElementsByTagName("violation");        Assert.assertEquals(1, violations.getLength());        Assert.assertEquals(msg, violations.item(0).getTextContent().trim());    }    @Test    public void testXMLEscapingWithUTF8() throws Exception {        Renderer renderer = getRenderer();        renderer.setProperty(XMLRenderer.ENCODING, "UTF-8");        verifyXmlEscaping(renderer, "\ud801\udc1c");    }    @Test    public void testXMLEscapingWithoutUTF8() throws Exception {        Renderer renderer = getRenderer();        renderer.setProperty(XMLRenderer.ENCODING, "ISO-8859-1");        verifyXmlEscaping(renderer, "&#x1041c;");    }        public String getHeader() {        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + PMD.EOL                + "<pmd xmlns=\"http://pmd.sourceforge.net/report/2.0.0\"" + PMD.EOL                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" + PMD.EOL                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/report/2.0.0 http://pmd.sourceforge.net/report_2_0_0.xsd\"" + PMD.EOL                + "    version=\"" + PMDVersion.VERSION + "\" timestamp=\"2014-10-06T19:30:51.262\">" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.regex.Pattern;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class YAHTMLRendererTest extends AbstractRendererTest {    private String outputDir;    @Before    public void setUp() throws IOException {        outputDir = getTemporaryDirectory("pmdtest").getAbsolutePath();    }    @After    public void cleanUp() {        deleteDirectory(new File(outputDir));    }    private File getTemporaryDirectory(String prefix) throws IOException {        // TODO: move to util class?        File dir = File.createTempFile(prefix, "");        dir.delete();        dir.mkdir();        return dir;    }    private void deleteDirectory(File dir) {        // TODO: move to util class?        File[] a = dir.listFiles();        if (a != null) {            for (File f : a) {                if (f.isDirectory()) {                    deleteDirectory(f);                } else {                    f.delete();                }            }        }        dir.delete();    }    private RuleViolation newRuleViolation(int endColumn, final String packageNameArg, final String classNameArg) {        DummyNode node = createNode(endColumn);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        return new ParametricRuleViolation<Node>(new FooRule(), ctx, node, "blah") {            {                packageName = packageNameArg;                className = classNameArg;            }        };    }    @Override    protected RuleViolation newRuleViolation(int endColumn) {        return newRuleViolation(endColumn, "net.sf.pmd.test", "YAHTMLSampleClass");    }    @Test    public void testReportMultipleViolations() throws Exception {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1, "net.sf.pmd.test", "YAHTMLSampleClass1"));        report.addRuleViolation(newRuleViolation(2, "net.sf.pmd.test", "YAHTMLSampleClass1"));        report.addRuleViolation(newRuleViolation(1, "net.sf.pmd.other", "YAHTMLSampleClass2"));        String actual = ReportTest.render(getRenderer(), report);        assertEquals(filter(getExpected()), filter(actual));        String[] htmlFiles = new File(outputDir).list();        assertEquals(3, htmlFiles.length);        Arrays.sort(htmlFiles);        assertEquals("YAHTMLSampleClass1.html", htmlFiles[0]);        assertEquals("YAHTMLSampleClass2.html", htmlFiles[1]);        assertEquals("index.html", htmlFiles[2]);        for (String file : htmlFiles) {            try (FileInputStream in = new FileInputStream(new File(outputDir, file));                    InputStream expectedIn = YAHTMLRendererTest.class.getResourceAsStream("yahtml/" + file)) {                String data = IOUtils.toString(in, StandardCharsets.UTF_8);                String expected = normalizeLineSeparators(IOUtils.toString(expectedIn, StandardCharsets.UTF_8));                assertEquals("File " + file + " is different", expected, data);            }        }    }    private static String normalizeLineSeparators(String s) {        return s.replaceAll(Pattern.quote(IOUtils.LINE_SEPARATOR_WINDOWS), IOUtils.LINE_SEPARATOR_UNIX)                .replaceAll(Pattern.quote(IOUtils.LINE_SEPARATOR_UNIX), PMD.EOL);    }    @Override    public Renderer getRenderer() {        Renderer result = new YAHTMLRenderer();        result.setProperty(YAHTMLRenderer.OUTPUT_DIR, outputDir);        return result;    }    @Override    public String getExpected() {        return "<h3 align=\"center\">The HTML files are located in '" + outputDir + "'.</h3>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getExpected();    }    @Override    public String getExpectedMultiple() {        return getExpected();    }    @Override    public String getExpectedError(ProcessingError error) {        return getExpected();    }    @Override    public String getExpectedError(ConfigurationError error) {        return getExpected();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.util.HashMap;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;public class SummaryHTMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        Renderer result = new SummaryHTMLRenderer();        result.setProperty(HTMLRenderer.LINK_PREFIX, "link_prefix");        result.setProperty(HTMLRenderer.LINE_PREFIX, "line_prefix");        return result;    }    @Override    protected String getSourceCodeFilename() {        return "notAvailable";    }    @Override    public String getExpected() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>1</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>2</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "<tr> " + PMD.EOL + "<td align=\"center\">2</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>file</td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Test    public void testShowSuppressions() throws Exception {        Report rep = createEmptyReportWithSuppression();        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(true);        String actual = ReportTest.render(renderer, rep);        assertEquals("<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>"                + PMD.EOL + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Suppressed warnings</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Line</th><th>Rule</th><th>NOPMD or Annotation</th><th>Reason</th></tr>"                + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"left\"></td>" + PMD.EOL                + "<td align=\"center\">1</td>" + PMD.EOL + "<td align=\"center\">Foo</td>" + PMD.EOL                         + "<td align=\"center\">//NOPMD</td>" + PMD.EOL + "<td align=\"center\">test</td>" + PMD.EOL                         + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL, actual);    }    @Test    public void testHideSuppressions() throws Exception {        Report rep = createEmptyReportWithSuppression();        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(false);        String actual = ReportTest.render(renderer, rep);        assertEquals(getExpectedEmpty(), actual);    }    private Report createEmptyReportWithSuppression() {        Map<Integer, String> suppressions = new HashMap<>();        suppressions.put(1, "test");        RuleContext ctx = new RuleContext();        DummyRoot root = new DummyRoot(suppressions);        root.setCoords(1, 10, 4, 5);        DefaultRuleViolationFactory.defaultInstance().addViolation(ctx, new FooRule(), root, "suppress test", 1, 1, new Object[0]);        return ctx.getReport();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.List;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.util.datasource.DataSource;public class PMDFilelistTest {    @Test    public void testGetApplicableFiles() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(2, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("anotherfile.dummy"));    }    @Test    public void testGetApplicableFilesMultipleLines() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist2.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(3, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("anotherfile.dummy"));        Assert.assertTrue(applicableFiles.get(2).getNiceFileName(false, "").endsWith("somefile.dummy"));    }    @Test    public void testGetApplicatbleFilesWithIgnores() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist3.txt");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(2, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile2.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("somefile4.dummy"));    }    @Test    public void testGetApplicatbleFilesWithDirAndIgnores() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputPaths("src/test/resources/net/sourceforge/pmd/cli/src");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(4, applicableFiles.size());        Collections.sort(applicableFiles, new Comparator<DataSource>() {            @Override            public int compare(DataSource o1, DataSource o2) {                if (o1 == null && o2 != null) {                    return -1;                } else if (o1 != null && o2 == null) {                    return 1;                } else {                    return o1.getNiceFileName(false, "").compareTo(o2.getNiceFileName(false, ""));                }            }        });        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("anotherfile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(2).getNiceFileName(false, "").endsWith("somefile2.dummy"));        Assert.assertTrue(applicableFiles.get(3).getNiceFileName(false, "").endsWith("somefile4.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.ExpectedSystemExit;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.cache.NoopAnalysisCache;/** * Unit test for {@link PMDCommandLineInterface} */public class PMDCommandLineInterfaceTest {    @Rule    public final ExpectedSystemExit exit = ExpectedSystemExit.none();    @Rule // Restores system properties after test    public final RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    @Before    public void clearSystemProperties() {        System.clearProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN);        System.clearProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY);    }    @Test    public void testProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "yahtml", "-P", "outputDir=output_folder", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        Assert.assertEquals("output_folder", params.getProperties().getProperty("outputDir"));    }    @Test    public void testMultipleProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "ideaj", "-P", "sourcePath=/home/user/source/", "-P",            "fileName=Foo.java", "-P", "classAndMethodName=Foo.method", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        Assert.assertEquals("/home/user/source/", params.getProperties().getProperty("sourcePath"));        Assert.assertEquals("Foo.java", params.getProperties().getProperty("fileName"));        Assert.assertEquals("Foo.method", params.getProperties().getProperty("classAndMethodName"));    }    @Test    public void testNoCacheSwitch() {        PMDParameters params = new PMDParameters();        String[] args = {"-d", "source_folder", "-f", "ideaj", "-R", "java-empty", "-cache", "/home/user/.pmd/cache", "-no-cache", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertTrue(params.isIgnoreIncrementalAnalysis());        PMDConfiguration config = params.toConfiguration();        assertTrue(config.isIgnoreIncrementalAnalysis());        assertTrue(config.getAnalysisCache() instanceof NoopAnalysisCache);    }    @Test    public void testSetStatusCodeOrExitDoExit() {        exit.expectSystemExitWithStatus(0);        PMDCommandLineInterface.setStatusCodeOrExit(0);    }    @Test    public void testSetStatusCodeOrExitSetStatus() {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "1");        PMDCommandLineInterface.setStatusCodeOrExit(0);        Assert.assertEquals(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY), "0");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import org.apache.commons.lang3.reflect.FieldUtils;import org.junit.Assert;import org.junit.Test;public class PMDParametersTest {    @Test    public void testVersion() throws Exception {        PMDParameters parameters = new PMDParameters();        // no language set, uses default language        Assert.assertEquals("1.7", parameters.getVersion());        // now set lanuage        FieldUtils.writeDeclaredField(parameters, "language", "dummy2", true);        Assert.assertEquals("1.0", parameters.getVersion());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.Reader;import java.nio.charset.Charset;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.util.ResourceLoader;public class RuleSetFactoryCompatibilityTest {    private static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");    private static final Charset UTF_8 = Charset.forName("UTF-8");    @Test    public void testCorrectOldReference() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\" />\n" + "</ruleset>\n";        RuleSetFactory factory = new RuleSetFactory();        factory.getCompatibilityFilter().addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);        Assert.assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));    }        @Test    public void testCorrectMovedAndRename() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/OldDummyBasicMockRule\" />\n" + "</ruleset>\n";        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "OldDummyBasicMockRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldDummyBasicMockRule", "NewNameForDummyBasicMockRule");        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);                Assert.assertFalse(out.contains("notexisting.xml"));        Assert.assertFalse(out.contains("OldDummyBasicMockRule"));        Assert.assertTrue(out.contains("<rule ref=\"rulesets/dummy/basic.xml/NewNameForDummyBasicMockRule\" />"));    }    @Test    public void testExclusion() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n" + " <rule ref=\"rulesets/dummy/basic.xml\">\n"                + "   <exclude name=\"OldNameOfSampleXPathRule\"/>\n" + " </rule>\n" + "</ruleset>\n";        RuleSetFactory factory = new RuleSetFactory();        factory.getCompatibilityFilter().addFilterRuleRenamed("dummy", "basic", "OldNameOfSampleXPathRule",                "SampleXPathRule");        RuleSet createdRuleSet = createRulesetFromString(ruleset, factory);        Assert.assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));        Assert.assertNull(createdRuleSet.getRuleByName("SampleXPathRule"));    }    @Test    public void testExclusionRenamedAndMoved() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/oldbasic.xml\">\n"                + "   <exclude name=\"OldDummyBasicMockRule\"/>\n"                + " </rule>\n"                + "</ruleset>\n";        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMovedAndRenamed("dummy", "oldbasic", "OldDummyBasicMockRule", "basic", "NewNameForDummyBasicMockRule");        InputStream stream = new ByteArrayInputStream(ruleset.getBytes(ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertTrue(out.contains("OldDummyBasicMockRule"));    }    @Test    public void testFilter() throws Exception {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        rsfc.addFilterRuleRemoved("dummy", "basic", "DeletedRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldNameOfBasicMockRule", "NewNameOfBasicMockRule");        String in = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\" />\n"                + " <rule ref=\"rulesets/dummy/basic.xml/DeletedRule\" />\n"                + " <rule ref=\"rulesets/dummy/basic.xml/OldNameOfBasicMockRule\" />\n" + "</ruleset>\n";        InputStream stream = new ByteArrayInputStream(in.getBytes(ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertFalse(out.contains("notexisting.xml"));        Assert.assertTrue(out.contains("<rule ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\" />"));        Assert.assertFalse(out.contains("DeletedRule"));        Assert.assertFalse(out.contains("OldNameOfBasicMockRule"));        Assert.assertTrue(out.contains("<rule ref=\"rulesets/dummy/basic.xml/NewNameOfBasicMockRule\" />"));    }    @Test    public void testExclusionFilter() throws Exception {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleRenamed("dummy", "basic", "AnotherOldNameOfBasicMockRule", "NewNameOfBasicMockRule");        String in = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n" + " <rule ref=\"rulesets/dummy/basic.xml\">\n"                + "   <exclude name=\"AnotherOldNameOfBasicMockRule\"/>\n" + " </rule>\n" + "</ruleset>\n";        InputStream stream = new ByteArrayInputStream(in.getBytes(ISO_8859_1));        Reader filtered = rsfc.filterRuleSetFile(stream);        String out = IOUtils.toString(filtered);        Assert.assertFalse(out.contains("OldNameOfBasicMockRule"));        Assert.assertTrue(out.contains("<exclude name=\"NewNameOfBasicMockRule\" />"));    }    @Test    public void testEncoding() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        String testString;        testString = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><x></x>";        Assert.assertEquals("ISO-8859-1", rsfc.determineEncoding(testString.getBytes(ISO_8859_1)));        testString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><x></x>";        Assert.assertEquals("UTF-8", rsfc.determineEncoding(testString.getBytes(ISO_8859_1)));    }    private RuleSet createRulesetFromString(final String ruleset, RuleSetFactory factory)            throws RuleSetNotFoundException {        return factory.createRuleSet(new RuleSetReferenceId(null) {            @Override            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {                return new ByteArrayInputStream(ruleset.getBytes(UTF_8));            }        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.IOException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Locale;import javax.xml.XMLConstants;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.stream.StreamSource;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import org.junit.Before;import org.junit.Test;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.xml.sax.EntityResolver;import org.xml.sax.ErrorHandler;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;public class RuleSetSchemaTest {    private CollectingErrorHandler errorHandler;    @Before    public void setUp() {        Locale.setDefault(Locale.ROOT);        errorHandler = new CollectingErrorHandler();    }    @Test    public void verifyVersion2() throws Exception {        String ruleset = generateRuleSet("2.0.0");        Document doc = parseWithVersion2(ruleset);        assertNotNull(doc);        assertTrue(errorHandler.isValid());        assertEquals("Custom ruleset", ((Attr) doc.getElementsByTagName("ruleset").item(0).getAttributes().getNamedItem("name")).getValue());    }    @Test    public void validateOnly() throws Exception {        Validator validator = PMDRuleSetEntityResolver.getSchemaVersion2().newValidator();        validator.setErrorHandler(errorHandler);        validator.validate(new StreamSource(new ByteArrayInputStream(generateRuleSet("2.0.0").getBytes(StandardCharsets.UTF_8))));        assertTrue(errorHandler.isValid());        errorHandler.reset();    }    private Document parseWithVersion2(String ruleset) throws SAXException, ParserConfigurationException, IOException {        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        dbf.setNamespaceAware(true);        dbf.setFeature("http://apache.org/xml/features/validation/schema", true);        DocumentBuilder builder = dbf.newDocumentBuilder();        builder.setErrorHandler(errorHandler);        builder.setEntityResolver(new PMDRuleSetEntityResolver());        Document doc = builder.parse(new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.UTF_8)));        return doc;    }    private String generateRuleSet(String version) {        String versionUnderscore = version.replaceAll("\\.", "_");        String ruleset = "<?xml version=\"1.0\"?>" + PMD.EOL                + "<ruleset " + PMD.EOL                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/" + version + "\"" + PMD.EOL                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" + PMD.EOL                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/" + version + " https://pmd.sourceforge.io/ruleset_" + versionUnderscore + ".xsd\""                + "    name=\"Custom ruleset\" >" + PMD.EOL                + "  <description>" + PMD.EOL                + "  This ruleset checks my code for bad stuff" + PMD.EOL                + "  </description>" + PMD.EOL                + "  <rule name=\"DummyBasicMockRule\" language=\"dummy\" since=\"1.0\" message=\"Test Rule 1\"" + PMD.EOL                + "        class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL                + "        externalInfoUrl=\"${pmd.website.baseurl}/rules/dummy/basic.xml#DummyBasicMockRule\"" + PMD.EOL                + "  >" + PMD.EOL                + "        <description>" + PMD.EOL                + "           Just for test" + PMD.EOL                + "     </description>" + PMD.EOL                + "        <priority>3</priority>" + PMD.EOL                + "        <example>" + PMD.EOL                + " <![CDATA[" + PMD.EOL                + " ]]>" + PMD.EOL                + "     </example>" + PMD.EOL                + "    </rule>" + PMD.EOL                + "  <rule ref=\"rulesets/dummy/basic.xml#DummyBasicMockRule\"/>" + PMD.EOL                + "</ruleset>" + PMD.EOL;        return ruleset;    }    public static class PMDRuleSetEntityResolver implements EntityResolver {        private static URL schema2 = RuleSetFactory.class.getResource("/ruleset_2_0_0.xsd");        private static SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);        @Override        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {            if ("https://pmd.sourceforge.io/ruleset_2_0_0.xsd".equals(systemId)) {                return new InputSource(schema2.toExternalForm());            }            throw new IllegalArgumentException("Unable to resolve entity (publicId=" + publicId + ", systemId=" + systemId + ")");        }        public static Schema getSchemaVersion2() throws SAXException {            return schemaFactory.newSchema(schema2);        }    }    public static class CollectingErrorHandler implements ErrorHandler {        private List<SAXParseException> warnings = new ArrayList<>();        private List<SAXParseException> errors = new ArrayList<>();        private List<SAXParseException> fatalErrors = new ArrayList<>();        public boolean isValid() {            return warnings.isEmpty() && errors.isEmpty() && fatalErrors.isEmpty();        }        public List<SAXParseException> getWarnings() {            return warnings;        }        public List<SAXParseException> getErrors() {            return errors;        }        public List<SAXParseException> getFatalErrors() {            return fatalErrors;        }        @Override        public void warning(SAXParseException exception) throws SAXException {            warnings.add(exception);        }        @Override        public void error(SAXParseException exception) throws SAXException {            errors.add(exception);        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {            fatalErrors.add(exception);        }        @Override        public String toString() {            return "Warnings: " + warnings + "; Errors: " + errors + "; Fatal Errors: " + fatalErrors;        }        public void reset() {            warnings.clear();            errors.clear();            fatalErrors.clear();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageFilenameFilter;import net.sourceforge.pmd.lang.LanguageRegistry;/** * Tests on FileSelector. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be */public class FileSelectorTest {    /**     * Test wanted selection of a source file.     */    @Test    public void testWantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/myFile.dummy");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("This file should be selected !", true, selected);    }    /**     * Test unwanted selection of a non source file.     */    @Test    public void testUnwantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/myFile.txt");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("Not-source file must not be selected!", false, selected);    }    /**     * Test unwanted selection of a java file.     */    @Test    public void testUnwantedJavaFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/MyClass.java");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("Unwanted java file must not be selected!", false, selected);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collection;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;import junit.framework.JUnit4TestAdapter;@RunWith(Parameterized.class)public class ReadableDurationTest {    private Integer value;    private String expected;    public ReadableDurationTest(String expected, Integer value) {        this.value = value;        this.expected = expected;    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { "0s", 35 }, { "25s", (25 * 1000) }, { "5m 0s", (60 * 1000 * 5) },            { "2h 0m 0s", (60 * 1000 * 120) }, });    }    @Test    public void test() {        assertEquals(expected, new Report.ReadableDuration(value).getTime());    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(ReadableDurationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertSame;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Random;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class RuleViolationComparatorTest {    @Test    public void testComparator() {        Rule rule1 = new MockRule("name1", "desc", "msg", "rulesetname1");        Rule rule2 = new MockRule("name2", "desc", "msg", "rulesetname2");        // RuleViolations created in pre-sorted order        RuleViolation[] expectedOrder = new RuleViolation[12];        int index = 0;        // Different begin line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 20, "desc1", 0, 20, 80);        // Different description        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc2", 0, 20, 80);        // Different begin column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 10, 20, 80);        // Different end line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 0, 30, 80);        // Different end column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 0, 20, 90);        // Different rule name        expectedOrder[index++] = createJavaRuleViolation(rule1, "file6", 10, "desc1", 0, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule2, "file6", 10, "desc1", 0, 20, 80);        // Randomize        List<RuleViolation> ruleViolations = new ArrayList<>(Arrays.asList(expectedOrder));        long seed = System.nanoTime();        Random random = new Random(seed);        Collections.shuffle(ruleViolations, random);        // Sort        Collections.sort(ruleViolations, RuleViolationComparator.INSTANCE);        // Check        int count = 0;        for (int i = 0; i < expectedOrder.length; i++) {            count++;            assertSame("Wrong RuleViolation " + i + ", used seed: " + seed, expectedOrder[i], ruleViolations.get(i));        }        assertEquals("Missing assertion for every RuleViolation", expectedOrder.length, count);    }    private RuleViolation createJavaRuleViolation(Rule rule, String fileName, int beginLine, String description,            int beginColumn, int endLine, int endColumn) {        RuleContext ruleContext = new RuleContext();        ruleContext.setSourceCodeFile(new File(fileName));        DummyNode simpleNode = new DummyNode(1);        simpleNode.testingOnlySetBeginLine(beginLine);        simpleNode.testingOnlySetBeginColumn(beginColumn);        simpleNode.testingOnlySetEndLine(endLine);        simpleNode.testingOnlySetEndColumn(endColumn);        RuleViolation ruleViolation = new ParametricRuleViolation<Node>(rule, ruleContext, simpleNode, description);        return ruleViolation;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.StringProperty;public class RuleReferenceTest {    @Test    public void testRuleSetReference() {        RuleReference ruleReference = new RuleReference();        RuleSetReference ruleSetReference = new RuleSetReference("somename");        ruleReference.setRuleSetReference(ruleSetReference);        assertEquals("Not same rule set reference", ruleSetReference, ruleReference.getRuleSetReference());    }    @Test    public void testOverride() {        final StringProperty PROPERTY1_DESCRIPTOR = new StringProperty("property1", "Test property", null, 0f);        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final StringProperty PROPERTY2_DESCRIPTOR = new StringProperty("property2", "Test property", null, 0f);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverridenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, ruleReference);    }        @Test    public void testDeepCopyOverride() {        final StringProperty PROPERTY1_DESCRIPTOR = new StringProperty("property1", "Test property", null, 0f);        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final StringProperty PROPERTY2_DESCRIPTOR = new StringProperty("property2", "Test property", null, 0f);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverridenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, (RuleReference) ruleReference.deepCopy());    }    private void validateOverridenValues(final StringProperty propertyDescriptor1,            final StringProperty propertyDescriptor2, RuleReference ruleReference) {        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getOverriddenLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getOverriddenMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getMaximumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getOverriddenMaximumLanguageVersion());        assertEquals("Override failed", false, ruleReference.getRule().isDeprecated());        assertEquals("Override failed", true, ruleReference.isDeprecated());        assertEquals("Override failed", true, ruleReference.isOverriddenDeprecated());        assertEquals("Override failed", "name2", ruleReference.getName());        assertEquals("Override failed", "name2", ruleReference.getOverriddenName());        assertEquals("Override failed", "value2", ruleReference.getProperty(propertyDescriptor1));        assertEquals("Override failed", "value3", ruleReference.getProperty(propertyDescriptor2));        assertTrue("Override failed", ruleReference.getPropertyDescriptors().contains(propertyDescriptor1));        assertTrue("Override failed", ruleReference.getPropertyDescriptors().contains(propertyDescriptor2));        assertFalse("Override failed", ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor1));        assertTrue("Override failed", ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor2));        assertTrue("Override failed",                ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1));        assertTrue("Override failed",                ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2));        assertTrue("Override failed",                ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1));        assertTrue("Override failed",                ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2));        assertEquals("Override failed", "message2", ruleReference.getMessage());        assertEquals("Override failed", "message2", ruleReference.getOverriddenMessage());        assertEquals("Override failed", "description2", ruleReference.getDescription());        assertEquals("Override failed", "description2", ruleReference.getOverriddenDescription());        assertEquals("Override failed", 2, ruleReference.getExamples().size());        assertEquals("Override failed", "example1", ruleReference.getExamples().get(0));        assertEquals("Override failed", "example2", ruleReference.getExamples().get(1));        assertEquals("Override failed", "example2", ruleReference.getOverriddenExamples().get(0));        assertEquals("Override failed", "externalInfoUrl2", ruleReference.getExternalInfoUrl());        assertEquals("Override failed", "externalInfoUrl2", ruleReference.getOverriddenExternalInfoUrl());        assertEquals("Override failed", RulePriority.MEDIUM_HIGH, ruleReference.getPriority());        assertEquals("Override failed", RulePriority.MEDIUM_HIGH, ruleReference.getOverriddenPriority());    }    @Test    public void testNotOverride() {        final StringProperty PROPERTY1_DESCRIPTOR = new StringProperty("property1", "Test property", null, 0f);        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        rule.setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(false);        ruleReference.setName("name1");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value1");        ruleReference.setMessage("message1");        ruleReference.setDescription("description1");        ruleReference.addExample("example1");        ruleReference.setExternalInfoUrl("externalInfoUrl1");        ruleReference.setPriority(RulePriority.HIGH);        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getLanguage());        assertNull("Override failed", ruleReference.getOverriddenLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getMinimumLanguageVersion());        assertNull("Override failed", ruleReference.getOverriddenMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getMaximumLanguageVersion());        assertNull("Override failed", ruleReference.getOverriddenMaximumLanguageVersion());        assertEquals("Override failed", false, ruleReference.isDeprecated());        assertNull("Override failed", ruleReference.isOverriddenDeprecated());        assertEquals("Override failed", "name1", ruleReference.getName());        assertNull("Override failed", ruleReference.getOverriddenName());        assertEquals("Override failed", "value1", ruleReference.getProperty(PROPERTY1_DESCRIPTOR));        assertEquals("Override failed", "message1", ruleReference.getMessage());        assertNull("Override failed", ruleReference.getOverriddenMessage());        assertEquals("Override failed", "description1", ruleReference.getDescription());        assertNull("Override failed", ruleReference.getOverriddenDescription());        assertEquals("Override failed", 1, ruleReference.getExamples().size());        assertEquals("Override failed", "example1", ruleReference.getExamples().get(0));        assertNull("Override failed", ruleReference.getOverriddenExamples());        assertEquals("Override failed", "externalInfoUrl1", ruleReference.getExternalInfoUrl());        assertNull("Override failed", ruleReference.getOverriddenExternalInfoUrl());        assertEquals("Override failed", RulePriority.HIGH, ruleReference.getPriority());        assertNull("Override failed", ruleReference.getOverriddenPriority());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.io.ByteArrayOutputStream;import java.util.Random;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.rule.RuleReference;/** * Unit test for {@link RuleSetWriter}. * */public class RuleSetWriterTest {    private ByteArrayOutputStream out;    private RuleSetWriter writer;    /**     * Prepare the output stream.     */    @Before    public void setupOutputStream() {        out = new ByteArrayOutputStream();        writer = new RuleSetWriter(out);    }    /**     * Closes the output stream at the end.     */    @After    public void cleanupStream() {        if (writer != null) {            writer.close();        }    }    /**     * Tests the exclude rule behavior. See bug #945.     *     * @throws Exception     *             any error     */    @Test    public void testWrite() throws Exception {        RuleSet braces = new RuleSetFactory().createRuleSet("net/sourceforge/pmd/TestRuleset1.xml");        RuleSet ruleSet = new RuleSetBuilder(new Random().nextLong())                .withName("ruleset")                .withDescription("ruleset description")                .addRuleSetByReference(braces, true, "MockRule2")                .build();        writer.write(ruleSet);        String written = out.toString("UTF-8");        Assert.assertTrue(written.contains("<exclude name=\"MockRule2\""));    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     * @throws Exception     *             any error     */    @Test    public void testRuleReferenceOverriddenName() throws Exception {        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet rs = ruleSetFactory.createRuleSet("dummy-basic");        RuleSetReference ruleSetReference = new RuleSetReference("rulesets/dummy/basic.xml");        RuleReference ruleRef = new RuleReference();        ruleRef.setRule(rs.getRuleByName("DummyBasicMockRule"));        ruleRef.setRuleSetReference(ruleSetReference);        ruleRef.setName("Foo"); // override the name        RuleSet ruleSet = ruleSetFactory.createSingleRuleRuleSet(ruleRef);        writer.write(ruleSet);        String written = out.toString("UTF-8");        Assert.assertTrue(written.contains("ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\""));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sourceforge.pmd.properties.StringProperty;public class AbstractRuleTest {    public static class MyRule extends AbstractRule {        private static final StringProperty FOO_PROPERTY = new StringProperty("foo", "foo property", "x", 1.0f);        private static final PropertyDescriptor<String> FOO_DEFAULT_PROPERTY = PropertyFactory.stringProperty("fooDefault")                .defaultValue("bar")                .desc("Property without value uses default value")                .build();        private static final StringProperty XPATH_PROPERTY = new StringProperty("xpath", "xpath property", "", 2.0f);        public MyRule() {            definePropertyDescriptor(FOO_PROPERTY);            definePropertyDescriptor(XPATH_PROPERTY);            definePropertyDescriptor(FOO_DEFAULT_PROPERTY);            setName("MyRule");            setMessage("my rule msg");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {        }    }    private static class MyOtherRule extends AbstractRule {        private static final PropertyDescriptor FOO_PROPERTY = new StringProperty("foo", "foo property", "x", 1.0f);        MyOtherRule() {            definePropertyDescriptor(FOO_PROPERTY);            setName("MyOtherRule");            setMessage("my other rule");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(List<? extends Node> nodes, RuleContext ctx) {        }    }    @Test    public void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginColumn(5);        s.testingOnlySetBeginLine(5);        RuleViolation rv = new ParametricRuleViolation(r, ctx, s, r.getMessage());        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule msg mismatch!", "my rule msg", rv.getDescription());        assertEquals("RuleSet name mismatch!", "foo", rv.getRule().getRuleSetName());    }    @Test    public void testCreateRV2() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginColumn(5);        s.testingOnlySetBeginLine(5);        RuleViolation rv = new ParametricRuleViolation<>(r, ctx, s, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }    @Test    public void testRuleWithVariableInMessage() {        MyRule r = new MyRule();        r.definePropertyDescriptor(PropertyFactory.intProperty("testInt").desc("description").require(inRange(0, 100)).defaultValue(10).build());        r.setMessage("Message ${packageName} ${className} ${methodName} ${variableName} ${testInt} ${noSuchProperty}");        RuleContext ctx = new RuleContext();        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        ctx.setReport(new Report());        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyRoot();        s.setCoords(5, 1, 6, 0);        s.setImage("TestImage");        r.addViolation(ctx, s);        RuleViolation rv = ctx.getReport().getViolationTree().iterator().next();        assertEquals("Message foo    10 ${noSuchProperty}", rv.getDescription());    }    @Test    public void testRuleSuppress() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        Map<Integer, String> m = new HashMap<>();        m.put(5, "");        ctx.setSourceCodeFile(new File("filename"));        DummyRoot n = new DummyRoot(m);        n.setCoords(5, 1, 6, 0);        DefaultRuleViolationFactory.defaultInstance().addViolation(ctx, r, n, "specificdescription", new Object[0]);        assertTrue(ctx.getReport().isEmpty());    }    @Test    public void testEquals1() {        MyRule r = new MyRule();        assertFalse("A rule is never equals to null!", r.equals(null));    }    @Test    public void testEquals2() {        MyRule r = new MyRule();        assertEquals("A rule must be equals to itself", r, r);    }    @Test    public void testEquals3() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        assertEquals("Two instances of the same rule are equal", r1, r2);        assertEquals("Hashcode for two instances of the same rule must be equal", r1.hashCode(), r2.hashCode());    }    @Test    public void testEquals4() {        MyRule myRule = new MyRule();        assertFalse("A rule cannot be equal to an object of another class", myRule.equals("MyRule"));    }    @Test    public void testEquals5() {        MyRule myRule = new MyRule();        MyOtherRule myOtherRule = new MyOtherRule();        assertFalse("Two rules from different classes cannot be equal", myRule.equals(myOtherRule));    }    @Test    public void testEquals6() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setName("MyRule2");        assertFalse("Rules with different names cannot be equal", r1.equals(r2));    }    @Test    public void testEquals7() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setPriority(RulePriority.HIGH);        assertFalse("Rules with different priority levels cannot be equal", r1.equals(r2));    }    @Test    public void testEquals8() {        MyRule r1 = new MyRule();        r1.setProperty(MyRule.XPATH_PROPERTY, "something");        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse("Rules with different properties values cannot be equal", r1.equals(r2));    }    @Test    public void testEquals9() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse("Rules with different properties cannot be equal", r1.equals(r2));    }    @Test    public void testEquals10() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setMessage("another message");        assertEquals("Rules with different messages are still equal", r1, r2);        assertEquals("Rules that are equal must have the an equal hashcode", r1.hashCode(), r2.hashCode());    }    @Test    public void testDeepCopyRule() {        MyRule r1 = new MyRule();        MyRule r2 = (MyRule) r1.deepCopy();        assertEquals(r1.getDescription(), r2.getDescription());        assertEquals(r1.getExamples(), r2.getExamples());        assertEquals(r1.getExternalInfoUrl(), r2.getExternalInfoUrl());        assertEquals(r1.getLanguage(), r2.getLanguage());        assertEquals(r1.getMaximumLanguageVersion(), r2.getMaximumLanguageVersion());        assertEquals(r1.getMessage(), r2.getMessage());        assertEquals(r1.getMinimumLanguageVersion(), r2.getMinimumLanguageVersion());        assertEquals(r1.getName(), r2.getName());        assertEquals(r1.getPriority(), r2.getPriority());        assertEquals(r1.getPropertyDescriptors(), r2.getPropertyDescriptors());        assertEquals(r1.getRuleChainVisits(), r2.getRuleChainVisits());        assertEquals(r1.getRuleClass(), r2.getRuleClass());        assertEquals(r1.getRuleSetName(), r2.getRuleSetName());        assertEquals(r1.getSince(), r2.getSince());        assertEquals(r1.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY),                r2.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;import static com.github.tomakehurst.wiremock.client.WireMock.findAll;import static com.github.tomakehurst.wiremock.client.WireMock.get;import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.head;import static com.github.tomakehurst.wiremock.client.WireMock.headRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;import static com.github.tomakehurst.wiremock.client.WireMock.verify;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.util.ResourceLoader;import com.github.tomakehurst.wiremock.junit.WireMockRule;public class RuleSetReferenceIdTest {    private static void assertRuleSetReferenceId(final boolean expectedExternal, final String expectedRuleSetFileName,            final boolean expectedAllRules, final String expectedRuleName, final String expectedToString,            final RuleSetReferenceId reference) {        assertEquals("Wrong external", expectedExternal, reference.isExternal());        assertEquals("Wrong RuleSet file name", expectedRuleSetFileName, reference.getRuleSetFileName());        assertEquals("Wrong all Rule reference", expectedAllRules, reference.isAllRules());        assertEquals("Wrong Rule name", expectedRuleName, reference.getRuleName());        assertEquals("Wrong toString()", expectedToString, reference.toString());    }    @Test(expected = IllegalArgumentException.class)    public void testCommaInSingleId() {        new RuleSetReferenceId("bad,id");    }    @Test(expected = IllegalArgumentException.class)    public void testInternalWithInternal() {        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("SomeOtherRule"));    }    @Test(expected = IllegalArgumentException.class)    public void testExternalWithExternal() {        new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test(expected = IllegalArgumentException.class)    public void testExternalWithInternal() {        new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("SomeOtherRule"));    }    @Test    public void testInteralWithExternal() {        // This is okay        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test    public void testEmptyRuleSet() {        // This is representative of how the Test framework creates        // RuleSetReferenceId from static RuleSet XMLs        RuleSetReferenceId reference = new RuleSetReferenceId(null);        assertRuleSetReferenceId(true, null, true, null, "anonymous all Rule", reference);    }    @Test    public void testInternalWithExternalRuleSet() {        // This is representative of how the RuleSetFactory temporarily pairs an        // internal reference        // with an external reference.        RuleSetReferenceId internalRuleSetReferenceId = new RuleSetReferenceId("MockRuleName");        assertRuleSetReferenceId(false, null, false, "MockRuleName", "MockRuleName", internalRuleSetReferenceId);        RuleSetReferenceId externalRuleSetReferenceId = new RuleSetReferenceId("rulesets/java/basic.xml");        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                externalRuleSetReferenceId);        RuleSetReferenceId pairRuleSetReferenceId = new RuleSetReferenceId("MockRuleName", externalRuleSetReferenceId);        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "MockRuleName",                "rulesets/java/basic.xml/MockRuleName", pairRuleSetReferenceId);    }    @Test    public void testConstructorGivenHttpUrlIdSucceedsAndProcessesIdCorrectly() {        final String sonarRulesetUrlId = "http://localhost:54321/profiles/export?format=pmd&language=java&name=Sonar%2520way";        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + sonarRulesetUrlId + "  ");        assertRuleSetReferenceId(true, sonarRulesetUrlId, true, null, sonarRulesetUrlId, ruleSetReferenceId);    }    @org.junit.Rule    public WireMockRule wireMockRule = new WireMockRule(0);    @Test    public void testConstructorGivenHttpUrlInputStream() throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String rulesetUrl = "http://localhost:" + wireMockRule.port() + path;        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200)));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody("xyz")));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + rulesetUrl + "  ");        assertRuleSetReferenceId(true, rulesetUrl, true, null, rulesetUrl, ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtils.toString(inputStream, StandardCharsets.UTF_8);            assertEquals("xyz", loaded);        }        verify(1, headRequestedFor(urlEqualTo(path)));        verify(0, headRequestedFor(urlEqualTo("/profiles")));        verify(1, getRequestedFor(urlEqualTo(path)));        assertEquals(1, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    public void testConstructorGivenHttpUrlSingleRuleInputStream() throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String completePath = path + "/DummyBasicMockRule";        String hostpart = "http://localhost:" + wireMockRule.port();        String basicRuleSet = IOUtils                .toString(RuleSetReferenceId.class.getResourceAsStream("/rulesets/dummy/basic.xml"), StandardCharsets.UTF_8);        stubFor(head(urlEqualTo(completePath)).willReturn(aResponse().withStatus(404)));        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml")));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody(basicRuleSet)));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + hostpart + completePath + "  ");        assertRuleSetReferenceId(true, hostpart + path, false, "DummyBasicMockRule", hostpart + completePath,                ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtils.toString(inputStream, StandardCharsets.UTF_8);            assertEquals(basicRuleSet, loaded);        }        verify(1, headRequestedFor(urlEqualTo(completePath)));        verify(1, headRequestedFor(urlEqualTo(path)));        verify(1, getRequestedFor(urlEqualTo(path)));        verify(0, getRequestedFor(urlEqualTo(completePath)));        assertEquals(2, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    public void testOneSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));    }    @Test    public void testMultipleSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-unusedcode,dummy-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(1));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1201/     */    @Test    public void testMultipleRulesWithSpaces() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic, dummy-unusedcode, dummy2-basic");        assertEquals(3, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(1));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(2));    }    @Test    public void testOneReleaseRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("50");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/releases/50.xml", true, null, "rulesets/releases/50.xml",                references.get(0));    }    @Test    public void testOneFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));    }    @Test    public void testOneFullRuleSetURL() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("file://somepath/rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", true, null,                "file://somepath/rulesets/java/unusedcode.xml", references.get(0));    }    @Test    public void testMultipleFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("rulesets/java/unusedcode.xml,rulesets/java/basic.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                references.get(1));    }    @Test    public void testMixRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/dummy/unusedcode.xml,dummy2-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(1));    }    @Test    public void testUnknownRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("nonexistant.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(0));    }    @Test    public void testUnknownAndSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic,nonexistant.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(1));    }    @Test    public void testSimpleRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic/DummyBasicMockRule");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", false, "DummyBasicMockRule",                "rulesets/dummy/basic.xml/DummyBasicMockRule", references.get(0));    }    @Test    public void testFullRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/basic.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "EmptyCatchBlock",                "rulesets/java/basic.xml/EmptyCatchBlock", references.get(0));    }    @Test    public void testFullRuleSetURLAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", false, "EmptyCatchBlock",                "file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock", references.get(0));    }    @Test    public void testInternalRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(false, null, false, "EmptyCatchBlock", "EmptyCatchBlock", references.get(0));    }    @Test    public void testRelativePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "pmd/pmd-ruleset.xml", true, null, "pmd/pmd-ruleset.xml", references.get(0));    }    @Test    public void testAbsolutePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("/home/foo/pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "/home/foo/pmd/pmd-ruleset.xml", true, null, "/home/foo/pmd/pmd-ruleset.xml",                references.get(0));    }    @Test    public void testFooRules() throws Exception {        String fooRulesFile = new File("./src/test/resources/net/sourceforge/pmd/rulesets/foo-project/foo-rules")                .getCanonicalPath();        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(fooRulesFile);        assertEquals(1, references.size());        assertRuleSetReferenceId(true, fooRulesFile, true, null, fooRulesFile, references.get(0));    }    @Test    public void testNullRulesetString() throws Exception {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(null);        assertTrue(references.isEmpty());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(RuleSetReferenceIdTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.Set;import java.util.regex.Pattern;import org.junit.Test;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.util.CollectionUtil;public class RuleSetTest {    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresName() {        new RuleSetBuilder(new Random().nextLong())            .withName(null);    }    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresDescription() {        new RuleSetBuilder(new Random().nextLong())            .withName("some name")            .withDescription(null);    }    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresName2() {        new RuleSetBuilder(new Random().nextLong()).build();    }    @Test    public void testNoDFA() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        mock.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        RuleSet rs = new RuleSetFactory().createSingleRuleRuleSet(mock);        assertFalse(rs.usesDFA(LanguageRegistry.getLanguage(DummyLanguageModule.NAME)));    }    @Test    public void testIncludesRuleWithDFA() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        mock.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        mock.setDfa(true);        RuleSet rs = new RuleSetFactory().createSingleRuleRuleSet(mock);        assertTrue(rs.usesDFA(LanguageRegistry.getLanguage(DummyLanguageModule.NAME)));    }    @Test    public void testAccessors() {        RuleSet rs = new RuleSetBuilder(new Random().nextLong())                .withFileName("baz")                .withName("foo")                .withDescription("bar")                .build();        assertEquals("file name mismatch", "baz", rs.getFileName());        assertEquals("name mismatch", "foo", rs.getName());        assertEquals("description mismatch", "bar", rs.getDescription());    }    @Test    public void testGetRuleByName() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = new RuleSetFactory().createSingleRuleRuleSet(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    @Test    public void testGetRuleByName2() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = new RuleSetFactory().createSingleRuleRuleSet(mock);        assertNull("the rule FooRule must not be found!", rs.getRuleByName("FooRule"));    }    @Test    public void testRuleList() {        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet ruleset = new RuleSetFactory().createSingleRuleRuleSet(rule);        assertEquals("Size of RuleSet isn't one.", 1, ruleset.size());        Collection<Rule> rules = ruleset.getRules();        Iterator<Rule> i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    private RuleSetBuilder createRuleSetBuilder(String name) {        return new RuleSetBuilder(new Random().nextLong())                .withName(name)                .withDescription("Description for " + name);    }    @Test    public void testAddRuleSet() {        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet set2 = createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSet(set1)                .build();        assertEquals("ruleset size wrong", 2, set2.size());    }    @Test(expected = RuntimeException.class)    public void testAddRuleSetByReferenceBad() {        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSetByReference(set1, false)                .build();    }    @Test    public void testAddRuleSetByReferenceAllRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")                .withFileName("foo")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, true)                .build();        assertEquals("wrong rule size", 2, set1.getRules().size());        for (Rule rule : set1.getRules()) {            assertTrue("not a rule reference", rule instanceof RuleReference);            RuleReference ruleReference = (RuleReference) rule;            assertEquals("wrong ruleset file name", "foo", ruleReference.getRuleSetReference().getRuleSetFileName());            assertTrue("not all rule reference", ruleReference.getRuleSetReference().isAllRules());        }    }    @Test    public void testAddRuleSetByReferenceSingleRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")                .withFileName("foo")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, false)                .build();        assertEquals("wrong rule size", 2, set1.getRules().size());        for (Rule rule : set1.getRules()) {            assertTrue("not a rule reference", rule instanceof RuleReference);            RuleReference ruleReference = (RuleReference) rule;            assertEquals("wrong ruleset file name", "foo", ruleReference.getRuleSetReference().getRuleSetFileName());            assertFalse("should not be all rule reference", ruleReference.getRuleSetReference().isAllRules());        }    }    @Test    public void testApply0Rules() throws Exception {        RuleSet ruleset = createRuleSetBuilder("ruleset").build();        verifyRuleSet(ruleset, 0, new HashSet<RuleViolation>());    }    @Test    public void testEquals1() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertFalse("A ruleset cannot be equals to null", s.equals(null));    }    @Test    @SuppressWarnings("PMD.UseAssertEqualsInsteadOfAssertTrue")    public void testEquals2() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertTrue("A rulset must be equals to itself", s.equals(s));    }    @Test    public void testEquals3() {        RuleSet s = new RuleSetBuilder(new Random().nextLong())                .withName("basic rules")                .withDescription("desc")                .build();        assertFalse("A ruleset cannot be equals to another kind of object", s.equals("basic rules"));    }    @Test    public void testEquals4() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        assertEquals("2 rulesets with same name and rules must be equals", s1, s2);        assertEquals("Equals rulesets must have the same hashcode", s1.hashCode(), s2.hashCode());    }    @Test    public void testEquals5() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my other ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        assertFalse("2 rulesets with different name but same rules must not be equals", s1.equals(s2));    }    @Test    public void testEquals6() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("other rule", "desc", "msg", "rulesetname"))                .build();        assertFalse("2 rulesets with same name but different rules must not be equals", s1.equals(s2));    }    @Test    public void testLanguageApplies() {        Rule rule = new MockRule();        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertFalse("Different languages should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME).getDefaultVersion()));        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertTrue("Same language with no min/max should apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5")));        rule.setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5"));        assertTrue("Same language with valid min only should apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5")));        rule.setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.6"));        assertTrue("Same language with valid min and max should apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.5")));        assertFalse("Same language with outside range of min/max should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.4")));        assertFalse("Same language with outside range of min/max should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7")));    }    @Test    public void testAddExcludePattern() {        RuleSet ruleSet =            createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertEquals("Invalid number of patterns", 1, ruleSet.getExcludePatterns().size());    }    @Test    public void testExcludePatternAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(Pattern.compile(".*"))                .withFileExclusions(Pattern.compile(".*ha"))                .build();        assertEquals("Exclude pattern", Arrays.asList(".*", ".*ha"), ruleSet2.getExcludePatterns());    }    @Test    public void testIncludePatternsAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileInclusions(Pattern.compile(".*"))                .withFileInclusions(Arrays.asList(Pattern.compile(".*ha"), Pattern.compile(".*hb")))                .build();        assertEquals("Exclude pattern", Arrays.asList(".*", ".*ha", ".*hb"), ruleSet2.getIncludePatterns());    }    @Test    public void testAddExcludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of patterns", 1, ruleSet.getFileExclusions().size());        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(ruleSet.getFileExclusions())                .build();        assertNotNull("Exclude patterns", ruleSet2.getFileExclusions());        assertEquals("Invalid number of patterns", 1, ruleSet2.getFileExclusions().size());    }    @Test    public void testSetExcludePatterns() {        List<Pattern> excludePatterns = new ArrayList<>();        excludePatterns.add(Pattern.compile("ah*"));        excludePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset").replaceFileExclusions(excludePatterns).build();        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 2, ruleSet.getFileExclusions().size());        assertEquals("Exclude pattern", "ah*", ruleSet.getFileExclusions().get(0).pattern());        assertEquals("Exclude pattern", ".*", ruleSet.getFileExclusions().get(1).pattern());        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of include patterns", 0, ruleSet.getFileInclusions().size());    }    @Test    public void testAddIncludePattern() {        RuleSet ruleSet = createRuleSetBuilder("ruleset")                .withFileInclusions(Pattern.compile(".*"))                .build();        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of patterns", 1, ruleSet.getFileInclusions().size());        assertEquals("Include pattern", ".*", ruleSet.getFileInclusions().get(0).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testAddIncludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")                .withFileInclusions(Pattern.compile("ah*"), Pattern.compile(".*"))                .build();        RuleSet ruleSet2 = createRuleSetBuilder("ruleset1")                .withFileInclusions(ruleSet.getFileInclusions())                .build();        assertNotNull("Include patterns", ruleSet2.getFileInclusions());        assertEquals("Invalid number of patterns", 2, ruleSet2.getFileInclusions().size());        assertEquals("Include pattern", "ah*", ruleSet2.getFileInclusions().get(0).pattern());        assertEquals("Include pattern", ".*", ruleSet2.getFileInclusions().get(1).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testSetIncludePatterns() {        List<Pattern> includePatterns = new ArrayList<>();        includePatterns.add(Pattern.compile("ah*"));        includePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset")            .replaceFileInclusions(includePatterns)            .build();        assertEquals("Include patterns", includePatterns, ruleSet.getFileInclusions());        assertNotNull("Exclude patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testIncludeExcludeApplies() {        File file = new File("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java");        RuleSet ruleSet = createRuleSetBuilder("ruleset").build();        assertTrue("No patterns", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .build();        assertTrue("Non-matching exclude", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"), Pattern.compile(".*/package/.*"))                .build();        assertFalse("Matching exclude", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .build();        assertFalse("Non-matching include", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .withFileInclusions(Pattern.compile(".*/random/.*"))                .build();        assertTrue("Matching include", ruleSet.applies(file));    }    @Test    public void testIncludeExcludeMultipleRuleSetWithRuleChainApplies() throws PMDException {        File file = new File("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java");        Rule rule = new FooRule();        rule.setName("FooRule1");        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.addRuleChainVisit("dummyNode");        assertTrue("RuleChain rule", rule.isRuleChain());        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")                .addRule(rule)                .build();        RuleSet ruleSet2 = createRuleSetBuilder("RuleSet2")                .addRule(rule)                .build();        RuleSets ruleSets = new RuleSets();        ruleSets.addRuleSet(ruleSet1);        ruleSets.addRuleSet(ruleSet2);        // Two violations        RuleContext ctx = new RuleContext();        Report r = new Report();        ctx.setReport(r);        ctx.setSourceCodeFile(file);        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        ruleSets.apply(makeCompilationUnits(), ctx, LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertEquals("Violations", 2, r.size());        // One violation        ruleSet1 = createRuleSetBuilder("RuleSet1")                .withFileExclusions(Pattern.compile(".*/package/.*"))                .addRule(rule)                .build();        ruleSets = new RuleSets();        ruleSets.addRuleSet(ruleSet1);        ruleSets.addRuleSet(ruleSet2);        r = new Report();        ctx.setReport(r);        ruleSets.apply(makeCompilationUnits(), ctx, LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertEquals("Violations", 1, r.size());    }    @Test    public void copyConstructorDeepCopies() {        Rule rule = new FooRule();        rule.setName("FooRule1");        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.addRuleChainVisit("dummyNode");        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")                .addRule(rule)                .build();        RuleSet ruleSet2 = new RuleSet(ruleSet1);        assertEquals(ruleSet1, ruleSet2);        assertNotSame(ruleSet1, ruleSet2);        assertEquals(rule, ruleSet2.getRuleByName("FooRule1"));        assertNotSame(rule, ruleSet2.getRuleByName("FooRule1"));    }    private void verifyRuleSet(RuleSet ruleset, int size, Set<RuleViolation> values) {        RuleContext context = new RuleContext();        Set<RuleViolation> reportedValues = new HashSet<>();        context.setReport(new Report());        ruleset.apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().size());        Iterator<RuleViolation> violations = context.getReport().iterator();        while (violations.hasNext()) {            RuleViolation violation = violations.next();            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        Iterator<RuleViolation> expected = values.iterator();        while (expected.hasNext()) {            RuleViolation violation = expected.next();            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    private List<Node> makeCompilationUnits() {        List<Node> nodes = new ArrayList<>();        DummyNode node = new DummyRoot();        node.setCoords(1, 1, 10, 1);        node.setImage("Foo");        nodes.add(node);        return nodes;    }    @Test    public void ruleExceptionShouldBeReported() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")                .addRule(new MockRule() {                    @Override                    public void apply(List<? extends Node> nodes, RuleContext ctx) {                        throw new RuntimeException("Test exception while applying rule");                    }                })                .build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        ruleset.apply(makeCompilationUnits(), context);        assertTrue("Report should have processing errors", context.getReport().hasErrors());        List<ProcessingError> errors = CollectionUtil.toList(context.getReport().errors());        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);    }    @Test(expected = RuntimeException.class)    public void ruleExceptionShouldBeThrownIfNotIgnored() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")                .addRule(new MockRule() {                    @Override                    public void apply(List<? extends Node> nodes, RuleContext ctx) {                        throw new RuntimeException("Test exception while applying rule");                    }                })                .build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeThrownIfNotIgnored"));        context.setIgnoreExceptions(false);        ruleset.apply(makeCompilationUnits(), context);    }    @Test    public void ruleExceptionShouldNotStopProcessingFile() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                throw new RuntimeException("Test exception while applying rule");            }        }).addRule(new MockRule() {            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                for (Node node : nodes) {                    addViolationWithMessage(ctx, node, "Test violation of the second rule in the ruleset");                }            }        }).build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        ruleset.apply(makeCompilationUnits(), context);        assertTrue("Report should have processing errors", context.getReport().hasErrors());        List<ProcessingError> errors = CollectionUtil.toList(context.getReport().errors());        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);        assertEquals("There should be a violation", 1, context.getReport().size());    }    @Test    public void ruleExceptionShouldNotStopProcessingFileWithRuleChain() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            {                addRuleChainVisit("dummyNode");            }            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                throw new RuntimeException("Test exception while applying rule");            }        }).addRule(new MockRule() {            {                addRuleChainVisit("dummyNode");            }            @Override            public void apply(List<? extends Node> nodes, RuleContext ctx) {                for (Node node : nodes) {                    addViolationWithMessage(ctx, node, "Test violation of the second rule in the ruleset");                }            }        }).build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        RuleSets rulesets = new RuleSets(ruleset);        rulesets.apply(makeCompilationUnits(), context, LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        assertTrue("Report should have processing errors", context.getReport().hasErrors());        List<ProcessingError> errors = CollectionUtil.toList(context.getReport().errors());        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);        assertEquals("There should be a violation", 1, context.getReport().size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.io.StringWriter;import java.util.Iterator;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;public class ReportTest implements ThreadSafeReportListener {    private boolean violationSemaphore;    @Override    public void ruleViolationAdded(RuleViolation ruleViolation) {        violationSemaphore = true;    }    // Files are grouped together now.    @Test    public void testSortedReportFile() throws IOException {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("foo"));        Node s = getNode(10, 5);        Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule1, ctx, s, rule1.getMessage()));        ctx.setSourceCodeFile(new File("bar"));        Node s1 = getNode(10, 5);        Rule rule2 = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule2, ctx, s1, rule2.getMessage()));        Renderer rend = new XMLRenderer();        String result = render(rend, r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    @Test    public void testSortedReportLine() throws IOException {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("foo1")); // same file!!        Node node1 = getNode(20, 5); // line 20: after rule2 violation        Rule rule1 = new MockRule("rule1", "rule1", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule1, ctx, node1, rule1.getMessage()));        ctx.setSourceCodeFile(new File("foo1")); // same file!!        Node node2 = getNode(10, 5); // line 10: before rule1 violation        Rule rule2 = new MockRule("rule2", "rule2", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule2, ctx, node2, rule2.getMessage()));        Renderer rend = new XMLRenderer();        String result = render(rend, r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    @Test    public void testListener() {        Report rpt = new Report();        rpt.addListener(this);        violationSemaphore = false;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("file"));        Node s = getNode(5, 5);        Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");        rpt.addRuleViolation(new ParametricRuleViolation<>(rule1, ctx, s, rule1.getMessage()));        assertTrue(violationSemaphore);    }    @Test    public void testSummary() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("foo1"));        Node s = getNode(5, 5);        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule, ctx, s, rule.getMessage()));        ctx.setSourceCodeFile(new File("foo2"));        Rule mr = new MockRule("rule1", "rule1", "msg", "rulesetname");        Node s1 = getNode(20, 5);        Node s2 = getNode(30, 5);        r.addRuleViolation(new ParametricRuleViolation<>(mr, ctx, s1, mr.getMessage()));        r.addRuleViolation(new ParametricRuleViolation<>(mr, ctx, s2, mr.getMessage()));        Map<String, Integer> summary = r.getSummary();        assertEquals(summary.keySet().size(), 2);        assertTrue(summary.values().contains(Integer.valueOf(1)));        assertTrue(summary.values().contains(Integer.valueOf(2)));    }    @Test    public void testTreeIterator() {        Report r = new Report();        RuleContext ctx = new RuleContext();        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Node node1 = getNode(5, 5, true);        r.addRuleViolation(new ParametricRuleViolation<>(rule, ctx, node1, rule.getMessage()));        Node node2 = getNode(5, 6, true);        r.addRuleViolation(new ParametricRuleViolation<>(rule, ctx, node2, rule.getMessage()));        Iterator<RuleViolation> violations = r.iterator();        int violationCount = 0;        while (violations.hasNext()) {            violations.next();            violationCount++;        }        assertEquals(2, violationCount);        Iterator<RuleViolation> treeIterator = r.treeIterator();        int treeCount = 0;        while (treeIterator.hasNext()) {            treeIterator.next();            treeCount++;        }        assertEquals(2, treeCount);    }    private static Node getNode(int line, int column) {        DummyNode s = new DummyNode(2);        DummyNode parent = new DummyNode(1);        parent.testingOnlySetBeginLine(line);        parent.testingOnlySetBeginColumn(column);        s.jjtSetParent(parent);        s.testingOnlySetBeginLine(line);        s.testingOnlySetBeginColumn(column);        return s;    }    private static Node getNode(int line, int column, boolean nextLine) {        DummyNode s = (DummyNode) getNode(line, column);        if (nextLine) {            s.testingOnlySetBeginLine(line + 1);            s.testingOnlySetBeginColumn(column + 4);        }        return s;    }    public static String render(Renderer renderer, Report report) throws IOException {        StringWriter writer = new StringWriter();        renderer.setWriter(writer);        renderer.start();        renderer.renderFileReport(report);        renderer.end();        return writer.toString();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.junit.LocaleRule;public class RuleSetFactoryDuplicatedRuleLoggingTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    @org.junit.Rule    public LocaleRule localeRule = LocaleRule.en();    @org.junit.Rule    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());    @Test    public void duplicatedRuleReferenceShouldWarn() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("duplicatedRuleReference.xml");        assertEquals(1, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.MEDIUM, mockRule.getPriority());        assertTrue(logging.getLog().contains("The rule DummyBasicMockRule is referenced multiple times in \"Custom Rules\". "                + "Only the last rule configuration is used."));    }    @Test    public void duplicatedRuleReferenceWithOverrideShouldNotWarn() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("duplicatedRuleReferenceWithOverride.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    @Test    public void duplicatedRuleReferenceWithOverrideBeforeShouldNotWarn() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("duplicatedRuleReferenceWithOverrideBefore.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    @Test    public void multipleDuplicates() throws RuleSetNotFoundException {        RuleSet ruleset = loadRuleSet("multipleDuplicates.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.MEDIUM_HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().contains("The rule DummyBasicMockRule is referenced multiple times in \"Custom Rules\". "                + "Only the last rule configuration is used."));        assertTrue(logging.getLog().contains("The ruleset rulesets/dummy/basic.xml is referenced multiple times in \"Custom Rules\"."));    }    private RuleSet loadRuleSet(String ruleSetFilename) throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory();        return rsf.createRuleSet("net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/" + ruleSetFilename);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cache.FileAnalysisCache;import net.sourceforge.pmd.cache.NoopAnalysisCache;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.util.ClasspathClassLoader;public class ConfigurationTest {    @Test    public void testSuppressMarker() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default suppress marker", PMD.SUPPRESS_MARKER, configuration.getSuppressMarker());        configuration.setSuppressMarker("CUSTOM_MARKER");        assertEquals("Changed suppress marker", "CUSTOM_MARKER", configuration.getSuppressMarker());    }    @Test    public void testThreads() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default threads", Runtime.getRuntime().availableProcessors(), configuration.getThreads());        configuration.setThreads(0);        assertEquals("Changed threads", 0, configuration.getThreads());    }    @Test    public void testClassLoader() throws IOException {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default ClassLoader", PMDConfiguration.class.getClassLoader(), configuration.getClassLoader());        configuration.prependClasspath("some.jar");        assertEquals("Prepended ClassLoader class", ClasspathClassLoader.class,                configuration.getClassLoader().getClass());        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        assertEquals("urls length", 1, urls.length);        assertTrue("url[0]", urls[0].toString().endsWith("/some.jar"));        assertEquals("parent classLoader", PMDConfiguration.class.getClassLoader(),                configuration.getClassLoader().getParent());        configuration.setClassLoader(null);        assertEquals("Revert to default ClassLoader", PMDConfiguration.class.getClassLoader(),                configuration.getClassLoader());    }    @Test    public void testRuleSets() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default RuleSets", null, configuration.getRuleSets());        configuration.setRuleSets("/rulesets/basic.xml");        assertEquals("Changed RuleSets", "/rulesets/basic.xml", configuration.getRuleSets());    }    @Test    public void testMinimumPriority() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default minimum priority", RulePriority.LOW, configuration.getMinimumPriority());        configuration.setMinimumPriority(RulePriority.HIGH);        assertEquals("Changed minimum priority", RulePriority.HIGH, configuration.getMinimumPriority());    }    @Test    public void testSourceEncoding() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default source encoding", System.getProperty("file.encoding"), configuration.getSourceEncoding().name());        configuration.setSourceEncoding(StandardCharsets.UTF_16LE.name());        assertEquals("Changed source encoding", StandardCharsets.UTF_16LE, configuration.getSourceEncoding());    }    @Test    public void testInputPaths() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default input paths", null, configuration.getInputPaths());        configuration.setInputPaths("a,b,c");        assertEquals("Changed input paths", "a,b,c", configuration.getInputPaths());    }    @Test    public void testReportShortNames() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report short names", false, configuration.isReportShortNames());        configuration.setReportShortNames(true);        assertEquals("Changed report short names", true, configuration.isReportShortNames());    }    @Test    public void testReportFormat() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report format", null, configuration.getReportFormat());        configuration.setReportFormat("csv");        assertEquals("Changed report format", "csv", configuration.getReportFormat());    }    @Test    public void testCreateRenderer() {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setReportFormat("csv");        Renderer renderer = configuration.createRenderer();        assertEquals("Renderer class", CSVRenderer.class, renderer.getClass());        assertEquals("Default renderer show suppressed violations", false, renderer.isShowSuppressedViolations());        configuration.setShowSuppressedViolations(true);        renderer = configuration.createRenderer();        assertEquals("Renderer class", CSVRenderer.class, renderer.getClass());        assertEquals("Changed renderer show suppressed violations", true, renderer.isShowSuppressedViolations());    }    @Test    public void testReportFile() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report file", null, configuration.getReportFile());        configuration.setReportFile("somefile");        assertEquals("Changed report file", "somefile", configuration.getReportFile());    }    @Test    public void testShowSuppressedViolations() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default show suppressed violations", false, configuration.isShowSuppressedViolations());        configuration.setShowSuppressedViolations(true);        assertEquals("Changed show suppressed violations", true, configuration.isShowSuppressedViolations());    }    @Test    public void testReportProperties() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report properties size", 0, configuration.getReportProperties().size());        configuration.getReportProperties().put("key", "value");        assertEquals("Changed report properties size", 1, configuration.getReportProperties().size());        assertEquals("Changed report properties value", "value", configuration.getReportProperties().get("key"));        configuration.setReportProperties(new Properties());        assertEquals("Replaced report properties size", 0, configuration.getReportProperties().size());    }    @Test    public void testDebug() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default debug", false, configuration.isDebug());        configuration.setDebug(true);        assertEquals("Changed debug", true, configuration.isDebug());    }    @Test    public void testStressTest() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default stress test", false, configuration.isStressTest());        configuration.setStressTest(true);        assertEquals("Changed stress test", true, configuration.isStressTest());    }    @Test    public void testBenchmark() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default benchmark", false, configuration.isBenchmark());        configuration.setBenchmark(true);        assertEquals("Changed benchmark", true, configuration.isBenchmark());    }    @Test    public void testAnalysisCache() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        assertNotNull("Default cache is null", configuration.getAnalysisCache());        assertTrue("Default cache is not a noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setAnalysisCache(null);        assertNotNull("Default cache was set to null", configuration.getAnalysisCache());        final File cacheFile = File.createTempFile("pmd-", ".cache");        cacheFile.deleteOnExit();        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertSame("Confgured cache not stored", analysisCache, configuration.getAnalysisCache());    }    @Test    public void testAnalysisCacheLocation() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        configuration.setAnalysisCacheLocation(null);        assertNotNull("Null cache location accepted", configuration.getAnalysisCache());        assertTrue("Null cache location accepted", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setAnalysisCacheLocation("pmd.cache");        assertNotNull("Not null cache location produces null cache", configuration.getAnalysisCache());        assertTrue("File cache location doesn't produce a file cache",                configuration.getAnalysisCache() instanceof FileAnalysisCache);    }    @Test    public void testIgnoreIncrementalAnalysis() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        // set dummy cache location        final File cacheFile = File.createTempFile("pmd-", ".cache");        cacheFile.deleteOnExit();        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertNotNull("Null cache location accepted", configuration.getAnalysisCache());        assertFalse("Non null cache location, cache should not be noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setIgnoreIncrementalAnalysis(true);        assertTrue("Ignoring incremental analysis should turn the cache into a noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.util.Arrays;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.lang3.StringUtils;import org.hamcrest.Matchers;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.junit.LocaleRule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.ResourceLoader;public class RuleSetFactoryTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    @org.junit.Rule    public LocaleRule localeRule = LocaleRule.en();    @Test    public void testRuleSetFileName() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertNull("RuleSet file name not expected", rs.getFileName());        RuleSetFactory rsf = new RuleSetFactory();        rs = rsf.createRuleSet("net/sourceforge/pmd/TestRuleset1.xml");        assertEquals("wrong RuleSet file name", rs.getFileName(), "net/sourceforge/pmd/TestRuleset1.xml");    }    @Test    public void testNoRuleSetFileName() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertNull("RuleSet file name not expected", rs.getFileName());    }    @Test    public void testRefs() throws Exception {        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet("net/sourceforge/pmd/TestRuleset1.xml");        assertNotNull(rs.getRuleByName("TestRuleRef"));    }    @Test    public void testExtendedReferences() throws Exception {        InputStream in = new ResourceLoader().loadClassPathResourceAsStream("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        assertNotNull("Test ruleset not found - can't continue with test!", in);        in.close();        RuleSetFactory rsf = new RuleSetFactory();        RuleSets rs = rsf.createRuleSets("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        // added by referencing a complete ruleset (TestRuleset1.xml)        assertNotNull(rs.getRuleByName("MockRule1"));        assertNotNull(rs.getRuleByName("MockRule2"));        assertNotNull(rs.getRuleByName("MockRule3"));        assertNotNull(rs.getRuleByName("TestRuleRef"));        // added by specific reference        assertNotNull(rs.getRuleByName("TestRule"));        // this is from TestRuleset2.xml, but not referenced        assertNull(rs.getRuleByName("TestRule2Ruleset2"));        Rule mockRule3 = rs.getRuleByName("MockRule3");        assertEquals("Overridden message", mockRule3.getMessage());        assertEquals(2, mockRule3.getPriority().getPriority());        Rule mockRule2 = rs.getRuleByName("MockRule2");        assertEquals("Just combine them!", mockRule2.getMessage());        // assert that MockRule2 is only once added to the ruleset, so that it        // really        // overwrites the configuration inherited from TestRuleset1.xml        assertEquals(1, countRule(rs, "MockRule2"));        Rule mockRule1 = rs.getRuleByName("MockRule1");        assertNotNull(mockRule1);        PropertyDescriptor<?> prop = mockRule1.getPropertyDescriptor("testIntProperty");        Object property = mockRule1.getProperty(prop);        assertEquals("5", String.valueOf(property));        // included from TestRuleset3.xml        assertNotNull(rs.getRuleByName("Ruleset3Rule2"));        // excluded from TestRuleset3.xml        assertNull(rs.getRuleByName("Ruleset3Rule1"));        // overridden to 5        Rule ruleset4Rule1 = rs.getRuleByName("Ruleset4Rule1");        assertNotNull(ruleset4Rule1);        assertEquals(5, ruleset4Rule1.getPriority().getPriority());        assertEquals(1, countRule(rs, "Ruleset4Rule1"));        // priority overridden for whole TestRuleset4 group        Rule ruleset4Rule2 = rs.getRuleByName("Ruleset4Rule2");        assertNotNull(ruleset4Rule2);        assertEquals(2, ruleset4Rule2.getPriority().getPriority());    }    private int countRule(RuleSets rs, String ruleName) {        int count = 0;        for (Rule r : rs.getAllRules()) {            if (ruleName.equals(r.getName())) {                count++;            }        }        return count;    }    @Test(expected = RuleSetNotFoundException.class)    public void testRuleSetNotFound() throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory();        rsf.createRuleSet("fooooo");    }    @Test    public void testCreateEmptyRuleSet() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    @Test    public void testSingleRule() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(SINGLE_RULE);        assertEquals(1, rs.size());        Rule r = rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("net.sourceforge.pmd.lang.rule.MockRule", r.getRuleClass());        assertEquals("avoid the mock rule", r.getMessage());    }    @Test    public void testMultipleRules() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(MULTIPLE_RULES);        assertEquals(2, rs.size());        Set<String> expected = new HashSet<>();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Rule rule : rs.getRules()) {            assertTrue(expected.contains(rule.getName()));        }    }    @Test    public void testSingleRuleWithPriority() throws RuleSetNotFoundException {        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());    }    @Test    @SuppressWarnings("unchecked")    public void testProps() throws RuleSetNotFoundException {        Rule r = loadFirstRule(PROPERTIES);        assertEquals("bar", r.getProperty((PropertyDescriptor<String>) r.getPropertyDescriptor("fooString")));        assertEquals(new Integer(3), r.getProperty((PropertyDescriptor<Integer>) r.getPropertyDescriptor("fooInt")));        assertTrue(r.getProperty((PropertyDescriptor<Boolean>) r.getPropertyDescriptor("fooBoolean")));        assertEquals(3.0d, r.getProperty((PropertyDescriptor<Double>) r.getPropertyDescriptor("fooDouble")), 0.05);        assertNull(r.getPropertyDescriptor("BuggleFish"));        assertNotSame(r.getDescription().indexOf("testdesc2"), -1);    }    @Test    public void testStringMultiPropertyDefaultDelimiter() throws Exception {        Rule r = loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ruleset name=\"the ruleset\">\n  <description>Desc</description>\n"                                   + "     <rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s instead.\" \n"                                   + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                                   + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                                   + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                                   + " value=\"com.aptsssss|com.abc\" \ntype=\"List[String]\" "                                   + "description=\"valid packages\"/>\n         </properties></rule></ruleset>");        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor("packageRegEx");        List<String> values = r.getProperty(prop);        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), values);    }    @Test    public void testStringMultiPropertyDelimiter() throws Exception {        Rule r = loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n "                                   + " <description>ruleset desc</description>\n     "                                   + "<rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s"                                   + " instead.\" \n" + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                                   + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                                   + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                                   + " value=\"com.aptsssss,com.abc\" \ntype=\"List[String]\" delimiter=\",\" "                                   + "description=\"valid packages\"/>\n"                                   + "         </properties></rule>" + "</ruleset>");        PropertyDescriptor<List<String>> prop = (PropertyDescriptor<List<String>>) r.getPropertyDescriptor("packageRegEx");        List<String> values = r.getProperty(prop);        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), values);    }    @Test    public void testRuleSetWithDeprecatedRule() throws Exception {        RuleSet rs = loadRuleSet("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"ruleset\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule deprecated=\"true\" ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\"/>"                + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("DummyBasicMockRule");        assertNotNull(rule);    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole, we shouldn't get a deprecation warning. The deprecated     * rule reference should be ignored, so at the end, we only have the new rule name in the ruleset.     * This is because the deprecated reference points to a rule in the same ruleset.     *     * @throws Exception     */    @Test    public void testRuleSetWithDeprecatedButRenamedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                + "         <description>d</description>\n" + "         <priority>2</priority>\n" + "     </rule>"                + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("NewName");        assertNotNull(rule);        assertNull(rs.getRuleByName("OldName"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a rule, that has been renamed.     * The user should get a deprecation warning.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesADeprecatedRenamedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule\"/>" + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("OldNameOfDummyBasicMockRule");        assertNotNull(rule);        assertEquals(1,            StringUtils.countMatches(logging.getLog(),                "WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule."));    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Although the referenced ruleset contains     * a deprecated rule, there should be no warning about it, because all deprecated rules are ignored,     * if a whole ruleset is referenced.     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesRulesetWithADeprecatedRenamedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"/>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule. The deprecated     * rule is excluded.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Since the deprecated rule is excluded,     * there should be no deprecation warning at all, although the deprecated ruleset would have been     * excluded by default (without explictly excluding it).     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesRulesetWithAExcludedDeprecatedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"DeprecatedRule\"/></rule>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     * There is a exclusion of a rule, that no longer exists.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset.     * Since the rule to be excluded doesn't exist, there should be a warning about that.     *     * @throws Exception     */    @Test    public void testRuleSetReferencesRulesetWithAExcludedNonExistingRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"NonExistingRule\"/></rule>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertEquals(0,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Discontinue using Rule rulesets/dummy/basic.xml/DeprecatedRule as it is scheduled for removal from PMD."));        assertEquals(1,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Unable to exclude rules [NonExistingRule] from ruleset reference rulesets/dummy/basic.xml; perhaps the rule name is mispelled or the rule doesn't exist anymore?"));    }    /**     * When a custom ruleset references a ruleset that only contains deprecated rules, then this ruleset itself is     * considered deprecated and the user should get a deprecation warning for the ruleset.     */    @Test    public void testRuleSetReferencesDeprecatedRuleset() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/deprecated.xml\" />" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertEquals(1,                StringUtils.countMatches(logging.getLog(),                    "WARNING: The RuleSet rulesets/dummy/deprecated.xml has been deprecated and will be removed in PMD"));    }    /**     * When a custom ruleset references a ruleset that contains both rules and rule references, that are left     * for backwards compatibility, because the rules have been moved to a different ruleset, then there should be     * no warning about deprecation - since the deprecated rules are not used.     */    @Test    public void testRuleSetReferencesRulesetWithAMovedRule() throws Exception {        RuleSet rs = loadRuleSetWithDeprecationWarnings("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic2.xml\" />" + "</ruleset>");        assertEquals(1, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasic2MockRule"));        assertEquals(0,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic2.xml/DummyBasicMockRule. PMD"));    }    @Test    @SuppressWarnings("unchecked")    public void testXPath() throws RuleSetNotFoundException {        Rule r = loadFirstRule(XPATH);        PropertyDescriptor<String> xpathProperty = (PropertyDescriptor<String>) r.getPropertyDescriptor("xpath");        assertNotNull("xpath property descriptor", xpathProperty);        assertNotSame(r.getProperty(xpathProperty).indexOf(" //Block "), -1);    }    @Test    public void testFacadesOffByDefault() throws RuleSetNotFoundException {        Rule r = loadFirstRule(XPATH);        assertFalse(r.isDfa());    }    @Test    public void testDFAFlag() throws RuleSetNotFoundException {        assertTrue(loadFirstRule(DFA).isDfa());    }    @Test    public void testExternalReferenceOverride() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REF_OVERRIDE);        assertEquals("TestNameOverride", r.getName());        assertEquals("Test message override", r.getMessage());        assertEquals("Test description override", r.getDescription());        assertEquals("Test that both example are stored", 2, r.getExamples().size());        assertEquals("Test example override", r.getExamples().get(1));        assertEquals(RulePriority.MEDIUM, r.getPriority());        PropertyDescriptor<?> test2Descriptor = r.getPropertyDescriptor("test2");        assertNotNull("test2 descriptor", test2Descriptor);        assertEquals("override2", r.getProperty(test2Descriptor));        PropertyDescriptor<?> test3Descriptor = r.getPropertyDescriptor("test3");        assertNotNull("test3 descriptor", test3Descriptor);        assertEquals("override3", r.getProperty(test3Descriptor));    }    @Test    public void testExternalReferenceOverrideNonExistent() throws RuleSetNotFoundException {        ex.expect(IllegalArgumentException.class);        ex.expectMessage("Cannot set non-existent property 'test4' on Rule TestNameOverride");        loadFirstRule(REF_OVERRIDE_NONEXISTENT);    }    @Test    public void testReferenceInternalToInternal() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull("Could not find Rule MockRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull("Could not find Rule MockRuleNameRef", ruleRef);    }    @Test    public void testReferenceInternalToInternalChain() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull("Could not find Rule MockRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull("Could not find Rule MockRuleNameRef", ruleRef);        Rule ruleRefRef = ruleSet.getRuleByName("MockRuleNameRefRef");        assertNotNull("Could not find Rule MockRuleNameRefRef", ruleRefRef);    }    @Test    public void testReferenceInternalToExternal() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull("Could not find Rule ExternalRefRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRef", ruleRef);    }    @Test    public void testReferenceInternalToExternalChain() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull("Could not find Rule ExternalRefRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRef", ruleRef);        Rule ruleRefRef = ruleSet.getRuleByName("ExternalRefRuleNameRefRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRefRef", ruleRefRef);    }    @Test    public void testReferencePriority() throws RuleSetNotFoundException {        ResourceLoader rl = new ResourceLoader();        RuleSetFactory rsf = new RuleSetFactory(rl, RulePriority.LOW, false, true);        RuleSet ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));        assertEquals("Number of Rules", 3, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleName"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));        assertEquals("Number of Rules", 2, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = new RuleSetFactory(rl, RulePriority.HIGH, false, true);        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_INTERNAL_CHAIN));        assertEquals("Number of Rules", 1, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = new RuleSetFactory(rl, RulePriority.LOW, false, true);        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));        assertEquals("Number of Rules", 3, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleName"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));        assertEquals("Number of Rules", 2, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rsf = new RuleSetFactory(rl, RulePriority.HIGH, false, true);        ruleSet = rsf.createRuleSet(createRuleSetReferenceId(REF_INTERNAL_TO_EXTERNAL_CHAIN));        assertEquals("Number of Rules", 1, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));    }    @Test    public void testOverridePriorityLoadWithMinimum() throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.MEDIUM_LOW, true, true);        RuleSet ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        // only one rule should remain, since we filter out the other rule by minimum priority        assertEquals("Number of Rules", 1, ruleset.getRules().size());        // Priority is overridden and applied, rule is missing        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        // now, load with default minimum priority        rsf = new RuleSetFactory();        ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        assertEquals("Number of Rules", 2, ruleset.getRules().size());        Rule dummyBasicMockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertEquals("Wrong Priority", RulePriority.LOW, dummyBasicMockRule.getPriority());    }    @Test    public void testExcludeWithMinimumPriority() throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.HIGH, true, true);        RuleSet ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // no rules should be loaded        assertEquals("Number of Rules", 0, ruleset.getRules().size());        // now, load with default minimum priority        rsf = new RuleSetFactory();        ruleset = rsf.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // only one rule, we have excluded one...        assertEquals("Number of Rules", 1, ruleset.getRules().size());        // rule is excluded        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));    }    @Test    public void testOverrideMessage() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test    public void testOverrideMessageOneElem() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectExternalRef() throws IllegalArgumentException, RuleSetNotFoundException {        loadFirstRule(REF_MISPELLED_XREF);    }    @Test    public void testSetPriority() throws RuleSetNotFoundException {        ResourceLoader rl = new ResourceLoader();        RuleSetFactory rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_HIGH, false, true);        assertEquals(0, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());        rsf = new RuleSetFactory(rl, RulePriority.MEDIUM_LOW, false, true);        assertEquals(1, rsf.createRuleSet(createRuleSetReferenceId(SINGLE_RULE)).size());    }    @Test    public void testLanguage() throws RuleSetNotFoundException {        Rule r = loadFirstRule(LANGUAGE);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME), r.getLanguage());    }    @Test(expected = IllegalArgumentException.class)    public void testIncorrectLanguage() throws RuleSetNotFoundException {        loadFirstRule(INCORRECT_LANGUAGE);    }    @Test    public void testMinimumLanguageVersion() throws RuleSetNotFoundException {        Rule r = loadFirstRule(MINIMUM_LANGUAGE_VERSION);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.4"),                r.getMinimumLanguageVersion());    }    @Test    public void testIncorrectMinimumLanguageVersion() throws RuleSetNotFoundException {        ex.expect(IllegalArgumentException.class);        ex.expectMessage(Matchers.containsString("1.0, 1.1, 1.2")); // and not "dummy 1.0, dummy 1.1, ..."        loadFirstRule(INCORRECT_MINIMUM_LANGUAGE_VERSION);    }    @Test    public void testMaximumLanguageVersion() throws RuleSetNotFoundException {        Rule r = loadFirstRule(MAXIMUM_LANGUAGE_VERSION);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                r.getMaximumLanguageVersion());    }    @Test    public void testIncorrectMaximumLanguageVersion() throws RuleSetNotFoundException {        ex.expect(IllegalArgumentException.class);        ex.expectMessage(Matchers.containsString("1.0, 1.1, 1.2")); // and not "dummy 1.0, dummy 1.1, ..."        loadFirstRule(INCORRECT_MAXIMUM_LANGUAGE_VERSION);    }    @Test(expected = IllegalArgumentException.class)    public void testInvertedMinimumMaximumLanguageVersions() throws RuleSetNotFoundException {        loadFirstRule(INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS);    }    @Test    public void testDirectDeprecatedRule() throws RuleSetNotFoundException {        Rule r = loadFirstRule(DIRECT_DEPRECATED_RULE);        assertNotNull("Direct Deprecated Rule", r);        assertTrue(r.isDeprecated());    }    @Test    public void testReferenceToDeprecatedRule() throws RuleSetNotFoundException {        Rule r = loadFirstRule(REFERENCE_TO_DEPRECATED_RULE);        assertNotNull("Reference to Deprecated Rule", r);        assertTrue("Rule Reference", r instanceof RuleReference);        assertFalse("Not deprecated", r.isDeprecated());        assertTrue("Original Rule Deprecated", ((RuleReference) r).getRule().isDeprecated());        assertEquals("Rule name", r.getName(), DEPRECATED_RULE_NAME);    }    @Test    public void testRuleSetReferenceWithDeprecatedRule() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE);        assertNotNull("RuleSet", ruleSet);        assertFalse("RuleSet empty", ruleSet.getRules().isEmpty());        // No deprecated Rules should be loaded when loading an entire RuleSet        // by reference - unless it contains only deprecated rules - then all rules would be added        Rule r = ruleSet.getRuleByName(DEPRECATED_RULE_NAME);        assertNull("Deprecated Rule Reference", r);        for (Rule rule : ruleSet.getRules()) {            assertFalse("Rule not deprecated", rule.isDeprecated());        }    }    @Test    public void testDeprecatedRuleSetReference() throws RuleSetNotFoundException {        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet ruleSet = ruleSetFactory.createRuleSet("net/sourceforge/pmd/rulesets/ruleset-deprecated.xml");        assertEquals(2, ruleSet.getRules().size());    }    @Test    public void testExternalReferences() throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);        assertEquals(1, rs.size());        assertEquals(MockRule.class.getName(), rs.getRuleByName("MockRule").getRuleClass());    }    @Test    public void testIncludeExcludePatterns() throws RuleSetNotFoundException {        RuleSet ruleSet = loadRuleSet(INCLUDE_EXCLUDE_RULESET);        assertNotNull("Include patterns", ruleSet.getIncludePatterns());        assertEquals("Include patterns size", 2, ruleSet.getIncludePatterns().size());        assertEquals("Include pattern #1", "include1", ruleSet.getIncludePatterns().get(0));        assertEquals("Include pattern #2", "include2", ruleSet.getIncludePatterns().get(1));        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertEquals("Exclude patterns size", 3, ruleSet.getExcludePatterns().size());        assertEquals("Exclude pattern #1", "exclude1", ruleSet.getExcludePatterns().get(0));        assertEquals("Exclude pattern #2", "exclude2", ruleSet.getExcludePatterns().get(1));        assertEquals("Exclude pattern #3", "exclude3", ruleSet.getExcludePatterns().get(2));    }    /**     * Rule reference can't be resolved - ref is used instead of class and the     * class is old (pmd 4.3 and not pmd 5).     *     * @throws Exception     *             any error     */    @Test(expected = RuleSetNotFoundException.class)    public void testBug1202() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset>\n"                + "  <rule ref=\"net.sourceforge.pmd.rules.XPathRule\">\n" + "    <priority>1</priority>\n"                + "    <properties>\n" + "      <property name=\"xpath\" value=\"//TypeDeclaration\" />\n"                + "      <property name=\"message\" value=\"Foo\" />\n" + "    </properties>\n" + "  </rule>\n"                + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        ruleSetFactory.createRuleSet(ref);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1225/     *     * @throws Exception     *             any error     */    @Test    public void testEmptyRuleSetFile() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "\n"                + "<ruleset name=\"Custom ruleset\" xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http:www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "    <description>PMD Ruleset.</description>\n" + "\n"                + "    <exclude-pattern>.*Test.*</exclude-pattern>\n" + "\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        assertEquals(0, ruleset.getRules().size());    }    /**     * See https://github.com/pmd/pmd/issues/782     * Empty ruleset should be interpreted as deprecated.     *     * @throws Exception     *             any error     */    @Test    public void testEmptyRuleSetReferencedShouldNotBeDeprecated() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "\n"                + "<ruleset name=\"Custom ruleset\" xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http:www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "    <description>Ruleset which references a empty ruleset</description>\n" + "\n"                + "    <rule ref=\"rulesets/dummy/empty-ruleset.xml\" />\n"                + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, true);        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        assertEquals(0, ruleset.getRules().size());        assertTrue(logging.getLog().isEmpty());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     *     * @throws Exception     *             any error     */    @Test(expected = IllegalArgumentException.class)    public void testWrongRuleNameReferenced() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\"?>\n"                + "<ruleset name=\"Custom ruleset for tests\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Custom ruleset for tests</description>\n"                + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/ThisRuleDoesNotExist\"/>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        ruleSetFactory.createRuleSet(ref);    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     * @throws Exception     *             any error     */    @Test    public void testRuleReferenceWithNameOverridden() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                + "<ruleset xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "         name=\"pmd-eclipse\"\n"                + "         xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "   <description>PMD Plugin preferences rule set</description>\n" + "\n"                + "<rule name=\"OverriddenDummyBasicMockRule\"\n"                + "    ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\">\n" + "</rule>\n" + "\n" + "</ruleset>");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet rs = ruleSetFactory.createRuleSet(ref);        Rule r = rs.getRules().toArray(new Rule[1])[0];        assertEquals("OverriddenDummyBasicMockRule", r.getName());        RuleReference ruleRef = (RuleReference) r;        assertEquals("DummyBasicMockRule", ruleRef.getRule().getName());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     *     * <p>See https://github.com/pmd/pmd/issues/1978 - with that, it should not be an error anymore.     *     * @throws Exception     *             any error     */    @Test    public void testWrongRuleNameExcluded() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml\">\n"                        + "    <exclude name=\"ThisRuleDoesNotExist\"/>\n" + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref);        assertEquals(4, ruleset.getRules().size());    }    /**     * This unit test manifests the current behavior - which might change in the     * future. See #1537.     *     * Currently, if a ruleset is imported twice, the excludes of the first     * import are ignored. Duplicated rules are silently ignored.     *     * @throws Exception     *             any error     * @see <a href="https://sourceforge.net/p/pmd/bugs/1537/">#1537 Implement     *      strict ruleset parsing</a>     * @see <a href=     *      "http://stackoverflow.com/questions/40299075/custom-pmd-ruleset-not-working">stackoverflow     *      - custom ruleset not working</a>     */    @Test    public void testExcludeAndImportTwice() throws Exception {        RuleSetReferenceId ref1 = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\">\n" + "    <exclude name=\"DummyBasicMockRule\"/>\n"                        + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        RuleSet ruleset = ruleSetFactory.createRuleSet(ref1);        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        RuleSetReferenceId ref2 = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\">\n" + "    <exclude name=\"DummyBasicMockRule\"/>\n"                        + "  </rule>\n" + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory2 = new RuleSetFactory();        RuleSet ruleset2 = ruleSetFactory2.createRuleSet(ref2);        assertNotNull(ruleset2.getRuleByName("DummyBasicMockRule"));        RuleSetReferenceId ref3 = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n" + "  <rule ref=\"rulesets/dummy/basic.xml\">\n"                        + "    <exclude name=\"DummyBasicMockRule\"/>\n" + "  </rule>\n" + "</ruleset>\n");        RuleSetFactory ruleSetFactory3 = new RuleSetFactory();        RuleSet ruleset3 = ruleSetFactory3.createRuleSet(ref3);        assertNotNull(ruleset3.getRuleByName("DummyBasicMockRule"));    }    @org.junit.Rule    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetFactory.class.getName());    @Test    public void testMissingRuleSetNameIsWarning() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset \n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                        + "  </ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        ruleSetFactory.createRuleSet(ref);        assertTrue(logging.getLog().contains("RuleSet name is missing."));    }    @Test    public void testMissingRuleSetDescriptionIsWarning() throws Exception {        RuleSetReferenceId ref = createRuleSetReferenceId(                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"then name\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                        + "  </ruleset>\n");        RuleSetFactory ruleSetFactory = new RuleSetFactory();        ruleSetFactory.createRuleSet(ref);        assertTrue(logging.getLog().contains("RuleSet description is missing."));    }    private static final String REF_OVERRIDE_ORIGINAL_NAME = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + " <description>testdesc</description>" + PMD.EOL + " <rule "            + PMD.EOL + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"> "            + PMD.EOL + " </rule>" + PMD.EOL + "</ruleset>";    private static final String REF_MISPELLED_XREF = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">"            + PMD.EOL + " <description>testdesc</description>" + PMD.EOL + " <rule " + PMD.EOL            + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/FooMockRule1\"> " + PMD.EOL + " </rule>" + PMD.EOL            + "</ruleset>";    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + " <description>testdesc</description>" + PMD.EOL            + " <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"/> "            + PMD.EOL + "</ruleset>";    private static final String REF_OVERRIDE = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + " <description>testdesc</description>" + PMD.EOL + " <rule " + PMD.EOL            + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" " + PMD.EOL + "  name=\"TestNameOverride\" "            + PMD.EOL + "  message=\"Test message override\"> " + PMD.EOL            + "  <description>Test description override</description>" + PMD.EOL            + "  <example>Test example override</example>" + PMD.EOL + "  <priority>3</priority>" + PMD.EOL            + "  <properties>" + PMD.EOL            + "   <property name=\"test2\" description=\"test2\" type=\"String\" value=\"override2\"/>" + PMD.EOL            + "   <property name=\"test3\" type=\"String\" description=\"test3\"><value>override3</value></property>"            // + PMD.EOL + "   <property name=\"test4\" description=\"test4\" type=\"String\" value=\"new property\"/>" // Nonsense            + PMD.EOL + "  </properties>" + PMD.EOL + " </rule>" + PMD.EOL + "</ruleset>";    private static final String REF_OVERRIDE_NONEXISTENT = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL                                                           + " <description>testdesc</description>" + PMD.EOL + " <rule " + PMD.EOL                                                           + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" " + PMD.EOL + "  name=\"TestNameOverride\" "                                                           + PMD.EOL + "  message=\"Test message override\"> " + PMD.EOL                                                           + "  <description>Test description override</description>" + PMD.EOL                                                           + "  <example>Test example override</example>" + PMD.EOL + "  <priority>3</priority>" + PMD.EOL                                                           + "  <properties>" + PMD.EOL                                                           + "   <property name=\"test4\" description=\"test4\" type=\"String\" value=\"new property\"/>" + PMD.EOL // inexistent property                                                           + "  </properties>" + PMD.EOL + " </rule>" + PMD.EOL + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + " <description>testdesc</description>" + PMD.EOL + "<rule "            + PMD.EOL + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">" + PMD.EOL + "</rule>"            + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"/> " + PMD.EOL + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL_CHAIN = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + " <description>testdesc</description>" + PMD.EOL + "<rule "            + PMD.EOL + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">" + PMD.EOL + "</rule>"            + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"><priority>2</priority></rule> " + PMD.EOL            + " <rule ref=\"MockRuleNameRef\" name=\"MockRuleNameRefRef\"><priority>1</priority></rule> " + PMD.EOL            + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + " <description>testdesc</description>" + PMD.EOL + "<rule "            + PMD.EOL + "name=\"ExternalRefRuleName\" " + PMD.EOL            + "ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\"/>" + PMD.EOL            + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"/> " + PMD.EOL + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL_CHAIN = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + " <description>testdesc</description>" + PMD.EOL + "<rule "            + PMD.EOL + "name=\"ExternalRefRuleName\" " + PMD.EOL            + "ref=\"net/sourceforge/pmd/TestRuleset2.xml/TestRule\"/>" + PMD.EOL            + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"><priority>2</priority></rule> "            + PMD.EOL            + " <rule ref=\"ExternalRefRuleNameRef\" name=\"ExternalRefRuleNameRefRef\"><priority>1</priority></rule> "            + PMD.EOL + "</ruleset>";    private static final String EMPTY_RULESET = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">"            + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "</ruleset>";    private static final String SINGLE_RULE = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL + "name=\"MockRuleName\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">"            + "<priority>3</priority>" + PMD.EOL + "</rule></ruleset>";    private static final String MULTIPLE_RULES = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">"            + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule name=\"MockRuleName1\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">"            + PMD.EOL + "</rule>" + PMD.EOL + "<rule name=\"MockRuleName2\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">"            + PMD.EOL + "</rule></ruleset>";    private static final String PROPERTIES = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + "<description>testdesc</description>" + PMD.EOL + "<rule name=\"MockRuleName\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">"            + PMD.EOL + "<description>testdesc2</description>" + PMD.EOL + "<properties>" + PMD.EOL            + "<property name=\"fooBoolean\" description=\"test\" type=\"Boolean\" value=\"true\" />" + PMD.EOL            + "<property name=\"fooChar\" description=\"test\" type=\"Character\" value=\"B\" />" + PMD.EOL            + "<property name=\"fooInt\" description=\"test\" type=\"Integer\" min=\"1\" max=\"10\" value=\"3\" />"            + PMD.EOL            + "<property name=\"fooFloat\" description=\"test\" type=\"Float\" min=\"1.0\" max=\"1.0\" value=\"1.0\"  />"            + PMD.EOL            + "<property name=\"fooDouble\" description=\"test\" type=\"Double\" min=\"1.0\" max=\"9.0\" value=\"3.0\"  />"            + PMD.EOL + "<property name=\"fooString\" description=\"test\" type=\"String\" value=\"bar\" />" + PMD.EOL            + "</properties>" + PMD.EOL + "</rule></ruleset>";    private static final String XPATH = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + "<description>testdesc</description>" + PMD.EOL + "<rule name=\"MockRuleName\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">"            + "<priority>3</priority>" + PMD.EOL + PMD.EOL + "<description>testdesc2</description>" + PMD.EOL            + "<properties>" + PMD.EOL + "<property name=\"xpath\" description=\"test\" type=\"String\">" + PMD.EOL            + "<value>" + PMD.EOL + "<![CDATA[ //Block ]]>" + PMD.EOL + "</value>" + PMD.EOL + "</property>" + PMD.EOL            + "</properties>" + PMD.EOL + "</rule></ruleset>";    private static final String PRIORITY = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL + "name=\"MockRuleName\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">"            + "<priority>3</priority>" + PMD.EOL + "</rule></ruleset>";    private static final String LANGUAGE = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL + "name=\"MockRuleName\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" language=\"dummy\">" + PMD.EOL + "</rule></ruleset>";    private static final String INCORRECT_LANGUAGE = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">"            + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL + "name=\"MockRuleName\" "            + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL + " language=\"bogus\">" + PMD.EOL            + "</rule></ruleset>";    private static final String MINIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL + " language=\"dummy\"" + PMD.EOL            + " minimumLanguageVersion=\"1.4\">" + PMD.EOL + "</rule></ruleset>";    private static final String INCORRECT_MINIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL + " language=\"dummy\"" + PMD.EOL            + " minimumLanguageVersion=\"bogus\">" + PMD.EOL + "</rule></ruleset>";    private static final String MAXIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL + " language=\"dummy\"" + PMD.EOL            + " maximumLanguageVersion=\"1.7\">" + PMD.EOL + "</rule></ruleset>";    private static final String INCORRECT_MAXIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL + " language=\"dummy\"" + PMD.EOL            + " maximumLanguageVersion=\"bogus\">" + PMD.EOL + "</rule></ruleset>";    private static final String INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "name=\"MockRuleName\" " + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" " + PMD.EOL + "language=\"dummy\"" + PMD.EOL            + " minimumLanguageVersion=\"1.7\"" + PMD.EOL + "maximumLanguageVersion=\"1.4\">" + PMD.EOL            + "</rule></ruleset>";    private static final String DIRECT_DEPRECATED_RULE = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">"            + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL + "name=\"MockRuleName\" "            + PMD.EOL + "message=\"avoid the mock rule\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" deprecated=\"true\">" + PMD.EOL + "</rule></ruleset>";    // Note: Update this RuleSet name to a different RuleSet with deprecated    // Rules when the Rules are finally removed.    private static final String DEPRECATED_RULE_RULESET_NAME = "net/sourceforge/pmd/TestRuleset1.xml";    // Note: Update this Rule name to a different deprecated Rule when the one    // listed here is finally removed.    private static final String DEPRECATED_RULE_NAME = "MockRule3";    private static final String REFERENCE_TO_DEPRECATED_RULE = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "ref=\"" + DEPRECATED_RULE_RULESET_NAME + "/" + DEPRECATED_RULE_NAME + "\">" + PMD.EOL            + "</rule></ruleset>";    private static final String REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL            + "ref=\"" + DEPRECATED_RULE_RULESET_NAME + "\">" + PMD.EOL + "</rule></ruleset>";    private static final String DFA = "<?xml version=\"1.0\"?>" + PMD.EOL + "<ruleset name=\"test\">" + PMD.EOL            + "<description>testdesc</description>" + PMD.EOL + "<rule " + PMD.EOL + "name=\"MockRuleName\" " + PMD.EOL            + "message=\"avoid the mock rule\" " + PMD.EOL + "dfa=\"true\" " + PMD.EOL            + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">" + "<priority>3</priority>" + PMD.EOL            + "</rule></ruleset>";    private static final String INCLUDE_EXCLUDE_RULESET = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL            + "<include-pattern>include1</include-pattern>" + PMD.EOL + "<include-pattern>include2</include-pattern>"            + PMD.EOL + "<exclude-pattern>exclude1</exclude-pattern>" + PMD.EOL            + "<exclude-pattern>exclude2</exclude-pattern>" + PMD.EOL + "<exclude-pattern>exclude3</exclude-pattern>"            + PMD.EOL + "</ruleset>";    private static final String EXTERNAL_REFERENCE_RULE_SET = "<?xml version=\"1.0\"?>" + PMD.EOL            + "<ruleset name=\"test\">" + PMD.EOL + "<description>testdesc</description>" + PMD.EOL            + "<rule ref=\"net/sourceforge/pmd/external-reference-ruleset.xml/MockRule\"/>" + PMD.EOL + "</ruleset>";    private Rule loadFirstRule(String ruleSetXml) throws RuleSetNotFoundException {        RuleSet rs = loadRuleSet(ruleSetXml);        return rs.getRules().iterator().next();    }    private RuleSet loadRuleSet(String ruleSetXml) throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory();        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));    }    private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) throws RuleSetNotFoundException {        RuleSetFactory rsf = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, false);        return rsf.createRuleSet(createRuleSetReferenceId(ruleSetXml));    }    private static RuleSetReferenceId createRuleSetReferenceId(final String ruleSetXml) {        return new RuleSetReferenceId(null) {            @Override            public InputStream getInputStream(ResourceLoader resourceLoader) throws RuleSetNotFoundException {                try {                    return new ByteArrayInputStream(ruleSetXml.getBytes("UTF-8"));                } catch (UnsupportedEncodingException e) {                    return null;                }            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Test;import junit.framework.JUnit4TestAdapter;public class RuleContextTest {    @Test    public void testReport() {        RuleContext ctx = new RuleContext();        assertEquals(0, ctx.getReport().size());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    @Test    public void testSourceCodeFilename() {        RuleContext ctx = new RuleContext();        assertEquals("filename should be empty", "", ctx.getSourceCodeFilename());        ctx.setSourceCodeFile(new File("dir/foo.java"));        assertEquals("filename mismatch", "foo.java", ctx.getSourceCodeFilename());    }    @Test    public void testSourceCodeFile() {        RuleContext ctx = new RuleContext();        assertNull("file should be null", ctx.getSourceCodeFile());        ctx.setSourceCodeFile(new File("somefile.java"));        assertEquals("filename mismatch", new File("somefile.java"), ctx.getSourceCodeFile());    }    @Test    public void testAttributes() {        RuleContext ctx1 = new RuleContext();        Object obj1 = new Object();        Object obj2 = new Object();        assertNull("attribute should be null", ctx1.getAttribute("attribute"));        boolean set = ctx1.setAttribute("attribute", obj1);        assertTrue("attribute should have been set", set);        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute"));        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute"), obj1);        set = ctx1.setAttribute("attribute", obj2);        assertFalse("attribute should not have been set", set);        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute"), obj1);        Object value = ctx1.removeAttribute("attribute");        assertSame("attribute value should be expected instance", value, obj1);        assertNull("attribute should be null", ctx1.getAttribute("attribute"));    }    @Test    public void testSharedAttributes() {        RuleContext ctx1 = new RuleContext();        RuleContext ctx2 = new RuleContext(ctx1);        StringBuilder obj1 = new StringBuilder();        StringBuilder obj2 = new StringBuilder();        ctx1.setAttribute("attribute1", obj1);        ctx2.setAttribute("attribute2", obj2);        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute1"));        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute2"));        assertNotNull("attribute should not be null", ctx2.getAttribute("attribute1"));        assertNotNull("attribute should not be null", ctx2.getAttribute("attribute2"));        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute1"), obj1);        assertSame("attribute should be expected instance", ctx1.getAttribute("attribute2"), obj2);        assertSame("attribute should be expected instance", ctx2.getAttribute("attribute1"), obj1);        assertSame("attribute should be expected instance", ctx2.getAttribute("attribute2"), obj2);        ctx1.removeAttribute("attribute1");        assertNull("attribute should be null", ctx1.getAttribute("attribute1"));        assertNull("attribute should be null", ctx2.getAttribute("attribute1"));        assertNotNull("attribute should not be null", ctx1.getAttribute("attribute2"));        assertNotNull("attribute should not be null", ctx2.getAttribute("attribute2"));        StringBuilder value = (StringBuilder) ctx1.getAttribute("attribute2");        assertEquals("attribute value should be empty", "", value.toString());        value.append("x");        StringBuilder value1 = (StringBuilder) ctx1.getAttribute("attribute2");        assertEquals("attribute value should be 'x'", "x", value1.toString());        StringBuilder value2 = (StringBuilder) ctx2.getAttribute("attribute2");        assertEquals("attribute value should be 'x'", "x", value2.toString());    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(RuleContextTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import junit.framework.JUnit4TestAdapter;public class RuleViolationTest {    @Test    public void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(2);        s.testingOnlySetBeginColumn(1);        RuleViolation r = new ParametricRuleViolation<Node>(rule, ctx, s, rule.getMessage());        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());    }    @Test    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(2);        s.testingOnlySetBeginColumn(1);        RuleViolation r = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    @Test    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolationComparator comp = RuleViolationComparator.INSTANCE;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename1"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(10);        s.testingOnlySetBeginColumn(1);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        ctx.setSourceCodeFile(new File("filename2"));        DummyNode s1 = new DummyNode(1);        s1.testingOnlySetBeginLine(10);        s1.testingOnlySetBeginColumn(1);        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, ctx, s1, "description");        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    @Test    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolationComparator comp = RuleViolationComparator.INSTANCE;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(10);        s.testingOnlySetBeginColumn(1);        DummyNode s1 = new DummyNode(1);        s1.testingOnlySetBeginLine(20);        s1.testingOnlySetBeginColumn(1);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, ctx, s1, "description");        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    @Ignore    @Test    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolationComparator comp = RuleViolationComparator.INSTANCE;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("filename"));        DummyNode s = new DummyNode(1);        s.testingOnlySetBeginLine(10);        s.testingOnlySetBeginColumn(1);        DummyNode s1 = new DummyNode(1);        s1.testingOnlySetBeginLine(10);        s1.testingOnlySetBeginColumn(1);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, ctx, s, "description");        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, ctx, s1, "description");        assertEquals(1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(RuleViolationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.resolver;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.modelica.ModelicaLoader;import net.sourceforge.pmd.lang.modelica.ast.ASTExtendsClause;import net.sourceforge.pmd.lang.modelica.ast.ASTStoredDefinition;import net.sourceforge.pmd.lang.modelica.ast.ModelicaClassSpecifierNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaParserVisitorAdapter;public class ModelicaResolverTest {    private static class NodeFinder extends ModelicaParserVisitorAdapter {        private ModelicaNode result;        private Class<?> nodeClass;        private String nodeName;        NodeFinder(Class<?> nodeClass, String nodeName) {            this.nodeClass = nodeClass;            this.nodeName = nodeName;        }        @Override        public Object visit(ModelicaNode node, Object data) {            if (nodeClass.isInstance(node) && node.getImage().equals(nodeName)) {                Assert.assertNull(result);                result = node;            }            return super.visit(node, data);        }        ModelicaNode getResult() {            return result;        }    }    private ModelicaNode findNodeByClassAndImage(ASTStoredDefinition ast, Class<?> clazz, String image) {        NodeFinder vis = new NodeFinder(clazz, image);        ast.jjtAccept(vis, null);        return vis.getResult();    }    private void ensureCounts(ResolutionResult result, int best, int hidden) {        Assert.assertFalse(result.wasTimedOut());        Assert.assertEquals(best, result.getBestCandidates().size());        Assert.assertEquals(hidden, result.getHiddenCandidates().size());    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, SubcomponentResolver resolver, boolean absolute, String[] names) {        ResolutionResult result = resolver.safeResolveComponent(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, ModelicaScope resolver, boolean absolute, String[] names) {        ResolutionResult result = resolver.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, SubcomponentResolver scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedComponentCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forComponentReference(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testLexicallyResolvedComponents(int best, int hidden, ModelicaClassScope scope, boolean absolute, String... names) {        ResolutionState state = ResolutionState.forComponentReference();        ResolutionResult<ResolvableEntity> result = scope.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    @Test    public void verySimpleScopeTest() {        String contents =              "model TestPackage"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        Assert.assertNotNull(ast);        Assert.assertTrue(ast.getMostSpecificScope() instanceof ModelicaSourceFileScope);        ModelicaSourceFileScope scope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        Assert.assertTrue(scope.getParent() instanceof RootScope);        Assert.assertNull(scope.getParent().getParent());    }    @Test    public void simpleScopeTest() {        String contents =              "package TestPackage"            + "  connector TestConnector"            + "  end TestConnector;"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        ModelicaSourceFileScope sourceFileScope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        Assert.assertEquals(1, sourceFileScope.getContainedDeclarations().size());        ModelicaNode testSubmodel = findNodeByClassAndImage(ast, ModelicaClassSpecifierNode.class, "TestSubmodel");        Assert.assertNotNull(testSubmodel);        Assert.assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:TestSubmodel",                ((AbstractModelicaScope) testSubmodel.getMostSpecificScope()).getNestingRepresentation()        );        ModelicaScope testPackage = testSubmodel.getMostSpecificScope().getParent().getParent();        Assert.assertTrue(testPackage instanceof ModelicaClassScope);        Assert.assertEquals("TestPackage", ((ModelicaClassScope) testPackage).getClassDeclaration().getSimpleTypeName());        Assert.assertEquals(3, testPackage.getContainedDeclarations().size());    }    @Test    public void extendsScopeTest() {        String contents =                  "package Test"                + "  model A"                + "    extends B;"                + "  end A;"                + "  model B"                + "  end B;"                + "end Test;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        List<ASTExtendsClause> extendsClauses = ast.findDescendantsOfType(ASTExtendsClause.class);        Assert.assertEquals(1, extendsClauses.size());        ASTExtendsClause extendsB = extendsClauses.get(0);        Assert.assertEquals("#ROOT#FILE#Class:Test#Class:A", ((AbstractModelicaScope) extendsB.getMostSpecificScope()).getNestingRepresentation());    }    @Test    public void absoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    public void nonAbsoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    public void multipleResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model A"            + "    end A;"            + "  end TestModel;"            + "  model A"            + "  end A;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        ResolutionResult<ResolvableEntity> testModelCandidates = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel");        ModelicaClassScope testModelScope = ((ModelicaClassType) testModelCandidates.getBestCandidates().get(0)).getClassScope();        Assert.assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel",                testModelScope.getNestingRepresentation()        );        ResolutionResult<ResolvableEntity> aCandidates = testLexicallyResolvedComponents(1, 1, testModelScope, false, "A");        ModelicaClassType aBest = (ModelicaClassType) aCandidates.getBestCandidates().get(0);        ModelicaClassType aHidden = (ModelicaClassType) aCandidates.getHiddenCandidates().get(0);        Assert.assertEquals("#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:A",                aBest.getClassScope().getNestingRepresentation());        Assert.assertEquals("#ROOT#FILE#Class:TestPackage#Class:A",                aHidden.getClassScope().getNestingRepresentation());    }    @Test    public void constantComponentResolutionTest() {        String contents =              "model Test"            + "  model A"            + "    constant Real x = 1;"            + "  end A;"            + "end Test;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        List<ResolvableEntity> xs = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "A", "x").getBestCandidates();        Assert.assertEquals(            "#ROOT#FILE#Class:Test#Class:A",                ((ModelicaComponentDeclaration) xs.get(0)).getContainingScope().getNestingRepresentation()        );    }    @Test    public void nestedStoredDefinitionTest() {        String contents =              "within TestPackage.SubPackage;\n"            + "model Test\n"            + "end Test;\n";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        RootScope rootScope = (RootScope) ast.getMostSpecificScope().getParent();        List<ResolvableEntity> nestedTest = testResolvedTypeCount(1, 0, rootScope, false, "TestPackage", "SubPackage", "Test").getBestCandidates();        Assert.assertEquals(                "#ROOT#FILE#Class:Test",                ((ModelicaClassType) nestedTest.get(0)).getClassScope().getNestingRepresentation()        );        // Simple names are visible from within the same file        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test");        // ... but from other files they should be resolved w.r.t. the within clause        testResolvedTypeCount(0, 0, rootScope, false, "Test");    }    @Test    public void extendsTest() {        String contents =              "model A\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "B", "X");    }    @Test    public void importTest() {        String contents =              "model I\n"            + "  model Z\n"            + "  end Z;\n"            + "end I;\n"            + "model A\n"            + "  import I.Z;\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "A", "Z");        testResolvedTypeCount(0, 0, ast.getMostSpecificScope(), false, "B", "Z");    }    @Test    public void builtinTest() {        String contents =              "model A"            + "  encapsulated model B"            + "    Real x;"            + "  end B;"            + "end A;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        List<ResolvableEntity> xs = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), true, "A", "B", "x").getBestCandidates();        ModelicaComponentDeclaration x = (ModelicaComponentDeclaration) xs.get(0);        ResolutionResult<ModelicaType> xTypes = x.getTypeCandidates();        ensureCounts(xTypes, 1, 0);        ResolvableEntity tpe = xTypes.getBestCandidates().get(0);        Assert.assertTrue(tpe instanceof ModelicaBuiltinType);        Assert.assertEquals(ModelicaBuiltinType.BaseType.REAL, ((ModelicaBuiltinType) tpe).getBaseType());    }    @Test    public void testRepeatingNameResolution() {        String contents =                  "package Test"                + "  model X"                + "    model X"                + "    end X;"                + "    Test.X.X mdl;"                + "  end X;"                + "end Test;";        ASTStoredDefinition ast = ModelicaLoader.parse(null, contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "Test", "X", "X");        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "X");        ResolutionResult<ResolvableEntity> result = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "mdl");        ModelicaComponentDeclaration mdl = (ModelicaComponentDeclaration) result.getBestCandidates().get(0);        ensureCounts(((ModelicaComponentDeclaration) mdl).getTypeCandidates(), 1, 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConnectUsingNonConnectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassStartNameEqualsEndNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AmbiguousResolutionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.modelica.ast.ASTStoredDefinition;public class ModelicaParserTest {    @Test    public void testParsingGrapgical() {        ASTStoredDefinition node = ModelicaLoader.parse("ParserTestGraphical.mo");        Assert.assertNotNull(node);    }    @Test    public void testParsingTextual() {        ASTStoredDefinition node = ModelicaLoader.parse("ParserTestTextual.mo");        Assert.assertNotNull(node);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.modelica.ModelicaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ModelicaLanguageModule.NAME, ModelicaLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(ModelicaLanguageModule.NAME).getDefaultVersion(),            },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class MatlabTokenizerTest extends AbstractTokenizerTest {    private static final String FILENAME = "sample-matlab.m";    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new MatlabTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), FILENAME));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(MatlabTokenizer.class.getResourceAsStream(FILENAME), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 3925;        super.tokenizeTest();    }        @Test    public void testIgnoreBetweenSpecialComments() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("% CPD-OFF" + PMD.EOL                + "function g = vec(op, y)" + PMD.EOL                + "  opy = op(y);" + PMD.EOL                + "  if ( any(size(opy) > 1) )" + PMD.EOL                + "    g = @loopWrapperArray;" + PMD.EOL                + "  end" + PMD.EOL                + "  % CPD-ON" + PMD.EOL                + "end"        ));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(2, tokens.size()); // 2 tokens: "end" + EOF    }    @Test    public void testComments() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("classdef LC" + PMD.EOL                + "    methods" + PMD.EOL                + "        function [obj, c,t, s ] = Classification( obj,m,t, cm )%#codegen" + PMD.EOL                + "        end" + PMD.EOL                + "    end" + PMD.EOL                + "end"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens); // should not result in parse error        assertEquals(28, tokens.size());    }    @Test    public void testBlockComments() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("%{" + PMD.EOL                + "  Name:     helloworld.m\n" + PMD.EOL                + "  Purpose:  Say \"Hello World!\" in two different ways" + PMD.EOL                + "%}" + PMD.EOL                + PMD.EOL                + "% Do it the good ol' fashioned way...command window" + PMD.EOL                + "disp('Hello World!');\n" + PMD.EOL                + "%" + PMD.EOL                + "% Do it the new hip GUI way...with a message box" + PMD.EOL                + "msgbox('Hello World!','Hello World!');"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens); // should not result in parse error        assertEquals(13, tokens.size());    }    @Test    public void testQuestionMark() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("classdef Class1" + PMD.EOL                + "properties (SetAccess = ?Class2)"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(10, tokens.size());    }    @Test    public void testDoubleQuotedStrings() throws IOException {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "error(\"This is a double-quoted string\");"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals("\"This is a double-quoted string\"", tokens.getTokens().get(2).toString());        assertEquals(6, tokens.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.Collection;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;@RunWith(Parameterized.class)public class LuaTokenizerTest extends AbstractTokenizerTest {    private final String filename;    private final int nExpectedTokens;    public LuaTokenizerTest(String filename, int nExpectedTokens) {        this.filename = filename;        this.nExpectedTokens = nExpectedTokens;    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(                new Object[] { "factorial.lua", 44 },                new Object[] { "helloworld.lua", 5 }        );    }    @Before    @Override    public void buildTokenizer() throws IOException {        this.tokenizer = new LuaTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), this.filename));    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(LuaTokenizer.class.getResourceAsStream(this.filename), StandardCharsets.UTF_8);    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = nExpectedTokens;        super.tokenizeTest();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class RubyTokenizerTest extends AbstractTokenizerTest {    @Before    @Override    public void buildTokenizer() {        this.tokenizer = new RubyTokenizer();        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(this.getSampleCode(), "server.rb"));    }    @Override    public String getSampleCode() {        try {            return IOUtils.toString(RubyTokenizerTest.class.getResourceAsStream("server.rb"), StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Test    public void tokenizeTest() throws IOException {        this.expectedTokenCount = 30;        super.tokenizeTest();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.StringReader;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathRuleQuery;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;import net.sourceforge.pmd.testframework.RuleTst;public class XPathRuleTest extends RuleTst {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    XPathRule rule;    @Before    public void setUp() {        rule = new XPathRule();        rule.setLanguage(LanguageRegistry.getLanguage(ScalaLanguageModule.NAME));        rule.setMessage("XPath Rule Failed");    }    @Test    public void testPrintHelloWorld() throws Exception {        String xpath = "//TermApply/TermName[@Image=\"println\"]";        rule.setXPath(xpath);        rule.setVersion(XPathRuleQuery.XPATH_2_0);        Report report = getReportForTestString(rule,                IOUtils.toString(getClass().getResourceAsStream(SCALA_TEST), "UTF-8"));        RuleViolation rv = report.iterator().next();        assertEquals(2, rv.getBeginLine());    }    private static Report getReportForTestString(Rule r, String test) throws PMDException {        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFile(new File("test.scala"));        RuleSet rules = new RuleSetFactory().createSingleRuleRuleSet(r);        p.getSourceCodeProcessor().processSourceCode(new StringReader(test), new RuleSets(rules), ctx);        return report;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import java.io.File;import java.io.StringReader;import java.util.Arrays;import java.util.concurrent.atomic.AtomicInteger;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.internal.util.IteratorUtil;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;import net.sourceforge.pmd.lang.scala.ast.ASTTermApply;import net.sourceforge.pmd.lang.scala.ast.ASTTermName;import net.sourceforge.pmd.lang.scala.ast.ScalaNode;public class ScalaRuleTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    public void testRuleVisits() throws Exception {        LanguageVersionHandler scalaVersionHandler = LanguageRegistry.getLanguage(ScalaLanguageModule.NAME)                .getDefaultVersion().getLanguageVersionHandler();        Parser parser = scalaVersionHandler.getParser(scalaVersionHandler.getDefaultParserOptions());        ScalaNode<?> root = (ScalaNode<?>) parser.parse(null,                new StringReader(IOUtils.toString(getClass().getResourceAsStream(SCALA_TEST), "UTF-8")));        final AtomicInteger visited = new AtomicInteger();        ScalaRule rule = new ScalaRule() {            @Override            public RuleContext visit(ScalaNode<?> node, RuleContext data) {                visited.incrementAndGet();                return super.visit(node, data);            }        };        rule.apply(Arrays.asList(root), null);        Assert.assertEquals(12, visited.get());    }    @Test    public void testDummyRule() throws Exception {        ScalaRule rule = new ScalaRule() {            @Override            public RuleContext visit(ASTTermApply node, RuleContext data) {                ASTTermName child = node.getFirstChildOfType(ASTTermName.class);                if (child != null && child.hasImageEqualTo("println")) {                    addViolation(data, node);                }                return data;            }        };        Report report = getReportForTestString(rule,                IOUtils.toString(getClass().getResourceAsStream(SCALA_TEST), "UTF-8"));        Assert.assertEquals(1, IteratorUtil.count(report.iterator()));    }    private static Report getReportForTestString(Rule r, String test) throws PMDException {        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFile(new File("test.scala"));        RuleSet rules = new RuleSetFactory().createSingleRuleRuleSet(r);        p.getSourceCodeProcessor().processSourceCode(new StringReader(test), new RuleSets(rules), ctx);        return report;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.File;import java.io.IOException;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.testframework.AbstractTokenizerTest;public class ScalaTokenizerTest extends AbstractTokenizerTest {    private static final Charset ENCODING = StandardCharsets.UTF_8;    private static final String FILENAME = "/tokenizerFiles/sample-LiftActor.scala";    private File tempFile;    @Before    @Override    public void buildTokenizer() throws IOException {        createTempFileOnDisk();        this.tokenizer = new ScalaTokenizer();    }    private void createTempFileOnDisk() throws IOException {        this.tempFile = File.createTempFile("scala-tokenizer-test-", ".scala");        FileUtils.writeStringToFile(tempFile, getSampleCode(), ENCODING);    }    @Override    public String getSampleCode() throws IOException {        return IOUtils.toString(getClass().getResourceAsStream(FILENAME), ENCODING);    }    @Test    public void tokenizeTest() throws IOException {        this.sourceCode = new SourceCode(new SourceCode.FileCodeLoader(tempFile, "UTF-8"));        this.expectedTokenCount = 2472;        super.tokenizeTest();    }    @Test    public void tokenizeFailTest() throws IOException {        this.sourceCode = new SourceCode(new SourceCode.StringCodeLoader(                "  object Main { "                + " def main(args: Array[String]): Unit = { "                + "  println(\"Hello, World!) " //unclosed string literal                + " }"                + "}"));        try {            super.tokenizeTest();            Assert.fail();        } catch (Exception e) {            // intentional        }    }    @After    public void cleanUp() {        FileUtils.deleteQuietly(this.tempFile);        this.tempFile = null;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.13",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.13"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.12",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.12"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.11",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.11"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.10",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.10"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test scala rulesets */public class RulesetFactoryTest extends AbstractRuleSetFactoryTest {    // no rulesets yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.cpp;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.io.StringReader;import org.junit.Test;public class CppCharStreamTest {    @Test    public void testContinuationUnix() throws IOException {        CppCharStream stream = new CppCharStream(new StringReader("a\\\nb"));        assertStream(stream, "ab");    }    @Test    public void testContinuationWindows() throws IOException {        CppCharStream stream = new CppCharStream(new StringReader("a\\\r\nb"));        assertStream(stream, "ab");    }    @Test    public void testBackup() throws IOException {        CppCharStream stream = new CppCharStream(new StringReader("a\\b\\\rc"));        assertStream(stream, "a\\b\\\rc");    }    private void assertStream(CppCharStream stream, String token) throws IOException {        char c = stream.BeginToken();        assertEquals(token.charAt(0), c);        for (int i = 1; i < token.length(); i++) {            c = stream.readChar();            assertEquals(token.charAt(i), c);        }        assertEquals(token, stream.GetImage());        assertEquals(token, new String(stream.GetSuffix(token.length())));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.Properties;import org.apache.commons.io.IOUtils;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.ast.TokenMgrError;public class CPPTokenizerTest {    @Rule    public ExpectedException expectedException = ExpectedException.none();    @Test    public void testUTFwithBOM() {        Tokens tokens = parse("\ufeffint start()\n{ int ret = 1;\nreturn ret;\n}\n");        assertNotSame(TokenEntry.getEOF(), tokens.getTokens().get(0));        assertEquals(15, tokens.size());    }    @Test    public void testUnicodeSupport() {        String code = "\ufeff" + "#include <iostream>\n" + "#include <string>\n" + "\n" + "// example\n" + "\n"                + "int main()\n" + "{\n" + "    std::string text(\"ąęćśźńó\");\n" + "    std::cout << text;\n"                + "    return 0;\n" + "}\n";        Tokens tokens = parse(code);        assertNotSame(TokenEntry.getEOF(), tokens.getTokens().get(0));        assertEquals(24, tokens.size());    }        @Test    public void testIgnoreBetweenSpecialComments() {        String code = "#include <iostream>\n" + "#include <string>\n" + "\n" + "// CPD-OFF\n"                + "int main()\n" + "{\n" + "    std::string text(\"ąęćśźńó\");\n" + "    std::cout << text;\n"                + "    return 0;\n" + "// CPD-ON\n" + "}\n";        Tokens tokens = parse(code);        assertNotSame(TokenEntry.getEOF(), tokens.getTokens().get(0));        assertEquals(2, tokens.size()); // "}" + EOF    }    @Test    public void testMultiLineMacros() {        Tokens tokens = parse(TEST1);        assertEquals(7, tokens.size());    }    @Test    public void testDollarSignInIdentifier() {        parse(TEST2);    }    @Test    public void testDollarSignStartingIdentifier() {        parse(TEST3);    }    @Test    public void testWideCharacters() {        parse(TEST4);    }    @Test    public void testTokenizerWithSkipBlocks() throws Exception {        String test = IOUtils.toString(CPPTokenizerTest.class.getResourceAsStream("cpp/cpp_with_asm.cpp"), StandardCharsets.UTF_8);        Tokens tokens = parse(test, true, new Tokens());        assertEquals(19, tokens.size());    }    @Test    public void testTokenizerWithSkipBlocksPattern() throws Exception {        String test = IOUtils.toString(CPPTokenizerTest.class.getResourceAsStream("cpp/cpp_with_asm.cpp"), StandardCharsets.UTF_8);        Tokens tokens = new Tokens();        try {            parse(test, true, "#if debug|#endif", tokens);        } catch (TokenMgrError ignored) {            // ignored        }        assertEquals(31, tokens.size());    }    @Test    public void testTokenizerWithoutSkipBlocks() throws Exception {        String test = IOUtils.toString(CPPTokenizerTest.class.getResourceAsStream("cpp/cpp_with_asm.cpp"), StandardCharsets.UTF_8);        Tokens tokens = new Tokens();        try {            parse(test, false, tokens);        } catch (TokenMgrError ignored) {            // ignored        }        assertEquals(37, tokens.size());    }    @Test    // ASM code containing the '@' character    public void testAsmWithAtSign() {        Tokens tokens = parse(TEST7);        assertEquals(22, tokens.size());    }    @Test    public void testEOLCommentInPreprocessingDirective() {        parse("#define LSTFVLES_CPP  //*" + PMD.EOL);    }    @Test    public void testEmptyCharacter() {        Tokens tokens = parse("std::wstring wsMessage( sMessage.length(), L'');" + PMD.EOL);        assertEquals(15, tokens.size());    }    @Test    public void testHexCharacter() {        Tokens tokens = parse("if (*pbuf == '\\0x05')" + PMD.EOL);        assertEquals(8, tokens.size());    }    @Test    public void testWhiteSpaceEscape() {        Tokens tokens = parse("szPath = m_sdcacheDir + _T(\"\\    oMedia\");" + PMD.EOL);        assertEquals(10, tokens.size());    }    @Test    public void testRawStringLiteral() {        String code = "const char* const KDefaultConfig = R\"(\n" + "    [Sinks.1]\n" + "    Destination=Console\n"                + "    AutoFlush=true\n"                + "    Format=\"[%TimeStamp%] %ThreadId% %QueryIdHigh% %QueryIdLow% %LoggerFile%:%Line% (%Severity%) - %Message%\"\n"                + "    Filter=\"%Severity% >= WRN\"\n" + ")\";\n";        Tokens tokens = parse(code);        assertTrue(TokenEntry.getEOF() != tokens.getTokens().get(0));        assertEquals(9, tokens.size());    }    @Test    public void testLexicalErrorFilename() throws Exception {        Properties properties = new Properties();        properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS, Boolean.toString(false));        String test = IOUtils.toString(CPPTokenizerTest.class.getResourceAsStream("cpp/issue-1559.cpp"), StandardCharsets.UTF_8);        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(test, "issue-1559.cpp"));        CPPTokenizer tokenizer = new CPPTokenizer();        tokenizer.setProperties(properties);        expectedException.expect(TokenMgrError.class);        expectedException.expectMessage("Lexical error in file issue-1559.cpp at");        tokenizer.tokenize(code, new Tokens());    }    public void testStringPrefix(String code, String expToken, int tokenIndex, int expNoTokens) {        final Tokens tokens = parse(code);        final TokenEntry token = tokens.getTokens().get(tokenIndex);        assertEquals(expNoTokens, tokens.size());        assertEquals(expToken, token.toString());    }    public void testCharacterPrefix(String code, String expToken) {        testStringPrefix(code, expToken, 3, 6);    }    public void testStringPrefix(String code, String expToken) {        testStringPrefix(code, expToken, 5, 8);    }    @Test    public void testCharacterPrefixNoPrefix() {        testCharacterPrefix("char a =  '\\x30';", "'\\x30'");    }    @Test    public void testCharacterPrefixWideCharacter() {        testCharacterPrefix("wchar_t b = L'\\xFFEF';", "L'\\xFFEF'");    }    @Test    public void testCharacterPrefixChar16() {        testCharacterPrefix("char16_t c = u'\\u00F6';", "u'\\u00F6'");    }    @Test    public void testCharacterPrefixChar32() {        testCharacterPrefix("char32_t d = U'\\U0010FFFF';", "U'\\U0010FFFF'");    }    @Test    public void testStringPrefixNoPrefix() {        testStringPrefix("char A[] = \"Hello\\x0A\";", "\"Hello\\x0A\"");    }    @Test    public void testStringPrefixWideString() {        testStringPrefix("wchar_t B[] = L\"Hell\\xF6\\x0A\";", "L\"Hell\\xF6\\x0A\"");    }    @Test    public void testStringPrefixChar16() {        testStringPrefix("char16_t C[] = u\"Hell\\u00F6\";", "u\"Hell\\u00F6\"");    }    @Test    public void testStringPrefixChar32() {        testStringPrefix("char32_t D[] = U\"Hell\\U000000F6\\U0010FFFF\";", "U\"Hell\\U000000F6\\U0010FFFF\"");    }    @Test    public void testStringPrefixUtf8() {        testStringPrefix("auto E[] = u8\"\\u00F6\\U0010FFFF\";", "u8\"\\u00F6\\U0010FFFF\"");    }    @Test    public void testRawStringLiterals() throws IOException {        final String code = IOUtils.toString(CPPTokenizerTest.class.getResourceAsStream("cpp/issue-1784.cpp"), StandardCharsets.UTF_8);        Tokens tokens = parse(code);        assertTrue(TokenEntry.getEOF() != tokens.getTokens().get(0));        assertEquals(16, tokens.size());    }    @Test    public void testDigitSeparators() {        final String code = "auto integer_literal = 1'000'000;" + PMD.EOL                + "auto floating_point_literal = 0.000'015'3;" + PMD.EOL                + "auto hex_literal = 0x0F00'abcd'6f3d;" + PMD.EOL                + "auto silly_example = 1'0'0'000'00;";        Tokens tokens = parse(code);        assertTrue(TokenEntry.getEOF() != tokens.getTokens().get(0));        assertEquals("1'000'000", tokens.getTokens().get(3).toString());        assertEquals(21, tokens.size());    }    private Tokens parse(String snippet) {        try {            return parse(snippet, false, new Tokens());        } catch (IOException e) {            throw new RuntimeException(e);        }    }    private Tokens parse(String snippet, boolean skipBlocks, Tokens tokens) throws IOException {        return parse(snippet, skipBlocks, null, tokens);    }    private Tokens parse(String snippet, boolean skipBlocks, String skipPattern, Tokens tokens) throws IOException {        Properties properties = new Properties();        properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS, Boolean.toString(skipBlocks));        if (skipPattern != null) {            properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS_PATTERN, skipPattern);        }        CPPTokenizer tokenizer = new CPPTokenizer();        tokenizer.setProperties(properties);        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(snippet));        tokenizer.tokenize(code, tokens);        return tokens;    }    private static final String TEST1 = "#define FOO a +\\" + PMD.EOL + "            b +\\" + PMD.EOL            + "            c +\\" + PMD.EOL + "            d +\\" + PMD.EOL + "            e +\\" + PMD.EOL            + "            f +\\" + PMD.EOL + "            g" + PMD.EOL + " void main() {}";    private static final String TEST2 = " void main() { int x$y = 42; }";    private static final String TEST3 = " void main() { int $x = 42; }";    private static final String TEST4 = " void main() { char x = L'a'; }";    private static final String TEST7 = "asm void eSPI_boot()" + PMD.EOL + "{" + PMD.EOL + "  // setup stack pointer"            + PMD.EOL + "  lis r1, _stack_addr@h" + PMD.EOL + "  ori r1, r1, _stack_addr@l" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.fail;import java.io.IOException;import java.io.StringReader;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Properties;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader;import net.sourceforge.pmd.lang.cpp.CppTokenManager;import net.sourceforge.pmd.lang.cpp.ast.Token;public class CPPTokenizerContinuationTest {    @Test    public void parseWithContinuation() throws Exception {        String code = load("cpp_with_continuation.cpp");        Tokens tokens = parse(code);        if (tokens.size() < 52) {            printTokens(tokens);            fail("Not enough tokens - probably parsing error. Tokens: " + tokens.size());        }        assertEquals("static", findByLine(8, tokens).get(0).toString());        assertEquals("int", findByLine(8, tokens).get(1).toString());        // special case, if the continuation is *within* a token        // see also test #testContinuationIntraToken        TokenEntry tokenEntry = findByLine(8, tokens).get(2);        assertEquals("ab", tokenEntry.toString());        assertEquals("int", findByLine(12, tokens).get(0).toString());        assertEquals("main", findByLine(12, tokens).get(1).toString());        assertEquals("(", findByLine(12, tokens).get(2).toString());        assertEquals(")", findByLine(12, tokens).get(3).toString());        assertEquals("{", findByLine(13, tokens).get(0).toString());        assertEquals("\"world!\\n\"", findByLine(16, tokens).get(0).toString());        assertEquals("\"3 Hello, \\world!\\n\"", findByLine(22, tokens).get(4).toString());        assertEquals("}", findByLine(29, tokens).get(0).toString());    }    /**     * Verifies the begin/end of a token. Uses the underlaying JavaCC Token and     * not TokenEntry.     */    @Test    public void parseWithContinuationCppTokenManager() throws Exception {        String code = load("cpp_with_continuation.cpp");        CppTokenManager tokenManager = new CppTokenManager(new StringReader(code));        List<Token> tokens = new ArrayList<>();        Token token = (Token) tokenManager.getNextToken();        while (!token.image.isEmpty()) {            tokens.add(token);            token = (Token) tokenManager.getNextToken();        }        assertEquals(51, tokens.size());        assertToken(tokens.get(2), "ab", 8, 12, 9, 1);        assertToken(tokens.get(22), "\"2 Hello, world!\\n\"", 18, 16, 19, 9);    }    private void assertToken(Token token, String image, int beginLine, int beginColumn, int endLine, int endColumn) {        assertEquals(image, token.image);        assertEquals(beginLine, token.beginLine);        assertEquals(beginColumn, token.beginColumn);        assertEquals(endLine, token.endLine);        assertEquals(endColumn, token.endColumn);    }    @Test    public void testContinuationIntraToken() throws Exception {        Tokens tokens = parse(load("cpp_continuation_intra_token.cpp"));        assertEquals(7, tokens.size());    }    @Test    public void testContinuationInterToken() throws Exception {        Tokens tokens = parse(load("cpp_continuation_inter_token.cpp"));        assertEquals(17, tokens.size());    }    private void printTokens(Tokens tokens) {        for (TokenEntry entry : tokens.getTokens()) {            System.out.printf("%02d: %s%s", entry.getBeginLine(), entry.toString(), PMD.EOL);        }    }    private List<TokenEntry> findByLine(int line, Tokens tokens) {        List<TokenEntry> result = new ArrayList<>();        for (TokenEntry entry : tokens.getTokens()) {            if (entry.getBeginLine() == line) {                result.add(entry);            }        }        if (result.isEmpty()) {            fail("No tokens at line " + line + " found");        }        return result;    }    private String load(String name) throws Exception {        return IOUtils.toString(CPPTokenizerContinuationTest.class                .getResourceAsStream("cpp/" + name), StandardCharsets.UTF_8);    }    private Tokens parse(String code) throws IOException {        CPPTokenizer tokenizer = new CPPTokenizer();        tokenizer.setProperties(new Properties());        Tokens tokens = new Tokens();        tokenizer.tokenize(new SourceCode(new StringCodeLoader(code)), tokens);        return tokens;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestAccessEvaluator.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import java.util.HashSet;import java.util.Objects;import java.util.Set;import apex.jorje.semantic.compiler.Namespace;import apex.jorje.semantic.compiler.StructuredVersion;import apex.jorje.semantic.compiler.sfdc.AccessEvaluator;import apex.jorje.semantic.compiler.sfdc.PlaceholderOrgPerm;import apex.jorje.semantic.symbol.type.SObjectTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfoImpl;import apex.jorje.semantic.symbol.type.TypeInfo;import com.google.common.collect.HashMultimap;import com.google.common.collect.Iterables;import com.google.common.collect.SetMultimap;/** * For now everything returns false. * If you actually need to override something, it would be easier to probably mock and adjust what you needed. * Otherwise this is simply to create a concrete representation and not force a mockito init. * * @author jspagnola */public class TestAccessEvaluator implements AccessEvaluator {    private final SetMultimap<Namespace, StructuredVersion> validPageVersions;    private final SetMultimap<SObjectTypeInfo, TypeInfo> visibleSetupEntitiesToTypes;    private final Set<Namespace> accessibleSystemNamespaces;    private final Set<PlaceholderOrgPerm> orgPerm;    private final Set<AllowedPermGuard> allowedPermGuards;    private final Set<Namespace> reservedNamespaces;    private final Set<String> globalComponents;    private final Set<Namespace> managedPackagesNotInstalled;    private final Set<String> typesWithConnectApiDeserializers;    private boolean hasInternalSfdc;    private boolean isRunningTests;    private boolean hasPrivateApi;    private boolean isTrustedApplication;    private boolean hasLocalizedTranslation;    private boolean isSfdc;    private boolean isReallyRunningTests;    private boolean hasApexGenericTypes;    private boolean hasRemoteActionPerm;    private boolean hasPersonAccountApiAvailable;    public TestAccessEvaluator() {        validPageVersions = HashMultimap.create();        visibleSetupEntitiesToTypes = HashMultimap.create();        managedPackagesNotInstalled = new HashSet<>();        accessibleSystemNamespaces = new HashSet<>();        orgPerm = new HashSet<>();        allowedPermGuards = new HashSet<>();        reservedNamespaces = new HashSet<>();        globalComponents = new HashSet<>();        typesWithConnectApiDeserializers = new HashSet<>();        hasRemoteActionPerm = true;        hasPersonAccountApiAvailable = true;    }    @Override    public boolean hasPermission(final PlaceholderOrgPerm orgPerm) {        return this.orgPerm.contains(orgPerm);    }    @Override    public boolean hasPermissionForPermGuard(final Namespace referencingNamespace, final String orgPerm) {        return allowedPermGuards.contains(new AllowedPermGuard(referencingNamespace, orgPerm));    }    @Override    public boolean hasPersonAccountApiAvailable() {        return hasPersonAccountApiAvailable;    }    @Override    public boolean hasPrivateApi() {        return hasPrivateApi;    }    @Override    public boolean hasLocalizedTranslation() {        return hasLocalizedTranslation;    }    @Override    public boolean hasInternalSfdc() {        return hasInternalSfdc;    }    @Override    public boolean isTrustedApplication(TypeInfo arg0) {        return isTrustedApplication;    }    @Override    public boolean isReservedNamespace(final Namespace namespace) {        return reservedNamespaces.contains(namespace);    }    @Override    public boolean isReservedNamespace(final Namespace namespace, final boolean excludePackages) {        return reservedNamespaces.contains(namespace);    }    /**     * See {@link #isAccessibleOrTrustedNamespace(Namespace)}     */    @Override    public boolean isAccessibleSystemNamespace(final Namespace namespace) {        return accessibleSystemNamespaces.contains(namespace);    }    /**     * Okay so this check and its partner isAccessibleSystemNamespace are used slightly differently.     * This is like a black list check, that prevents referencing code from seeing things in a reserved namespace.     * The other check allows code to see certain things if the code's namespace is a reserved namespace.     * <p>     * Hence here we return true by default, and the {@link #isAccessibleSystemNamespace(Namespace)} returns false     * by default.     */    @Override    public boolean isAccessibleOrTrustedNamespace(final Namespace namespace) {        return true;    }    @Override    public boolean isRunningTests() {        return isRunningTests;    }    @Override    public boolean isReallyRunningTests() {        return isReallyRunningTests;    }    @Override    public boolean isSfdc() {        return isSfdc;    }    @Override    public boolean hasApexParameterizedTypes() {        return hasApexGenericTypes;    }    @Override    public boolean isValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        return validPageVersions.containsEntry(namespace, version);    }    /**     * @return 'true' for everything EXCEPT namespaces you've added through {@link #addManagedPackageNotInstalled(Namespace)}     */    @Override    public boolean isManagedPackageInstalled(final Namespace namespace) {        return !managedPackagesNotInstalled.contains(namespace);    }    @Override    public boolean isSetupEntityVisibleToType(final SObjectTypeInfo type, final TypeInfo referencingType) {        final TypeInfo visibleReferencingType = Iterables.getFirst(visibleSetupEntitiesToTypes.get(type), null);        return visibleReferencingType != null            && visibleReferencingType.getBytecodeName().equals(referencingType.getBytecodeName());    }    @Override    public boolean hasConnectDeserializer(final TypeInfo type) {        return typesWithConnectApiDeserializers.contains(type.getApexName());    }    @Override    public boolean hasRemoteAction(final TypeInfo type) {        return false;    }    @Override    public boolean hasRemoteActionPerm() {        return hasRemoteActionPerm;    }    @Override    public boolean isGlobalComponent(final TypeInfo type) {        return globalComponents.contains(type.getApexName());    }    /**     * Things isManagedPackageInstalled will say 'false' to.     */    public TestAccessEvaluator addManagedPackageNotInstalled(final Namespace namespace) {        managedPackagesNotInstalled.add(namespace);        return this;    }    public TestAccessEvaluator addReservedNamespace(final Namespace namespace) {        reservedNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator addPermission(final PlaceholderOrgPerm orgPerm) {        this.orgPerm.add(orgPerm);        return this;    }    public TestAccessEvaluator setHasInternalSfdc(final boolean hasInternalSfdc) {        this.hasInternalSfdc = hasInternalSfdc;        return this;    }    public TestAccessEvaluator addValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        validPageVersions.put(namespace, version);        return this;    }    public TestAccessEvaluator addSetupEntityVisibleToType(        final SObjectTypeInfo type,        final String typeName    ) {        final StandardTypeInfo typeInfo = StandardTypeInfoImpl.builder()            .setApexName(typeName)            .setBytecodeName(typeName)            .buildResolved();        visibleSetupEntitiesToTypes.put(type, typeInfo);        return this;    }    public TestAccessEvaluator setIsRunningTests(final boolean isRunningTests) {        this.isRunningTests = isRunningTests;        return this;    }    public TestAccessEvaluator setHasPrivateApi(final boolean hasPrivateApi) {        this.hasPrivateApi = hasPrivateApi;        return this;    }    public TestAccessEvaluator setIsTrustedApplication(final boolean isTrustedApplication) {        this.isTrustedApplication = isTrustedApplication;        return this;    }    public TestAccessEvaluator setHasLocalizedTranslation(final boolean hasLocalizedTranslation) {        this.hasLocalizedTranslation = hasLocalizedTranslation;        return this;    }    public TestAccessEvaluator setIsSfdc(final boolean isSfdc) {        this.isSfdc = isSfdc;        return this;    }    public TestAccessEvaluator setIsReallyRunningTests(final boolean isReallyRunningTests) {        this.isReallyRunningTests = isReallyRunningTests;        return this;    }    public TestAccessEvaluator setAccessibleSystemNamespace(final Namespace namespace) {        accessibleSystemNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator setHasApexGenericType(final boolean hasApexGenericTypes) {        this.hasApexGenericTypes = hasApexGenericTypes;        return this;    }    public TestAccessEvaluator allowPermGuard(final Namespace namespace, final String permGuard) {        allowedPermGuards.add(new AllowedPermGuard(namespace, permGuard));        return this;    }    /**     * It appears that remote action is enabled by default in most orgs, at least test orgs.     * So we will behave the same.     */    public TestAccessEvaluator setHasRemoteActionPerm(final boolean hasRemoteActionPerm) {        this.hasRemoteActionPerm = hasRemoteActionPerm;        return this;    }    public TestAccessEvaluator setTypeWithConnectApiDeserializer(final String typeName) {        typesWithConnectApiDeserializers.add(typeName);        return this;    }    public void setGlobalComponent(final String globalComponent) {        globalComponents.add(globalComponent);    }    private static class AllowedPermGuard {        private final Namespace referencingNamespace;        private final String permGuard;        AllowedPermGuard(final Namespace namespace, final String permGuard) {            referencingNamespace = namespace;            this.permGuard = permGuard;        }        @Override        public int hashCode() {            return Objects.hash(referencingNamespace, permGuard);        }        @Override        public boolean equals(final Object obj) {            if (this == obj) {                return true;            }            if (obj == null || getClass() != obj.getClass()) {                return false;            }            final AllowedPermGuard other = (AllowedPermGuard) obj;            return Objects.equals(referencingNamespace, other.referencingNamespace)                && Objects.equals(permGuard, other.permGuard);        }    }    @Override    public boolean isSecondGenerationPackagingNamespace(Namespace namespace) {        return false;    }    @Override    public boolean useTestValueForAnonymousScriptLengthLimit() {        return false;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestQueryValidators.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import apex.jorje.semantic.ast.expression.SoqlExpression;import apex.jorje.semantic.ast.expression.SoslExpression;import apex.jorje.semantic.ast.visitor.ValidationScope;import apex.jorje.semantic.compiler.sfdc.QueryValidator;import apex.jorje.semantic.symbol.resolver.SymbolResolver;/** * The test query validators will return back the query it was given. The real implementation actually creates its own * query. * * @author jspagnola */@SuppressWarnings("PMD.MissingStaticMethodInNonInstantiatableClass") // this class provides utility classespublic final class TestQueryValidators {    private TestQueryValidators() {    }    public static class Noop implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope typeInfo,            final SoslExpression sosl        ) {            return sosl.getCanonicalQuery();        }    }    public static class Error implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            scope.getErrors().markInvalid(soql, "Bad Soql");            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope scope,            final SoslExpression sosl        ) {            scope.getErrors().markInvalid(sosl, "Bad Sosl");            return sosl.getCanonicalQuery();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.metrics.impl;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.apex.metrics.ApexMetricsHook;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clément Fournier */public class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/apex/metrics_test.xml";    @Override    protected Rule reinitializeRule(Rule rule) {        ApexMetricsHook.reset();        return rule;    }    @Override    public void setUp() {        addRule(RULESET, "CycloTest");        addRule(RULESET, "WmcTest");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.lang.apex.ast.ASTMethod;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserClassOrInterface;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers;import net.sourceforge.pmd.lang.apex.ast.ApexParserVisitorAdapter;import net.sourceforge.pmd.lang.apex.metrics.impl.AbstractApexClassMetric;import net.sourceforge.pmd.lang.apex.metrics.impl.AbstractApexOperationMetric;import net.sourceforge.pmd.lang.apex.multifile.ApexMultifileVisitorTest;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricKeyUtil;import net.sourceforge.pmd.lang.metrics.MetricMemoizer;import net.sourceforge.pmd.lang.metrics.MetricOptions;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clément Fournier */public class ApexProjectMirrorTest {    private static ApexNode<Compilation> acu;    private MetricKey<ASTUserClassOrInterface<?>> classMetricKey = MetricKeyUtil.of(null, new RandomClassMetric());    private MetricKey<ASTMethod> opMetricKey = MetricKeyUtil.of(null, new RandomOperationMetric());    static {        try {            acu = parseAndVisitForString(                IOUtils.toString(ApexMultifileVisitorTest.class.getResourceAsStream("MetadataDeployController.cls"),                        StandardCharsets.UTF_8));        } catch (IOException ioe) {            // Should definitely not happen        }    }    @Test    public void memoizationTest() {        List<Integer> expected = visitWith(acu, true);        List<Integer> real = visitWith(acu, false);        assertEquals(expected, real);    }    @Test    public void forceMemoizationTest() {        List<Integer> reference = visitWith(acu, true);        List<Integer> real = visitWith(acu, true);        assertEquals(reference.size(), real.size());        // we force recomputation so each result should be different        for (int i = 0; i < reference.size(); i++) {            assertNotEquals(reference.get(i), real.get(i));        }    }    private List<Integer> visitWith(ApexNode<Compilation> acu, final boolean force) {        final ApexProjectMemoizer toplevel = ApexMetrics.getFacade().getLanguageSpecificProjectMemoizer();        final List<Integer> result = new ArrayList<>();        acu.jjtAccept(new ApexParserVisitorAdapter() {            @Override            public Object visit(ASTMethod node, Object data) {                MetricMemoizer<ASTMethod> op = toplevel.getOperationMemoizer(node.getQualifiedName());                result.add((int) ApexMetricsComputer.getInstance().computeForOperation(opMetricKey, node, force,                                                                                  MetricOptions.emptyOptions(), op));                return super.visit(node, data);            }            @Override            public Object visit(ASTUserClass node, Object data) {                MetricMemoizer<ASTUserClassOrInterface<?>> clazz = toplevel.getClassMemoizer(node.getQualifiedName());                result.add((int) ApexMetricsComputer.getInstance().computeForType(classMetricKey, node, force,                                                                             MetricOptions.emptyOptions(), clazz));                return super.visit(node, data);            }        }, null);        return result;    }    static ApexNode<Compilation> parseAndVisitForString(String source) {        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(ApexLanguageModule.NAME)                                                                        .getDefaultVersion().getLanguageVersionHandler();        ApexNode<Compilation> acu = ApexParserTestHelpers.parse(source);        languageVersionHandler.getSymbolFacade().start(acu);        return acu;    }    private class RandomOperationMetric extends AbstractApexOperationMetric {        private Random random = new Random();        @Override        public double computeFor(ASTMethod node, MetricOptions options) {            return random.nextInt();        }    }    private class RandomClassMetric extends AbstractApexClassMetric {        private Random random = new Random();        @Override        public double computeFor(ASTUserClassOrInterface<?> node, MetricOptions options) {            return random.nextInt();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.multifile;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersionHandler;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.lang.apex.ast.ASTMethod;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.apex.ast.ApexParserTest;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers;import net.sourceforge.pmd.lang.apex.ast.ApexParserVisitorAdapter;import net.sourceforge.pmd.lang.apex.metrics.ApexSignatureMatcher;import net.sourceforge.pmd.lang.apex.metrics.signature.ApexOperationSigMask;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clément Fournier */public class ApexMultifileVisitorTest extends ApexParserTest {    @Test    public void testProjectMirrorNotNull() {        assertNotNull(ApexProjectMirror.INSTANCE);    }    @Test    public void testOperationsAreThere() throws IOException {        ApexNode<Compilation> acu = parseAndVisitForString(            IOUtils.toString(ApexMultifileVisitorTest.class.getResourceAsStream("MetadataDeployController.cls"),                    StandardCharsets.UTF_8));        final ApexSignatureMatcher toplevel = ApexProjectMirror.INSTANCE;        final ApexOperationSigMask opMask = new ApexOperationSigMask();        // We could parse qnames from string but probably simpler to do that        acu.jjtAccept(new ApexParserVisitorAdapter() {            @Override            public Object visit(ASTMethod node, Object data) {                if (!node.isSynthetic()) {                    assertTrue(toplevel.hasMatchingSig(node.getQualifiedName(), opMask));                }                return data;            }        }, null);    }    static ApexNode<Compilation> parseAndVisitForString(String source) {        LanguageVersionHandler languageVersionHandler = LanguageRegistry.getLanguage(ApexLanguageModule.NAME)                                                                        .getDefaultVersion().getLanguageVersionHandler();        ApexNode<Compilation> acu = ApexParserTestHelpers.parse(source);        languageVersionHandler.getSymbolFacade().start(acu);        languageVersionHandler.getMultifileFacade().start(acu);        return acu;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexBadCryptoTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexXSSFromURLParamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexCRUDViolationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexInsecureEndpointTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexXSSFromEscapeFalseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSOQLInjectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexOpenRedirectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSuggestUsingNamedCredTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexDangerousMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSharingViolationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyTryOrFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidNonExistentAnnotationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexCSRFTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDirectAccessTriggerMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidHardcodingIdTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.apex.metrics.ApexMetricsHook;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {    @Override    protected Rule reinitializeRule(Rule rule) {        ApexMetricsHook.reset();        return super.reinitializeRule(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import java.io.StringReader;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StdCyclomaticComplexityTest extends PmdRuleTst {    /**     * Make sure the entry stack is empty, if show classes complexity is     * disabled.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1501/">bug #1501</a>     */    @Test    public void entryStackMustBeEmpty() {        StdCyclomaticComplexityRule rule = new StdCyclomaticComplexityRule();        rule.setProperty(StdCyclomaticComplexityRule.SHOW_CLASSES_COMPLEXITY_DESCRIPTOR, Boolean.FALSE);        RuleContext ctx = new RuleContext();        LanguageVersion javaLanguageVersion = LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = javaLanguageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = javaLanguageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse("test", new StringReader("public class SampleClass {}"));        rule.apply(Arrays.asList(node), ctx);        Assert.assertTrue(rule.entryStack.isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssConstructorCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssTypeCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSoqlInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDmlStatementsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSoslInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexDocTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PropertyNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLogicInTriggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestClassShouldHaveAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidGlobalModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestMethodShouldHaveIsTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestShouldNotUseSeeAllDataTrueTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DebugsShouldUseLoggingLevelTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexParserXPathTest {    @Test    public void testBooleanExpressions() throws Exception {        ApexNode<Compilation> node = parse(IOUtils.toString(ApexParserXPathTest.class.getResourceAsStream("BooleanExpressions.cls"),                StandardCharsets.UTF_8));        List<ASTBooleanExpression> booleanExpressions = node.findDescendantsOfType(ASTBooleanExpression.class);        Assert.assertEquals(2, booleanExpressions.size());        Assert.assertEquals("&&", booleanExpressions.get(0).getOperator().toString());        Assert.assertEquals("!=", booleanExpressions.get(1).getOperator().toString());        List<? extends Node> xpathResult = node.findChildNodesWithXPath("//BooleanExpression[@Operator='&&']");        Assert.assertEquals(1, xpathResult.size());        Assert.assertSame(booleanExpressions.get(0), xpathResult.get(0));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserEnumTest {    @Test    public void testEnumName() {        ApexNode<Compilation> node = parse("class Foo { enum Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserEnum enumNode = node.getFirstDescendantOfType(ASTUserEnum.class);        Assert.assertNotNull(enumNode);        Assert.assertEquals("Bar", enumNode.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;public class ASTUserTriggerTest {    @Test    public void testTriggerName() {        ApexNode<?> node = parse("trigger HelloWorldTrigger on Book__c (before insert, after update) {\n"                + "   Book__c[] books = Trigger.new;\n" + "   MyHelloWorld.applyDiscount(books);\n" + "}\n");        Assert.assertSame(ASTUserTrigger.class, node.getClass());        Assert.assertEquals("HelloWorldTrigger", node.getImage());        ASTUserTrigger trigger = (ASTUserTrigger) node;        Assert.assertEquals("Book__c", trigger.getTargetName());        Assert.assertEquals(Arrays.asList(TriggerUsage.AFTER_UPDATE, TriggerUsage.BEFORE_INSERT), trigger.getUsages());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserClassTest {    @Test    public void testClassName() {        ApexNode<Compilation> node = parse("class Foo { }");        Assert.assertSame(ASTUserClass.class, node.getClass());        Assert.assertEquals("Foo", node.getImage());    }    @Test    public void testInnerClassName() {        ApexNode<Compilation> node = parse("class Foo { class Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass innerNode = node.getFirstDescendantOfType(ASTUserClass.class);        Assert.assertNotNull(innerNode);        Assert.assertEquals("Bar", innerNode.getImage());    }    @Test    public void testSuperClassName() {        ApexNode<?> node = parse("public class AccountTriggerHandler extends TriggerHandler {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals("TriggerHandler", toplevel.getSuperClassName());    }    @Test    public void testSuperClassName2() {        ApexNode<?> node = parse("public class AccountTriggerHandler extends Other.TriggerHandler {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals("Other.TriggerHandler", toplevel.getSuperClassName());    }    @Test    public void testInterfaces() {        ApexNode<?> node = parse("public class AccountTriggerHandler implements TriggerHandler, Other.Interface2 {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals(Arrays.asList("TriggerHandler", "Other.Interface2"), toplevel.getInterfaceNames());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTFieldTest {    @Test    public void testGetType() {        ApexNode<Compilation> node = parse("public class Foo { private String myField = 'a'; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertEquals("myField", field.getImage());        Assert.assertEquals("String", field.getType());        Assert.assertEquals("a", field.getValue());    }    @Test    public void testGetValue() {        ApexNode<Compilation> node = parse("public class Foo { private String myField = 'a'; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertEquals("a", field.getValue());    }    @Test    public void testGetNoValue() {        ApexNode<Compilation> node = parse("public class Foo { private String myField; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertNull(field.getValue());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.antlr.runtime.ANTLRStringStream;import org.antlr.runtime.CharStream;import org.antlr.runtime.CommonTokenStream;import org.antlr.runtime.Token;import org.junit.Assert;import org.junit.Test;import apex.jorje.data.ast.CompilationUnit;import apex.jorje.parser.impl.ApexLexer;import apex.jorje.parser.impl.ApexParser;public class ApexLexerTest {    private static final String CODE = "public class Foo {\n"            + "   public List<SObject> test1() {\n"            + "       return Database.query(\"Select Id from Account LIMIT 100\");\n"            + "   }\n"            + "}\n";    @Test    public void testLexer() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);                Token token = lexer.nextToken();        int tokenCount = 0;        while (token.getType() != Token.EOF) {            tokenCount++;            token = lexer.nextToken();        }        Assert.assertEquals(43, tokenCount);    }    @Test    public void testParser() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        ApexParser parser = new ApexParser(new CommonTokenStream(lexer));        CompilationUnit compilationUnit = parser.compilationUnit();        Assert.assertNotNull(compilationUnit);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.io.StringReader;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.apex.ApexParserOptions;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexCompilerSoqlTest {    private static final String CODE = "public class Foo {\n"            + "   public List<SObject> test1() {\n"            + "       return Database.query(\'Select Id from Account LIMIT 100\');\n"            + "   }\n"            + "}\n";    @Test    public void testSoqlCompilation() {        ApexParser parser = new ApexParser(new ApexParserOptions());        ApexNode<Compilation> cu = parser.parse(new StringReader(CODE));        Assert.assertNotNull(cu);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTSoqlExpressionTest {    @Test    public void testQuery() {        ApexNode<Compilation> node = parse("class Foo { void test1() { Account acc = [SELECT 1 FROM Account]; } }");        ASTSoqlExpression soqlExpression = node.getFirstDescendantOfType(ASTSoqlExpression.class);        Assert.assertEquals("SELECT 1 FROM Account", soqlExpression.getQuery());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTNewKeyValueObjectExpressionTest {    @Test    public void testParameterName() {        ApexNode<Compilation> node = parse("public class Foo { \n"                + "    public void foo(String newName, String tempID) { \n"                + "        if (Contact.sObjectType.getDescribe().isCreateable() && Contact.sObjectType.getDescribe().isUpdateable()) {\n"                + "            upsert new Contact(FirstName = 'First', LastName = 'Last', Phone = '414-414-4414');\n"                + "        }\n" + "    } \n" + "}");        ASTNewKeyValueObjectExpression keyValueExpr = node.getFirstDescendantOfType(ASTNewKeyValueObjectExpression.class);        Assert.assertEquals(3, keyValueExpr.getParameterCount());        List<ASTLiteralExpression> literals = keyValueExpr.findDescendantsOfType(ASTLiteralExpression.class);        Assert.assertEquals(3, literals.size());        Assert.assertEquals("FirstName", literals.get(0).getName());        Assert.assertEquals("LastName", literals.get(1).getName());        Assert.assertEquals("Phone", literals.get(2).getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.util.List;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clément Fournier */public class ApexQualifiedNameTest {    @Test    public void testClass() {        ApexNode<Compilation> root = ApexParserTestHelpers.parse("public class Foo {}");        ApexQualifiedName qname = ASTUserClass.class.cast(root).getQualifiedName();        assertEquals("c__Foo", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    public void testNestedClass() {        ApexNode<Compilation> root = ApexParserTestHelpers.parse("public class Foo { class Bar {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTUserClass.class).getQualifiedName();        assertEquals("c__Foo.Bar", qname.toString());        assertEquals(2, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    public void testSimpleMethod() {        ApexNode<Compilation> root = ApexParserTestHelpers.parse("public class Foo { String foo() {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTMethod.class).getQualifiedName();        assertEquals("c__Foo#foo()", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo()", qname.getOperation());    }    @Test    public void testMethodWithArguments() {        ApexNode<Compilation> root = ApexParserTestHelpers.parse("public class Foo { String foo(String h, Foo g) {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTMethod.class).getQualifiedName();        assertEquals("c__Foo#foo(String,Foo)", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo(String,Foo)", qname.getOperation());    }    @Test    public void testOverLoads() {        ApexNode<Compilation> root = ApexParserTestHelpers.parse("public class Foo { "                                                                 + "String foo(String h) {} "                                                                 + "String foo(int c) {}"                                                                 + "String foo(Foo c) {}}");        List<ASTMethod> methods = root.findDescendantsOfType(ASTMethod.class);        for (ASTMethod m1 : methods) {            for (ASTMethod m2 : methods) {                if (m1 != m2) {                    assertNotEquals(m1.getQualifiedName(), m2.getQualifiedName());                }            }        }    }    @Test    public void testTrigger() {        ApexNode<Compilation> root = ApexParserTestHelpers.parse("trigger myAccountTrigger on Account (before insert, before update) {}");        List<ASTMethod> methods = root.findDescendantsOfType(ASTMethod.class);        for (ASTMethod m : methods) {            assertEquals("c__trigger.Account#myAccountTrigger", m.getQualifiedName().toString());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexParserTest {    @Test    public void understandsSimpleFile() {        // Setup        String code = "@isTest\n public class SimpleClass {\n" + "    @isTest\n public static void testAnything() {\n"                + "        \n" + "    }\n" + "}";        // Exercise        ApexNode<Compilation> rootNode = parse(code);        // Verify        List<ASTMethod> methods = rootNode.findDescendantsOfType(ASTMethod.class);        assertEquals(4, methods.size());    }    private String testCodeForLineNumbers =              "public class SimpleClass {\n" // line 1            + "    public void method1() {\n" // line 2            + "        System.out.println(\"abc\");\n" // line 3            + "        // this is a comment\n" // line 4            + "    }\n" // line 5            + "}\n"; // line 6    @Test    public void verifyLineColumNumbers() {        ApexNode<Compilation> rootNode = parse(testCodeForLineNumbers);        assertLineNumbersForTestCode(rootNode);    }    @Test    public void verifyLineColumNumbersWithWindowsLineEndings() {        String windowsLineEndings = testCodeForLineNumbers.replaceAll(" \n", "\r\n");        ApexNode<Compilation> rootNode = parse(windowsLineEndings);        assertLineNumbersForTestCode(rootNode);    }    private void assertLineNumbersForTestCode(ApexNode<Compilation> rootNode) {        // whole source code, well from the beginning of the class        // name Modifier of the class - doesn't work. This node just        // sees the identifier ("SimpleClass")        // assertPosition(rootNode.jjtGetChild(0), 1, 1, 1, 6);        // "public"        assertPosition(rootNode, 1, 14, 6, 2);        // "method1" - starts with identifier until end of its block statement        Node method1 = rootNode.jjtGetChild(1);        assertPosition(method1, 2, 17, 5, 5);        // Modifier of method1 - doesn't work. This node just sees the        // identifier ("method1")        // assertPosition(method1.jjtGetChild(0), 2, 17, 2, 20); // "public" for        // method1        // BlockStatement - the whole method body        Node blockStatement = method1.jjtGetChild(1);        assertTrue(((ASTBlockStatement) blockStatement).hasCurlyBrace());        assertPosition(blockStatement, 2, 27, 5, 5);        // the expression ("System.out...")        Node expressionStatement = blockStatement.jjtGetChild(0);        assertPosition(expressionStatement, 3, 9, 3, 34);    }    @Test    public void verifyEndLine() {        String code = "public class SimpleClass {\n" // line 1                + "    public void method1() {\n" // line 2                + "    }\n" // line 3                + "    public void method2() {\n" // line 4                + "    }\n" // line 5                + "}\n"; // line 6        ApexNode<Compilation> rootNode = parse(code);        Node method1 = rootNode.jjtGetChild(1);        assertEquals("Wrong begin line", 2, method1.getBeginLine());        assertEquals("Wrong end line", 3, method1.getEndLine());        Node method2 = rootNode.jjtGetChild(2);        assertEquals("Wrong begin line", 4, method2.getBeginLine());        assertEquals("Wrong end line", 5, method2.getEndLine());    }    @Test    public void parsesRealWorldClasses() throws Exception {        File directory = new File("src/test/resources");        File[] fList = directory.listFiles();        for (File file : fList) {            if (file.isFile() && file.getName().endsWith(".cls")) {                String sourceCode = FileUtils.readFileToString(file, StandardCharsets.UTF_8);                ApexNode<Compilation> rootNode = parse(sourceCode);                Assert.assertNotNull(rootNode);            }        }    }    /**     * See github issue #1546     * @see <a href="https://github.com/pmd/pmd/issues/1546">[apex] PMD parsing exception for Apex classes using 'inherited sharing' keyword</a>     */    @Test    public void parseInheritedSharingClass() throws IOException {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("InheritedSharing.cls"),                StandardCharsets.UTF_8);        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);    }    /**     * See bug #1485     *      * @see <a href="https://sourceforge.net/p/pmd/bugs/1485/">#1485 [apex] Analysis of some apex classes cause a stackoverflow error</a>     */    @Test    public void stackOverflowDuringClassParsing() throws Exception {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("StackOverflowClass.cls"),                StandardCharsets.UTF_8);        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);        int count = visitPosition(rootNode, 0);        Assert.assertEquals(427, count);    }    private int visitPosition(Node node, int count) {        int result = count + 1;        Assert.assertTrue(node.getBeginLine() > 0);        Assert.assertTrue(node.getBeginColumn() > 0);        Assert.assertTrue(node.getEndLine() > 0);        Assert.assertTrue(node.getEndColumn() > 0);        for (int i = 0; i < node.jjtGetNumChildren(); i++) {            result = visitPosition(node.jjtGetChild(i), result);        }        return result;    }    // TEST HELPER    private static void assertPosition(Node node, int beginLine, int beginColumn, int endLine, int endColumn) {        assertEquals("Wrong begin line", beginLine, node.getBeginLine());        assertEquals("Wrong begin column", beginColumn, node.getBeginColumn());        assertEquals("Wrong end line", endLine, node.getEndLine());        assertEquals("Wrong end column", endColumn, node.getEndColumn());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTMethodTest {    @Test    public void testConstructorName() {        ApexNode<Compilation> node = parse("public class Foo { public Foo() {} public void bar() {} }");        Assert.assertSame(ASTUserClass.class, node.getClass());        List<ASTMethod> methods = node.findChildrenOfType(ASTMethod.class);        Assert.assertEquals("Foo", methods.get(0).getImage()); // constructor        Assert.assertEquals("bar", methods.get(1).getImage()); // normal method    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static net.sourceforge.pmd.lang.apex.ast.ApexParserTestHelpers.parse;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserInterfaceTest {    @Test    public void testInterfaceName() {        ApexNode<Compilation> node = parse("interface Foo { }");        Assert.assertSame(ASTUserInterface.class, node.getClass());        Assert.assertEquals("Foo", node.getImage());    }    @Test    public void testInnerInterfaceName() {        ApexNode<Compilation> node = parse("class Foo { interface Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserInterface innerNode = node.getFirstDescendantOfType(ASTUserInterface.class);        Assert.assertNotNull(innerNode);        Assert.assertEquals("Bar", innerNode.getImage());    }    @Test    public void testSuperInterface() {        ApexNode<?> node = parse("public interface CustomInterface extends A {}");        Assert.assertSame(ASTUserInterface.class, node.getClass());        ASTUserInterface toplevel = (ASTUserInterface) node;        Assert.assertEquals("A", toplevel.getSuperInterfaceName());    }    @Test    public void testSuperInterface2() {        ApexNode<?> node = parse("public interface CustomInterface extends Other.A {}");        Assert.assertSame(ASTUserInterface.class, node.getClass());        ASTUserInterface toplevel = (ASTUserInterface) node;        Assert.assertEquals("Other.A", toplevel.getSuperInterfaceName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;import net.sourceforge.pmd.testframework.RuleTst;public class SuppressWarningsTest extends RuleTst {    private static class BarRule extends AbstractApexRule {        @Override        public Object visit(ASTUserClass clazz, Object ctx) {            if (clazz.getImage().equalsIgnoreCase("bar")) {                addViolation(ctx, clazz);            }            return super.visit(clazz, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    public void testClassLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST1, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());        runTestFromString(TEST2, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testInheritedSuppression() {        Report rpt = new Report();        runTestFromString(TEST3, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testMethodLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST4, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testConstructorLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST5, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testFieldLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST6, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testParameterLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST7, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testLocalVariableLevelSuppression() {        Report rpt = new Report();        runTestFromString(TEST8, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppression() {        Report rpt = new Report();        runTestFromString(TEST9, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(1, rpt.size());    }    @Test    public void testSpecificSuppressionMulitpleValues() {        Report rpt = new Report();        runTestFromString(TEST9_MULTIPLE_VALUES, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testNoSuppressionBlank() {        Report rpt = new Report();        runTestFromString(TEST10, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(2, rpt.size());    }    @Test    public void testNoSuppressionSomethingElseS() {        Report rpt = new Report();        runTestFromString(TEST11, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(2, rpt.size());    }    @Test    public void testSuppressAll() {        Report rpt = new Report();        runTestFromString(TEST12, new FooRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    @Test    public void testSpecificSuppressionAtTopLevel() {        Report rpt = new Report();        runTestFromString(TEST13, new BarRule(), rpt,                LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion());        assertEquals(0, rpt.size());    }    private static final String TEST1 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {}";    private static final String TEST2 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST3 = "public class Baz {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public class Bar {" + PMD.EOL + "  void bar() {" + PMD.EOL + "   Integer foo;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "public class Foo {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST5 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public Bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST6 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST7 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL            + " void bar(@SuppressWarnings('PMD') Integer foo) {}" + PMD.EOL + "}";    private static final String TEST8 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD.NoFoo') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_MULTIPLE_VALUES = "@SuppressWarnings('PMD.NoFoo, PMD.NoBar')"            + PMD.EOL + "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL            + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST10 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST11 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('SomethingElse') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST12 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('all') Integer foo;"            + PMD.EOL + "}";    private static final String TEST13 = "@SuppressWarnings('PMD.NoBar')" + PMD.EOL + "public class Bar {" + PMD.EOL            + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.AbstractLanguageVersionTest;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<?> data() {        return Arrays.asList(new Object[][] { { ApexLanguageModule.NAME, ApexLanguageModule.TERSE_NAME, "35",            LanguageRegistry.getLanguage("Apex").getVersion("35"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.logging.Handler;import java.util.logging.LogRecord;import java.util.logging.Logger;import org.junit.After;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import net.sourceforge.pmd.RulePriority;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.util.ResourceLoader;public class DefaultRulesetTest {    @Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    private RuleSetFactory factory = new RuleSetFactory(new ResourceLoader(), RulePriority.LOW, true, false);    @Test    public void loadDefaultRuleset() throws Exception {        RuleSet ruleset = factory.createRuleSet("rulesets/apex/ruleset.xml");        Assert.assertNotNull(ruleset);    }    @After    public void cleanup() {        Handler[] handlers = Logger.getLogger(RuleSetFactory.class.getName()).getHandlers();        for (Handler handler : handlers) {            Logger.getLogger(RuleSetFactory.class.getName()).removeHandler(handler);        }    }    @Test    public void loadQuickstartRuleset() throws Exception {        Logger.getLogger(RuleSetFactory.class.getName()).addHandler(new Handler() {            @Override            public void publish(LogRecord record) {                Assert.fail("No Logging expected: " + record.getMessage());            }            @Override            public void flush() {            }            @Override            public void close() throws SecurityException {            }        });        RuleSet ruleset = factory.createRuleSet("rulesets/apex/quickstart.xml");        Assert.assertNotNull(ruleset);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;import net.sourceforge.pmd.lang.apex.rule.ApexXPathRule;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    public RuleSetFactoryTest() {        super();        validXPathClassNames.add(ApexXPathRule.class.getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.util.Iterator;import org.apache.commons.io.FilenameUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;public class ApexCpdTest {    private File testdir;    @Before    public void setUp() {        String path = FilenameUtils.normalize("src/test/resources/net/sourceforge/pmd/cpd/issue427");        testdir = new File(path);    }    @Test    public void testIssue427() throws IOException {        CPDConfiguration configuration = new CPDConfiguration();        configuration.setMinimumTileSize(10);        configuration.setLanguage(LanguageFactory.createLanguage(ApexLanguageModule.TERSE_NAME));        CPD cpd = new CPD(configuration);        cpd.add(new File(testdir, "SFDCEncoder.cls"));        cpd.add(new File(testdir, "SFDCEncoderConstants.cls"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        int duplications = 0;        while (matches.hasNext()) {            matches.next();            duplications++;        }        assertEquals(1, duplications);        Match firstDuplication = cpd.getMatches().next();        assertTrue(firstDuplication.getSourceCodeSlice().startsWith("global with sharing class SFDCEncoder"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.fail;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Properties;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader;public class ApexTokenizerTest {    @Test    public void testTokenize() throws IOException {        Tokens tokens = tokenize(load("Simple.cls"));        if (tokens.size() != 28) {            printTokens(tokens);        }        assertEquals(28, tokens.size());        assertEquals("someparam", findTokensByLine(8, tokens).get(0).toString());    }    @Test    public void testTokenizeCaseSensitive() throws IOException {        Tokens tokens = tokenize(load("Simple.cls"), true);        if (tokens.size() != 28) {            printTokens(tokens);        }        assertEquals(28, tokens.size());        assertEquals("someParam", findTokensByLine(8, tokens).get(0).toString());    }    /**     * Comments are ignored since using ApexLexer.     */    @Test    public void testTokenizeWithComments() throws IOException {        Tokens tokens = tokenize(load("issue427/SFDCEncoder.cls"));        assertEquals(17, tokens.size());        Tokens tokens2 = tokenize(load("issue427/SFDCEncoderConstants.cls"));        assertEquals(17, tokens2.size());    }    private List<TokenEntry> findTokensByLine(int line, Tokens tokens) {        List<TokenEntry> result = new ArrayList<>();        for (TokenEntry entry : tokens.getTokens()) {            if (entry.getBeginLine() == line) {                result.add(entry);            }        }        if (result.isEmpty()) {            fail("Not tokens found at line " + line);        }        return result;    }    private Tokens tokenize(String code) {        return tokenize(code, false);    }    private Tokens tokenize(String code, boolean caseSensitive) {        ApexTokenizer tokenizer = new ApexTokenizer();        Properties properties = new Properties();        properties.setProperty(ApexTokenizer.CASE_SENSITIVE, Boolean.toString(caseSensitive));        tokenizer.setProperties(properties);        Tokens tokens = new Tokens();        tokenizer.tokenize(new SourceCode(new StringCodeLoader(code)), tokens);        return tokens;    }    private void printTokens(Tokens tokens) {        for (TokenEntry entry : tokens.getTokens()) {            System.out.printf("%02d: %s%s", entry.getBeginLine(), entry.toString(), PMD.EOL);        }    }    private String load(String name) throws IOException {        return IOUtils.toString(ApexTokenizerTest.class.getResourceAsStream(name), StandardCharsets.UTF_8);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.it;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import org.apache.commons.io.FileUtils;import org.junit.AfterClass;import org.junit.BeforeClass;import net.sourceforge.pmd.PMDVersion;public abstract class AbstractBinaryDistributionTest {    protected static File getBinaryDistribution() {        return new File(".", "target/pmd-bin-" + PMDVersion.VERSION + ".zip");    }    /**     * The temporary directory, to which the binary distribution will be extracted.     * It will be deleted again after the test.     */    protected static Path tempDir;    @BeforeClass    public static void setupTempDirectory() throws Exception {        tempDir = Files.createTempDirectory("pmd-it-test-");        if (getBinaryDistribution().exists()) {            ZipFileExtractor.extractZipFile(getBinaryDistribution().toPath(), tempDir);        }    }    @AfterClass    public static void cleanupTempDirectory() throws IOException {        if (tempDir != null && tempDir.toFile().exists()) {            FileUtils.forceDelete(tempDir.toFile());        }    }}