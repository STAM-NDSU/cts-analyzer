/* *  */package test.net.sourceforge.pmd.jdbc;import com.mockobjects.sql.MockConnection;import com.mockobjects.sql.MockDriver;import com.mockobjects.sql.MockPreparedStatement;import com.mockobjects.sql.MockSingleRowResultSet;import junit.framework.TestCase;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.jdbc.JDBCReportListener;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.MockRule;import java.sql.Date;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Properties;public class JDBCReportListenerTest extends TestCase {    private MockDriver driver = null;    private MockPreparedStatement violInsert = null;    private MockPreparedStatement metInsert = null;    public void setUp() {driver = new MockDriver();try {    DriverManager.registerDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    public void tearDown() {try {    DriverManager.deregisterDriver( driver );} catch (Exception e) {    e.printStackTrace();}    }    private class MockInsertPMDRunsextends MockPreparedStatement    {private int runId = 0;public MockInsertPMDRuns( int projectId, int runId ) {    //    setExpectedQueryString("INSERT INTO PMD_RUNS (PROJECT_ID, RUN_DATE) VALUES (?, ?)");    addExpectedSetParameter( 1, projectId );    this.runId = runId;}public void setDate( int position, Date dateTime ) {    assertEquals("Date in wrong position.", 2, position);    assertTrue( "Didn't add the current date.",dateTime.getTime() > System.currentTimeMillis() - 5000);    assertTrue( "Set a future date.",dateTime.getTime() < System.currentTimeMillis() + 5000);}public ResultSet getGeneratedKeys() {    MockSingleRowResultSet RC = new MockSingleRowResultSet();    RC.addExpectedIndexedValues( new Object[] { new Integer(runId) });    return RC;}    }    private class MockPMDConxextends MockConnection    {public MockPMDConx( int projectId, int runId ) {    super();    setupAddPreparedStatement( new MockInsertPMDRuns( projectId, runId ) );    violInsert = new MockPreparedStatement();    setupAddPreparedStatement( violInsert );        metInsert = new MockPreparedStatement();    setupAddPreparedStatement( metInsert );}public PreparedStatement prepareStatement( String sql, int returnKeys )    throws SQLException{    assertEquals( "Not set to return generated keys.",   returnKeys, Statement.RETURN_GENERATED_KEYS );    return prepareStatement( sql );}    }    public JDBCReportListener getIUT(int projectId) throws SQLException    {return new JDBCReportListener( "jdbc:mock:getIUT",       "iut_user", "iut_pw", projectId );    }    public void testLongConstructor() throws Throwable {MockConnection conx = new MockPMDConx(1, 5);driver.setupConnect( conx );new JDBCReportListener("jdbc:mock:testLongConstructor", "tlc_user", "tlc_pw", 1);    }    public void testPropConstructor() throws Throwable {MockConnection conx = new MockPMDConx(2, 8);driver.setupConnect( conx );Properties props = new Properties();props.put( JDBCReportListener.JDBC_URL, "jdbc:mock:testPropConstructor" );props.put( JDBCReportListener.JDBC_USER, "tpc_user" );props.put( JDBCReportListener.JDBC_PASSWORD, "tpc_pw" );props.put( JDBCReportListener.JDBC_PROJECTID, "2");new JDBCReportListener(props);    }    public void testSingleViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );JDBCReportListener IUT = getIUT( 16 );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));    }    public void testMultiViolation() throws Throwable {MockConnection conx = new MockPMDConx( 16, 36 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 16 );violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileA" );      // File NameviolInsert.addExpectedSetParameter( 4, 256 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageB" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classC" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msg" );RuleContext ctx = new RuleContext();ctx.setSourceCodeFilename( "fileA" );ctx.setPackageName( "packageB" );ctx.setClassName( "classC" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1", "Description", "msg" ),    256, ctx ));violInsert.addExpectedSetParameter( 1, 36 ); // Run IDviolInsert.addExpectedSetParameter( 2, "viol1a" ); // RuleviolInsert.addExpectedSetParameter( 3, "fileAa" );      // File NameviolInsert.addExpectedSetParameter( 4, 2561 );          // Line NumberviolInsert.addExpectedSetParameter( 5, "packageBa" );   // Package NameviolInsert.addExpectedSetParameter( 6, "classCa" );     // Class NameviolInsert.addExpectedSetParameter( 7, "msga" );ctx = new RuleContext();ctx.setSourceCodeFilename( "fileAa" );ctx.setPackageName( "packageBa" );ctx.setClassName( "classCa" );IUT.ruleViolationAdded( new RuleViolation( new MockRule("viol1a", "Descriptiona", "msga" ),    2561, ctx ));    }    public void testSingleMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "single" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));JDBCReportListener IUT = getIUT( 18 );IUT.metricAdded( new Metric("single", 5, 30, 1.0, 6.0, 3.0, 1.5) );    }    public void testMultiMetric() throws Throwable {MockConnection conx = new MockPMDConx( 18, 378 );driver.setupConnect( conx );JDBCReportListener IUT = getIUT( 18 );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "first" );metInsert.addExpectedSetParameter( 3, new Double( 1.0 ));metInsert.addExpectedSetParameter( 4, new Double( 6.0 ));metInsert.addExpectedSetParameter( 5, new Double( 3.0 ));metInsert.addExpectedSetParameter( 6, new Double( 1.5 ));IUT.metricAdded( new Metric("first", 5, 30, 1.0, 6.0, 3.0, 1.5) );metInsert.addExpectedSetParameter( 1, 378 );metInsert.addExpectedSetParameter( 2, "second" );metInsert.addExpectedSetParameter( 3, new Double( 1.01 ));metInsert.addExpectedSetParameter( 4, new Double( 6.01 ));metInsert.addExpectedSetParameter( 5, new Double( 3.01 ));metInsert.addExpectedSetParameter( 6, new Double( 1.51 ));IUT.metricAdded( new Metric("second", 7, 32.5, 1.01, 6.01, 3.01, 1.51) );    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.util;import junit.framework.TestCase;import net.sourceforge.pmd.util.Applier;import net.sourceforge.pmd.util.UnaryFunction;import java.util.ArrayList;import java.util.List;public class ApplierTest extends TestCase {    private static class MyFunction implements UnaryFunction {        private boolean gotCallback;        public void applyTo(Object o) {            this.gotCallback = true;        }        public boolean gotCallback() {            return this.gotCallback;        }    }    public void testSimple() {        MyFunction f = new MyFunction();        List l = new ArrayList();        l.add(new Object());        Applier.apply(f, l.iterator());        assertTrue(f.gotCallback());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.testframework;import net.sourceforge.pmd.Rule;public class TestDescriptor {    public String code;    public String description;    public int numberOfProblemsExpected;    public Rule rule;    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;    }}
/** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.AssertionFailedError;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.stat.DataPoint;import net.sourceforge.pmd.stat.Metric;import net.sourceforge.pmd.stat.StatisticalRule;import net.sourceforge.pmd.symboltable.SourceFileScope;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.Random;/** * This class tests the Statistical Rules in PMD. * * The idea is, that we fill up 999 datapoints into * the Stat Rule, and then throw random parameters * at it. * * The three parameters which are checked are: * sigma - # Sigmas over the mean. * topscore - Only the top 5 or so items. * minimum - Only things of score 10 or better * * When more than one parameter is lumped together, then * we expect the one which would return the fewest to * determine what gets sent back. * * So, we throw each collection of parameters, where each * one is a different order into the system.  We check the * results off of what the smallest value should be. * * If you are going to work with StatisticalRule any, please * bump the "NUM_TESTS" number up to something like 128.  That * way you are more likely to identify problems.  It is set low * now to make building and running tests easier (when we aren't * touching the file.) * * Note also, that when verifying the Sigma, I wasn't quite able * to determine how many results it would return (it would vary * from -2 to 2 of what I expected.)  That is what the delta * parameter on the verify method takes.  If you can figure it * out exactly, (without stealing code from the StatRule) then * feel free to change it and tighten the deltas. */public class StatisticalRuleTest extends TestCase {    private static final int POINTS = 100;    private DataPoint points[] = new DataPoint[POINTS];    private MockStatisticalRule IUT = null;    private String testName = null;    private Random random = new Random();    public static final double MAX_MINIMUM = POINTS;    public static final double NO_MINIMUM = -1.0;    public static final double MAX_SIGMA = 5.0;    public static final double NO_SIGMA = -1.0;    public static final int MIN_TOPSCORE = 0;    public static final int NO_TOPSCORE = -1;    public static final double MEAN = 49.5;    public static final double SIGMA = 29.0115;    public static final int NUM_TESTS = 1;    public static final double DELTA = 0.005;    public StatisticalRuleTest(String name) {        super(name);        this.testName = name;    }    public void setUp() {        IUT = new MockStatisticalRule();        if (testName.endsWith("0")) {            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                SimpleNode s = new SimpleNode(1);                s.setScope(new SourceFileScope("foo"));                s.testingOnly__setBeginLine(i);                s.testingOnly__setBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else if (testName.endsWith("1")) {            for (int i = POINTS-1; i >= 0; i--) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                SimpleNode s = new SimpleNode(1);                s.setScope(new SourceFileScope("foo"));                s.testingOnly__setBeginLine(i);                s.testingOnly__setBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                IUT.addDataPoint(points[i]);            }        } else {            List lPoints = new ArrayList();            for (int i = 0; i < POINTS; i++) {                points[i] = new DataPoint();                points[i].setScore(1.0 * i);                SimpleNode s = new SimpleNode(1);                s.setScope(new SourceFileScope("foo"));                s.testingOnly__setBeginLine(i);                s.testingOnly__setBeginColumn(1);                s.testingOnly__setBeginColumn(1);                points[i].setNode(s);                points[i].setMessage("DataPoint[" + Integer.toString(i) + "]");                lPoints.add(points[i]);            }            Collections.shuffle(lPoints);            for (int i = 0; i < POINTS; i++) {                IUT.addDataPoint((DataPoint) lPoints.get(i));            }        }    }    /**                           * This test verifies that the Stat rule creates a Metric,     * with the proper values.     */    public void testMetrics() throws Throwable {        Report report = makeReport(IUT);        Iterator metrics = report.metrics();        assertTrue(metrics.hasNext());        Object o = metrics.next();        assertTrue(o instanceof Metric);        Metric m = (Metric) o;        assertEquals("test.net.sourceforge.pmd.stat.MockStatisticalRule", m.getMetricName());        assertEquals(0.0, m.getLowValue(), 0.05);        assertEquals(POINTS -1.0, m.getHighValue(), 0.05);        assertEquals(MEAN, m.getAverage(), 0.05);        assertEquals(SIGMA, m.getStandardDeviation(), 0.05);    }    /**     * This returns a Random value for Sigma which will     * return some values.     */    public double randomSigma() {        return random.nextDouble() * 1.0;    }    /**     * This returns a Random value for Sigma which value     * is greater than the parameter.     */    public double randomSigma(int minimum) {        double minSigma = ((POINTS -1 - minimum) - MEAN) / SIGMA;        if ((minSigma <= 0) || (minSigma > 2))            return randomSigma();        return minSigma + (random.nextDouble() * (2 - minSigma));    }    /**     * This returns the expected number of results when     * the Sigma rating is the smallest.     */    public int expectedSigma(double sigma) {        long expectedMin = Math.round(MEAN + (sigma * SIGMA));        if (((POINTS -1) - expectedMin) < 0)            return 0;        return (POINTS -1) - (int) expectedMin;    }    /**     * This generates a random minimum value for testing.     */    public double randomMinimum() {        return random.nextDouble() * (POINTS -1);    }    /**     * This generates a random minimum value for which fewer     * results would be returned.     */    public double randomMinimum(int minimum) {        double diffTarget = 1.0 * (POINTS -1 - minimum);        return (random.nextDouble() * minimum) + diffTarget;    }    /**     * This returns the expected number of reports.     *     * If the Minimum comes in at 521.569 then we expect     * 522, 523, ... 999 will pass.     */    public int expectedMinimum(double minimum) {        Double d = new Double(minimum);        return POINTS -1 - d.intValue();    }    public void testExpectedMinimum() {        for (int i = 0; i < POINTS -1; i++) {            assertEquals("Integer Min", POINTS -1 - i, expectedMinimum(i * 1.0));            assertEquals("Double Min", POINTS -1 - i, expectedMinimum((i * 1.0) + 0.5));        }    }    /**     * This returns a random value for Top Score.     */    public int randomTopScore() {        return random.nextInt(POINTS -1);    }    /**     * This will return a random value for the Top Score     * which will return more than the minimum provided.     */    public int randomTopScore(double target) {        if (target < 0)            return 0;        return random.nextInt((new Double(target)).intValue());    }    /**     * This will return the expected number of results     * with the given Top Score.     */    public int expectedTopScore(int target) {        return target;    }    // Test Single Datapoint    public void testSingleDatapoint() {        StatisticalRule IUT = new MockStatisticalRule();        DataPoint point = new DataPoint();        point.setScore(POINTS + 1.0);        SimpleNode s = new SimpleNode(1);        s.setScope(new SourceFileScope("foo"));        s.testingOnly__setBeginLine(POINTS + 1);        s.testingOnly__setBeginColumn(1);        point.setNode(s);        point.setMessage("SingleDataPoint");        IUT.addProperty("minimum", Integer.toString(POINTS));        IUT.addDataPoint(point);        Report report = makeReport(IUT);        assertEquals("Expecting only one result.", 1, report.size());    }    // Okay, we have three properties we need to    // test in Combination:    //  S = Sigma    //  T = Top Score    //  M = Minimum    //    // They are listed in decreasing order of what    // to expect.    //    // Thus testSM() should have the Sigma less than    // the minimum, so we expect the Minimum # of results.    //    public void testS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, NO_TOPSCORE, 0, 2);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            verifyResults(sigma, -1.0, -1, expectedSigma(sigma), 2);        }    }    public void testS1() throws Throwable {        testS();    }    public void testS2() throws Throwable {        testS();    }    public void testS3() throws Throwable {        testS();    }    public void testS4() throws Throwable {        testS();    }    public void testS5() throws Throwable {        testS();    }    public void testT() throws Throwable {        verifyResults(NO_SIGMA, NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            verifyResults(-1.0, -1.0, topScore, expectedTopScore(topScore), 0);        }    }    public void testT1() throws Throwable {        testT();    }    public void testT2() throws Throwable {        testT();    }    public void testT3() throws Throwable {        testT();    }    public void testT4() throws Throwable {        testT();    }    public void testT5() throws Throwable {        testT();    }    public void testM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            verifyResults(-1.0, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testM1() throws Throwable {        testM();    }    public void testM2() throws Throwable {        testM();    }    public void testM3() throws Throwable {        testM();    }    public void testM4() throws Throwable {        testM();    }    public void testM5() throws Throwable {        testM();    }    public void testST() throws Throwable {        verifyResults(randomSigma(), NO_MINIMUM, MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            verifyResults(sigma, NO_MINIMUM, topScore, expectedTopScore(topScore), 0);        }    }    public void testST1() throws Throwable {        testST();    }    public void testST2() throws Throwable {        testST();    }    public void testST3() throws Throwable {        testST();    }    public void testST4() throws Throwable {        testST();    }    public void testST5() throws Throwable {        testST();    }    public void testTS() throws Throwable {        verifyResults(MAX_SIGMA, NO_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            verifyResults(sigma, -1.0, topScore, expectedSigma(sigma), 2);        }    }    public void testTS1() throws Throwable {        testTS();    }    public void testTS2() throws Throwable {        testTS();    }    public void testTS3() throws Throwable {        testTS();    }    public void testTS4() throws Throwable {        testTS();    }    public void testTS5() throws Throwable {        testTS();    }    public void testSM() throws Throwable {        verifyResults(randomSigma(), MAX_MINIMUM, NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, -1, expectedMinimum(minimum), 0);        }    }    public void testSM1() throws Throwable {        testSM();    }    public void testSM2() throws Throwable {        testSM();    }    public void testSM3() throws Throwable {        testSM();    }    public void testSM4() throws Throwable {        testSM();    }    public void testSM5() throws Throwable {        testSM();    }    public void testMS() throws Throwable {        verifyResults(MAX_SIGMA, randomMinimum(), NO_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, -1, expectedSigma(sigma), 2);        }    }    public void testMS1() throws Throwable {        testMS();    }    public void testMS2() throws Throwable {        testMS();    }    public void testMS3() throws Throwable {        testMS();    }    public void testMS4() throws Throwable {        testMS();    }    public void testMS5() throws Throwable {        testMS();    }    public void testTM() throws Throwable {        verifyResults(NO_SIGMA, MAX_MINIMUM, randomTopScore(), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            int topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(NO_SIGMA, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTM1() throws Throwable {        testTM();    }    public void testTM2() throws Throwable {        testTM();    }    public void testTM3() throws Throwable {        testTM();    }    public void testTM4() throws Throwable {        testTM();    }    public void testTM5() throws Throwable {        testTM();    }    public void testMT() throws Throwable {        verifyResults(NO_SIGMA, randomMinimum(), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            double minimum = randomMinimum();            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(NO_SIGMA, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testMT1() throws Throwable {        testMT();    }    public void testMT2() throws Throwable {        testMT();    }    public void testMT3() throws Throwable {        testMT();    }    public void testMT4() throws Throwable {        testMT();    }    public void testMT5() throws Throwable {        testMT();    }    public void testSTM() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, MAX_MINIMUM, randomTopScore(expectedSigma(sigma)), 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            int topScore = randomTopScore(expectedSigma(sigma));            double minimum = randomMinimum(expectedTopScore(topScore));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testSTM1() throws Throwable {        testSTM();    }    public void testSTM2() throws Throwable {        testSTM();    }    public void testSTM3() throws Throwable {        testSTM();    }    public void testSTM4() throws Throwable {        testSTM();    }    public void testSTM5() throws Throwable {        testSTM();    }    public void testSMT() throws Throwable {        double sigma = randomSigma();        verifyResults(sigma, randomMinimum(expectedSigma(sigma)), MIN_TOPSCORE, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            sigma = randomSigma();            double minimum = randomMinimum(expectedSigma(sigma));            int topScore = randomTopScore(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedTopScore(topScore), 0);        }    }    public void testSMT1() throws Throwable {        testSMT();    }    public void testSMT2() throws Throwable {        testSMT();    }    public void testSMT3() throws Throwable {        testSMT();    }    public void testSMT4() throws Throwable {        testSMT();    }    public void testSMT5() throws Throwable {        testSMT();    }    public void testTSM() throws Throwable {        int topScore = randomTopScore();        verifyResults(randomSigma(expectedTopScore(topScore)), MAX_MINIMUM, topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double sigma = randomSigma(expectedTopScore(topScore));            double minimum = randomMinimum(expectedSigma(sigma));            verifyResults(sigma, minimum, topScore, expectedMinimum(minimum), 0);        }    }    public void testTSM1() throws Throwable {        testTSM();    }    public void testTSM2() throws Throwable {        testTSM();    }    public void testTSM3() throws Throwable {        testTSM();    }    public void testTSM4() throws Throwable {        testTSM();    }    public void testTSM5() throws Throwable {        testTSM();    }    public void testTMS() throws Throwable {        int topScore = randomTopScore();        verifyResults(MAX_SIGMA, randomMinimum(expectedTopScore(topScore)), topScore, 0, 0);        for (int i = 0; i < NUM_TESTS; i++) {            topScore = randomTopScore();            double minimum = randomMinimum(expectedTopScore(topScore));            double sigma = randomSigma(expectedMinimum(minimum));            verifyResults(sigma, minimum, topScore, expectedSigma(sigma), 2);        }    }    public void testTMS1() throws Throwable {        testTMS();    }    public void testTMS2() throws Throwable {        testTMS();    }    public void testTMS3() throws Throwable {        testTMS();    }    public void testTMS4() throws Throwable {        testTMS();    }    public void testTMS5() throws Throwable {        testTMS();    }    /**     * Verifies what happens when you pass these parameters     * into the thing.  DELTA is the amount of error allowed.     * Usually DELTA is only used for Sigma, as we really can't     * calculate it exactly.     */    public void verifyResults(double sigma, double minimum, int topScore, int expected, int delta) {        try {            setUp();            if (sigma >= 0) {                IUT.addProperty("sigma", Double.toString(sigma));            }            if (minimum >= 0) {                IUT.addProperty("minimum", Double.toString(minimum));            }            if (topScore >= 0) {                IUT.addProperty("topscore", Integer.toString(topScore));            }            Report report = makeReport(IUT);            if (delta == 0) {                assertEquals("Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore), expected, report.size());            } else {                String assertStr = "Unexpected number of results: sigma= " + Double.toString(sigma) + " min= " + Double.toString(minimum) + " topscore= " + Integer.toString(topScore) + " expected= " + Integer.toString(expected) + " +/- " + Integer.toString(delta) + " actual-result= " + report.size();                assertTrue(assertStr, report.size() >= (expected - delta));                assertTrue(assertStr, report.size() <= (expected + delta));            }        } catch (AssertionFailedError afe) {            System.err.println("******** " + testName + " ***********");            if (sigma != NO_SIGMA) {                System.err.println("SIGMA: " + Double.toString(sigma) + " EXPECT: " + Integer.toString(expectedSigma(sigma)));            }            if (minimum != NO_MINIMUM) {                System.err.println("MIN: " + Double.toString(minimum) + " EXPECT: " + Integer.toString(expectedMinimum(minimum)));            }            if (topScore != NO_TOPSCORE) {                System.err.println("TOP: " + Integer.toString(topScore) + " EXPECT: " + Integer.toString(expectedTopScore(topScore)));            }            throw afe;        }    }    public Report makeReport(Rule IUT) {        List list = new ArrayList();        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFilename(testName);        IUT.apply(list, ctx);        return report;    }}
/** * <copyright> *  Copyright 1997-2002 BBNT Solutions, LLC *  under sponsorship of the Defense Advanced Research Projects Agency (DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as published by *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> * * Created on Aug 26, 2002 */package test.net.sourceforge.pmd.stat;import junit.framework.TestCase;import net.sourceforge.pmd.stat.Metric;import java.util.Random;/** * @author David Dixon-Peugh */public class MetricTest extends TestCase {    private String testName = null;    private Random random = new Random();    /**     * Constructor for MetricTest.     * @param arg0     */    public MetricTest(String arg0) {        super(arg0);        this.testName = arg0;    }    public void testGetMetricName() {        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(testName, IUT.getMetricName());    }    public void testGetCount() {        int count = random.nextInt();        Metric IUT = new Metric(testName, count, 0.0, 0.0, 0.0, 0.0, 0.0);        assertEquals(count, IUT.getCount());    }    public void testGetTotal() {        double total = random.nextDouble();        Metric IUT = new Metric(testName, 0, total, 0.0, 0.0, 0.0, 0.0);        assertEquals(total, IUT.getTotal(), 0.05);    }    public void testGetLowValue() {        double low = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, low, 0.0, 0.0, 0.0);        assertEquals(low, IUT.getLowValue(), 0.05);    }    public void testGetHighValue() {        double high = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, high, 0.0, 0.0);        assertEquals(high, IUT.getHighValue(), 0.05);    }    public void testGetAverage() {        double mean = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, mean, 0.0);        assertEquals(mean, IUT.getAverage(), 0.05);    }    public void testGetStandardDeviation() {        double stdev = random.nextDouble();        Metric IUT = new Metric(testName, 0, 0.0, 0.0, 0.0, 0.0, stdev);        assertEquals(stdev, IUT.getStandardDeviation(), 0.05);    }}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidCallingFinalizeTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("finalizers", "AvoidCallingFinalize");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "simple failure case", 1, rule),               new TestDescriptor(TEST2, "calling finalize on an object", 1, rule),               new TestDescriptor(TEST3, "calling super.finalize", 1, rule),               new TestDescriptor(TEST4, "no call to finalize", 0, rule),               new TestDescriptor(TEST5, "it's ok in a finalizer", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo () {" +    "  finalize();" +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo () {" +    "  Foo f;" +    "  f.finalize();" +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo () {" +    "  super.finalize();" +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void finalize () {" +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void finalize () {" +    "  super.finalize(); " + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeDoesNotCallSuperFinalizeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("finalizers", "FinalizeDoesNotCallSuperFinalize");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "ok, super.finalize called in try..finally", 0, rule),           new TestDescriptor(TEST4, "ok, super.finalize called in try..catch..finally", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  try {} finally {" + PMD.EOL +    "   super.finalize();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  try {} catch(Exception e) {} finally {" + PMD.EOL +    "   super.finalize();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeOnlyCallsSuperFinalizeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("finalizers", "FinalizeOnlyCallsSuperFinalize");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  super.finalize();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.finalize;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeOverloadedRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("finalizers", "FinalizeOverloaded");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize(int foo) {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize() {" + PMD.EOL +    "  doSomething();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.javabeans;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MissingSerialVersionUIDTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("javabeans", "MissingSerialVersionUID");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "Happy case", 0, rule),               new TestDescriptor(TEST2, "Simple failure case", 1, rule),               new TestDescriptor(TEST3, "failure using java.io.Serializable", 1, rule),               new TestDescriptor(TEST4, "implements Serializable and provides a serialVersionUID", 0, rule),               new TestDescriptor(TEST5, "TEST5", 0, rule),               new TestDescriptor(TEST6, "interface", 0, rule)       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo implements Serializable {" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo implements java.io.Serializable {" + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo implements Serializable {" + PMD.EOL +        "public static final long serialVersionUID = 43L;" + PMD.EOL +        "}";    private static final String TEST5 =        "public class Foo implements java.io.Serializable {" + PMD.EOL +        "public static final long serialVersionUID = 43L;" + PMD.EOL +        "}";    private static final String TEST6 =    "public interface Foo implements Bar{" + PMD.EOL +    " void getName();" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.javabeans;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class BeanMembersShouldSerializeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("javabeans", "BeanMembersShouldSerialize");        rule.setMessage("Don't {0} !");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "private String, no accessor", 1, rule),           new TestDescriptor(TEST2, "private static String", 0, rule),           new TestDescriptor(TEST3, "private transient String", 0, rule),           new TestDescriptor(TEST4, "getter, no setter", 1, rule),           new TestDescriptor(TEST5, "setter, no getter", 1, rule),           new TestDescriptor(TEST6, "both accessors, yay!", 0, rule),           new TestDescriptor(TEST7, "setFoo and isFoo is OK for booleans", 0, rule),           new TestDescriptor(TEST8, "setFoo and isFoo is not OK for Strings", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private static String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private transient String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    " public String getFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    " public void setFoo(Foo foo) {this.foo = foo;}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = Foo.foo;" + PMD.EOL +    " public void setFoo(Foo foo) {this.foo = foo;}" + PMD.EOL +    " public String getFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " private boolean foo;" + PMD.EOL +    " public void setFoo(boolean foo) {this.foo = foo;}" + PMD.EOL +    " public boolean isFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " public void setFoo(String foo) {this.foo = foo;}" + PMD.EOL +    " public String isFoo() {return foo;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseAssertSameInsteadOfAssertTrueTest extends SimpleAggregatorTst {    private Rule rule;        public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "UseAssertSameInsteadOfAssertTrue");    }    public void testAll() throws Throwable {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "TEST1", 1, rule),           new TestDescriptor(TEST2, "TEST2", 1, rule),           new TestDescriptor(TEST3, "TEST3", 1, rule),           new TestDescriptor(TEST4, "TEST4", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(a==b);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  assertTrue(a!=b);" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  assertFalse(a==b);" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  assertFalse(a!=b);" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseAssertEqualsInsteadOfAssertTrueTest extends SimpleAggregatorTst {    private Rule rule;        public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "UseAssertEqualsInsteadOfAssertTrue");    }    public void testAll() throws Throwable {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "TEST1", 0, rule),           new TestDescriptor(TEST2, "TEST2", 1, rule),           new TestDescriptor(TEST3, "TEST3", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(a==b);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  assertTrue(a.equals(b));" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  assertTrue(a.mySpecialequals(b));" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitAssertionsShouldIncludeMessageTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "JUnitAssertionsShouldIncludeMessage");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "assertEquals ok", 0, rule),           new TestDescriptor(TEST2, "assertEquals bad", 1, rule),           new TestDescriptor(TEST3, "assertTrue ok", 0, rule),           new TestDescriptor(TEST4, "assertTrue bad", 1, rule),           new TestDescriptor(TEST5, "assertNull OK", 0, rule),           new TestDescriptor(TEST6, "assertNull bad", 1, rule),           new TestDescriptor(TEST7, "assertSame OK", 0, rule),           new TestDescriptor(TEST8, "assertSame badd", 1, rule),           new TestDescriptor(TEST9, "assertNotNull OK", 0, rule),           new TestDescriptor(TEST10, "assertNotNull bad", 1, rule),           new TestDescriptor(TEST11, "find that pesky bug", 0, rule),           new TestDescriptor(TEST12, "assertFalse ok", 0, rule),           new TestDescriptor(TEST13, "assertFalse bad", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertEquals(\"1 == 1\", 1, 1);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertEquals(1, 1);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(\"foo\", \"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(\"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNull(\"it's not null\", null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNull(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertSame(\"not same!\", null, null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertSame(null, null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNotNull(\"foo\", null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertNotNull(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  this.test1(\"foo\");" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " public void testBar() {" + PMD.EOL +    "  assertFalse(\"foo!\", \"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " public void testBar() {" + PMD.EOL +    "  assertFalse(\"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitTestsShouldContainAssertsTest extends SimpleAggregatorTst {    private Rule rule;        public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "JUnitTestsShouldIncludeAssert");    }    public void testAll() throws Throwable {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "Contains assert", 0, rule),           new TestDescriptor(TEST2, "Missing assert", 1, rule),           new TestDescriptor(TEST3, "All ok", 0, rule),           new TestDescriptor(TEST4, "Two wrong", 2, rule),           new TestDescriptor(TEST5, "Contains fail", 0, rule),           new TestDescriptor(TEST6, "One wrong", 1, rule),           new TestDescriptor(TEST7, "Skip interfaces", 0, rule),           new TestDescriptor(TEST8, "Skip abstract methods", 0, rule),           new TestDescriptor(TEST9, "Another fail() case", 0, rule),           new TestDescriptor(TEST10, "BUG 1105633 - False +: JUnit testcases could have fail() instead of assert", 0, rule),   new TestDescriptor(BUG_1146116, "BUG 1146116 PMDException with inner interfaces", 0, rule),   new TestDescriptor(TEST12, "skip static test methods", 0, rule),   new TestDescriptor(TEST13, "exceptions shouldn't block it", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertEquals(\"1 == 1\", 1, 1);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void setUp() {" + PMD.EOL +    " }" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  assertTrue(\"foo\", \"foo\".equals(\"foo\"));" + PMD.EOL +    " }" + PMD.EOL +    " public void test2() {" + PMD.EOL +    "  assertEquals(\"foo\", \"foo\");" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " public void setUp() {" + PMD.EOL +        " }" + PMD.EOL +        " public void test1() {" + PMD.EOL +        " int a;" + PMD.EOL +        " callMethod(a);" + PMD.EOL +        " }" + PMD.EOL +        " public void test2() {" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  fail(\"1 == 1\");" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " public void setUp() {" + PMD.EOL +        " }" + PMD.EOL +        " public void test1() {" + PMD.EOL +        " int a;" + PMD.EOL +        " callMethod(a);" + PMD.EOL +        " }" + PMD.EOL +        " public void test2() {" + PMD.EOL +        " fail();" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST7 =        "public interface Foo {" + PMD.EOL +        " public void setUp() throws Exception;" + PMD.EOL +        "}";    private static final String TEST8 =        "public class Foo {" + PMD.EOL +        " public abstract void setUp() throws Exception;" + PMD.EOL +        "}";    private static final String TEST9 =        "public abstract class AbstractAggregateCreator {" + PMD.EOL +             "    public abstract int getType();" + PMD.EOL +             "    public abstract ProfileAggregate create(DatabaseTransaction db," + PMD.EOL +             "        DailyProfileList profiles, ProfileType type, ProfileStatus status)" + PMD.EOL +             "        throws VixenException;" + PMD.EOL +             "}";        private static final String TEST10 =        "public class FooTest {" +  PMD.EOL +        " public void testNPEThrown() {" +  PMD.EOL +        "  try {" + PMD.EOL +         "   methodCall(null);" + PMD.EOL +         "   fail(\"Expected NullPointerException to be thrown.\");" + PMD.EOL +         "  } catch (NullPointerException npe) {" + PMD.EOL +         "   // Caught expected exception" + PMD.EOL +         "  }" +  PMD.EOL +        " }" +  PMD.EOL +        "}";        private static final String BUG_1146116 = "package at.herold.anthilltest;" + PMD.EOL +  "public class TestJunitRuleException {" +  PMD.EOL + "   interface I1 { " +  PMD.EOL + "      public void meth(); // this is ok" + PMD.EOL +  "   }" + PMD.EOL +  "   interface I2 {" +  PMD.EOL + "      public void meth() throws Exception; // this causes PMDException" + PMD.EOL +  "   }" + PMD.EOL +  "}";    private static final String TEST12 ="public class Foo {" +  PMD.EOL +" public static void testfoo() {}" + PMD.EOL +"}";    private static final String TEST13 ="public class Foo {" +  PMD.EOL +" public void testfoo() throws Exception {}" + PMD.EOL +"}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitStaticSuiteRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "JUnitStaticSuite");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "nonstatic is bad", 1, rule),           new TestDescriptor(TEST2, "public static with no params is OK", 0, rule),           new TestDescriptor(TEST3, "private suite() is bad", 1, rule),           new TestDescriptor(TEST4, "if there are params, just skip it", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public TestSuite suite() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public static TestSuite suite() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private static TestSuite suite() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " protected static Test suite(Foo foo) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JUnitSpellingRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "JUnitSpelling");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "testSetupMisspellings1", 2, rule),           new TestDescriptor(TEST2, "testTeardownMisspellings", 2, rule),           new TestDescriptor(TEST3, "testMethodsSpelledOK", 0, rule),           new TestDescriptor(TEST4, "testUnrelatedMethods", 0, rule),           new TestDescriptor(TEST5, "testMethodWithParams", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void setup() {}" + PMD.EOL +    " public void SetUp() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void TearDown() {}" + PMD.EOL +    " public void teardown() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void setUp() {}" + PMD.EOL +    " public void tearDown() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void utility() {}" + PMD.EOL +    " public void foobr() {}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public void setup(String x) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryBooleanAssertionTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("junit", "UnnecessaryBooleanAssertion");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "failure case", 1, rule),               new TestDescriptor(TEST2, "variations", 4, rule),               new TestDescriptor(TEST3, "nested boolean literal", 0, rule),               new TestDescriptor(TEST4, "asserting true a !", 1, rule),               new TestDescriptor(TEST5, "asserting false a !", 1, rule),               new TestDescriptor(TEST6, "buz", 0, rule),       });    }    private static final String TEST1 =    "public class Foo extends TestCase {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assertTrue(true); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo extends TestCase {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assertTrue(true); " + PMD.EOL +    "  assertTrue(false); " + PMD.EOL +    "  assertFalse(true); " + PMD.EOL +    "  assertFalse(false); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo extends TestCase {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assertTrue(foobar(fiddle, true)); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo extends TestCase {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assertTrue(!foo); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo extends TestCase {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assertFalse(!foo); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo extends TestCase {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assertTrue(!s.contains(new NameOccurrence(node, node.getImage()))); " + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LongParameterListRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("codesize", "ExcessiveParameterList");        rule.addProperty("minimum", "9");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "short", 0, rule),           new TestDescriptor(TEST2, "long", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    public void foo(int p01, int p02, int p03, int p04, int p05, int p06, int p07, int p08, int p09, int p10 ) { }" + PMD.EOL +    "    public void bar(int p01, int p02, int p03, int p04, int p05 ) { }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.design.SwitchDensityRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SwitchDensityTest  extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new SwitchDensityRule();        rule.addProperty("minimum", "4");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "Five stmts in one switch case, should be flagged", 1, rule),           new TestDescriptor(TEST2, "One stmt in one switch case, ok", 0, rule),           new TestDescriptor(TEST3, "Five stmts, 5 cases, OK", 0, rule),       });    }    private static final String TEST1 =    "// Switch Density = 5.0" + PMD.EOL +    "public class SwitchDensity1 {" + PMD.EOL +    " public void foo(int i) {" + PMD.EOL +    "  switch (i) {" + PMD.EOL +    "  case 0:" + PMD.EOL +    "  {" + PMD.EOL + pad(5) +    "  }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "// Switch Density = 1.0" + PMD.EOL +    "public class SwitchDensity2 {" + PMD.EOL +    "       public void foo(int i) {" + PMD.EOL +    "               switch (i) {" + PMD.EOL +    "                       case 0:" + PMD.EOL +    "                       {" + PMD.EOL + pad(1) +    "                       }" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST3 =    "// Switch Density = 1.0" + PMD.EOL +    "public class SwitchDensity3 {" + PMD.EOL +    "       public void foo(int i) {" + PMD.EOL +    "               switch (i) {" + PMD.EOL +    "                       case 0:" + PMD.EOL +    "                       case 1:" + PMD.EOL +    "                       case 2:" + PMD.EOL +    "                       case 3:" + PMD.EOL +    "                       case 4:" + PMD.EOL +    "                       {" + PMD.EOL + pad(5) +    "                       }" + PMD.EOL +    "               } " + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static String pad(int times) {        String x = "";        for (int i = 0; i < times; i++) {            x += "System.err.println(\"I am a fish.\");" + PMD.EOL;        }        return x;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExcessiveMethodLengthTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("codesize", "ExcessiveMethodLength");        rule.addProperty("minimum", "10");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "short", 0, rule),           new TestDescriptor(TEST2, "long", 1, rule),           new TestDescriptor(TEST3, "not quite long", 0, rule),           new TestDescriptor(TEST4, "long", 1, rule),       });    }    public void testReallyLongMethodWithLongerRange() throws Throwable {        Rule r = findRule("codesize", "ExcessiveMethodLength");        r.addProperty("minimum", "20");        runTestFromString(TEST2, 0, r);    }/*    public void testOverrideMinimumWithTopScore() throws Throwable {        Rule r = findRule("codesize", "ExcessiveMethodLength");        r.addProperty("minimum", "1");        r.addProperty("topscore", "2");        Report rpt = new Report();        runTestFromString(TEST5, r, rpt);        for (Iterator i = rpt.iterator(); i.hasNext();) {            RuleViolation rv = (RuleViolation)i.next();            assertTrue(rv.getLine() == 2 || rv.getLine() == 6);        }    }*/    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "  bar();" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "    } // 11 lines - violation" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "    } // 9 lines - Not a violation" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "    } // > 10 lines - Not a violation" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "    void foo1() {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  baz();" + PMD.EOL +    "    }" + PMD.EOL +    "    void foo2() {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  baz();" + PMD.EOL +    "    }" + PMD.EOL +    "    void foo3() {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  baz();" + PMD.EOL +    "    }" + PMD.EOL +    "    void foo4() {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  baz();" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AssignmentToNonFinalStaticTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "AssignmentToNonFinalStatic");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "clear rule violation", 1, rule),               new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " static int x;" + PMD.EOL +    "     Foo(int y) {" +    "     x = y; " + PMD.EOL +    "     }" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " static final int x;" + PMD.EOL +        "     Foo(int y) {" +        "     x = y; " + PMD.EOL +        "     }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ConfusingTernaryRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "ConfusingTernary");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "!=, bad", 1, rule),           new TestDescriptor(TEST2, "==, good", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x = a != b ? c : d;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x = a == b ? c : d;" + PMD.EOL +    " }" + PMD.EOL +    "}";    /*public class BadTernaries {  public static void main(String[] args) {    int i = 0;    int j = 1;    int k = 2;    boolean x = true;    boolean y = false;    boolean z = true;    // flag all of these, lines 11 - 42:    if (i != 11) {a();} else {b();}    if (i != 12 && j != 0) {a();} else {b();}    if (i != 13 || j != 0) {a();} else {b();}    if (i != 14 && j != 0 && k != 0) {a();} else {b();}    if (i != 15 || j != 0 || k != 0) {a();} else {b();}    if (i != 16) {a();} else if (i != j) {b();} else{c();}    if (i != 17) {a();} else if (i == j) {b();} else{c();}    if (i == 18) {a();} else if (i != j) {b();} else{c();}    x = (!y ? x : y);    x = (!(x && y) ? y : z);    x = (!(x || y) ? y : z);    x = ((!x && !y) ? y : z);    x = ((!x || !y) ? y : z);    if (i != 24 && !x) {a();} else {b();}    if (i != 25 || !x) {a();} else {b();}    if (i != 26 && j != 0 && !y) {a();} else {b();}    if (i != 27 || j != 0 || !y) {a();} else {b();}    if (i != 28) {a();} else if (!x) {b();} else{c();}    if (i != 29) {a();} else if (x) {b();} else{c();}    if (i == 30) {a();} else if (!x) {b();} else{c();}    x = !(c() == y) ? y : !z;    if (!c()) {a();} else {b();}    if (c() != x) {a();} else {b();}    if (!c() != x) {a();} else {b();}    if (!c() != !x) {a();} else {b();}    if ((i != 36) || !(j == 0)) {a();} else {b();}    if ((i != 37) || !(x ? y : z)) {a();} else {b();}    if ((i != 38)) {a();} else {b();}    if (i != 39 || (j != 0 || k != 0)) {a();} else {b();}    if (i != 40 && (j != 0 && k != 0)) {a();} else {b();}    if (!x && (j != 41 && k != 0)) {a();} else {b();}    if (((x != y)) || !(x)) { a(); } else { b(); }    // don't flag these:    if (i != 0) {a();}    if (!x) {a();}    if (i == 0) {a();} else {b();}    if (i == 0 && j != 0) {a();} else {b();}    if (i == 0 || j != 0) {a();} else {b();}    if (i == 0 && !x) {a();} else {b();}    if (x) {a();} else {b();}    if (x ? y : !z) {a();} else {b();}    if (c() == !x) {a();} else {b();}    if (c() ? !x : !c()) {a();} else {b();}    if (!x && d() instanceof String) {a();} else {b();}    if (!x && (d() instanceof String)) {a();} else {b();}  }  private static void a() { }  private static void b() { }  private static boolean c() { return true; }  private static Object d() { return null; }}    */}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NullAssignmentRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "NullAssignment");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "initial assignment", 0, rule),           new TestDescriptor(TEST2, "bad assignment", 1, rule),           new TestDescriptor(TEST3, "check test", 0, rule),           new TestDescriptor(TEST4, "null param on right hand sidel", 0, rule),           new TestDescriptor(TEST5, "null assignment in ternary", 1, rule),           new TestDescriptor(TEST6, "null assignment in ternary, part deux", 1, rule),           new TestDescriptor(TEST7, "comparison is not assignment", 0, rule),           new TestDescriptor(TEST8, "final fields must be assigned", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Object foo() {" + PMD.EOL +    "  Object x = null; // OK" + PMD.EOL +    "  return x;" + PMD.EOL +    " }       " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  Object x;" + PMD.EOL +    "  x = new Object();" + PMD.EOL +    "  bar(x);  " + PMD.EOL +    "  x = null; // This is bad" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  Object x;" + PMD.EOL +    "  if (x == null) { // This is OK" + PMD.EOL +    "   return;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  String x = null;" + PMD.EOL +    "  x = new String(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  String x = bar() ? \"fiz\" : null;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  String x = bar() ? null : \"fiz\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public String foo() {" + PMD.EOL +    "  return x == null ? \"42\" : x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private final String x;" + PMD.EOL +    " public Foo(String y) {" + PMD.EOL +    "  if (y == \"\") x = null;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.design.PositionalIteratorRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class PositionalIteratorRuleTest extends RuleTst {    private static final String TEST1 =    "public class PositionalIterator1 {" + PMD.EOL +    " public void foo(Iterator i) {" + PMD.EOL +    "  while(i.hasNext()) {" + PMD.EOL +    "   Object one = i.next();" + PMD.EOL +    "   " + PMD.EOL +    "   // 2 calls to next() inside the loop == bad!" + PMD.EOL +    "   Object two = i.next(); " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class PositionalIterator2 {" + PMD.EOL +    " public void foo(Iterator i) {" + PMD.EOL +    "  while(i.hasNext()) {" + PMD.EOL +    "   Object one = i.next();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class PositionalIterator3 {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  Iterator i = (new List()).iterator();" + PMD.EOL +    "  while(i.hasNext()) {" + PMD.EOL +    "   Object one = i.next();" + PMD.EOL +    "   Iterator j = (new List()).iterator();" + PMD.EOL +    "   while (j.hasNext()) {" + PMD.EOL +    "    j.next();" + PMD.EOL +    "   }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    public void test1() throws Throwable {        runTestFromString(TEST1, 1, new PositionalIteratorRule());    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, new PositionalIteratorRule());    }    public void test3() throws Throwable {        runTestFromString(TEST3, 0, new PositionalIteratorRule());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.rules.design.LongClassRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LongClassRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("codesize", "ExcessiveClassLength");        rule.addProperty("minimum", "10");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST0, "short", 0, rule),           new TestDescriptor(TEST1, "long", 1, rule),       });    }    public void testLongClassWithLongerTest() throws Throwable {        LongClassRule IUT = new LongClassRule();        IUT.addProperty("minimum", "2000");        runTestFromString(TEST1, 0, IUT);    }    private static final String TEST0 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "  int x;" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public void bar() {" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "  bar();" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ImmutableFieldTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "ImmutableField");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "could be immutable, only assigned in constructor", 1, rule),           new TestDescriptor(TEST2, "could be immutable, only assigned in decl", 1, rule),           new TestDescriptor(TEST3, "ok, assigned twice", 0, rule),           new TestDescriptor(TEST4, "ok, static field ", 0, rule), // TODO - probably should check these, not just discard them           new TestDescriptor(TEST5, "ok, one constructor assigns, one doesn't", 0, rule),           new TestDescriptor(TEST6, "ok, assignment via postfix expression", 0, rule),           new TestDescriptor(TEST7, "postfix expressions imply mutability", 0, rule),           new TestDescriptor(TEST8, "compound assignment", 0, rule),           new TestDescriptor(TEST9, "preincrement", 0, rule),           new TestDescriptor(TEST10, "predecrement", 0, rule),           new TestDescriptor(TEST11, "compound assignment 2", 0, rule),           new TestDescriptor(TEST12, "rhs 2", 0, rule),           new TestDescriptor(TEST13, "assignment in constructor is in try block", 0, rule),           new TestDescriptor(TEST14, "assignment in method is in try block", 0, rule),           new TestDescriptor(TEST15, "assignment in constructor in loop is ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private int x = 42;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  x = 41;" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  x = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private static int x = 0;" + PMD.EOL +    " private final int y;" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  y = x;" + PMD.EOL +    "  x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public Foo(int y) {" + PMD.EOL +    "  x = y;" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    " private void bar() {x++;}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " private int x = 0;" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "  x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private int w;" + PMD.EOL +    " private int z;" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "  w = 2;" + PMD.EOL +    "  z = 4;" + PMD.EOL +    " }" + PMD.EOL +    " private void gaz() {" + PMD.EOL +    "  w += z++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " private int x = 0;" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  ++x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " private int x = 0;" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  --x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " private int x = 0;" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  x += 1;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " private int x = 0;" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  Object y = new Bar(x++);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   x = 2;" + PMD.EOL +    "  } catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST14 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   x = 2;" + PMD.EOL +    "  } catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST15 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  for (int i=0; i<10; i++) { x += 5; }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class OnlyOneReturnRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "OnlyOneReturn");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "two returns", 1, rule),           new TestDescriptor(TEST2, "one", 0, rule),           new TestDescriptor(TEST3, "none", 0, rule),           new TestDescriptor(TEST4, "void", 0, rule),           new TestDescriptor(TEST5, "finally", 0, rule),           new TestDescriptor(TEST6, "return inside anonymous inner class", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public int foo(int x) {    " + PMD.EOL +    "  if (x > 0) {" + PMD.EOL +    "   return 3;" + PMD.EOL +    "  }" + PMD.EOL +    "  return 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public int foo(int x) {    " + PMD.EOL +    "  return 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void foo(int x) {      " + PMD.EOL +    "  int y =2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void foo(int x) {      " + PMD.EOL +    "  if (x>2) {" + PMD.EOL +    "    return;" + PMD.EOL +    "  }" + PMD.EOL +    "  int y =2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public int foo(int x) {" + PMD.EOL +    "  try {" + PMD.EOL +    "   x += 2;" + PMD.EOL +    "   return x;" + PMD.EOL +    "  } finally {" + PMD.EOL +    "    int y;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public int foo() {" + PMD.EOL +    "  FileFilter f = new FileFilter() {" + PMD.EOL +    "   public boolean accept(File file) {" + PMD.EOL +    "    return false;" + PMD.EOL +    "   }" + PMD.EOL +    "  };" + PMD.EOL +    "  return 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.design.LooseCoupling;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LooseCouplingTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new LooseCoupling();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "returning a HashSet, bad", 1, rule),           new TestDescriptor(TEST2, "returning a Map, OK", 0, rule),           new TestDescriptor(TEST3, "no problemo", 0, rule),           new TestDescriptor(TEST4, "returning a set", 0, rule),           new TestDescriptor(TEST5, "field declared of type HashSet", 1, rule),           new TestDescriptor(TEST6, "field, return type both HashSet", 2, rule),           new TestDescriptor(TEST7, "two fields", 2, rule),           new TestDescriptor(TEST8, "method param is HashMap", 1, rule),           new TestDescriptor(TEST9, "Vector could be List", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " HashSet foo() {" + PMD.EOL +    "  return new HashSet();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Map getFoo() {" + PMD.EOL +    "  return new HashMap();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " Set fooSet = new HashSet(); // OK" + PMD.EOL +    " Set foo() {" + PMD.EOL +    "  return fooSet;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " HashSet fooSet = new HashSet(); // NOT OK" + PMD.EOL +    " HashSet foo() { // NOT OK" + PMD.EOL +    "  return fooSet;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " HashSet fooSet = new HashSet();" + PMD.EOL +    " HashMap fooMap = new HashMap();" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " void foo(HashMap bar) {}" + PMD.EOL +    "}";    private static final String TEST9 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo(Vector bar) {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class PositionLiteralsFirstInComparisonsTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "PositionLiteralsFirstInComparisons");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, literal comes first", 0, rule),           new TestDescriptor(TEST2, "bad, literal comes last", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " boolean bar(String x) {" + PMD.EOL +    "  return \"2\".equals(x);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " boolean bar(String x) {" + PMD.EOL +    "  return x.equals(\"2\");" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.rules.design.UseSingleton;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseSingletonTest extends SimpleAggregatorTst implements ReportListener {    private int callbacks;    private Rule rule;    public void setUp() {        rule = findRule("design", "UseSingleton");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "should be singleton since all static, public constructor", 1, rule),           new TestDescriptor(TEST2, "ok, uses non-static", 0, rule),           new TestDescriptor(TEST3, "should be singleton, couple of statics, no constructor", 1, rule),           new TestDescriptor(TEST4, "no constructor, one static - ok", 0, rule),           new TestDescriptor(TEST5, "classic singleton - ok", 0, rule),           new TestDescriptor(TEST6, "abstract, so ok", 0, rule),           new TestDescriptor(TEST7, "has no fields, so ok", 0, rule),           new TestDescriptor(TEST8, "has public static field, so need to check", 1, rule),           new TestDescriptor(TEST9, "junit 'suite' method is OK", 0, rule),       });    }    public void testResetState() throws Throwable {        callbacks = 0;        Rule rule = new UseSingleton();        Report report = new Report();        report.addListener(this);        runTestFromString(TEST3, rule, report);        runTestFromString(TEST4, rule, report);        assertEquals(1, callbacks);    }    public void ruleViolationAdded(RuleViolation ruleViolation) {        callbacks++;    }    public void metricAdded(Metric metric) {}    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() { }" + PMD.EOL +    " public static void doSomething() {}" + PMD.EOL +    " public static void main(String args[]) {" + PMD.EOL +    "  doSomething();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    public Foo() { }" + PMD.EOL +    "    public void doSomething() { }" + PMD.EOL +    "    public static void main(String args[]) { }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "    public static void doSomething1() { }" + PMD.EOL +    "    public static void doSomething2() { }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "    public Foo() { }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private Foo() {}" + PMD.EOL +    " public static Foo get() {" + PMD.EOL +    "  return null;" + PMD.EOL +    " }     " + PMD.EOL +    "}";    private static final String TEST6 =    "public abstract class Foo {" + PMD.EOL +    "    public static void doSomething1() { }" + PMD.EOL +    "    public static void doSomething2() { }" + PMD.EOL +    "    public static void doSomething3() { }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public Foo() { }" + PMD.EOL +    " private int x;" + PMD.EOL +    " public static void doSomething() {}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public static final int x = 5;" + PMD.EOL +    " public static void doSomething() {}" + PMD.EOL +    "}";    private static final String TEST9 =    "public class FooTest {" + PMD.EOL +    " public static Test suite() {" + PMD.EOL +    "  return new TestSuite();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CompareObjectsWithEqualsTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "CompareObjectsWithEquals");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure with method params", 1, rule),           new TestDescriptor(TEST2, "primitives are ok", 0, rule),           new TestDescriptor(TEST3, "skip nulls", 0, rule),           new TestDescriptor(TEST4, "missed hit - qualified names.  that's ok, we can't resolve the types yet, so better to skip this for now", 0, rule),           new TestDescriptor(TEST5, "more qualified name skippage", 0, rule),           new TestDescriptor(TEST6, "locals", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " boolean bar(String a, String b) {" + PMD.EOL +    "  return a == b;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " boolean bar(int a, int b) {" + PMD.EOL +    "  return a == b;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " boolean bar(int a, int b) {" + PMD.EOL +    "  return a == null || null == b;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " boolean bar(Foo b) {" + PMD.EOL +    "  return this.b == b.foo;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " boolean bar(String a, String b) {" + PMD.EOL +    "  return a.charAt(0) == b.charAt(0);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " boolean bar() {" + PMD.EOL +    "  String a = \"foo\";" + PMD.EOL +    "  String b = \"bar\";" + PMD.EOL +    "  return a == b;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidInstanceofChecksInCatchClauseTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "AvoidInstanceofChecksInCatchClause");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "bad, instanceof FooException", 1, rule),               new TestDescriptor(TEST2, "ok, no instanceof", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" +    "  try {" + PMD.EOL +    "   foo();" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   if (e instanceof FooException) {}" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" +    "  try {" + PMD.EOL +    "   foo();" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidProtectedFieldInFinalClassRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "AvoidProtectedFieldInFinalClass");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, protected field in non final class", 0, rule),           new TestDescriptor(TEST2, "bad, protected field in final class", 1, rule),           new TestDescriptor(TEST3, "ok, private field in final class", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " protected int x;" + PMD.EOL +    "}";    private static final String TEST2 =    "public final class Foo {" + PMD.EOL +    " protected int x;" + PMD.EOL +    "}";    private static final String TEST3 =    "public final class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryLocalBeforeReturnRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("design", "UnnecessaryLocalBeforeReturn");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "skip void/native/abstract methods", 0, rule),           new TestDescriptor(TEST2, "skip literal returns", 0, rule),           new TestDescriptor(TEST3, "simple failure case", 1, rule),           new TestDescriptor(TEST4, "skip complicated returns", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    " public native int buz();" + PMD.EOL +    " public abstract int baz();" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public int bar() { return 5; }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public int bar() {" + PMD.EOL +    "  int x = doSomething();" + PMD.EOL +    "  return x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public int bar() {" + PMD.EOL +    "  int x = doSomething();" + PMD.EOL +    "  return x == null ? foo : bar;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CollapsibleIfStatementsTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "CollapsibleIfStatements");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "ok, intervening statements", 0, rule),           new TestDescriptor(TEST3, "ok, different intervening statements", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (x) {" + PMD.EOL +    "   if (y) {" + PMD.EOL +    "   }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (x) {" + PMD.EOL +    "   int z = 5;" + PMD.EOL +    "   if (y) {" + PMD.EOL +    "   }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (x) {" + PMD.EOL +    "   if (y) {" + PMD.EOL +    "   }" + PMD.EOL +    "   int z = 5;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class TooManyFieldsTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() {        rule = findRule("codesize", "TooManyFields");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "3 fields, max is 15", 0, rule),               new TestDescriptor(TEST2, "16 fields, bad", 1, rule),               new TestDescriptor(TEST3, "12 fields, but 6 in inner and 6 in outer", 0, rule),               new TestDescriptor(TEST4, "outer class, inner interface, both OK", 0, rule),               new TestDescriptor(TEST5, "interface with 10 fields", 0, rule),               new TestDescriptor(TEST6, "2 inner classes, each with > 10 fields", 2, rule),               new TestDescriptor(TEST7, "anonymous class with a field", 0, rule),       });    }        public void testPropertySetting() throws Throwable {        Report rpt = new Report();        rule.addProperty("maxfields", "2");        runTestFromString(TEST8, rule, rpt);        assertEquals(1, rpt.size());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " int a1; " + PMD.EOL +    " int a2; " + PMD.EOL +    " int a3; " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " int a1; " + PMD.EOL +    " int a2; " + PMD.EOL +    " int a3; " + PMD.EOL +    " int a4; " + PMD.EOL +    " int a5; " + PMD.EOL +    " int a6; " + PMD.EOL +    " int a7; " + PMD.EOL +    " int a8; " + PMD.EOL +    " int a9; " + PMD.EOL +    " int a10; " + PMD.EOL +    " int a11; " + PMD.EOL +    " int a12; " + PMD.EOL +    " int a13; " + PMD.EOL +    " int a14; " + PMD.EOL +    " int a15; " + PMD.EOL +    " int a16; " + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " int a1; " + PMD.EOL +    " int a2; " + PMD.EOL +    " int a3; " + PMD.EOL +    " int a4; " + PMD.EOL +    " int a5; " + PMD.EOL +    " int a6; " + PMD.EOL +    " public class Bar {" + PMD.EOL +    "  int a7; " + PMD.EOL +    "  int a8; " + PMD.EOL +    "  int a9; " + PMD.EOL +    "  int a10; " + PMD.EOL +    "  int a11; " + PMD.EOL +    "  int a12; " + PMD.EOL +    " }" +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " int a1; " + PMD.EOL +    " int a2; " + PMD.EOL +    " int a3; " + PMD.EOL +    " int a4; " + PMD.EOL +    " int a5; " + PMD.EOL +    " interface Bar {" + PMD.EOL +    "  int a6; " + PMD.EOL +    "  int a7; " + PMD.EOL +    "  int a8; " + PMD.EOL +    "  int a9; " + PMD.EOL +    "  int a10; " + PMD.EOL +    " }" +    "}";    private static final String TEST5 =    "public interface Foo {" + PMD.EOL +    " int a1; " + PMD.EOL +    " int a2; " + PMD.EOL +    " int a3; " + PMD.EOL +    " int a4; " + PMD.EOL +    " int a5; " + PMD.EOL +    " int a6; " + PMD.EOL +    " int a7; " + PMD.EOL +    " int a8; " + PMD.EOL +    " int a9; " + PMD.EOL +    " int a10; " + PMD.EOL +    "}";        private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public class Bar1 {" + PMD.EOL +    "  int b1; " + PMD.EOL +    "  int b2; " + PMD.EOL +    "  int b3; " + PMD.EOL +    "  int b4; " + PMD.EOL +    "  int b5; " + PMD.EOL +    "  int b6; " + PMD.EOL +    "  int b7; " + PMD.EOL +    "  int b8; " + PMD.EOL +    "  int b9; " + PMD.EOL +    "  int b10; " + PMD.EOL +    "  int b11; " + PMD.EOL +    "  int b12; " + PMD.EOL +    "  int b13; " + PMD.EOL +    "  int b14; " + PMD.EOL +    "  int b15; " + PMD.EOL +    "  int b16; " + PMD.EOL +    " }" + PMD.EOL +    " public class Bar2 {" + PMD.EOL +    "  int b1; " + PMD.EOL +    "  int b2; " + PMD.EOL +    "  int b3; " + PMD.EOL +    "  int b4; " + PMD.EOL +    "  int b5; " + PMD.EOL +    "  int b6; " + PMD.EOL +    "  int b7; " + PMD.EOL +    "  int b8; " + PMD.EOL +    "  int b9; " + PMD.EOL +    "  int b10; " + PMD.EOL +    "  int b11; " + PMD.EOL +    "  int b12; " + PMD.EOL +    "  int b13; " + PMD.EOL +    "  int b14; " + PMD.EOL +    "  int b15; " + PMD.EOL +    "  int b16; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public class Bar1 {" + PMD.EOL +    "  Object foo = new Object() {public int x;}; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " int a1; " + PMD.EOL +    " int a2; " + PMD.EOL +    " int a3; " + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.design;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyStatementNotInLoopRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyStatementNotInLoop");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, semicolon after for", 0, rule),           new TestDescriptor(TEST2, "ok, semicolon after while", 0, rule),           new TestDescriptor(TEST3, "bad, random semicolon", 1, rule),           new TestDescriptor(TEST4, "bad, double semicolon", 1, rule),           new TestDescriptor(TEST5, "ok, nested class", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  for (int i=2; i<10; i++);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  while (i++ < 20);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  ;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  class Y {};" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class IfElseStmtsMustUseBracesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("braces", "IfElseStmtsMustUseBraces");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "else without braces", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "two sets of missing braces", 2, rule),           new TestDescriptor(TEST4, "elseif with missing braces", 1, rule),           new TestDescriptor(TEST5, "elseif with braces after else", 0, rule),           new TestDescriptor(TEST6, "elseif with missing braces, first braces on separate line", 1, rule),           new TestDescriptor(TEST7, "bug 976643 - nested ifs without braces", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else {" + PMD.EOL +    "   x=4;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) " + PMD.EOL +    "   y=2;" + PMD.EOL +    "  else " + PMD.EOL +    "   x=4;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else if (true) { " + PMD.EOL +    "   x = 3; " + PMD.EOL +    "  } else " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } else if (true) { " + PMD.EOL +    "   x = 3; " + PMD.EOL +    "  } else { " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {     " + PMD.EOL +    "  if (true) " + PMD.EOL +    "  {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  } " + PMD.EOL +    "  else " + PMD.EOL +    "   y=4;" + PMD.EOL +    "  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  if (true) " + PMD.EOL +    "   if (false) " + PMD.EOL +    "    x=2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class WhileLoopsMustUseBracesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("braces", "WhileLoopsMustUseBraces");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "no braces", 1, rule),           new TestDescriptor(TEST2, "with braces", 0, rule),       });    }    private static final String TEST1 =    "public class WhileLoopsNeedBraces1 {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  int x =0;" + PMD.EOL +    "  while (true)" + PMD.EOL +    "   x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class WhileLoopsNeedBraces2 {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  int x =0;" + PMD.EOL +    "  while (true) {" + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ForLoopsMustUseBracesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("braces", "ForLoopsMustUseBraces");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "", 1, rule),           new TestDescriptor(TEST4, "", 1, rule),           new TestDescriptor(TEST5, "", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int i=0; i<42;i++)" + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (int i=0; i<42;i++) {" + PMD.EOL +    "       foo();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (int i=0; i<42;) " + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (int i=0;;) " + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  for (;;) " + PMD.EOL +    "       foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.braces;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class IfStmtsMustUseBracesRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("braces", "IfStmtsMustUseBraces");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "nested ifs", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  if (true) x=2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   x=2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {   " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   if (true) bar();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.logging.jakartacommons;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseCorrectExceptionLoggingTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/logging-jakarta-commons.xml", "UseCorrectExceptionLogging");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "failure case - two calls", 2, rule),           new TestDescriptor(TEST3, "must be in a catch block", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " static final Log _LOG = LogFactory.getLog( Main.class );" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (OtherException oe) {" + PMD.EOL +    "   _LOG.error(oe.getMessage(), oe);" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " static final Log _LOG = LogFactory.getLog( Main.class );" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (Exception e) {" + PMD.EOL +    "   _LOG.error(e);" + PMD.EOL +    "   _LOG.info(e);" + PMD.EOL +    "  } " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " static final Log _LOG = LogFactory.getLog( Main.class );" + PMD.EOL +    " void foo(int e) {" + PMD.EOL +    "  _LOG.error(e);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.logging.jakartacommons;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ProperLoggerTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/logging-jakarta-commons.xml", "ProperLogger");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "wrong class name", 1, rule),           new TestDescriptor(TEST3, "ok, special case", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private static final Log LOG = LogFactory.getLog(Foo.class);" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private static final Log LOG = LogFactory.getLog(Bar.class);" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private final Log log;" + PMD.EOL +    " Foo(Log log) {" + PMD.EOL +    "  this.log = log;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.logging.java;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MoreThanOneLoggerTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("logging-java", "MoreThanOneLogger");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "two loggers", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " Logger log;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Logger log;" + PMD.EOL +    " Logger log2;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.logging.java;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SystemPrintlnTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("logging-java", "SystemPrintln");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "one", 1, rule),           new TestDescriptor(TEST2, "many", 3, rule),           new TestDescriptor(TEST3, "none", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private void foo() { " + PMD.EOL +    " System.out.println(\"debug message\");  " + PMD.EOL +    " }  " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void foo1() { " + PMD.EOL +    " System.out.println(\"debug message\");  " + PMD.EOL +    " }  " + PMD.EOL +    " private void foo2() { " + PMD.EOL +    " System.out.println(\"debug message\");  " + PMD.EOL +    " System.out.println(\"debug message\");  " + PMD.EOL +    " }  " + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private void foo() { " + PMD.EOL +    " int x = 2;  " + PMD.EOL +    " }  " + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.logging.java;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LoggerIsNotStaticFinalTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("logging-java", "LoggerIsNotStaticFinal");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "two bad loggers", 2, rule),           new TestDescriptor(TEST3, "ok with internal class", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " static final Logger log;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " static final Logger log;" + PMD.EOL +    " Logger log1;" + PMD.EOL +    " Logger log2;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " static final Logger log;" + PMD.EOL +    " static class c { " + PMD.EOL +    "  static final Logger log;" + PMD.EOL +    " } " + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.logging.java;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidPrintStackTraceTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("logging-java", "AvoidPrintStackTrace");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (Exception e) {" + PMD.EOL +    "   e.printStackTrace();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (Exception e) {" + PMD.EOL +    "   LOG.error(e, \"Whoa!\");" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.sunsecure;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ArrayIsStoredDirectlyTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("sunsecure", "ArrayIsStoredDirectly");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "Clear violation", 1, rule),           new TestDescriptor(TEST2, "Clear violation with this.", 1, rule),           new TestDescriptor(TEST3, "assignment to an internal array", 1, rule),           new TestDescriptor(TEST4, "assignment of param to local", 0, rule),           new TestDescriptor(TEST5, "skip interfaces", 0, rule),           new TestDescriptor(TEST6, "skip abstract, native", 0, rule),           new TestDescriptor(TEST7, "equality expression, not assignment", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " String [] arr;" + PMD.EOL +    " void foo (String[] x) {arr = x;} ;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " String [] arr;" + PMD.EOL +    " void foo (String[] arr) {this.arr = arr;} ;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " String [] arr;" + PMD.EOL +    " void foo (String[] x) {this.arr = x;} ;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " String [] arr;" + PMD.EOL +    " void getArr(String[] arr) {String[] foo; foo = arr;} ;" + PMD.EOL +    "}";    private static final String TEST5 =    "public interface Foo {" + PMD.EOL +    " void getArr(String[] arr);" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " abstract void getArr(String[] arr);" + PMD.EOL +    " native void getArr2(String[] arr);" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void bar(String[] buf) {" + PMD.EOL +    "   x = (buf[0] == 1);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.sunsecure;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MethodReturnsInternalArrayTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("sunsecure", "MethodReturnsInternalArray");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "Clear violation", 1, rule),           new TestDescriptor(TEST2, "Clear violation with this.", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),           new TestDescriptor(TEST4, "tricky field hiding", 0, rule),           new TestDescriptor(TEST5, "really sick code", 1, rule),           new TestDescriptor(TEST6, "returning a local array is ok", 0, rule),           new TestDescriptor(TEST7, "returning a local array is ok part deux", 0, rule),           new TestDescriptor(TEST8, "returning a cloned field", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " String [] arr;" + PMD.EOL +    " String [] getArr() {return arr;} ;" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " String [] arr;" + PMD.EOL +        " String [] getArr() {return this.arr;} ;" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " String [] arr;" + PMD.EOL +        " String [] getArr() {String[] foo; return foo;} ;" + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " String [] arr;" + PMD.EOL +        " String [] getArr() {String[] arr; return arr;} ;" + PMD.EOL +        "}";    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " String [] arr;" + PMD.EOL +        " String [] getArr() {String[] arr; return this.arr;} ;" + PMD.EOL +        "}";    private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " int[] getArr() {" + PMD.EOL +        "  int[] x = new int[] {1,2,3};" + PMD.EOL +        "  return x;" + PMD.EOL +        " } ;" + PMD.EOL +        "}";    private static final String TEST7 =        "public class Foo {" + PMD.EOL +        " Object[] getArr() {" + PMD.EOL +        "  return new Object[] {foo,bar};" + PMD.EOL +        " } ;" + PMD.EOL +        "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private Object[] x;" + PMD.EOL +    " Object[] getArr() {" + PMD.EOL +    "  return this.x.clone();" + PMD.EOL +    " } ;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.clone;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CloneMethodMustImplementCloneableTest extends SimpleAggregatorTst{  private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("clone", "CloneMethodMustImplementCloneable");    }  public void testAll() {     runTests(new TestDescriptor[] {         new TestDescriptor(TEST1, "ok, implements Cloneable", 0, rule),         new TestDescriptor(TEST2, "bad, doesn't implement Cloneable", 1, rule),         new TestDescriptor(TEST3, "ok, not Object.clone since method has a param", 0, rule),     });  }    private static final String TEST1 =    "public class Foo implements Cloneable {" + PMD.EOL +    " void clone() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void clone() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void clone(int x) {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.clone;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CloneThrowsCloneNotSupportedExceptionTest extends SimpleAggregatorTst{  private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("clone", "CloneThrowsCloneNotSupportedException");    }  public void testAll() {     runTests(new TestDescriptor[] {         new TestDescriptor(TEST1, "ok, throws CloneNotSupportedException", 0, rule),         new TestDescriptor(TEST2, "bad", 1, rule),         new TestDescriptor(TEST3, "final class, rule does not apply", 0, rule),         new TestDescriptor(TEST4, "testing with multiple methods", 1, rule),     });  }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void clone() throws CloneNotSupportedException {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public final class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void clone() {}" + PMD.EOL +    " void foo() {}" + PMD.EOL +    " void bar() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.clone;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ProperCloneImplementationTest extends SimpleAggregatorTst{  private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("clone", "ProperCloneImplementation");    }  public void testAll() {     runTests(new TestDescriptor[] {         new TestDescriptor(TEST1, "ok, calls super.clone", 0, rule),         new TestDescriptor(TEST2, "bad, Foo.clone() calls new Foo();", 1, rule),         new TestDescriptor(TEST3, "clone([whatever]) is fine", 0, rule),     });  }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    "  super.clone();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void clone() {" + PMD.EOL +    "  Foo f = new Foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void clone(String fiddle) {" + PMD.EOL +    "  Foo f = new Foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.optimization;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimplifyStartsWithTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("optimizations", "SimplifyStartsWith");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "failure case", 1, rule),               new TestDescriptor(TEST2, "startsWith multiple chars", 0, rule),               new TestDescriptor(TEST3, "startsWith defined on some other class, doesn't take a String", 0, rule),       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        " public boolean bar(String x) {" + PMD.EOL +        "  return x.startsWith(\"x\");" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public boolean bar(Fiddle x) {" + PMD.EOL +        "  return x.startsWith(\"abc\");" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public boolean bar(Fiddle x) {" + PMD.EOL +        "  return x.startsWith(123);" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/* * Created on Jan 10, 2005  * * $Id$ */package test.net.sourceforge.pmd.rules.optimization;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;/** * Tests for the rule AvoidInstantiatingObjectsInLoops *  * @author mgriffa */public class AvoidInstantiatingObjectsInLoopsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("optimizations", "AvoidInstantiatingObjectsInLoops");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "TEST1", 1, rule),               new TestDescriptor(TEST2, "TEST2", 1, rule),               new TestDescriptor(TEST3, "TEST3", 1, rule),               new TestDescriptor(TEST4, "TEST4", 2, rule),               new TestDescriptor(TEST5, "throw new is OK", 0, rule),               new TestDescriptor(TEST6, "return new in loop is OK", 0, rule),               //new TestDescriptor(BUG_1114051, "BUG [ 1114051 ] Semi-false positive for instantiating new object in loop", 0, rule), //FIXME       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "   for(;;) {" + PMD.EOL +    "       String a = new String();" + PMD.EOL +     "   }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "   while(true) {" + PMD.EOL +        "       String a = new String();" + PMD.EOL +         "   }" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "   do{" + PMD.EOL +        "       String a = new String();" + PMD.EOL +         "   }while(true) ;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "   do{" + PMD.EOL +        "       String a = new String();" + PMD.EOL +         "       String b = new String();" + PMD.EOL +         "   }while(true) ;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "   for(;;) {" + PMD.EOL +        "       throw new Exception();" + PMD.EOL +        "   }" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " public String test1() {" + PMD.EOL +        "   for(;;) {" + PMD.EOL +        "       return new String();" + PMD.EOL +        "   }" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String BUG_1114051 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "   while (true) {" +        "        try {" +        "       } catch (Exception e) {" + PMD.EOL +        "           url = new StringBuffer(); " + PMD.EOL +        "           break; " + PMD.EOL +        "       }" + PMD.EOL +        "  }" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/* * Created on Jan 10, 2005  * * $Id$ */package test.net.sourceforge.pmd.rules.optimization;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;/** * Tests for the rule LocalVariableCouldBeFinal *  * @author mgriffa */public class LocalVariableCouldBeFinalTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("optimizations", "LocalVariableCouldBeFinal");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "TEST1", 1, rule),               new TestDescriptor(TEST2, "TEST2", 0, rule),               new TestDescriptor(TEST3, "TEST3", 0, rule),               new TestDescriptor(TEST4, "TEST4", 0, rule),               new TestDescriptor(TEST5, "TEST5", 2, rule),               new TestDescriptor(TEST6, "TEST6", 0, rule),               new TestDescriptor(TEST7, "TEST7", 0, rule),               new TestDescriptor(TEST8, "TEST8", 0, rule),               new TestDescriptor(TEST9, "TEST9", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void test1() {" + PMD.EOL +    "  int a = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  final int a = 0;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  a = 100;" + PMD.EOL +        " }" + PMD.EOL +        "}";        private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  a += 100;" + PMD.EOL +        " }" + PMD.EOL +        "}";    /*     * It can be discussed if this is a violation or not,      * not always the value of a, b is constant and he logic could of course be more complex     * */    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  int b = 0;" + PMD.EOL +        "  int c ;" + PMD.EOL +        "  c = a + b;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  ++a;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST7 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  a+=1;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST8 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  a++;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST9 =        "public class Foo {" + PMD.EOL +        " public void test1() {" + PMD.EOL +        "  int a = 0;" + PMD.EOL +        "  int b = 0;" + PMD.EOL +        "  a++;" + PMD.EOL +        "  a+=b;" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/* * Created on Jan 10, 2005  * * $Id$ */package test.net.sourceforge.pmd.rules.optimization;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MethodArgumentCouldBeFinalTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("optimizations", "MethodArgumentCouldBeFinal");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "TEST1", 1, rule),               new TestDescriptor(TEST2, "TEST2", 2, rule),               new TestDescriptor(TEST3, "TEST3", 2, rule),               new TestDescriptor(TEST4, "TEST4", 1, rule),               new TestDescriptor(TEST5, "TEST5", 1, rule),               new TestDescriptor(TEST6, "TEST6", 0, rule),               new TestDescriptor(TEST7, "Shouldn't trigger on try blocks", 0, rule),               new TestDescriptor(TEST8, "Skip native methods", 0, rule),               new TestDescriptor(TEST9, "Skip abstract methods", 0, rule),               new TestDescriptor(TEST10, "self assignment of a method param means it can't be final", 0, rule),               new TestDescriptor(TEST11, "same as above but prefix vs postfix", 0, rule),       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        " public void bar(int a) {}" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public void bar(int a, Object o) {}" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public void bar(int a, Object o) {" + PMD.EOL +        "  int z = a;" + PMD.EOL +        "  Object x = o.clone();" + PMD.EOL +        " }" + PMD.EOL +        "}";        private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " public void bar(final int a, Object o) {" + PMD.EOL +        "  int z = a;" + PMD.EOL +        "  Object x = o.clone();" + PMD.EOL +        " }" + PMD.EOL +        "}";        private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " public void bar(int a, final Object o) {" + PMD.EOL +        "  int z = a;" + PMD.EOL +        "  Object x = o.clone();" + PMD.EOL +        " }" + PMD.EOL +        "}";        private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " public void bar(final int a, final Object o) {" + PMD.EOL +        "  int z = a;" + PMD.EOL +        "  Object x = o.clone();" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST7 =        "public class Foo {" + PMD.EOL +        " public void bar(final List batch) {" + PMD.EOL +        "   try {} catch (Exception e) {} " + PMD.EOL +        "   try {} catch (Exception ee) {} " + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST8 =        "public class Foo {" + PMD.EOL +        " public native void bar(Object x);" + PMD.EOL +        "}";    private static final String TEST9 =        "public class Foo {" + PMD.EOL +        " public abstract void bar(Object x);" + PMD.EOL +        "}";    private static final String TEST10 =        "public class Foo {" + PMD.EOL +        " public void bar(int a) {" + PMD.EOL +        "  x[a++] = 1;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST11 =        "public class Foo {" + PMD.EOL +        " public void bar(int a) {" + PMD.EOL +        "  x[--a] = 1;" + PMD.EOL +        " }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.rules.optimization;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseStringBufferForStringAppendsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("optimizations", "UseStringBufferForStringAppends");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "failure case", 1, rule),               new TestDescriptor(TEST2, "startsWith multiple chars", 0, rule),       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        " public void bar() {" + PMD.EOL +        "  String x;" + PMD.EOL +        "  x = \"foo\";" + PMD.EOL +        "  x += \"bar\";" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public boolean bar(Fiddle x) {" + PMD.EOL +        "  return x.startsWith(\"abc\");" + PMD.EOL +        " }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidThrowingNullPointerExceptionTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("strictexception", "AvoidThrowingNullPointerException");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "throwing various types", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  throw new NullPointerException();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExceptionAsFlowControlTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("strictexception", "ExceptionAsFlowControl");        rule.setMessage("Avoid this stuff -> ''{0}''");    }        public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "normal throw catch", 0, rule),           new TestDescriptor(TEST3, "BUG 996007", 0, rule),           new TestDescriptor(TEST4, "NPE", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   try {" + PMD.EOL +    "   } catch (Exception e) {" + PMD.EOL +    "    throw new WrapperException(e);" + PMD.EOL +    "    // this is essentially a GOTO to the WrapperException catch block" + PMD.EOL +    "   }" + PMD.EOL +    "  } catch (WrapperException e) {" + PMD.EOL +    "   // do some more stuff " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";        private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  try {} catch (IOException e) {" + PMD.EOL +        "  if (foo!=null) " + PMD.EOL +        "       throw new IOException(foo.getResponseMessage()); " + PMD.EOL +        "  else  " + PMD.EOL +        "       throw e; " + PMD.EOL +        "  " + PMD.EOL +        "  }" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  switch(foo) {" + PMD.EOL +    "   default:" + PMD.EOL +    "    throw new IllegalArgumentException();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidCatchingThrowableRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("strictexception", "AvoidCatchingThrowable");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (Throwable t) {}   " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch (RuntimeException t) {}   " + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidThrowingRawExceptionTypesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("strictexception", "AvoidThrowingRawExceptionTypes");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "throwing various types", 4, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  throw new Throwable();" + PMD.EOL +    "  throw new Exception();" + PMD.EOL +    "  throw new Error();" + PMD.EOL +    "  throw new RuntimeException();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExceptionSignatureDeclarationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("strictexception", "SignatureDeclareThrowsException");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "method throws Exception", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "constructor throws Exception", 1, rule),           new TestDescriptor(TEST4, "skip junit setUp method", 0, rule),           new TestDescriptor(TEST5, "skip junit tearDown method", 0, rule),       });    }    public void testGenerics() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST6, rule, rpt);        assertEquals(0, rpt.size());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() throws Exception {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " Foo() throws Exception {}" + PMD.EOL +    "}";    private static final String TEST4 =    "import junit.framework.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " void setUp() throws Exception {}" + PMD.EOL +    "}";    private static final String TEST5 =    "import junit.framework.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " void tearDown() throws Exception {}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public <T> Bar<T> foo() { /* blah */}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strictexception;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidCatchingNPETest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("strictexception", "AvoidCatchingNPE");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "catching another type, ok", 0, rule),           new TestDescriptor(TEST3, "throwing it, ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (NullPointerException e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (FooException e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  throw new NullPointerException();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryCaseChangeRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("rulesets/strings.xml", "UnnecessaryCaseChange");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case with String.toUpperCase().equals()", 1, rule),           new TestDescriptor(TEST2, "failure case with String.toLowerCase().equals()", 1, rule),       });    }   private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private boolean baz(String buz) {" + PMD.EOL +    "  return foo.toUpperCase().equals(\"foo\");" + PMD.EOL +    " }" + PMD.EOL +    "}";   private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private boolean baz(String buz) {" + PMD.EOL +    "  return foo.toLowerCase().equals(\"foo\");" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class StringInstantiationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("strings", "StringInstantiation");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "new 'new String's", 2, rule),           new TestDescriptor(TEST2, "new String array", 0, rule),           new TestDescriptor(TEST3, "using multiple parameter constructor", 0, rule),           new TestDescriptor(TEST4, "using 4 parameter constructor", 0, rule),           new TestDescriptor(TEST5, "byte array constructor is ok", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private String bar = new String(\"bar\");" + PMD.EOL +    " private String baz = new String();" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private String[] bar = new String[5];" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  byte[] bytes = new byte[50];" + PMD.EOL +    "  String bar = new String(bytes, 0, bytes.length);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  byte[] bytes = new byte[50];" + PMD.EOL +    "  String bar = new String(bytes, 0, bytes.length, \"some-encoding\");" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  byte[] bytes = new byte[50];" + PMD.EOL +    "  String bar = new String(bytes);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class StringToStringRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("strings", "StringToString");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "local var", 1, rule),           new TestDescriptor(TEST2, "parameter", 1, rule),           new TestDescriptor(TEST3, "field", 1, rule),           new TestDescriptor(TEST4, "primitive", 0, rule),           new TestDescriptor(TEST5, "multiple similar params", 0, rule),           new TestDescriptor(TEST6, "string array", 1, rule)       });    }   private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private String baz() {" + PMD.EOL +    "  String bar = \"howdy\";" + PMD.EOL +    "  return bar.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private String baz(String bar) {" + PMD.EOL +    "  return bar.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private String baz;" + PMD.EOL +    " private int getBaz() {" + PMD.EOL +    "  return baz.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private int baz;" + PMD.EOL +    " private int getBaz() {" + PMD.EOL +    "  return baz;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private String getBaz(String foo, StringBuffer buffer) {" + PMD.EOL +    "  return buffer.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private String getBaz() {" + PMD.EOL +    "  String[] foo = {\"hi\"};" + PMD.EOL +    "  return foo[0].toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidConcatenatingNonLiteralsInStringBufferTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("strings", "AvoidConcatenatingNonLiteralsInStringBuffer");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "concatenating a literal to a method return value", 1, rule),               new TestDescriptor(TEST2, "same as TEST1, but in SB constructor", 1, rule),               new TestDescriptor(TEST3, "chained appends", 0, rule),               new TestDescriptor(TEST4, "concatenating two literals in SB constructor", 0, rule),               new TestDescriptor(TEST5, "concatenating two literals post-construction", 0, rule),               new TestDescriptor(TEST6, "case where concatenation is not a child of a BlockStatement, but instead is a child of an ExplicitConstructorInvocation", 0, rule),               new TestDescriptor(TEST7, "don't error out on array instantiation", 0, rule),               new TestDescriptor(TEST8, "usage of the StringBuffer constructor that takes an int", 0, rule),               new TestDescriptor(TEST9, "nested", 0, rule),               new TestDescriptor(TEST10, "looking up too high", 0, rule),       });    }   private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private void baz() {" + PMD.EOL +    "  StringBuffer sb = new StringBuffer();" + PMD.EOL +    "  sb.append(\"hello\"+ world()); "+    " }" + PMD.EOL +    "}";   private static final String TEST2 =       "public class Foo {" + PMD.EOL +       " private void baz() {" + PMD.EOL +       "  StringBuffer sb = new StringBuffer(\"hello\"+ world());" + PMD.EOL +       " }" + PMD.EOL +       "}";   private static final String TEST3 =       "public class Foo {" + PMD.EOL +       " private void baz() {" + PMD.EOL +       "  StringBuffer sb = new StringBuffer();" + PMD.EOL +       "  sb.append(\"hello\").append(world()); "+       " }" + PMD.EOL +       "}";   private static final String TEST4 =       "public class Foo {" + PMD.EOL +       " private void baz() {" + PMD.EOL +       "  StringBuffer sb = new StringBuffer(\"hello\"+ \"world\");" + PMD.EOL +       " }" + PMD.EOL +       "}";      private static final String TEST5 =       "public class Foo {" + PMD.EOL +       " private void baz() {" + PMD.EOL +       "  StringBuffer sb = new StringBuffer();" + PMD.EOL +       "  sb.append(\"hello\"+\"world\"); "+       " }" + PMD.EOL +       "}";   private static final String TEST6 =       "public class Foo {" + PMD.EOL +       " public Foo() {" + PMD.EOL +       "  super(\"CauseMsg:\" + ex.getMessage(), ex); " + PMD.EOL +       " }" + PMD.EOL +       "}";    private static final String TEST7 =        "public class Foo {" + PMD.EOL +        " public void bar() {" + PMD.EOL +        "  int t[] = new int[x+y+1];" + PMD.EOL +        " }" + PMD.EOL +        "}";   private static final String TEST8 =       "public class Foo {" + PMD.EOL +       " public int foor() {return 2;}" + PMD.EOL +       " public void bar(int x) {" + PMD.EOL +       "  StringBuffer buf = new StringBuffer(1 + foo());" + PMD.EOL +       " }" + PMD.EOL +       "}";   private static final String TEST9 =       "public class Foo {" + PMD.EOL +       " public void bar(int x) {" + PMD.EOL +       "  StringBuffer buf = new StringBuffer(x);" + PMD.EOL +       " }" + PMD.EOL +       "}";   private static final String TEST10 =       "public class Foo {" + PMD.EOL +       " public void bar() {" + PMD.EOL +       "  if (foo) {" + PMD.EOL +       "   StringBuffer buf = new StringBuffer();" + PMD.EOL +       "   buf.append(\"hello\");" + PMD.EOL +       "   Object x = a(\"world\" + x, buf.toString());" + PMD.EOL +       "  }" + PMD.EOL +       " }" + PMD.EOL +       "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules.strings;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.AvoidDuplicateLiteralsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;import java.util.Set;public class AvoidDuplicateLiteralsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("strings", "AvoidDuplicateLiterals");        rule.setMessage("avoid ''{0}'' and ''{1}'' and ''{2}''");        rule.addProperty("threshold", "2");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "duplicate literals in argument list", 1, rule),           new TestDescriptor(TEST2, "literal int argument, ok for now", 0, rule),           new TestDescriptor(TEST3, "duplicate literals in field decl", 1, rule),       });    }    public void testStringParserEmptyString() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("");        assertTrue(res.isEmpty());    }    public void testStringParserSimple() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("a,b,c");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("c"));    }    public void testStringParserEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("a,b,\\,");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains(","));    }    public void testStringParserEscapedEscapedChar() {        AvoidDuplicateLiteralsRule.ExceptionParser p = new AvoidDuplicateLiteralsRule.ExceptionParser(',');        Set res = p.parse("a,b,\\\\");        assertEquals(3, res.size());        assertTrue(res.contains("a"));        assertTrue(res.contains("b"));        assertTrue(res.contains("\\"));    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    "    buz(\"Howdy\");" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "    buz(2);" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " String[] FOO = {\"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\", \"foo\"};" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NoPackageTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "NoPackage");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "good", 0, rule),           new TestDescriptor(TEST3, "nested package", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "}";    private static final String TEST2 =    "package foo;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}";    private static final String TEST3 =    "package foo.bar;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AbstractClassWithoutAbstractMethodTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "AbstractClassWithoutAbstractMethod");    }    public void testAll() {       runTests(new TestDescriptor[] {       new TestDescriptor(TEST1, "concrete class", 0, rule),new TestDescriptor(TEST2, "failure case", 1, rule),new TestDescriptor(TEST3, "failure case, 1 method", 1, rule),new TestDescriptor(TEST4, "abstract class with abstract method", 0, rule),new TestDescriptor(TEST5, "abstract class implements interface", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {}";    private static final String TEST2 =    "public abstract class Foo {}";    private static final String TEST3 =    "public abstract class Foo {" + PMD.EOL +    "   int bar() {} " + PMD.EOL +    "}";    private static final String TEST4 =    "public abstract class Foo {" + PMD.EOL +    "   abstract int bar(); " + PMD.EOL +    "}";    private static final String TEST5 =    "public abstract class Foo implements Foo {" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.ExcessiveImports;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ExcessiveImportsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = new ExcessiveImports();        rule.addProperty("minimum", "3");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "import java.util.Vector;" + PMD.EOL +    "import java.util.Vector;" + PMD.EOL +    "import java.util.Vector;" + PMD.EOL +    "import java.util.Vector;" + PMD.EOL +    "public class Foo{}";    private static final String TEST2 =    "import java.util.Vector;" + PMD.EOL +    "public class Foo{}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousConstantFieldNameTest  extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "SuspiciousConstantFieldName");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "PI not final", 1, rule),           new TestDescriptor(TEST3, "PI and E not final", 2, rule),           new TestDescriptor(TEST4, "ok", 0, rule),           new TestDescriptor(TEST5, "ignore interfaces", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public int e;" + PMD.EOL +    " public final int PI;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public int e;" + PMD.EOL +    " public int PI;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public int E;" + PMD.EOL +    " public int PI;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public final int e;" + PMD.EOL +    " public final int PI;" + PMD.EOL +    "}";    private static final String TEST5 =    "public interface Foo {" + PMD.EOL +    " public int E;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyStaticInitializerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyStaticInitializer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " static {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " static {" + PMD.EOL +    "  x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class OverrideBothEqualsAndHashcodeTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "OverrideBothEqualsAndHashcode");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "hash code only", 1, rule),           new TestDescriptor(TEST2, "equals only", 1, rule),           new TestDescriptor(TEST3, "overrides both", 0, rule),           new TestDescriptor(TEST4, "overrides neither", 0, rule),           new TestDescriptor(TEST5, "equals sig uses String, not Object", 1, rule),           new TestDescriptor(TEST6, "interface", 0, rule),           new TestDescriptor(TEST7, "java.lang.Object", 0, rule),       });    }    private static final String TEST1 =    "public class OverrideBothEqualsAndHashcode1 {" + PMD.EOL +    " public int hashCode() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class OverrideBothEqualsAndHashcode2 {" + PMD.EOL +    " public boolean equals(Object other) {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class OverrideBothEqualsAndHashcode3 {" + PMD.EOL +    " public boolean equals(Object other) {}" + PMD.EOL +    " public int hashCode() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class OverrideBothEqualsAndHashcode4 {" + PMD.EOL +    "}";    private static final String TEST5 =    "public class OverrideBothEqualsAndHashcode5 {" + PMD.EOL +    " public boolean equals(String o) {" + PMD.EOL +    "  return true;" + PMD.EOL +    " }" + PMD.EOL +    " public int hashCode() {" + PMD.EOL +    "  return 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public interface OverrideBothEqualsAndHashcode6 {" + PMD.EOL +    " public boolean equals(Object o);" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public boolean equals(java.lang.Object o) {" + PMD.EOL +    "  return true;" + PMD.EOL +    " }" + PMD.EOL +    " public int hashCode() {" + PMD.EOL +    "  return 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class JumbledIncrementerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "JumbledIncrementer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "1", 1, rule),           new TestDescriptor(TEST2, "2", 0, rule),           new TestDescriptor(TEST3, "3", 0, rule),           new TestDescriptor(TEST4, "using outer loop incrementor as array index is OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i = 0; i < 10; i++) { " + PMD.EOL +    "   for (int k = 0; k < 20; i++) { " + PMD.EOL +    "    int x = 2; " + PMD.EOL +    "   } " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i = 0; i < 10; i++) { " + PMD.EOL +    "   for (int k = 0; k < 20; k++) { " + PMD.EOL +    "    int x = 2; " + PMD.EOL +    "   } " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i=0; i<5; ) {" + PMD.EOL +    "   i++;" + PMD.EOL +    "  }" + PMD.EOL +    "  for (int i=0;;) {" + PMD.EOL +    "   if (i<5) {" + PMD.EOL +    "    break;" + PMD.EOL +    "   }" + PMD.EOL +    "   i++;" + PMD.EOL +    "  }" + PMD.EOL +    "  for (;;) {" + PMD.EOL +    "   int x =5;" + PMD.EOL +    "  }" + PMD.EOL +    "  for (int i=0; i<5;i++) ;" + PMD.EOL +    "  for (int i=0; i<5;i++) " + PMD.EOL +    "   foo();" + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  for (int i = 0; i < 10; i++) { " + PMD.EOL +    "   for (int k = 0; k < 20; j[i]++) { " + PMD.EOL +    "    int x = 2; " + PMD.EOL +    "   } " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalizeShouldBeProtectedRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("finalizers", "FinalizeShouldBeProtected");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "public finalize", 1, rule),           new TestDescriptor(TEST2, "finalize with some params", 0, rule),           new TestDescriptor(TEST3, "legitimate overriding", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void finalize() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void finalize(int x) {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " protected void finalize() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptySynchronizedBlockRuleTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptySynchronizedBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  synchronized (this) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  synchronized (this) {int x = 2;}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MethodWithSameNameAsEnclosingClassRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "MethodWithSameNameAsEnclosingClass");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "doesn't crash on interfaces", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " int Foo(double x) {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " void voo();" + PMD.EOL +    "}";}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.ExcessivePublicCount;import test.net.sourceforge.pmd.testframework.RuleTst;public class ExcessivePublicCountTest extends RuleTst {    private Rule rule = new ExcessivePublicCount();    public void testSimpleOK() throws Throwable {        rule.addProperty("minimum", "50");        runTestFromString(TEST1, 0, rule);    }    public void testSimpleBad() throws Throwable {        rule.addProperty("minimum", "2");        runTestFromString(TEST2, 1, rule);    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public int foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public int foo;" + PMD.EOL +    " public int bif;" + PMD.EOL +    " public int baz;" + PMD.EOL +    " public int bof;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class InstantiationToGetClassRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "InstantiationToGetClass");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "should catch param to constructor", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " Class clazz = new String().getClass();" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Class clazz = getFoo().getClass();" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " Class clazz = new Integer(10).getClass();" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryParenthesesTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws Exception {        rule = findRule("controversial", "UnnecessaryParentheses");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case, returning literal", 1, rule),           new TestDescriptor(TEST2, "ok, complex expression", 0, rule),           new TestDescriptor(TEST3, "bad, returning variable in parens", 1, rule),           new TestDescriptor(TEST4, "ok, returning comparison", 0, rule),       });    }    private static final String TEST1 =    " public class Foo {" + PMD.EOL +    "  int bar() {" + PMD.EOL +    "   return (2); " + PMD.EOL +    "  }" + PMD.EOL +    " }";    private static final String TEST2 =    " public class Foo {" + PMD.EOL +    "  int bar() {" + PMD.EOL +    "   return (2+2); " + PMD.EOL +    "  }" + PMD.EOL +    " }";    private static final String TEST3 =    " public class Foo {" + PMD.EOL +    "  int bar(int y) {" + PMD.EOL +    "   return (y); " + PMD.EOL +    "  }" + PMD.EOL +    " }";    private static final String TEST4 =    " public class Foo {" + PMD.EOL +    "  int bar(int y) {" + PMD.EOL +    "   return (x=y); " + PMD.EOL +    "  }" + PMD.EOL +    " }";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class BooleanInstantiationRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "BooleanInstantiation");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "new java.lang.Boolean", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),           new TestDescriptor(TEST4, "don't use Boolean.valueOf() with literal", 2, rule),           new TestDescriptor(TEST5, "valueOf() with variable is fine", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " Boolean b = new Boolean(\"true\");" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " Boolean b = new java.lang.Boolean(\"true\");" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " Boolean b = Boolean.TRUE;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " Boolean b = Boolean.valueOf(true);" + PMD.EOL +    " Boolean b1 = Boolean.valueOf(false);" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " Boolean b = Boolean.valueOf(x);" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedPrivateFieldRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("unusedcode", "UnusedPrivateField");        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple unused private field", 1, rule),           new TestDescriptor(TEST2, "private field referenced in another field's initializer", 0, rule),           new TestDescriptor(TEST3, "private field with field of same name in anonymous inner class", 1, rule),           new TestDescriptor(TEST4, "field is used semantically before it's declared syntactically", 0, rule),           new TestDescriptor(TEST5, "private field referenced via 'this' modifier", 0, rule),           new TestDescriptor(TEST6, "private referenced by anonymous inner class", 0, rule),           new TestDescriptor(TEST7, "interface sanity test", 0, rule),           new TestDescriptor(TEST8, "unused private field in static inner class", 1, rule),           new TestDescriptor(TEST9, "private field referenced in nonstatic inner class", 0, rule),           new TestDescriptor(TEST10, "unused private static field", 1, rule),           new TestDescriptor(TEST11, "private static final referenced with qualifier", 0, rule),           new TestDescriptor(TEST12, "unused private field after class decl", 1, rule),           new TestDescriptor(TEST13, "two unused private fields in separate inner classes", 2, rule),           new TestDescriptor(TEST14, "method param shadows unused private field", 1, rule),           new TestDescriptor(TEST15, "private field referenced via 'this' not shadowed by param of same name", 0, rule),           new TestDescriptor(TEST16, "don't catch public fields", 0, rule),           new TestDescriptor(TEST17, "instantiate self and reference private field on other object", 0, rule),           new TestDescriptor(TEST18, "don't count Serialization fields as being unused", 0, rule),           new TestDescriptor(TEST19, "an assignment does not a usage make", 1, rule),           new TestDescriptor(TEST20, "assignment to field member is a usage", 0, rule),           new TestDescriptor(TEST21, "assignment to field member using this modifier is a usage", 0, rule),           new TestDescriptor(TEST22, "this.foo++ shouldn't throw an NPE, but isn't a usage", 1, rule),           new TestDescriptor(TEST23, "super.foo++ shouldn't throw an NPE", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "private String foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " private String bar = foo;" + PMD.EOL +    " void buz() {" + PMD.EOL +    "  bar = bar + 1;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " void baz() {" + PMD.EOL +    "  Runnable r = new Runnable() {" + PMD.EOL +    "   public void run() {" + PMD.EOL +    "    String foo = \"buz\";" + PMD.EOL +    "   }" + PMD.EOL +    "  };   " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  foo[0] = foo[0] + 1;" + PMD.EOL +    " }" + PMD.EOL +    " private int[] foo;" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private String foo;" + PMD.EOL +    " void bar() {   " + PMD.EOL +    "  bar = this.foo;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " private static final String FOO = \"foo\";" + PMD.EOL +    "  public Runnable bar() {      " + PMD.EOL +    "   return new Runnable() {" + PMD.EOL +    "    public void run() {" + PMD.EOL +    "     FOO.toString();" + PMD.EOL +    "    }" + PMD.EOL +    "   };" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    " public static final String FOO = \"FOO\"; " + PMD.EOL +    " public boolean equals(Object another);" + PMD.EOL +    " public int hashCode();" + PMD.EOL +    " public String toString();" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public static class Services {" + PMD.EOL +    "  private String x;    " + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " private class Bar {" + PMD.EOL +    "  void baz() {" + PMD.EOL +    "   x = x + 2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " private static String foo;" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " private static final int BAR = 2;" + PMD.EOL +    " int x = Foo.BAR;" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " public class Foo {}" + PMD.EOL +    " private int x;" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " public class Foo {private int x;}" + PMD.EOL +    " public class Bar {private int x;}" + PMD.EOL +    "}";    private static final String TEST14 =    "public class Foo {" + PMD.EOL +    " private int value;" + PMD.EOL +    " int doSomething(int value) { " + PMD.EOL +    "  return value + 1; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST15 =    "public class Foo {" + PMD.EOL +    " private int x; " + PMD.EOL +    " public Foo(int x) {" + PMD.EOL +    "  this.x= this.x + 1;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + PMD.EOL +    " public static final int FOO = 1;" + PMD.EOL +    "}";    private static final String TEST17 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  Foo foo = new Foo();  " + PMD.EOL +    "  foo.x = foo.x + 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST18 =    "public class Foo {" + PMD.EOL +    " private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"foo\", String.class)};" + PMD.EOL +    "}";    private static final String TEST19 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x = 4;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST20 =    "public class Foo {" + PMD.EOL +    " private Foo x = new Foo();" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  x.y = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST21 =    "public class Foo {" + PMD.EOL +    " private Foo x = new Foo();" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  this.x.y = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST22 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  this.x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST23 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  super.x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class LongVariableRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "LongVariable");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "param", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "local", 1, rule),           new TestDescriptor(TEST4, "for", 1, rule),           new TestDescriptor(TEST5, "17 character max", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    void foo(String argsWithExtraMustard) {} " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    void foo() {" + PMD.EOL +    "       int bugleDeWump = -1;" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "" + PMD.EOL +    "    void foo() {" + PMD.EOL +    "       int abcdefghijklmnopqrstuvwxyz = -1; " + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "   void foo() {" + PMD.EOL +    "       for (int interestingIntIterator = 0; " + PMD.EOL +    "            interestingIntIterator < 10; " + PMD.EOL +    "            interestingIntIterator++) { }" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "    private int a2345678901234567;" + PMD.EOL +    "    private int a23456789012345678;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class OptimizableToArrayCallTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "OptimizableToArrayCall");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "Array dimensioner uses method call, ok", 0, rule),           new TestDescriptor(TEST3, "Array dimensioner uses variable, ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " {x.toArray(new Foo[0]);}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " {x.toArray(new Foo[x.size()]);}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " {x.toArray(new Foo[y]);}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseArrayListInsteadOfVectorTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("optimizations", "UseArrayListInsteadOfVector");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST0, "TEST0", 0, rule),               new TestDescriptor(TEST1, "TEST1", 1, rule),               new TestDescriptor(TEST2, "TEST2", 1, rule),               new TestDescriptor(TEST3, "TEST3", 1, rule),       });    }    private static final String TEST0 =    "public class Bar {" + PMD.EOL +    " void x() {" + PMD.EOL +     "  List v = new ArrayList(); " + PMD.EOL +    " }" + PMD.EOL +    "}";        private static final String TEST1 =    "public class Bar {" + PMD.EOL +    " void x() {" + PMD.EOL +    "  Vector v = new Vector(); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Bar {" + PMD.EOL +    " Vector v = new Vector(); " + PMD.EOL +    " void x() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Bar {" + PMD.EOL +    " List v = new Vector(); " + PMD.EOL +    " void x() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.rules.ClassNamingConventions;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ClassNamingConventionsTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "class names should not start with lowercase character", 1, new ClassNamingConventions()),           new TestDescriptor(TEST2, "all is well", 0, new ClassNamingConventions()),       });    }    private static final String TEST1 =    "public class foo {};";    private static final String TEST2 =    "public class FooBar {};";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DontImportSunTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "DontImportSun");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad, import from sun.", 1, rule),           new TestDescriptor(TEST2, "ok, signal is ok", 0, rule),       });    }    private static final String TEST1 =    "import sun.Foo;" + PMD.EOL +    "public class Bar {}";    private static final String TEST2 =    "import sun.misc.Signal;" + PMD.EOL +    "public class Bar {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.rules.VariableNamingConventions;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class VariableNamingConventionsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "VariableNamingConventions");    }        public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "final statics should be all caps", 1, rule),           new TestDescriptor(TEST2, "non-finals shouldn't have underscores", 1, rule),           new TestDescriptor(TEST3, "variables names should start with lowercase character", 1,  rule),           new TestDescriptor(TEST4, "all is well", 0,  rule),           new TestDescriptor(TEST5, "local finals are ok", 0, rule),           new TestDescriptor(TEST6, "serialVersionUID is OK", 0,  rule),           new TestDescriptor(TEST7, "interface fields are tested", 1,  rule),           new TestDescriptor(TEST8, "final non-statics need not be all caps", 0,  rule),       });    }    public void testPrefixStripping() throws Throwable {        Rule r =  new VariableNamingConventions();        r.addProperty("staticPrefix", "s_");        runTestFromString(TEST9, 0, r);    }    public void testSuffixStripping() throws Throwable {        Rule r =  new VariableNamingConventions();        r.addProperty("staticSuffix", "_s");        runTestFromString(TEST10, 0, r);    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private static final int foo = 2;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private int foo_bar = 2;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private int Ubar = 2;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private int bar = 2;" + PMD.EOL +    " private static final int FOO_BAR = 2;" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "  final int STATE_READING = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    "  static final long serialVersionUID = 423343L;" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    "  int foo = 42;" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    "  final int foo = 42;" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    "  static int s_foo = 42;" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    "  static int foo_s = 42;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedLocalVariableTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("unusedcode", "UnusedLocalVariable");        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "unused local with assignment", 1, rule),           new TestDescriptor(TEST2, "unused local w/o assignment", 1, rule),           new TestDescriptor(TEST3, "unused local in constructor", 1, rule),           new TestDescriptor(TEST4, "local used on rhs", 0, rule),           new TestDescriptor(TEST5, "unused local in static initializer", 1, rule),           new TestDescriptor(TEST6, "unused field", 0, rule),           new TestDescriptor(TEST7, "loop indexes are not unused locals", 0, rule),           new TestDescriptor(TEST8, "local used in anonymous inner class", 0, rule),           new TestDescriptor(TEST9, "two unused locals of same name, one in nested class", 2, rule),           new TestDescriptor(TEST10, "two locals declared on same line", 2, rule),           new TestDescriptor(TEST11, "an assignment does not a usage make", 1, rule),           new TestDescriptor(TEST12, "a compound assignment operator doth a usage make", 0, rule),           new TestDescriptor(TEST13, "assignment to a member field means used", 0, rule),           new TestDescriptor(TEST14, "make sure scopes are working", 3, rule),           new TestDescriptor(TEST15, "another scope test", 1, rule),           new TestDescriptor(TEST16, "assignment to an array member will be treated as a usage", 0, rule),           new TestDescriptor(TEST17, "local variable used in postfix expression as child of StatementExpression", 1, rule),           new TestDescriptor(TEST18, "local variable used in postfix expression on right hand side", 0, rule),           new TestDescriptor(TEST19, "local variable, object ref, public field of which is incremented via in postfix expression", 0, rule),           new TestDescriptor(TEST20, "local used in right shift", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "   String fr = new String();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x;" + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST3 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "    public Foo() {" + PMD.EOL +    "       List a = new ArrayList();" + PMD.EOL +    "    }" + PMD.EOL +    "}" + PMD.EOL +    "";    private static final String TEST4 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "    public Foo() {" + PMD.EOL +    "       List a = new ArrayList();" + PMD.EOL +    "       if (true) {" + PMD.EOL +    "               a.size();" + PMD.EOL +    "       }" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST5 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " static {" + PMD.EOL +    "  String x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public int x;" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int i=0;i<10; i++);" + PMD.EOL +    "  for (int i=0;i<10; i++);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  final int x = 2;" + PMD.EOL +    "   new Runnable() {" + PMD.EOL +    "    public void run() {" + PMD.EOL +    "     System.out.println(x);" + PMD.EOL +    "    }" + PMD.EOL +    "   };  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST9=    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  class Bar {" + PMD.EOL +    "   void buz() {" + PMD.EOL +    "    int x = 4;" + PMD.EOL +    "   }" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x,y=0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x;" + PMD.EOL +    "   x = 4;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 0;" + PMD.EOL +    "   x += 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   Bar b = new Bar();" + PMD.EOL +    "   b.buz = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST14 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   if (true) {int y =2;int j =3;} " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST15 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   if (true) {int y =2;foo(y);int j =3;foo(j);} " + PMD.EOL +    " }" + PMD.EOL +    " void bar2() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   fiddle(x);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int[] x = {2};" + PMD.EOL +    "   x[1] = 2; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST17 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   x++; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST18 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   foo(x++); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST19 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   Baz b = getBaz();" + PMD.EOL +    "   b.x++; " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST20 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "   int x = 2;" + PMD.EOL +    "   int y = 4 >> x;" + PMD.EOL +    "   foo(y);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AssignmentInOperandTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "AssignmentInOperand");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "assignment in if conditional expression", 0, rule),           new TestDescriptor(TEST4, "assignment in while conditional expression", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  if ((x = getX()) == 3) {" + PMD.EOL +    "   System.out.println(\"3!\");" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    " private int getX() {" + PMD.EOL +    "  return 3;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  if (false) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  if (false) {" + PMD.EOL +    "   int x =2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  while ( (x = getX()) != 0 ) {}" + PMD.EOL +    " }" + PMD.EOL +    " private int getX() {return 2;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ForLoopShouldBeWhileLoopRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "ForLoopShouldBeWhileLoop");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "for loop like this: for (;;) {} ", 0, rule),       });    }    public void testJDK15ForLoop() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST4, rule, rpt);        assertEquals(0, rpt.size());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  for (;x<5;) { " + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (int x=2;x<5;) { " + PMD.EOL +    "   x++;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (;;) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  for (String x : mylist) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class TestClassWithoutTestCasesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("junit", "TestClassWithoutTestCases");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "TEST1", 1, rule),   new TestDescriptor(TEST2, "TEST2", 0, rule),   new TestDescriptor(TEST3, "TEST3", 1, rule),   new TestDescriptor(TEST4, "TEST4", 0, rule),       });    }    private static final String TEST1 =    "public class FooTest {}";    private static final String TEST2 =        "public class FooTest {" + PMD.EOL +        "   void testX(){}" + PMD.EOL +        "}";    private static final String TEST3 =        "public class FooTest {" + PMD.EOL +        "   class Bar { void testX(){} } " + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        "   class BarTest { void testX(){} } " + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class BadComparisonTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "BadComparison");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "comparison to Double.NaN", 1, rule),           new TestDescriptor(TEST2, "ok equality comparison", 0, rule),           new TestDescriptor(TEST3, "comparison to Float.NaN", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " boolean x = (y == Double.NaN);" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " boolean x = (y == z);" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " boolean x = (y == Float.NaN);" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedFormalParameterRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = find();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "method called on param", 0, rule),           new TestDescriptor(TEST3, "assignment to param", 0, rule),           new TestDescriptor(TEST4, "interface", 0, rule),           new TestDescriptor(TEST5, "don't flag public methods by default", 0, rule),           new TestDescriptor(TEST6, "skip native/abstract methods", 0, rule),           new TestDescriptor(TEST7, "anonymous inner class npe", 0, rule)       });    }    public void testCheckPublicFlag() throws Throwable {        Rule r = find();        r.addProperty("checkall", "true");        runTestFromString(TEST5, 1, r);    }    private Rule find() throws Exception {        return findRule("unusedcode", "UnusedFormalParameter");    }    private static final String TEST1 =    "class Foo {" + PMD.EOL +    " private void bar(String x) {}" + PMD.EOL +    "}";    private static final String TEST2 =    "class Foo {" + PMD.EOL +    " private void foo (String s) {" + PMD.EOL +    "  String str = s.toString();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "class Foo {" + PMD.EOL +    " private void bar(int s) {" + PMD.EOL +    "  s = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo {" + PMD.EOL +    " void foo(int x);" + PMD.EOL +    "}";    private static final String TEST5 =    "class Foo {" + PMD.EOL +    " public void bar(int s) {}" + PMD.EOL +    "}";    private static final String TEST6 =    "class Foo {" + PMD.EOL +    " public native void bar(int s);" + PMD.EOL +    " protected abstract void foo(Long s);" + PMD.EOL +    "}";    private static final String TEST7 =    "class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  ActionListener a  = new ActionListener() {" + PMD.EOL +    "   public void event(Event e) {}" + PMD.EOL +    "  };" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimpleDateFormatNeedsLocaleRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "SimpleDateFormatNeedsLocale");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, uses a two arg constructor", 0, rule),           new TestDescriptor(TEST2, "bad, using the single-arg contructor", 1, rule),           new TestDescriptor(TEST3, "all quiet", 0, rule),       });    }    private static final String TEST1 =    "class Foo {" + PMD.EOL +    "  private SimpleDateFormat sdf = new SimpleDateFormat(\"pattern\", Locale.US);" + PMD.EOL +    "}";    private static final String TEST2 =    "class Foo {" + PMD.EOL +    "  private SimpleDateFormat sdf = new SimpleDateFormat(\"pattern\");" + PMD.EOL +    "}";    private static final String TEST3 =    "class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ShortMethodNameTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "ShortMethodName");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "bad", 1, rule),           new TestDescriptor(TEST3, "2 violations", 2, rule),           new TestDescriptor(TEST4, "2 methods, 1 violation", 1, rule),       });    }    private static final String TEST1 =    "public class ShortMethodName0 {" + PMD.EOL +    "    public int abcd( int i ) {" + PMD.EOL +    "       // Should not violate." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class ShortMethodName1 {" + PMD.EOL +    "    public int a( int i ) {" + PMD.EOL +    "       // Should violate." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class ShortMethodName2 {" + PMD.EOL +    "    public int a( int i ) {" + PMD.EOL +    "       // Should violate" + PMD.EOL +    "    }" + PMD.EOL +    "" + PMD.EOL +    "    public int b( int i ) {" + PMD.EOL +    "       // Should violate" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class ShortMethodName3 {" + PMD.EOL +    "    public int a( int i ) {" + PMD.EOL +    "       // Should violate" + PMD.EOL +    "    }" + PMD.EOL +    "" + PMD.EOL +    "    public int bcde( int i ) {" + PMD.EOL +    "       // Should not violate" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class FinalFieldCouldBeStaticRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "FinalFieldCouldBeStatic");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "already static, OK", 0, rule),           new TestDescriptor(TEST3, "non-final, OK", 0, rule),           new TestDescriptor(TEST4, "non-primitive failure case - only works for String", 1, rule),           new TestDescriptor(TEST5, "final field that's a thread, OK", 0, rule),           new TestDescriptor(TEST6, "don't flag interfaces", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public final int BAR = 42;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public static final int BAR = 42;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public int BAR = 42;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public final String BAR = \"42\";" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public final Thread BAR = new Thread();" + PMD.EOL +    "}";    private static final String TEST6 =    "public interface Foo {" + PMD.EOL +    " public final int BAR = 42;" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ShortVariableRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "ShortVariable");        rule.setMessage("{0}");        rule.addProperty("pluginname", "true");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "param", 1, rule),           new TestDescriptor(TEST2, "none", 0, rule),           new TestDescriptor(TEST3, "local", 1, rule),           new TestDescriptor(TEST4, "for", 0, rule),           new TestDescriptor(TEST5, "field", 1, rule),           new TestDescriptor(TEST6, "catch(Exception e) is OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public static void main(String a[]) { // a should trigger it." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "       int bugleDeWump = -1;" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "       int ab = -1; " + PMD.EOL +    "       // Should trigger ShortVariable rule." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "    public static void main(String args[]) {" + PMD.EOL +    "       for (int i = 0; i < 10; i++) { } // Should NOT!! trigger." + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "    private int qx; // Should cause a problem." + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    "    private void bar() {" + PMD.EOL +    "     try {} catch (Exception e) {}" + PMD.EOL +    "    }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.rules.XPathRule;import test.net.sourceforge.pmd.testframework.RuleTst;import java.io.StringReader;/** * @author daniels */public class XPathRuleTest extends RuleTst {    XPathRule rule;    public void setUp() {        rule = new XPathRule();        rule.setMessage("XPath Rule Failed");    }    public void testPluginname() throws Throwable {        Rule rule = new XPathRule();        rule.addProperty("xpath", "//VariableDeclaratorId[string-length(@Image) < 3]");        rule.setMessage("{0}");        rule.addProperty("pluginname", "true");        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        RuleSet rules = new RuleSet();        rules.addRule(rule);        p.processFile(new StringReader(TEST1), rules, ctx);        RuleViolation rv = (RuleViolation)report.iterator().next();        assertEquals("a", rv.getDescription());    }    public void testVariables() throws Throwable {        Rule rule = new XPathRule();        rule.addProperty("xpath", "//VariableDeclaratorId[@Image=$var]");        rule.setMessage("Avoid vars");        rule.addProperty("var", "fiddle");        PMD p = new PMD();        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        RuleSet rules = new RuleSet();        rules.addRule(rule);        p.processFile(new StringReader(TEST2), rules, ctx);        RuleViolation rv = (RuleViolation)report.iterator().next();        assertEquals(3, rv.getLine());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " int a;" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " int faddle;" + PMD.EOL +    " int fiddle;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EqualsNullRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "EqualsNull");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "object.equals(null), bad", 1, rule),           new TestDescriptor(TEST2, "object == null, ok", 0, rule),           new TestDescriptor(TEST3, "object.method().equals(null), bad", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (foo.equals(null)) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (foo == null) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (foo.bar().equals(null)) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CallSuperInConstructorTest extends SimpleAggregatorTst {private Rule rule = null;public void setUp() {rule = findRule("controversial", "CallSuperInConstructor");}    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "TEST1", 1, rule),   new TestDescriptor(TEST2, "TEST2", 0, rule),   new TestDescriptor(TEST3, "TEST3", 0, rule),       });    }        private static final String TEST1 =    "public class Foo {" + PMD.EOL +" public Foo() {" + PMD.EOL +" }" + PMD.EOL +"}";        private static final String TEST2 =    "public class Foo {" + PMD.EOL +" public Foo() {" + PMD.EOL +" super();" + PMD.EOL +"}" + PMD.EOL +"}";        private static final String TEST3 =    "public class Foo {" + PMD.EOL +" public Foo(Object o) {" + PMD.EOL +" this();" + PMD.EOL +"}" + PMD.EOL +" public Foo() {" + PMD.EOL +" super();" + PMD.EOL +"}" + PMD.EOL +"}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UselessOverridingMethodTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/basic.xml", "UselessOverridingMethod");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "return value returned by super()", 1, rule),               new TestDescriptor(TEST2, "void method", 1, rule),               new TestDescriptor(TEST3, "return concatenated strings expression", 0, rule),               new TestDescriptor(TEST4, "return method call that uses param", 0, rule),               new TestDescriptor(TEST5, "use superclass method with expression", 0, rule),       });    }    private static final String TEST1 =    "public class Bar {" + PMD.EOL +    " String foo() {" + PMD.EOL +    "  return super.foo(); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Buz{" + PMD.EOL +    " public void foo(String bar) {" + PMD.EOL +    "  super.foo(bar); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Buz{" + PMD.EOL +    " public String foo(String bar) {" + PMD.EOL +    "   return \"\" + super.foo(bar); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Buz{" + PMD.EOL +    " public String foo(String bar) {" + PMD.EOL +    "   return super.foo(buz(bar)); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Buz{" + PMD.EOL +    " public String foo(String bar) {" + PMD.EOL +    "   return super.foo(\"\" + bar); " + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.DuplicateImportsRule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DuplicateImportsRuleTest extends SimpleAggregatorTst {    private DuplicateImportsRule rule;    public void setUp() {        rule = new DuplicateImportsRule();        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "duplicate single type imports", 1, rule),           new TestDescriptor(TEST2, "duplicate wildcard imports", 1, rule),           new TestDescriptor(TEST3, "single type import after wildcard import", 1, rule),           new TestDescriptor(TEST4, "subpackage import, ok", 0, rule),       });    }    private static final String TEST1 =    "import java.io.File;" + PMD.EOL +    "import java.util.*;" + PMD.EOL +    "import java.io.File;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import java.io.*;" + PMD.EOL +    "import java.io.*;" + PMD.EOL +    "public class Foo {}";    private static final String TEST3 =    "import java.util.*;" + PMD.EOL +    "import java.net.*;" + PMD.EOL +    "import java.io.*;" + PMD.EOL +    "import java.io.File;" + PMD.EOL +    "public class Foo {}";    private static final String TEST4 =    "import javax.servlet.*;" + PMD.EOL +    "import javax.servlet.http.*;" + PMD.EOL +    "public class Foo {}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousEqualsMethodNameRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "SuspiciousEqualsMethodName");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad, equals(Foo foo)", 1, rule),           new TestDescriptor(TEST2, "ok, equals(Object foo)", 0, rule),           new TestDescriptor(TEST3, "bad, equal(Object foo)", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public boolean equals(Foo foo) {return true;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public boolean equals(Object foo) {return true;}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public boolean equal(Object foo) {return true;}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidDollarSignsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "AvoidDollarSigns");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "class Fo$o", 1, rule),           new TestDescriptor(TEST2, "variable fo$oo", 1, rule),           new TestDescriptor(TEST3, "method foo$oo", 1, rule),           new TestDescriptor(TEST4, "interface fo$oo", 1, rule),           new TestDescriptor(TEST5, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class F$oo {}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " int fo$o;" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void fo$o() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo$oo {}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    " int buz;" + PMD.EOL +    "}" + PMD.EOL +    "public interface Baz {} ";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.RuleViolation;import test.net.sourceforge.pmd.testframework.RuleTst;import java.util.Iterator;public class CyclomaticComplexityTest extends RuleTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("codesize", "CyclomaticComplexity");        rule.setMessage("The {0} ''{1}'' has a Cyclomatic Complexity of {2}.");    }    public void testOneMethod() throws Throwable {        rule.addProperty("reportLevel", "1");        Report report = new Report();        runTestFromString(TEST1, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);    }    public void testNastyComplicatedMethod() throws Throwable {        rule.addProperty("reportLevel", "10");        Report report = new Report();        runTestFromString(TEST2, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 12") != -1);    }    public void testConstructor() throws Throwable {        rule.addProperty("reportLevel", "1");        Report report = new Report();        runTestFromString(TEST3, rule, report);        Iterator i = report.iterator();        RuleViolation rv = (RuleViolation) i.next();        assertTrue(rv.getDescription().indexOf("Highest = 1") != -1);    }    public void testLessComplicatedThanReportLevel() throws Throwable {        rule.addProperty("reportLevel", "10");        Report report = new Report();        runTestFromString(TEST1, rule, report);        assertEquals(0, report.size());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public void example() {" + PMD.EOL +    "  int x = 0;" + PMD.EOL +    "  int a = 0;" + PMD.EOL +    "  int b = 0;" + PMD.EOL +    "  int c = 0;" + PMD.EOL +    "  int d = 0;" + PMD.EOL +    "  int a1 = 0;" + PMD.EOL +    "  int a2 = 0;" + PMD.EOL +    "  int b1 = 0;" + PMD.EOL +    "  int b2 = 0;" + PMD.EOL +    "  int z = 0;" + PMD.EOL +    "  int h = 0;" + PMD.EOL +    "  int e = 0;" + PMD.EOL +    "  int f = 0;" + PMD.EOL +    "" + PMD.EOL +    "  if (a == b) {" + PMD.EOL +    "   if (a1 == b1) {" + PMD.EOL +    "     x=2;" + PMD.EOL +    "   } else if (a2 == b2) {" + PMD.EOL +    "     x=2;" + PMD.EOL +    "   }" + PMD.EOL +    "            else" + PMD.EOL +    "            {" + PMD.EOL +    "                x=2;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "       else if (c == d)" + PMD.EOL +    "        {" + PMD.EOL +    "           while (c == d)" + PMD.EOL +    "            {" + PMD.EOL +    "                x=2;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "       else if (e == f)" + PMD.EOL +    "        {" + PMD.EOL +    "           for (int n = 0; n < h; n++)" + PMD.EOL +    "            {" + PMD.EOL +    "                x=2;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "        else" + PMD.EOL +    "        {" + PMD.EOL +    "            switch (z)" + PMD.EOL +    "            {" + PMD.EOL +    "               case 1:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "" + PMD.EOL +    "              case 2:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "" + PMD.EOL +    "              case 3:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "" + PMD.EOL +    "              default:" + PMD.EOL +    "                x=2;" + PMD.EOL +    "                    break;" + PMD.EOL +    "            }" + PMD.EOL +    "        }" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyTryBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyTryBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "bad", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule)       });    }    private static final String TEST1 =    "public class EmptyTryBlock1 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               try {" + PMD.EOL +    "               } catch (Exception e) {" + PMD.EOL +    "                       e.printStackTrace();" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class EmptyTryBlock2 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               try {" + PMD.EOL +    "               } finally {" + PMD.EOL +    "                       int x = 5;" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class EmptyTryBlock3 {" + PMD.EOL +    "       public void foo() {" + PMD.EOL +    "               try {" + PMD.EOL +    "                       int f =2;" + PMD.EOL +    "               } finally {" + PMD.EOL +    "                       int x = 5;" + PMD.EOL +    "               }" + PMD.EOL +    "       }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ReturnFromFinallyBlockTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "ReturnFromFinallyBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "throw exception but return from finally", 1, rule),           new TestDescriptor(TEST2, "lots of returns", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " String bugga() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   throw new Exception( \"My Exception\" );" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   throw e;" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   return \"A. O. K.\"; // Very bad." + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " String getBar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   return \"buz\";" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   return \"biz\";" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   return \"fiddle!\"; // bad!" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "  String getBar() {" + PMD.EOL +    "  try {" + PMD.EOL +    "   return \"buz\";" + PMD.EOL +    "  } finally {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CouplingBetweenObjectsTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("coupling", "CouplingBetweenObjects");        rule.addProperty("threshold", "2");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "lots of coupling", 1, rule),           new TestDescriptor(TEST2, "no coupling", 0, rule),           new TestDescriptor(TEST3, "skip interfaces", 0, rule),       });    }    private static final String TEST1 =    "import java.util.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public List foo() {return null;}" + PMD.EOL +    " public ArrayList foo() {return null;}" + PMD.EOL +    " public Vector foo() {return null;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " public static final int FOO = 2;  " + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedPrivateMethodRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("unusedcode", "UnusedPrivateMethod");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "private method called by public method", 0, rule),           new TestDescriptor(TEST2, "simple unused private method", 1, rule),           new TestDescriptor(TEST3, "anonymous inner class calls private method", 0, rule),           new TestDescriptor(TEST4, "two private methods with same name but different parameters", 1, rule),           new TestDescriptor(TEST5, "calling private method after instantiating new copy of myself", 0, rule),           new TestDescriptor(TEST6, "calling private method using 'this' modifier", 0, rule),           new TestDescriptor(TEST7, "simple unused private static method", 1, rule),           new TestDescriptor(TEST8, "readResolve/writeReplace/etc are OK", 0, rule),           new TestDescriptor(TEST9, "Private methods called only by themselves, BUG 1038229", 1, rule),           new TestDescriptor(TEST10, "private with same name as public, different method signature", 0, rule),           new TestDescriptor(BUG_1114754, "False +, BUG 1114754", 0, rule),           new TestDescriptor(TEST11, "called from constructor", 0, rule),           new TestDescriptor(TEST12, "private method with same name but diff arg count than public method", 0, rule),           // FIXME new TestDescriptor(TEST13, "two methods, one private, one public, same name, same arg count, diff types", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  foo();" + PMD.EOL +    " }" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  new Runnable() {" + PMD.EOL +    "   public void run() {" + PMD.EOL +    "    foo();" + PMD.EOL +    "   }" + PMD.EOL +    "  };" + PMD.EOL +    " }" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    " private void foo(String baz) {}" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  foo();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private void foo(String[] args) {}" + PMD.EOL +    " public static void main(String[] args) {" + PMD.EOL +    "  Foo u = new Foo();" + PMD.EOL +    "  u.foo(args); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  this.foo();" + PMD.EOL +    " }" + PMD.EOL +    " private void foo() {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " private static void foo() {}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " private void readResolve() {}" + PMD.EOL +    " private void writeReplace() {}" + PMD.EOL +    " private void readObject() {}" + PMD.EOL +    " private void writeObject() {}" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " private void bar() {" + PMD.EOL +    "  bar(); " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " public void bar(int x) {" + PMD.EOL +    "  bar(); " + PMD.EOL +    " }" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String BUG_1114754 =    "public class Foo {" + PMD.EOL +    "   public void methodFlagged(Object[] arrayObj) {" + PMD.EOL +    "       for(int i=0; i<arrayObj.length; i++) {" + PMD.EOL +    "           methodFlagged(arrayObj[i]);" + PMD.EOL +    "       }" + PMD.EOL +    "   }" + PMD.EOL +    "   private void methodFlagged(Object a) {" + PMD.EOL +    "       a.toString();" + PMD.EOL +    "   }" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    " public void baz() {" + PMD.EOL +    "  baz(x, y);" + PMD.EOL +    " }" + PMD.EOL +    " private void baz(int x, int y) {}" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    " public void baz() {" + PMD.EOL +    "  foo(\"hi\");" + PMD.EOL +    " }" + PMD.EOL +    " private void foo(String y) {}" + PMD.EOL +    " public void foo(List y) {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DefaultLabelNotLastInSwitchStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "DefaultLabelNotLastInSwitchStmt");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "bad", 1, rule),           new TestDescriptor(TEST3, "ok, no default", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch(x) { " + PMD.EOL +    "  case 1: " + PMD.EOL +    "   break; " + PMD.EOL +    "  default:" + PMD.EOL +    "   break;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch(x) { " + PMD.EOL +    "  case 1: " + PMD.EOL +    "   break; " + PMD.EOL +    "  default:" + PMD.EOL +    "   break;" + PMD.EOL +    "  case 2: " + PMD.EOL +    "   break; " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch(x) { " + PMD.EOL +    "  case 1: " + PMD.EOL +    "   break; " + PMD.EOL +    "  case 2: " + PMD.EOL +    "   break; " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class CloseConnectionTest extends SimpleAggregatorTst  {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "CloseConnection");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "connection is closed, ok", 0, rule),           new TestDescriptor(TEST2, "connection not closed, should have failed", 1, rule),           new TestDescriptor(TEST3, "java.sql.* not imported, ignore", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  Connection c = pool.getConnection();" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  } finally {" + PMD.EOL +    "   c.close();" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "import java.sql.*;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  Connection c = pool.getConnection();" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "import some.pckg.Connection;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  Connection c = pool.getConnection();" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseLocaleWithCaseConversionsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "UseLocaleWithCaseConversions");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "toLowerCase() with no args", 1, rule),           new TestDescriptor(TEST2, "toUpperCase() with no args", 1, rule),           new TestDescriptor(TEST3, "both ok", 0, rule),           new TestDescriptor(TEST4, "toHexString OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " String x = y.toLowerCase();" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " String x = y.toUpperCase();" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " String x = y.toUpperCase(Locale.EN);" + PMD.EOL +    " String z = y.toLowerCase(Locale.EN);" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " String x = y.toHexString().toUpperCase();" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimplifyConditionalTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "SimplifyConditional");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "transpose x and null, still bad", 1, rule),           new TestDescriptor(TEST4, "conditional or and !(instanceof)", 1, rule),           new TestDescriptor(TEST5, "indexing into array is ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar(Object x) {" + PMD.EOL +    "  if (x != null && x instanceof String) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar(Object x) {" + PMD.EOL +    "  if (x instanceof String) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar(Object x) {" + PMD.EOL +    "  if (null != x && x instanceof String) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar(Object x) {" + PMD.EOL +    "  if (x == null || !(x instanceof String)) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void bar(Object x) {" + PMD.EOL +    "  if (x != null && x[0] instanceof String) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryReturnTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "UnnecessaryReturn");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok since method is not void", 0, rule),           new TestDescriptor(TEST3, "ok since return is in sub block", 0, rule),           new TestDescriptor(TEST4, "interface methods don't have return statements", 0, rule),           new TestDescriptor(TEST5, "abstract methods don't have return statements", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int y = 3;" + PMD.EOL +    "  return;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " int bar() {" + PMD.EOL +    "  return 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (false) return;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo {" + PMD.EOL +    " void bar();" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " abstract void bar();" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousHashcodeMethodNameRuleTest  extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "SuspiciousHashcodeMethodName");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0, rule),           new TestDescriptor(TEST2, "hashcode", 1, rule),           new TestDescriptor(TEST3, "HashCode", 1, rule),           new TestDescriptor(TEST4, "Hashcode", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public int hashCode() {return 42;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public int hashcode() {return 42;}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public int HashCode() {return 42;}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public int Hashcode() {return 42;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidReassigningParametersTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("design", "AvoidReassigningParameters");        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "reassigned parameter, bad", 1, rule),           new TestDescriptor(TEST2, "one parameter, not reassigned, good", 0, rule),           new TestDescriptor(TEST3, "instance variable and parameter have same name", 1, rule),           new TestDescriptor(TEST4, "qualified instance variable same name as parameter", 0, rule),           new TestDescriptor(TEST5, "qualified name same as parameter", 0, rule),           new TestDescriptor(TEST6, "assignment to parameter public field", 0, rule),           new TestDescriptor(TEST7, "assignment to array parameter slot", 0, rule),           new TestDescriptor(TEST8, "throws a stacktrace", 1, rule),           new TestDescriptor(TEST9, "postfix increment in array dereference is bad", 1, rule),       });    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo(int bar) {" + PMD.EOL +    "  bar = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo(int bar) {}" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private int bar;" + PMD.EOL +    " void foo(float bar) {" + PMD.EOL +    "  bar = 2.2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST4 =    "public class Foo {" + PMD.EOL +    " private int bar;" + PMD.EOL +    " void foo(float bar) {" + PMD.EOL +    "  this.bar = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST5 =    "public class Faz {" + PMD.EOL +    " private class Foo {" + PMD.EOL +    "  public String bar;" + PMD.EOL +    " }" + PMD.EOL +    " void foo(String bar) {" + PMD.EOL +    "  Foo f = new Foo();" + PMD.EOL +    "  f.bar = bar;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo(Bar bar) {" + PMD.EOL +    "  bar.buz = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo(Bar[] bar) {" + PMD.EOL +    "  bar[0] = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST8 =    "public class Foo {" + PMD.EOL +    " void foo(int x) {" + PMD.EOL +    "   try {" + PMD.EOL +    "     x = 2;" + PMD.EOL +    "   } catch (Throwable t) { " + PMD.EOL +    "   } " + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST9 =    "public class Foo {" + PMD.EOL +    " void foo(int x) {" + PMD.EOL +    "  y[x++] = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedModifierRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "UnusedModifier");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "Unneeded 'public' in interface method", 1, rule),           new TestDescriptor(TEST2, "class, no problem", 0, rule),           new TestDescriptor(TEST3, "Unneeded 'abstract' in interface method", 1, rule),           new TestDescriptor(TEST4, "all is well in interface method", 0, rule),           new TestDescriptor(TEST5, "Unneeded 'public' in interface field", 1, rule),           new TestDescriptor(TEST6, "Unneeded 'static' in interface field", 1, rule),           new TestDescriptor(TEST7, "Unneeded 'final' in interface field", 1, rule),           new TestDescriptor(TEST8, "Unneeded 'public static final' in interface field", 1, rule),           new TestDescriptor(TEST9, "OK in interface field", 0, rule),           new TestDescriptor(TEST10, "Unneeded 'public' in class nested in interface", 1, rule),           new TestDescriptor(TEST11, "Unneeded 'static' in class nested in interface", 1, rule),           new TestDescriptor(TEST12, "OK in class nested in interface", 0, rule),           new TestDescriptor(TEST13, "Unneeded 'public' in interface nested in interface", 1, rule),           new TestDescriptor(TEST14, "Unneeded 'static' in interface nested in interface", 1, rule),           new TestDescriptor(TEST15, "OK in interface nested in interface", 0, rule),           new TestDescriptor(TEST16, "Unneeded 'static' in interface nested in class", 1, rule),           new TestDescriptor(TEST17, "OK in interface nested in class", 0, rule),           new TestDescriptor(TEST18, "Unneeded 'public static final' in interface field inside another interface", 2, rule),           new TestDescriptor(TEST19, "OK in interface field inside another interface", 0, rule),           new TestDescriptor(TEST20, "Don't check methods in nested classes", 0, rule),           new TestDescriptor(TEST21, "Don't check fields in nested classes", 0, rule),           new TestDescriptor(TEST22, "Don't check fields that are anonymous inner classes", 0, rule),       });    }    private static final String TEST1 =    "public interface Foo {" + PMD.EOL +    " public void bar();" + PMD.EOL +    "}";    private static final String TEST2 =    "public abstract class Foo {" + PMD.EOL +    " public abstract void bar();" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " abstract void bar();" + PMD.EOL +    "}";    private static final String TEST4 =    "public interface Foo {" + PMD.EOL +    " void bar();" + PMD.EOL +    "}";    private static final String TEST5 =    "public interface Foo {" + PMD.EOL +    " public int X = 0;" + PMD.EOL +    "}";    private static final String TEST6 =    "public interface Foo {" + PMD.EOL +    " static int X = 0;" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    " final int X = 0;" + PMD.EOL +    "}";    private static final String TEST8 =    "public interface Foo {" + PMD.EOL +    " public static final int X = 0;" + PMD.EOL +    "}";    private static final String TEST9 =    "public interface Foo {" + PMD.EOL +    " int X = 0;" + PMD.EOL +    "}";    private static final String TEST10 =    "public interface Foo {" + PMD.EOL +    " public class Bar {}" + PMD.EOL +    "}";    private static final String TEST11 =    "public interface Foo {" + PMD.EOL +    " static class Bar {}" + PMD.EOL +    "}";    private static final String TEST12 =    "public interface Foo {" + PMD.EOL +    " class Bar {}" + PMD.EOL +    "}";    private static final String TEST13 =    "public interface Foo {" + PMD.EOL +    " public interface Baz {}" + PMD.EOL +    "}";    private static final String TEST14 =    "public interface Foo {" + PMD.EOL +    " static interface Baz {}" + PMD.EOL +    "}";    private static final String TEST15 =    "public interface Foo {" + PMD.EOL +    " interface Baz {}" + PMD.EOL +    "}";    private static final String TEST16 =    "public class Foo {" + PMD.EOL +    " public static interface Bar {}" + PMD.EOL +    "}";    private static final String TEST17 =    "public class Foo {" + PMD.EOL +    " public interface Bar {}" + PMD.EOL +    "}";    private static final String TEST18 =    "public interface Foo {" + PMD.EOL +    " public interface Bar {" + PMD.EOL +    "  public static final int X = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST19 =    "interface Foo {" + PMD.EOL +    " interface Bar {" + PMD.EOL +    "  int X = 0;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST20 =    "interface Foo {" + PMD.EOL +    " class Bar {" + PMD.EOL +    "  public void foo() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST21 =    "interface Foo {" + PMD.EOL +    " class Bar {" + PMD.EOL +    "  public int buz;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST22 =    "interface Foo {" + PMD.EOL +    "   Test DFLT_IMPL = new Test() {" + PMD.EOL +    "   public int size() { return 0;}" + PMD.EOL +    " };" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.MethodNamingConventions;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MethodNamingConventionsTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "method names should start with lowercase character", 1, new MethodNamingConventions()),           new TestDescriptor(TEST2, "method names should not contain underscores", 1, new MethodNamingConventions()),           new TestDescriptor(TEST3, "all is well", 0, new MethodNamingConventions()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void Bar() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar_foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyCatchBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyCatchBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "no catch with nested catch in finally", 1, rule),           new TestDescriptor(TEST4, "multiple catch blocks", 2, rule),           new TestDescriptor(TEST5, "empty try with finally", 0, rule),           new TestDescriptor(TEST6, "InterruptedException is OK", 0, rule),           new TestDescriptor(TEST7, "CloneNotSupportedException is OK", 0, rule),       });    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  try {} catch (RuntimeException e) {e.getMessage();}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} finally { " + PMD.EOL +    "   try {" + PMD.EOL +    "    int x =2;" + PMD.EOL +    "   } catch (Exception e) {}" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "  } catch (Throwable t) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (Exception e) {" + PMD.EOL +    "   ;" + PMD.EOL +    "  } finally {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (InterruptedException e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (CloneNotSupportedException e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class PackageCaseTest extends SimpleAggregatorTst{    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "PackageCase");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "good", 0, rule),       });    }    private static final String TEST1 =    "package foo.BarBuz;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}";    private static final String TEST2 =    "package foo.bar;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NonStaticInitializerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "NonStaticInitializer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "static initializers are OK", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " static {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.IdempotentOperations;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class IdempotentOperationsTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "assignment of a variable (local or field) to itself", 1, new IdempotentOperations()),           new TestDescriptor(TEST2, "assignment of one array element to another", 0, new IdempotentOperations()),           new TestDescriptor(TEST3, "qualified names causing NPE troubleshooting", 0, new IdempotentOperations()),           new TestDescriptor(TEST4, "check for method calls", 0, new IdempotentOperations()),           new TestDescriptor(TEST5, "compound assignments are OK", 0, new IdempotentOperations())       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private void bar() { " + PMD.EOL +    "  x = x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private void bar() { " + PMD.EOL +    "  int[] x = {2,3};" + PMD.EOL +    "  x = x[1];" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    "  void bar() {this.x = foo;}" + PMD.EOL +    "  void buz() {foo = this.x;}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    "  void bar() {x = x();}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    "  void bar() {x += x;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SwitchStmtsShouldHaveDefaultRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "SwitchStmtsShouldHaveDefault");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "simple ok case", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "   default: int j=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.SimplifyBooleanReturns;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimplifyBooleanReturnsTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, new SimplifyBooleanReturns()),           new TestDescriptor(TEST2, "bad", 1, new SimplifyBooleanReturns()),           new TestDescriptor(TEST3, "ok", 0, new SimplifyBooleanReturns()),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void foo() {   " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "   return true;" + PMD.EOL +    "  } else {" + PMD.EOL +    "   return false;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public boolean foo() {        " + PMD.EOL +    "  if (true) " + PMD.EOL +    "   return true;" + PMD.EOL +    "   else " + PMD.EOL +    "  return false;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Object foo() { " + PMD.EOL +    "  if (!true) {" + PMD.EOL +    "   return null;" + PMD.EOL +    "  } else {}" + PMD.EOL +    "  return null;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AbstractNamingTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "AbstractNaming");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok, abstract class AbstractFoo", 0, rule),           new TestDescriptor(TEST2, "bad, abstract class named Foo", 1, rule),           new TestDescriptor(TEST3, "ok, concrete class named AbstractFoo", 0, rule),           new TestDescriptor(TEST4, "ok, concrete class named Foo", 0, rule),       });    }    private static final String TEST1 =    "public abstract class AbstractFoo {}";    private static final String TEST2 =    "public abstract class Foo {}";    private static final String TEST3 =    "public class AbstractFoo {}";    private static final String TEST4 =    "public class Foo {}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryFinalModifierTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "UnnecessaryFinalModifier");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "TEST1", 0, rule),           new TestDescriptor(TEST2, "TEST2", 0, rule),           new TestDescriptor(TEST3, "TEST3", 0, rule),           new TestDescriptor(TEST4, "TEST4", 1, rule),           new TestDescriptor(TEST5, "TEST5", 1, rule),           new TestDescriptor(TEST6, "TEST6", 3, rule),           new TestDescriptor(TEST7, "final method in inner class of non-final outer class", 0, rule),           new TestDescriptor(TEST8, "final method in inner final class ", 1, rule),       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        " public void foo() { }" + PMD.EOL +        "}";        private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public final void foo() { }" + PMD.EOL +        "}";        private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " public final void foo() { }" + PMD.EOL +        " public void foo2() { }" + PMD.EOL +        "}";    private static final String TEST4 =        "public final class Foo {" + PMD.EOL +        " public final void foo() { }" + PMD.EOL +        "}";    private static final String TEST5 =        "public final class Foo {" + PMD.EOL +        " public final void foo() { }" + PMD.EOL +        " public void foo2() { }" + PMD.EOL +        "}";    private static final String TEST6 =        "public final class Foo {" + PMD.EOL +        " public final void fooA() { }" + PMD.EOL +        " public final void fooS() { }" + PMD.EOL +        " public final void fooD() { }" + PMD.EOL +        " public void foo2() { }" + PMD.EOL +        "}";        private static final String TEST7 =        "public final class Foo {" + PMD.EOL +        " public static class Bar {" + PMD.EOL +        "  public final void buz() {}" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST8 =        "public final class Foo {" + PMD.EOL +        " public final class Bar {" + PMD.EOL +        "  public final void buz() {}" + PMD.EOL +        " }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UselessAssignmentRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("rulesets/controversial.xml", "UselessAssignment");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "local variable useless assignment", 1, rule),       });    }    private static final String TEST1 =    "public class Bar {" + PMD.EOL +    " void foo(){" + PMD.EOL +    "  int x = 2; " + PMD.EOL +    "  x = 5; " + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyWhileStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyWhileStmt");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "while(true); ", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "    public void bar() {" + PMD.EOL +    "       while (true == true) {" + PMD.EOL +    "       }" + PMD.EOL +    "       while (true == true) {" + PMD.EOL +    "               String x = \"\";" + PMD.EOL +    "       }" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        "    public void bar() {" + PMD.EOL +        "       while (true) " + PMD.EOL +        "          ; " + PMD.EOL +        "    }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnconditionalIfStatementRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "UnconditionalIfStatement");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "if (true)", 1, rule),           new TestDescriptor(TEST2, "if (false)", 1, rule),           new TestDescriptor(TEST3, "no constant folding", 0, rule),           new TestDescriptor(TEST4, "short circuit operator", 0, rule)       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (true) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (false) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private static final boolean DEBUG = \"false\";" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (DEBUG) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar(Object x, boolean y) {" + PMD.EOL +    "  if (y == true) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyIfStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyIfStmt");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "one empty", 1, rule),           new TestDescriptor(TEST2, "one not empty", 0, rule),           new TestDescriptor(TEST3, "empty statement", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  if (x>2) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  if (x>2) {" + PMD.EOL +    "   x = 1;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  if (x>2);" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnusedImportsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() {        rule = findRule("imports", "UnusedImports");        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple unused single type import", 1, rule),           new TestDescriptor(TEST2, "one used single type import", 0, rule),           new TestDescriptor(TEST3, "2 unused single-type imports", 2, rule),           new TestDescriptor(TEST4, "1 used single type import", 0, rule),           new TestDescriptor(TEST5, "1 import stmt, used only in throws clause", 0, rule),       });    }    public void testForLoop() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST6, rule, rpt);        assertEquals(0, rpt.size());    }    public void testGenerics() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST7, rule, rpt);        assertEquals(0, rpt.size());    }    public void testAnnotations() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST8, rule, rpt);        assertEquals(0, rpt.size());    }    public void testAnnotations2() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST9, rule, rpt);        assertEquals(0, rpt.size());    }    private static final String TEST1 =    "import java.io.File;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import java.io.File;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " private File file;" + PMD.EOL +    "}";    private static final String TEST3 =    "import java.io.File;" + PMD.EOL +    "import java.util.List;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}";    private static final String TEST4 =    "import java.security.AccessController;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  AccessController.doPrivileged(null);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "import java.rmi.RemoteException;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo() throws RemoteException {}" + PMD.EOL +    "}";    private static final String TEST6 =    "import java.util.ArrayList;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " public void foo(ArrayList list) {" + PMD.EOL +    "  for (String s : list) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST7 =    "import foo.TestInterfaceTwo;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    " private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();" + PMD.EOL +    "}";    private static final String TEST8 =    "import foo.annotation.Retention;" + PMD.EOL +    "import foo.annotation.RetentionPolicy;" + PMD.EOL +    "@Retention(RetentionPolicy.RUNTIME)" + PMD.EOL +    "public @interface Foo {" + PMD.EOL +    "}";    private static final String TEST9 =    "import foo.FooAnnotation1;" + PMD.EOL +    "import foo.FooAnnotation2;" + PMD.EOL +    "@FooAnnotation1" + PMD.EOL +    "@FooAnnotation2" + PMD.EOL +    "public class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MissingStaticMethodInNonInstantiatableClassTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "MissingStaticMethodInNonInstantiatableClass");    }        public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "ok", 0, rule),               new TestDescriptor(TEST2, "ok, default constructor", 0, rule),               new TestDescriptor(TEST3, "simple failure", 1, rule),               new TestDescriptor(TEST4, "failure with multiple constructors", 1, rule),               new TestDescriptor(TEST5, "protected constructor is ok", 0, rule),               new TestDescriptor(TEST6, "ok, one static method", 0, rule),               new TestDescriptor(TEST7, "nested class", 0, rule),       });    }        private static final String TEST1 =        "public class Foo {" + PMD.EOL +        "}";        private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " public void bar() {} " + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " private Foo() {}" + PMD.EOL +        " public void bar() {}" + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " private Foo(){}" + PMD.EOL +        " private Foo(Object o){}" + PMD.EOL +        " public void bar() {} " + PMD.EOL +        "}";    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " private Foo(){}" + PMD.EOL +        " protected Foo(Object o){}" + PMD.EOL +        " public void bar() {} " + PMD.EOL +        "}";    private static final String TEST6 =        "public class Foo {" + PMD.EOL +        " private Foo(){}" + PMD.EOL +        " private Foo(Object o){}" + PMD.EOL +        " public static void bar() {} " + PMD.EOL +        "}";    private static final String TEST7 =        "public class Foo {" + PMD.EOL +        " private static class Bar {" + PMD.EOL +        "  private Bar() {}" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidNonConstructorMethodsWithClassNameTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "AvoidNonConstructorMethodsWithClassName");    }        public void testAll() {    runTests(new TestDescriptor[] {    new TestDescriptor(TEST1, "TEST1", 1, rule),new TestDescriptor(TEST2, "TEST2", 1, rule),new TestDescriptor(TEST3, "TEST3", 2, rule),new TestDescriptor(TEST4, "TEST4", 1, rule),    });    }        private static final String TEST1 =    "public class Foo {" + PMD.EOL +"   public int Foo() {}" + PMD.EOL +"} ";        private static final String TEST2 =    "public class Foo {" + PMD.EOL +"   public Foo() {}" + PMD.EOL +"   public int Foo(Object o) {}" + PMD.EOL +"} ";        private static final String TEST3 =    "public class Foo {" + PMD.EOL +"   public Foo() {}" + PMD.EOL +"   public int Foo(Object o) {}" + PMD.EOL +"   public int Foo(Object o, Object o1) {}" + PMD.EOL +"} ";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +"   public Foo() {}" + PMD.EOL +"   class Bar{" +"void Bar(){}" +"   }" + PMD.EOL +"} ";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DoubleCheckedLockingTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "DoubleCheckedLocking");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple ok", 0, rule),           new TestDescriptor(TEST2, "simple failure", 1, rule),           new TestDescriptor(TEST3, "skip interfaces", 0, rule),       });    }    public void testGenerics() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST4, rule, rpt);        assertEquals(0, rpt.size());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public void foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "      Object baz;" + PMD.EOL +    "      Object bar() {" + PMD.EOL +    "        if(baz == null) { //baz may be non-null yet not fully created" + PMD.EOL +    "          synchronized(this){" + PMD.EOL +    "            if(baz == null){" + PMD.EOL +    "              baz = new Object();" + PMD.EOL +    "            }" + PMD.EOL +    "          }" + PMD.EOL +    "        }" + PMD.EOL +    "        return baz;" + PMD.EOL +    "      }" + PMD.EOL +    "}";    private static final String TEST3 =    "public interface Foo {" + PMD.EOL +    " void foo();" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public <T> Bar<T> foo() { /* blah */}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidFieldNameMatchingMethodNameTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "AvoidFieldNameMatchingMethodName");    }        public void testAll() {    runTests(new TestDescriptor[] {    new TestDescriptor(TEST1, "TEST1", 1, rule),new TestDescriptor(TEST2, "TEST2", 1, rule),new TestDescriptor(TEST3, "TEST3", 0, rule),new TestDescriptor(TEST4, "TEST4", 0, rule),new TestDescriptor(TEST5, "Just skip interfaces", 0, rule),    });    }        private static final String TEST1 =    "public class Foo {" + PMD.EOL +"   int bar;" + PMD.EOL +"   void bar() {}" + PMD.EOL +"} ";        private static final String TEST2 =    "public class Bar {" + PMD.EOL +"   class Dummy {" + PMD.EOL +"Foo foo;" + PMD.EOL +"void foo() {}" + PMD.EOL +"   }" + PMD.EOL +"} ";    private static final String TEST3 =    "public class Bar {" + PMD.EOL +"   Foo foo;" + PMD.EOL +"   class Dummy {" + PMD.EOL +"void foo() {}" + PMD.EOL +"   }" + PMD.EOL +"} ";    private static final String TEST4 =    "public class Bar {" + PMD.EOL +"void foo() {}" + PMD.EOL +"   class Dummy {" + PMD.EOL +"      Foo foo;" + PMD.EOL +"   }" + PMD.EOL +"} ";    private static final String TEST5 =    "public interface Bar {" + PMD.EOL +"  public static final int FOO = 5;" + PMD.EOL +"} ";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryTemporariesTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws Exception {        rule = findRule("basic", "UnnecessaryConversionTemporary");        rule.setMessage("Avoid this stuff -> ''{0}''");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "all glommed together", 6, rule),       });    }    private static final String TEST1 =    " public class Foo {" + PMD.EOL +    "     void method (int x) {" + PMD.EOL +    "        new Integer(x).toString(); " + PMD.EOL +    "        new Long(x).toString(); " + PMD.EOL +    "        new Float(x).toString(); " + PMD.EOL +    "        new Byte((byte)x).toString(); " + PMD.EOL +    "        new Double(x).toString(); " + PMD.EOL +    "        new Short((short)x).toString(); " + PMD.EOL +    "     }" + PMD.EOL +    " }";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SimplifyBooleanExpressionsRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "SimplifyBooleanExpressions");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "in field assignment", 1, rule),           new TestDescriptor(TEST2, "in method body", 1, rule),           new TestDescriptor(TEST3, "ok", 0, rule),           new TestDescriptor(TEST4, "two cases in an && expression", 2, rule),           new TestDescriptor(TEST5, "simple use of BooleanLiteral, should not be flagged", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private boolean foo = (isFoo() == true);" + PMD.EOL +    " boolean isFoo() {return foo;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  boolean bar = (new String().length() >2) == false;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " boolean bar = true;" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (getFoo() == false && isBar() == true) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  if (true) {}" + PMD.EOL +    "  if (false) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SingularFieldRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "SingularField");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "failure case", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),           new TestDescriptor(TEST3, "second method uses 'this'", 0, rule),           new TestDescriptor(TEST4, "skip publics", 0, rule),           new TestDescriptor(TEST5, "skip statics", 0, rule),           new TestDescriptor(TEST6, "unused fields shouldn't show up", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " int bar(int y) {" + PMD.EOL +    "  x = y + 5; " + PMD.EOL +    "  return x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void setX(int x) {" + PMD.EOL +    "  this.x = x;" + PMD.EOL +    " }" + PMD.EOL +    " int getX() {" + PMD.EOL +    "  return x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " private int x;" + PMD.EOL +    " void setX(int x) {" + PMD.EOL +    "  this.x = x;" + PMD.EOL +    " }" + PMD.EOL +    " int getX() {" + PMD.EOL +    "  return this.x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public int x;" + PMD.EOL +    " int bar(int y) {" + PMD.EOL +    "  x = y + 5; " + PMD.EOL +    "  return x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " private static int x;" + PMD.EOL +    " int bar(int y) {" + PMD.EOL +    "  x = y + 5; " + PMD.EOL +    "  return x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " int a = 3;" + PMD.EOL +    " int b = 3;" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  foo(b); " + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyFinallyBlockRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptyFinallyBlock");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "empty try/catch/finally", 1, rule),           new TestDescriptor(TEST2, "try/finally, no catch", 1, rule),           new TestDescriptor(TEST3, "finally block with contents", 0, rule),           new TestDescriptor(TEST4, "multiple catch blocks with finally", 1, rule),       });    }    private static final String TEST1 =    "public class EmptyFinallyBlock1 {" + PMD.EOL +    "    public void foo() {" + PMD.EOL +    "       try {" + PMD.EOL +    "       } catch (Exception e) {} finally {}" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class EmptyFinallyBlock2 {" + PMD.EOL +    "    public void foo() {" + PMD.EOL +    "       try {" + PMD.EOL +    "       } finally {}" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class EmptyFinallyBlock3 {" + PMD.EOL +    "    public void foo() {" + PMD.EOL +    "       try {" + PMD.EOL +    "       } finally {int x =2;}" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class EmptyFinallyBlock4 {" + PMD.EOL +    " public void foo() {" + PMD.EOL +    "  try {" + PMD.EOL +    "  } catch (IOException e ){" + PMD.EOL +    "  } catch (Exception e ) {" + PMD.EOL +    "  } catch (Throwable t ) {" + PMD.EOL +    "  } finally{" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UseNotifyAllInsteadOfNotifyTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "UseNotifyAllInsteadOfNotify");    }    public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "TEST1", 1, rule),               new TestDescriptor(TEST2, "TEST2", 2, rule),               new TestDescriptor(TEST3, "TEST3", 1, rule),               new TestDescriptor(TEST4, "TEST4", 1, rule),               new TestDescriptor(TEST5, "TEST5", 1, rule),       });    }    private static final String TEST1 =        "public class Foo {" + PMD.EOL +        " void foo () {" + PMD.EOL +        " foo.notify();" + PMD.EOL +        "}" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +        " void foo () {" + PMD.EOL +        " foo.notify();" + PMD.EOL +        " foo.notify();" + PMD.EOL +        "}" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +        " void foo () {" + PMD.EOL +        " notify();" + PMD.EOL +        "}" + PMD.EOL +        "}";    private static final String TEST4 =        "public class Foo {" + PMD.EOL +        " void foo () {" + PMD.EOL +        " super.notify();" + PMD.EOL +        "}" + PMD.EOL +        "}";    private static final String TEST5 =        "public class Foo {" + PMD.EOL +        " void foo () {" + PMD.EOL +        " new Object().notify();" + PMD.EOL +        "}" + PMD.EOL +        "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.rules.AvoidDeeplyNestedIfStmtsRule;import test.net.sourceforge.pmd.testframework.RuleTst;public class AvoidDeeplyNestedIfStmtsRuleTest extends RuleTst {    public static final String TEST1 =    "public class AvoidDeeplyNestedIfStmtsRule1 {" + PMD.EOL +    " public void bar() { " + PMD.EOL +    "  int x=2; " + PMD.EOL +    "  int y=3; " + PMD.EOL +    "  int z=4; " + PMD.EOL +    "  if (x>y) { " + PMD.EOL +    "   if (y>z) { " + PMD.EOL +    "    if (z==x) { " + PMD.EOL +    "     // this is officially out of control now " + PMD.EOL +    "    } " + PMD.EOL +    "   } " + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class AvoidDeeplyNestedIfStmtsRule2 {" + PMD.EOL +    " public void bar() { " + PMD.EOL +    "  if (true) {" + PMD.EOL +    "  } else if (true) {" + PMD.EOL +    "  } else if (true) {" + PMD.EOL +    "  } else {" + PMD.EOL +    "    // this ain't good code, but it shouldn't trigger this rule" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private Rule rule;    public void setUp() {        rule = new AvoidDeeplyNestedIfStmtsRule();        rule.addProperty("problemDepth", "3");    }    public void test1() throws Throwable {        runTestFromString(TEST1, 1, rule);    }    public void test2() throws Throwable {        runTestFromString(TEST2, 0, rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptySwitchStmtRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("basic", "EmptySwitchStatements");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "bad", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class EmptySwitchStmt1 {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class EmptySwitchStmt2 {" + PMD.EOL +    " public void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=4;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ImportFromSamePackageRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("imports", "ImportFromSamePackage");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, rule),           new TestDescriptor(TEST2, "class in default package importing from sub package", 0, rule),           new TestDescriptor(TEST3, "class in default package importing from other package", 0, rule),           new TestDescriptor(TEST4, "class not in default package importing from default package", 0, rule),           new TestDescriptor(TEST5, "class in default package importing from default package", 1, rule),           new TestDescriptor(TEST6, "importing from subpackage", 0, rule),           new TestDescriptor(TEST7, "importing all from same package", 1, rule),       });    }    private static final String TEST1 =    "package foo;" + PMD.EOL +    "import foo.Bar;" + PMD.EOL +    "public class Baz{}";    private static final String TEST2 =    "package foo;" + PMD.EOL +    "import foo.buz.Bar;" + PMD.EOL +    "public class Baz{}";    private static final String TEST3 =    "import java.util.*;" + PMD.EOL +    "public class Baz{}";    private static final String TEST4 =    "package bar;" + PMD.EOL +    "import Foo;" + PMD.EOL +    "public class Baz{}";    private static final String TEST5 =    "import Foo;" + PMD.EOL +    "public class Baz{}";    private static final String TEST6 =    "package foo.bar;" + PMD.EOL +    "import foo.bar.baz.*;" + PMD.EOL +    "public class Baz{}";    private static final String TEST7 =    "package foo.bar;" + PMD.EOL +    "import foo.bar.*;" + PMD.EOL +    "public class Baz{}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class DontImportJavaLangRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("imports", "DontImportJavaLang");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "import java.lang.String", 1, rule),           new TestDescriptor(TEST2, "import java.lang.*", 1, rule),           new TestDescriptor(TEST3, "import java.lang.ref/reflect/annotation/instrument/management", 0, rule),       });    }    private static final String TEST1 =    "import java.lang.String;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import java.lang.*;" + PMD.EOL +    "public class Foo {}";    private static final String TEST3 =    "import java.lang.ref.*;" + PMD.EOL +    "import java.lang.reflect.*;" + PMD.EOL +    "import java.lang.annotation.*;" + PMD.EOL +    "import java.lang.instrument.*;" + PMD.EOL +    "import java.lang.management.*;" + PMD.EOL +    "public class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AvoidFieldNameMatchingTypeNameTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("naming", "AvoidFieldNameMatchingTypeName");    }    public void testAll() {    runTests(new TestDescriptor[] {    new TestDescriptor(TEST1, "TEST1", 1, rule),new TestDescriptor(TEST2, "TEST2", 1, rule),new TestDescriptor(TEST3, "TEST3", 0, rule),new TestDescriptor(TEST4, "TEST4", 1, rule),    });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +"   int foo;" + PMD.EOL +"} ";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +"   String foo;" + PMD.EOL +"} ";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +"   class Bar {" + PMD.EOL +"Foo foo;" + PMD.EOL +"   }" + PMD.EOL +"} ";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +"   class Bar {" + PMD.EOL +"String bar;" + PMD.EOL +"   }" + PMD.EOL +"} ";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AtLeastOneConstructorRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "AtLeastOneConstructor");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok", 0,rule),           new TestDescriptor(TEST2, "simple failure case", 1, rule),           new TestDescriptor(TEST3, "inner bad, outer ok", 1, rule),           new TestDescriptor(TEST4, "inner ok, outer bad", 1, rule),           new TestDescriptor(TEST5, "inner and outer both bad", 2, rule),           new TestDescriptor(TEST6, "inner and outer both ok", 0, rule),           new TestDescriptor(TEST7, "skip interfaces", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public class Bar {}" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public class Bar { " + PMD.EOL +    "  public Bar() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public class Bar {} " + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public class Bar { " + PMD.EOL +    "  public Bar() {}" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public interface Foo {" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class EmptyFinalizerRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("finalizers", "EmptyFinalizer");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void finalize() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void finalize() { int x = 2;}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class UnnecessaryConstructorTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("controversial", "UnnecessaryConstructor");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "simple failure case", 1, rule),           new TestDescriptor(TEST2, "private constructor", 0, rule),           new TestDescriptor(TEST3, "constructor with arguments", 0, rule),           new TestDescriptor(TEST4, "constructor with contents", 0, rule),           new TestDescriptor(TEST5, "constructor throws exception", 0, rule),           new TestDescriptor(TEST6, "two constructors", 0, rule),           new TestDescriptor(TEST7, "inner class with unnecessary constructor", 1, rule),           new TestDescriptor(TEST8, "inner and outer both have unnecessary constructors", 2, rule),           new TestDescriptor(TEST9, "inner and outer, both ok", 0, rule),           new TestDescriptor(TEST10, "inner ok, outer bad", 1, rule),           new TestDescriptor(TEST11, "inner ok due to nonpublic constructor", 0, rule),           new TestDescriptor(TEST12, "constructor calls super", 0, rule),           new TestDescriptor(TEST13, "constructor calls super, no args", 1, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " private Foo() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Foo(int x) {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public Foo() {  " + PMD.EOL +    "  int x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public Foo() throws IOException {  " + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    " }" + PMD.EOL +    " public Foo(String foo) {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    "  public Inner() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    "  public Inner() {}" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST10 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    " }" + PMD.EOL +    " public Foo() {}" + PMD.EOL +    "}";    private static final String TEST11 =    "public class Foo {" + PMD.EOL +    " public class Inner {" + PMD.EOL +    "  private Inner() {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST12 =    "public class Foo {" + PMD.EOL +    "  public Foo() {super(7);}" + PMD.EOL +    "}";    private static final String TEST13 =    "public class Foo {" + PMD.EOL +    "  public Foo() {super();}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class AccessorClassGenerationTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "AccessorClassGeneration");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "inner class has private constructor", 1, rule),           new TestDescriptor(TEST2, "inner class has public constructor", 0, rule),           new TestDescriptor(TEST3, "outer class has public constructor", 1, rule),           new TestDescriptor(TEST4, "final inner class", 0, rule),       });    }    private static final String TEST1 =    "public class Foo1 {" + PMD.EOL +    " public class InnerClass {" + PMD.EOL +    "   private InnerClass(){" + PMD.EOL +    "   }" + PMD.EOL +    " }" + PMD.EOL +    " void method(){" + PMD.EOL +    "   new InnerClass();//Causes generation of accessor" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo2 {" + PMD.EOL +    " public class InnerClass {" + PMD.EOL +    "   public InnerClass(){" + PMD.EOL +    "   }" + PMD.EOL +    " }" + PMD.EOL +    " void method(){" + PMD.EOL +    "   new InnerClass(); //OK, due to public constructor" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo3 {" + PMD.EOL +    "    public class InnerClass {" + PMD.EOL +    "      void method(){" + PMD.EOL +    "        new Foo3();//Causes generation of accessor" + PMD.EOL +    "      }" + PMD.EOL +    "    }" + PMD.EOL +    "    private Foo3() {" + PMD.EOL +    "    }" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void method() {" + PMD.EOL +    "   final class Inner {}; " + PMD.EOL +    "   Inner i = new Inner();" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.rules.SuspiciousOctalEscape;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class SuspiciousOctalEscapeTest extends SimpleAggregatorTst {    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "ok use of octal", 0, new SuspiciousOctalEscape()),           new TestDescriptor(TEST2, "should be flagged", 1, new SuspiciousOctalEscape()),       });    }   private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = \128;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  System.out.println(\"foo = \\128\");" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class MissingBreakInSwitchTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "MissingBreakInSwitch");    }        public void testAll() {       runTests(new TestDescriptor[] {               new TestDescriptor(TEST1, "TEST1", 1, rule),               new TestDescriptor(TEST2, "TEST2", 1, rule),       new TestDescriptor(TEST3, "TEST3", 0, rule),       });    }        private static final String TEST1 =        "public class Foo {" + PMD.EOL +"void main() {" + PMD.EOL +"switch(i) {" + PMD.EOL +"case 1:" + PMD.EOL +"default:" + PMD.EOL +"}" + PMD.EOL +"}" + PMD.EOL +        "}";    private static final String TEST2 =        "public class Foo {" + PMD.EOL +"void main() {" + PMD.EOL +"switch(i) {" + PMD.EOL +"}" + PMD.EOL +"}" + PMD.EOL +        "}";    private static final String TEST3 =        "public class Foo {" + PMD.EOL +"void main() {" + PMD.EOL +"switch(i) {" + PMD.EOL +"case 1:" + PMD.EOL +"case 2:" + PMD.EOL +"break;" + PMD.EOL +"default:" + PMD.EOL +"}" + PMD.EOL +"}" + PMD.EOL +        "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class ConstructorCallsOverridableMethodTest extends SimpleAggregatorTst {private Rule rule;public void setUp() {rule = findRule("design", "ConstructorCallsOverridableMethod");}    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "calling public method from constructor", 1, rule),           new TestDescriptor(TEST2, "calling protected method from constructor", 1, rule),           new TestDescriptor(TEST3, "calling package private method from constructor", 1, rule),           new TestDescriptor(TEST4, "calling private method, ok", 0, rule),           new TestDescriptor(TEST5, "overloaded constructors, calling public method", 1, rule),           new TestDescriptor(TEST6, "calling method on literal bug", 0, rule),           new TestDescriptor(TEST7, "method in anonymous inner class is ok", 0, rule),           new TestDescriptor(TEST8, "bug report 975407", 0, rule),   new TestDescriptor(TEST9, "ignore abstract methods", 0, rule),   //FIXME new TestDescriptor(BUG_985989, "bug report 985989, ", 1, rule),       });    }    public void testGenerics() throws Throwable {        Report rpt = new Report();        runTestFromString15(TEST10, rule, rpt);        assertEquals(0, rpt.size());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " protected void bar() {}" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " void bar() {}" + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String TEST5 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  this(\"Bar\");" + PMD.EOL +    " }" + PMD.EOL +    " private Foo(String bar) {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    "}";    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public Foo(String s) {" + PMD.EOL +    "  \"foo\".equals(s);" + PMD.EOL +    " }" + PMD.EOL +    " public void equals(String bar) {}" + PMD.EOL +    "}";    private static final String TEST7 =    "public class Foo {" + PMD.EOL +    " public Foo(String s) {" + PMD.EOL +    "  addActionListener(new ActionListener() {" + PMD.EOL +    "   public void actionPerformed(ActionEvent e) {bar();}" + PMD.EOL +    "  });" + PMD.EOL +    " }" + PMD.EOL +    " public void bar() {}" + PMD.EOL +    "}";    private static final String TEST8 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String TEST9 =    "public class Foo {" + PMD.EOL +    " public Foo() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    " abstract void bar() {}" + PMD.EOL +    "}";    private static final String TEST10 =    "package foo.bar;" + PMD.EOL +    "public enum Buz {" + PMD.EOL +    " FOO(2);" + PMD.EOL +    " private Buz(String s) {}" + PMD.EOL +    "}";    private static final String BUG_985989 =    "public class Test {" + PMD.EOL +    "public static class SeniorClass {" + PMD.EOL +    "  public SeniorClass(){" + PMD.EOL +    "    toString(); //may throw NullPointerException if overridden" + PMD.EOL +    "  }" + PMD.EOL +    "  public String toString(){" + PMD.EOL +    "    return \"IAmSeniorClass\";" + PMD.EOL +    "  }" + PMD.EOL +    "}" + PMD.EOL +    "public static class JuniorClass extends SeniorClass {" + PMD.EOL +    "  private String name;" + PMD.EOL +    "  public JuniorClass(){" + PMD.EOL +    "    super(); //Automatic call leads to NullPointerException" + PMD.EOL +    "    name = \"JuniorClass\";" + PMD.EOL +    "  }" + PMD.EOL +    "  public String toString(){" + PMD.EOL +    "    return name.toUpperCase();" + PMD.EOL +    "  }" + PMD.EOL +    "}" + PMD.EOL +    "public static void main (String[] args) {" + PMD.EOL +    "  System.out.println(\": \"+new SeniorClass());" + PMD.EOL +    "  System.out.println(\": \"+new JuniorClass());" + PMD.EOL +    "}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.rules;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSetNotFoundException;import test.net.sourceforge.pmd.testframework.SimpleAggregatorTst;import test.net.sourceforge.pmd.testframework.TestDescriptor;public class NonCaseLabelInSwitchStatementRuleTest extends SimpleAggregatorTst {    private Rule rule;    public void setUp() throws RuleSetNotFoundException {        rule = findRule("design", "NonCaseLabelInSwitchStatement");    }    public void testAll() {       runTests(new TestDescriptor[] {           new TestDescriptor(TEST1, "label inside switch", 1, rule),           new TestDescriptor(TEST2, "ok", 0, rule),       });    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "    break;" + PMD.EOL +    "   somelabel: " + PMD.EOL +    "    break;" + PMD.EOL +    "   default: " + PMD.EOL +    "    int j=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 2: int y=8;" + PMD.EOL +    "    break;" + PMD.EOL +    "   default: " + PMD.EOL +    "    int j=8;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.CPPTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;public class CPPTokenizerTest extends TestCase{    public void testMultiLineMacros() throws Throwable {        CPPTokenizer tokenizer = new CPPTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(TEST1));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        assertEquals(7, tokens.size());    }    private static final String TEST1 =    "#define FOO a +\\" + PMD.EOL +    "            b +\\" + PMD.EOL +    "            c +\\" + PMD.EOL +    "            d +\\" + PMD.EOL +    "            e +\\" + PMD.EOL +    "            f +\\" + PMD.EOL +    "            g"  + PMD.EOL +    " void main() {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.CPPLanguage;import net.sourceforge.pmd.cpd.JavaLanguage;import net.sourceforge.pmd.cpd.LanguageFactory;import net.sourceforge.pmd.cpd.PHPLanguage;public class LanguageFactoryTest extends TestCase {    public void testSimple() {        LanguageFactory f = new LanguageFactory();        assertTrue(f.createLanguage(LanguageFactory.JAVA_KEY) instanceof JavaLanguage);        assertTrue(f.createLanguage(LanguageFactory.CPP_KEY) instanceof CPPLanguage);        assertTrue(f.createLanguage(LanguageFactory.PHP_KEY) instanceof PHPLanguage);        try {            f.createLanguage("fiddlesticks");            throw new RuntimeException("Should have thrown an exception!");        } catch (RuntimeException e) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.TokenEntry;import java.util.Iterator;public class MatchTest extends TestCase  {    public void testSimple() {        TokenEntry mark1 = new TokenEntry("public", "/var/Foo.java", 1);TokenEntry mark2 = new TokenEntry("class", "/var/Foo.java", 1);        Match match = new Match(1, mark1, mark2);        match.setSourceCodeSlice("public class Foo {}");        assertEquals("public class Foo {}", match.getSourceCodeSlice());        match.setLineCount(10);        assertEquals(10, match.getLineCount());        assertEquals(1, match.getTokenCount());        Iterator i = match.iterator();        assertEquals(mark1, i.next());        assertEquals(mark2, i.next());        assertFalse(i.hasNext());    }    public void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1), new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;public class SourceCodeTest extends TestCase {    public void testSimple() throws Throwable {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(MatchAlgorithmTest.getSampleCode(), "Foo.java"));        assertEquals("Foo.java", sourceCode.getFileName());        tokenizer.tokenize(sourceCode, new Tokens());        assertEquals(MatchAlgorithmTest.LINE_1, sourceCode.getSlice(1,1));        assertEquals(MatchAlgorithmTest.LINE_2, sourceCode.getSlice(2,2));        assertEquals(MatchAlgorithmTest.LINE_1 + PMD.EOL + MatchAlgorithmTest.LINE_2, sourceCode.getSlice(1,2));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;public class JavaTokensTokenizerTest extends TestCase {    public void test1() throws Throwable {        Tokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("public class Foo {}"));        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());        assertEquals("public class Foo {}", sourceCode.getSlice(1, 1));    }    public void test2() throws Throwable {        Tokenizer t = new JavaTokenizer();        String data = "public class Foo {" + PMD.EOL + "public void bar() {}" + PMD.EOL + "public void buz() {}" + PMD.EOL + "}";        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(data));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals("public class Foo {" + PMD.EOL + "public void bar() {}", sourceCode.getSlice(1,2));    }    public void testDiscardSemicolons() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("public class Foo {private int x;}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(9, tokens.size());    }    public void testDiscardImports() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("import java.io.File;" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }    public void testDiscardPkgStmts() throws Throwable {        Tokenizer t = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader("package foo.bar.baz;" + PMD.EOL + "public class Foo {}"));        Tokens tokens = new Tokens();        t.tokenize(sourceCode, tokens);        assertEquals(6, tokens.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.FileReporter;import net.sourceforge.pmd.cpd.ReportException;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;/** * @author  Philippe T'Seyen */public class FileReporterTest extends TestCase{  public void testCreation() {    try {      new FileReporter(null);      fail("expected NullPointerException");    } catch (NullPointerException npe) {    }  }  public void testEmptyReport() throws ReportException {    File reportFile = new File("report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    fileReporter.report("");    assertTrue(reportFile.exists());    assertEquals(0, reportFile.length());    assertTrue(reportFile.delete());  }  public void testReport() throws ReportException, IOException {    String testString = "first line\nsecond line";    File reportFile = new File("report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    fileReporter.report(testString);    assertEquals(testString, readFile(reportFile));    assertTrue(reportFile.delete());  }  public void testInvalidFile() {    File reportFile = new File("/invalid_folder/report.tmp");    FileReporter fileReporter = new FileReporter(reportFile);    try {      fileReporter.report("");      fail("expected ReportException");    } catch (ReportException re) {    }  }  private String readFile(File file) throws IOException {    BufferedReader reader = null;    try {      reader = new BufferedReader(new FileReader(file));      StringBuffer buffer = new StringBuffer();      String line = reader.readLine();      while (line != null) {        buffer.append(line);        line = reader.readLine();        if (line != null) {          buffer.append("\n");        }      }      return buffer.toString();    } finally {      if (reader != null) reader.close();    }  }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.AnyTokenizer;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.Tokens;public class AnyTokenizerTest extends TestCase{    public void testMultiLineMacros() throws Throwable {        AnyTokenizer tokenizer = new AnyTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(TEST1));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        assertEquals(30, tokens.size());    }    private static final String TEST1 =    "using System;" + PMD.EOL +    "namespace HelloNameSpace {" + PMD.EOL +    "" + PMD.EOL +    "    public class HelloWorld {" + PMD.EOL +    "        static void Main(string[] args) {"+ PMD.EOL +    "            Console.WriteLine(\"Hello World!\");" + PMD.EOL +    "        }"+ PMD.EOL +    "    }"+ PMD.EOL +    "}"+ PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.JavaTokenizer;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.MatchAlgorithm;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokens;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class MatchAlgorithmTest extends TestCase {    public static final String LINE_1 = "public class Foo { ";    public static final String LINE_2 = " public void bar() {";    public static final String LINE_3 = "  System.out.println(\"hello\");";    public static final String LINE_4 = "  System.out.println(\"hello\");";    public static final String LINE_5 = "  int i = 5";    public static final String LINE_6 = "  System.out.print(\"hello\");";    public static final String LINE_7 = " }";    public static final String LINE_8 = "}";    public static String getSampleCode() {        return            LINE_1 + PMD.EOL +            LINE_2 + PMD.EOL +            LINE_3 + PMD.EOL +            LINE_4 + PMD.EOL +            LINE_5 + PMD.EOL +            LINE_6 + PMD.EOL +            LINE_7 + PMD.EOL +            LINE_8;    }    public void testSimple() throws Throwable {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(41, tokens.size());        Map codeMap = new HashMap();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator matches = matchAlgorithm.matches();        Match match = (Match)matches.next();        assertFalse(matches.hasNext());        Iterator marks = match.iterator();        TokenEntry mark1 = (TokenEntry)marks.next();        TokenEntry mark2 = (TokenEntry)marks.next();        assertTrue(!marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals(4, mark2.getBeginLine());        assertTrue("Foo.java" == mark1.getTokenSrcID() && "Foo.java" == mark2.getTokenSrcID());        assertEquals(LINE_3, match.getSourceCodeSlice());    }        public void testIgnore() throws Throwable {        JavaTokenizer tokenizer = new JavaTokenizer();        tokenizer.setIgnoreLiterals(true);        tokenizer.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        Map codeMap = new HashMap();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator matches = matchAlgorithm.matches();        Match match = (Match)matches.next();        assertFalse(matches.hasNext());        Iterator marks = match.iterator();        marks.next();        marks.next();        marks.next();        assertTrue(!marks.hasNext());    }}
package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenEntry;public class TokenEntryTest extends TestCase {    public void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.cpd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.Match;import net.sourceforge.pmd.cpd.Renderer;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.XMLRenderer;import java.util.ArrayList;import java.util.List;/** * @author  Philippe T'Seyen */public class XMLRendererTest extends TestCase{  public void testRender_NoMatches()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd></pmd-cpd>", report);  }  public void testRender_Match()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    Match match = new Match(75, new TokenEntry("public", "/var/Foo.java", 48), new TokenEntry("stuff", "/var/Foo.java", 73));    match.setLineCount(6);    match.setSourceCodeSlice("code fragment");    list.add(match);    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd><duplication lines=\"6\" tokens=\"75\"><file line=\"48\" path=\"/var/Foo.java\"/><file line=\"73\" path=\"/var/Foo.java\"/><codefragment><![CDATA[" + PMD.EOL + "code fragment" + PMD.EOL + "]]></codefragment></duplication></pmd-cpd>", report);  }  public void testRender_MultipleMatch()  {    Renderer renderer = new XMLRenderer();    List list = new ArrayList();    Match match1 = new Match(75, new TokenEntry("public", "/var/Foo.java", 48), new TokenEntry("void", "/var/Foo.java", 73));    match1.setLineCount(6);    match1.setSourceCodeSlice("code fragment");    Match match2 = new Match(76, new TokenEntry("void", "/var/Foo2.java", 49), new TokenEntry("stuff", "/var/Foo2.java", 74));    match2.setLineCount(7);    match2.setSourceCodeSlice("code fragment 2");    list.add(match1);    list.add(match2);    String report = renderer.render(list.iterator());    assertEquals("<?xml version=\"1.0\"?><pmd-cpd><duplication lines=\"6\" tokens=\"75\"><file line=\"48\" path=\"/var/Foo.java\"/><file line=\"73\" path=\"/var/Foo.java\"/><codefragment><![CDATA[" + PMD.EOL + "code fragment" + PMD.EOL + "]]></codefragment></duplication><duplication lines=\"7\" tokens=\"76\"><file line=\"49\" path=\"/var/Foo2.java\"/><file line=\"74\" path=\"/var/Foo2.java\"/><codefragment><![CDATA[" + PMD.EOL + "code fragment 2" + PMD.EOL + "]]></codefragment></duplication></pmd-cpd>", report);  }}
package test.net.sourceforge.pmd.dfa;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.dfa.Structure;public class StructureTest extends TestCase {    public void testAddResultsinDFANodeContainingAddedNode() {        Structure s = new Structure();        SimpleNode n = new ASTMethodDeclaration(1);        assertEquals(n, s.createNewNode(n).getSimpleNode());    }}
package test.net.sourceforge.pmd.dfa;import junit.framework.TestCase;import net.sourceforge.pmd.dfa.DataFlowNode;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.NodeType;import net.sourceforge.pmd.dfa.StartOrEndDataFlowNode;import java.util.LinkedList;public class DataFlowNodeTest extends TestCase {    public void testAddPathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList(), 10, false);        IDataFlowNode child = new StartOrEndDataFlowNode(new LinkedList(), 12, false);        parent.addPathToChild(child);        assertEquals(parent.getChildren().size(), 1);        assertTrue(child.getParents().contains(parent));        assertTrue(parent.getChildren().contains(child));    }    public void testRemovePathToChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList(), 10, false);        IDataFlowNode child = new StartOrEndDataFlowNode(new LinkedList(), 12, false);        parent.addPathToChild(child);        assertTrue(parent.removePathToChild(child));        assertTrue(!child.getParents().contains(parent));        assertTrue(!parent.getChildren().contains(child));    }    public void testRemovePathWithNonChild() {        DataFlowNode parent = new StartOrEndDataFlowNode(new LinkedList(), 10, false);        IDataFlowNode child = new StartOrEndDataFlowNode(new LinkedList(), 12, false);        assertFalse(parent.removePathToChild(child));    }    public void testReverseParentPathsTo() {        DataFlowNode parent1 = new StartOrEndDataFlowNode(new LinkedList(), 10, false);        DataFlowNode parent2 = new StartOrEndDataFlowNode(new LinkedList(), 12, false);        IDataFlowNode child1 = new StartOrEndDataFlowNode(new LinkedList(), 13, false);        IDataFlowNode child2 = new StartOrEndDataFlowNode(new LinkedList(), 13, false);        parent1.addPathToChild(child1);        parent2.addPathToChild(child1);        assertTrue(parent1.getChildren().contains(child1));        child1.reverseParentPathsTo(child2);        assertTrue(parent1.getChildren().contains(child2));        assertFalse(parent1.getChildren().contains(child1));        assertTrue(parent2.getChildren().contains(child2));        assertFalse(parent2.getChildren().contains(child1));        assertEquals(0, child1.getParents().size());        assertEquals(2, child2.getParents().size());    }    public void testSetType() {        DataFlowNode node = new StartOrEndDataFlowNode(new LinkedList(), 10, false);        node.setType(NodeType.BREAK_STATEMENT);        assertTrue(node.isType(NodeType.BREAK_STATEMENT));        assertFalse(node.isType(NodeType.CASE_LAST_STATEMENT));    }}
package test.net.sourceforge.pmd.dfa;import junit.framework.TestCase;import net.sourceforge.pmd.dfa.variableaccess.VariableAccess;public class VariableAccessTest extends TestCase {    public void testGetVariableName() {        VariableAccess va = new VariableAccess(VariableAccess.DEFINITION, "foo.bar");        assertEquals("foo", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, ".foobar");        assertEquals("", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar.");        assertEquals("foobar", va.getVariableName());        va = new VariableAccess(VariableAccess.DEFINITION, "foobar");        assertEquals("foobar", va.getVariableName());    }}
package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.pathfinder.DAAPathFinder;import net.sourceforge.pmd.dfa.pathfinder.Executable;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.List;public class DAAPathFinderTest extends ParserTst implements Executable {    public void testTwoUpdateDefs() throws Throwable {        ASTMethodDeclarator meth = (ASTMethodDeclarator)getOrderedNodes(ASTMethodDeclarator.class, TWO_UPDATE_DEFS).get(0);        DAAPathFinder a = new DAAPathFinder((IDataFlowNode)meth.getDataFlowNode().getFlow().get(0), this);//        a.run();    }    public void execute(List path) {}    private static final String TWO_UPDATE_DEFS =    "class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  for (int i=0; i<10; i++, j--) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.ast.ASTExpression;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTStatementExpression;import net.sourceforge.pmd.ast.ASTVariableDeclarator;import net.sourceforge.pmd.dfa.DataFlowNode;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.NodeType;import net.sourceforge.pmd.dfa.StatementAndBraceFinder;import test.net.sourceforge.pmd.testframework.ParserTst;public class StatementAndBraceFinderTest extends ParserTst {    public void testStatementExpressionParentChildLinks() throws Throwable {        ASTStatementExpression se = (ASTStatementExpression)getOrderedNodes(ASTStatementExpression.class, TEST1).get(0);        ASTMethodDeclaration seParent = (ASTMethodDeclaration)((DataFlowNode)se.getDataFlowNode().getParents().get(0)).getSimpleNode();        assertEquals(se, ((IDataFlowNode)seParent.getDataFlowNode().getChildren().get(0)).getSimpleNode());        assertEquals(seParent, ((IDataFlowNode)se.getDataFlowNode().getParents().get(0)).getSimpleNode());    }    public void testVariableDeclaratorParentChildLinks() throws Throwable {        ASTVariableDeclarator vd = (ASTVariableDeclarator)getOrderedNodes(ASTVariableDeclarator.class, TEST2).get(0);        ASTMethodDeclaration vdParent = (ASTMethodDeclaration)((DataFlowNode)vd.getDataFlowNode().getParents().get(0)).getSimpleNode();        assertEquals(vd, ((IDataFlowNode)vdParent.getDataFlowNode().getChildren().get(0)).getSimpleNode());        assertEquals(vdParent, ((IDataFlowNode)vd.getDataFlowNode().getParents().get(0)).getSimpleNode());    }    public void testIfStmtHasCorrectTypes() throws Throwable {        ASTExpression exp = (ASTExpression)getOrderedNodes(ASTExpression.class, TEST3).get(0);        IDataFlowNode dfn = (IDataFlowNode)exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.IF_EXPR));        assertTrue(dfn.isType(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE));    }    public void testWhileStmtHasCorrectTypes() throws Throwable {        ASTExpression exp = (ASTExpression)getOrderedNodes(ASTExpression.class, TEST4).get(0);        IDataFlowNode dfn = (IDataFlowNode)exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.WHILE_EXPR));        assertTrue(dfn.isType(NodeType.WHILE_LAST_STATEMENT));    }    public void testForStmtHasCorrectTypes() throws Throwable {        ASTExpression exp = (ASTExpression)getOrderedNodes(ASTExpression.class, TEST5).get(0);        IDataFlowNode dfn = (IDataFlowNode)exp.getDataFlowNode().getFlow().get(2);        assertTrue(dfn.isType(NodeType.FOR_INIT));        dfn = (IDataFlowNode)exp.getDataFlowNode().getFlow().get(3);        assertTrue(dfn.isType(NodeType.FOR_EXPR));        dfn = (IDataFlowNode)exp.getDataFlowNode().getFlow().get(4);        assertTrue(dfn.isType(NodeType.FOR_UPDATE));        assertTrue(dfn.isType(NodeType.FOR_BEFORE_FIRST_STATEMENT));        assertTrue(dfn.isType(NodeType.FOR_END));    }    public void testOnlyWorksForMethodsAndConstructors() {        StatementAndBraceFinder sbf = new StatementAndBraceFinder();        try {            sbf.buildDataFlowFor(new ASTCompilationUnit(1));            fail("Should have failed!");        } catch (RuntimeException e) {            // cool        }        sbf.buildDataFlowFor(new ASTMethodDeclaration(1));        sbf.buildDataFlowFor(new ASTConstructorDeclaration(1));    }    private static final String TEST1 =        "class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  x = 2;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST2 =        "class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  int x;" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST3 =        "class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  if (x) {}" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST4 =        "class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  while (x) {}" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final String TEST5 =        "class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  for (int i=0; i<10; i++) {}" + PMD.EOL +        " }" + PMD.EOL +        "}";}
package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.DataFlowNode;import net.sourceforge.pmd.dfa.IDataFlowNode;import net.sourceforge.pmd.dfa.variableaccess.VariableAccess;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.List;public class GeneralFiddlingTest extends ParserTst {    public void test1() throws Throwable {        ASTCompilationUnit acu = buildDFA(TEST1);        ASTMethodDeclarator meth = (ASTMethodDeclarator)acu.findChildrenOfType(ASTMethodDeclarator.class).get(0);        IDataFlowNode n = meth.getDataFlowNode();        List f = n.getFlow();        for (Iterator i = f.iterator(); i.hasNext();) {            DataFlowNode dfan = (DataFlowNode)i.next();            System.out.println(dfan);            List va = dfan.getVariableAccess();            for (Iterator j = va.iterator(); j.hasNext();) {                VariableAccess o = (VariableAccess)j.next();                System.out.println(o);            }        }    }    private static final String TEST1 =        "class Foo {" + PMD.EOL +        " void bar() {" + PMD.EOL +        "  int x = 2;" + PMD.EOL +        "  foo(x);" + PMD.EOL +        "  x = 3;" + PMD.EOL +        " }"  + PMD.EOL +        "}";}
/* * Created on 18.08.2004 */package test.net.sourceforge.pmd.dfa;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import net.sourceforge.pmd.dfa.IDataFlowNode;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.List;public class AcceptanceTest extends ParserTst {    public void testbook() throws Throwable {        getOrderedNodes(ASTMethodDeclarator.class, FOO);    }    private static final String FOO =    "class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public void testLabelledBreakLockup() throws Throwable {        getOrderedNodes(ASTMethodDeclarator.class, LABELLED_BREAK_LOCKUP);    }    private static final String LABELLED_BREAK_LOCKUP =    "class Foo {" + PMD.EOL +    " void bar(int x) {" + PMD.EOL +    "  here: if (x>2) {" + PMD.EOL +    "   break here;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private boolean check(int[][] array, List methodNodes) {        for (int i=0; i<methodNodes.size(); i++) {            ASTMethodDeclarator decl = (ASTMethodDeclarator)methodNodes.get(i);            IDataFlowNode inode = decl.getDataFlowNode();            for (int j = 0; j < inode.getChildren().size(); j++) {                IDataFlowNode child = (IDataFlowNode) inode.getChildren().get(j);                if (array[i][j] != child.getIndex()-1) {                    return false;                }            }        }        return true;    }    public void test_1() throws Throwable {        assertTrue(check(TEST1_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST1)));    }    public void test_2() throws Throwable {        assertTrue(check(TEST2_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST2)));    }    public void test_3() throws Throwable {        assertTrue(check(TEST3_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST3)));    }    public void test_4() throws Throwable {        assertTrue(check(TEST4_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST4)));    }    public void test_6() throws Throwable {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST6)));    }    public void test_7() throws Throwable {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST7)));    }    public void test_8() throws Throwable {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST8)));    }    public void test_9() throws Throwable {        assertTrue(check(TEST5_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST9)));    }    public void test_10() throws Throwable {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST10)));    }    public void test_11() throws Throwable {        assertTrue(check(TEST8_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST11)));    }    public void test_12() throws Throwable {        assertTrue(check(TEST12_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST12)));    }    public void test_13() throws Throwable {        assertTrue(check(TEST13_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST13)));    }    public void test_14() throws Throwable {        assertTrue(check(TEST14_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST14)));    }    public void test_15() throws Throwable {        assertTrue(check(TEST15_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST15)));    }    public void test_16() throws Throwable {        assertTrue(check(TEST16_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST16)));    }    public void test_17() throws Throwable {        assertTrue(check(TEST17_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST17)));    }    public void test_18() throws Throwable {        assertTrue(check(TEST18_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST18)));    }    public void test_19() throws Throwable {        assertTrue(check(TEST19_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST19)));    }    public void test_20() throws Throwable {        assertTrue(check(TEST20_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST20)));    }    public void test_21() throws Throwable {        assertTrue(check(TEST21_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST21)));    }    public void test_22() throws Throwable {        assertTrue(check(TEST22_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST22)));    }    public void test_23() throws Throwable {        assertTrue(check(TEST23_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST23)));    }    public void test_24() throws Throwable {        assertTrue(check(TEST24_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST24)));    }    public void test_25() throws Throwable {        assertTrue(check(TEST25_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST25)));    }    public void test_26() throws Throwable {        assertTrue(check(TEST26_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST26)));    }    public void test_27() throws Throwable {        assertTrue(check(TEST27_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST27)));    }    public void test_28() throws Throwable {        assertTrue(check(TEST28_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST28)));    }    public void test_29() throws Throwable {        assertTrue(check(TEST29_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST29)));    }    public void test_30() throws Throwable {        assertTrue(check(TEST30_NODES, getOrderedNodes(ASTMethodDeclarator.class, TEST30)));    }    //  first dimension: the index of a node    //  second dimension: the indices of the children    private static final int[][] TEST1_NODES = {            {1},            {2},            {3},            {4, 6},            {5},            {6},            {}        };    private static final String TEST1 =        "class Foo {" + PMD.EOL +        " void test_1() {" + PMD.EOL +        "  int x = 0;" + PMD.EOL +        "  if (x == 0) {" + PMD.EOL +        "   x++;" + PMD.EOL +        "   x = 0;" + PMD.EOL +        "  }" + PMD.EOL +        " }"  + PMD.EOL +        " }";    private static final int[][] TEST2_NODES = {            {1},            {2},            {3},            {5, 7},            {3},            {6},            {4},            {}        };    private static final String TEST2 =            "class Foo {" + PMD.EOL +            " public void test_2() {" + PMD.EOL +            "  for (int i = 0; i < 1; i++) {" + PMD.EOL +            "   i++;" + PMD.EOL +            "   i = 8;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST3_NODES = {            {1},            {2},            {3},            {4, 5},            {3},            {}        };        private static final String TEST3 =            "public class Foo {" + PMD.EOL +            " public void test_3() {" + PMD.EOL +            "  for (int i = 0; i < 1; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST4_NODES =  {            {1},            {2},            {3},            {}        };    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " public void test_4() {" + PMD.EOL +    "  for (; ;) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    " }";    private static final int[][] TEST5_NODES =  {            {1},            {2},            {3},            {4},            {}        };    private static final String TEST6 =    "public class Foo {" + PMD.EOL +    " public void test_6() {" + PMD.EOL +    "  for (int i = 0; ;) {" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    " }";    private static final String TEST7 =            "public class Foo {" + PMD.EOL +            " public void test_7() {" + PMD.EOL +            "  for (int i = 0; i < 0;) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST8_NODES = {            {1},            {2},            {3},            {4, 5},            {3},            {}        };    public static final String TEST8 =        "public class Foo {" + PMD.EOL +        " public void test_8() {" + PMD.EOL +        "  for (int i = 0; ; i++) {" + PMD.EOL +        "  }" + PMD.EOL +        " }" + PMD.EOL +            " }";    public static final String TEST9 =        "public class Foo {" + PMD.EOL +            " public void test_9() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  for (; i < 0;) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    public static final String TEST10 =        "public class Foo {" + PMD.EOL +            " public void test_10() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  for (; i < 0; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    public static final String TEST11 =        "public class Foo {" + PMD.EOL +            " public void test_11() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  for (; ; i++) {" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST12_NODES = {            {1},            {2},            {3},            {4, 5},            {3},            {}        };    public static final String TEST12 =        "public class Foo {" + PMD.EOL +            " public void test_12() {" + PMD.EOL +            "  for (; ;) {" + PMD.EOL +            "   int i = 0;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST13_NODES = {        {1},        {2},        {3},        {5, 9},        {3},        {6},        {7, 8},        {8},        {4},        {}        };    public static final String TEST13 =        "public class Foo {" + PMD.EOL +            " public void test_13() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   i = 9;" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   }" + PMD.EOL +            "   i = 6;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST14_NODES = {        {1},        {2},        {3},        {5, 8},        {3},        {6},        {7, 4},        {4},        {}        };    public static final String TEST14 =        "public class Foo {" + PMD.EOL +            " public void test_14() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   i = 9;" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST15_NODES = {        {1},        {2},        {3},        {5, 7},        {3},        {6, 4},        {4},        {}        };    public static final String TEST15 =        "public class Foo {" + PMD.EOL +            " public void test_15() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST16_NODES = {        {1},        {2},        {3},        {5, 8},        {3},        {6, 7},        {4},        {4},        {}        };    public static final String TEST16 =        "public class Foo {" + PMD.EOL +            " public void test_16() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   if (i < 8) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   } else {" + PMD.EOL +            "    i = 6;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST17_NODES = {        {1},        {2},        {3},        {5, 10},        {3},        {6, 7},        {4},        {8, 9},        {4},        {4},        {}        };    public static final String TEST17 =        "public class Foo {" + PMD.EOL +            " public void test_17() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   if (i < 6) {" + PMD.EOL +            "    i = 7;" + PMD.EOL +            "   } else if (i > 8) {" + PMD.EOL +            "    i = 9;" + PMD.EOL +            "   } else {" + PMD.EOL +            "    i = 10;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST18_NODES = {        {1},        {2},        {3},        {5, 9},        {3},        {6},        {8, 4},        {6},        {7},        {}        };    public static final String TEST18 =        "public class Foo {" + PMD.EOL +            " public void test_18() {" + PMD.EOL +            "  for (int i = 0; i < 0; i++) {" + PMD.EOL +            "   for (int j = 0; j < 0; j++) {" + PMD.EOL +            "    j++;" + PMD.EOL +            "   }" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST19_NODES = {        {1},        {2},        {3},        {4, 5},        {10},        {6, 7},        {10},        {8, 9},        {10},        {10},        {}        };    public static final String TEST19 =        "public class Foo {" + PMD.EOL +            " public void test_19() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   i = 2;" + PMD.EOL +            "  } else if (i == 3) {" + PMD.EOL +            "   i = 4;" + PMD.EOL +            "  } else if (i == 5) {" + PMD.EOL +            "   i = 6;" + PMD.EOL +            "  } else {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST20_NODES = {        {1},        {2},        {3},        {4, 6},        {5, 7},        {7},        {7},        {}        };    public static final String TEST20 =        "public class Foo {" + PMD.EOL +            " public void test_20() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   if (i == 2) {" + PMD.EOL +            "    i = 3;" + PMD.EOL +            "   }" + PMD.EOL +            "  } else {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST21_NODES = {        {1},        {2},        {3},        {4, 9},        {5},        {7, 8},        {5},        {6},        {11},        {10, 11},        {11},        {}        };    public static final String TEST21 =        "public class Foo {" + PMD.EOL +            " public void test_21() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   for (i = 3; i < 4; i++) {" + PMD.EOL +            "    i = 5;" + PMD.EOL +            "   }" + PMD.EOL +            "   i++;" + PMD.EOL +            "  } else if (i < 6) {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST22_NODES = {        {1},        {2},        {3},        {4, 8},        {5},        {7, 9},        {5},        {6},        {9},        {}        };    public static final String TEST22 =        "public class Foo {" + PMD.EOL +            " public void test_22() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   for (i = 3; i < 4; i++) {" + PMD.EOL +            "    i = 5;" + PMD.EOL +            "   }" + PMD.EOL +            "  } else {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST23_NODES = {        {1},        {2},        {3},        {4, 8},        {5},        {7, 10},        {5},        {6},        {9, 10},        {10},        {}        };    public static final String TEST23 =        "public class Foo {" + PMD.EOL +            " public void test_23() {" + PMD.EOL +            "  int i = 0;" + PMD.EOL +            "  if (i == 1) {" + PMD.EOL +            "   for (i = 3; i < 4; i++) {" + PMD.EOL +            "    i = 5;" + PMD.EOL +            "   }" + PMD.EOL +            "  } else if (i < 6) {" + PMD.EOL +            "   i = 7;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST24_NODES = {        {1},        {2},        {3},        {4, 9},        {5},        {7, 11},        {5},        {8, 6},        {6},        {10, 11},        {11},        {}        };    public static final String TEST24 =        "public class Foo {" + PMD.EOL +            " public void test_24() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  if (x > 2) {" + PMD.EOL +            "   for (int i = 0; i < 1; i++) {" + PMD.EOL +            "    if (x > 3) {" + PMD.EOL +            "     x++;" + PMD.EOL +            "    }" + PMD.EOL +            "   }" + PMD.EOL +            "  } else if (x > 4) {" + PMD.EOL +            "   x++;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST25_NODES = {        {1},        {2},        {3},        {4,5},        {5},        {}        };    public static final String TEST25 =        "public class Foo {" + PMD.EOL +            " public void test_25() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  switch (x) {" + PMD.EOL +            "   default:" + PMD.EOL +            "    x = 9;" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST26_NODES = {        {1},        {2},        {3},        {4},        {5, 6},        {6},        {7},        {8, 3},        {9},        {}        };    public static final String TEST26 =        "public class Foo {" + PMD.EOL +            " public void test_26() {" + PMD.EOL +            "  int x = 0;" + PMD.EOL +            "  do {" + PMD.EOL +            "   if (x > 0) {" + PMD.EOL +            "    x++;" + PMD.EOL +            "   }" + PMD.EOL +            "   x++;" + PMD.EOL +            "  } while (x < 9);" + PMD.EOL +            "  x++;" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST27_NODES = {        {1},        {2},        {3},        {5, 9},        {3},        {6},        {7},        {8},        {6, 4},        {}        };    public static final String TEST27 =        "public class Foo {" + PMD.EOL +            " public void test_27() {" + PMD.EOL +            "  for (int i = 0; i < 36; i++) {" + PMD.EOL +            "   int x = 0;" + PMD.EOL +            "   do {" + PMD.EOL +            "    x++;" + PMD.EOL +            "   } while (x < 9);" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST28_NODES = {        {1},        {2},        {3},        {5, 14},        {3},        {6},        {7},        {8, 12},        {9},        {10, 12},        {11},        {12},        {13},        {6, 4},        {}        };    public static final String TEST28 =        "public class Foo {" + PMD.EOL +            " private void test_28() {" + PMD.EOL +            "  for (int i = 0; i < 36; i++) {" + PMD.EOL +            "   int x = 0;" + PMD.EOL +            "   do {" + PMD.EOL +            "    if (x > 0) {" + PMD.EOL +            "     x++;" + PMD.EOL +            "     switch (i) {" + PMD.EOL +            "      case 0:" + PMD.EOL +            "       x = 0;" + PMD.EOL +            "       break;" + PMD.EOL +            "     }" + PMD.EOL +            "    }" + PMD.EOL +            "    x++;" + PMD.EOL +            "   } while (x < 9);" + PMD.EOL +            "  }" + PMD.EOL +            " }" + PMD.EOL +            " }";    private static final int[][] TEST29_NODES = {               {1},               {2},               {3,4,5},               {6},               {6},               {6},               {}        };    public static final String TEST29 =        "public class Foo {" + PMD.EOL +        " private void test_29() {" + PMD.EOL +        "  switch(x) {" + PMD.EOL +        "   case 1:" + PMD.EOL +        "    break; " + PMD.EOL +        "   default: " + PMD.EOL +        "    break;" + PMD.EOL +        "   case 2:" + PMD.EOL +        "    break;" + PMD.EOL +        "  }" + PMD.EOL +        " }" + PMD.EOL +        "}";    private static final int[][] TEST30_NODES = {               {1},               {2},               {3},               {4,7},               {5,6},               {4},               {3},               {}        };    public static final String TEST30 =        "public class Foo {" + PMD.EOL +        " private void test_30() {" + PMD.EOL +        "  int x = 0;" + PMD.EOL +        "  while (true) {" + PMD.EOL +        "   while (x>0) {" + PMD.EOL +        "     x++;" + PMD.EOL +        "   }" + PMD.EOL +        "   continue;" + PMD.EOL +        "  }" + PMD.EOL +        " }" + PMD.EOL +        "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.ant.PMDTask;import net.sourceforge.pmd.ant.RuleSetWrapper;import org.apache.tools.ant.BuildException;public class PMDTaskTest extends TestCase {    public void testNoFormattersValidation() {        PMDTask task = new PMDTask();        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no Formatters");        } catch (BuildException be) {            // cool        }    }    public void testFormatterWithNoToFileAttribute() {        PMDTask task = new PMDTask();        task.addFormatter(new Formatter());        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - a Formatter was missing a toFile attribute");        } catch (BuildException be) {            // cool        }    }    public void testNoRuleSets() {        PMDTask task = new PMDTask();        task.setPrintToConsole(true);        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - no rulesets");        } catch (BuildException be) {            // cool        }    }    public void testNestedRuleset() {        PMDTask task = new PMDTask();        RuleSetWrapper r = new RuleSetWrapper();        r.addText("rulesets/basic.xml");        task.addRuleset(r);        r.addText("rulesets/design.xml");        task.addRuleset(r);        Formatter f = new Formatter();        task.addFormatter(f);                //TODO        try {            task.execute();        } catch (BuildException be) {            //fail(be.toString());        }    }    public void testInValidJDK() {        PMDTask task = new PMDTask();        task.setTargetJDK("1.6");        try {            task.execute();            throw new RuntimeException("Should have thrown a BuildException - JDK 1.6 targeted");        } catch (BuildException be) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ant;import junit.framework.TestCase;import net.sourceforge.pmd.ant.Formatter;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;import org.apache.tools.ant.BuildException;import java.io.File;public class FormatterTest extends TestCase {    public void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.getRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.getRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.getRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.getRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            f.getRenderer();            throw new RuntimeException("Should have failed!");        } catch (BuildException be) {            // cool        }    }    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isToFileNull());        f.setToFile(new File("foo"));        assertFalse("Formatter toFile should not be null!", f.isToFileNull());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.jaxen.Attribute;import net.sourceforge.pmd.jaxen.AttributeAxisIterator;import java.util.HashSet;import java.util.Set;public class AttributeAxisIteratorTest extends TestCase {    public void testBasicAttributes() {        Set names = new HashSet();        names.add("BeginLine");        names.add("EndLine");        names.add("BeginColumn");        names.add("EndColumn");        names.add("Discardable");        SimpleNode n = new SimpleNode(0);        n.testingOnly__setBeginColumn(1);        n.testingOnly__setBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        try {            Attribute a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));            a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));            a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));            a = (Attribute)iter.next();            assertTrue(names.contains(a.getName()));        } catch (UnsupportedOperationException e) {            // cool        }    }    public void testRemove() {        SimpleNode n = new SimpleNode(0);        n.testingOnly__setBeginColumn(1);        n.testingOnly__setBeginLine(1);        AttributeAxisIterator iter = new AttributeAxisIterator(n);        try {            iter.remove();            fail("Should have thrown an exception!");        } catch (UnsupportedOperationException e) {            // cool        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.jaxen;import junit.framework.TestCase;import net.sourceforge.pmd.jaxen.Attribute;public class AttributeTest extends TestCase {    public void testConstructor() {        Attribute a = new Attribute(null, "name", "value");        assertEquals("name", a.getName());        assertEquals("value", a.getValue());        assertNull(a.getParent());    }    public void testAccessors() {        Attribute a = new Attribute(null, null, null);        a.setName("name");        a.setValue("value");        a.setParent(null);        assertEquals("name", a.getName());        assertEquals("value", a.getValue());        assertNull(a.getParent());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.jaxen;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTStatement;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.jaxen.DocumentNavigator;import org.jaxen.BaseXPath;import org.jaxen.JaxenException;import org.jaxen.UnsupportedAxisException;import test.net.sourceforge.pmd.testframework.RuleTst;import java.util.Iterator;import java.util.List;public class DocumentNavigatorTest extends RuleTst {       private TestRule rule;    private class TestRule extends AbstractRule {        private Node compilationUnit;        private Node importDeclaration;        private Node statement;        private Node primaryPrefix;        private Node primaryExpression;        /**         * @see net.sourceforge.pmd.ast.JavaParserVisitor#visit(ASTCompilationUnit, Object)         */        public Object visit(ASTCompilationUnit node, Object data) {            this.compilationUnit = node;            return super.visit(node, data);        }        public Object visit(ASTImportDeclaration node, Object data) {            this.importDeclaration = node;            return super.visit(node, data);        }        public Object visit(ASTStatement node, Object data) {            this.statement = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryPrefix node, Object data) {            this.primaryPrefix = node;            return super.visit(node, data);        }        public Object visit(ASTPrimaryExpression node, Object data) {            this.primaryExpression = node;            return super.visit(node, data);        }    }    public void setUp() throws Exception {        try{            rule = new TestRule();            runTestFromString(TEST, rule, new Report());        } catch (Throwable xx) {            xx.printStackTrace();            fail();        }    }        public void testChildAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getChildAxisIterator(rule.compilationUnit);        assertSame(rule.compilationUnit.jjtGetChild(0), iter.next());        assertSame(rule.compilationUnit.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testParentAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getParentAxisIterator(rule.importDeclaration);        assertSame(rule.importDeclaration.jjtGetParent(), iter.next());        assertFalse(iter.hasNext());    }        public void testParentAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter =nav.getParentAxisIterator(rule.compilationUnit);        assertFalse(iter.hasNext());    }    public void testDescendantAxisIterator() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();Iterator iter = nav.getDescendantAxisIterator(rule.statement);Node statementExpression = rule.statement.jjtGetChild(0);assertSame(statementExpression, iter.next());Node primaryExpression = statementExpression.jjtGetChild(0);        assertSame(primaryExpression, iter.next());        Node primaryPrefix = primaryExpression.jjtGetChild(0);        assertSame(primaryPrefix, iter.next());        Node primarySuffix = primaryExpression.jjtGetChild(1);        assertSame(primarySuffix, iter.next());        Node name = primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        Node arguments = primarySuffix.jjtGetChild(0);        assertSame(arguments, iter.next());        assertFalse(iter.hasNext());    }        public void testDescendantAxisIterator2() throws UnsupportedAxisException {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getDescendantAxisIterator(rule.primaryPrefix);        Node name = rule.primaryPrefix.jjtGetChild(0);        assertSame(name, iter.next());        assertFalse(iter.hasNext());    }        public void testFollowingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertSame(rule.primaryExpression.jjtGetChild(1), iter.next());        assertFalse(iter.hasNext());    }    public void testFollowingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getFollowingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(1));        assertSame(rule.primaryExpression.jjtGetChild(0), iter.next());        assertFalse(iter.hasNext());    }    public void testPrecedingSiblingAxisIterator2() {        DocumentNavigator nav = new DocumentNavigator();        Iterator iter = nav.getPrecedingSiblingAxisIterator(rule.primaryExpression.jjtGetChild(0));        assertFalse(iter.hasNext());    }    public void testXPath() throws JaxenException {BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());List matches = xPath.selectNodes(rule.statement);assertEquals(6, matches.size());    }    public void testXPath2() throws JaxenException {        BaseXPath xPath = new BaseXPath(".//*", new DocumentNavigator());        List matches = xPath.selectNodes(rule.importDeclaration);        assertEquals(1, matches.size());            }      public static final String TEST =      "import java.io.*;" + PMD.EOL +      "public class Foo {" + PMD.EOL +      " public Foo() {" + PMD.EOL +      "  try {" + PMD.EOL +      "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL +      "  } catch (Exception e) {}" + PMD.EOL +      "  try {" + PMD.EOL +      "   FileReader fr = new FileReader(\"/dev/null\");" + PMD.EOL +      "  } catch (Exception e) {" + PMD.EOL +      "   e.printStackTrace();" + PMD.EOL +      "   // this shouldn't show up on the report" + PMD.EOL +      "  }" + PMD.EOL +      " }" + PMD.EOL +      "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.renderers;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.TextPadRenderer;import test.net.sourceforge.pmd.testframework.MockRule;public class TextPadRendererTest extends TestCase  {    public void testNullPassedIn() {        try  {            (new TextPadRenderer()).render(null);            fail("Providing a render(null) should throw an npx");        }  catch(NullPointerException npx)  {            // cool        }    }    public void testRenderer()  {        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("Foo.java");        Report rep = new Report();        rep.addRuleViolation(new RuleViolation(new MockRule("DontImportJavaLang", "Avoid importing anything from the package 'java.lang'", "Avoid importing anything from the package 'java.lang'", "rulesetname"), 3,ctx, "package", "class", "method"));        String actual = (new TextPadRenderer()).render(rep);        String expected = PMD.EOL + "Foo.java(3,  DontImportJavaLang):  Avoid importing anything from the package 'java.lang'" ;        assertEquals(expected, actual);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.renderers;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.XMLRenderer;import org.w3c.dom.Element;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import test.net.sourceforge.pmd.testframework.MockRule;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import java.io.IOException;import java.io.StringReader;public class XMLRendererTest extends TestCase {    private MockRule RULE1 = new MockRule("RULE1", "RULE1", "msg", "rulesetname", 3);    private MockRule RULE2 = new MockRule("RULE2", "RULE2", "msg", "rulesetname");    private RuleContext ctx = new RuleContext();    public XMLRendererTest(String name) {        super(name);    }    public void testEmptyReport() throws Throwable {        Element root = parseRootElement(new Report());        assertEquals("pmd", root.getNodeName());        assertNull(root.getFirstChild().getNextSibling()); // only one child, it's whitespace    }    public void testErrorReport() throws Throwable {        Report report = new Report();        report.addError(new Report.ProcessingError("test_msg", "test_filename"));        Element root = parseRootElement(report);        assertEquals("test_msg", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("msg").getNodeValue());    }    public void testSingleReport() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testSingleReport");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        Element root = parseRootElement(report);        assertEquals("testSingleReport", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());        assertEquals("RULE1", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());        assertEquals("rulesetname", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("ruleset").getNodeValue());        assertEquals("1", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("line").getNodeValue());    }    public void testDoubleReport() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testDoubleReport");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        report.addRuleViolation(new RuleViolation(RULE2, 2, "Rule2", ctx));        Element root = parseRootElement(report);        assertEquals("RULE1", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());        assertEquals("RULE2", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getNextSibling().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());    }    public void testTwoFiles() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_1");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        Element root = parseRootElement(report);        assertEquals("testTwoFiles_0", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());        assertEquals("testTwoFiles_1", root.getFirstChild().getNextSibling().getNextSibling().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());    }    public void testUnorderedFiles() throws Throwable {        Report report = new Report();        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_1");        report.addRuleViolation(new RuleViolation(RULE1, 1, "Rule1", ctx));        ctx.setSourceCodeFilename("testTwoFiles_0");        report.addRuleViolation(new RuleViolation(RULE2, 2, "Rule2", ctx));        Element root = parseRootElement(report);        assertEquals("testTwoFiles_0", root.getFirstChild().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());        assertEquals("testTwoFiles_1", root.getFirstChild().getNextSibling().getNextSibling().getNextSibling().getAttributes().getNamedItem("name").getNodeValue());        assertEquals("RULE1", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());        assertEquals("RULE2", root.getFirstChild().getNextSibling().getFirstChild().getNextSibling().getNextSibling().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());        assertEquals("RULE1", root.getFirstChild().getNextSibling().getNextSibling().getNextSibling().getFirstChild().getNextSibling().getAttributes().getNamedItem("rule").getNodeValue());    }    public void testEscaping() throws Throwable {        // <?xml version="1.0"?>        // <pmd>        //   <file name="testEscaping: Less than: &lt; Greater than: &gt; Ampersand: &amp; Quote: &quot; 'e' acute: &#233;">        //     <violation line="1" rule="RULE1">        // [RULE] Less than: &lt; Greater than: &gt; Ampersand: &amp; Quote: &quot; 'e' acute: &#233;        //     </violation>        //   </file>        // </pmd>        Report report = new Report();        ctx.setSourceCodeFilename("testEscaping: Less than: < Greater than: > Ampersand: & Quote: \" 'e' acute: \u00E9");        report.addRuleViolation(new RuleViolation(RULE1, 1, "[RULE] Less than: < Greater than: > Ampersand: & Quote: \" 'e' acute: \u00E9", ctx));        Element root = parseRootElement(report);        String out = root.getFirstChild().getNextSibling().toString();        // TODO - this works when run "manually" but not when run using Maven.  Must        // be some hideous XML difference.  Argh./*        assertTrue(out.indexOf("&gt;") != -1);        assertTrue(out.indexOf("&lt;") != -1);        assertTrue(out.indexOf("&amp;") != -1);        assertTrue(out.indexOf("&apos;") != -1);*/    }    private Element parseRootElement(Report rpt) throws SAXException, IOException, ParserConfigurationException {        return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(new StringReader(new XMLRenderer().render(rpt)))).getDocumentElement();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.symboltable.TypeSet;import java.io.File;import java.util.HashSet;import java.util.Set;public class TypeSetTest extends TestCase {    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    public void testFindClassImplicitImport() throws Throwable {        TypeSet t = new TypeSet();        Class clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    public void testFindClassSamePackage() throws Throwable {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd.");        Class clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    public void testFindClassExplicitImport() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassImportOnDemand() throws Throwable {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    public void testFindClassPrimitive() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    public void testFindClassVoid() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    public void testFindFullyQualified() throws Throwable {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    public void testPrimitiveTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    public void testVoidTypeResolver() throws Throwable {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    public void testExplicitImportResolver() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(imports);        assertEquals(File.class, r.resolve("File"));    }    public void testImplicitImportResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        assertEquals(String.class, r.resolve("String"));    }    public void testImplicitImportResolverPassFail() throws Throwable {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver();        try {            r.resolve("PMD");            fail("Should have thrown an exception");        } catch (ClassNotFoundException cnfe) {        }    }    public void testCurrentPackageResolverPass() throws Throwable {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver("net.sourceforge.pmd.");        assertEquals(PMD.class, r.resolve("PMD"));    }    public void testImportOnDemandResolverPass() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    public void testImportOnDemandResolverFail() throws Throwable {        Set imports = new HashSet();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(imports);        try {            r.resolve("foo");            fail("Should have thrown a ClassNotFoundException");        } catch (ClassNotFoundException cnfe) {        }        try {            r.resolve("String");            fail("Should have thrown a ClassNotFoundException");        } catch (ClassNotFoundException cnfe) {        }    }}
package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import net.sourceforge.pmd.symboltable.VariableUsageFinderFunction;import net.sourceforge.pmd.util.Applier;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class VariableUsageFinderFunctionTest extends TestCase {    public void testLookingForUsed() {        ASTVariableDeclaratorId variableDeclarationIdNode = new ASTVariableDeclaratorId(1);        variableDeclarationIdNode.setImage("x");        NameDeclaration nameDeclaration = new VariableNameDeclaration(variableDeclarationIdNode);        List nameOccurrences = new ArrayList();        nameOccurrences.add(new NameOccurrence(new SimpleNode(2), "x"));        Map declarations = new HashMap();        declarations.put(nameDeclaration, nameOccurrences);        List vars = new ArrayList();        vars.add(nameDeclaration);        VariableUsageFinderFunction f = new VariableUsageFinderFunction(declarations);        Applier.apply(f, vars.iterator());        Map p = f.getUsed();        assertEquals(1, p.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.Scope;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;public class VariableNameDeclarationTest extends STBBaseTst  {    public void testConstructor() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        Scope s = ((ASTVariableDeclaratorId)nodes.get(0)).getScope();        VariableNameDeclaration decl = (VariableNameDeclaration)s.getVariableDeclarations().keySet().iterator().next();        assertEquals("bar", decl.getImage());        assertEquals(3, decl.getNode().getBeginLine());    }    public void testExceptionBlkParam() {        ASTVariableDeclaratorId id = new ASTVariableDeclaratorId(3);        id.testingOnly__setBeginLine(10);        id.setImage("foo");        ASTFormalParameter param = new ASTFormalParameter(2);        id.jjtSetParent(param);        param.jjtSetParent(new ASTTryStatement(1));        VariableNameDeclaration decl = new VariableNameDeclaration(id);        assertTrue(decl.isExceptionBlockParameter());    }    public void testIsArray() {        parseCode(TEST3);        VariableNameDeclaration decl = (VariableNameDeclaration)((ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0)).getScope().getVariableDeclarations().keySet().iterator().next();        assertTrue(decl.isArray());    }    public void testPrimitiveType() {        parseCode(TEST1);        VariableNameDeclaration decl = (VariableNameDeclaration)((ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0)).getScope().getVariableDeclarations().keySet().iterator().next();        assertTrue(decl.isPrimitiveType());    }    public void testArrayIsReferenceType() {        parseCode(TEST3);        VariableNameDeclaration decl = (VariableNameDeclaration)((ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0)).getScope().getVariableDeclarations().keySet().iterator().next();        assertTrue(decl.isReferenceType());    }    public void testPrimitiveTypeImage() {        parseCode(TEST3);        VariableNameDeclaration decl = (VariableNameDeclaration)((ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0)).getScope().getVariableDeclarations().keySet().iterator().next();        assertEquals("int", decl.getTypeImage());    }    public void testRefTypeImage() {        parseCode(TEST4);        VariableNameDeclaration decl = (VariableNameDeclaration)((ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0)).getScope().getVariableDeclarations().keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    public void testParamTypeImage() {        parseCode(TEST5);        VariableNameDeclaration decl = (VariableNameDeclaration)((ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0)).getScope().getVariableDeclarations().keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int bar = 42;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  try {} catch(Exception e) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int[] x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  String x;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo(String x) {}" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTIfStatement;import net.sourceforge.pmd.symboltable.LocalScope;public class ScopeCreationVisitorTest extends STBBaseTst {    public void testScopesAreCreated() {        parseCode(TEST1);        ASTIfStatement n = (ASTIfStatement)acu.findChildrenOfType(ASTIfStatement.class).get(0);        assertTrue(n.getScope() instanceof LocalScope);    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  if (x>2) {}" + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import net.sourceforge.pmd.symboltable.ClassScope;import net.sourceforge.pmd.symboltable.MethodNameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.Iterator;import java.util.List;import java.util.Map;public class ClassScopeTest extends STBBaseTst {    public void testEnumsClassScope() {        parseCode15(ENUM_SCOPE);    }    // FIXME - these will break when this goes from Anonymous$1 to Foo$1    public void testAnonymousInnerClassName() {        ClassScope s = new ClassScope();        assertEquals("Anonymous$1", s.getClassName());        s = new ClassScope();        assertEquals("Anonymous$2", s.getClassName());    }    public void testContains() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testCantContainsSuperToString() {        ClassScope s = new ClassScope("Foo");        SimpleNode node = new SimpleNode(1);        node.setImage("super.toString");        assertTrue(!s.contains(new NameOccurrence(node, node.getImage())));    }    public void testContainsStaticVariablePrefixedWithClassName() {        ClassScope s = new ClassScope("Foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("X");        s.addDeclaration(new VariableNameDeclaration(node));        SimpleNode node2 = new SimpleNode(2);        node2.setImage("Foo.X");        assertTrue(s.contains(new NameOccurrence(node2, node2.getImage())));    }    public void testClassName() {        parseCode(CLASS_NAME);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        assertEquals("Foo", n.getScope().getEnclosingClassScope().getClassName());    }    public void testMethodDeclarationRecorded() {        parseCode(METHOD_DECLARATIONS_RECORDED);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope s = (ClassScope)n.getScope();        Map m = s.getMethodDeclarations();        assertEquals(1, m.size());        MethodNameDeclaration mnd = (MethodNameDeclaration)m.keySet().iterator().next();        assertEquals("bar", mnd.getImage());        ASTMethodDeclaration node = (ASTMethodDeclaration)mnd.getNode().jjtGetParent();        assertTrue(node.isPrivate());    }    public void testTwoMethodsSameNameDiffArgs() {        // TODO this won't work with String and java.lang.String        parseCode(METHODS_WITH_DIFF_ARG);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        assertEquals(2, m.size());        Iterator i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration)i.next();        assertEquals("bar", mnd.getImage());        assertEquals("bar", ((MethodNameDeclaration)i.next()).getImage());    }    public final void testOneParams() throws Throwable {        parseCode(ONE_PARAM);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration)m.keySet().iterator().next();        assertEquals("(String)", mnd.getParameterDisplaySignature());    }    public final void testTwoParams() throws Throwable {        parseCode(TWO_PARAMS);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration)m.keySet().iterator().next();        assertEquals("(String,int)", mnd.getParameterDisplaySignature());    }    public final void testNoParams() throws Throwable {        parseCode(NO_PARAMS);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration)m.keySet().iterator().next();        assertEquals("()", mnd.getParameterDisplaySignature());    }    public final void testNestedClassDeclFound() throws Throwable {        parseCode(NESTED_CLASS_FOUND);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope c = (ClassScope)n.getScope();        Map m = c.getClassDeclarations();        ClassNameDeclaration cnd = (ClassNameDeclaration)m.keySet().iterator().next();        assertEquals("Buz", cnd.getImage());    }    public final void testbuz() throws Throwable {        parseCode(METH);        //SymbolTableViewer st = new SymbolTableViewer();        //acu.jjtAccept(st, null);    }    public void testMethodUsageSeen() {        parseCode(METHOD_USAGE_SEEN);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        Iterator i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration)i.next();        if (!mnd.getImage().equals("bar")) {            mnd = (MethodNameDeclaration)i.next();        }        List usages = (List)m.get(mnd);        assertEquals(1, usages.size());        assertEquals("bar", ((NameOccurrence)usages.get(0)).getImage());    }    public void testMethodUsageSeenWithThis() {        parseCode(METHOD_USAGE_SEEN_WITH_THIS);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        Iterator i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration)i.next();        if (!mnd.getImage().equals("bar")) {            mnd = (MethodNameDeclaration)i.next();        }        List usages = (List)m.get(mnd);        assertEquals(1, usages.size());        assertEquals("bar", ((NameOccurrence)usages.get(0)).getImage());    }    public void testMethodUsageSeen2() {        parseCode(METHOD_USAGE_SEEN2);        ASTClassOrInterfaceDeclaration n = (ASTClassOrInterfaceDeclaration)acu.findChildrenOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map m = ((ClassScope)n.getScope()).getMethodDeclarations();        Iterator i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration)i.next();        if (mnd.getNode().getBeginLine() == 2) {            List usages = (List)m.get(mnd);            System.out.println(usages.size());            System.out.println(mnd);            mnd = (MethodNameDeclaration)i.next();        }    }    private static final String METHOD_USAGE_SEEN2 =    "public class Foo {" + PMD.EOL +    " public void baz() {" + PMD.EOL +    "  baz(x, y);" + PMD.EOL +    " }" + PMD.EOL +   " private void baz(int x, int y) {}" + PMD.EOL +    "}";    private static final String METHOD_USAGE_SEEN =    "public class Foo {" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    " public void buz() {" + PMD.EOL +    "  bar();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String METHOD_USAGE_SEEN_WITH_THIS =    "public class Foo {" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    " public void buz() {" + PMD.EOL +    "  this.bar();" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String METH =    "public class Test {" + PMD.EOL +    "  static { " + PMD.EOL +    "   int y; " + PMD.EOL +    "  } " + PMD.EOL +    "  void bar(int x) {} " + PMD.EOL +    "  void baz(int x) {} " + PMD.EOL +    "}";    private static final String NESTED_CLASS_FOUND =    "public class Test {" + PMD.EOL +    "  private class Buz {} " + PMD.EOL +    "}";    private static final String ONE_PARAM =    "public class Test {" + PMD.EOL +    "  void bar(String x) {" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String TWO_PARAMS =    "public class Test {" + PMD.EOL +    "  void bar(String x, int y) {" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String NO_PARAMS =    "public class Test {" + PMD.EOL +    "  void bar() {" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String CLASS_NAME =    "public class Foo {}";    private static final String METHOD_DECLARATIONS_RECORDED =    "public class Foo {" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String METHODS_WITH_DIFF_ARG =    "public class Foo {" + PMD.EOL +    " private void bar(String x) {}" + PMD.EOL +    " private void bar() {}" + PMD.EOL +    "}";    private static final String ENUM_SCOPE =    "public enum Foo {" + PMD.EOL +    " HEAP(\"foo\");" + PMD.EOL +    " private final String fuz;" + PMD.EOL +    " public String getFuz() {" + PMD.EOL +    "  return fuz;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTFormalParameter;import net.sourceforge.pmd.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTPrimaryPrefix;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.LocalScope;import net.sourceforge.pmd.symboltable.MethodScope;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;import java.util.Map;public class LocalScopeTest extends STBBaseTst {    public void testNameWithThisOrSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesThisModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertTrue(!scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testNameWithSuperIsNotFlaggedAsUnused() {        LocalScope scope = new LocalScope();        ASTName name = new ASTName(1);        name.setImage("foo");        ASTPrimaryPrefix prefix = new ASTPrimaryPrefix(2);        prefix.setUsesSuperModifier();        name.jjtAddChild(prefix, 1);        NameOccurrence occ = new NameOccurrence(name, "foo");        scope.addVariableNameOccurrence(occ);        assertTrue(!scope.getVariableDeclarations().keySet().iterator().hasNext());    }    public void testLocalVariableDeclarationFound() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId)nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        assertEquals(1, vars.size());        NameDeclaration decl = (NameDeclaration)vars.keySet().iterator().next();        assertEquals("b", decl.getImage());    }    public void testQualifiedNameOccurrence() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId)nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        NameDeclaration decl = (NameDeclaration)vars.keySet().iterator().next();        NameOccurrence occ = (NameOccurrence)((List)vars.get(decl)).get(0);        assertEquals("b", occ.getImage());    }    public void testPostfixUsageIsRecorded() {        parseCode(TEST3);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = (ASTVariableDeclaratorId)nodes.get(0);        Map vars = node.getScope().getVariableDeclarations();        NameDeclaration decl = (NameDeclaration)vars.keySet().iterator().next();        List usages = (List)vars.get(decl);        NameOccurrence occ = (NameOccurrence)usages.get(0);        assertEquals(4, occ.getLocation().getBeginLine());    }    public void testLocalVariableTypesAreRecorded() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTVariableDeclaratorId.class);        Map vars = ((ASTVariableDeclaratorId)nodes.get(0)).getScope().getVariableDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration)vars.keySet().iterator().next();        assertEquals("Bar", decl.getTypeImage());    }    public void testMethodArgumentTypesAreRecorded() {        parseCode(TEST5);        List nodes = acu.findChildrenOfType(ASTFormalParameter.class);        Map vars = ((ASTFormalParameter)nodes.get(0)).getScope().getVariableDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration)vars.keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    public void testgetEnclosingMethodScope() {        parseCode(TEST4);        ASTLocalVariableDeclaration node = (ASTLocalVariableDeclaration)acu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        LocalScope scope = (LocalScope)node.getScope();        MethodScope ms  = scope.getEnclosingMethodScope();        assertEquals(2, ms.getVariableDeclarations().size());    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  Bar b = new Bar();" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  Bar b = new Bar();" + PMD.EOL +    "  b.buz = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x = 2;" + PMD.EOL +    "  x++;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo(String x, String z) { int y; }" + PMD.EOL +    "}";    public static final String TEST5 =    "public class Foo {" + PMD.EOL +    " void foo(String x);" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.symboltable.MethodScope;import net.sourceforge.pmd.symboltable.NameOccurrence;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.List;import java.util.Map;public class MethodScopeTest extends STBBaseTst {    public void testMethodParameterOccurrenceRecorded() {        parseCode(TEST1);        Map m = ((ASTMethodDeclaration)(acu.findChildrenOfType(ASTMethodDeclaration.class)).get(0)).getScope().getVariableDeclarations();        VariableNameDeclaration vnd = (VariableNameDeclaration)m.keySet().iterator().next();        assertEquals("bar", vnd.getImage());        List occs = (List)m.get(vnd);        NameOccurrence occ = (NameOccurrence)occs.get(0);        assertEquals(3, occ.getLocation().getBeginLine());    }    public void testMethodName() {        parseCode(TEST1);        ASTMethodDeclaration meth = (ASTMethodDeclaration)(acu.findChildrenOfType(ASTMethodDeclaration.class)).get(0);        MethodScope ms = (MethodScope)meth.getScope();        assertEquals(ms.getName(), "foo");    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo(int bar) {" + PMD.EOL +    "  bar = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTPrimaryExpression;import net.sourceforge.pmd.symboltable.NameFinder;import net.sourceforge.pmd.symboltable.NameOccurrence;import java.util.List;public class NameOccurrencesTest extends STBBaseTst {    public void testSuper() {        parseCode(TEST1);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression)nodes.get(0));        assertEquals("super", ((NameOccurrence)occs.getNames().get(0)).getImage());    }    public void testThis() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression)nodes.get(0));        assertEquals("this", ((NameOccurrence)occs.getNames().get(0)).getImage());        assertEquals("x", ((NameOccurrence)occs.getNames().get(1)).getImage());    }    public void testNameLinkage() {        parseCode(TEST2);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression)nodes.get(0));        NameOccurrence thisNameOccurrence = (NameOccurrence)occs.getNames().get(0);        assertEquals(thisNameOccurrence.getNameForWhichThisIsAQualifier(), occs.getNames().get(1));    }    public void testSimpleVariableOccurrence() {        parseCode(TEST3);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression)nodes.get(0));        assertEquals("x", ((NameOccurrence)occs.getNames().get(0)).getImage());        assertFalse(((NameOccurrence)occs.getNames().get(0)).isThisOrSuper());        assertFalse(((NameOccurrence)occs.getNames().get(0)).isMethodOrConstructorInvocation());        assertTrue(((NameOccurrence)occs.getNames().get(0)).isOnLeftHandSide());    }    public void testQualifiedOccurrence() {        parseCode(TEST4);        List nodes = acu.findChildrenOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder((ASTPrimaryExpression)nodes.get(0));        assertEquals("b", ((NameOccurrence)occs.getNames().get(0)).getImage());        assertEquals("x", ((NameOccurrence)occs.getNames().get(1)).getImage());    }    public static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  super.x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  this.x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    public static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  b.x = 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import net.sourceforge.pmd.symboltable.Scope;import java.util.Map;public class GlobalScopeTest extends STBBaseTst {    public void testClassDeclAppears() {        parseCode(TEST1);        ASTCompilationUnit decl = (ASTCompilationUnit)(acu.findChildrenOfType(ASTCompilationUnit.class)).get(0);        Scope scope = decl.getScope();        Map m = scope.getClassDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration)m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    private static final String TEST1 =    "public class Foo {}" + PMD.EOL;}
package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.symboltable.ClassNameDeclaration;import java.util.Iterator;import java.util.Map;public class SourceFileScopeTest extends STBBaseTst {    public void testClassDeclAppears() {        parseCode(TEST1);        Map m = acu.getScope().getClassDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration)m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    public void testPackageIsEmptyString() {        parseCode(TEST1);        ASTCompilationUnit decl = (ASTCompilationUnit)(acu.findChildrenOfType(ASTCompilationUnit.class)).get(0);        assertEquals(decl.getScope().getEnclosingSourceFileScope().getPackageName(), "");    }    public void testPackageNameFound() {        parseCode(TEST2);        ASTCompilationUnit decl = (ASTCompilationUnit)(acu.findChildrenOfType(ASTCompilationUnit.class)).get(0);        assertEquals(decl.getScope().getEnclosingSourceFileScope().getPackageName(), "foo.bar");    }    public void testNestedClasses() {        parseCode(TEST3);        Map m = acu.getScope().getClassDeclarations();        Iterator iterator = m.keySet().iterator();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration)iterator.next();        assertEquals(classNameDeclaration.getImage(), "Foo");        assertFalse(iterator.hasNext());    }    private static final String TEST1 =    "public class Foo {}" + PMD.EOL;    private static final String TEST2 =    "package foo.bar;" + PMD.EOL +    "public class Foo {" + PMD.EOL +    "}" + PMD.EOL;    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " public class Bar {" + PMD.EOL +    " }" + PMD.EOL +    "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.symboltable.Scope;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.Iterator;import java.util.Map;public class AcceptanceTest extends STBBaseTst {/*    public void testClashingSymbols() {        parseCode(TEST1);    }    public void testInitializer() {        parseCode(TEST_INITIALIZERS);        ASTInitializer a = (ASTInitializer)(acu.findChildrenOfType(ASTInitializer.class)).get(0);        assertFalse(a.isStatic());        a = (ASTInitializer)(acu.findChildrenOfType(ASTInitializer.class)).get(1);        assertTrue(a.isStatic());    }    public void testCatchBlocks() {        parseCode(TEST_CATCH_BLOCKS);        ASTCatchStatement c = (ASTCatchStatement)(acu.findChildrenOfType(ASTCatchStatement.class)).get(0);        ASTBlock a = (ASTBlock)(c.findChildrenOfType(ASTBlock.class)).get(0);        Scope s = a.getScope();        Map vars = s.getParent().getVariableDeclarations();        assertEquals(1, vars.size());        VariableNameDeclaration v = (VariableNameDeclaration)vars.keySet().iterator().next();        assertEquals("e", v.getImage());        assertEquals(1, ((List)vars.get(v)).size());    }    public void testEq() {        parseCode(TEST_EQ);        ASTEqualityExpression e = (ASTEqualityExpression)(acu.findChildrenOfType(ASTEqualityExpression.class)).get(0);        ASTMethodDeclaration method = (ASTMethodDeclaration)e.getFirstParentOfType(ASTMethodDeclaration.class);        Scope s = method.getScope();        Map m = s.getVariableDeclarations();        for (Iterator i = m.keySet().iterator(); i.hasNext();) {            VariableNameDeclaration vnd = (VariableNameDeclaration)i.next();            SimpleNode node = vnd.getNode();            //System.out.println();        }        //System.out.println(m.size());    }*/    public void testDemo() {        parseCode(TEST_DEMO);        System.out.println(TEST_DEMO);        ASTMethodDeclaration node = (ASTMethodDeclaration)acu.findChildrenOfType(ASTMethodDeclaration.class).get(0);        Scope s = node.getScope();        Map m = s.getVariableDeclarations();        for (Iterator i = m.keySet().iterator(); i.hasNext();) {            VariableNameDeclaration d = (VariableNameDeclaration)i.next();            System.out.println("Variable: " + d.getImage());            System.out.println("Type: " + d.getTypeImage());        }    }/*            List u = (List)m.get(d);            System.out.println("Usages: " + u.size());            NameOccurrence o = (NameOccurrence)u.get(0);            int beginLine = o.getLocation().getBeginLine();            System.out.println("Used in line " + beginLine);*/    private static final String TEST_DEMO =    "public class Foo  {" + PMD.EOL +    " void bar(ArrayList buz) { " + PMD.EOL +    " } " + PMD.EOL +    "}" + PMD.EOL;    private static final String TEST_EQ =    "public class Foo  {" + PMD.EOL +    " boolean foo(String a, String b) { " + PMD.EOL +    "  return a == b; " + PMD.EOL +    " } " + PMD.EOL +    "}" + PMD.EOL;    private static final String TEST1 =    "import java.io.*;" + PMD.EOL +    "public class Foo  {" + PMD.EOL +    " void buz( ) {" + PMD.EOL +    "  Object o = new Serializable() { int x; };" + PMD.EOL +    "  Object o1 = new Serializable() { int x; };" + PMD.EOL +    " }" + PMD.EOL  +    "}" + PMD.EOL;    private static final String TEST_INITIALIZERS =    "public class Foo  {" + PMD.EOL +    " {} " + PMD.EOL +    " static {} " + PMD.EOL +    "}" + PMD.EOL;    private static final String TEST_CATCH_BLOCKS =    "public class Foo  {" + PMD.EOL +    " void foo() { " + PMD.EOL +    "  try { " + PMD.EOL +    "  } catch (Exception e) { " + PMD.EOL +    "   e.printStackTrace(); " + PMD.EOL +    "  } " + PMD.EOL +    " } " + PMD.EOL +    "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.symboltable;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.symboltable.ImageFinderFunction;import net.sourceforge.pmd.symboltable.NameDeclaration;import net.sourceforge.pmd.symboltable.VariableNameDeclaration;import java.util.ArrayList;import java.util.List;public class ImageFinderFunctionTest extends TestCase {    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }    public void testSeveralImages() {        List imgs = new ArrayList();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = new ASTVariableDeclaratorId(1);        node.setImage("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.applyTo(decl);        assertEquals(decl, f.getDecl());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTPrimarySuffix;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTPrimarySuffixTest extends ParserTst {    public void testArrayDereference() throws Throwable {        Set ops = getNodes(ASTPrimarySuffix.class, TEST1);        assertTrue(((ASTPrimarySuffix)(ops.iterator().next())).isArrayDereference());    }    public void testArguments() throws Throwable {        Set ops = getNodes(ASTPrimarySuffix.class, TEST2);        assertTrue(((ASTPrimarySuffix)(ops.iterator().next())).isArguments());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    "  {x[0] = 2;}" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    "  {foo(a);}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTAnnotation;import net.sourceforge.pmd.ast.ASTAnnotationTypeDeclaration;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTEqualityExpression;import net.sourceforge.pmd.ast.ASTInstanceOfExpression;import net.sourceforge.pmd.ast.ASTModifiers;import net.sourceforge.pmd.ast.ASTRelationalExpression;import net.sourceforge.pmd.ast.ASTTypeDeclaration;import net.sourceforge.pmd.ast.DiscardableNodeCleaner;import test.net.sourceforge.pmd.testframework.ParserTst;public class DiscardableNodeCleanerTest extends ParserTst {    public void testRemoveDiscardNodes() throws Throwable {        ASTCompilationUnit cu = new ASTCompilationUnit(1);        ASTEqualityExpression ee = new ASTEqualityExpression(2);        ee.jjtSetParent(cu);        cu.jjtAddChild(ee, 0);        ASTInstanceOfExpression io1 = new ASTInstanceOfExpression(3);        io1.setDiscardable();        io1.jjtSetParent(ee);        ASTRelationalExpression re = new ASTRelationalExpression(4);        re.jjtSetParent(ee);        ee.jjtAddChild(io1, 0);        io1.jjtAddChild(re, 0);        assertEquals(cu.findChildrenOfType(ASTInstanceOfExpression.class).size(), 1);        DiscardableNodeCleaner c = new DiscardableNodeCleaner();        c.clean(cu);        assertEquals(cu.findChildrenOfType(ASTInstanceOfExpression.class).size(), 0);    }    public void testRemoveModifierNodesWithClass() throws Throwable {        ASTCompilationUnit cu = new ASTCompilationUnit(1);        ASTTypeDeclaration td = new ASTTypeDeclaration(2);        td.jjtSetParent(cu);        cu.jjtAddChild(td, 0);        ASTModifiers m = new ASTModifiers(3);        m.setDiscardable();        m.jjtSetParent(td);        td.jjtAddChild(m, 0);        ASTClassOrInterfaceDeclaration cd = new ASTClassOrInterfaceDeclaration(4);        cd.jjtSetParent(td);        td.jjtAddChild(cd, 1);        assertEquals(cu.findChildrenOfType(ASTModifiers.class).size(), 1);        DiscardableNodeCleaner c = new DiscardableNodeCleaner();        c.clean(cu);        assertTrue(cu.findChildrenOfType(ASTModifiers.class).isEmpty());    }    public void testRemoveModifierNodesWithAnnotation() throws Throwable {        ASTCompilationUnit cu = new ASTCompilationUnit(1);        ASTTypeDeclaration td = new ASTTypeDeclaration(2);        td.jjtSetParent(cu);        cu.jjtAddChild(td, 0);        ASTAnnotationTypeDeclaration atd = new ASTAnnotationTypeDeclaration(5);        atd.jjtSetParent(td);        td.jjtAddChild(atd, 0);        ASTModifiers m = new ASTModifiers(3);        m.setDiscardable();        m.jjtSetParent(td);        td.jjtAddChild(m, 1);        ASTAnnotation ann = new ASTAnnotation(4);        ann.jjtSetParent(m);        m.jjtAddChild(ann, 0);        assertEquals(cu.findChildrenOfType(ASTModifiers.class).size(), 1);        DiscardableNodeCleaner c = new DiscardableNodeCleaner();        c.clean(cu);        assertTrue(cu.findChildrenOfType(ASTModifiers.class).isEmpty());       assertFalse(cu.findChildrenOfType(ASTAnnotation.class).isEmpty());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.Set;public class ClassDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, false, false);    }    public void testAbstract() throws Throwable {        String access[] = {"abstract"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, true, false, false);    }    public void testFinal() throws Throwable {        String access[] = {"final"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, true, false);    }    public void testStrict() throws Throwable {        String access[] = {"strictfp"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, false, false, false, true);    }    public void testPublicFinal() throws Throwable {        String access[] = {"public", "final"};        ASTClassOrInterfaceDeclaration acd = getClassDecl(access);        verifyFlags(acd, true, false, true, false);    }    public void verifyFlags(ASTClassOrInterfaceDeclaration acd, boolean bPublic, boolean bAbstract, boolean bFinal, boolean bStrict) {        assertEquals("Public: ", bPublic, acd.isPublic());        assertEquals("Abstract: ", bAbstract, acd.isAbstract());        assertEquals("Final: ", bFinal, acd.isFinal());        assertEquals("Strict: ", bStrict, acd.isStrictfp());    }    public ASTClassOrInterfaceDeclaration getClassDecl(String access[]) throws Throwable {        String javaCode = "";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " class Test { } ";        Set classes = getNodes(ASTClassOrInterfaceDeclaration.class, javaCode);        assertEquals("Wrong number of classes", 1, classes.size());        Iterator i = classes.iterator();        return (ASTClassOrInterfaceDeclaration) i.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.Set;public class FieldDeclTest extends ParserTst {    public String makeAccessJavaCode(String access[]) {        String result = "public class Test { ";        for (int i = 0; i < access.length; i++) {            result += access[i] + " ";        }        return result + " int j;  }";    }    public ASTFieldDeclaration getFieldDecl(String access[]) throws Throwable {        Set fields = getNodes(ASTFieldDeclaration.class, makeAccessJavaCode(access));        assertEquals("Wrong number of fields", 1, fields.size());        Iterator i = fields.iterator();        return (ASTFieldDeclaration) i.next();    }    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be protected.", afd.isProtected());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testStatic() throws Throwable {        String access[] = {"private", "static"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be static.", afd.isStatic());        assertTrue("Expecting field to be private.", afd.isPrivate());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be final.", afd.isFinal());        assertTrue("Expecting field to be public.", afd.isPublic());    }    public void testTransient() throws Throwable {        String access[] = {"private", "transient"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be private.", afd.isPrivate());        assertTrue("Expecting field to be transient.", afd.isTransient());    }    public void testVolatile() throws Throwable {        String access[] = {"private", "volatile"};        ASTFieldDeclaration afd = getFieldDecl(access);        assertTrue("Expecting field to be volatile.", afd.isVolatile());        assertTrue("Expecting field to be private.", afd.isPrivate());    }}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTAllocationExpression;import net.sourceforge.pmd.ast.ASTAssertStatement;import net.sourceforge.pmd.ast.ASTBlockStatement;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTBlockStatementTest extends ParserTst {    public void testIsAllocation()  {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAllocationExpression(1), 0);        assertTrue(bs.isAllocation());    }    public void testIsAllocation2()  {        ASTBlockStatement bs = new ASTBlockStatement(0);        bs.jjtAddChild(new ASTAssertStatement(1), 0);        assertFalse(bs.isAllocation());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Iterator;import java.util.Set;public class MethodDeclTest extends ParserTst {    public void testPublic() throws Throwable {        String access[] = {"public"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testPrivate() throws Throwable {        String access[] = {"private"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testProtected() throws Throwable {        String access[] = {"protected"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be protected.", amd.isProtected());    }    public void testFinal() throws Throwable {        String access[] = {"public", "final"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be final.", amd.isFinal());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testSynchronized() throws Throwable {        String access[] = {"public", "synchronized"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be synchronized.", amd.isSynchronized());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testAbstract() throws Throwable {        String access[] = {"public", "abstract"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be abstract.", amd.isAbstract());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public void testNative() throws Throwable {        String access[] = {"private", "native"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be native.", amd.isNative());        assertTrue("Expecting method to be private.", amd.isPrivate());    }    public void testStrict() throws Throwable {        String access[] = {"public", "strictfp"};        ASTMethodDeclaration amd = getMethodDecl(access);        assertTrue("Expecting method to be strict.", amd.isStrictfp());        assertTrue("Expecting method to be public.", amd.isPublic());    }    public ASTMethodDeclaration getMethodDecl(String access[]) throws Throwable {        String javaCode = "public class Test { ";        for (int i = 0; i < access.length; i++) {            javaCode += access[i] + " ";        }        javaCode += " void stuff() { } }";        Set methods = getNodes(ASTMethodDeclaration.class, javaCode);        assertEquals("Wrong number of methods", 1, methods.size());        Iterator i = methods.iterator();        return (ASTMethodDeclaration) i.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.ast.ASTImportDeclaration;import net.sourceforge.pmd.ast.ParseException;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTImportDeclarationTest extends ParserTst {    public void testImportOnDemand() throws Throwable {        Set ops = getNodes(ASTImportDeclaration.class, TEST1);        assertTrue(((ASTImportDeclaration)(ops.iterator().next())).isImportOnDemand());    }    public void testGetImportedNameNode() throws Throwable {        ASTImportDeclaration i = (ASTImportDeclaration)(getNodes(ASTImportDeclaration.class, TEST2).iterator().next());        assertEquals("foo.bar.Baz", i.getImportedName());    }    public void testStaticImport() throws Throwable {        Set ops = getNodes(new TargetJDK1_5(),  ASTImportDeclaration.class, TEST3);        ASTImportDeclaration i = (ASTImportDeclaration)(ops.iterator().next());        assertTrue(i.isStatic());    }    public void testStaticImportFailsWithJDK14() throws Throwable {        try {            getNodes(ASTImportDeclaration.class, TEST3);            fail("Should have failed to parse a static import in JDK 1.4 mode");        } catch (ParseException pe) {            // cool        }    }    private static final String TEST1 =    "import foo.bar.*;" + PMD.EOL +    "public class Foo {}";    private static final String TEST2 =    "import foo.bar.Baz;" + PMD.EOL +    "public class Foo {}";    private static final String TEST3 =    "import static foo.bar.Baz;" + PMD.EOL +    "public class Foo {}";    private static final String TEST4 =    "import foo.bar.Baz;" + PMD.EOL +    "public class Foo {}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.ast.ASTAnnotation;import net.sourceforge.pmd.ast.ParseException;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTAnnotationTest extends ParserTst {    public void testAnnotationFailsWithJDK14() throws Throwable {        try {            getNodes(ASTAnnotation.class, TEST1);            // FIXME fail("Should have failed to parse an annotation in JDK 1.4 mode");        } catch (ParseException pe) {            // cool        }    }    public void testAnnotationSucceedsWithJDK15() throws Throwable {        try {            getNodes(new TargetJDK1_5(), ASTAnnotation.class, TEST1);        } catch (ParseException pe) {            pe.printStackTrace();            fail("Should have been able to parse an annotation in JDK 1.5 mode");        }    }    private static final String TEST1 =    "public class Foo extends Buz {"  + PMD.EOL +    " @Override"  + PMD.EOL +    " void bar() {"  + PMD.EOL +    "  // overrides a superclass method"  + PMD.EOL +    " }"  + PMD.EOL +    "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTClassOrInterfaceType;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTTryStatement;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import test.net.sourceforge.pmd.testframework.ParserTst;public class ASTVariableDeclaratorIdTest extends ParserTst {    public void testIsExceptionBlockParameter() {        ASTTryStatement tryNode = new ASTTryStatement(1);        ASTBlock block = new ASTBlock(2);        ASTVariableDeclaratorId v = new ASTVariableDeclaratorId(3);        v.jjtSetParent(block);        block.jjtSetParent(tryNode);        assertTrue(v.isExceptionBlockParameter());    }    public void testTypeNameNode() throws Throwable {        ASTCompilationUnit acu = (ASTCompilationUnit)(super.getNodes(ASTCompilationUnit.class, TYPE_NAME_NODE).iterator().next());        ASTVariableDeclaratorId id = (ASTVariableDeclaratorId)acu.findChildrenOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType)id.getTypeNameNode().jjtGetChild(0);        assertEquals("String", name.getImage());    }    private static final String TYPE_NAME_NODE =    "public class Test {" + PMD.EOL +    "  private String bar;" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.ast.JavaParser;import test.net.sourceforge.pmd.testframework.ParserTst;import java.io.StringReader;public class ASTLocalVariableDeclarationTest extends ParserTst {    public void testSingleDimArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST1));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTLocalVariableDeclaration node = (ASTLocalVariableDeclaration)cu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(1, node.getArrayDepth());    }    public void testMultDimArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST2));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTLocalVariableDeclaration node = (ASTLocalVariableDeclaration)cu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(2, node.getArrayDepth());    }    public void testMultDimArraySplitBraces() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST3));        ASTCompilationUnit cu = parser.CompilationUnit();        ASTLocalVariableDeclaration node = (ASTLocalVariableDeclaration)cu.findChildrenOfType(ASTLocalVariableDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    private static final String TEST1 =    "class Foo {" + PMD.EOL +    " void bar() {int x[] = null;}" + PMD.EOL +    "}";    private static final String TEST2 =    "class Foo {" + PMD.EOL +    " void bar() {int x[][] = null;}" + PMD.EOL +    "}";    private static final String TEST3 =    "class Foo {" + PMD.EOL +    " void bar() {int[] x[][] = null;}" + PMD.EOL +    "}";}
/* * Created on Jan 19, 2005  * * $Id$ */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTThrowStatement;import test.net.sourceforge.pmd.testframework.ParserTst;/** *  * @author mgriffa */public class ASTThrowStatementTest extends ParserTst {    public final void testGetFirstASTNameImageNull() throws Throwable {        ASTThrowStatement t = (ASTThrowStatement)getNodes(ASTThrowStatement.class, NULL_NAME).iterator().next();        assertNull(t.getFirstClassOrInterfaceTypeImage());    }    public final void testGetFirstASTNameImageNew() throws Throwable {        ASTThrowStatement t = (ASTThrowStatement)getNodes(ASTThrowStatement.class, OK_NAME).iterator().next();        assertEquals("FooException", t.getFirstClassOrInterfaceTypeImage());    }    private static final String NULL_NAME =    "public class Test {" + PMD.EOL +    "  void bar() {" + PMD.EOL +    "   throw e;" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String OK_NAME =    "public class Test {" + PMD.EOL +    "  void bar() {" + PMD.EOL +    "   throw new FooException();" + PMD.EOL +    "  }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import net.sourceforge.pmd.ast.ASTType;import net.sourceforge.pmd.ast.ASTVariableDeclarator;import net.sourceforge.pmd.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.ast.Dimensionable;import net.sourceforge.pmd.ast.JavaParser;import test.net.sourceforge.pmd.testframework.ParserTst;import java.io.StringReader;public class ASTFieldDeclarationTest extends ParserTst{    public void testIsArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST1));        ASTCompilationUnit cu = parser.CompilationUnit();        Dimensionable node = (Dimensionable)cu.findChildrenOfType(ASTFieldDeclaration.class).get(0);        assertTrue(node.isArray());        assertEquals(1, node.getArrayDepth());    }    public void testMultiDimensionalArray() {        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(TEST2));        ASTCompilationUnit cu = parser.CompilationUnit();        Dimensionable node = (Dimensionable)cu.findChildrenOfType(ASTFieldDeclaration.class).get(0);        assertEquals(3, node.getArrayDepth());    }    private static final String TEST1 =    "class Foo {" + PMD.EOL +    " String[] foo;" + PMD.EOL +    "}";    private static final String TEST2 =    "class Foo {" + PMD.EOL +    " String[][][] foo;" + PMD.EOL +    "}";        public void testGetVariableName() {    int id = 0;    ASTFieldDeclaration n = new ASTFieldDeclaration(id++);    ASTType t = new ASTType(id++);    ASTVariableDeclarator decl = new ASTVariableDeclarator(id++);    ASTVariableDeclaratorId declid = new ASTVariableDeclaratorId(id++);    n.jjtAddChild(t, 0);    t.jjtAddChild(decl, 0);    decl.jjtAddChild(declid, 0);    declid.setImage("foo");        assertEquals("foo", n.getVariableName());        }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html*/package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.AccessNode;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class AccessNodeTest extends ParserTst {    public void testModifiersOnClassDecl() throws Throwable {        Set ops = getNodes(ASTClassOrInterfaceDeclaration.class, TEST1);        assertTrue(((ASTClassOrInterfaceDeclaration)(ops.iterator().next())).isPublic());    }    private static final String TEST1 =    "public class Foo {}";    public void testStatic() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not static.", !node.isStatic());        node.setStatic();        assertTrue("Node set to static, not static.", node.isStatic());    }    public void testPublic() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not public.", !node.isPublic());        node.setPublic();        assertTrue("Node set to public, not public.", node.isPublic());    }    public void testProtected() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not protected.", !node.isProtected());        node.setProtected();        assertTrue("Node set to protected, not protected.", node.isProtected());    }    public void testPrivate() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not private.", !node.isPrivate());        node.setPrivate();        assertTrue("Node set to private, not private.", node.isPrivate());    }    public void testFinal() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not final.", !node.isFinal());        node.setFinal();        assertTrue("Node set to final, not final.", node.isFinal());    }    public void testSynchronized() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not synchronized.", !node.isSynchronized());        node.setSynchronized();        assertTrue("Node set to synchronized, not synchronized.", node.isSynchronized());    }    public void testVolatile() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not volatile.", !node.isVolatile());        node.setVolatile();        assertTrue("Node set to volatile, not volatile.", node.isVolatile());    }    public void testTransient() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not transient.", !node.isTransient());        node.setTransient();        assertTrue("Node set to transient, not transient.", node.isTransient());    }    public void testNative() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not native.", !node.isNative());        node.setNative();        assertTrue("Node set to native, not native.", node.isNative());    }    public void testAbstract() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not abstract.", !node.isAbstract());        node.setAbstract();        assertTrue("Node set to abstract, not abstract.", node.isAbstract());    }    public void testStrict() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to not strict.", !node.isStrictfp());        node.setStrictfp();        assertTrue("Node set to strict, not strict.", node.isStrictfp());    }    public void testPackagePrivate() {        AccessNode node = new AccessNode(1);        assertTrue("Node should default to package private.", node.isPackagePrivate());        node.setPrivate();        assertTrue("Node set to private, still package private.", !node.isPackagePrivate());        node = new AccessNode(1);        node.setPublic();        assertTrue("Node set to public, still package private.", !node.isPackagePrivate());        node = new AccessNode(1);        node.setProtected();        assertTrue("Node set to protected, still package private.", !node.isPackagePrivate());    }}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import java.io.ByteArrayInputStream;import java.io.InputStreamReader;public class EncodingTest extends TestCase {    public void testDecodingOfUTF8() throws Throwable {        //String platformEncoding = System.getProperty("file.encoding");        //String encoding = "ISO-8859-1";        String encoding = "UTF-8";        String code = new String(TEST_UTF8.getBytes(), encoding);        InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(code.getBytes()));        //FIXME/*        ASTCompilationUnit acu = new TargetJDK1_4().createParser(isr).CompilationUnit();        String methodName = ((ASTMethodDeclarator)acu.findChildrenOfType(ASTMethodDeclarator.class).get(0)).getImage();        assertEquals(new String("é".getBytes(), encoding), methodName);*/    }    private static final String TEST_UTF8 =    "class Foo {" + PMD.EOL +    " void é() {}" + PMD.EOL +    " void fiddle() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTBooleanLiteral;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTBooleanLiteralTest extends ParserTst {    public void testTrue() throws Throwable {        Set ops = getNodes(ASTBooleanLiteral.class, TEST1);        ASTBooleanLiteral b = (ASTBooleanLiteral)ops.iterator().next();        assertTrue(b.isTrue());    }    public void testFalse() throws Throwable {        Set ops = getNodes(ASTBooleanLiteral.class, TEST2);        ASTBooleanLiteral b = (ASTBooleanLiteral)ops.iterator().next();        assertTrue(!b.isTrue());    }    private static final String TEST1 =    "class Foo { " + PMD.EOL +    " boolean bar = true; " + PMD.EOL +    "} ";    private static final String TEST2 =    "class Foo { " + PMD.EOL +    " boolean bar = false; " + PMD.EOL +    "} ";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTSwitchLabel;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTSwitchLabelTest extends ParserTst {    public void testDefaultOff() throws Throwable {        Set ops = getNodes(ASTSwitchLabel.class, TEST1);        assertFalse(((ASTSwitchLabel)(ops.iterator().next())).isDefault());    }    public void testDefaultSet() throws Throwable {        Set ops = getNodes(ASTSwitchLabel.class, TEST2);        assertTrue(((ASTSwitchLabel)(ops.iterator().next())).isDefault());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   case 1: y = 2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  switch (x) {" + PMD.EOL +    "   default: y = 2;" + PMD.EOL +    "  }" + PMD.EOL +    " }" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclarator;public class ASTMethodDeclarationTest extends TestCase {        public void testGetVariableName() {    int id = 0;    ASTMethodDeclaration md = new ASTMethodDeclaration(id++);    ASTMethodDeclarator de = new ASTMethodDeclarator(id++);    de.setImage("foo");    md.jjtAddChild(de, 0);        assertEquals("foo", md.getMethodName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTAssignmentOperator;import net.sourceforge.pmd.ast.ASTBlock;import net.sourceforge.pmd.ast.ASTBlockStatement;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTCompilationUnit;import net.sourceforge.pmd.ast.ASTEqualityExpression;import net.sourceforge.pmd.ast.ASTExpression;import net.sourceforge.pmd.ast.ASTExtendsList;import net.sourceforge.pmd.ast.ASTFieldDeclaration;import net.sourceforge.pmd.ast.ASTImplementsList;import net.sourceforge.pmd.ast.ASTInstanceOfExpression;import net.sourceforge.pmd.ast.ASTMethodDeclaration;import net.sourceforge.pmd.ast.ASTName;import net.sourceforge.pmd.ast.ASTRelationalExpression;import net.sourceforge.pmd.ast.ASTReturnStatement;import net.sourceforge.pmd.ast.ASTStatement;import net.sourceforge.pmd.ast.ASTVariableInitializer;import net.sourceforge.pmd.ast.Node;import net.sourceforge.pmd.ast.SimpleNode;import org.apache.xml.serialize.OutputFormat;import org.apache.xml.serialize.XMLSerializer;import org.w3c.dom.Document;import test.net.sourceforge.pmd.testframework.ParserTst;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Set;public class SimpleNodeTest extends ParserTst {    public void testMethodDiffLines() throws Throwable {        Set methods = getNodes(ASTMethodDeclaration.class, METHOD_DIFF_LINES);        Iterator iter = methods.iterator();        verifyNode((SimpleNode) iter.next(), 2, 9, 4, 2);    }    public void testMethodSameLine() throws Throwable {        Set methods = getNodes(ASTMethodDeclaration.class, METHOD_SAME_LINE);        verifyNode((SimpleNode) methods.iterator().next(), 2, 9, 2, 21);    }    public void testNoLookahead() throws Throwable {        String code = NO_LOOKAHEAD; // 1, 8 -> 1, 20        Set uCD = getNodes(ASTClassOrInterfaceDeclaration.class, code);        verifyNode((SimpleNode) uCD.iterator().next(), 1, 8, 1, 20);    }    public void testHasExplicitExtends() throws Throwable {        String code = HAS_EXPLICIT_EXTENDS;        ASTClassOrInterfaceDeclaration ucd = (ASTClassOrInterfaceDeclaration) (getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next());        assertTrue(ucd.jjtGetChild(0) instanceof ASTExtendsList);    }    public void testNoExplicitExtends() throws Throwable {        String code = NO_EXPLICIT_EXTENDS;        ASTClassOrInterfaceDeclaration ucd = (ASTClassOrInterfaceDeclaration) (getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next());        assertFalse(ucd.jjtGetChild(0) instanceof ASTExtendsList);    }    public void testHasExplicitImplements() throws Throwable {        String code = HAS_EXPLICIT_IMPLEMENTS;        ASTClassOrInterfaceDeclaration ucd = (ASTClassOrInterfaceDeclaration) (getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next());        assertTrue(ucd.jjtGetChild(0) instanceof ASTImplementsList);    }    public void testNoExplicitImplements() throws Throwable {        String code = NO_EXPLICIT_IMPLEMENTS;        ASTClassOrInterfaceDeclaration ucd = (ASTClassOrInterfaceDeclaration) (getNodes(ASTClassOrInterfaceDeclaration.class, code).iterator().next());        assertFalse(ucd.jjtGetChild(0) instanceof ASTImplementsList);    }    public void testColumnsOnQualifiedName() throws Throwable {        Set name = getNodes(ASTName.class, QUALIFIED_NAME);        Iterator i = name.iterator();        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 1, 19);            }        }    }    public void testLineNumbersForNameSplitOverTwoLines() throws Throwable {        Set name = getNodes(ASTName.class, BROKEN_LINE_IN_NAME);        Iterator i = name.iterator();        while (i.hasNext()) {            SimpleNode node = (SimpleNode) i.next();            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 2, 4);            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 18);            }        }    }    public void testLineNumbersAreSetOnAllSiblings() throws Throwable {        Set blocks = getNodes(ASTBlock.class, LINE_NUMBERS_ON_SIBLINGS);        Iterator i = blocks.iterator();        while (i.hasNext()) {            ASTBlock b = (ASTBlock) i.next();            assertTrue(b.getBeginLine() > 0);        }        blocks = getNodes(ASTVariableInitializer.class, LINE_NUMBERS_ON_SIBLINGS);        i = blocks.iterator();        while (i.hasNext()) {            ASTVariableInitializer b = (ASTVariableInitializer) i.next();            assertTrue(b.getBeginLine() > 0);        }        blocks = getNodes(ASTExpression.class, LINE_NUMBERS_ON_SIBLINGS);        i = blocks.iterator();        while (i.hasNext()) {            ASTExpression b = (ASTExpression) i.next();            assertTrue(b.getBeginLine() > 0);        }    }    public void testFindChildrenOfType() {        ASTBlock block = new ASTBlock(2);        block.jjtAddChild(new ASTReturnStatement(1), 0);        assertEquals(1, block.findChildrenOfType(ASTReturnStatement.class).size());    }    public void testFindChildrenOfTypeMultiple() {        ASTBlock block = new ASTBlock(1);        block.jjtAddChild(new ASTBlockStatement(2), 0);        block.jjtAddChild(new ASTBlockStatement(3), 1);        List nodes = new ArrayList();        block.findChildrenOfType(ASTBlockStatement.class, nodes);        assertEquals(2, nodes.size());    }    public void testFindChildrenOfTypeRecurse() {        ASTBlock block = new ASTBlock(1);        ASTBlock childBlock = new ASTBlock(2);        block.jjtAddChild(childBlock, 0);        childBlock.jjtAddChild(new ASTMethodDeclaration(3), 0);        List nodes = new ArrayList();        block.findChildrenOfType(ASTMethodDeclaration.class, nodes);        assertEquals(1, nodes.size());    }    public void testReplaceChild() {        ASTEqualityExpression ee = new ASTEqualityExpression(1);        ASTInstanceOfExpression io1 = new ASTInstanceOfExpression(2);        ASTRelationalExpression re = new ASTRelationalExpression(3);        ASTInstanceOfExpression io2 = new ASTInstanceOfExpression(2);        ee.jjtAddChild(io1, 0);        ee.jjtAddChild(io2, 1);        io1.jjtAddChild(re, 0);        ee.jjtReplaceChild(io1, re);        assertEquals(ee.jjtGetChild(0), re);        assertEquals(ee.jjtGetChild(1), io2);    }    public void testGetFirstChild() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstChildOfType(ASTStatement.class);        assertNotNull(n);        assertTrue(n instanceof ASTStatement);        assertEquals(x, n);    }    public void testGetFirstChildNested() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        x.jjtAddChild(x1, 1);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstChildOfType(ASTAssignmentOperator.class);        assertNotNull(n);        assertTrue(n instanceof ASTAssignmentOperator);        assertEquals(x1, n);    }    public void testGetFirstChildNestedDeeper() {        ASTBlock block = new ASTBlock(1);        ASTStatement x = new ASTStatement(2);        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);        ASTName x2 = new ASTName(5);        x.jjtAddChild(x1, 1);        x1.jjtAddChild(x2, 0);        block.jjtAddChild(x, 0);        block.jjtAddChild(new ASTStatement(3), 1);        Node n = block.getFirstChildOfType(ASTName.class);        assertNotNull(n);        assertTrue(n instanceof ASTName);        assertEquals(x2, n);    }/*    public void testContainsNoInner() throws Throwable {        ASTCompilationUnit c = (ASTCompilationUnit) getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER).iterator().next();        List res = new ArrayList();        c.findChildrenOfType(ASTFieldDeclaration.class, res, false);        assertTrue(res.isEmpty());        String expectedXml = "<CompilationUnit BeginColumn=\"1\" BeginLine=\"5\" EndColumn=\"1\" EndLine=\"5\">" +                "<TypeDeclaration BeginColumn=\"1\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">" +                "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"8\" BeginLine=\"1\" EndColumn=\"1\" " +                "EndLine=\"5\" Final=\"false\" Image=\"Test\" Interface=\"false\" Native=\"false\" Nested=\"false\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">" +                "<ClassOrInterfaceBody BeginColumn=\"19\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">" +                "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"3\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">" +                "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"10\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\" Final=\"false\" " +                "Image=\"Inner\" Interface=\"false\" Native=\"false\" Nested=\"true\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" " +                "Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">" +                "<ClassOrInterfaceBody BeginColumn=\"22\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">" +                "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\">" +                "<FieldDeclaration Abstract=\"false\" Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\" Final=\"false\" Native=\"false\" PackagePrivate=\"true\" Private=\"false\" Protected=\"false\" Public=\"false\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" VariableName=\"foo\" Volatile=\"false\"><Type Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"6\" EndLine=\"3\">" +                "<PrimitiveType Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" Boolean=\"false\" EndColumn=\"6\" EndLine=\"3\" Image=\"int\"/>" +                "</Type>" +                "<VariableDeclarator BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\">" +                "<VariableDeclaratorId Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\" ExceptionBlockParameter=\"false\" Image=\"foo\"/>" +                "</VariableDeclarator></FieldDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody>" +                "</ClassOrInterfaceDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody></ClassOrInterfaceDeclaration>" +                "</TypeDeclaration></CompilationUnit>";        assertEquals( expectedXml, getXmlString( c ) );    }*/    public void testContainsNoInnerWithAnonInner() throws Throwable {        ASTCompilationUnit c = (ASTCompilationUnit) getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER_WITH_ANON_INNER).iterator().next();        List res = new ArrayList();        c.findChildrenOfType(ASTFieldDeclaration.class, res, false);        assertTrue(res.isEmpty());    }    public void testContainsChildOfType() throws Throwable {        ASTClassOrInterfaceDeclaration c = (ASTClassOrInterfaceDeclaration) getNodes(ASTClassOrInterfaceDeclaration.class, CONTAINS_CHILDREN_OF_TYPE).iterator().next();        assertTrue(c.containsChildOfType(ASTFieldDeclaration.class));    }    public void testXPathNodeSelect() throws Throwable {        ASTClassOrInterfaceDeclaration c = (ASTClassOrInterfaceDeclaration) getNodes(ASTClassOrInterfaceDeclaration.class, TEST_XPATH).iterator().next();        List nodes = c.findChildNodesWithXPath("//FieldDeclaration");        assertEquals(2, nodes.size());        assertTrue(nodes.get(0) instanceof ASTFieldDeclaration);    }    private void verifyNode(SimpleNode node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Unexpected beginning line: ", beginLine, node.getBeginLine());        assertEquals("Unexpected beginning column: ", beginCol, node.getBeginColumn());        assertEquals("Unexpected ending line:", endLine, node.getEndLine());        assertEquals("Unexpected ending column:", endCol, node.getEndColumn());    }    private static final String HAS_EXPLICIT_EXTENDS =            "public class Test extends Foo {}";    private static final String NO_EXPLICIT_EXTENDS =            "public class Test {}";    private static final String HAS_EXPLICIT_IMPLEMENTS =            "public class Test implements Foo {}";    private static final String NO_EXPLICIT_IMPLEMENTS =            "public class Test {}";    private static final String METHOD_SAME_LINE =            "public class Test {" + PMD.EOL +            " public void foo() {}" + PMD.EOL +            "}";    private static final String QUALIFIED_NAME =            "import java.io.File;" + PMD.EOL +            "public class Foo{}";    private static final String BROKEN_LINE_IN_NAME =            "import java.io." + PMD.EOL +            "File;" + PMD.EOL +            "public class Foo{}";    private static final String LINE_NUMBERS_ON_SIBLINGS =            "public class Foo {" + PMD.EOL +            " void bar() {" + PMD.EOL +            "  try {" + PMD.EOL +            "  } catch (Exception1 e) {" + PMD.EOL +            "   int x =2;" + PMD.EOL +            "  }" + PMD.EOL +            " if (x != null) {}" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String NO_LOOKAHEAD = "public class Foo { }";    private static final String METHOD_DIFF_LINES =            "public class Test {" + PMD.EOL +            " public void foo() {" + PMD.EOL +            "  int x;" + PMD.EOL +            " }" + PMD.EOL +            "}";    private static final String CONTAINS_CHILDREN_OF_TYPE =            "public class Test {" + PMD.EOL +            "  int x;" + PMD.EOL +            "}";    private static final String CONTAINS_NO_INNER =            "public class Test {" + PMD.EOL +            "  public class Inner {" + PMD.EOL +            "   int foo;" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String CONTAINS_NO_INNER_WITH_ANON_INNER =            "public class Test {" + PMD.EOL +            "  void bar() {" + PMD.EOL +            "   foo(new Fuz() { int x = 2;});" + PMD.EOL +            "  }" + PMD.EOL +            "}";    private static final String TEST_XPATH =            "public class Test {" + PMD.EOL +            "  int x = 2;" + PMD.EOL +            "  int y = 42;" + PMD.EOL +            "}";}
package test.net.sourceforge.pmd.ast;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.TargetJDK1_3;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.TargetJDKVersion;import net.sourceforge.pmd.ast.JavaParser;import net.sourceforge.pmd.ast.ParseException;import java.io.StringReader;public class JDKVersionTest extends TestCase  {    // enum keyword/identifier    public void testEnumAsKeywordShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_ENUM));            p.CompilationUnit();            throw new Error("JDK 1.4 parser should have failed to parse enum used as keyword");        } catch (ParseException e) {}    // cool    }    public void testEnumAsIdentifierShouldPassWith14() throws Throwable {        JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK14_ENUM));        p.CompilationUnit();    }    public void testEnumAsKeywordShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_ENUM));        p.CompilationUnit();    }    public void testEnumAsIdentifierShouldFailWith15() throws Throwable {        try {            TargetJDKVersion jdk = new TargetJDK1_5();            JavaParser p = jdk.createParser(new StringReader(JDK14_ENUM));            p.CompilationUnit();            throw new Error("JDK 1.5 parser should have failed to parse enum used as identifier");        } catch (ParseException e) {}    // cool    }    // enum keyword/identifier    // assert keyword/identifier    public void testAssertAsKeywordVariantsSucceedWith1_4() {        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST1)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST2)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST3)).CompilationUnit();        (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST4)).CompilationUnit();    }    public void testAssertAsVariableDeclIdentifierFailsWith1_4() {        try {            (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST5)).CompilationUnit();            throw new RuntimeException("Usage of assert as identifier should have failed with 1.4");        } catch (ParseException pe) {            // cool        }    }    public void testAssertAsMethodNameIdentifierFailsWith1_4() {        try {            (new TargetJDK1_4()).createParser(new StringReader(ASSERT_TEST7)).CompilationUnit();            throw new RuntimeException("Usage of assert as identifier should have failed with 1.4");        } catch (ParseException pe) {            // cool        }    }    public void testAssertAsIdentifierSucceedsWith1_3() {        JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST5));        jp.CompilationUnit();    }    public void testAssertAsKeywordFailsWith1_3() {        try {            JavaParser jp = (new TargetJDK1_3()).createParser(new StringReader(ASSERT_TEST6));            jp.CompilationUnit();            throw new RuntimeException("Usage of assert as keyword should have failed with 1.3");        } catch (ParseException pe) {            // cool        }    }    // assert keyword/identifier    public void testVarargsShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_VARARGS));        p.CompilationUnit();    }    public void testVarargsShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_VARARGS));            p.CompilationUnit();            fail("Should have throw ParseException!");        } catch (ParseException pe) {            // cool        }    }    public void testJDK15ForLoopSyntaxShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_FORLOOP));        p.CompilationUnit();    }    public void testJDK15ForLoopSyntaxWithModifiers() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_FORLOOP_WITH_MODIFIER));        p.CompilationUnit();    }    public void testJDK15ForLoopShouldFailWith14() throws Throwable {        try {            JavaParser p = new TargetJDK1_4().createParser(new StringReader(JDK15_FORLOOP));            p.CompilationUnit();            fail("Should have throw ParseException!");        } catch (ParseException pe) {            // cool        }    }    public void testJDK15GenericsSyntaxShouldPassWith15() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(JDK15_GENERICS));        p.CompilationUnit();    }    public void testVariousParserBugs() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(FIELDS_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(GT_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(ANNOTATIONS_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(GENERIC_IN_FIELD));        p.CompilationUnit();    }    public void testNestedClassInMethodBug() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(INNER_BUG));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(INNER_BUG2));        p.CompilationUnit();    }    public void testGenericsInMethodCall() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(GENERIC_IN_METHOD_CALL));        p.CompilationUnit();    }    public void testGenericINAnnotation() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(GENERIC_IN_ANNOTATION));        p.CompilationUnit();    }    public void testGenericReturnType() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(GENERIC_RETURN_TYPE));        p.CompilationUnit();    }    public void testMultipleGenerics() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(FUNKY_GENERICS));        p.CompilationUnit();        p = new TargetJDK1_5().createParser(new StringReader(MULTIPLE_GENERICS));        p.CompilationUnit();    }    public void testAnnotatedParams() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(ANNOTATED_PARAMS));        p.CompilationUnit();    }    public void testAnnotatedLocals() throws Throwable {        JavaParser p = new TargetJDK1_5().createParser(new StringReader(ANNOTATED_LOCALS));        p.CompilationUnit();    }    private static final String ANNOTATED_LOCALS =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  @SuppressWarnings(\"foo\") int y = 5;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ANNOTATED_PARAMS =    "public class Foo {" + PMD.EOL +    " void bar(@SuppressWarnings(\"foo\") int x) {}" + PMD.EOL +    "}";    private static final String ASSERT_TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert x == 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert (x == 2);" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert (x==2) : \"hi!\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST4 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  assert (x==2) : \"hi!\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST5 =    "public class Foo {" + PMD.EOL +    "  int assert = 2;" + PMD.EOL +    "}";    private static final String ASSERT_TEST6 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  assert (x == 2) : \"hi!\";" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String ASSERT_TEST7 =    "public class Foo {" + PMD.EOL +    " void assert() {}" + PMD.EOL +    "}";    private static final String JDK15_ENUM =    "public class Test {" + PMD.EOL +    " enum Season { winter, spring, summer, fall };" + PMD.EOL +    "}";    private static final String JDK14_ENUM =    "public class Test {" + PMD.EOL +    " int enum;" + PMD.EOL +    "}";    private static final String JDK15_VARARGS =    "public class Test {" + PMD.EOL +    " void bar(Object ... args) {}" + PMD.EOL +    "}";    private static final String JDK15_FORLOOP =    "public class Test {" + PMD.EOL +    " void foo(List list) {" + PMD.EOL +    "  for (Integer i : list) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String JDK15_FORLOOP_WITH_MODIFIER =    "public class Test {" + PMD.EOL +    " void foo(List list) {" + PMD.EOL +    "  for (final Integer i : list) {}" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String JDK15_GENERICS =    "public class Test {" + PMD.EOL +    "  ArrayList<Integer> list =  new ArrayList<Integer>();" + PMD.EOL +    "}";    private static final String FIELDS_BUG =    "public class Test {" + PMD.EOL +    "  private Foo bar;" + PMD.EOL +    "}";    private static final String GT_BUG =    "public class Test {" + PMD.EOL +    "  int y = x > 32;" + PMD.EOL +    "}";    private static final String ANNOTATIONS_BUG =    "@Target(ElementType.METHOD)" + PMD.EOL +    "public @interface Foo {" + PMD.EOL +    "}";    private static final String GENERIC_IN_FIELD =    "public class Foo {" + PMD.EOL +    " Class<Double> foo = (Class<Double>)clazz;" + PMD.EOL +    "}";    private static final String GENERIC_IN_ANNOTATION =    "public class Foo {" + PMD.EOL +    " public <A extends Annotation> A foo(Class<A> c) {"  + PMD.EOL +    "  return null;"  + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String INNER_BUG =    "public class Test {" + PMD.EOL +    "  void bar() {" + PMD.EOL +    "   final class Inner {};" + PMD.EOL +    "   Inner i = new Inner();" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String INNER_BUG2 =    "public class Test {" + PMD.EOL +    "  void bar() {" + PMD.EOL +    "   class Inner {};" + PMD.EOL +    "   Inner i = new Inner();" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String GENERIC_IN_METHOD_CALL =    "public class Test {" + PMD.EOL +    "  List<String> test() {" + PMD.EOL +    "   return Collections.<String>emptyList();" + PMD.EOL +    "  }" + PMD.EOL +    "}";    private static final String GENERIC_RETURN_TYPE =    "public class Test {" + PMD.EOL +    "  public static <String> String test(String x) {" + PMD.EOL +    "   return x;" + PMD.EOL +    "  }" + PMD.EOL +    "}";    // See java/lang/concurrent/ConcurrentHashMap    private static final String MULTIPLE_GENERICS =    "public class Foo<K,V> {" + PMD.EOL +    "  public <A extends K, B extends V> Foo(Bar<A,B> t) {}" + PMD.EOL +    "}";    // See java/lang/concurrent/CopyOnWriteArraySet    private static final String FUNKY_GENERICS =    "public class Foo {" + PMD.EOL +    "  public <T extends E> Foo() {}" + PMD.EOL +    "}";}
package test.net.sourceforge.pmd.ast;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.ast.ASTAssignmentOperator;import test.net.sourceforge.pmd.testframework.ParserTst;import java.util.Set;public class ASTAssignmentOperatorTest extends ParserTst {    public void testSimpleAssignmentRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST1);        assertTrue(!((ASTAssignmentOperator)(ops.iterator().next())).isCompound());    }    public void testCompoundAssignmentPlusRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST2);        assertTrue(((ASTAssignmentOperator)(ops.iterator().next())).isCompound());    }    public void testCompoundAssignmentMultRecognized() throws Throwable {        Set ops = super.getNodes(ASTAssignmentOperator.class, TEST3);        assertTrue(((ASTAssignmentOperator)(ops.iterator().next())).isCompound());    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x;" + PMD.EOL +    "  x=2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x;" + PMD.EOL +    "  x += 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void bar() {" + PMD.EOL +    "  int x;" + PMD.EOL +    "  x *= 2;" + PMD.EOL +    " }" + PMD.EOL +    "}";}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.ExternalRuleID;public class ExternalRuleIDTest extends TestCase {    public void testSimpleRef() {        String xrefString = "rulesets/basic.xml/EmptyCatchBlock";        ExternalRuleID xref = new ExternalRuleID(xrefString);        assertEquals("Filename mismatch!", "rulesets/basic.xml", xref.getFilename());        assertEquals("Rule name mismatch!", "EmptyCatchBlock", xref.getRuleName());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.CommandLineOptions;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.EmacsRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.IDEAJRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.VBHTMLRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;import java.io.InputStreamReader;public class CommandLineOptionsTest extends TestCase {    public void testTargetJDKVersion() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic"});        assertEquals("1.4", opt.getTargetJDK());        opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-targetjdk", "1.3"});        assertEquals("1.3", opt.getTargetJDK());        opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-targetjdk", "1.5"});        assertEquals("1.5", opt.getTargetJDK());    }    public void testDebug() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic", "-debug"});        assertTrue(opt.debugEnabled());    }    public void testExcludeMarker() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic", "-excludemarker", "FOOBAR"});        assertEquals("FOOBAR", opt.getExcludeMarker());    }    public void testShortNames() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic", "-shortnames"});        assertTrue(opt.shortNamesEnabled());    }    public void testEncoding() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic"});        assertTrue(opt.getEncoding().equals((new InputStreamReader(System.in)).getEncoding()));        opt = new CommandLineOptions(new String[] {"file", "format", "ruleset", "-encoding", "UTF-8"});        assertTrue(opt.getEncoding().equals("UTF-8"));    }    public void testInputFileName() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic"});        assertEquals("file", opt.getInputPath());    }    public void testReportFormat() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic"});        assertEquals("format", opt.getReportFormat());    }    public void testRulesets() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "format", "basic"});        assertEquals("rulesets/basic.xml", opt.getRulesets());    }    public void testCommaSeparatedFiles() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file1,file2,file3", "format", "basic"});        assertTrue(opt.containsCommaSeparatedFileList());    }    public void testNotEnoughArgs() {        try {            new CommandLineOptions(new String[] {"file1", "format"});            fail("Should have thrown an exception when only array contained < 3 args");        } catch (RuntimeException re) {            // cool        }    }    public void testNullArgs() {        try {            new CommandLineOptions(null);            fail("Should have thrown an exception when null passed to constructor");        } catch (RuntimeException re) {            // cool        }    }    public void testRenderer() {        CommandLineOptions opt = new CommandLineOptions(new String[] {"file", "xml", "basic"});        assertTrue(opt.createRenderer() instanceof XMLRenderer);        opt = new CommandLineOptions(new String[] {"file", "html", "basic"});        assertTrue(opt.createRenderer() instanceof HTMLRenderer);        opt = new CommandLineOptions(new String[] {"file", "text", "basic"});        assertTrue(opt.createRenderer() instanceof TextRenderer);        opt = new CommandLineOptions(new String[] {"file", "emacs", "basic"});        assertTrue(opt.createRenderer() instanceof EmacsRenderer);        opt = new CommandLineOptions(new String[] {"file", "csv", "basic"});        assertTrue(opt.createRenderer() instanceof CSVRenderer);        opt = new CommandLineOptions(new String[] {"file", "vbhtml", "basic"});        assertTrue(opt.createRenderer() instanceof VBHTMLRenderer);        opt = new CommandLineOptions(new String[] {"file", "ideaj", "basic"});        assertTrue(opt.createRenderer() instanceof IDEAJRenderer);        try {            opt = new CommandLineOptions(new String[] {"file", "fiddlefaddle", "basic"});            opt.createRenderer();        } catch (IllegalArgumentException iae) {            // cool        }        try {            opt = new CommandLineOptions(new String[] {"file", "", "basic"});            opt.createRenderer();        } catch (IllegalArgumentException iae) {            // cool        }    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;public class ReadableDurationTest extends TestCase{    public void testMillisSeconds() {        assertEquals("0s", new Report.ReadableDuration(35).getTime());    }    public void testSeconds() {        assertEquals("25s", new Report.ReadableDuration(25 * 1000).getTime());    }    public void testWholeMinutes() {        assertEquals("5m 0s", new Report.ReadableDuration(60 * 1000 * 5).getTime());    }    public void testMinutesAndSeconds() {        assertEquals("5m 10s", new Report.ReadableDuration((60 * 1000 * 5) + (1000 * 10)).getTime());    }    public void testHours() {        assertEquals("2h 0m 0s", new Report.ReadableDuration(60 * 1000 * 120).getTime());    }}
package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.SimpleRuleSetNameMapper;public class SimpleRuleSetNameMapperTest extends TestCase{    public void testMultipleSimple() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("unusedcode,basic");        assertEquals("rulesets/unusedcode.xml,rulesets/basic.xml", s.getRuleSets());    }    public void testOneSimple() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("basic");        assertEquals("rulesets/basic.xml", s.getRuleSets());    }    public void testMultipleRegular() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("rulesets/unusedcode.xml,rulesets/basic.xml");        assertEquals("rulesets/unusedcode.xml,rulesets/basic.xml", s.getRuleSets());    }    public void testOneRegular() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("rulesets/unusedcode.xml");        assertEquals("rulesets/unusedcode.xml", s.getRuleSets());    }    public void testMix() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("rulesets/unusedcode.xml,basic");        assertEquals("rulesets/unusedcode.xml,rulesets/basic.xml", s.getRuleSets());    }    public void testUnknown() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("favorites.xml");        assertEquals("favorites.xml", s.getRuleSets());    }    public void testUnknownAndSimple() {        SimpleRuleSetNameMapper s = new SimpleRuleSetNameMapper("basic,favorites.xml");        assertEquals("rulesets/basic.xml,favorites.xml", s.getRuleSets());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.ast.SimpleNode;import net.sourceforge.pmd.symboltable.SourceFileScope;import java.util.HashSet;import java.util.Set;public class AbstractRuleTest extends TestCase {    private static class MyRule extends AbstractRule{        public MyRule() {            setName("MyRule");            setMessage("my rule");            setPriority(3);            addProperty("foo", "value");        }    }    private static class MyOtherRule extends AbstractRule{        public MyOtherRule() {            setName("MyOtherRule");            setMessage("my other rule");            setPriority(3);            addProperty("foo", "value");        }    }    public AbstractRuleTest(String name) {        super(name);    }    public void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleNode(1);        s.testingOnly__setBeginColumn(5);        s.testingOnly__setBeginLine(5);        s.setScope(new SourceFileScope("foo"));        RuleViolation rv = r.createRuleViolation(ctx, s);        assertEquals("Line number mismatch!", 5, rv.getLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "my rule", rv.getDescription());        assertEquals("RuleSet name mismatch!", "foo", rv.getRule().getRuleSetName());    }    public void testCreateRV2() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        SimpleNode s = new SimpleNode(1);        s.testingOnly__setBeginColumn(5);        s.testingOnly__setBeginLine(5);        s.setScope(new SourceFileScope("foo"));        RuleViolation rv = r.createRuleViolation(ctx, s, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }    public void testRuleExclusion() {        MyRule r = new MyRule();        RuleContext ctx = new RuleContext();        Set s = new HashSet();        s.add(new Integer(5));        ctx.setReport(new Report());        ctx.excludeLines(s);        ctx.setSourceCodeFilename("filename");        SimpleNode n = new SimpleNode(1);        n.testingOnly__setBeginColumn(5);        n.testingOnly__setBeginLine(5);        n.setScope(new SourceFileScope("foo"));        r.createRuleViolation(ctx, n, "specificdescription");        assertTrue(ctx.getReport().isEmpty());    }        public void testEquals1() {        MyRule r = new MyRule();        assertFalse("A rule is never equals to null!", r.equals(null));    }        public void testEquals2() {        MyRule r = new MyRule();        assertEquals("A rule must be equals to itself", r, r);    }        public void testEquals3() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        assertEquals("2 instances of the same rule are equals", r1, r2);        assertEquals("hasCode for 2 instances of the same rule must be equals", r1.hashCode(), r2.hashCode());    }        public void testEquals4() {        MyRule myRule = new MyRule();        assertFalse("A rule cannot be equals to an object of another class", myRule.equals("MyRule"));    }        public void testEquals5() {        MyRule myRule = new MyRule();        MyOtherRule myOtherRule = new MyOtherRule();        assertFalse("2 rules of different classes cannot be equals", myRule.equals(myOtherRule));        assertFalse("Rules that are not equals should not have the same hashcode", myRule.hashCode() == myOtherRule.hashCode());    }        public void testEquals6() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setName("MyRule2");        assertFalse("Rules with different names cannot be equals", r1.equals(r2));        assertFalse("Rules that are not equals should not have the same hashcode", r1.hashCode() == r2.hashCode());    }        public void testEquals7() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setPriority(1);        assertFalse("Rules with different priority cannot be equals", r1.equals(r2));        assertFalse("Rules that are not equals should not have the same hashcode", r1.hashCode() == r2.hashCode());    }        public void testEquals8() {        MyRule r1 = new MyRule();        r1.addProperty("xpath", "something");        MyRule r2 = new MyRule();        r2.addProperty("xpath", "something else");        assertFalse("Rules with different properties values cannot be equals", r1.equals(r2));        assertFalse("Rules that are not equals should not have the same hashcode", r1.hashCode() == r2.hashCode());    }        public void testEquals9() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.addProperty("xpath", "something else");        assertFalse("Rules with different properties cannot be equals", r1.equals(r2));        assertFalse("Rules that are not equals should not have the same hashcode", r1.hashCode() == r2.hashCode());    }        public void testEquals10() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setMessage("another message");        assertTrue("Rules with different message are still equals", r1.equals(r2));        assertTrue("Rules that are equals must have the same hashcode", r1.hashCode() == r2.hashCode());    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.ast.JavaParser;import test.net.sourceforge.pmd.testframework.MockRule;import java.io.StringReader;import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;public class RuleSetTest extends TestCase {    private String javaCode = "public class Test { }";    public void testNoDFA() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertFalse(rs.usesDFA());    }    public void testIncludesRuleWithDFA() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        mock.setUsesDFA();        rs.addRule(mock);        assertTrue(rs.usesDFA());    }    public void testAccessors() {        RuleSet rs = new RuleSet();        rs.setName("foo");        assertEquals("name mismatch", "foo", rs.getName());        rs.setDescription("bar");        assertEquals("description mismatch", "bar", rs.getDescription());    }    public void testGetRuleByName() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    public void testGetRuleByName2() {        RuleSet rs = new RuleSet();        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        rs.addRule(mock);        assertNull("the rule FooRule must not be found!", rs.getRuleByName("FooRule"));    }    public void testRuleList() {        RuleSet IUT = new RuleSet();        assertEquals("Size of RuleSet isn't zero.", 0, IUT.size());        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        IUT.addRule(rule);        assertEquals("Size of RuleSet isn't one.", 1, IUT.size());        Set rules = IUT.getRules();        Iterator i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    public void testAddRuleSet() {        RuleSet set1 = new RuleSet();        set1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet set2 = new RuleSet();        set2.addRule(new MockRule("name2", "desc", "msg", "rulesetname"));        set1.addRuleSet(set2);        assertEquals("ruleset size wrong", 2, set1.size());    }    public void testApply0Rules() throws Throwable {        RuleSet IUT = new RuleSet();        verifyRuleSet(IUT, 0, new HashSet());    }        public void testEquals1() {        RuleSet s = new RuleSet();        assertFalse("A ruleset cannot be equals to null", s.equals(null));    }        public void testEquals2() {        RuleSet s = new RuleSet();        assertTrue("A rulset must be equals to itself", s.equals(s));    }        public void testEquals3() {        RuleSet s = new RuleSet();        s.setName("basic rules");        assertFalse("A ruleset cannot be equals to another kind of object", s.equals("basic rules"));    }        public void testEquals4() {        RuleSet s1 = new RuleSet();        s1.setName("my ruleset");        s1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet s2 = new RuleSet();        s2.setName("my ruleset");        s2.addRule(new MockRule("name", "desc", "msg", "rulesetname"));                assertEquals("2 rulesets with same name and rules must be equals", s1, s2);        assertEquals("Equals rulesets must have the same hashcode", s1.hashCode(), s2.hashCode());    }        public void testEquals5() {        RuleSet s1 = new RuleSet();        s1.setName("my ruleset");        s1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet s2 = new RuleSet();        s2.setName("my other ruleset");        s2.addRule(new MockRule("name", "desc", "msg", "rulesetname"));                assertFalse("2 rulesets with different name but same rules must not be equals", s1.equals(s2));        assertFalse("Rulesets that are not equals should not have the same hashcode", s1.hashCode() == s2.hashCode());    }        public void testEquals6() {        RuleSet s1 = new RuleSet();        s1.setName("my ruleset");        s1.addRule(new MockRule("name", "desc", "msg", "rulesetname"));        RuleSet s2 = new RuleSet();        s2.setName("my ruleset");        s2.addRule(new MockRule("other rule", "desc", "msg", "rulesetname"));                assertFalse("2 rulesets with same name but different rules must not be equals", s1.equals(s2));        assertFalse("Rulesets that are not equals should not have the same hashcode", s1.hashCode() == s2.hashCode());    }    protected void verifyRuleSet(RuleSet IUT, int size, Set values) throws Throwable {        RuleContext context = new RuleContext();        Set reportedValues = new HashSet();        context.setReport(new Report());        IUT.apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().size());        Iterator violations = context.getReport().iterator();        while (violations.hasNext()) {            RuleViolation violation = (RuleViolation) violations.next();            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        Iterator expected = values.iterator();        while (expected.hasNext()) {            RuleViolation violation = (RuleViolation) expected.next();            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    protected List makeCompilationUnits() throws Throwable {        List RC = new ArrayList();        JavaParser parser = (new TargetJDK1_4()).createParser(new StringReader(javaCode));        RC.add(parser.CompilationUnit());        return RC;    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportListener;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;import net.sourceforge.pmd.stat.Metric;import test.net.sourceforge.pmd.testframework.MockRule;import java.util.Iterator;import java.util.Map;public class ReportTest extends TestCase implements ReportListener {    private boolean violationSemaphore;    private boolean metricSemaphore;    public void testBasic() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 5, ctx, "package", "class", "method"));        assertTrue(!r.isEmpty());    }    public void testMetric0() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());    }    public void testMetric1() {        Report r = new Report();        assertTrue("Default report shouldn't contain metrics", !r.hasMetrics());        r.addMetric(new Metric("m1", 0, 0.0, 1.0, 2.0, 3.0, 4.0));        assertTrue("Expected metrics weren't there", r.hasMetrics());        Iterator ms = r.metrics();        assertTrue("Should have some metrics in there now", ms.hasNext());        Object o = ms.next();        assertTrue("Expected Metric, got " + o.getClass(), o instanceof Metric);        Metric m = (Metric) o;        assertEquals("metric name mismatch", "m1", m.getMetricName());        assertEquals("wrong low value", 1.0, m.getLowValue(), 0.05);        assertEquals("wrong high value", 2.0, m.getHighValue(), 0.05);        assertEquals("wrong avg value", 3.0, m.getAverage(), 0.05);        assertEquals("wrong std dev value", 4.0, m.getStandardDeviation(), 0.05);    }    // Files are grouped together now.    public void testSortedReport_File() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 10, ctx, "package", "class", "method"));        ctx.setSourceCodeFilename("bar");        r.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 20, ctx, "package", "class", "method"));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    public void testSortedReport_Line() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        r.addRuleViolation(new RuleViolation(new MockRule("rule2", "rule2", "msg", "rulesetname"), 10, ctx, "package", "class", "method"));        ctx.setSourceCodeFilename("foo2");        r.addRuleViolation(new RuleViolation(new MockRule("rule1", "rule1", "msg", "rulesetname"), 20, ctx, "package", "class", "method"));        Renderer rend = new XMLRenderer();        String result = rend.render(r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    public void testListener() {        Report rpt = new Report();        rpt.addListener(this);        violationSemaphore = false;        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("file");        rpt.addRuleViolation(new RuleViolation(new MockRule("name", "desc", "msg", "rulesetname"), 5, ctx, "package", "class", "method"));        assertTrue(violationSemaphore);        metricSemaphore = false;        rpt.addMetric(new Metric("test", 0, 0.0, 0.0, 0.0, 0.0, 0.0));        assertTrue("no metric", metricSemaphore);    }    public void ruleViolationAdded(RuleViolation ruleViolation) {        violationSemaphore = true;    }    public void metricAdded(Metric metric) {        metricSemaphore = true;    }    public void testSummary() {        Report r = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("foo1");        r.addRuleViolation(new RuleViolation(new MockRule("rule2", "rule2", "msg", "rulesetname"), 10, ctx, "package", "class", "method"));        ctx.setSourceCodeFilename("foo2");        Rule mr = new MockRule("rule1", "rule1", "msg", "rulesetname");        r.addRuleViolation(new RuleViolation(mr, 20, ctx, "package", "class", "method"));        r.addRuleViolation(new RuleViolation(mr, 30, ctx, "package", "class", "method"));        Map summary = r.getSummary();        assertEquals(summary.keySet().size(), 2);        assertTrue(summary.values().contains(new Integer(1)));        assertTrue(summary.values().contains(new Integer(2)));    }}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.util.ResourceLoader;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class RuleSetFactoryTest extends TestCase {    public void testRefs() throws Throwable {        InputStream in = ResourceLoader.loadResourceAsStream("rulesets/favorites.xml", this.getClass().getClassLoader());        if (in == null) {            throw new RuleSetNotFoundException("Can't find resource   Make sure the resource is a valid file or URL or is on the CLASSPATH.  Here's the current classpath: " + System.getProperty("java.class.path"));        }        RuleSetFactory rsf = new RuleSetFactory();        RuleSet rs = rsf.createRuleSet("rulesets/favorites.xml");        assertNotNull(rs.getRuleByName("WhileLoopsMustUseBraces"));    }    public void testRuleSetNotFound() {        RuleSetFactory rsf = new RuleSetFactory();        try {            rsf.createRuleSet("fooooo");            fail("Should have thrown a RuleSetNotFoundException");        } catch (RuleSetNotFoundException rsnfe) {            // cool        }    }    public void testCreateEmptyRuleSet() {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    public void testSingleRule() {        RuleSet rs = loadRuleSet(SINGLE_RULE);        assertEquals(1, rs.size());        Rule r = (Rule)rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("avoid the mock rule", r.getMessage());    }    public void testMultipleRules() {        RuleSet rs = loadRuleSet(MULTIPLE_RULES);        assertEquals(2, rs.size());        Set expected = new HashSet();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Iterator i = rs.getRules().iterator(); i.hasNext();) {            assertTrue(expected.contains(((Rule) i.next()).getName()));        }    }    public void testSingleRuleWithPriority() {        assertEquals(3, loadFirstRule(PRIORITY).getPriority());    }    public void testProps() {        Rule r = loadFirstRule(PROPERTIES);        assertTrue(r.hasProperty("foo"));        assertEquals("bar", r.getStringProperty("foo"));        assertEquals(2, r.getIntProperty("fooint"));        assertTrue(r.hasProperty("fooBoolean"));        assertTrue(r.getBooleanProperty("fooBoolean"));        assertTrue(r.hasProperty("fooDouble"));        assertEquals(1.0, r.getDoubleProperty("fooDouble"), 0.05);        assertTrue(!r.hasProperty("BuggleFish"));        assertTrue(r.getDescription().indexOf("testdesc2") != -1);    }    public void testXPathPluginnameProperty() {        Rule r = loadFirstRule(XPATH_PLUGINNAME);        assertTrue(r.hasProperty("pluginname"));    }    public void testXPath() {        Rule r = loadFirstRule(XPATH);        assertTrue(r.hasProperty("xpath"));        assertTrue(r.getStringProperty("xpath").indexOf(" //Block ") != -1);    }    public void testFacadesOffByDefault() {        Rule r = loadFirstRule(XPATH);        assertFalse(r.usesDFA());    }    public void testDFAFlag() {        assertTrue(loadFirstRule(DFA).usesDFA());    }    public void testExternalReferenceOverride() {        Rule r = loadFirstRule(REF_OVERRIDE);        assertEquals("TestNameOverride", r.getName());        assertEquals("Test message override", r.getMessage());        assertEquals("Test description override", r.getDescription());        assertEquals("Test example override", r.getExample());        assertEquals(3, r.getPriority());        assertTrue(r.hasProperty("test2"));        assertEquals("override2", r.getStringProperty("test2"));        assertTrue(r.hasProperty("test3"));        assertEquals("override3", r.getStringProperty("test3"));        assertTrue(r.hasProperty("test4"));        assertEquals("new property", r.getStringProperty("test4"));    }    public void testOverrideMessage() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);        assertEquals("TestMessageOverride", r.getMessage());    }    public void testOverrideMessageOneElem() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);        assertEquals("TestMessageOverride", r.getMessage());    }    public void testExternalRef() {        try {            loadFirstRule(REF_MISPELLED_XREF);            fail("Whoa, should have gotten an IllegalArgumentException");        } catch (IllegalArgumentException iae) {            // cool        }    }    private static final String REF_OVERRIDE_ORIGINAL_NAME =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule " + PMD.EOL +            "  ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\" message=\"TestMessageOverride\"> " + PMD.EOL +            " </rule>" + PMD.EOL +            "</ruleset>";    private static final String REF_MISPELLED_XREF =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule " + PMD.EOL +            "  ref=\"rulesets/unusedcode.xml/FooUnusedLocalVariable\"> " + PMD.EOL +            " </rule>" + PMD.EOL +            "</ruleset>";    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\" message=\"TestMessageOverride\"/> " + PMD.EOL +            "</ruleset>";    private static final String REF_OVERRIDE =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            " <description>testdesc</description>" + PMD.EOL +            " <rule " + PMD.EOL +            "  ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\" " + PMD.EOL +            "  name=\"TestNameOverride\" " + PMD.EOL +            "  message=\"Test message override\"> " + PMD.EOL +            "  <description>Test description override</description>" + PMD.EOL +            "  <example>Test example override</example>" + PMD.EOL +            "  <priority>3</priority>" + PMD.EOL +            "  <properties>" + PMD.EOL +            "   <property name=\"test2\" value=\"override2\"/>" + PMD.EOL +            "   <property name=\"test3\"><value>override3</value></property>" + PMD.EOL +            "   <property name=\"test4\" value=\"new property\"/>" + PMD.EOL +            "  </properties>" + PMD.EOL +            " </rule>" + PMD.EOL +            "</ruleset>";    private static final String EMPTY_RULESET =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "</ruleset>";    private static final String SINGLE_RULE =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "</rule></ruleset>";    private static final String MULTIPLE_RULES =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule name=\"MockRuleName1\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "</rule>" + PMD.EOL +            "<rule name=\"MockRuleName2\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "</rule></ruleset>";    private static final String PROPERTIES =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"fooBoolean\" value=\"true\"/>" + PMD.EOL +            "<property name=\"fooDouble\" value=\"1.0\" />" + PMD.EOL +            "<property name=\"foo\" value=\"bar\"/>" + PMD.EOL +            "<property name=\"fooint\" value=\"2\"/>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String XPATH =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<priority>3</priority>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"xpath\">" + PMD.EOL +            "<value>" + PMD.EOL +            "<![CDATA[ //Block ]]>" + PMD.EOL +            "</value>" + PMD.EOL +            "</property>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String XPATH_PLUGINNAME =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<priority>3</priority>" + PMD.EOL +            "<rule name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" + PMD.EOL +            "<description>testdesc2</description>" + PMD.EOL +            "<properties>" + PMD.EOL +            "<property name=\"xpath\" pluginname=\"true\">" + PMD.EOL +            "<value>" + PMD.EOL +            "<![CDATA[ //Block ]]>" + PMD.EOL +            "</value>" + PMD.EOL +            "</property>" + PMD.EOL +            "</properties>" + PMD.EOL +            "</rule></ruleset>";    private static final String PRIORITY =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "<priority>3</priority>" + PMD.EOL +            "</rule></ruleset>";    private static final String DFA =            "<?xml version=\"1.0\"?>" + PMD.EOL +            "<ruleset name=\"test\">" + PMD.EOL +            "<description>testdesc</description>" + PMD.EOL +            "<rule " + PMD.EOL +            "name=\"MockRuleName\" " + PMD.EOL +            "message=\"avoid the mock rule\" " + PMD.EOL +            "dfa=\"true\" " + PMD.EOL +            "class=\"test.net.sourceforge.pmd.testframework.MockRule\">" +            "<priority>3</priority>" + PMD.EOL +            "</rule></ruleset>";    private Rule loadFirstRule(String ruleSetName) {        RuleSet rs = loadRuleSet(ruleSetName);        return ((Rule)(rs.getRules().iterator().next()));    }    private RuleSet loadRuleSet(String ruleSetName) {        RuleSetFactory rsf = new RuleSetFactory();        return rsf.createRuleSet(new ByteArrayInputStream(ruleSetName.getBytes()));    }/*    public void testExternalReferences() {        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);        assertEquals(1, rs.size());        assertEquals(UnusedLocalVariableRule.class, rs.getRuleByName("UnusedLocalVariable").getClass());    }        private static final String EXTERNAL_REFERENCE_RULE_SET =                "<?xml version=\"1.0\"?>" + PMD.EOL +                "<ruleset name=\"test\">" + PMD.EOL +                "<description>testdesc</description>" + PMD.EOL +                "<rule ref=\"rulesets/unusedcode.xml/UnusedLocalVariable\"/>" + PMD.EOL +                "</ruleset>";*/}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;public class RuleContextTest extends TestCase {    public void testReport() {        RuleContext ctx = new RuleContext();        assertEquals(0, ctx.getReport().size());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    public void testFilename() {        RuleContext ctx = new RuleContext();        assertNull("filename should be null", ctx.getSourceCodeFilename());        ctx.setSourceCodeFilename("foo");        assertEquals("filename mismatch", "foo", ctx.getSourceCodeFilename());    }}
package test.net.sourceforge.pmd;import net.sourceforge.pmd.ExcludeLines;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Rule;import test.net.sourceforge.pmd.testframework.RuleTst;import java.io.BufferedReader;import java.io.StringReader;public class ExcludeLinesTest extends RuleTst {    public void testExcludeOne() throws Throwable {        ExcludeLines e = new ExcludeLines(new StringReader(TEST1));        assertFalse(e.getLinesToExclude().isEmpty());        Integer i = (Integer)e.getLinesToExclude().iterator().next();        assertEquals(3, i.intValue());    }    public void testExcludeMultiple() throws Throwable {        ExcludeLines e = new ExcludeLines(new StringReader(TEST2));        assertEquals(3, e.getLinesToExclude().size());        assertTrue(e.getLinesToExclude().contains(new Integer(3)));        assertTrue(e.getLinesToExclude().contains(new Integer(4)));        assertTrue(e.getLinesToExclude().contains(new Integer(5)));    }    public void testCopyMatches() throws Throwable {        ExcludeLines e = new ExcludeLines(new StringReader(TEST1));        BufferedReader br = new BufferedReader(e.getCopyReader());        StringBuffer copyBuffer = new StringBuffer();        String tmp;        while ((tmp = br.readLine()) != null) {            copyBuffer.append(tmp + PMD.EOL);        }        copyBuffer.deleteCharAt(copyBuffer.length()-1);        if (PMD.EOL.length() == 2) {            copyBuffer.deleteCharAt(copyBuffer.length()-1);        }        assertEquals(TEST1, copyBuffer.toString());    }    public void testAlternateMarker() throws Throwable {        ExcludeLines e = new ExcludeLines(new StringReader(TEST4), "FOOBAR");        assertFalse(e.getLinesToExclude().isEmpty());    }    public void testAcceptance() throws Throwable {        try {            Rule rule = findRule("rulesets/unusedcode.xml", "UnusedLocalVariable");            runTestFromString(TEST1, 0, rule);            runTestFromString(TEST3, 1, rule);        } catch (Exception e) {            fail("Acceptance tests failed");        }    }    private static final String TEST1 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x; //NOPMD " + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST2 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x; //NOPMD " + PMD.EOL +    "  int y; //NOPMD " + PMD.EOL +    "  int z; //NOPMD " + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST3 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x;" + PMD.EOL +    " } " + PMD.EOL +    "}";    private static final String TEST4 =    "public class Foo {" + PMD.EOL +    " void foo() {" + PMD.EOL +    "  int x; // FOOBAR" + PMD.EOL +    " } " + PMD.EOL +    "}";}
/** * <copyright> *  Copyright 1997-2002 InfoEther, LLC *  under sponsorship of the Defense Advanced Research Projects Agency(DARPA). * *  This program is free software; you can redistribute it and/or modify *  it under the terms of the Cougaar Open Source License as publishedby *  DARPA on the Cougaar Open Source Website (www.cougaar.org). * *  THE COUGAAR SOFTWARE AND ANY DERIVATIVE SUPPLIED BY LICENSOR IS *  PROVIDED 'AS IS' WITHOUT WARRANTIES OF ANY KIND, WHETHER EXPRESS OR *  IMPLIED, INCLUDING (BUT NOT LIMITED TO) ALL IMPLIED WARRANTIES OF *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, AND WITHOUT *  ANY WARRANTIES AS TO NON-INFRINGEMENT.  IN NO EVENT SHALL COPYRIGHT *  HOLDER BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT OR CONSEQUENTIAL *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE OF DATA OR PROFITS, *  TORTIOUS CONDUCT, ARISING OUT OF OR IN CONNECTION WITH THE USE OR *  PERFORMANCE OF THE COUGAAR SOFTWARE. * </copyright> */package test.net.sourceforge.pmd;import junit.framework.TestCase;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import test.net.sourceforge.pmd.testframework.MockRule;public class RuleViolationTest extends TestCase {    public void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r = new RuleViolation(rule, 2, ctx, "package", "class", "method");        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getLine());        assertEquals("filename is wrong", "filename", r.getFilename());    }    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r = new RuleViolation(rule, 2, "description", ctx);        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename1");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        ctx.setSourceCodeFilename("filename2");        RuleViolation r2 = new RuleViolation(rule, 20, "description", ctx);        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        RuleViolation r2 = new RuleViolation(rule, 20, "description", ctx);        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleViolation.RuleViolationComparator comp = new RuleViolation.RuleViolationComparator();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFilename("filename");        RuleViolation r1 = new RuleViolation(rule, 10, "description", ctx);        RuleViolation r2 = new RuleViolation(rule, 10, "description", ctx);        assertEquals(1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.rules.junit;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.ast.ASTMethodDeclarator;import java.util.Iterator;import java.util.List;public class TestClassWithoutTestCases extends AbstractRule {public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {        if (node.isInterface() || node.isNested()) {return data;        }        String className = node.getImage();        if (className.endsWith("Test")) {            List m = node.findChildrenOfType(ASTMethodDeclarator.class);            boolean testsFound = false;            if (m!=null) {                for (Iterator it = m.iterator() ; it.hasNext() && !testsFound ; ) {                    ASTMethodDeclarator md = (ASTMethodDeclarator) it.next();                    if (!isInInnerClassOrInterface(md)                            && md.getImage().startsWith("test")) {                                testsFound = true;                    }                }            }            if (!testsFound) {                addViolation(data, node);            }        }        return data;}private boolean isInInnerClassOrInterface(ASTMethodDeclarator md) {ASTClassOrInterfaceDeclaration p = (ASTClassOrInterfaceDeclaration)md.getFirstParentOfType(ASTClassOrInterfaceDeclaration.class);        return p != null && p.isNested();}}
package test.net.sourceforge.pmd.rx.rules;import java.util.Set;import java.util.Iterator;import net.sourceforge.pmd.rx.facts.*;import net.sourceforge.pmd.rx.rules.*;import test.net.sourceforge.pmd.rx.*;public class DuplicateImportTest    extends DroolsRuleTst{    private String testName = null;    private String JAVA_NO_DUPE ="import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_DEMAND ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private String JAVA_DUPE_NO_DEMAND ="import java.util.List;" +"import java.util.List;" +"public class HelloWorld { }";    private String JAVA_DUPE_ON_NO_DEMAND ="import java.util.*;" +"import java.util.List;" +"public class HelloWorld { }";    public DuplicateImportTest(String name) {super( name );this.testName = name;    }    public void testNoDupes() throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_NO_DUPE );Iterator rvs = results.iterator();while (rvs.hasNext()) {    RuleViolationFact rvFact = (RuleViolationFact) rvs.next();    ImportFact impFact = (ImportFact) rvFact.getFact();    System.err.println("DuplicateImport: " + impFact.getACU() + "/" +       impFact.getImportPackage() + "/" +       Integer.toString( impFact.getLineNumber() ));}assertEquals("Expecting no violations",     0, results.size() );    }    public void testDupeOnDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }    public void testDupeOnNoDemand()throws Throwable    {Set results = collectViolations( new DuplicateImport(), JAVA_DUPE_ON_NO_DEMAND );assertEquals("Expecting 2 violations",     2, results.size() );    }}
package test.net.sourceforge.pmd.rx;import java.util.Set;import java.util.HashSet;import java.util.Iterator;import java.io.StringReader;import org.drools.*;import org.drools.spi.*;import org.drools.semantic.java.*;import net.sourceforge.pmd.*;import net.sourceforge.pmd.rx.*;import net.sourceforge.pmd.ast.*;import net.sourceforge.pmd.rx.facts.*;import junit.framework.TestCase;public class DroolsVisitorTest    extends TestCase{    private String testName = null;    private static String JAVA_TEST_PACKAGE ="package test;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_1 ="import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_2 ="import java.util.*;" +"import java.lang.ref.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_SINGLE ="import java.util.Map;" +"public class HelloWorld { }";    private static String JAVA_TEST_IMPORT_DUP ="import java.util.*;" +"import java.util.*;" +"public class HelloWorld { }";    private static String JAVA_TEST_CLASS ="class TestClass { }";    private static String JAVA_TEST_CLASS_PUBLIC ="public class TestClass { }";    private static String JAVA_TEST_CLASS_ABSTRACT ="abstract class TestClass { }";    private static String JAVA_TEST_CLASS_INNER ="class Outer { class Inner { } }";    private static String JAVA_TEST_CLASS_ANON ="class Named { " +"  void foo() { Named.bar( new Runnable() { } ); } " +        "}";    private ASTCompilationUnit current = null;    public DroolsVisitorTest(String name) {super( name );this.testName = name;    }    public void testPackage() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.PackageFact.class,  JAVA_TEST_PACKAGE );assertEq("Expected one result.", 1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT( "Expected PackageFact.", fact instanceof PackageFact );PackageFact pkgFact = (PackageFact) fact;assertEq("Expecting package name of 'test'", "test", pkgFact.getPackageName() );    }    public void testImport1() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_1 );assertEq("Expected one result.", 1, results.size() );Iterator imports = results.iterator();Object fact = imports.next();assertT("Expected type of ImportFact",fact instanceof ImportFact);ImportFact impFact = (ImportFact) fact;assertEq("Expecting 'java.util' in Imports.", "java.util", impFact.getImportPackage() );    }    public void testImport2() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_2 );assertEq("Expected two results.", 2, results.size() );boolean sawUtil = false;boolean sawRef = false;ACUFact acu = null;Iterator imports = results.iterator();while (imports.hasNext()) {    Object fact = imports.next();    assertT("Expected type of ImportFact",    fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );    sawUtil = sawUtil |impFact.getImportPackage().equals("java.util");    sawRef = sawRef |impFact.getImportPackage().equals("java.lang.ref");}assertT("Expecting one import of 'java.util'", sawUtil);assertT("Expecting one import of 'java.lang.ref'", sawRef);    }    public void testImportDup() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_DUP );assertEq("Expected two results.", 2, results.size() );ACUFact acu = null;Iterator dups = results.iterator();while (dups.hasNext()) {    Object fact = dups.next();        assertT( "Expected fact to be of ImportFact type.",     fact instanceof ImportFact);    ImportFact impFact = (ImportFact) fact;    if (acu == null) {acu = impFact.getACU();    }        assertEq("Expecting Same ACU",     acu, acu );        assertT( "Should be On Demand.",     impFact.isOnDemand() );    assertEq("Expected java.util.Map to be imported.",     "java.util", impFact.getImportPackage() );}    }    public void testImportSingle() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ImportFact.class,  JAVA_TEST_IMPORT_SINGLE );assertEq("Expected one result.", 1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ImportFact type.", fact instanceof ImportFact );ImportFact impFact = (ImportFact) fact;assertT( "Should not be listed as On Demand.", !impFact.isOnDemand() );assertEq("Expected java.util.Map to be imported.", "java.util.Map", impFact.getImportPackage() );    }    public void testClass() throws Throwable {Set results =    collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS );assertEq( "Expected one result.",  1, results.size() );Iterator facts = results.iterator();Object fact = facts.next();assertT("Expected fact to be of ClassFact type.",fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass", classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, false, false, false );    }    public void testClassPublic() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_PUBLIC );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, true, false, false, false );    }    public void testClassAbstract() throws Throwable {Set results =      collectFacts( net.sourceforge.pmd.rx.facts.ClassFact.class,  JAVA_TEST_CLASS_ABSTRACT );assertEq( "Expected one result.",  1, results.size() );Iterator singles = results.iterator();Object fact = singles.next();assertT( "Expected fact to be of ClassFact type.", fact instanceof ClassFact );ClassFact classFact = (ClassFact) fact;assertEq("Expected ClassName to be 'TestClass'", "TestClass",  classFact.getClassName() );assertEq("Expected outer class to be 'null'", null, classFact.getOuterClass() );verifyClassFlags( classFact, false, true, false, false );    }        public void testClassInner() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_INNER );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact outer = null;  ClassFact inner = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;          if (classFact.getClassName().equals("Outer")) {  outer = classFact;      }          if (classFact.getClassName().equals("Inner")) {  inner = classFact;      }}    }    public void testClassAnon() throws Throwable {  Set results =      collectFacts(net.sourceforge.pmd.rx.facts.ClassFact.class,   JAVA_TEST_CLASS_ANON );  assertEq("Expecting two results.",   2, results.size() );  Iterator facts = results.iterator();  ClassFact named = null;  ClassFact anon = null;  while (facts.hasNext()) {      Object fact = facts.next();          assertT("Expected both facts to be ClassFact type.",      fact instanceof ClassFact );          ClassFact classFact = (ClassFact) fact;      if (classFact.getOuterClass() == null) {  named = classFact;      } else {  anon = classFact;      }  }  assertNotNull( "Expected to find Named class.", named );  assertNotNull( "Expected to find Anon class.", anon );  assertEq( "Expected both classes to have same ACU.",    named.getACU(), anon.getACU() );  assertEq( "Expected Outer Class of Anon to be Named.",    named, anon.getOuterClass() );    }        public void assertEq( String message,  Object expected,  Object result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }        public void assertEq( String message,  boolean expected,  boolean result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertEq( String message,  int expected,  int result ) throws Throwable    {try {    assertEquals( message, expected, result );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public void assertT( String message, boolean cond ) throws Throwable    {try {    assertTrue( message, cond );} catch (Throwable t) {    current.dump(testName + ": ");    throw t;}    }    public Set collectFacts( Class clazz,     String javaCode )throws Throwable    {RuleBase rules = new RuleBase();FactCollector collector = new FactCollector( clazz );rules.addRule( collector );JavaParser parser =    new JavaParser( new StringReader( javaCode ));ASTCompilationUnit acu =    parser.CompilationUnit();current = acu;WorkingMemory memory = rules.createWorkingMemory();DroolsVisitor IUT = new DroolsVisitor( memory );IUT.visit( acu, null );return collector.getFacts();    }    public void verifyClassFlags( ClassFact classFact,  boolean bPublic,  boolean bAbstract,  boolean bFinal,  boolean bStrict ) throws Throwable    {assertEq("Public: ", bPublic, classFact.isPublic() );assertEq("Abstract: ", bAbstract, classFact.isAbstract() );assertEq("Final: ", bFinal, classFact.isFinal() );assertEq("Strict: ", bStrict, classFact.isStrict() );    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 12:06:26 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.cpd.Tile;import net.sourceforge.pmd.dcpd.*;import java.util.ArrayList;import java.util.List;import java.util.Iterator;public class TileHarvesterTest extends TestCase {    public TileHarvesterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        // do the expansion from 1 to 2 tokens and write those expansions        // back to the mock space so TileHarvester can read them        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    TileExpanderTest.marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        space.setTileWrappers(space.getWrittenEntries());        // now the test        TileHarvester tileGatherer = new TileHarvester(space, job);        Occurrences newOcc = tileGatherer.harvest(occ.size());        assertEquals(2, newOcc.size());*/    }}
/* * User: tom * Date: Sep 5, 2002 * Time: 11:04:26 AM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.jini.space.JavaSpace;import net.jini.core.lease.Lease;import net.sourceforge.pmd.dcpd.*;import net.sourceforge.pmd.cpd.*;import java.io.StringReader;import java.util.Iterator;import java.util.List;import java.util.ArrayList;import java.util.Stack;public class TileExpanderTest extends TestCase {    public TileExpanderTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        int tilesSoFar=0;        List tilesToWrite = new ArrayList();        for (Iterator i = occ.getTiles(); i.hasNext();) {            Tile tile = (Tile)i.next();            TileWrapper tw = new TileWrapper(tile,                    marshal(occ.getOccurrences(tile)),                    job.id,                    Batch.NOT_DONE,                    null,                    new Integer(tilesSoFar),                    null, null);            tilesToWrite.add(tw);            tilesSoFar++;        }        space.setTileWrappers(tilesToWrite);        TileExpander expander = new TileExpander(space, new TokenSetsWrapper(tokenSets, job.id));        expander.expandAvailableTiles();        List writtenEntries = space.getWrittenEntries();        assertEquals(7, writtenEntries.size());*/    }   public static List marshal(Iterator i) {        List list = new ArrayList();        while (i.hasNext()) {            list.add(i.next());        }        return list;    }    public static TokenSets createTokenSets() throws Throwable {        TokenSets tokenSets = new TokenSets();        TokenList tokenList1 = new TokenList("list1");        JavaTokensTokenizer tokenizer = new JavaTokensTokenizer();        tokenizer.tokenize(tokenList1, new StringReader("public class Foo {}"));        tokenSets.add(tokenList1);        TokenList tokenList2 = new TokenList("list2");        tokenizer.tokenize(tokenList2, new StringReader("public class Bar {}"));        tokenSets.add(tokenList2);        return tokenSets;    }}
/* * User: tom * Date: Sep 6, 2002 * Time: 4:15:46 PM */package test.net.sourceforge.pmd.dcpd;import junit.framework.TestCase;import net.sourceforge.pmd.cpd.TokenSets;import net.sourceforge.pmd.cpd.Occurrences;import net.sourceforge.pmd.dcpd.Job;import net.sourceforge.pmd.dcpd.TilePlanter;public class TilePlanterTest extends TestCase {    public TilePlanterTest(String name) {        super(name);    }    public void test1() throws Throwable {/*        TokenSets tokenSets = TileExpanderTest.createTokenSets();        MockJavaSpace space = new MockJavaSpace();        Job job = new Job("foo", new Integer(1));        Occurrences occ = new Occurrences(tokenSets);        TilePlanter scatterer = new TilePlanter(space, job);        scatterer.plant(occ);        assertEquals(6, space.getWrittenEntries().size());*/    }}
/* * Created on 2 juillet 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.core.ext;import java.util.Iterator;import java.util.Set;import junit.framework.TestCase;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.core.PMDCorePlugin;/** * Test the ruleset extension *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2005/07/02 14:32:02  phherlin * Implement the RuleSets extension points new tests * * */public class RuleSetsExtensionProcessorTest extends TestCase {        /**     * Tests the additional rulesets has been registered.     * For this test to work, the test plugin fragment must be installed.     *     */    public void testAdditionalRuleSetsRegistered() throws RuleSetNotFoundException {        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();        assertFalse("No registered rulesets!", registeredRuleSets.isEmpty());                RuleSetFactory factory = new RuleSetFactory();        RuleSet ruleSet = factory.createRuleSet("rulesets/extra1.xml");        assertTrue("RuleSet \"rulesets/extra1.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));        ruleSet = factory.createRuleSet("rulesets/extra2.xml");        assertTrue("RuleSet \"rulesets/extra2.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));    }        /**     * Tests the additional default rulesets has been registered.     * For this test to work, the test plugin fragment must be installed.     *     */    public void testAdditionalDefaultRuleSetsRegistered() throws RuleSetNotFoundException {        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getDefaultRuleSets();        assertFalse("No registered default rulesets!", registeredRuleSets.isEmpty());                RuleSetFactory factory = new RuleSetFactory();        RuleSet ruleSet = factory.createRuleSet("rulesets/extra1.xml");        assertTrue("RuleSet \"rulesets/extra1.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));        ruleSet = factory.createRuleSet("rulesets/extra2.xml");        assertTrue("RuleSet \"rulesets/extra2.xml\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));    }    /**     * test if a ruleset is registered     * @param ruleSet     * @param set     * @return true if ok     */    private boolean ruleSetRegistered(RuleSet ruleSet, Set set) {        boolean registered = false;                Iterator i = set.iterator();        while (i.hasNext() && !registered) {            RuleSet registeredRuleSet = (RuleSet) i.next();            registered = registeredRuleSet.getName().equals(ruleSet.getName());        }                return registered;    }}
/* * Created on 7 juin 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.core;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.core.IRuleSetManager;import net.sourceforge.pmd.core.impl.RuleSetManagerImpl;import junit.framework.TestCase;/** * Test the ruleset manager. *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2005/07/02 14:32:01  phherlin * Implement the RuleSets extension points new tests * * Revision 1.1  2005/06/15 21:14:56  phherlin * Create the project for the Eclipse plugin unit tests * * */public class RuleSetManagerTest extends TestCase {    private IRuleSetManager ruleSetManager;    /**     * Default constructor     * @param name     */    public RuleSetManagerTest(String name) {        super(name);    }        /**     * Test the register ruleset     *     */    public void testRegisterRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        assertEquals("RuleSet not registrered!", 1, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Test the registration of a null ruleset     *     */    public void testRegisterNullRuleSet() {        try {            this.ruleSetManager.registerRuleSet(null);            fail("Should return an IllegalArgumentException");        } catch (IllegalArgumentException e) {            ; // cool        }    }        /**     * Registering twice the same rule set results in no addition     *     */    public void testDuplicateRegister() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        this.ruleSetManager.registerRuleSet(ruleSet);        assertEquals("Only one rule set should have been registered", 1, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Test unregistration     *     */    public void testUnregisterRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        assertEquals("RuleSet not registered!", 1, this.ruleSetManager.getRegisteredRuleSets().size());        this.ruleSetManager.unregisterRuleSet(ruleSet);        assertEquals("RuleSet not unregistered", 0, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Unregistering a null ruleset is illegal     *     */    public void testUnregisterNullRuleSet() {        try {            this.ruleSetManager.unregisterRuleSet(null);            fail("An IllegalArgumentException should be returned");        } catch (RuntimeException e) {            ; // cool        }    }        /**     * Unregistering twice the same rule set has no effect     *     */    public void testDuplicateUnregister() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        this.ruleSetManager.unregisterRuleSet(ruleSet);        this.ruleSetManager.unregisterRuleSet(ruleSet);        assertEquals("RuleSet not unregistered", 0, this.ruleSetManager.getRegisteredRuleSets().size());    }        /**     * Test the register default ruleset     *     */    public void testRegisterDefaultRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not registrered!", 1, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * Test the registration of a null ruleset     *     */    public void testRegisterNullDefaultRuleSet() {        try {            this.ruleSetManager.registerDefaultRuleSet(null);            fail("Should return an IllegalArgumentException");        } catch (IllegalArgumentException e) {            ; // cool        }    }        /**     * Registering twice the same default rule set results in no addition     *     */    public void testDuplicateRegisterDefault() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        assertEquals("Only one rule set should have been registered", 1, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * Test unregistration default     *     */    public void testUnregisterDefaultRuleSet() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not registered!", 1, this.ruleSetManager.getDefaultRuleSets().size());        this.ruleSetManager.unregisterDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not unregistered", 0, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * Unregistering a null default ruleset is illegal     *     */    public void testUnregisterNullDefaultRuleSet() {        try {            this.ruleSetManager.unregisterDefaultRuleSet(null);            fail("An IllegalArgumentException should be returned");        } catch (RuntimeException e) {            ; // cool        }    }        /**     * Unregistering twice the same Default rule set has no effect     *     */    public void testDuplicateUnregisterDefault() {        RuleSet ruleSet = new RuleSet();        this.ruleSetManager.registerRuleSet(ruleSet);        this.ruleSetManager.unregisterDefaultRuleSet(ruleSet);        this.ruleSetManager.unregisterDefaultRuleSet(ruleSet);        assertEquals("Default RuleSet not unregistered", 0, this.ruleSetManager.getDefaultRuleSets().size());    }        /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        this.ruleSetManager = new RuleSetManagerImpl();    }}
/* * Created on 7 juin 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.core;import java.util.Iterator;import java.util.Set;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.core.PMDCorePlugin;import net.sourceforge.pmd.core.PluginConstants;import junit.framework.TestCase;/** * Test the PMD Core plugin *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2005/07/02 14:32:01  phherlin * Implement the RuleSets extension points new tests * * Revision 1.1  2005/06/15 21:14:56  phherlin * Create the project for the Eclipse plugin unit tests * * */public class PMDCorePluginTest extends TestCase {    /**     * Constructor for PMDCorePluginTest.     * @param name     */    public PMDCorePluginTest(String name) {        super(name);    }    /**     * Test that the core plugin has been instantiated     *     */    public void testPMDCorePluginNotNull() {        assertNotNull("The Core Plugin has not been instantiated", PMDCorePlugin.getDefault());    }        /**     * Test that we can get a ruleset manager     *     */    public void testRuleSetManagerNotNull() {        assertNotNull("Cannot get a ruleset manager", PMDCorePlugin.getDefault().getRuleSetManager());            }        /**     * Test all the known PMD rulesets has been registered     * For this test to work, no fragement or only the test plugin fragment should be installed.     *     */    public void testStandardPMDRuleSetsRegistered() throws RuleSetNotFoundException {        Set registeredRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();        assertFalse("No registered rulesets!", registeredRuleSets.isEmpty());                RuleSetFactory factory = new RuleSetFactory();        for (int i = 0; i < PluginConstants.PMD_RULESETS.length; i++) {            RuleSet ruleSet = factory.createRuleSet(PluginConstants.PMD_RULESETS[i]);            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", ruleSetRegistered(ruleSet, registeredRuleSets));        }    }        /**     * Test the default rulesets has been registered     * For this test to work, no fragement or only the test plugin fragment should be installed.     *     */    public void testDefaultPMDRuleSetsRegistered() throws RuleSetNotFoundException {        Set defaultRuleSets = PMDCorePlugin.getDefault().getRuleSetManager().getRegisteredRuleSets();        assertFalse("No registered default rulesets!", defaultRuleSets.isEmpty());                RuleSetFactory factory = new RuleSetFactory();        for (int i = 0; i < PluginConstants.PMD_RULESETS.length; i++) {            RuleSet ruleSet = factory.createRuleSet(PluginConstants.PMD_RULESETS[i]);            assertTrue("RuleSet \"" + PluginConstants.PMD_RULESETS[i] + "\" has not been registered", ruleSetRegistered(ruleSet, defaultRuleSets));        }    }        /**     * test if a ruleset is registered     * @param ruleSet     * @param set     * @return true if ok     */    private boolean ruleSetRegistered(RuleSet ruleSet, Set set) {        boolean registered = false;                Iterator i = set.iterator();        while (i.hasNext() && !registered) {            RuleSet registeredRuleSet = (RuleSet) i.next();            registered = registeredRuleSet.getName().equals(ruleSet.getName());        }                return registered;    }}
/* * Created on 14 avr. 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.eclipse.cmd;import java.io.InputStream;import junit.framework.TestCase;import name.herlin.command.CommandException;import name.herlin.command.UnsetInputPropertiesException;import net.sourceforge.pmd.eclipse.PMDPluginConstants;import net.sourceforge.pmd.eclipse.cmd.RenderReportCmd;import net.sourceforge.pmd.eclipse.cmd.ReviewCodeCmd;import net.sourceforge.pmd.renderers.HTMLRenderer;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IFolder;import org.eclipse.core.resources.IProject;import org.eclipse.core.resources.IResource;import org.eclipse.core.runtime.CoreException;import test.net.sourceforge.pmd.eclipse.EclipseUtils;/** * Test the report rendering *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2005/06/15 21:14:57  phherlin * Create the project for the Eclipse plugin unit tests * * */public class RenderReportCmdTest extends TestCase {    private IProject testProject;    /**     * Default constructor     * @param name     */    public RenderReportCmdTest(String name) {        super(name);    }        /**     * Test the basic usage of the report rendering command     *     */    public void testRenderReportCmdBasic() throws CommandException, CoreException {        ReviewCodeCmd reviewCmd = new ReviewCodeCmd();        reviewCmd.setResource(this.testProject);        reviewCmd.performExecute();                RenderReportCmd cmd = new RenderReportCmd();        cmd.setProject(this.testProject);        cmd.setRenderer(new HTMLRenderer());        cmd.setReportName(PMDPluginConstants.HTML_REPORT_NAME);        cmd.performExecute();        cmd.join();                IFolder reportFolder = this.testProject.getFolder(PMDPluginConstants.REPORT_FOLDER);        assertTrue(reportFolder.exists());                IFile reportFile = reportFolder.getFile(PMDPluginConstants.HTML_REPORT_NAME);        assertTrue(reportFile.exists());                this.testProject.deleteMarkers(PMDPluginConstants.PMD_MARKER, true, IResource.DEPTH_INFINITE);                if (reportFile.exists()) {            reportFile.delete(true, false, null);        }                if (reportFolder.exists()) {            reportFolder.delete(true, false, null);        }    }    /**     * Test robustness #1     * @throws CommandException     */    public void testRenderReportCmdNullArg1() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(new HTMLRenderer());            cmd.setReportName(PMDPluginConstants.HTML_REPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #2     * @throws CommandException     */    public void testRenderReportCmdNullArg2() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(PMDPluginConstants.HTML_REPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #3     * @throws CommandException     */    public void testRenderReportCmdNullArg3() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(new HTMLRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #4     * @throws CommandException     */    public void testRenderReportCmdNullArg4() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(PMDPluginConstants.HTML_REPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #5     * @throws CommandException     */    public void testRenderReportCmdNullArg5() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(new HTMLRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #6     * @throws CommandException     */    public void testRenderReportCmdNullArg6() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #7     * @throws CommandException     */    public void testRenderReportCmdNullArg7() throws CommandException {        try {            RenderReportCmd cmd = new RenderReportCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Create a test source file inside that project        EclipseUtils.createTestSourceFile(this.testProject);        InputStream is = EclipseUtils.getResourceStream(this.testProject, "/Test.java");        assertNotNull("Cannot find the test source file", is);        is.close();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                EclipseUtils.removePMDNature(this.testProject);//                this.testProject.refreshLocal(IResource.DEPTH_INFINITE, null);//                Thread.sleep(500);//                this.testProject.delete(true, true, null);//                this.testProject = null;            }        }        super.tearDown();    }}
/* * Created on 14 avr. 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.eclipse.cmd;import java.io.InputStream;import junit.framework.TestCase;import name.herlin.command.CommandException;import name.herlin.command.UnsetInputPropertiesException;import net.sourceforge.pmd.cpd.SimpleRenderer;import net.sourceforge.pmd.eclipse.PMDPluginConstants;import net.sourceforge.pmd.eclipse.cpd.DetectCutAndPasteCmd;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IFolder;import org.eclipse.core.resources.IProject;import org.eclipse.core.runtime.CoreException;import test.net.sourceforge.pmd.eclipse.EclipseUtils;/** * Test the CPD command *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2005/06/15 21:14:57  phherlin * Create the project for the Eclipse plugin unit tests * * */public class DetectCutAndPasteCmdTest extends TestCase {    private IProject testProject;    /**     * Default constructor     * @param name     */    public DetectCutAndPasteCmdTest(String name) {        super(name);    }        /**     * Test the basic usage of the report rendering command     *     */    public void testDetectCutAndPasteCmdBasic() throws CommandException, CoreException {        DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();        cmd.setProject(this.testProject);        cmd.setRenderer(new SimpleRenderer());        cmd.setReportName(PMDPluginConstants.SIMPLE_CPDREPORT_NAME);        cmd.performExecute();        cmd.join();                IFolder reportFolder = this.testProject.getFolder(PMDPluginConstants.REPORT_FOLDER);        assertTrue(reportFolder.exists());                IFile reportFile = reportFolder.getFile(PMDPluginConstants.SIMPLE_CPDREPORT_NAME);        assertTrue(reportFile.exists());        if (reportFile.exists()) {            reportFile.delete(true, false, null);        }                if (reportFolder.exists()) {            reportFolder.delete(true, false, null);        }    }    /**     * Test robustness #1     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg1() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(new SimpleRenderer());            cmd.setReportName(PMDPluginConstants.SIMPLE_CPDREPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #2     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg2() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(PMDPluginConstants.SIMPLE_CPDREPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #3     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg3() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(new SimpleRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #4     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg4() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(PMDPluginConstants.SIMPLE_CPDREPORT_NAME);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #5     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg5() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(new SimpleRenderer());            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #6     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg6() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(this.testProject);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * Test robustness #7     * @throws CommandException     */    public void testDetectCutAndPasteCmdNullArg7() throws CommandException {        try {            DetectCutAndPasteCmd cmd = new DetectCutAndPasteCmd();            cmd.setProject(null);            cmd.setRenderer(null);            cmd.setReportName(null);            cmd.performExecute();            fail();        } catch (UnsetInputPropertiesException e) {            // yes cool        }    }    /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Create a test source file inside that project        EclipseUtils.createTestSourceFile(this.testProject);        InputStream is = EclipseUtils.getResourceStream(this.testProject, "/Test.java");        assertNotNull("Cannot find the test source file", is);        is.close();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                EclipseUtils.removePMDNature(this.testProject);//                this.testProject.refreshLocal(IResource.DEPTH_INFINITE, null);//                Thread.sleep(500);//                this.testProject.delete(true, true, null);//                this.testProject = null;            }        }        super.tearDown();    }}
/* * Created on 12 avr. 2005 * * Copyright (c) 2005, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.eclipse.cmd;import java.io.InputStream;import java.util.Map;import junit.framework.TestCase;import name.herlin.command.CommandException;import name.herlin.command.UnsetInputPropertiesException;import net.sourceforge.pmd.eclipse.cmd.ReviewCodeCmd;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IProject;import org.eclipse.core.runtime.CoreException;import test.net.sourceforge.pmd.eclipse.EclipseUtils;/** * This tests the PMD Processor command *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2005/06/15 21:14:57  phherlin * Create the project for the Eclipse plugin unit tests * *   */public class ReviewCmdTest extends TestCase {    private IProject testProject;    /**     * Test case constructor     *      * @param name     *            of the test case     */    public ReviewCmdTest(String name) {        super(name);    }    /**     * Test the basic usage of the processor command     *       */    public void testReviewCmdBasic() throws CommandException, CoreException {        ReviewCodeCmd cmd = new ReviewCodeCmd();        cmd.setResource(this.testProject);        cmd.performExecute();        cmd.join();        Map markers = cmd.getMarkers();                // We do not test PMD, only a non-empty report is enough        assertNotNull(markers);        assertTrue("Report size = " + markers.size(), markers.size() > 0);    }    /**     * The ReviewCodeCmd must also work on a ResourceDelta      * @throws CommandException     */    public void testReviewCmdDelta() throws CommandException {        // Don't know how to test that yet        // How to instantiate a ResourceDelta ?        // Let's comment for now    }        /**     * Normally a null resource and a null resource delta is not acceptable.     * @throws CommandException     */    public void testReviewCmdNullResource() throws CommandException {        try {            ReviewCodeCmd cmd = new ReviewCodeCmd();            cmd.setResource(null);            cmd.setResourceDelta(null);            cmd.performExecute();            fail("A UnsetInputPropertiesException must be thrown");        } catch (UnsetInputPropertiesException e) {            ; // cool, success        }    }        /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());        // 2. Create a test source file inside that project        IFile testFile = EclipseUtils.createTestSourceFile(this.testProject);        InputStream is = EclipseUtils.getResourceStream(this.testProject, "/Test.java");        assertNotNull("Cannot find the test source file", is);        is.close();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                EclipseUtils.removePMDNature(this.testProject);//                this.testProject.refreshLocal(IResource.DEPTH_INFINITE, null);//                Thread.sleep(500);//                this.testProject.delete(true, true, null);//                this.testProject = null;            }        }        super.tearDown();    }}
package test.net.sourceforge.pmd.eclipse.properties;import java.util.Iterator;import junit.framework.TestCase;import name.herlin.command.CommandException;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.eclipse.PMDPlugin;import net.sourceforge.pmd.eclipse.model.ModelException;import net.sourceforge.pmd.eclipse.model.ModelFactory;import net.sourceforge.pmd.eclipse.model.ProjectPropertiesModel;import net.sourceforge.pmd.eclipse.properties.UpdateProjectPropertiesCmd;import org.eclipse.core.resources.IProject;import test.net.sourceforge.pmd.eclipse.EclipseUtils;public class UpdateProjectPropertiesCmdTest extends TestCase {    private IProject testProject;    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());    }    protected void tearDown() throws Exception {        // 1. Delete the test project        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                this.testProject.delete(true, true, null);                this.testProject = null;            }        }                super.tearDown();    }    /**     * Bug: when a user deselect a project rule it is not saved     */    public void testBug() throws CommandException, ModelException {        RuleSetFactory factory = new RuleSetFactory();        // First ensure that the plugin initial ruleset is equal to the project ruleset        ProjectPropertiesModel model = ModelFactory.getFactory().getProperiesModelForProject(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", PMDPlugin.getDefault().getRuleSet(), projectRuleSet);                // 2. remove the first rule (keep its name for assertion)        RuleSet newRuleSet = new RuleSet();        newRuleSet.addRuleSet(projectRuleSet);        Iterator i = newRuleSet.getRules().iterator();        Rule removedRule = (Rule) i.next();        i.remove();        UpdateProjectPropertiesCmd cmd = new UpdateProjectPropertiesCmd();        cmd.setPmdEnabled(true);        cmd.setProject(this.testProject);        cmd.setProjectRuleSet(newRuleSet);        cmd.setProjectWorkingSet(null);        cmd.setRuleSetStoredInProject(false);        cmd.execute();        // 3. test the rule has correctly been removed        projectRuleSet = model.getProjectRuleSet();        assertNull("The rule has not been removed!", projectRuleSet.getRuleByName(removedRule.getName()));    }}
/* * Created on 6 f�vr. 2005 * * Copyright (c) 2004, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.eclipse.model;import net.sourceforge.pmd.eclipse.model.ModelFactory;import net.sourceforge.pmd.eclipse.model.PreferencesModel;import junit.framework.TestCase;/** *  *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.1  2005/06/15 21:14:56  phherlin * Create the project for the Eclipse plugin unit tests * * */public class PreferencesModelTest extends TestCase {    private static final String REVIEW_ADDITIONAL_COMMENT = "sample review additional comment";        /**     * Test case constructor     * @param name of the test case     */    public PreferencesModelTest(String name) {        super(name);    }        /**     * Plugin preferences should contains a review additional comment.     * This preference must be access through a model.     *     */    public void testReviewAdditionalComment() {        // Get the preference model        PreferencesModel model = ModelFactory.getFactory().getPreferencesModel();        assertNotNull("Cannot get a preferenes model", model);                // Store a comment        model.setReviewAdditionalComment(REVIEW_ADDITIONAL_COMMENT);        // nothing to assert yet                // try get the comment        String comment = model.getReviewAdditionalComment();        assertNotNull(comment);        assertEquals(REVIEW_ADDITIONAL_COMMENT, comment);    }    }
/* * Created on 6 fevr. 2005 * * Copyright (c) 2004, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.eclipse.model;import java.util.Iterator;import junit.framework.TestCase;import net.sourceforge.pmd.AbstractRule;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.eclipse.PMDPlugin;import net.sourceforge.pmd.eclipse.PMDPluginConstants;import net.sourceforge.pmd.eclipse.builder.PMDNature;import net.sourceforge.pmd.eclipse.model.ModelException;import net.sourceforge.pmd.eclipse.model.ProjectPropertiesModel;import net.sourceforge.pmd.eclipse.model.ProjectPropertiesModelImpl;import org.eclipse.core.resources.IFile;import org.eclipse.core.resources.IProject;import org.eclipse.core.runtime.CoreException;import org.eclipse.ui.IWorkingSet;import test.net.sourceforge.pmd.eclipse.EclipseUtils;/** * Test the project properties model. *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.3  2005/07/02 14:31:11  phherlin * Fixing equals assertion to test on rules collection instead * * Revision 1.2  2005/07/01 00:06:38  phherlin * Refactoring and writing more tests * * Revision 1.1  2005/06/15 21:14:56  phherlin * Create the project for the Eclipse plugin unit tests * *   */public class ProjectPropertiesModelTest extends TestCase {    private IProject testProject;    private RuleSet initialPluginRuleSet;    /**     * Test case constructor     *      * @param name     *            of the test case     */    public ProjectPropertiesModelTest(String name) {        super(name);    }    /**     * A property should be used to know if PMD is enabled for a project. Set to     * TRUE     *       */    public void testPmdEnabledTRUE() throws ModelException, CoreException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        model.setPmdEnabled(true);        model.sync();        assertTrue("Cannot activate PMD for that project", this.testProject.hasNature(PMDNature.PMD_NATURE));        assertTrue("PMD Property not set!", model.isPmdEnabled());    }    /**     * A property should be used to know id PMD is enabled for a project. Set to     * FALSE.     *       */    public void testPmdEnabledFALSE() throws ModelException, CoreException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        model.setPmdEnabled(true);        model.sync();        assertTrue("Cannot activate PMD for that project", this.testProject.hasNature(PMDNature.PMD_NATURE));        model.setPmdEnabled(false);        model.sync();        assertFalse("Cannot desactivate PMD for that project", this.testProject.hasNature(PMDNature.PMD_NATURE));        assertFalse("PMD Property not reset!", model.isPmdEnabled());    }    /**     * A brand new project should be affected the Plugin ruleset in the global     * ruleset.     *       */    public void testProjectRuleSet() throws ModelException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        assertSame("A new project a is not set the plugin ruleset", model.getProjectRuleSet(), PMDPlugin.getDefault().getRuleSet());    }    /**     * Set another ruleset.     */    public void testProjectRuleSet1() throws ModelException, RuleSetNotFoundException, CoreException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        RuleSetFactory factory = new RuleSetFactory();        // use the basic ruleset because it should be included in the plugin        // ruleset.        RuleSet basicRuleSet = factory.createRuleSet("rulesets/basic.xml");        // First set the project ruleset        model.setProjectRuleSet(basicRuleSet);        model.sync();        // Test the ruleset we set is equal to the ruleset we queried        RuleSet projectRuleSet = model.getProjectRuleSet();        assertNotNull("Project ruleset has not been set", projectRuleSet);        assertEquals("The project ruleset is not the basic ruleset", basicRuleSet.getRules(), projectRuleSet.getRules());    }    /**     * When rules are removed from the plugin preferences, these rules should also be removed from the project     */    public void testProjectRuleSet2() throws ModelException, RuleSetNotFoundException, CoreException {        // First ensure that the plugin initial ruleset is equal to the project ruleset        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", this.initialPluginRuleSet.getRules(), projectRuleSet.getRules());                // use the basic ruleset and set it at the only plugin ruleset        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createRuleSet("rulesets/basic.xml");        PMDPlugin.getDefault().setRuleSet(basicRuleSet, null);        projectRuleSet = model.getProjectRuleSet();                assertEquals("The project ruleset is not equal to the plugin ruleset", basicRuleSet.getRules(), projectRuleSet.getRules());    }    /**     * When rules are added to the plugin preferences, these rules should also be added to the project     */    public void testProjectRuleSet3() throws ModelException, RuleSetNotFoundException, CoreException {        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createRuleSet("rulesets/basic.xml");        // First ensure that the plugin initial ruleset is equal to the project ruleset        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", this.initialPluginRuleSet, projectRuleSet);        // 2. add a rule to the plugin rule set        Rule myRule = new AbstractRule() {            public String getName() {                return "MyRule";            }        };                RuleSet newRuleSet = new RuleSet();        newRuleSet.setName("foo");        newRuleSet.addRuleSet(this.initialPluginRuleSet);        newRuleSet.addRule(myRule);        PMDPlugin.getDefault().setRuleSet(newRuleSet, null);                // Test that the project rule set should still be the same as the plugin rule set        model = new ProjectPropertiesModelImpl(this.testProject);        projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", PMDPlugin.getDefault().getRuleSet().getRules(), projectRuleSet.getRules());    }    /**     * Bug: when a user deselect a project rule it is not saved     */    public void testBug() throws ModelException, RuleSetNotFoundException, CoreException {        RuleSetFactory factory = new RuleSetFactory();        // First ensure that the plugin initial ruleset is equal to the project ruleset        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        RuleSet projectRuleSet = model.getProjectRuleSet();        assertEquals("The project ruleset is not equal to the plugin ruleset", initialPluginRuleSet, projectRuleSet);                // 2. remove the first rule (keep its name for assertion)        RuleSet newRuleSet = new RuleSet();        newRuleSet.addRuleSet(projectRuleSet);        Iterator i = newRuleSet.getRules().iterator();        Rule removedRule = (Rule) i.next();        i.remove();                model.setProjectRuleSet(newRuleSet);        model.sync();        // 3. test the rule has correctly been removed        projectRuleSet = model.getProjectRuleSet();        assertNull("The rule has not been removed!", projectRuleSet.getRuleByName(removedRule.getName()));    }    /**     * It should not be possible to set to null a project ruleset     *       */    public void testProjectRuleSetNull() throws ModelException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        try {            model.setProjectRuleSet(null);            fail("A ModelException must be raised when setting a project ruleset to null");        } catch (ModelException e) {            // OK that's correct        }    }    /**     * A project may have its ruleset stored in the project own directory. Test     * set to TRUE.     */    public void testRuleSetStoredInProjectTRUE() throws ModelException, RuleSetNotFoundException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createRuleSet("rulesets/basic.xml");        model.setPmdEnabled(true);        model.setRuleSetStoredInProject(false);        model.setProjectWorkingSet(null);        model.setProjectRuleSet(basicRuleSet);        model.sync();                model.createDefaultRuleSetFile();        model.setRuleSetStoredInProject(true);        model.sync();                boolean b = model.isRuleSetStoredInProject();        IFile file = this.testProject.getFile(PMDPluginConstants.PROJECT_RULESET_FILE);        RuleSet projectRuleSet = factory.createRuleSet(file.getLocation().toOSString());        assertTrue("the ruleset should be stored in the project", b);        assertEquals("The project ruleset must be equals to the one found in the project", model.getProjectRuleSet(),                projectRuleSet);    }    /**     * A project may have its ruleset stored in the project own directory. Test     * set to FALSE.     *       */    public void testRuleSetStoredInProjectFALSE() throws ModelException, RuleSetNotFoundException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        RuleSetFactory factory = new RuleSetFactory();        RuleSet basicRuleSet = factory.createRuleSet("rulesets/basic.xml");        model.setPmdEnabled(true);        model.setRuleSetStoredInProject(false);        model.setProjectWorkingSet(null);        model.setProjectRuleSet(basicRuleSet);        model.sync();        model.createDefaultRuleSetFile();        model.setRuleSetStoredInProject(true);        model.sync();        model.setRuleSetStoredInProject(false);        model.sync();        boolean b = model.isRuleSetStoredInProject();        assertFalse("the ruleset should'nt be stored in the project", b);    }    /**     * A project may work only on a subset of files defined by a working set     *       */    public void testProjectWorkingSetNull() throws ModelException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        model.setProjectWorkingSet(null);        IWorkingSet w = model.getProjectWorkingSet();        assertNull("The project should not have a working set defined", w);    }    /**     * A project may know if it should be rebuilt or not     *       */    public void testRebuild1() throws ModelException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        model.setPmdEnabled(false);        model.setProjectWorkingSet(null);        model.setRuleSetStoredInProject(false);        model.setNeedRebuild(false);        assertFalse(model.isNeedRebuild());    }    /**     * A project may know if it should be rebuilt or not     *       */    public void testRebuild2() throws ModelException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        model.setPmdEnabled(true);        assertTrue(model.isNeedRebuild());    }    /**     * A project may know if it should be rebuilt or not     *       */    public void testRebuild3() throws ModelException {        ProjectPropertiesModel model = new ProjectPropertiesModelImpl(this.testProject);        model.setPmdEnabled(true);                RuleSet pmdRuleSet = PMDPlugin.getDefault().getRuleSet();        RuleSet fooRuleSet = new RuleSet();        Rule rule1 = pmdRuleSet.getRuleByName("EmptyCatchBlock");        fooRuleSet.addRule(rule1);        model.setProjectRuleSet(fooRuleSet);        assertTrue(model.isNeedRebuild());    }    /**     * @see junit.framework.TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        // 1. Create a Java project        this.testProject = EclipseUtils.createJavaProject("PMDTestProject");        assertTrue("A test project cannot be created; the tests cannot be performed.", (this.testProject != null)                && this.testProject.exists() && this.testProject.isAccessible());                // 2. Keep the plugin ruleset        this.initialPluginRuleSet = PMDPlugin.getDefault().getRuleSet();    }    /**     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        // 1. Delete the test project        if (this.testProject != null) {            if (this.testProject.exists() && this.testProject.isAccessible()) {                this.testProject.delete(true, true, null);                this.testProject = null;            }        }                // 2. Restore the plugin initial rule set        PMDPlugin.getDefault().setRuleSet(this.initialPluginRuleSet, null);        super.tearDown();    }        private void dumpRuleSet(RuleSet ruleSet) {        System.out.println("Dumping rule set:" + ruleSet.getName());        Iterator i = ruleSet.getRules().iterator();        while (i.hasNext()) {            Rule rule = (Rule) i.next();            System.out.println(rule.getName());        }        System.out.println();    }}
/* * Created on 6 f�vr. 2005 * * Copyright (c) 2004, PMD for Eclipse Development Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are * met: *  *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * The end-user documentation included with the redistribution, if *       any, must include the following acknowledgement: *       "This product includes software developed in part by support from *        the Defense Advanced Research Project Agency (DARPA)" *     * Neither the name of "PMD for Eclipse Development Team" nor the names of its *       contributors may be used to endorse or promote products derived from *       this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package test.net.sourceforge.pmd.eclipse;import java.io.Reader;import java.io.StringReader;import java.util.Iterator;import junit.framework.TestCase;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetFactory;import net.sourceforge.pmd.RuleSetNotFoundException;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.TargetJDK1_3;import net.sourceforge.pmd.TargetJDK1_4;import net.sourceforge.pmd.TargetJDK1_5;import net.sourceforge.pmd.eclipse.PMDPluginConstants;/** * Test if PMD can be run correctly *  * @author Philippe Herlin * @version $Revision$ *  * $Log$ * Revision 1.2  2005/07/01 00:06:38  phherlin * Refactoring and writing more tests * * Revision 1.1  2005/06/15 21:14:57  phherlin * Create the project for the Eclipse plugin unit tests * *   */public class BasicPMDTest extends TestCase {    /**     * Test case constructor     *      * @param name     *            of the test case     */    public BasicPMDTest(String name) {        super(name);    }    /**     * One first thing the plugin must be able to do is to run PMD     *       */    public void testRunPmdJdk13() {        try {            PMD pmd = new PMD(new TargetJDK1_3());            String sourceCode = "public class Foo {\n public void foo() {\nreturn;\n}}";            Reader input = new StringReader(sourceCode);            RuleContext context = new RuleContext();            context.setSourceCodeFilename("foo.java");            context.setReport(new Report());            RuleSet basicRuleSet = new RuleSetFactory().createRuleSet("rulesets/basic.xml");            pmd.processFile(input, basicRuleSet, context);            Iterator iter = context.getReport().iterator();            assertTrue("There should be at least one violation", iter.hasNext());            RuleViolation violation = (RuleViolation) iter.next();            assertEquals(violation.getRule().getName(), "UnnecessaryReturn");            assertEquals(3, violation.getLine());        } catch (RuleSetNotFoundException e) {            e.printStackTrace();            fail();        } catch (PMDException e) {            e.printStackTrace();            fail();        }    }    /**     * Let see with Java 1.4     *       */    public void testRunPmdJdk14() {        try {            PMD pmd = new PMD(new TargetJDK1_4());            String sourceCode = "public class Foo {\n public void foo() {\nreturn;\n}}";            Reader input = new StringReader(sourceCode);            RuleContext context = new RuleContext();            context.setSourceCodeFilename("foo.java");            context.setReport(new Report());            RuleSet basicRuleSet = new RuleSetFactory().createRuleSet("rulesets/basic.xml");            pmd.processFile(input, basicRuleSet, context);            Iterator iter = context.getReport().iterator();            assertTrue("There should be at least one violation", iter.hasNext());            RuleViolation violation = (RuleViolation) iter.next();            assertEquals(violation.getRule().getName(), "UnnecessaryReturn");            assertEquals(3, violation.getLine());        } catch (RuleSetNotFoundException e) {            e.printStackTrace();            fail();        } catch (PMDException e) {            e.printStackTrace();            fail();        }    }    /**     * Let see with Java 1.5     *       */    public void testRunPmdJdk15() {        try {            PMD pmd = new PMD(new TargetJDK1_5());            String sourceCode = "public class Foo {\n public void foo() {\nreturn;\n}}";            Reader input = new StringReader(sourceCode);            RuleContext context = new RuleContext();            context.setSourceCodeFilename("foo.java");            context.setReport(new Report());            RuleSet basicRuleSet = new RuleSetFactory().createRuleSet("rulesets/basic.xml");            pmd.processFile(input, basicRuleSet, context);            Iterator iter = context.getReport().iterator();            assertTrue("There should be at least one violation", iter.hasNext());            RuleViolation violation = (RuleViolation) iter.next();            assertEquals(violation.getRule().getName(), "UnnecessaryReturn");            assertEquals(3, violation.getLine());        } catch (RuleSetNotFoundException e) {            e.printStackTrace();            fail();        } catch (PMDException e) {            e.printStackTrace();            fail();        }    }    /**     * Try to load all the plugin known rulesets     *       */    public void testDefaulltRuleSets() {        RuleSetFactory factory = new RuleSetFactory();        String allRuleSets[] = PMDPluginConstants.RULESET_ALLPMD;        for (int i = 0; i < allRuleSets.length; i++) {            try {                RuleSet ruleSet = factory.createRuleSet(allRuleSets[i]);            } catch (RuleSetNotFoundException e) {                e.printStackTrace();                fail("unable to load ruleset " + allRuleSets[i]);            }        }    }}