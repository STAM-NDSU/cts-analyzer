/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class GroovyTokenizerTest extends CpdTextComparisonTest {    public GroovyTokenizerTest() {        super(".groovy");    }    @Override    protected String getResourcePrefix() {        return "../lang/groovy/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new GroovyTokenizer();    }    @Test    public void testSample() {        doTest("sample");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyForeachStmtTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveTemplateLengthTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineJavaScriptTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineStylesTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedMacroParameterTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vm;import org.junit.Test;import net.sourceforge.pmd.lang.vm.ast.VmParsingHelper;/** * Unit test for VM parsing. */public class VmParserTest {    private static final String VM_SRC = "<HTML><BODY>Hello $customer.Name <table> "        + "#foreach($mud in $mudsOnSpecial)" + "  #if ( $customer.hasPurchased($mud) )" + "     <tr>" + "      <td>"        + "       $flogger.getPromo( $mud )" + "    </td>" + "  </tr>" + " #elseif ($customer.broke) do stuff #end"        + "\n " + "#end " + "</table>";    private static final String SRC2 = "#macro(tablerows $color $values ) " + "#foreach( $value in $values ) "        + "<tr><td bgcolor=$color>$value</td></tr> " + "#end " + "#end "        + "#set( $greatlakes = [\"Superior\",\"Michigan\",\"Huron\",\"Erie\",\"Ontario\"] ) "        + "#set( $color = \"blue\" ) " + "<table> " + " #tablerows( $color $greatlakes ) " + "</table>";    private static final String SRC3 = "#if ( $c1 ) #if ( $c2)#end #end";    // private static final String VM_SRC = "#if( $mud == 1 ) blah #if ($dirt ==    // 2) stuff #end #end";    @Test    public void testParser() {        VmParsingHelper.DEFAULT.parse(VM_SRC);    }    @Test    public void testParser2() {        VmParsingHelper.DEFAULT.parse(SRC2);    }    @Test    public void testParser3() {        VmParsingHelper.DEFAULT.parse(SRC3);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vm.VmLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VmLanguageModule.NAME, VmLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(VmLanguageModule.NAME).getDefaultVersion(), }, });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test velocity's rulesets. */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.perl.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.PerlLanguage;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * */public class PerlTokenizerTest extends CpdTextComparisonTest {    public PerlTokenizerTest() {        super(".pl");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PerlLanguage().getTokenizer();    }    @Test    public void testSample() {        doTest("sample");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToDateToCharTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATE_TO_CHAR");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToDateWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_DATEWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.errorprone;import java.util.Collections;import java.util.List;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ToTimestampWithoutDateFormatTest extends PmdRuleTst {    // No additional unit tests    @Override    protected List<Rule> getRules() {        Rule rule = findRule("category/plsql/errorprone.xml", "TO_TIMESTAMPWithoutDateFormat");        return Collections.singletonList(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssObjectCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePackageSpecificationLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveTypeLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePackageBodyLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NPathComplexityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveObjectLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CodeFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LineLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidTabCharacterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MisplacedPragmaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TomKytesDespairTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class InsertIntoClauseTest extends AbstractPLSQLParserTst {    @Test    public void parseInsertInto() {        plsql.parseResource("InsertIntoClause.pls");    }    @Test    public void parseInsertIntoReturning() {        plsql.parseResource("InsertIntoClauseReturning.pls");    }    @Test    public void parseInsertIntoWithRecord() {        plsql.parseResource("InsertIntoClauseRecord.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class XMLElementTest extends AbstractPLSQLParserTst {    @Test    public void testParseXMLElement() {        ASTInput input = plsql.parseResource("XMLElement.pls");        List<ASTXMLElement> xmlelements = input.findDescendantsOfType(ASTXMLElement.class);        Assert.assertEquals(10, xmlelements.size());        Assert.assertEquals("\"Emp\"", xmlelements.get(0).getFirstChildOfType(ASTID.class).getImage());        Assert.assertTrue(xmlelements.get(3).getChild(1) instanceof ASTXMLAttributesClause);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorForLoopTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorForLoopSimple() {        ASTInput input = plsql.parseResource("CursorForLoopSimple.pls");        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        Assert.assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        Assert.assertNotNull(forindex);        Assert.assertEquals("someone", forindex.getImage());    }    @Test    public void parseCursorForLoopNested() {        ASTInput input = plsql.parseResource("CursorForLoopNested.pls");        ASTCursorForLoopStatement forloop = input.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        Assert.assertNotNull(forloop);        ASTForIndex forindex = forloop.getFirstChildOfType(ASTForIndex.class);        Assert.assertNotNull(forindex);        Assert.assertEquals("c_cmp", forindex.getImage());        ASTCursorForLoopStatement forloop2 = forloop.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex2 = forloop2.getFirstChildOfType(ASTForIndex.class);        Assert.assertEquals("c_con", forindex2.getImage());        ASTCursorForLoopStatement forloop3 = forloop2.getFirstDescendantOfType(ASTCursorForLoopStatement.class);        ASTForIndex forindex3 = forloop3.getFirstChildOfType(ASTForIndex.class);        Assert.assertEquals("c_pa", forindex3.getImage());    }    @Test    public void parseCursorForLoop1047a() {        ASTInput input = plsql.parseResource("CursorForLoop1047a.pls");        Assert.assertNotNull(input);    }    @Test    public void parseCursorForLoop1047b() {        ASTInput input = plsql.parseResource("CursorForLoop1047b.pls");        Assert.assertNotNull(input);    }    @Test    public void parseCursorForLoop681() {        ASTInput input = plsql.parseResource("CursorForLoop681.pls");        Assert.assertNotNull(input);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class MultipleDDLStatementsTest extends AbstractPLSQLParserTst {    @Test    public void parseDDLCommands() throws Exception {        ASTInput input = plsql.parseResource("DDLCommands.sql");        List<ASTDDLCommand> ddlcommands = input.findDescendantsOfType(ASTDDLCommand.class);        Assert.assertEquals(6, ddlcommands.size());        List<ASTComment> comments = input.findDescendantsOfType(ASTComment.class);        Assert.assertEquals(5, comments.size());        Assert.assertEquals("'abbreviated job title'", comments.get(0).getFirstChildOfType(ASTStringLiteral.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class JoinClauseTest extends AbstractPLSQLParserTst {    @Test    public void testInnerCrossJoin() {        ASTInput input = plsql.parseResource("InnerCrossJoin.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(1, joins.size());        Assert.assertTrue(joins.get(0).isCross());        Assert.assertFalse(joins.get(0).isNatural());    }    @Test    public void testInnerNaturalJoin() {        ASTInput input = plsql.parseResource("InnerNaturalJoin.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(2, joins.size());        Assert.assertFalse(joins.get(0).isCross());        Assert.assertTrue(joins.get(0).isNatural());    }    @Test    public void testInnerJoinUsing() {        ASTInput input = plsql.parseResource("InnerJoinUsing.pls");        List<ASTInnerCrossJoinClause> joins = input.findDescendantsOfType(ASTInnerCrossJoinClause.class);        Assert.assertEquals(3, joins.size());        Assert.assertFalse(joins.get(0).isCross());        Assert.assertFalse(joins.get(0).isNatural());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        Assert.assertEquals(1, columns.size());        Assert.assertEquals("department_id", columns.get(0).getImage());    }    @Test    public void testOuterJoinUsing() {        ASTInput input = plsql.parseResource("OuterJoinUsing.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.FULL, type.getType());        List<ASTColumn> columns = joins.get(0).findChildrenOfType(ASTColumn.class);        Assert.assertEquals(1, columns.size());        Assert.assertEquals("department_id", columns.get(0).getImage());    }    @Test    public void testRightOuterJoin() {        ASTInput input = plsql.parseResource("RightOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());    }    @Test    public void testLeftOuterJoin() {        ASTInput input = plsql.parseResource("LeftOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(2, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.LEFT, type.getType());        List<ASTSelectStatement> selects = input.findDescendantsOfType(ASTSelectStatement.class);        Assert.assertEquals(2, selects.size());        Assert.assertTrue(selects.get(0).getFromClause().getChild(0) instanceof ASTJoinClause);        Assert.assertTrue(selects.get(1).getFromClause().getChild(0) instanceof ASTJoinClause);    }    @Test    public void testNaturalRightOuterJoin() {        ASTInput input = plsql.parseResource("NaturalRightOuterJoin.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        Assert.assertTrue(joins.get(0).isNatural());    }    @Test    public void testOuterJoinPartitioned() {        ASTInput input = plsql.parseResource("OuterJoinPartitioned.pls");        List<ASTOuterJoinClause> joins = input.findDescendantsOfType(ASTOuterJoinClause.class);        Assert.assertEquals(1, joins.size());        ASTOuterJoinType type = joins.get(0).getFirstChildOfType(ASTOuterJoinType.class);        Assert.assertEquals(ASTOuterJoinType.Type.RIGHT, type.getType());        Assert.assertNotNull(joins.get(0).getFirstChildOfType(ASTQueryPartitionClause.class));    }    @Test    public void testFullOuterJoin() {        plsql.parseResource("FullOuterJoin.pls");    }    @Test    public void testInnerJoinSubquery() {        plsql.parseResource("InnerJoinSubquery.pls");    }    @Test    public void testJoinOperator() {        ASTInput input = plsql.parseResource("JoinOperator.pls");        List<ASTOuterJoinExpression> expressions = input.findDescendantsOfType(ASTOuterJoinExpression.class);        Assert.assertEquals(4, expressions.size());        Assert.assertEquals("h.opp_id", expressions.get(3).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorAttributesTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorWithAttribute() {        ASTInput input = plsql.parseResource("CursorAttributes.pls");        ASTExpression exp = input.getFirstDescendantOfType(ASTIfStatement.class).getFirstChildOfType(ASTExpression.class);        Assert.assertEquals("TestSearch%notfound", exp.getImage());    }    @Test    public void parseImplicitCursorAttributeBulkExceptions() {        plsql.parseResource("CursorAttributesBulkExceptions.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTFetchStatementTest extends AbstractPLSQLParserTst {    @Test    public void testBulkCollectLimit() {        ASTInput input = plsql.parseResource("FetchStatementBulkCollectLimit.pls");        List<ASTFetchStatement> fetchStatements = input.findDescendantsOfType(ASTFetchStatement.class);        Assert.assertEquals(1, fetchStatements.size());        ASTFetchStatement fetch = fetchStatements.get(0);        Assert.assertTrue(fetch.isBulkCollect());        Assert.assertTrue(fetch.isLimit());    }    @Test    public void testFetch() {        ASTInput input = plsql.parseResource("FetchStatement.pls");        List<ASTFetchStatement> fetchStatements = input.findDescendantsOfType(ASTFetchStatement.class);        Assert.assertEquals(1, fetchStatements.size());        ASTFetchStatement fetch = fetchStatements.get(0);        Assert.assertFalse(fetch.isBulkCollect());        Assert.assertFalse(fetch.isLimit());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class DeleteStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseDeleteStatementExample() {        ASTInput input = plsql.parseResource("DeleteStatementExample.pls");        List<ASTDeleteStatement> deleteStatements = input.findDescendantsOfType(ASTDeleteStatement.class);        Assert.assertEquals(3, deleteStatements.size());        Assert.assertEquals("product_descriptions", deleteStatements.get(0).getChild(0)                                                                    .getFirstChildOfType(ASTTableName.class).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectUnionTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectUnion() {        plsql.parseResource("SelectUnion.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectIntoWithGroupByTest extends AbstractPLSQLParserTst {    @Test    public void testExample1() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy1.pls");        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        Assert.assertNotNull(groupByClause);    }    @Test    public void testExample2() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy2.pls");        ASTGroupByClause groupByClause = input.getFirstDescendantOfType(ASTGroupByClause.class);        Assert.assertNotNull(groupByClause);    }    @Test    public void testExample3WithCube() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy3.pls");        ASTRollupCubeClause cubeClause = input.getFirstDescendantOfType(ASTRollupCubeClause.class);        Assert.assertNotNull(cubeClause);        Assert.assertEquals("CUBE", cubeClause.getImage());    }    @Test    public void testExample4WithGroupingSets() {        ASTInput input = plsql.parseResource("SelectIntoWithGroupBy4.pls");        ASTGroupingSetsClause groupingSetsClause = input.getFirstDescendantOfType(ASTGroupingSetsClause.class);        Assert.assertNotNull(groupingSetsClause);        List<ASTFromClause> fromClauses = input.findDescendantsOfType(ASTFromClause.class);        Assert.assertEquals(1, fromClauses.size());        Assert.assertEquals(5, fromClauses.get(0).getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectForUpdateTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectForUpdateWait() {        ASTInput input = plsql.parseResource("SelectForUpdateWait.pls");        Assert.assertNotNull(input);        Assert.assertEquals(5, input.findDescendantsOfType(ASTForUpdateClause.class).size());    }    @Test    public void parseSelectForUpdate() {        ASTInput input = plsql.parseResource("SelectForUpdate.pls");        Assert.assertNotNull(input);        List<ASTForUpdateClause> forUpdateClauses = input.findDescendantsOfType(ASTForUpdateClause.class);        Assert.assertEquals(2, forUpdateClauses.size());        Assert.assertEquals(2, forUpdateClauses.get(1).getNumChildren());        Assert.assertEquals("e", forUpdateClauses.get(1).getChild(0).getImage());        Assert.assertEquals("salary", forUpdateClauses.get(1).getChild(1).getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class PLSQLParserTest extends AbstractPLSQLParserTst {    @Test    public void testExceptions() {        plsql.parse("CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                       + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                       + "        doSomethingElse;" + "END;");    }    /**     * See https://sourceforge.net/p/pmd/bugs/1167/     */    @Test    public void testBOM() {        plsql.parse("\ufeff" + "CREATE OR REPLACE PROCEDURE bar IS BEGIN" + "    doSomething;" + "    EXCEPTION"                       + "    WHEN FooException THEN" + "        doSomethingElse;" + "    WHEN OTHERS THEN"                       + "        doSomethingElse;" + "END;");    }    @Test(timeout = 5000)    public void testBug1531() {        plsql.parse("create or replace force view oxa.o_xa_function_role_types as\n"                       + "select \"CFT_ID\",\"CFR_ID\",\"CFT_NAME\",\"TCN\",\"LOG_MODULE\",\"LOG_USER\",\"LOG_DATE\",\"LOG_TIME\" from crm_function_role_types\n"                       + "/");    }    @Test    public void testBug1527() {        plsql.parseResource("InlinePragmaProcError.pls");    }    @Test    public void testBug1520IsOfType() {        plsql.parseResource("IsOfType.pls");    }    @Test    public void testBug1520Using() {        plsql.parseResource("Using.pls");    }    @Test    public void testSingleLineSelect() {        plsql.parseResource("SingleLineSelect.pls");    }    @Test    public void testMultiLineSelect() {        plsql.parseResource("MultiLineSelect.pls");    }    @Test    public void testIsNull() {        plsql.parseResource("IsNull.pls");    }    @Test    public void testCodingStyleExample() {        plsql.parseResource("CodingStyleExample.pls");    }    @Test    public void testCaseIssue1454() {        plsql.parseResource("CaseIssue1454.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class InOutNoCopyTest extends AbstractPLSQLParserTst {    @Test    public void parseInOutNoCopy() {        ASTInput input = plsql.parseResource("InOutNoCopy.pls");        Assert.assertNotNull(input);        List<ASTFormalParameter> params = input.findDescendantsOfType(ASTFormalParameter.class);        Assert.assertEquals(18, params.size());        //detailed check of first 6 test cases        Assert.assertFalse(params.get(0).isIn());        Assert.assertFalse(params.get(0).isOut());        Assert.assertFalse(params.get(0).isNoCopy());        Assert.assertTrue(params.get(1).isIn());        Assert.assertFalse(params.get(1).isOut());        Assert.assertFalse(params.get(1).isNoCopy());        Assert.assertFalse(params.get(2).isIn());        Assert.assertTrue(params.get(2).isOut());        Assert.assertFalse(params.get(2).isNoCopy());        Assert.assertTrue(params.get(3).isIn());        Assert.assertTrue(params.get(3).isOut());        Assert.assertFalse(params.get(3).isNoCopy());        Assert.assertTrue(params.get(4).isIn());        Assert.assertTrue(params.get(4).isOut());        Assert.assertTrue(params.get(4).isNoCopy());        Assert.assertFalse(params.get(5).isIn());        Assert.assertTrue(params.get(5).isOut());        Assert.assertTrue(params.get(5).isNoCopy());        //piecemeal test of other test cases        Assert.assertFalse(params.get(11).isIn());        Assert.assertTrue(params.get(11).isOut());        Assert.assertTrue(params.get(11).isNoCopy());        Assert.assertTrue(params.get(16).isIn());        Assert.assertTrue(params.get(16).isOut());        Assert.assertTrue(params.get(16).isNoCopy());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectExpressionsTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectExpression() {        plsql.parseResource("SelectExpressions.pls");    }    @Test    public void parseSelectSimpleExpression() {        ASTInput input = plsql.parseResource("SelectSimpleExpression.pls");        Assert.assertNotNull(input);        List<ASTSimpleExpression> simpleExpressions = input.findDescendantsOfType(ASTSimpleExpression.class);        Assert.assertEquals(1, simpleExpressions.size());        ASTSimpleExpression exp = simpleExpressions.get(0);        Assert.assertEquals("e.first_name", exp.getImage());        Assert.assertEquals(2, exp.getNumChildren());        Assert.assertEquals(ASTTableName.class, exp.getChild(0).getClass());        Assert.assertEquals(ASTColumn.class, exp.getChild(1).getClass());    }    @Test    public void parseSelectCount() {        plsql.parseResource("SelectCount.pls");    }    @Test    public void parseSelectSubqueryExpression() {        plsql.parseResource("SelectSubqueryExpressions.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CreateTableTest extends AbstractPLSQLParserTst {    @Test    public void parseCreateTable() {        ASTInput input = plsql.parseResource("CreateTable.pls");        // 5th column of first table statement has a inline constraint of type check        ASTTableColumn columnStatus = input.findChildrenOfType(ASTTable.class).get(0).findChildrenOfType(ASTTableColumn.class).get(4);        Assert.assertEquals("status", columnStatus.getFirstChildOfType(ASTID.class).getImage());        Assert.assertEquals(ConstraintType.CHECK, columnStatus.getFirstChildOfType(ASTInlineConstraint.class).getType());    }    @Test    public void parseCreateOrganizedTable() {        plsql.parseResource("CreateOrganizedTable.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TrimWithRecordTypeTest extends AbstractPLSQLParserTst {    @Test    public void parseTrimWithRecordType() {        plsql.parseResource("TrimWithRecordType.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class WhereClauseTest extends AbstractPLSQLParserTst {    @Test    public void testFunctionCall() {        ASTInput input = plsql.parseResource("WhereClauseFunctionCall.pls");        List<ASTSelectIntoStatement> selectStatements = input.findDescendantsOfType(ASTSelectIntoStatement.class);        Assert.assertEquals(4, selectStatements.size());        ASTFunctionCall functionCall = selectStatements.get(0).getFirstDescendantOfType(ASTFunctionCall.class);        Assert.assertEquals("UPPER", functionCall.getImage());        ASTFunctionCall functionCall2 = selectStatements.get(2).getFirstDescendantOfType(ASTFunctionCall.class);        Assert.assertEquals("utils.get_colname", functionCall2.getImage());    }    @Test    public void testLikeCondition() {        plsql.parseResource("WhereClauseLike.pls");    }    @Test    public void testNullCondition() {        plsql.parseResource("WhereClauseIsNull.pls");    }    @Test    public void testBetweenCondition() {        plsql.parseResource("WhereClauseBetween.pls");    }    @Test    public void testInCondition() {        plsql.parseResource("WhereClauseIn.pls");    }    @Test    public void testIsOfTypeCondition() {        plsql.parseResource("WhereClauseIsOfType.pls");    }    @Test    public void testConcatenationOperator() {        plsql.parseResource("WhereClauseConcatenation.pls");    }    @Test    public void testExistsCondition() {        plsql.parseResource("WhereClauseExists.pls");    }    @Test    public void testMultisetCondition() {        plsql.parseResource("WhereClauseMultiset.pls");    }    @Test    public void testRegexpLikeCondition() {        ASTInput input = plsql.parseResource("WhereClauseRegexpLike.pls");        List<ASTRegexpLikeCondition> regexps = input.findDescendantsOfType(ASTRegexpLikeCondition.class);        Assert.assertEquals(3, regexps.size());        Assert.assertEquals("last_name", regexps.get(1).getSourceChar().getImage());        Assert.assertEquals("'([aeiou])\\1'", regexps.get(1).getPattern().getImage());        Assert.assertEquals("'i'", regexps.get(1).getMatchParam());    }    @Test    public void testSubqueries() {        plsql.parseResource("WhereClauseSubqueries.pls");    }    @Test    public void testParentheses() {        plsql.parseResource("WhereClauseParens.pls");    }    @Test    public void testCurrentOf() {        plsql.parseResource("WhereCurrentOf.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class AnonymousBlockTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorInsideProcAnonymousBlock() {        plsql.parseResource("AnonymousBlock1.sql");    }    @Test    public void parseCursorInsideAnonymousBlock() {        plsql.parseResource("AnonymousBlock2.sql");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TriggerTest extends AbstractPLSQLParserTst {    /**     * Parsing a trigger should not result in a NPE.     *     * @see <a href="https://github.com/pmd/pmd/issues/2325">#2325 [plsql] NullPointerException while running parsing test for CREATE TRIGGER</a>     */    @Test    public void parseCreateTrigger() {        ASTInput input = plsql.parseResource("TriggerUnit.pls");        PLSQLNode trigger = input.getChild(0);        Assert.assertEquals(ASTTriggerUnit.class, trigger.getClass());        Assert.assertNotNull(trigger.getScope());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class CursorWithWithTest extends AbstractPLSQLParserTst {    @Test    public void parseCursorWithWith() {        ASTInput input = plsql.parseResource("CursorWithWith.pls");        ASTCursorUnit cursor = input.getFirstDescendantOfType(ASTCursorUnit.class);        ASTSelectStatement select = (ASTSelectStatement) cursor.getChild(1);        ASTWithClause with = (ASTWithClause) select.getChild(0);        ASTName queryName = (ASTName) with.getChild(0);        Assert.assertEquals("risk_set", queryName.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SlashAsDivisionTest extends AbstractPLSQLParserTst {    @Test    public void parseSlashAsDivision() {        plsql.parseResource("SlashAsDivision.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectHierarchicalTest extends AbstractPLSQLParserTst {    @Test    public void parseSelectHierarchicalQueries() {        plsql.parseResource("SelectHierarchical.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class XMLTableTest extends AbstractPLSQLParserTst {    @Test    public void testParseXMLTable() {        ASTInput node = plsql.parseResource("XMLTable.pls");        List<ASTFunctionCall> functions = node.findDescendantsOfType(ASTFunctionCall.class);        ASTFunctionCall xmlforest = functions.get(functions.size() - 1);        Assert.assertEquals("XMLFOREST", xmlforest.getImage());        Assert.assertEquals("e.employee_id", xmlforest.getChild(1).getImage());        Assert.assertEquals("foo", xmlforest.getChild(2).getImage());        Assert.assertTrue(xmlforest.getChild(2) instanceof ASTID);        Assert.assertEquals("e.last_name", xmlforest.getChild(3).getImage());        Assert.assertEquals("last_name", xmlforest.getChild(4).getImage());        Assert.assertTrue(xmlforest.getChild(4) instanceof ASTID);        Assert.assertEquals("e.salary", xmlforest.getChild(5).getImage());        Assert.assertEquals(6, xmlforest.getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ViewTest extends AbstractPLSQLParserTst {    @Test    public void parseCreateViewIssue981() {        plsql.parseResource("ViewIssue981.pls");    }    @Test    public void parseCreateView() {        plsql.parseResource("CreateViewWithSubquery.pls");    }    @Test    public void parseCreateViewWithoutSemicolon() {        plsql.parseResource("QueryWithoutSemicolon.sql");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class RecordTypeTest extends AbstractPLSQLParserTst {    @Test    public void parseRecordType() {        plsql.parseResource("RecordType.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class FunctionsTest extends AbstractPLSQLParserTst {    @Test    public void parseTrimCall() {        plsql.parseResource("TrimFunction.pls");    }    @Test    public void parseSelectExtractExpression() {        plsql.parseResource("ExtractExpressions.pls");    }    @Test    public void parseXMLExpression() {        plsql.parseResource("XMLFunctions.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class SelectIntoStatementTest extends AbstractPLSQLParserTst {    @Test    public void testParsingComplex() {        plsql.parseResource("SelectIntoStatement.pls");    }    @Test    public void testParsingExample1() {        plsql.parseResource("SelectIntoStatementExample1.pls");    }    @Test    public void testParsingExample2() {        plsql.parseResource("SelectIntoStatementExample2.pls");    }    @Test    public void testParsingExample3() {        plsql.parseResource("SelectIntoStatementExample3.pls");    }    @Test    public void testParsingExample4() {        plsql.parseResource("SelectIntoStatementExample4.pls");    }    @Test    public void testParsingExample5() {        plsql.parseResource("SelectIntoStatementExample5.pls");    }    @Test    public void testParsingWithFunctionCall() {        plsql.parseResource("SelectIntoStatementFunctionCall.pls");    }    @Test    public void testParsingIntoRecordField() {        plsql.parseResource("SelectIntoStatementRecordField.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class IfStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseIfWithElseIf() throws Exception {        String code = "BEGIN\nIF 1 = 1 THEN null;\nELSIF (2 = 2) THEN null;\nELSE null;\nEND IF;\nEND;\n/\n";        ASTInput input = plsql.parse(code);        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ExecuteImmediateTest extends AbstractPLSQLParserTst {    @Test    public void parseExecuteImmediate1047a() {        plsql.parseResource("ExecuteImmediate1047a.pls");    }    @Test    public void parseExecuteImmediate1047b() {        plsql.parseResource("ExecuteImmediate1047b.pls");    }    @Test    public void parseExecuteImmediateString() {        plsql.parseResource("ExecuteImmediateString.pls");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTSqlStatementTest extends AbstractPLSQLParserTst {    @Test    public void testCommit() {        ASTInput input = plsql.parseResource("CommitStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(1, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.COMMIT);    }    @Test    public void testRollback() {        ASTInput input = plsql.parseResource("RollbackStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(1, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.ROLLBACK);    }    @Test    public void testSavepoint() {        ASTInput input = plsql.parseResource("SavepointStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(2, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.SAVEPOINT);        assertType(sqlStatements, 1, ASTSqlStatement.Type.ROLLBACK);    }    @Test    public void testSetTransaction() {        ASTInput input = plsql.parseResource("SetTransactionStatement.pls");        List<ASTSqlStatement> sqlStatements = input.findDescendantsOfType(ASTSqlStatement.class);        Assert.assertEquals(3, sqlStatements.size());        assertType(sqlStatements, 0, ASTSqlStatement.Type.COMMIT);        assertType(sqlStatements, 1, ASTSqlStatement.Type.SET_TRANSACTION);        assertType(sqlStatements, 2, ASTSqlStatement.Type.COMMIT);    }    private void assertType(List<ASTSqlStatement> sqlStatements, int index, ASTSqlStatement.Type expectedType) {        Assert.assertEquals(expectedType, sqlStatements.get(index).getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class UpdateStatementTest extends AbstractPLSQLParserTst {    @Test    public void parseUpdateStatementExample() {        ASTInput input = plsql.parseResource("UpdateStatementExample.pls");        List<ASTUpdateStatement> updateStatements = input.findDescendantsOfType(ASTUpdateStatement.class);        Assert.assertEquals(2, updateStatements.size());        Assert.assertEquals(2, updateStatements.get(1).getFirstChildOfType(ASTUpdateSetClause.class)                .findChildrenOfType(ASTColumn.class).size());    }    @Test    public void parseUpdateStatementExample2() {        ASTInput input = plsql.parseResource("UpdateStatementExample2.pls");        Assert.assertNotNull(input);    }    @Test    public void parseUpdateStatementRef() {        ASTInput input = plsql.parseResource("UpdateStatementRef.pls");        Assert.assertNotNull(input);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTCompoundConditionTest extends AbstractPLSQLParserTst {    @Test    public void testParseType() {        ASTInput input = plsql.parse("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1 AnD user_id = 2; END;");        List<ASTCompoundCondition> compoundConditions = input.findDescendantsOfType(ASTCompoundCondition.class);        Assert.assertFalse(compoundConditions.isEmpty());        Assert.assertEquals("AND", compoundConditions.get(0).getType());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTExtractExpressionTest extends AbstractPLSQLParserTst {    @Test    public void testXml() {        ASTInput unit = plsql.parse("SELECT warehouse_name, EXTRACT(warehouse_spec, '/Warehouse/Docks', "                + "'xmlns:a=\"http://warehouse/1\" xmlns:b=\"http://warehouse/2\"') \"Number of Docks\" "                + " FROM warehouses WHERE warehouse_spec IS NOT NULL;");        ASTExtractExpression extract = unit.getFirstDescendantOfType(ASTExtractExpression.class);        Assert.assertTrue(extract.isXml());        Assert.assertEquals("/Warehouse/Docks", extract.getXPath());        Assert.assertEquals("xmlns:a=\"http://warehouse/1\" xmlns:b=\"http://warehouse/2\"", extract.getNamespace());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class OrderByExpressionsTest extends AbstractPLSQLParserTst {    @Test    public void parseOrderByExpression() {        plsql.parseResource("OrderByExpression.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class ASTComparisonConditionTest extends AbstractPLSQLParserTst {    @Test    public void testOperator() {        ASTInput input = plsql.parse("BEGIN SELECT COUNT(1) INTO MY_TABLE FROM USERS_TABLE WHERE user_id = 1; END;");        List<ASTComparisonCondition> conditions = input.findDescendantsOfType(ASTComparisonCondition.class);        Assert.assertEquals(1, conditions.size());        Assert.assertEquals("=", conditions.get(0).getOperator());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class TableCollectionExpressionTest extends AbstractPLSQLParserTst {    @Test    public void testExamples() {        plsql.parseResource("TableCollectionExpressionExamples.pls");    }    @Test    public void testIssue1526() {        plsql.parseResource("TableCollectionExpressionIssue1526.pls");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.plsql.AbstractPLSQLParserTst;public class StringLiteralsTest extends AbstractPLSQLParserTst {    @Test    public void parseStringLiterals() throws Exception {        ASTInput input = plsql.parseResource("StringLiterals.pls");        List<ASTStringLiteral> strings = input.findDescendantsOfType(ASTStringLiteral.class);        Assert.assertEquals(20, strings.size());        assertString("'Hello'", "Hello", 0, strings);        assertString("N'nchar literal'", "nchar literal", 4, strings);        assertString("nQ'[ab']cd]'", "ab']cd", 11, strings);        assertString("Q'{SELECT * FROM employees WHERE last_name = 'Smith';}'",                "SELECT * FROM employees WHERE last_name = 'Smith';", 13, strings);        assertString("q'{\n" + "    also multiple\n" + "    lines\n" + "  }'",                "\n" + "    also multiple\n" + "    lines\n" + "  ", 15, strings);    }    @Test    public void parseMultilineVarchar() throws Exception {        ASTInput input = plsql.parseResource("MultilineVarchar.pls");        List<ASTStringLiteral> strings = input.findDescendantsOfType(ASTStringLiteral.class);        Assert.assertEquals(1, strings.size());        Assert.assertTrue(normalizeEol(strings.get(0).getString()).startsWith("\ncreate or replace and"));    }    private static void assertString(String quoted, String plain, int index, List<ASTStringLiteral> strings) {        Assert.assertEquals(quoted, normalizeEol(strings.get(index).getImage()));        Assert.assertEquals(plain, normalizeEol(strings.get(index).getString()));    }    private static String normalizeEol(String s) {        return s.replaceAll("\r\n|\n\r|\n|\r", "\n");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.plsql;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;/** * Tests to use XPath rules with PLSQL. */public class PLSQLXPathRuleTest extends AbstractPLSQLParserTst {    private static final String SOURCE =        "create or replace\n" + "package pkg_xpath_problem\n" + "AS\n" + "    PROCEDURE pkg_minimal\n" + "    IS\n"            + "        a_variable VARCHAR2(1);\n" + "    BEGIN \n" + "        --PRAGMA INLINE(output,'YES');\n"            + "        a_variable := 'Y' ;\n" + "    END ;\n" + "end pkg_xpath_problem;\n" + "/\n";    public PLSQLXPathRuleTest() {    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule1() {        testOnVersion(XPathVersion.XPATH_1_0);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule1Compatibility() {        testOnVersion(XPathVersion.XPATH_1_0_COMPATIBILITY);    }    /**     * See https://sourceforge.net/p/pmd/bugs/1166/     */    @Test    public void testXPathRule2() {        testOnVersion(XPathVersion.XPATH_2_0);    }    private void testOnVersion(XPathVersion xpath10) {        XPathRule rule = new XPathRule(xpath10, "//PrimaryPrefix");        rule.setLanguage(LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME));        rule.setMessage("Test Violation");        Report report = plsql.executeRule(rule, SOURCE);        Assert.assertEquals(2, report.getViolations().size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class PLSQLTokenizerTest extends CpdTextComparisonTest {    public PLSQLTokenizerTest() {        super(".sql");    }    @Override    protected String getResourcePrefix() {        return "../lang/plsql/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PLSQLTokenizer();    }        @Test    public void testSimple() {        doTest("sample-plsql");    }    @Test    public void testSpecialComments() {        doTest("specialComments");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on PLSQL file with default version     */    @Test    public void testPlsql() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File plsqlFile = new File("/path/to/MY_PACKAGE.sql");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(plsqlFile);        assertEquals("LanguageVersion must be PLSQL!",                LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.plsql.PLSQLLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { PLSQLLanguageModule.NAME, PLSQLLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(PLSQLLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test plsql's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForceCastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForceTryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnavailableFunctionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProhibitedInterfaceBuilderTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.swift.ast;import org.checkerframework.checker.nullness.qual.NonNull;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.NodePrintersKt;/** * */public class BaseSwiftTreeDumpTest extends BaseTreeDumpTest {    public BaseSwiftTreeDumpTest() {        super(NodePrintersKt.getSimpleNodePrinter(), ".swift");    }    @NonNull    @Override    public SwiftParsingHelper getParser() {        return SwiftParsingHelper.DEFAULT.withResourceContext(getClass(), "testdata");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class SwiftTokenizerTest extends CpdTextComparisonTest {    public SwiftTokenizerTest() {        super(".swift");    }    @Override    protected String getResourcePrefix() {        return "../lang/swift/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new SwiftTokenizer();    }    @Test    public void testSwift42() {        doTest("Swift4.2");    }    @Test    public void testSwift50() {        doTest("Swift5.0");    }    @Test    public void testSwift51() {        doTest("Swift5.1");    }    @Test    public void testSwift52() {        doTest("Swift5.2");    }    @Test    public void testStackoverflowOnLongLiteral() {        doTest("Issue628");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class ObjectiveCTokenizerTest extends CpdTextComparisonTest {    public ObjectiveCTokenizerTest() {        super(".m");    }    @Override    protected String getResourcePrefix() {        return "../lang/objc/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new ObjectiveCTokenizer();    }    @Test    public void testLongSample() {        doTest("big_sample");    }    @Test    public void testUnicodeEscape() {        doTest("unicodeEscapeInString");    }    @Test    public void testUnicodeCharInIdent() {        doTest("unicodeCharInIdent");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;import net.sourceforge.pmd.lang.scala.ast.BaseScalaTest;public class XPathRuleTest extends BaseScalaTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    public void testPrintHelloWorld() {        Report report = evaluate(SCALA_TEST, "//TermApply/TermName[@Image=\"println\"]");        RuleViolation rv = report.getViolations().get(0);        assertEquals(2, rv.getBeginLine());    }    private Report evaluate(String testSource, String xpath) {        XPathRule rule = new XPathRule(XPathVersion.XPATH_2_0, xpath);        rule.setLanguage(LanguageRegistry.getLanguage(ScalaLanguageModule.NAME));        rule.setMessage("XPath Rule Failed");        return scala.executeRuleOnResource(rule, testSource);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.rule;import java.util.concurrent.atomic.AtomicInteger;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.scala.ast.ASTSource;import net.sourceforge.pmd.lang.scala.ast.ASTTermApply;import net.sourceforge.pmd.lang.scala.ast.ASTTermName;import net.sourceforge.pmd.lang.scala.ast.BaseScalaTest;import net.sourceforge.pmd.lang.scala.ast.ScalaNode;public class ScalaRuleTest extends BaseScalaTest {    private static final String SCALA_TEST = "/parserFiles/helloworld.scala";    @Test    public void testRuleVisits() {        final AtomicInteger visited = new AtomicInteger();        ScalaRule rule = new ScalaRule() {            @Override            public RuleContext visit(ScalaNode<?> node, RuleContext data) {                visited.incrementAndGet();                return super.visit(node, data);            }        };        ASTSource root = scala.parseResource(SCALA_TEST);        rule.apply(root, null);        Assert.assertEquals(12, visited.get());    }    @Test    public void testDummyRule() {        ScalaRule rule = new ScalaRule() {            @Override            public String getMessage() {                return "message";            }            @Override            public RuleContext visit(ASTTermApply node, RuleContext data) {                ASTTermName child = node.getFirstChildOfType(ASTTermName.class);                if (child != null && child.hasImageEqualTo("println")) {                    addViolation(data, node);                }                return data;            }        };        Report report = scala.executeRuleOnResource(rule, SCALA_TEST);        Assert.assertEquals(1, report.getViolations().size());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.scala.ast;/** * @author Clment Fournier */public abstract class BaseScalaTest {    protected final ScalaParsingHelper scala = ScalaParsingHelper.DEFAULT.withResourceContext(getClass());}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.ast.TokenMgrError;public class ScalaTokenizerTest extends CpdTextComparisonTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    public ScalaTokenizerTest() {        super(".scala");    }    @Override    protected String getResourcePrefix() {        return "../lang/scala/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new ScalaTokenizer();    }    @Test    public void testSample() {        doTest("sample-LiftActor");    }    @Test    public void testSuppressionComments() {        doTest("special_comments");    }    @Test    public void tokenizeFailTest() {        ex.expect(TokenMgrError.class);        doTest("unlexable_sample");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.scala.ScalaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.13",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.13"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.12",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.12"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.11",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.11"), },            { ScalaLanguageModule.NAME, ScalaLanguageModule.TERSE_NAME, "2.10",                LanguageRegistry.getLanguage(ScalaLanguageModule.NAME).getVersion("2.10"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test scala rulesets */public class RulesetFactoryTest extends AbstractRuleSetFactoryTest {    // no rulesets yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidTrailingCommaTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InnaccurateNumericLiteralTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EqualComparisonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryParenthesesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoElseReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnreachableCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ScopeForInVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConsistentReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GlobalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidWithStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseBaseWithParseIntTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTForInLoopTest extends EcmascriptParserTestBase {    /**     * Note: for each loops are deprecated.     *     * @see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in">for each...in</a>     */    @Test    public void testForEachLoop() {        ASTAstRoot node = js.parse("for each (var item in items) {}");        ASTForInLoop loop = (ASTForInLoop) node.getChild(0);        Assert.assertFalse(loop.isForOf());        Assert.assertTrue(loop.isForEach());    }    @Test    public void testForOfLoop() {        ASTAstRoot node = js.parse("for (var item of items) {}");        ASTForInLoop loop = (ASTForInLoop) node.getChild(0);        Assert.assertTrue(loop.isForOf());        Assert.assertFalse(loop.isForEach());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import org.mozilla.javascript.ast.AstRoot;/** * See the following bugs: #1141 ECMAScript: getFinallyBlock() is buggy. #1142 * ECMAScript: getCatchClause() is buggy */public class ASTTryStatementTest extends EcmascriptParserTestBase {    private ASTTryStatement getTryStmt(String js) {        EcmascriptNode<AstRoot> node = this.js.parse(js);        List<ASTTryStatement> trys = node.findDescendantsOfType(ASTTryStatement.class);        Assert.assertEquals(1, trys.size());        ASTTryStatement tryStmt = trys.get(0);        return tryStmt;    }    @Test    public void testFinallyBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } finally { } }");        Assert.assertNull(tryStmt.getCatchClause(0));        Assert.assertFalse(tryStmt.hasCatch());        Assert.assertEquals(0, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }    @Test    public void testCatchBlockOnly() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(1, tryStmt.getNumCatchClause());        Assert.assertNull(tryStmt.getFinallyBlock());        Assert.assertFalse(tryStmt.hasFinally());    }    @Test    public void testCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt("function() { try { } catch (error) { } finally { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(1, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }    @Test    public void testMultipleCatchAndFinallyBlock() {        ASTTryStatement tryStmt = getTryStmt(                "function() { " + "try { } " + "catch (error if error instanceof BadError) { } "                        + "catch (error2 if error2 instanceof OtherError) { } " + "finally { } }");        Assert.assertNotNull(tryStmt.getCatchClause(0));        Assert.assertNotNull(tryStmt.getCatchClause(1));        Assert.assertTrue(tryStmt.hasCatch());        Assert.assertEquals(2, tryStmt.getNumCatchClause());        Assert.assertNotNull(tryStmt.getFinallyBlock());        Assert.assertTrue(tryStmt.hasFinally());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import java.util.Locale;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;public class TrailingCommaTest extends EcmascriptParserTestBase {    @Rule    public DefaultLocale defaultLocale = new DefaultLocale();    @Test    public void testTrailingCommaDefaultLocale() {        testTrailingComma();    }    @Test    public void testTrailingCommaFrFr() {        defaultLocale.set(Locale.FRANCE);        testTrailingComma();    }    @Test    public void testTrailingCommaRootLocale() {        defaultLocale.set(Locale.ROOT);        testTrailingComma();    }    public void testTrailingComma() {        ASTAstRoot node = js.parse("x = {a : 1, };\n");        ASTObjectLiteral fn = node.getFirstDescendantOfType(ASTObjectLiteral.class);        Assert.assertTrue(fn.isTrailingComma());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.junit.Test;import org.mozilla.javascript.ast.AstRoot;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;public class EcmascriptParserTest extends EcmascriptParserTestBase {    /**     * https://sourceforge.net/p/pmd/bugs/1043/     */    @Test    public void testLineNumbers() {        final String SOURCE_CODE = "function a() {" + PMD.EOL + "  alert('hello');" + PMD.EOL + "}" + PMD.EOL;        EcmascriptNode<AstRoot> node = js.parse(SOURCE_CODE);        assertEquals(1, node.getBeginLine());        assertEquals(1, node.getBeginColumn());        assertEquals(3, node.getEndLine());        assertEquals(1, node.getEndColumn());        Node child = node.getFirstChildOfType(ASTFunctionNode.class);        assertEquals(1, child.getBeginLine());        assertEquals(1, child.getBeginColumn());        assertEquals(3, child.getEndLine());        assertEquals(1, child.getEndColumn());        child = node.getFirstDescendantOfType(ASTFunctionCall.class);        assertEquals(2, child.getBeginLine());        assertEquals(3, child.getBeginColumn());        assertEquals(2, child.getEndLine());        assertEquals(16, child.getEndColumn());    }    /**     * https://sourceforge.net/p/pmd/bugs/1149/     */    @Test    public void testLineNumbersWithinEcmascriptRules() {        String source = "function f(x){\n" + "   if (x) {\n" + "       return 1;\n" + "   } else {\n"                + "       return 0;\n" + "   }\n" + "}";        final List<String> output = new ArrayList<>();        class MyEcmascriptRule extends AbstractEcmascriptRule {            public Object visit(ASTScope node, Object data) {                output.add("Scope from " + node.getBeginLine() + " to " + node.getEndLine());                return super.visit(node, data);            }        }        MyEcmascriptRule rule = new MyEcmascriptRule();        RuleContext ctx = new RuleContext();        rule.apply(js.parse(source), ctx);        assertEquals("Scope from 2 to 4", output.get(0));        assertEquals("Scope from 4 to 6", output.get(1));    }    /**     * Test bug https://sourceforge.net/p/pmd/bugs/1118/     */    @Test    public void testArrayAccess() {        EcmascriptNode<AstRoot> node = js.parse("function a() { b['a'] = 1; c[1] = 2; }");        List<ASTElementGet> arrays = node.findDescendantsOfType(ASTElementGet.class);        assertEquals("b", arrays.get(0).getTarget().getImage());        assertEquals("a", arrays.get(0).getElement().getImage());        assertEquals("c", arrays.get(1).getTarget().getImage());        assertEquals("1", arrays.get(1).getElement().getImage());    }    /**     * Test for bug #1136 ECAMScript: NullPointerException in getLeft() and     * getRight()     */    @Test    public void testArrayMethod() {        EcmascriptNode<AstRoot> rootNode = js.parse(            "function test(){\n" + "  a();      // OK\n" + "  b.c();    // OK\n" + "  d[0]();   // OK\n"                + "  e[0].f(); // OK\n" + "  y.z[0](); // FAIL ==> java.lang.NullPointerException\n" + "}");        List<ASTFunctionCall> calls = rootNode.findDescendantsOfType(ASTFunctionCall.class);        List<String> results = new ArrayList<>();        for (ASTFunctionCall f : calls) {            Node node = f.getTarget();            results.add(getName(node));        }        assertEquals("[a, b.c, d[], e[].f, y.z[]]", results.toString());    }    private String getName(Node node) {        if (node instanceof ASTName) {            return ((ASTName) node).getIdentifier();        }        if (node instanceof ASTPropertyGet) {            final ASTPropertyGet pgNode = (ASTPropertyGet) node;            final String leftName = getName(pgNode.getLeft());            final String rightName = getName(pgNode.getRight());            return leftName + "." + rightName;        }        if (node instanceof ASTElementGet) {            return getName(((ASTElementGet) node).getTarget()) + "[]";        }        return "????";    }    /**     * https://sourceforge.net/p/pmd/bugs/1150/ #1150 "EmptyExpression" for     * valid statements!     */    @Test    public void testCaseAsIdentifier() {        ASTAstRoot rootNode = js.parse("function f(a){\n" + "    a.case.flag = 1;\n" + "    return;\n" + "}");        ASTBlock block = rootNode.getFirstDescendantOfType(ASTBlock.class);        assertFalse(block.getChild(0) instanceof ASTEmptyExpression);        assertTrue(block.getChild(0) instanceof ASTExpressionStatement);        assertTrue(block.getChild(0).getChild(0) instanceof ASTAssignment);    }    /**     * https://sourceforge.net/p/pmd/bugs/1045/ #1045 //NOPMD not working (or     * not implemented) with ECMAscript     */    @Test    public void testSuppressionComment() {        ASTAstRoot root = js.parse("function(x) {\n" + "x = x; //NOPMD I know what I'm doing\n" + "}\n");        assertEquals(" I know what I'm doing", root.getNoPmdComments().get(2));        assertEquals(1, root.getNoPmdComments().size());        ParserOptions parserOptions = new ParserOptions();        parserOptions.setSuppressMarker("FOOOO");        root = js.withParserOptions(parserOptions).parse("function(x) {\n" + "y = y; //NOPMD xyz\n" + "x = x; //FOOOO I know what I'm doing\n" + "}\n");        assertEquals(" I know what I'm doing", root.getNoPmdComments().get(3));        assertEquals(1, root.getNoPmdComments().size());    }    /**     * #1191 Ecmascript fails to parse "void(0)"     */    @Test    public void testVoidKeyword() {        ASTAstRoot rootNode = js.parse("function f(matchFn, fieldval, n){\n"                                           + "    return (matchFn)?(matcharray = eval(matchFn+\"('\"+fieldval+\"','\"+n.id+\"')\")):void(0);\n"                                           + "}\n");        ASTUnaryExpression unary = rootNode.getFirstDescendantOfType(ASTUnaryExpression.class);        assertEquals("void", unary.getImage());    }    /**     * #1192 Ecmascript fails to parse this operator " ^= "     */    @Test    public void testXorAssignment() {        ASTAstRoot rootNode = js.parse("function f() { var x = 2; x ^= 2; x &= 2; x |= 2; "                                           + "x &&= true; x ||= false; x *= 2; x /= 2; x %= 2; x += 2; x -= 2; "                                           + "x <<= 2; x >>= 2; x >>>= 2; }");        ASTAssignment infix = rootNode.getFirstDescendantOfType(ASTAssignment.class);        assertEquals("^=", infix.getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTVariableDeclarationTest extends EcmascriptParserTestBase {    @Test    public void testLet() {        ASTAstRoot node = js.parse("let x = 1;");        ASTVariableDeclaration varDecl = (ASTVariableDeclaration) node.getChild(0);        Assert.assertTrue(varDecl.isLet());        ASTVariableInitializer varInit = (ASTVariableInitializer) varDecl.getChild(0);        ASTName name = (ASTName) varInit.getChild(0);        Assert.assertEquals("x", name.getImage());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.NodePrintersKt;public class JsTreeDumpTest extends BaseTreeDumpTest {    public JsTreeDumpTest() {        super(NodePrintersKt.getSimpleNodePrinter(), ".js");    }    @Override    public BaseParsingHelper<JsParsingHelper, ASTAstRoot> getParser() {        return JsParsingHelper.DEFAULT.withResourceContext(JsTreeDumpTest.class, "testdata");    }    @Test    public void simpleJavascriptFile() {        doTest("SimpleJavascriptFile");    }    @Test    public void jquerySelector() {        doTest("jquery-selector");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ecmascript.ast;import org.junit.Assert;import org.junit.Test;public class ASTFunctionNodeTest extends EcmascriptParserTestBase {    @Test    public void testGetBody() {        ASTAstRoot node = js.parse("function foo() { var a = 'a'; }");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        Assert.assertFalse(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        Assert.assertTrue(body instanceof ASTBlock);    }    @Test    public void testGetBodyFunctionClosureExpression() {        ASTAstRoot node = js.parse("(function(x) x*x)");        ASTFunctionNode fn = node.getFirstDescendantOfType(ASTFunctionNode.class);        Assert.assertTrue(fn.isClosure());        EcmascriptNode<?> body = fn.getBody();        Assert.assertTrue(body instanceof ASTBlock);        Assert.assertTrue(body.getChild(0) instanceof ASTReturnStatement);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.emptyString;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    @Test    public void shouldFindDuplicatesWithDifferentFileExtensions() {        runCPD("--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File1.ts",                "src/test/resources/net/sourceforge/pmd/cpd/ts/File2.ts");        assertThat(getOutput(), containsString("Found a 9 line (32 tokens) duplication in the following files"));    }    @Test    public void shouldFindNoDuplicatesWithDifferentFileExtensions() {        runCPD("--minimum-tokens", "5", "--language", "js", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/ts/");        assertThat(getOutput().trim(), emptyString());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class EcmascriptTokenizerTest extends CpdTextComparisonTest {    public EcmascriptTokenizerTest() {        super(".js");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new EcmascriptTokenizer();    }    @Override    protected String getResourcePrefix() {        return "../lang/ecmascript/cpd/testdata";    }    @Test    public void testSimple() {        doTest("simple");    }    @Test    public void testSimplewithSemis() {        doTest("simpleWithSemis");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1239/     */    @Test    public void parseStringNotAsMultiline() {        doTest("lineContinuations");    }    @Test    public void testIgnoreSingleLineComments() {        doTest("singleLineCommentIgnore");    }    @Test    public void testIgnoreMultiLineComments() {        doTest("multilineCommentIgnore");    }    @Test    public void testTemplateStrings() {        doTest("templateStrings");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * */public class AnyTokenizerForTypescriptTest extends CpdTextComparisonTest {    public AnyTokenizerForTypescriptTest() {        super(".ts");    }    @Override    protected String getResourcePrefix() {        return "testdata/ts";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new AnyTokenizer();    }    @Test    public void testFile1() {        doTest("SampleTypeScript");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testEcmascript() {        executeTarget("testEcmascript");        assertOutputContaining("A 'return', 'break', 'continue', or 'throw' statement should be the last in a block.");        assertOutputContaining("Avoid using global variables");        assertOutputContaining("Use ===/!== to compare with true/false or Numbers");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.util.FileUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CLITest extends BaseCLITest {    @Test    public void useEcmaScript() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "xml", "-R", "ecmascript-basic", "-l",            "ecmascript", "-debug", };        String resultFilename = runTest(args, "useEcmaScript");        assertTrue("Invalid JavaScript version",                FileUtil.findPatternInFile(new File(resultFilename), "Using Ecmascript version: Ecmascript ES6"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ecmascript.EcmascriptLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { EcmascriptLanguageModule.NAME, EcmascriptLanguageModule.TERSE_NAME,                "ES6",                LanguageRegistry.getLanguage(EcmascriptLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import org.junit.Test;import net.sourceforge.pmd.lang.ecmascript.ast.ASTFunctionNode;import net.sourceforge.pmd.lang.ecmascript.ast.EcmascriptParserTestBase;import net.sourceforge.pmd.lang.ecmascript.rule.AbstractEcmascriptRule;public class ReportTest extends EcmascriptParserTestBase {    @Test    public void testExclusionsInReportWithNOPMDEcmascript() {        Rule rule = new AbstractEcmascriptRule() {            @Override            public Object visit(ASTFunctionNode node, Object data) {                addViolationWithMessage(data, node, "Test");                return data;            }        };        rule.setLanguage(js.getDefaultVersion().getLanguage());        Report rpt = js.executeRule(rule, "function(x) // NOPMD test suppress\n{ x = 1; }");        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test javascript's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.VfTokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class VfTokenizerTest extends CpdTextComparisonTest {    public VfTokenizerTest() {        super(".page");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        VfTokenizer tokenizer = new VfTokenizer();        return tokenizer;    }    @Test    public void testTokenize() {        doTest("SampleUnescapeElWithTab");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.nio.file.Path;import java.nio.file.Paths;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfLanguageModule;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfUnescapeElTest extends PmdRuleTst {    public static final String EXPECTED_RULE_MESSAGE = "Avoid unescaped user controlled content in EL";    /**     * Verify that CustomFields stored in sfdx project format are correctly parsed     */    @Test    public void testSfdxCustomFields() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("StandardAccount.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals("Number of violations", 20, ruleViolations.size());        int firstLineWithErrors = 14;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            int expectedLineNumber = firstLineWithErrors + i;            if ((ruleViolations.size() + firstLineWithErrors - 1) == expectedLineNumber) {                // The last line has two errors on the same page                expectedLineNumber = expectedLineNumber - 1;            }            assertEquals("Line Number", expectedLineNumber, ruleViolation.getBeginLine());        }    }    /**     * Verify that CustomFields stored in mdapi format are correctly parsed     */    @Test    public void testMdapiCustomFields() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Vf).resolve("StandardAccount.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals("Number of violations", 6, ruleViolations.size());        int firstLineWithErrors = 8;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals("Line Number", firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Tests a page with a single Apex controller     */    @Test    public void testApexController() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("ApexController.page");        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals("Number of violations", 2, ruleViolations.size());        int firstLineWithErrors = 9;        for (int i = 0; i < ruleViolations.size(); i++) {            // There should start at line 9            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals("Line Number", firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Tests a page with a standard controller and two Apex extensions     */    @Test    public void testExtensions() throws IOException, PMDException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve(Paths.get("StandardAccountWithExtensions.page"));        Report report = runRule(vfPagePath);        List<RuleViolation> ruleViolations = report.getViolations();        assertEquals(8, ruleViolations.size());        int firstLineWithErrors = 9;        for (int i = 0; i < ruleViolations.size(); i++) {            RuleViolation ruleViolation = ruleViolations.get(i);            assertEquals(EXPECTED_RULE_MESSAGE, ruleViolation.getDescription());            assertEquals(firstLineWithErrors + i, ruleViolation.getBeginLine());        }    }    /**     * Runs a rule against a Visualforce page on the file system. This code is based on     * {@link net.sourceforge.pmd.testframework.RuleTst#runTestFromString(String, Rule, Report, LanguageVersion, boolean)}     */    private Report runRule(Path vfPagePath) throws FileNotFoundException, PMDException {        LanguageVersion languageVersion = LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = languageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = languageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse(vfPagePath.toString(), new FileReader(vfPagePath.toFile()));        assertNotNull(node);        // BEGIN Based on RuleTst class        PMD p = new PMD();        p.getConfiguration().setDefaultLanguageVersion(languageVersion);        p.getConfiguration().setIgnoreIncrementalAnalysis(true);        // simple class loader, that doesn't delegate to parent.        // this allows us in the tests to simulate PMD run without        // auxclasspath, not even the classes from the test dependencies        // will be found.        p.getConfiguration().setClassLoader(new ClassLoader() {            @Override            protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {                if (name.startsWith("java.") || name.startsWith("javax.")) {                    return super.loadClass(name, resolve);                }                throw new ClassNotFoundException(name);            }        });        Rule rule = findRule("category/vf/security.xml", "VfUnescapeEl");        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setReport(report);        ctx.setSourceCodeFile(vfPagePath.toFile());        ctx.setLanguageVersion(languageVersion);        ctx.setIgnoreExceptions(false);        RuleSet rules = RuleSet.forSingleRule(rule);        p.getSourceCodeProcessor().processSourceCode(new FileReader(vfPagePath.toFile()), new RuleSets(rules), ctx);        // END Based on RuleTst class        return report;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class VfCsrfTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.vf.DataType;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfParserOptions;public class ObjectFieldTypesTest {    private static final Map<String, DataType> EXPECTED_SFDX_DATA_TYPES;    private static final Map<String, DataType> EXPECTED_MDAPI_DATA_TYPES;    static {        EXPECTED_SFDX_DATA_TYPES = new HashMap<>();        EXPECTED_SFDX_DATA_TYPES.put("Account.Checkbox__c", DataType.Checkbox);        EXPECTED_SFDX_DATA_TYPES.put("Account.DateTime__c", DataType.DateTime);        EXPECTED_SFDX_DATA_TYPES.put("Account.LongTextArea__c", DataType.LongTextArea);        EXPECTED_SFDX_DATA_TYPES.put("Account.Picklist__c", DataType.Picklist);        EXPECTED_SFDX_DATA_TYPES.put("Account.Text__c", DataType.Text);        EXPECTED_SFDX_DATA_TYPES.put("Account.TextArea__c", DataType.TextArea);        // Edge Cases        // Invalid property should return null        EXPECTED_SFDX_DATA_TYPES.put("Account.DoesNotExist__c", null);        EXPECTED_MDAPI_DATA_TYPES = new HashMap<>();        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDCheckbox__c", DataType.Checkbox);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDDateTime__c", DataType.DateTime);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDLongTextArea__c", DataType.LongTextArea);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDPicklist__c", DataType.Picklist);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDText__c", DataType.Text);        EXPECTED_MDAPI_DATA_TYPES.put("Account.MDTextArea__c", DataType.TextArea);        // Edge Cases        // Invalid property should return null        EXPECTED_MDAPI_DATA_TYPES.put("Account.DoesNotExist__c", null);    }    /**     * Verify that CustomFields stored in sfdx project format are correctly parsed     */    @Test    public void testSfdxAccountIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue());    }    /**     * Verify that CustomFields stored in mdapi format are correctly parsed     */    @Test    public void testMdapiAccountIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        validateMDAPIAccount(objectFieldTypes, vfPagePath, VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue());    }    /**     * Verify that fields are found across multiple directories     */    @Test    public void testFieldsAreFoundInMultipleDirectories() {        ObjectFieldTypes objectFieldTypes;        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)            .resolve("SomePage.page");        List<String> paths = Arrays.asList(VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR.defaultValue().get(0),                VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.MDAPI, VFTestUtils.MetadataType.Objects).toString());        objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, paths);        validateMDAPIAccount(objectFieldTypes, vfPagePath, paths);        Collections.reverse(paths);        objectFieldTypes = new ObjectFieldTypes();        validateSfdxAccount(objectFieldTypes, vfPagePath, paths);        validateMDAPIAccount(objectFieldTypes, vfPagePath, paths);    }    @Test    public void testInvalidDirectoryDoesNotCauseAnException() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf).resolve("SomePage.page");        String vfFileName = vfPagePath.toString();        List<String> paths = Arrays.asList(Paths.get("..", "objects-does-not-exist").toString());        ObjectFieldTypes objectFieldTypes = new ObjectFieldTypes();        assertNull(objectFieldTypes.getDataType("Account.DoesNotExist__c", vfFileName, paths));    }    /**     * Validate the expected results when the Account Fields are stored in decomposed sfdx format     */    private void validateSfdxAccount(ObjectFieldTypes objectFieldTypes, Path vfPagePath, List<String> paths) {        validateDataTypes(EXPECTED_SFDX_DATA_TYPES, objectFieldTypes, vfPagePath, paths);    }    /**     * Validate the expected results when the Account Fields are stored in a single file MDAPI format     */    private void validateMDAPIAccount(ObjectFieldTypes objectFieldTypes, Path vfPagePath, List<String> paths) {        validateDataTypes(EXPECTED_MDAPI_DATA_TYPES, objectFieldTypes, vfPagePath, paths);    }    /**     * Verify that return values of {@link SalesforceFieldTypes#getDataType(String, String, List)} using the keys of     * {@code expectedDataTypes} matches the values of {@code expectedDataTypes}     */    public static void validateDataTypes(Map<String, DataType> expectedDataTypes, SalesforceFieldTypes fieldTypes,                                         Path vfPagePath, List<String> paths) {        String vfFileName = vfPagePath.toString();        for (Map.Entry<String, DataType> entry : expectedDataTypes.entrySet()) {            assertEquals(entry.getKey(), entry.getValue(), fieldTypes.getDataType(entry.getKey(), vfFileName, paths));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.IOException;import java.util.List;import java.util.Map;import java.util.stream.Collectors;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer;public class ASTExpressionTest {    /**     * Slightly different scenarios which cause different AST, but should return the same results.     */    private static final String[] SNIPPET_TEMPLATES = new String[] {        "{!%s}",        "<apex:outputText value=\"{!%s}\" escape=\"false\"/>",        "<script>function someFunc() {var foo = \"{!%s}\";}</script>"};    @Test    public void testExpressionWithApexGetter() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyValue"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertTrue(template, map.containsKey("MyValue"));            assertTrue(template, map.get("MyValue") instanceof ASTIdentifier);        }    }    @Test    public void testExpressionWithStandardController() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c.Text__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertTrue(template, map.containsKey("MyObject__c.Text__c"));            assertTrue(template, map.get("MyObject__c.Text__c") instanceof ASTIdentifier);        }    }    @Test    public void testSelectOptions() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "userOptions.0"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertTrue(template, map.containsKey("userOptions.0"));            assertTrue(template, map.get("userOptions.0") instanceof ASTLiteral);        }    }    @Test    public void testMultipleIdentifiers() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c.Text__c + ' this is a string' + MyObject__c.Text2__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 2, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertEquals(template, 2, map.size());            assertTrue(template, map.containsKey("MyObject__c.Text__c"));            assertTrue(template, map.get("MyObject__c.Text__c") instanceof ASTIdentifier);            assertTrue(template, map.containsKey("MyObject__c.Text2__c"));            assertTrue(template, map.get("MyObject__c.Text2__c") instanceof ASTIdentifier);        }    }    @Test    public void testIdentifierWithRelation() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c.MyObject2__r.Text__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 1, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertEquals(template, 1, map.size());            assertTrue(template, map.containsKey("MyObject1__c.MyObject2__r.Text__c"));            assertTrue(template, map.get("MyObject1__c.MyObject2__r.Text__c") instanceof ASTIdentifier);        }    }    @Test    public void testMultipleIdentifiersWithRelation() throws ASTExpression.DataNodeStateException {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c.MyObject2__r.Text__c + ' this is a string' + MyObject1__c.MyObject2__r.Text2__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 1, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            Map<VfTypedNode, String> identifiers = expression.getDataNodes();            assertEquals(template, 2, identifiers.size());            Map<String, Node> map = invertMap(identifiers);            assertEquals(template, 2, map.size());            assertTrue(template, map.containsKey("MyObject1__c.MyObject2__r.Text__c"));            assertTrue(template, map.get("MyObject1__c.MyObject2__r.Text__c") instanceof ASTIdentifier);            assertTrue(template, map.containsKey("MyObject1__c.MyObject2__r.Text2__c"));            assertTrue(template, map.get("MyObject1__c.MyObject2__r.Text2__c") instanceof ASTIdentifier);        }    }    /**     * The current implementation does not support expressing statements using array notation. This notation introduces     * complexities that may be addressed in a future release.     */    @Test    public void testExpressionWithArrayIndexingNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject__c['Name']"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 2, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    @Test    public void testIdentifierWithRelationIndexedAsArrayNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "MyObject1__c['MyObject2__r'].Text__c"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 2, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    @Test    public void testIdentifierWithComplexIndexedArrayNotSupported() {        for (String template : SNIPPET_TEMPLATES) {            ASTCompilationUnit compilationUnit = compile(String.format(template, "theLineItems[item.Id].UnitPrice"));            List<Node> nodes = getExpressions(compilationUnit);            assertEquals(template, 2, nodes.size());            ASTExpression expression = (ASTExpression) nodes.get(0);            try {                expression.getDataNodes();                fail(template + " should have thrown");            } catch (ASTExpression.DataNodeStateException expected) {                // Intentionally left blank            }        }    }    private static List<Node> getExpressions(ASTCompilationUnit compilationUnit) {        return compilationUnit.descendants(ASTExpression.class).toList(it -> it);    }    /**     * Invert the map to make it easier to unit test.     */    private Map<String, Node> invertMap(Map<VfTypedNode, String> map) {        Map<String, Node> result = map.entrySet().stream()                                      .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));        // Ensure no values have been lost        assertEquals(map.size(), result.size());        return result;    }    private ASTCompilationUnit compile(String snippet) {        return compile(snippet, false);    }    private ASTCompilationUnit compile(String snippet, boolean renderAST) {        ASTCompilationUnit node = VfParsingHelper.DEFAULT.parse(            "<apex:page>"                + snippet                + "</apex:page>"        );        if (renderAST) {            try {                new XmlTreeRenderer().renderSubtree(node, System.out);            } catch (IOException e) {                throw new RuntimeException(e);            }        }        return node;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.jupiter.api.Assertions.assertNull;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.nio.file.Path;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;import net.sourceforge.pmd.lang.vf.DataType;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfLanguageModule;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer;public class VfExpressionTypeVisitorTest {    private static final Map<String, DataType> EXPECTED_CUSTOM_FIELD_DATA_TYPES;    private static final Map<String, DataType> EXPECTED_APEX_DATA_TYPES;    static {        EXPECTED_CUSTOM_FIELD_DATA_TYPES = new HashMap<>();        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("CreatedDate", DataType.DateTime);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("DateTime__c", DataType.DateTime);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Checkbox__c", DataType.Checkbox);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Name", DataType.Text);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Text__c", DataType.Text);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("TextArea__c", DataType.TextArea);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("LongTextArea__c", DataType.LongTextArea);        EXPECTED_CUSTOM_FIELD_DATA_TYPES.put("Picklist__c", DataType.Picklist);        EXPECTED_APEX_DATA_TYPES = new HashMap<>();        EXPECTED_APEX_DATA_TYPES.put("AccountIdProp", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("AccountId", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountId", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountIdProp", DataType.Lookup);        EXPECTED_APEX_DATA_TYPES.put("AccountName", DataType.Text);        EXPECTED_APEX_DATA_TYPES.put("InnerAccountName", DataType.Text);        EXPECTED_APEX_DATA_TYPES.put("ConflictingProp", DataType.Unknown);    }    /**     * Strings that use dot notation(Account.CreatedDate) result in ASTIdentifier nodes     */    @Test    public void testXpathQueryForCustomFieldIdentifiers() throws FileNotFoundException {        Node rootNode = compile("StandardAccount.page");        for (Map.Entry<String, DataType> entry : EXPECTED_CUSTOM_FIELD_DATA_TYPES.entrySet()) {            List<ASTIdentifier> nodes = getIdentifiers(rootNode, entry);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(entry.getKey(), 2, nodes.size());            for (Node node : nodes) {                assertEquals(entry.getKey(), node.getImage());                assertTrue(node.getClass().getSimpleName(), node instanceof ASTIdentifier);                ASTIdentifier identifier = (ASTIdentifier) node;                assertEquals(entry.getKey(), entry.getValue(), identifier.getDataType());            }        }    }    /**     * Strings that use array notation, Account['CreatedDate') don't have a DataType added. This type of notation     * creates ambiguous situations with Apex methods that return Maps. This may be addressed in a future release.     */    @Test    public void testXpathQueryForCustomFieldLiteralsHaveNullDataType() throws FileNotFoundException {        Node rootNode = compile("StandardAccount.page");        for (Map.Entry<String, DataType> entry : EXPECTED_CUSTOM_FIELD_DATA_TYPES.entrySet()) {            List<ASTLiteral> nodes = rootNode.descendants(ASTLiteral.class)                                             // Literals are surrounded by apostrophes                                             .filterMatching(ASTLiteral::getImage, "'" + entry.getKey() + "'")                                             .filterMatching(ASTLiteral::getDataType, null)                                             .toList();            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(entry.getKey(), 2, nodes.size());            for (Node node : nodes) {                assertEquals(String.format("'%s'", entry.getKey()), node.getImage());                assertTrue(node.getClass().getSimpleName(), node instanceof ASTLiteral);                ASTLiteral literal = (ASTLiteral) node;                assertEquals(entry.getKey(), null, literal.getDataType());            }        }    }    /**     * Nodes where the DataType can't be determined should have a null DataType     */    @Test    public void testDataTypeForCustomFieldsNotFound() throws FileNotFoundException {        Node rootNode = compile("StandardAccount.page");        checkNodes(rootNode.descendants(ASTIdentifier.class)                           .filterMatching(ASTIdentifier::getImage, "NotFoundField__c"));        checkNodes(rootNode.descendants(ASTLiteral.class)                           .filterMatching(ASTLiteral::getImage, "'NotFoundField__c'"));    }    private void checkNodes(NodeStream<? extends VfTypedNode> nodeStream) {        // Each string appears twice, it is set on a "value" attribute and inline        List<? extends VfTypedNode> nodes = nodeStream.toList();        assertEquals(2, nodes.size());        for (VfTypedNode node : nodes) {            assertNull(node.getDataType());        }    }    /**     * Apex properties result in ASTIdentifier nodes     */    @Test    public void testXpathQueryForProperties() throws FileNotFoundException {        Node rootNode = compile("ApexController.page");        for (Map.Entry<String, DataType> entry : EXPECTED_APEX_DATA_TYPES.entrySet()) {            List<ASTIdentifier> nodes = getIdentifiers(rootNode, entry);            // Each string appears twice, it is set on a "value" attribute and inline            assertEquals(entry.getKey(), 2, nodes.size());            for (Node node : nodes) {                assertEquals(entry.getKey(), node.getImage());                assertTrue(node.getClass().getSimpleName(), node instanceof ASTIdentifier);                ASTIdentifier identifier = (ASTIdentifier) node;                assertEquals(entry.getKey(), entry.getValue(), identifier.getDataType());            }        }    }    private List<ASTIdentifier> getIdentifiers(Node rootNode, Entry<String, DataType> entry) {        return rootNode.descendants(ASTIdentifier.class)                       .filterMatching(ASTIdentifier::getImage, entry.getKey())                       .filterMatching(ASTIdentifier::getDataType, entry.getValue())                       .toList();    }    /**     * Nodes where the DataType can't be determined should have a null DataType     */    @Test    public void testDataTypeForApexPropertiesNotFound() throws FileNotFoundException {        Node rootNode = compile("ApexController.page");        // Each string appears twice, it is set on a "value" attribute and inline        checkNodes(rootNode.descendants(ASTIdentifier.class)                           .filterMatching(ASTIdentifier::getImage, "NotFoundProp"));    }    private Node compile(String pageName) throws FileNotFoundException {        return compile(pageName, false);    }    private Node compile(String pageName, boolean renderAST) throws FileNotFoundException {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve(pageName);        return compile(vfPagePath, renderAST);    }    private Node compile(Path vfPagePath, boolean renderAST) throws FileNotFoundException {        LanguageVersion languageVersion = LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = languageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = languageVersion.getLanguageVersionHandler().getParser(parserOptions);        Node node = parser.parse(vfPagePath.toString(), new FileReader(vfPagePath.toFile()));        assertNotNull(node);        if (renderAST) {            try {                new XmlTreeRenderer().renderSubtree(node, System.out);            } catch (IOException e) {                throw new RuntimeException(e);            }        }        return node;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;/** * @author sergey.gorbaty */public class VfParserTest extends AbstractVfTest {    @Test    public void testSingleDoubleQuoteAndEL() {        vf.parse("<span escape='false' attrib=\"{!call}\">${!'yes'}</span>");    }    @Test    public void testSingleDoubleQuoteAndELFunction() {        vf.parse("<span escape='false' attrib=\"{!call}\">${!method}</span>");    }    @Test    public void testSingleDoubleQuote() {        vf.parse("<span escape='false' attrib=\"{!call}\">${\"yes\"}</span>");    }    @Test    public void testAttributeNameWithDot() {        vf.parse("<table-row keep-together.within-page=\"always\" >");    }    @Test    public void testAttributeNameWithUnderscore() {        vf.parse("<table-row test_attribute=\"always\" >");    }    @Test    public void testAttributeNameWithColon() {        vf.parse("<table-row test:attribute=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidSymbol() {        vf.parse("<table-row test&attribute=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidDot() {        vf.parse("<table-row .class=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidDotV2() {        vf.parse("<table-row test..attribute=\"always\" >");    }    @Test(expected = ParseException.class)    public void testAttributeNameWithInvalidDotV3() {        vf.parse("<table-row test.attribute.=\"always\" >");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import java.util.List;import org.junit.Test;public class VfPageStyleTest extends AbstractVfTest {    /**     * Test parsing of a EL expression.     */    @Test    public void testElExpression() {        List<ASTElExpression> expressions = vf.getNodes(ASTElExpression.class, VF_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "myBean", id.getImage());        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "get", dotid.getImage());        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("Correct expression content expected!", "\"{! World }\"", literal.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testElExpressionInAttribute() {        List<ASTElExpression> expressions = vf.getNodes(ASTElExpression.class, VF_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        ASTExpression exp = expression.getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = exp.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "myValidator", id.getImage());        ASTDotExpression dot = exp.getFirstChildOfType(ASTDotExpression.class);        ASTIdentifier dotid = dot.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Correct expression content expected!", "find", dotid.getImage());        ASTArguments arguments = exp.getFirstChildOfType(ASTArguments.class);        ASTExpression innerExpression = arguments.getFirstChildOfType(ASTExpression.class);        ASTLiteral literal = innerExpression.getFirstChildOfType(ASTLiteral.class);        assertEquals("Correct expression content expected!", "\"'vf'\"", literal.getImage());    }    private static final String VF_EL_EXPRESSION = "<html><title>Hello {!myBean.get(\"{! World }\") } .vf</title></html>";    private static final String VF_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').{!myValidator.find(\"'vf'\")}\" /> </html>";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VfPageStyleTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertNull;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.lang.vf.DataType;import net.sourceforge.pmd.lang.vf.VFTestUtils;import net.sourceforge.pmd.lang.vf.VfParserOptions;public class ApexClassPropertyTypesTest {    private static final Map<String, DataType> EXPECTED_DATA_TYPES;    static {        // Intentionally use the wrong case for property names to ensure that they can be found. The Apex class name        // must have the correct case since it is used to lookup the file. The Apex class name is guaranteed to be correct        // in the Visualforce page, but the property names are not        EXPECTED_DATA_TYPES = new HashMap<>();        EXPECTED_DATA_TYPES.put("ApexController.accOuntIdProp", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.AcCountId", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.AcCountname", DataType.Text);        // InnerController        // The class should be parsed to Unknown. It's not a valid expression on its own.        EXPECTED_DATA_TYPES.put("ApexController.innErController", DataType.Unknown);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountIdProp", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountid", DataType.Lookup);        EXPECTED_DATA_TYPES.put("ApexController.innErController.innErAccountnAme", DataType.Text);        // Edge cases        // Invalid class should return null        EXPECTED_DATA_TYPES.put("unknownclass.invalidProperty", null);        // Invalid class property should return null        EXPECTED_DATA_TYPES.put("ApexController.invalidProperty", null);        /*         * It is possible to have a property and method with different types that resolve to the same Visualforce         * expression. An example is an Apex class with a property "public String Foo {get; set;}" and a method of         * "Integer getFoo() { return 1; }". These properties should map to {@link DataType#Unknown}.         */        EXPECTED_DATA_TYPES.put("ApexController.ConflictingProp", DataType.Unknown);    }    @Test    public void testApexClassIsProperlyParsed() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                                     .resolve("SomePage.page");        ApexClassPropertyTypes apexClassPropertyTypes = new ApexClassPropertyTypes();        ObjectFieldTypesTest.validateDataTypes(EXPECTED_DATA_TYPES, apexClassPropertyTypes, vfPagePath,                                               VfParserOptions.APEX_DIRECTORIES_DESCRIPTOR.defaultValue());    }    @Test    public void testInvalidDirectoryDoesNotCauseAnException() {        Path vfPagePath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Vf)                .resolve("SomePage.page");        String vfFileName = vfPagePath.toString();        List<String> paths = Arrays.asList(Paths.get("..", "classes-does-not-exist").toString());        ApexClassPropertyTypes apexClassPropertyTypes = new ApexClassPropertyTypes();        assertNull(apexClassPropertyTypes.getDataType("ApexController.accOuntIdProp", vfFileName, paths));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.util.Collections;import java.util.Comparator;import java.util.Iterator;import java.util.List;import org.junit.Test;/** * Test parsing of a VF in document style, by checking the generated AST. * Original @author pieter_van_raemdonck - Application Engineers NV/SA - * www.ae.be * * @author sergey.gorbaty - VF adaptation * */public class VfDocStyleTest extends AbstractVfTest {    /**     * Smoke test for VF parser.     */    @Test    public void testSimplestVf() {        List<ASTElement> nodes = vf.getNodes(ASTElement.class, TEST_SIMPLEST_HTML);        assertEquals("Exactly " + 1 + " element(s) expected", 1, nodes.size());    }    /**     * Test the information on a Element and Attribute.     */    @Test    public void testElementAttributeAndNamespace() {        ASTCompilationUnit root = vf.parse(TEST_ELEMENT_AND_NAMESPACE);        List<ASTElement> elementNodes = root.findDescendantsOfType(ASTElement.class);        assertEquals("One element node expected!", 1, elementNodes.size());        ASTElement element = elementNodes.iterator().next();        assertEquals("Correct name expected!", "h:html", element.getName());        assertTrue("Has namespace prefix!", element.isHasNamespacePrefix());        assertTrue("Element is empty!", element.isEmpty());        assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "html", element.getLocalName());        List<ASTAttribute> attributeNodes = root.findDescendantsOfType(ASTAttribute.class);        assertEquals("One attribute node expected!", 1, attributeNodes.size());        ASTAttribute attribute = attributeNodes.iterator().next();        assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());        assertTrue("Has namespace prefix!", attribute.isHasNamespacePrefix());        assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix", attribute.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    public void testAttributeValueContainingHash() {        List<ASTAttribute> attributes = vf.getNodes(ASTAttribute.class, TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        assertEquals("Three attributes expected!", 3, attributes.size());        ASTAttribute attr = attributes.get(0);        assertEquals("Correct attribute name expected!", "something", attr.getName());        assertEquals("Correct attribute value expected!", "#yes#",                     attr.getFirstDescendantOfType(ASTText.class).getImage());        attr = attributes.get(1);        assertEquals("Correct attribute name expected!", "foo", attr.getName());        assertEquals("Correct attribute value expected!", "CREATE",                attr.getFirstDescendantOfType(ASTText.class).getImage());        attr = attributes.get(2);        assertEquals("Correct attribute name expected!", "href", attr.getName());        assertEquals("Correct attribute value expected!", "#", attr.getFirstDescendantOfType(ASTText.class).getImage());    }    /**     * Test correct parsing of CDATA.     */    @Test    public void testCData() {        List<ASTCData> cdataNodes = vf.getNodes(ASTCData.class, TEST_CDATA);        assertEquals("One CDATA node expected!", 1, cdataNodes.size());        ASTCData cdata = cdataNodes.iterator().next();        assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());    }    /**     * Test parsing of Doctype declaration.     */    @Test    public void testDoctype() {        ASTCompilationUnit root = vf.parse(TEST_DOCTYPE);        List<ASTDoctypeDeclaration> docTypeDeclarations = root.findDescendantsOfType(ASTDoctypeDeclaration.class);        assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());        List<ASTDoctypeExternalId> externalIds = root.findDescendantsOfType(ASTDoctypeExternalId.class);        assertEquals("One doctype external id expected!", 1, externalIds.size());        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());        assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",                externalId.getUri());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "Script!", text.getImage());    }    /**     * Test parsing of EL in attribute of an element.     */    @Test    public void testELInTagValue() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE);        assertEquals("One element expected!", 1, elements.size());        ASTElement element = elements.iterator().next();        ASTAttributeValue attribute = element.getFirstDescendantOfType(ASTAttributeValue.class);        ASTIdentifier id = attribute.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "foo", id.getImage());    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    public void testELInTagValueWithCommentDQ() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT);        assertEquals("One element expected!", 1, elements.size());        ASTElement element = elements.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "init", id.getImage());    }    /**     * Test parsing of EL in attribute of an element that also has a comment.     */    @Test    public void testELInTagValueWithCommentSQ() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ);        assertEquals("One element expected!", 1, elements.size());        ASTElement element = elements.iterator().next();        ASTElExpression elExpr = element.getFirstDescendantOfType(ASTElExpression.class);        ASTIdentifier id = elExpr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct identifier expected", "init", id.getImage());    }    /**     * Test parsing of EL in HTML &lt;script&gt; element.     */    @Test    public void testELInHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext=", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of inline comment in EL.     */    @Test    public void testInlineCommentInEL() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext=", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of quoted EL in HTML &lt;script&gt; element.     */    @Test    public void testQuotedELInHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_QUOTED_EL_IN_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "vartext='textHere", text.getImage());        ASTElExpression el = script.getFirstChildOfType(ASTElExpression.class);        ASTIdentifier id = el.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Correct EL content expected!", "elInScript", id.getImage());    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be     * valid html but it is likely to appear in .page files.     */    @Test    public void testImportHtmlScript() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttribute> attr = script.findDescendantsOfType(ASTAttribute.class);        assertEquals("One script expected!", 1, attr.size());        ASTAttribute att = attr.iterator().next();        ASTAttributeValue val = att.getFirstChildOfType(ASTAttributeValue.class);        ASTText text = val.getFirstChildOfType(ASTText.class);        assertEquals("filename.js", text.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScriptWithAttribute() {        List<ASTHtmlScript> scripts = vf.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        ASTText text = script.getFirstChildOfType(ASTText.class);        assertEquals("Correct script content expected!", "Script!", text.getImage());        List<ASTText> attrs = script.findDescendantsOfType(ASTText.class);        assertEquals("text/javascript", attrs.get(0).getImage());    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    public void testComplexHtmlScript() {        List<ASTHtmlScript> script = vf.getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals("One script expected!", 1, script.size());        ASTHtmlScript next = script.iterator().next();        ASTText text = next.getFirstChildOfType(ASTText.class);        assertTrue(text.getImage().contains("<!--"));    }    /**     * Test parsing of HTML &lt;style&gt; element.     */    @Test    public void testInlineCss() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals("Two elements expected!", 3, elements.size());    }    /**     * Test parsing of HTML text within element.     */    @Test    public void testTextInTag() {        List<ASTText> scripts = vf.getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals("One text chunk expected!", 1, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    public void noSpacesBetweenTags() {        List<ASTElement> scripts = vf.getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals("Two tags expected!", 2, scripts.size());        Iterator<ASTElement> iterator = scripts.iterator();        ASTElement script = iterator.next();        assertEquals("Correct content expected!", "a", script.getName());        script = iterator.next();        assertEquals("Correct content expected!", "b", script.getName());    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    public void unclosedTagsWithDollar() {        List<ASTText> scripts = vf.getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " $ ", script.getImage());    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    public void unclosedTagsWithELWithin() {        List<ASTElement> element = vf.getNodes(ASTElement.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals("One element expected!", 1, element.size());        for (ASTElement elem : element) {            ASTContent content = elem.getFirstChildOfType(ASTContent.class);            List<ASTElExpression> els = content.findChildrenOfType(ASTElExpression.class);            assertEquals("Two EL expressions expected!", 2, els.size());            ASTElExpression node = (ASTElExpression) content.getChild(0);            ASTIdentifier id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("Correct content expected!", "expr1", id.getImage());            node = (ASTElExpression) content.getChild(1);            id = node.getFirstDescendantOfType(ASTIdentifier.class);            assertEquals("Correct content expected!", "expr2", id.getImage());        }    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void textAfterOpenAndClosedTag() {        List<ASTElement> nodes = vf.getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two elements expected!", 2, nodes.size());        assertEquals("First element should be a", "a", nodes.get(0).getName());        assertFalse("first element should be closed", nodes.get(0).isUnclosed());        assertEquals("Second element should be b", "b", nodes.get(1).getName());        assertTrue("Second element should not be closed", nodes.get(1).isUnclosed());        List<ASTText> text = vf.getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two text chunks expected!", 2, text.size());    }    @Test    public void quoteEL() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        List<ASTElExpression> els = attr.findChildrenOfType(ASTElExpression.class);        assertEquals("Must be 1!", 1, els.size());        ASTExpression expr = els.get(0).getFirstChildOfType(ASTExpression.class);        ASTIdentifier id = expr.getFirstChildOfType(ASTIdentifier.class);        assertEquals("Expected to detect proper value for attribute!", "something", id.getImage());    }    /**     * smoke test for a non-quoted attribute value     */    @Test    public void quoteAttrValue() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("Expected to detect proper value for attribute!", "yes|", text.getImage());    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    public void noQuoteAttrEmpty() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_EMPTY_ATTR);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertNull("Expected to detect proper value for attribute!", attr.getImage());    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    public void singleQuoteAttrTab() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_TAB_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTText text = attr.getFirstChildOfType(ASTText.class);        assertEquals("Expected to detect proper value for attribute!", "\t", text.getImage());    }    @Test    public void unclosedTag() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("Second element should be tag:someTag", "tag:someTag", elements.get(0).getName());        assertEquals("First element should be sorted tag:if", "tag:if", elements.get(1).getName());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());    }    @Test    public void unclosedTagAndNoQuotesForAttribute() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_ATTR);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("Second element should be tag:someTag", "tag:someTag", elements.get(0).getName());        assertEquals("First element should be sorted tag:if", "tag:if", elements.get(1).getName());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());    }    @Test    public void unclosedTagMultipleLevels() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("3 tags expected", 3, elements.size());        assertEquals("First element should be sorted tag:someTag", "tag:someTag", sortedElmnts.get(0).getName());        assertEquals("Second element should be tag:someTag", "tag:someTag", sortedElmnts.get(1).getName());        assertEquals("Third element should be tag:x", "tag:x", sortedElmnts.get(2).getName());        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        assertFalse(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    public void nestedEmptyTags() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Third element should be html", "html", sortedElmnts.get(3).getName());        // a1        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2        assertTrue(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertFalse(sortedElmnts.get(2).isUnclosed());        // html        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt;     * &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    public void nestedMultipleTags() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 6, elements.size());        assertEquals("First element should a1", "a1", sortedElmnts.get(0).getName());        assertEquals("Second element should be a2", "a2", sortedElmnts.get(1).getName());        assertEquals("Third element should be a3", "a3", sortedElmnts.get(2).getName());        assertEquals("Forth element should be a4", "a4", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be b", "b", sortedElmnts.get(4).getName());        assertEquals("Sixth element should be html", "html", sortedElmnts.get(5).getName());        // a1 not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // a2 not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // a3 empty and not closed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // a4 empty but closed        assertTrue(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());        // b empty but closed        assertTrue(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());        // html not empty and closed        assertFalse(sortedElmnts.get(5).isEmpty());        assertFalse(sortedElmnts.get(5).isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt;     * &lt;/x&gt; . Here x is the first tag to be closed thus rendering the next     * close of a (&lt;/a&gt;) to be disregarded.     */    @Test    public void unclosedParentTagClosedBeforeChild() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // b        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This should     * be disregarded and structure of children and parents should not be     * influenced. in other words &lt;/a&gt; should close the first &lt;a&gt;     * tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    public void unmatchedTagDoesNotInfluenceStructure() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("4 tags expected", 4, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be b", "b", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be x", "x", sortedElmnts.get(3).getName());        // a is not empty and closed        assertFalse(sortedElmnts.get(0).isEmpty());        assertFalse(sortedElmnts.get(0).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(1).isEmpty());        assertTrue(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(3).isEmpty());        assertFalse(sortedElmnts.get(3).isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt; An unmatched closing of 'z' appears randomly in the document.     * This should be disregarded and structure of children and parents should     * not be influenced. Also un unclosed &lt;a&gt; tag appears at the start of     * the document     */    @Test    public void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        List<ASTElement> elements = vf.getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        List<ASTElement> sortedElmnts = sortNodesByName(elements);        assertEquals("5 tags expected", 5, elements.size());        assertEquals("First element should be 'a'", "a", sortedElmnts.get(0).getName());        assertEquals("Second element should be a", "a", sortedElmnts.get(1).getName());        assertEquals("Third element should be b", "b", sortedElmnts.get(2).getName());        assertEquals("Forth element should be b", "b", sortedElmnts.get(3).getName());        assertEquals("Fifth element should be x", "x", sortedElmnts.get(4).getName());        // first a is empty and unclosed        assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(sortedElmnts.get(0).isUnclosed());        // second a not empty and closed        assertFalse(sortedElmnts.get(1).isEmpty());        assertFalse(sortedElmnts.get(1).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(2).isEmpty());        assertTrue(sortedElmnts.get(2).isUnclosed());        // b empty and unclosed        assertTrue(sortedElmnts.get(3).isEmpty());        assertTrue(sortedElmnts.get(3).isUnclosed());        // x not empty and closed        assertFalse(sortedElmnts.get(4).isEmpty());        assertFalse(sortedElmnts.get(4).isUnclosed());    }    /**     * will sort the AST element in list in alphabetical order and if tag name     * is the same it will sort against o1.getBeginColumn() +""+     * o1.getBeginLine(). so first criteria is the name, then the second is the     * column +""+line string.     *     * @param elements     * @return     */    private List<ASTElement> sortNodesByName(List<ASTElement> elements) {        Collections.sort(elements, new Comparator<ASTElement>() {            @Override            public int compare(ASTElement o1, ASTElement o2) {                if (o1.getName() == null) {                    return Integer.MIN_VALUE;                }                if (o2.getName() == null) {                    return Integer.MAX_VALUE;                }                if (o1.getName().equals(o2.getName())) {                    String o1Value = o1.getBeginColumn() + "" + o1.getBeginLine();                    String o2Value = o2.getBeginColumn() + "" + o2.getBeginLine();                    return o1Value.compareTo(o2Value);                }                return o1.getName().compareTo(o2.getName());            }        });        return elements;    }    @Test    public void noQuoteAttrWithJspEL() {        List<ASTAttributeValue> attributes = vf.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        ASTIdentifier id = attr.getFirstDescendantOfType(ASTIdentifier.class);        assertEquals("Expected to detect proper value for EL in attribute!", "something", id.getImage());    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE = "<apex:page action=\"{!foo}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT = "<apex:page action=\"{!/*comment here*/init}\">text</apex:page>";    private static final String TEST_EL_IN_TAG_ATTRIBUTE_WITH_COMMENT_SQ = "<apex:page action='{!/*comment here*/init}'>text</apex:page>";    private static final String TEST_EL_IN_HTML_SCRIPT = "<html><head><script>var text={!elInScript};</script></head></html>";    private static final String TEST_EL_IN_HTML_SCRIPT_WITH_COMMENT = "<html><head><script>var text={!/*junk1*/elInScript/*junk2*/};</script></head></html>";    private static final String TEST_QUOTED_EL_IN_HTML_SCRIPT = "<html><head><script>var text='textHere{!elInScript}';</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" /></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>{!expr1}{!expr2}</a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"{!something}\" > </tag:if>";    private static final String TEST_ATTR = "<tag:if something=\"yes|\" > </tag:if>";    private static final String TEST_EMPTY_ATTR = "<tag:if something= >  <a href=\"http://someHost:/some_URL\" >foo</a> </tag:if>";    private static final String TEST_TAB_ATTR = "<tag:if something='\t' >   </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if something=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag something=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_ATTR = "<tag:someTag> <tag:if something='x' > </tag:someTag>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<apex:someTag something={!something} > foo </apex:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;public abstract class AbstractVfTest {    protected final VfParsingHelper vf = VfParsingHelper.DEFAULT.withResourceContext(getClass());}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.io.BufferedReader;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Hashtable;import java.util.List;import java.util.Map;import org.apache.commons.lang3.tuple.Pair;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;import net.sourceforge.pmd.lang.apex.ast.ApexNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.vf.VFTestUtils;import apex.jorje.semantic.symbol.type.BasicType;public class ApexClassPropertyTypesVisitorTest {    @Test    public void testApexClassIsProperlyParsed() throws IOException {        LanguageVersion languageVersion = LanguageRegistry.getLanguage(ApexLanguageModule.NAME).getDefaultVersion();        ParserOptions parserOptions = languageVersion.getLanguageVersionHandler().getDefaultParserOptions();        Parser parser = languageVersion.getLanguageVersionHandler().getParser(parserOptions);        Path apexPath = VFTestUtils.getMetadataPath(this, VFTestUtils.MetadataFormat.SFDX, VFTestUtils.MetadataType.Apex)                                   .resolve("ApexController.cls").toAbsolutePath();        ApexClassPropertyTypesVisitor visitor = new ApexClassPropertyTypesVisitor();        try (BufferedReader reader = Files.newBufferedReader(apexPath, StandardCharsets.UTF_8)) {            Node node = parser.parse(apexPath.toString(), reader);            assertNotNull(node);            visitor.visit((ApexNode<?>) node, null);        }        List<Pair<String, BasicType>> variables = visitor.getVariables();        assertEquals(7, variables.size());        Map<String, BasicType> variableNameToVariableType = new Hashtable<>();        for (Pair<String, BasicType> variable : variables) {            // Map the values and ensure there were no duplicates            BasicType previous = variableNameToVariableType.put(variable.getKey(), variable.getValue());            assertNull(variable.getKey(), previous);        }        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.AccountIdProp"));        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.AccountId"));        assertEquals(BasicType.STRING, variableNameToVariableType.get("ApexController.AccountName"));        assertEquals(BasicType.APEX_OBJECT, variableNameToVariableType.get("ApexController.InnerController"));        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.InnerController.InnerAccountIdProp"));        assertEquals(BasicType.ID, variableNameToVariableType.get("ApexController.InnerController.InnerAccountId"));        assertEquals(BasicType.STRING, variableNameToVariableType.get("ApexController.InnerController.InnerAccountName"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @Before    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *     */    @Test    public void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt;     * &lt;/x&gt;     */    @Test    public void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertEquals;import org.junit.Test;public class VfParserOptionsTest {    @Test    public void testDefaultPropertyDescriptors() {        VfParserOptions vfParserOptions = new VfParserOptions();        assertEquals(VfParserOptions.DEFAULT_APEX_DIRECTORIES,                     vfParserOptions.getProperty(VfParserOptions.APEX_DIRECTORIES_DESCRIPTOR));        assertEquals(VfParserOptions.DEFAULT_OBJECT_DIRECTORIES,                     vfParserOptions.getProperty(VfParserOptions.OBJECTS_DIRECTORIES_DESCRIPTOR));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    public RuleSetFactoryTest() {        super(ApexLanguageModule.TERSE_NAME);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.vf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;import apex.jorje.semantic.symbol.type.BasicType;public class DataTypeTest {    @Test    public void testFromString() {        assertEquals(DataType.AutoNumber, DataType.fromString("AutoNumber"));        assertEquals(DataType.AutoNumber, DataType.fromString("autonumber"));        assertEquals(DataType.Unknown, DataType.fromString(""));        assertEquals(DataType.Unknown, DataType.fromString(null));    }    @Test    public void testFromBasicType() {        assertEquals(DataType.Checkbox, DataType.fromBasicType(BasicType.BOOLEAN));        assertEquals(DataType.Number, DataType.fromBasicType(BasicType.DECIMAL));        assertEquals(DataType.Number, DataType.fromBasicType(BasicType.DOUBLE));        assertEquals(DataType.Unknown, DataType.fromBasicType(BasicType.APEX_OBJECT));        assertEquals(DataType.Unknown, DataType.fromBasicType(null));    }    @Test    public void testRequiresEncoding() {        assertFalse(DataType.AutoNumber.requiresEscaping);        assertTrue(DataType.Text.requiresEscaping);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.vf.VfLanguageModule;/** * @author sergey.gorbaty * */public class LanguageVersionDiscovererTest {    /**     * Test on VF file.     */    @Test    public void testVFFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File vfFile = new File("/path/to/MyPage.page");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals("LanguageVersion must be VF!",                LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), languageVersion);    }    @Test    public void testComponentFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File vfFile = new File("/path/to/MyPage.component");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(vfFile);        assertEquals("LanguageVersion must be VF!",                LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.vf.VfLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { VfLanguageModule.NAME, VfLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(VfLanguageModule.NAME).getDefaultVersion(), }, });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class DartTokenizerTest extends CpdTextComparisonTest {    public DartTokenizerTest() {        super(".dart");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new DartTokenizer();    }    @Test    public void testComment() {        doTest("comment");    }    @Test    public void testEscapeSequences() {        doTest("escape_sequences");    }    @Test    public void testEscapedBackslash() {        doTest("escaped_backslash");    }    @Test    public void testEscapedString() {        doTest("escaped_string");    }    @Test    public void testIncrement() {        doTest("increment");    }    @Test    public void testImports() {        doTest("imports");    }    @Test    public void testStringInterpolation() {        doTest("string_interpolation");    }    @Test    public void testEscapedDollar() {        doTest("escaped_dollar");    }    @Test    public void testRegex() {        doTest("regex");    }    @Test    public void testRegex2() {        doTest("regex2");    }    @Test    public void testRegex3() {        doTest("regex3");    }    @Test    public void testStringWithBackslashes() {        doTest("string_with_backslashes");    }    @Test    public void testMultiline() {        doTest("string_multiline");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class PythonTokenizerTest extends CpdTextComparisonTest {    public PythonTokenizerTest() {        super(".py");    }    @Override    protected String getResourcePrefix() {        return "../lang/python/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new PythonTokenizer();    }            @Test    public void sampleTest() {        doTest("sample_python");    }    @Test    public void specialComments() {        doTest("special_comments");    }    @Test    public void testBackticks() {        doTest("backticks");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.xml.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class XmlCPDTokenizerTest extends CpdTextComparisonTest {    public XmlCPDTokenizerTest() {        super(".xml");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new XmlTokenizer();    }    @Test    public void tokenizeTest() {        doTest("simple");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MistypedCDATASectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;import org.w3c.dom.Attr;import org.w3c.dom.CharacterData;import org.w3c.dom.Comment;import org.w3c.dom.Document;import org.w3c.dom.DocumentType;import org.w3c.dom.Element;import org.w3c.dom.Entity;import org.w3c.dom.EntityReference;import org.w3c.dom.Notation;import org.w3c.dom.ProcessingInstruction;import org.w3c.dom.Text;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.xml.XmlParserOptions;import net.sourceforge.pmd.lang.xml.XmlParsingHelper;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractDomXmlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><?mypi?><!DOCTYPE testDoc [<!ENTITY entity \"e\">]><!--Comment--><foo abc=\"abc\"><bar>TEXT</bar><![CDATA[cdata!]]>&gt;&entity;&lt;</foo>";        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setExpandEntityReferences(false);        XmlNode xmlNode = XmlParsingHelper.XML.withParserOptions(parserOptions).parse(source);        MyRule rule = new MyRule();        rule.apply(xmlNode, null);        List<org.w3c.dom.Node> visited = rule.visitedNodes.get("Attr");        assertEquals(1, visited.size());        assertEquals("abc", visited.get(0).getLocalName());        visited = rule.visitedNodes.get("CharacterData");        assertEquals(1, visited.size());        assertEquals("cdata!", ((CharacterData) visited.get(0)).getData());        visited = rule.visitedNodes.get("Comment");        assertEquals("Comment", ((Comment) visited.get(0)).getData());        visited = rule.visitedNodes.get("Document");        assertEquals(1, visited.size());        visited = rule.visitedNodes.get("DocumentType");        assertEquals("testDoc", ((DocumentType) visited.get(0)).getName());        visited = rule.visitedNodes.get("Element");        assertEquals(2, visited.size());        assertEquals("foo", visited.get(0).getLocalName());        assertEquals("bar", visited.get(1).getLocalName());        // TODO Figure out how to trigger this.        // visited = rule.visitedNodes.get("Entity");        // assertEquals(0, visited.size());        visited = rule.visitedNodes.get("EntityReference");        assertEquals(1, visited.size());        assertEquals("entity", ((EntityReference) visited.get(0)).getNodeName());        // TODO Figure out how to trigger this.        // visited = rule.visitedNodes.get("Notation");        // assertEquals(0, visited.size());        visited = rule.visitedNodes.get("ProcessingInstruction");        assertEquals(1, visited.size());        assertEquals("mypi", ((ProcessingInstruction) visited.get(0)).getTarget());        visited = rule.visitedNodes.get("Text");        assertEquals(3, visited.size());        assertEquals("TEXT", ((Text) visited.get(0)).getData());        assertEquals(">", ((Text) visited.get(1)).getData());        String text = ((Text) visited.get(2)).getData();        if ("<".equals(text)) {            // java13 and later don't expand entities if setExpandEntityReferences==false            assertEquals("<", ((Text) visited.get(2)).getData());        } else {            assertEquals("e<", ((Text) visited.get(2)).getData());        }    }    @Test    public void dtdIsNotLookedUp() {        String source = "<!DOCTYPE struts-config PUBLIC "                + " \"-//Apache Software Foundation//DTD Struts Configuration 1.1//EN \" "                + " \"http://jakarta.inexistinghost.org/struts/dtds/struts-config_1_1.dtd\" >" + "<struts-config/>";        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setLookupDescriptorDoc(false);        XmlNode xmlNode = XmlParsingHelper.XML.withParserOptions(parserOptions).parse(source);        // no exception should be thrown        MyRule rule = new MyRule();        rule.apply(xmlNode, null);        // first element is still parsed        assertNotNull(rule.visitedNodes.get("Element"));    }    @Test    public void xsdIsNotLookedUp() {        String source = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> "                + "<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" "                + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "                + "xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.inexisting.com/xml/ns/javaee/web-app_2_5.xsd\" "                + "version=\"2.5\">" + "</web-app>";        XmlNode xmlNode = XmlParsingHelper.XML.parse(source);        // no exception should be thrown        // first element is still parsed        MyRule rule = new MyRule();        rule.apply(xmlNode, null);        assertNotNull(rule.visitedNodes.get("Element"));    }    private static class MyRule extends AbstractDomXmlRule {        final Map<String, List<org.w3c.dom.Node>> visitedNodes = new HashMap<>();        MyRule() {        }        private void visit(String key, org.w3c.dom.Node node) {            List<org.w3c.dom.Node> nodes = visitedNodes.get(key);            if (nodes == null) {                nodes = new ArrayList<>();                visitedNodes.put(key, nodes);            }            nodes.add(node);        }        @Override        protected void visit(XmlNode node, Attr attr, RuleContext ctx) {            visit("Attr", attr);            super.visit(node, attr, ctx);        }        @Override        protected void visit(XmlNode node, CharacterData characterData, RuleContext ctx) {            visit("CharacterData", characterData);            super.visit(node, characterData, ctx);        }        @Override        protected void visit(XmlNode node, Comment comment, RuleContext ctx) {            visit("Comment", comment);            super.visit(node, comment, ctx);        }        @Override        protected void visit(XmlNode node, Document document, RuleContext ctx) {            visit("Document", document);            super.visit(node, document, ctx);        }        @Override        protected void visit(XmlNode node, DocumentType documentType, RuleContext ctx) {            visit("DocumentType", documentType);            super.visit(node, documentType, ctx);        }        @Override        protected void visit(XmlNode node, Element element, RuleContext ctx) {            visit("Element", element);            super.visit(node, element, ctx);        }        @Override        protected void visit(XmlNode node, Entity entity, RuleContext ctx) {            visit("Entity", entity);            super.visit(node, entity, ctx);        }        @Override        protected void visit(XmlNode node, EntityReference entityReference, RuleContext ctx) {            visit("EntityReference", entityReference);            super.visit(node, entityReference, ctx);        }        @Override        protected void visit(XmlNode node, Notation notation, RuleContext ctx) {            visit("Notation", notation);            super.visit(node, notation, ctx);        }        @Override        protected void visit(XmlNode node, ProcessingInstruction processingInstruction, RuleContext ctx) {            visit("ProcessingInstruction", processingInstruction);            super.visit(node, processingInstruction, ctx);        }        @Override        protected void visit(XmlNode node, Text text, RuleContext ctx) {            visit("Text", text);            super.visit(node, text, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml.rule;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.xml.XmlParsingHelper;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractXmlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><foo abc=\"abc\"><bar/></foo>";        XmlNode xmlNode = XmlParsingHelper.XML.parse(source);        MyRule rule = new MyRule();        rule.apply(xmlNode, null);        assertEquals(3, rule.visitedNodes.size());        assertEquals("document", rule.visitedNodes.get(0).toString());        assertEquals("foo", rule.visitedNodes.get(1).toString());        assertEquals("bar", rule.visitedNodes.get(2).toString());    }    private static class MyRule extends AbstractXmlRule {        final List<XmlNode> visitedNodes = new ArrayList<>();        MyRule() {        }        @Override        public void start(RuleContext ctx) {            visitedNodes.clear();        }        @Override        protected void visit(XmlNode node, RuleContext ctx) {            visitedNodes.add(node);            super.visit(node, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static net.sourceforge.pmd.lang.ParserOptionsTestUtils.verifyOptionsEqualsHashcode;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.xml.rule.AbstractXmlRule;import net.sourceforge.pmd.properties.PropertyDescriptor;public class XmlParserOptionsTest {    @Test    public void testDefaults() {        XmlParserOptions options = new XmlParserOptions();        assertFalse(options.isCoalescing());        assertTrue(options.isExpandEntityReferences());        assertFalse(options.isIgnoringComments());        assertFalse(options.isIgnoringElementContentWhitespace());        assertTrue(options.isNamespaceAware());        assertFalse(options.isValidating());        assertFalse(options.isXincludeAware());        MyRule rule = new MyRule();        options = (XmlParserOptions) rule.getParserOptions();        assertFalse(options.isCoalescing());        assertTrue(options.isExpandEntityReferences());        assertFalse(options.isIgnoringComments());        assertFalse(options.isIgnoringElementContentWhitespace());        assertTrue(options.isNamespaceAware());        assertFalse(options.isValidating());        assertFalse(options.isXincludeAware());    }    @Test    public void testConstructor() {        MyRule rule = new MyRule();        rule.setProperty(XmlParserOptions.COALESCING_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isCoalescing());        rule.setProperty(XmlParserOptions.COALESCING_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isCoalescing());        rule.setProperty(XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isExpandEntityReferences());        rule.setProperty(XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isExpandEntityReferences());        rule.setProperty(XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isIgnoringComments());        rule.setProperty(XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isIgnoringComments());        rule.setProperty(XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isIgnoringElementContentWhitespace());        rule.setProperty(XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isIgnoringElementContentWhitespace());        rule.setProperty(XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isNamespaceAware());        rule.setProperty(XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isNamespaceAware());        rule.setProperty(XmlParserOptions.VALIDATING_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isValidating());        rule.setProperty(XmlParserOptions.VALIDATING_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isValidating());        rule.setProperty(XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, true);        assertTrue(((XmlParserOptions) rule.getParserOptions()).isXincludeAware());        rule.setProperty(XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR, false);        assertFalse(((XmlParserOptions) rule.getParserOptions()).isXincludeAware());    }    @Test    public void testSetters() {        XmlParserOptions options = new XmlParserOptions();        options.setSuppressMarker("foo");        assertEquals("foo", options.getSuppressMarker());        options.setCoalescing(true);        assertTrue(options.isCoalescing());        options.setCoalescing(false);        assertFalse(options.isCoalescing());        options.setExpandEntityReferences(true);        assertTrue(options.isExpandEntityReferences());        options.setExpandEntityReferences(false);        assertFalse(options.isExpandEntityReferences());        options.setIgnoringComments(true);        assertTrue(options.isIgnoringComments());        options.setIgnoringComments(false);        assertFalse(options.isIgnoringComments());        options.setIgnoringElementContentWhitespace(true);        assertTrue(options.isIgnoringElementContentWhitespace());        options.setIgnoringElementContentWhitespace(false);        assertFalse(options.isIgnoringElementContentWhitespace());        options.setNamespaceAware(true);        assertTrue(options.isNamespaceAware());        options.setNamespaceAware(false);        assertFalse(options.isNamespaceAware());        options.setValidating(true);        assertTrue(options.isValidating());        options.setValidating(false);        assertFalse(options.isValidating());        options.setXincludeAware(true);        assertTrue(options.isXincludeAware());        options.setXincludeAware(false);        assertFalse(options.isXincludeAware());    }    @Test    public void testEqualsHashcode() throws Exception {        List<PropertyDescriptor<Boolean>> properties = listOf(XmlParserOptions.COALESCING_DESCRIPTOR,                                                              XmlParserOptions.EXPAND_ENTITY_REFERENCES_DESCRIPTOR,                                                              XmlParserOptions.IGNORING_COMMENTS_DESCRIPTOR,                                                              XmlParserOptions.IGNORING_ELEMENT_CONTENT_WHITESPACE_DESCRIPTOR,                                                              XmlParserOptions.NAMESPACE_AWARE_DESCRIPTOR,                                                              XmlParserOptions.VALIDATING_DESCRIPTOR,                                                              XmlParserOptions.XINCLUDE_AWARE_DESCRIPTOR);        for (PropertyDescriptor<Boolean> property : properties) {            MyRule rule = new MyRule();            rule.setProperty(property, true);            ParserOptions options1 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options2 = rule.getParserOptions();            rule.setProperty(property, true);            ParserOptions options3 = rule.getParserOptions();            rule.setProperty(property, false);            ParserOptions options4 = rule.getParserOptions();            verifyOptionsEqualsHashcode(options1, options2, options3, options4);        }        XmlParserOptions options1 = new XmlParserOptions();        options1.setSuppressMarker("foo");        XmlParserOptions options2 = new XmlParserOptions();        options2.setSuppressMarker("bar");        XmlParserOptions options3 = new XmlParserOptions();        options3.setSuppressMarker("foo");        XmlParserOptions options4 = new XmlParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    private static final class MyRule extends AbstractXmlRule {    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(XmlParserOptionsTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xml;import static net.sourceforge.pmd.lang.xml.XmlParsingHelper.XML;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.UnsupportedEncodingException;import java.util.Iterator;import java.util.Locale;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.lang.xml.ast.XmlNode;import net.sourceforge.pmd.lang.xml.ast.internal.XmlParserImpl;import net.sourceforge.pmd.util.StringUtil;/** * Unit test for the {@link XmlParserImpl}. */public class XmlParserTest {    private static final String XML_TEST = "<?xml version=\"1.0\"?>\n" + "<!DOCTYPE rootElement\n" + "[\n"            + "<!ELEMENT rootElement (child1,child2)>\n" + "<!ELEMENT child1 (#PCDATA)>\n"            + "<!ATTLIST child1 test CDATA #REQUIRED>\n" + "<!ELEMENT child2 (#PCDATA)>\n" + "\n"            + "<!ENTITY pmd \"Copyright: PMD\">\n" + "]\n" + ">\n" + "<rootElement>\n"            + "    <!-- that's a comment -->\n" + "    <child1 test=\"1\">entity: &pmd;\n" + "    </child1>\n"            + "    <child2>\n" + "      <![CDATA[ cdata section ]]>\n" + "    </child2>\n" + "</rootElement>";    private static final String XML_NAMESPACE_TEST = "<?xml version=\"1.0\"?>\n"            + "<pmd:rootElement xmlns:pmd=\"http://pmd.sf.net\">\n" + "    <!-- that's a comment -->\n"            + "    <pmd:child1 test=\"1\">entity: &amp;\n" + "    </pmd:child1>\n" + "    <pmd:child2>\n"            + "      <![CDATA[ cdata section ]]>\n" + "    </pmd:child2>\n" + "</pmd:rootElement>";    private static final String XML_INVALID_WITH_DTD = "<?xml version=\"1.0\"?>\n" + "<!DOCTYPE rootElement\n" + "[\n"            + "<!ELEMENT rootElement (child)>\n" + "<!ELEMENT child (#PCDATA)>\n" + "]\n" + ">\n" + "<rootElement>\n"            + "  <invalidChild></invalidChild>\n" + "</rootElement>";    /**     * See bug #1054: XML Rules ever report a line -1 and not the line/column     * where the error occurs     *     */    @Test    public void testLineNumbers() {        Node document = XML.parse(XML_TEST);        assertNode(document, "document", 2);        assertLineNumbers(document, 1, 1, 19, 14);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        assertLineNumbers(dtdElement, 2, 1, 11, 1);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertLineNumbers(rootElement, 12, 1, 19, 14);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertLineNumbers(rootElement.getChild(0), 12, 14, 13, 4);        assertNode(rootElement.getChild(1), "comment", 0);        assertLineNumbers(rootElement.getChild(1), 13, 5, 13, 29);        assertTextNode(rootElement.getChild(2), "\\n    ");        assertLineNumbers(rootElement.getChild(2), 13, 30, 14, 4);        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertLineNumbers(child1, 14, 5, 15, 13);        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertLineNumbers(child1.getChild(0), 14, 22, 15, 4);        assertTextNode(rootElement.getChild(4), "\\n    ");        assertLineNumbers(rootElement.getChild(4), 15, 14, 16, 4);        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 3);        assertLineNumbers(child2, 16, 5, 18, 13);        assertTextNode(child2.getChild(0), "\\n      ");        assertLineNumbers(child2.getChild(0), 16, 13, 17, 6);        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertLineNumbers(child2.getChild(1), 17, 7, 17, 33);        assertTextNode(child2.getChild(2), "\\n    ");        assertLineNumbers(child2.getChild(2), 17, 34, 18, 4);        assertTextNode(rootElement.getChild(6), "\\n");        assertLineNumbers(rootElement.getChild(6), 18, 14, 18, 14);    }    /**     * Verifies the default parsing behavior of the XML parser.     */    @Test    public void testDefaultParsing() {        Node document = XML.parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser with coalescing enabled.     */    @Test    public void testParsingCoalescingEnabled() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setCoalescing(true);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 1);        assertTextNode(child2.getChild(0), "\\n       cdata section \\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if entities are not     * expanded.     */    @Test    public void testParsingDoNotExpandEntities() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setExpandEntityReferences(false);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 7);        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "child1", 3, "test", "1");        assertTextNode(child1.getChild(0), "entity: ");        assertNode(child1.getChild(1), "pmd", 0);        // with java13, expandEntityReferences=false works correctly, and the        // entity &pmd; is not expanded        String text = child1.getChild(2).getImage();        if ("\n    ".equals(text)) {            // java13 and later            assertTextNode(child1.getChild(2), "\\n    ");        } else {            assertTextNode(child1.getChild(2), "Copyright: PMD\\n    ");        }        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if ignoring comments.     */    @Test    public void testParsingIgnoreComments() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setIgnoringComments(true);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 5);        assertTextNode(rootElement.getChild(0), "\\n    \\n    ");        Node child1 = rootElement.getChild(1);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child2 = rootElement.getChild(3);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(4), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser if ignoring whitespaces     * in elements.     */    @Test    public void testParsingIgnoreElementContentWhitespace() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setIgnoringElementContentWhitespace(true);        Node document = XML.withParserOptions(parserOptions).parse(XML_TEST);        assertNode(document, "document", 2);        Node dtdElement = document.getChild(0);        assertNode(dtdElement, "rootElement", 0);        Node rootElement = document.getChild(1);        assertNode(rootElement, "rootElement", 3);        assertNode(rootElement.getChild(0), "comment", 0);        Node child1 = rootElement.getChild(1);        assertNode(child1, "child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: Copyright: PMD\\n    ");        Node child2 = rootElement.getChild(2);        assertNode(child2, "child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");    }    /**     * Verifies the default parsing behavior of the XML parser with namespaces.     */    @Test    public void testDefaultParsingNamespaces() {        Node document = XML.parse(XML_NAMESPACE_TEST);        assertNode(document, "document", 1);        Node rootElement = document.getChild(0);        assertNode(rootElement, "pmd:rootElement", 7, "xmlns:pmd", "http://pmd.sf.net");        Assert.assertEquals("http://pmd.sf.net", ((XmlNode) rootElement).getNode().getNamespaceURI());        Assert.assertEquals("pmd", ((XmlNode) rootElement).getNode().getPrefix());        Assert.assertEquals("rootElement", ((XmlNode) rootElement).getNode().getLocalName());        Assert.assertEquals("pmd:rootElement", ((XmlNode) rootElement).getNode().getNodeName());        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "pmd:child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: &\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "pmd:child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the default parsing behavior of the XML parser with namespaces     * but not namespace aware.     */    @Test    public void testParsingNotNamespaceAware() {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setNamespaceAware(false);        Node document = XML.withParserOptions(parserOptions).parse(XML_NAMESPACE_TEST);        assertNode(document, "document", 1);        Node rootElement = document.getChild(0);        assertNode(rootElement, "pmd:rootElement", 7, "xmlns:pmd", "http://pmd.sf.net");        Assert.assertNull(((XmlNode) rootElement).getNode().getNamespaceURI());        Assert.assertNull(((XmlNode) rootElement).getNode().getPrefix());        Assert.assertNull(((XmlNode) rootElement).getNode().getLocalName());        Assert.assertEquals("pmd:rootElement", ((XmlNode) rootElement).getNode().getNodeName());        assertTextNode(rootElement.getChild(0), "\\n    ");        assertNode(rootElement.getChild(1), "comment", 0);        assertTextNode(rootElement.getChild(2), "\\n    ");        Node child1 = rootElement.getChild(3);        assertNode(child1, "pmd:child1", 1, "test", "1");        assertTextNode(child1.getChild(0), "entity: &\\n    ");        assertTextNode(rootElement.getChild(4), "\\n    ");        Node child2 = rootElement.getChild(5);        assertNode(child2, "pmd:child2", 3);        assertTextNode(child2.getChild(0), "\\n      ");        assertTextNode(child2.getChild(1), " cdata section ", "cdata-section");        assertTextNode(child2.getChild(2), "\\n    ");        assertTextNode(rootElement.getChild(6), "\\n");    }    /**     * Verifies the parsing behavior of the XML parser with validation on.     *     * @throws UnsupportedEncodingException     *             error     */    @Test    public void testParsingWithValidation() throws UnsupportedEncodingException {        XmlParserOptions parserOptions = new XmlParserOptions();        parserOptions.setValidating(true);        PrintStream oldErr = System.err;        Locale oldLocale = Locale.getDefault();        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            System.setErr(new PrintStream(bos));            Locale.setDefault(Locale.ENGLISH);            Node document = XML.withParserOptions(parserOptions).parse(XML_INVALID_WITH_DTD);            Assert.assertNotNull(document);            String output = bos.toString("UTF-8");            Assert.assertTrue(output.contains("Element type \"invalidChild\" must be declared."));            Assert.assertTrue(output.contains("The content of element type \"rootElement\" must match \"(child)\"."));            Assert.assertEquals(2, document.getNumChildren());            Assert.assertEquals("invalidChild", String.valueOf(document.getChild(1).getChild(1)));        } finally {            System.setErr(oldErr);            Locale.setDefault(oldLocale);        }    }    @Test    public void testWithProcessingInstructions() {        String xml = "<?xml version=\"1.0\"?><?mypi?><!DOCTYPE testDoc [<!ENTITY myentity \"e\">]><!--Comment--><foo abc=\"abc\"><bar>TEXT</bar><![CDATA[cdata!]]>&gt;&myentity;&lt;</foo>";        XmlParserOptions options = new XmlParserOptions();        options.setExpandEntityReferences(false);        Node document = XmlParsingHelper.XML.withParserOptions(options).parse(xml);        Assert.assertNotNull(document);        assertNode(document.getChild(0), "mypi", 0);        assertLineNumbers(document.getChild(0), 1, 22, 1, 29);    }    @Test    public void testBug1518() throws Exception {        XML.parseResource("parsertests/bug1518.xml");    }    @Test    public void testAutoclosingElementLength() {        final String xml = "<elementName att1='foo' att2='bar' att3='other' />";        assertLineNumbers(XML.parse(xml), 1, 1, 1, xml.length());    }    /**     * Asserts a single node inclusive attributes.     *     * @param node     *            the node     * @param toString     *            the to String representation to expect     * @param childs     *            number of childs     * @param atts     *            attributes - each object pair forms one attribute: first name,     *            then value.     */    private void assertNode(Node node, String toString, int childs, Object... atts) {        Assert.assertEquals(toString, String.valueOf(node));        Assert.assertEquals(childs, node.getNumChildren());        Iterator<Attribute> attributeIterator = node.getXPathAttributesIterator();        if (atts != null) {            for (int i = 0; i < atts.length; i += 2) {                Assert.assertTrue(attributeIterator.hasNext());                String name = String.valueOf(atts[i]);                Object value = atts[i + 1];                Attribute attribute = attributeIterator.next();                Assert.assertEquals(name, attribute.getName());                Assert.assertEquals(value, attribute.getValue());            }        }        Assert.assertFalse(attributeIterator.hasNext());    }    /**     * Assert a single text node.     *     * @param node     *            the node to check     * @param text     *            the text to expect     */    private void assertTextNode(Node node, String text) {        assertTextNode(node, text, "text");    }    /**     * Assert a single text node.     *     * @param node     *            the node to check     * @param text     *            the text to expect     * @param toString     *            the to string representation     */    private void assertTextNode(Node node, String text, String toString) {        Assert.assertEquals(toString, String.valueOf(node));        Assert.assertEquals(0, node.getNumChildren());        Assert.assertEquals(text, StringUtil.escapeWhitespace(node.getImage()));        Iterator<Attribute> attributeIterator = node.getXPathAttributesIterator();        Assert.assertTrue(attributeIterator.hasNext());        Attribute attribute = attributeIterator.next();        Assert.assertEquals("Image", attribute.getName());        Assert.assertEquals(text, StringUtil.escapeWhitespace(attribute.getValue()));        Assert.assertFalse(attributeIterator.hasNext());    }    /**     * Assert the line numbers of a node.     *     * @param node     *            the node     * @param beginLine     *            the begin line     * @param beginColumn     *            the begin column     * @param endLine     *            the end line     * @param endColumn     *            the end column     */    private void assertLineNumbers(Node node, int beginLine, int beginColumn, int endLine, int endColumn) {        Assert.assertEquals("begin line wrong", beginLine, node.getBeginLine());        Assert.assertEquals("begin column wrong", beginColumn, node.getBeginColumn());        Assert.assertEquals("end line wrong", endLine, node.getEndLine());        Assert.assertEquals("end column wrong", endColumn, node.getEndColumn());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ProjectVersionAsDependencyVersionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.pom.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InvalidDependencyTypesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.wsdl.rule;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.xml.XmlParsingHelper;import net.sourceforge.pmd.lang.xml.ast.XmlNode;public class AbstractWsdlRuleTest {    @Test    public void testVisit() throws Exception {        String source = "<?xml version=\"1.0\"?><foo abc=\"abc\"><bar/></foo>";        XmlNode xmlNode = XmlParsingHelper.WSDL.parse(source);        MyRule rule = new MyRule();        rule.apply(xmlNode, null);        assertEquals(3, rule.visitedNodes.size());        assertEquals("document", rule.visitedNodes.get(0).toString());        assertEquals("foo", rule.visitedNodes.get(1).toString());        assertEquals("bar", rule.visitedNodes.get(2).toString());    }    private static class MyRule extends AbstractWsdlRule {        final List<XmlNode> visitedNodes = new ArrayList<>();        MyRule() {        }        @Override        public void start(RuleContext ctx) {            visitedNodes.clear();        }        @Override        protected void visit(XmlNode node, RuleContext ctx) {            visitedNodes.add(node);            super.visit(node, ctx);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidAxisNavigationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.xsl.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseConcatOnceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import org.junit.Test;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testXML() {        executeTarget("testXML");        assertOutputContaining("Potentially mistyped CDATA section with extra [ at beginning or ] at the end.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.pom.PomLanguageModule;import net.sourceforge.pmd.lang.wsdl.WsdlLanguageModule;import net.sourceforge.pmd.lang.xml.XmlLanguageModule;import net.sourceforge.pmd.lang.xsl.XslLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { XmlLanguageModule.NAME, XmlLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(XmlLanguageModule.NAME).getDefaultVersion(), },            { XslLanguageModule.NAME, XslLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(XslLanguageModule.NAME).getDefaultVersion(), },            { WsdlLanguageModule.NAME, WsdlLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(WsdlLanguageModule.NAME).getDefaultVersion(), },            { PomLanguageModule.NAME, PomLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(PomLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test xml's and xslt's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class GoTokenizerTest extends CpdTextComparisonTest {    public GoTokenizerTest() {        super(".go");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new GoTokenizer();    }    @Override    protected String getResourcePrefix() {        return "../lang/go/cpd/testdata";    }    @Test    public void simpleTest() {        doTest("hello");    }    @Test    public void bigFileTest() {        doTest("btrfs");    }    @Test    public void testIssue1751() {        doTest("issue-1751");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;import net.sourceforge.pmd.lang.ast.TokenMgrError;public class CsTokenizerTest extends CpdTextComparisonTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    public CsTokenizerTest() {        super(".cs");    }    @Override    protected String getResourcePrefix() {        return "../lang/cs/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        CsTokenizer tok = new CsTokenizer();        tok.setProperties(properties);        return tok;    }    @Test    public void testSimpleClass() {        doTest("simpleClass");    }    @Test    public void testSimpleClassMethodMultipleLines() {        doTest("simpleClassMethodMultipleLines");    }    @Test    public void testStrings() {        doTest("strings");    }    @Test    public void testOpenString() {        ex.expect(TokenMgrError.class);        doTest("unlexable_string");    }    @Test    public void testCommentsIgnored1() {        doTest("comments");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testOperators() {        doTest("operatorsAndStuff");    }    @Test    public void testLineNumberAfterMultilineString() {        doTest("strings");    }    @Test    public void testDoNotIgnoreUsingDirectives() {        doTest("usingDirectives");    }    @Test    public void testIgnoreUsingDirectives() {        doTest("usingDirectives", "_ignored", ignoreUsings());    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    @Test    public void testLongListsOfNumbersAreNotIgnored() {        doTest("listOfNumbers");    }    @Test    public void testLongListsOfNumbersAreIgnored() {        doTest("listOfNumbers", "_ignored", skipLiteralSequences());    }    private Properties ignoreUsings() {        return properties(true, false);    }    private Properties skipLiteralSequences() {        return properties(false, true);    }    private Properties properties(boolean ignoreUsings, boolean ignoreLiteralSequences) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.IGNORE_USINGS, Boolean.toString(ignoreUsings));        properties.setProperty(Tokenizer.OPTION_IGNORE_LITERAL_SEQUENCES, Boolean.toString(ignoreLiteralSequences));        return properties;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import java.util.ArrayList;import java.util.List;import java.util.Properties;import org.junit.Ignore;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageVersion;/** * Stores the information required to run a complete test. */@Ignore("this is not a unit test")public class TestDescriptor {    private Rule rule;    private Properties properties;    private String description;    private int numberOfProblemsExpected;    private List<String> expectedMessages = new ArrayList<>();    private List<Integer> expectedLineNumbers = new ArrayList<>();    private String code;    private LanguageVersion languageVersion;    // default, avoids unintentional mixing of state between test cases    private boolean reinitializeRule = true;    private boolean isRegressionTest = true;    private boolean useAuxClasspath = true;    private int numberInDocument = -1;    public TestDescriptor() {        // Empty default descriptor added to please mvn surefire plugin    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule) {        this(code, description, numberOfProblemsExpected, rule, rule.getLanguage().getDefaultVersion());    }    public TestDescriptor(String code, String description, int numberOfProblemsExpected, Rule rule,            LanguageVersion languageVersion) {        this.rule = rule;        this.code = code;        this.description = description;        this.numberOfProblemsExpected = numberOfProblemsExpected;        this.languageVersion = languageVersion;    }    public int getNumberInDocument() {        return numberInDocument;    }    public void setNumberInDocument(int numberInDocument) {        this.numberInDocument = numberInDocument;    }    public void setExpectedMessages(List<String> messages) {        expectedMessages.clear();        expectedMessages.addAll(messages);    }    public List<String> getExpectedMessages() {        return expectedMessages;    }    public void setExpectedLineNumbers(List<Integer> expectedLineNumbers) {        this.expectedLineNumbers.clear();        this.expectedLineNumbers.addAll(expectedLineNumbers);    }    public List<Integer> getExpectedLineNumbers() {        return expectedLineNumbers;    }    public void setProperties(Properties properties) {        this.properties = properties;    }    public Properties getProperties() {        return properties;    }    public String getCode() {        return code;    }    public LanguageVersion getLanguageVersion() {        return languageVersion;    }    public String getDescription() {        return description;    }    public int getNumberOfProblemsExpected() {        return numberOfProblemsExpected;    }    public Rule getRule() {        return rule;    }    public boolean getReinitializeRule() {        return reinitializeRule;    }    public void setReinitializeRule(boolean reinitializeRule) {        this.reinitializeRule = reinitializeRule;    }    /**     * Checks whether we are testing for regression problems only. Return value     * is based on the system property "pmd.regress".     *     * @return <code>false</code> if system property "pmd.regress" is set to     *         <code>false</code>, <code>true</code> otherwise     */    public static boolean inRegressionTestMode() {        boolean inRegressionMode = true; // default        try {            // get the "pmd.regress" System property            String property = System.getProperty("pmd.regress");            if (property != null) {                inRegressionMode = Boolean.parseBoolean(property);            }        } catch (IllegalArgumentException e) {            throw new RuntimeException("Invalid system property 'pmd.regress'", e);        }        return inRegressionMode;    }    public boolean isRegressionTest() {        return isRegressionTest;    }    public void setRegressionTest(boolean isRegressionTest) {        this.isRegressionTest = isRegressionTest;    }    public void setUseAuxClasspath(boolean useAuxClasspath) {        this.useAuxClasspath = useAuxClasspath;    }    public boolean isUseAuxClasspath() {        return useAuxClasspath;    }    @Override    public String toString() {        return description + "\n\n" + code;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.util.List;import net.sourceforge.pmd.cpd.SourceCode;import net.sourceforge.pmd.cpd.TokenEntry;import net.sourceforge.pmd.cpd.Tokenizer;import net.sourceforge.pmd.cpd.Tokens;/** * @author Romain PELISSE, belaran@gmail.com * * @deprecated Use CpdTextComparisonTest in module pmd-lang-test */@Deprecatedpublic abstract class AbstractTokenizerTest {    protected int expectedTokenCount;    protected Tokenizer tokenizer;    protected SourceCode sourceCode;    public abstract void buildTokenizer() throws IOException;    public abstract String getSampleCode() throws IOException;    protected void tokenizeTest() throws IOException {        Tokens tokens = new Tokens();        tokenizer.tokenize(sourceCode, tokens);        List<TokenEntry> entries = tokens.getTokens();        assertEquals(expectedTokenCount, entries.size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;/** * Unit tests for {@link ParserOptions}. * @deprecated for removal in PMD 7.0. Use {@link ParserOptionsTestUtils}. */@Deprecatedpublic class ParserOptionsTest {    /**     * SuppressMarker should be initially null and changeable.     */    @Test    public void testSuppressMarker() {        ParserOptions parserOptions = new ParserOptions();        Assert.assertNull(parserOptions.getSuppressMarker());        parserOptions.setSuppressMarker("foo");        Assert.assertEquals("foo", parserOptions.getSuppressMarker());    }    /**     * Verify that the equals and hashCode methods work as expected.     */    @Test    public void testEqualsHashcode() {        ParserOptions options1 = new ParserOptions();        options1.setSuppressMarker("foo");        ParserOptions options2 = new ParserOptions();        options2.setSuppressMarker("bar");        ParserOptions options3 = new ParserOptions();        options3.setSuppressMarker("foo");        ParserOptions options4 = new ParserOptions();        options4.setSuppressMarker("bar");        verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }    /**     * Verify equals and hashCode for 4 {@link ParserOptions} instances. The     * given options should be as follows: 1 and 3 are equals, as are 2 and 4.     *     * @param options1     *            first option instance - equals third     * @param options2     *            second option instance - equals fourth     * @param options3     *            third option instance - equals first     * @param options4     *            fourth option instance - equals second     */    public static void verifyOptionsEqualsHashcode(ParserOptions options1, ParserOptions options2,                                                   ParserOptions options3, ParserOptions options4) {        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.nio.file.Files;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.BeforeClass;import net.sourceforge.pmd.PMD;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public abstract class BaseCLITest {    protected static final String TEST_OUPUT_DIRECTORY = "target/cli-tests/";    // Points toward a folder with not many source files, to avoid actually PMD    // and slowing down tests    protected static final String SOURCE_FOLDER = "src/test/resources/net/sourceforge/pmd/cli";    protected PrintStream originalOut;    protected PrintStream originalErr;    /**     * @throws java.lang.Exception     */    @BeforeClass    public static void setUp() throws Exception {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        File testOuputDir = new File(TEST_OUPUT_DIRECTORY);        if (!testOuputDir.exists()) {            assertTrue("failed to create output directory for test:" + testOuputDir.getAbsolutePath(),                    testOuputDir.mkdirs());        }    }    @Before    public void setup() {        originalOut = System.out;        originalErr = System.err;    }    @After    public void tearDown() {        IOUtils.closeQuietly(System.out);        System.setOut(originalOut);        System.setErr(originalErr);    }    protected void createTestOutputFile(String filename) {        try {            @SuppressWarnings("PMD.CloseResource")            PrintStream out = new PrintStream(Files.newOutputStream(new File(filename).toPath()));            System.setOut(out);            System.setErr(out);        } catch (IOException e) {            fail("Can't create file " + filename + " for test.");        }    }    protected String runTest(String[] args, String testname) {        return runTest(args, testname, 0);    }    protected String runTest(String[] args, String testname, int expectedExitCode) {        String filename = TEST_OUPUT_DIRECTORY + testname + ".txt";        long start = System.currentTimeMillis();        createTestOutputFile(filename);        System.out.println("Start running test " + testname);        runPMDWith(args);        checkStatusCode(expectedExitCode);        System.out.println("Test finished successfully after " + (System.currentTimeMillis() - start) + "ms.");        return filename;    }    protected void runPMDWith(String[] args) {        PMD.main(args);    }    protected void checkStatusCode(int expectedExitCode) {        int statusCode = getStatusCode();        if (statusCode != expectedExitCode) {            fail("PMD failed with status code:" + statusCode);        }    }    protected int getStatusCode() {        return Integer.parseInt(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.io.UnsupportedEncodingException;import org.junit.After;import org.junit.Before;import net.sourceforge.pmd.cpd.CPD;import net.sourceforge.pmd.cpd.CPDCommandLineInterface;public abstract class BaseCPDCLITest {    private ByteArrayOutputStream bufferStdout;    private PrintStream originalStdout;    private PrintStream originalStderr;    @Before    public void setup() throws UnsupportedEncodingException {        originalStdout = System.out;        originalStderr = System.err;        bufferStdout = new ByteArrayOutputStream();        System.setOut(new PrintStream(bufferStdout, false, "UTF-8"));        System.setErr(System.out);    }    @After    public void teardown() {        System.setOut(originalStdout);        System.setErr(originalStderr);    }    public final String getOutput() {        try {            return bufferStdout.toString("UTF-8");        } catch (UnsupportedEncodingException e) {            throw new RuntimeException(e);        }    }    protected void runCPD(String... args) {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPD.main(args);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Properties;import java.util.Set;import java.util.StringTokenizer;import java.util.regex.Pattern;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import org.apache.commons.io.FilenameUtils;import org.junit.BeforeClass;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;import org.xml.sax.helpers.DefaultHandler;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.properties.PropertyDescriptor;/** * Base test class to verify the language's rulesets. This class should be * subclassed for each language. */public abstract class AbstractRuleSetFactoryTest {    @org.junit.Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    private static ValidateDefaultHandler validateDefaultHandler;    private static SAXParser saxParser;    protected Set<String> validXPathClassNames = new HashSet<>();    private final Set<String> languagesToSkip = new HashSet<>();    public AbstractRuleSetFactoryTest() {        this(new String[0]);    }    /**     * Constructor used when a module that depends on another module wants to filter out the dependee's rulesets.     *     * @param languagesToSkip {@link Language}s terse names that appear in the classpath via a dependency, but should be     * skipped because they aren't the primary language which the concrete instance of this class is testing.     */    public AbstractRuleSetFactoryTest(String... languagesToSkip) {        this.languagesToSkip.addAll(Arrays.asList(languagesToSkip));        validXPathClassNames.add(XPathRule.class.getName());    }    /**     * Setups the XML parser with validation.     *     * @throws Exception     *             any error     */    @BeforeClass    public static void init() throws Exception {        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();        saxParserFactory.setValidating(true);        saxParserFactory.setNamespaceAware(true);        // Hope we're using Xerces, or this may not work!        // Note: Features are listed here        // http://xerces.apache.org/xerces2-j/features.html        saxParserFactory.setFeature("http://xml.org/sax/features/validation", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema", true);        saxParserFactory.setFeature("http://apache.org/xml/features/validation/schema-full-checking", true);        validateDefaultHandler = new ValidateDefaultHandler();        saxParser = saxParserFactory.newSAXParser();    }    /**     * Checks all rulesets of all languages on the classpath and verifies that     * all required attributes for all rules are specified.     *     * @throws Exception     *             any error     */    @Test    public void testAllPMDBuiltInRulesMeetConventions() throws Exception {        int invalidSinceAttributes = 0;        int invalidExternalInfoURL = 0;        int invalidClassName = 0;        int invalidRegexSuppress = 0;        int invalidXPathSuppress = 0;        StringBuilder messages = new StringBuilder();        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            RuleSet ruleSet = loadRuleSetByFileName(fileName);            for (Rule rule : ruleSet.getRules()) {                // Skip references                if (rule instanceof RuleReference) {                    continue;                }                Language language = rule.getLanguage();                String group = fileName.substring(fileName.lastIndexOf('/') + 1);                group = group.substring(0, group.indexOf(".xml"));                if (group.indexOf('-') >= 0) {                    group = group.substring(0, group.indexOf('-'));                }                // Is since missing ?                if (rule.getSince() == null) {                    invalidSinceAttributes++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" is missing 'since' attribute")                            .append(PMD.EOL);                }                // Is URL valid ?                if (rule.getExternalInfoUrl() == null || "".equalsIgnoreCase(rule.getExternalInfoUrl())) {                    invalidExternalInfoURL++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" is missing 'externalInfoURL' attribute")                            .append(PMD.EOL);                } else {                    String expectedExternalInfoURL = "https?://pmd.(sourceforge.net|github.io)/.+/pmd_rules_"                            + language.getTerseName() + "_"                            + FilenameUtils.getBaseName(fileName)                            + ".html#"                            + rule.getName().toLowerCase(Locale.ROOT);                    if (rule.getExternalInfoUrl() == null                            || !rule.getExternalInfoUrl().matches(expectedExternalInfoURL)) {                        invalidExternalInfoURL++;                        messages.append("Rule ")                                .append(fileName)                                .append("/")                                .append(rule.getName())                                .append(" seems to have an invalid 'externalInfoURL' value (")                                .append(rule.getExternalInfoUrl())                                .append("), it should be:")                                .append(expectedExternalInfoURL)                                .append(PMD.EOL);                    }                }                // Proper class name/packaging?                String expectedClassName = "net.sourceforge.pmd.lang." + language.getTerseName() + ".rule." + group                        + "." + rule.getName() + "Rule";                if (!rule.getRuleClass().equals(expectedClassName)                        && !validXPathClassNames.contains(rule.getRuleClass())) {                    invalidClassName++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" seems to have an invalid 'class' value (")                            .append(rule.getRuleClass())                            .append("), it should be:")                            .append(expectedClassName)                            .append(PMD.EOL);                }                // Should not have violation suppress regex property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR) != null) {                    invalidRegexSuppress++;                    messages.append("Rule ")                            .append(fileName)                            .append("/")                            .append(rule.getName())                            .append(" should not have '")                            .append(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name())                            .append("', this is intended for end user customization only.")                            .append(PMD.EOL);                }                // Should not have violation suppress xpath property                if (rule.getProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) != null) {                    invalidXPathSuppress++;                    messages.append("Rule ").append(fileName).append("/").append(rule.getName()).append(" should not have '").append(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name()).append("', this is intended for end user customization only.").append(PMD.EOL);                }            }        }        // We do this at the end to ensure we test ALL the rules before failing        // the test        if (invalidSinceAttributes > 0 || invalidExternalInfoURL > 0 || invalidClassName > 0 || invalidRegexSuppress > 0                || invalidXPathSuppress > 0) {            fail("All built-in PMD rules need 'since' attribute (" + invalidSinceAttributes                    + " are missing), a proper ExternalURLInfo (" + invalidExternalInfoURL                    + " are invalid), a class name meeting conventions (" + invalidClassName + " are invalid), no '"                    + Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR.name() + "' property (" + invalidRegexSuppress                    + " are invalid), and no '" + Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR.name() + "' property ("                    + invalidXPathSuppress + " are invalid)" + PMD.EOL + messages);        }    }    /**     * Verifies that all rulesets are valid XML according to the xsd schema.     *     * @throws Exception     *             any error     */    @Test    public void testXmlSchema() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstSchema(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Verifies that all rulesets are valid XML according to the DTD.     *     * @throws Exception     *             any error     */    @Test    public void testDtd() throws Exception {        boolean allValid = true;        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            boolean valid = validateAgainstDtd(fileName);            allValid = allValid && valid;        }        assertTrue("All XML must parse without producing validation messages.", allValid);    }    /**     * Reads and writes the rulesets to make sure, that no data is lost if the     * rulests are processed.     *     * @throws Exception     *             any error     */    @Test    public void testReadWriteRoundTrip() throws Exception {        List<String> ruleSetFileNames = getRuleSetFileNames();        for (String fileName : ruleSetFileNames) {            testRuleSet(fileName);        }    }    // Gets all test PMD Ruleset XML files    private List<String> getRuleSetFileNames() throws IOException {        List<String> result = new ArrayList<>();        for (Language language : LanguageRegistry.getLanguages()) {            if (this.languagesToSkip.contains(language.getTerseName())) {                continue;            }            result.addAll(getRuleSetFileNames(language.getTerseName()));        }        return result;    }    private List<String> getRuleSetFileNames(String language) throws IOException {        List<String> ruleSetFileNames = new ArrayList<>();        Properties properties = new Properties();        @SuppressWarnings("PMD.CloseResource")        InputStream input = getClass().getResourceAsStream("rulesets/" + language + "/rulesets.properties");        if (input == null) {            // this might happen if a language is only support by CPD, but not            // by PMD            System.err.println("No ruleset found for language " + language);            return Collections.emptyList();        }        try (InputStream is = input) {            properties.load(is);        }        String fileNames = properties.getProperty("rulesets.filenames");        StringTokenizer st = new StringTokenizer(fileNames, ",");        while (st.hasMoreTokens()) {            ruleSetFileNames.add(st.nextToken());        }        return ruleSetFileNames;    }    private RuleSet loadRuleSetByFileName(String ruleSetFileName) {        return new RuleSetLoader().loadFromResource(ruleSetFileName);    }    private boolean validateAgainstSchema(String fileName) throws IOException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstSchema(inputStream);            if (!valid) {                System.err.println("Validation against XML Schema failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstSchema(InputStream inputStream) throws IOException, SAXException {        saxParser.parse(inputStream, validateDefaultHandler.resetValid());        inputStream.close();        return validateDefaultHandler.isValid();    }    private boolean validateAgainstDtd(String fileName) throws IOException, SAXException {        try (InputStream inputStream = loadResourceAsStream(fileName)) {            boolean valid = validateAgainstDtd(inputStream);            if (!valid) {                System.err.println("Validation against DTD failed for: " + fileName);            }            return valid;        }    }    private boolean validateAgainstDtd(InputStream inputStream) throws IOException, SAXException {        // Read file into memory        String file = readFullyToString(inputStream);        inputStream.close();        String rulesetNamespace = RuleSetWriter.RULESET_2_0_0_NS_URI;        // Remove XML Schema stuff, replace with DTD        file = file.replaceAll("<\\?xml [ a-zA-Z0-9=\".-]*\\?>", "");        file = file.replaceAll("xmlns=\"" + rulesetNamespace + "\"", "");        file = file.replaceAll("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "");        file = file.replaceAll("xsi:schemaLocation=\"" + rulesetNamespace                + " https://pmd.sourceforge.io/ruleset_\\d_0_0.xsd\"", "");        if (rulesetNamespace.equals(RuleSetWriter.RULESET_2_0_0_NS_URI)) {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset SYSTEM "                    + "\"https://pmd.sourceforge.io/ruleset_2_0_0.dtd\">" + PMD.EOL + file;        } else {            file = "<?xml version=\"1.0\"?>" + PMD.EOL + "<!DOCTYPE ruleset>" + PMD.EOL + file;        }        try (InputStream modifiedStream = new ByteArrayInputStream(file.getBytes())) {            saxParser.parse(modifiedStream, validateDefaultHandler.resetValid());        }        return validateDefaultHandler.isValid();    }    private String readFullyToString(InputStream inputStream) throws IOException {        StringBuilder buf = new StringBuilder(64 * 1024);        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {            String line;            while ((line = reader.readLine()) != null) {                buf.append(line);                buf.append(PMD.EOL);            }            return buf.toString();        }    }    private InputStream loadResourceAsStream(String resource) {        return getClass().getResourceAsStream(resource);    }    private void testRuleSet(String fileName) throws IOException, SAXException {        // Load original XML        // String xml1 =        // readFullyToString(ResourceLoader.loadResourceAsStream(fileName));        // System.out.println("xml1: " + xml1);        // Load the original RuleSet        RuleSet ruleSet1 = loadRuleSetByFileName(fileName);        // Write to XML, first time        ByteArrayOutputStream outputStream1 = new ByteArrayOutputStream();        RuleSetWriter writer1 = new RuleSetWriter(outputStream1);        writer1.write(ruleSet1);        writer1.close();        String xml2 = new String(outputStream1.toByteArray());        // System.out.println("xml2: " + xml2);        // Read RuleSet from XML, first time        RuleSetLoader loader = new RuleSetLoader();        RuleSet ruleSet2 = loader.loadFromString("", xml2);        // Do write/read a 2nd time, just to be sure        // Write to XML, second time        ByteArrayOutputStream outputStream2 = new ByteArrayOutputStream();        RuleSetWriter writer2 = new RuleSetWriter(outputStream2);        writer2.write(ruleSet2);        writer2.close();        String xml3 = new String(outputStream2.toByteArray());        // System.out.println("xml3: " + xml3);        // Read RuleSet from XML, second time        RuleSet ruleSet3 = loader.loadFromString("", xml3);        // The 2 written XMLs should all be valid w.r.t Schema/DTD        assertTrue("1st roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against Schema (filename: " + fileName + ")",                validateAgainstSchema(new ByteArrayInputStream(xml3.getBytes())));        assertTrue("1st roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml2.getBytes())));        assertTrue("2nd roundtrip RuleSet XML is not valid against DTD (filename: " + fileName + ")",                validateAgainstDtd(new ByteArrayInputStream(xml3.getBytes())));        // All 3 versions of the RuleSet should be the same        assertEqualsRuleSet("Original RuleSet and 1st roundtrip Ruleset not the same (filename: " + fileName + ")",                ruleSet1, ruleSet2);        assertEqualsRuleSet("1st roundtrip Ruleset and 2nd roundtrip RuleSet not the same (filename: " + fileName + ")",                ruleSet2, ruleSet3);        // It's hard to compare the XML DOMs. At least the roundtrip ones should        // textually be the same.        assertEquals("1st roundtrip RuleSet XML and 2nd roundtrip RuleSet XML (filename: " + fileName + ")", xml2,                xml3);    }    private void assertEqualsRuleSet(String message, RuleSet ruleSet1, RuleSet ruleSet2) {        assertEquals(message + ", RuleSet name", ruleSet1.getName(), ruleSet2.getName());        assertEquals(message + ", RuleSet description", ruleSet1.getDescription(), ruleSet2.getDescription());        assertEquals(message + ", RuleSet exclude patterns", ruleSet1.getFileExclusions(),                ruleSet2.getFileExclusions());        assertEquals(message + ", RuleSet include patterns", ruleSet1.getFileInclusions(),                ruleSet2.getFileInclusions());        assertEquals(message + ", RuleSet rule count", ruleSet1.getRules().size(), ruleSet2.getRules().size());        for (int i = 0; i < ruleSet1.getRules().size(); i++) {            Rule rule1 = ((List<Rule>) ruleSet1.getRules()).get(i);            Rule rule2 = ((List<Rule>) ruleSet2.getRules()).get(i);            assertFalse(message + ", Different RuleReference",                        rule1 instanceof RuleReference != rule2 instanceof RuleReference);            if (rule1 instanceof RuleReference) {                RuleReference ruleReference1 = (RuleReference) rule1;                RuleReference ruleReference2 = (RuleReference) rule2;                assertEquals(message + ", RuleReference overridden minimum language version",                        ruleReference1.getOverriddenMinimumLanguageVersion(),                        ruleReference2.getOverriddenMinimumLanguageVersion());                assertEquals(message + ", RuleReference overridden maximum language version",                        ruleReference1.getOverriddenMaximumLanguageVersion(),                        ruleReference2.getOverriddenMaximumLanguageVersion());                assertEquals(message + ", RuleReference overridden deprecated", ruleReference1.isOverriddenDeprecated(),                        ruleReference2.isOverriddenDeprecated());                assertEquals(message + ", RuleReference overridden name", ruleReference1.getOverriddenName(),                        ruleReference2.getOverriddenName());                assertEquals(message + ", RuleReference overridden description",                        ruleReference1.getOverriddenDescription(), ruleReference2.getOverriddenDescription());                assertEquals(message + ", RuleReference overridden message", ruleReference1.getOverriddenMessage(),                        ruleReference2.getOverriddenMessage());                assertEquals(message + ", RuleReference overridden external info url",                        ruleReference1.getOverriddenExternalInfoUrl(), ruleReference2.getOverriddenExternalInfoUrl());                assertEquals(message + ", RuleReference overridden priority", ruleReference1.getOverriddenPriority(),                        ruleReference2.getOverriddenPriority());                assertEquals(message + ", RuleReference overridden examples", ruleReference1.getOverriddenExamples(),                        ruleReference2.getOverriddenExamples());            }            assertEquals(message + ", Rule name", rule1.getName(), rule2.getName());            assertEquals(message + ", Rule class", rule1.getRuleClass(), rule2.getRuleClass());            assertEquals(message + ", Rule description " + rule1.getName(), rule1.getDescription(),                    rule2.getDescription());            assertEquals(message + ", Rule message", rule1.getMessage(), rule2.getMessage());            assertEquals(message + ", Rule external info url", rule1.getExternalInfoUrl(), rule2.getExternalInfoUrl());            assertEquals(message + ", Rule priority", rule1.getPriority(), rule2.getPriority());            assertEquals(message + ", Rule examples", rule1.getExamples(), rule2.getExamples());            List<PropertyDescriptor<?>> propertyDescriptors1 = rule1.getPropertyDescriptors();            List<PropertyDescriptor<?>> propertyDescriptors2 = rule2.getPropertyDescriptors();            assertEquals(message + ", Rule property descriptor ", propertyDescriptors1, propertyDescriptors2);            for (int j = 0; j < propertyDescriptors1.size(); j++) {                Object value1 = rule1.getProperty(propertyDescriptors1.get(j));                Object value2 = rule2.getProperty(propertyDescriptors2.get(j));                // special case for Pattern, there is no equals method                if (propertyDescriptors1.get(j).type() == Pattern.class) {                    value1 = ((Pattern) value1).pattern();                    value2 = ((Pattern) value2).pattern();                }                assertEquals(message + ", Rule property value " + j, value1, value2);            }            assertEquals(message + ", Rule property descriptor count", propertyDescriptors1.size(),                    propertyDescriptors2.size());        }    }    /**     * Validator for the SAX parser     */    private static class ValidateDefaultHandler extends DefaultHandler {        private boolean valid = true;        private final Map<String, String> schemaMapping;        ValidateDefaultHandler() {            schemaMapping = new HashMap<>();            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.xsd", "ruleset_2_0_0.xsd");            schemaMapping.put("https://pmd.sourceforge.io/ruleset_2_0_0.dtd", "ruleset_2_0_0.dtd");        }        public ValidateDefaultHandler resetValid() {            valid = true;            return this;        }        public boolean isValid() {            return valid;        }        @Override        public void error(SAXParseException e) {            log("Error", e);        }        @Override        public void fatalError(SAXParseException e) {            log("FatalError", e);        }        @Override        public void warning(SAXParseException e) {            log("Warning", e);        }        private void log(String prefix, SAXParseException e) {            String message = prefix + " at (" + e.getLineNumber() + ", " + e.getColumnNumber() + "): " + e.getMessage();            System.err.println(message);            valid = false;        }        @Override        public InputSource resolveEntity(String publicId, String systemId) throws IOException {            String resource = schemaMapping.get(systemId);            if (resource != null) {                InputStream inputStream = getClass().getResourceAsStream(resource);                if (inputStream == null) {                    throw new FileNotFoundException(resource);                }                return new InputSource(inputStream);            }            throw new IllegalArgumentException(                    "No clue how to handle: publicId=" + publicId + ", systemId=" + systemId);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.ant.SourceLanguage;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;/** * Base test class for {@link LanguageVersion} implementations. <br> * Each language implementation should subclass this and provide a data method. * * <pre> * &#64;Parameters *     public static Collection&lt;Object[]&gt; data() { *       return Arrays.asList(new Object[][] { *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.1", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.1") }, *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.2", *              LanguageRegistry.getLanguage(MyLanguageModule.NAME).getVersion("1.2") }, * *            // doesn't exist *            { MyLanguageModule.NAME, MyLanguageModule.TERSE_NAME, "1.3", *              null } *       }); * </pre> * * <p>For the parameters, see the constructor * {@link #AbstractLanguageVersionTest(String, String, String, LanguageVersion)}.</p> */@RunWith(Parameterized.class)public class AbstractLanguageVersionTest {    private String name;    private String version;    private String simpleTerseName;    private LanguageVersion expected;    /**     * Creates a new {@link AbstractLanguageVersionTest}     *     * @param name     *            the name under which the language module is registered     * @param terseName     *            the terse name under which the language module is registered     * @param version     *            the specific version of the language version     * @param expected     *            the expected {@link LanguageVersion} instance     */    public AbstractLanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        this.name = name;        this.version = version;        this.simpleTerseName = terseName;        this.expected = expected;    }    /**     * Checks that the expected {@link LanguageVersion} can be found via     * {@link #name} and {@link #version}.     */    @Test    public void testFindVersionsForLanguageNameAndVersion() {        SourceLanguage sourceLanguage = new SourceLanguage();        sourceLanguage.setName(name);        sourceLanguage.setVersion(version);        Language language = LanguageRegistry.getLanguage(sourceLanguage.getName());        LanguageVersion languageVersion = null;        if (language != null) {            languageVersion = language.getVersion(sourceLanguage.getVersion());        }        assertEquals(expected, languageVersion);    }    /**     * Makes sure, that for each language a "categories.properties" file exists.     *     * @throws Exception     *             any error     */    @Test    public void testRegisteredRulesets() throws Exception {        if (expected == null) {            return;        }        Properties props = new Properties();        String rulesetsProperties = "/category/" + simpleTerseName + "/categories.properties";        try (InputStream inputStream = getClass().getResourceAsStream(rulesetsProperties)) {            if (inputStream == null) {                throw new IOException();            }            props.load(inputStream);        }        assertRulesetsAndCategoriesProperties(props);    }    /**     * If a rulesets.properties file still exists, test it as well.     *     * @throws Exception     *             any error     */    @Test    public void testOldRegisteredRulesets() throws Exception {        // only check for languages, that support rules        if (expected == null) {            return;        }        Properties props = new Properties();        String rulesetsProperties = "/rulesets/" + simpleTerseName + "/rulesets.properties";        InputStream inputStream = getClass().getResourceAsStream(rulesetsProperties);        if (inputStream != null) {            // rulesets.properties file exists            try (InputStream in = inputStream) {                props.load(in);            }            assertRulesetsAndCategoriesProperties(props);        }    }    @Test    public void testVersionsAreDistinct() {        if (expected == null) {            return;        }        Language lang = expected.getLanguage();        int count = 0;        for (LanguageVersion lv : lang.getVersions()) {            if (lv.equals(expected)) {                count++;            }        }        assertEquals("Expected exactly one occurrence of " + expected                         + " in the language versions of its language", 1, count);    }    private void assertRulesetsAndCategoriesProperties(Properties props) throws IOException {        String rulesetFilenames = props.getProperty("rulesets.filenames");        assertNotNull(rulesetFilenames);        RuleSetLoader factory = new RuleSetLoader();        if (rulesetFilenames.trim().isEmpty()) {            return;        }        String[] rulesets = rulesetFilenames.split(",");        for (String r : rulesets) {            RuleSet ruleset = factory.loadFromResource(r);            assertNotNull(ruleset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.testframework;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;import static org.mockito.Mockito.when;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import org.mockito.Mockito;import org.mockito.invocation.InvocationOnMock;import org.mockito.stubbing.Answer;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.RuleTargetSelector;import net.sourceforge.pmd.test.lang.ast.DummyNode;public class RuleTstTest {    private LanguageVersion dummyLanguage = LanguageRegistry.findLanguageByTerseName("dummy").getDefaultVersion();    private Rule rule = mock(Rule.class);    private RuleTst ruleTester = new RuleTst() {    };    @Test    public void shouldCallStartAndEnd() {        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        when(rule.getTargetSelector()).thenReturn(RuleTargetSelector.forRootOnly());        when(rule.deepCopy()).thenReturn(rule);        ruleTester.runTestFromString("the code", rule, dummyLanguage, false);        verify(rule).start(any(RuleContext.class));        verify(rule).end(any(RuleContext.class));        verify(rule).getLanguage();        verify(rule, times(2)).getTargetSelector();        verify(rule).getMinimumLanguageVersion();        verify(rule).getMaximumLanguageVersion();        verify(rule).apply(any(Node.class), any(RuleContext.class));        verify(rule, times(4)).getName();        verify(rule).getPropertiesByPropertyDescriptor();    }    @Test    public void shouldAssertLinenumbersSorted() {        when(rule.getLanguage()).thenReturn(dummyLanguage.getLanguage());        when(rule.getName()).thenReturn("test rule");        when(rule.getTargetSelector()).thenReturn(RuleTargetSelector.forRootOnly());        when(rule.deepCopy()).thenReturn(rule);        Mockito.doAnswer(new Answer<Void>() {            private RuleViolation createViolation(int beginLine, String message) {                DummyNode node = new DummyNode();                node.setCoords(beginLine, 1, beginLine + 1, 2);                return new ParametricRuleViolation<Node>(rule, "someFile", node, message);            }            @Override            public Void answer(InvocationOnMock invocation) throws Throwable {                RuleContext context = invocation.getArgument(1, RuleContext.class);                // the violations are reported out of order                context.getReport().addRuleViolation(createViolation(15, "first reported violation"));                context.getReport().addRuleViolation(createViolation(5, "second reported violation"));                return null;            }        }).when(rule).apply(any(Node.class), Mockito.any(RuleContext.class));        TestDescriptor testDescriptor = new TestDescriptor("the code", "sample test", 2, rule, dummyLanguage);        testDescriptor.setReinitializeRule(false);        testDescriptor.setExpectedLineNumbers(Arrays.asList(5, 15));        try {            ruleTester.runTest(testDescriptor);            // there should be no assertion failures            // expected line numbers and actual line numbers match        } catch (AssertionError assertionError) {            Assert.fail(assertionError.toString());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.Arrays;import java.util.Collections;import java.util.List;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sourceforge.pmd.test.lang.DummyLanguageModule;/** * Unit tests for {@link ParserOptions}. * This class is located in the pmd-test project instead of pmd-core so that it can invoke * {@link ParserOptionsTestUtils#verifyOptionsEqualsHashcode} * * TODO: 7.0.0: Rename to ParserOptionsTest when {@link ParserOptionsTest} is removed. */public class ParserOptionsUnitTest {    private static final List<String> DEFAULT_LIST = Arrays.asList("value1", "value2");    private static final String DEFAULT_STRING = "value3";    private static final List<String> OVERRIDDEN_LIST = Arrays.asList("override1", "override2");    private static final String OVERRIDDEN_STRING = "override3";    private static class TestParserOptions extends ParserOptions {        private static final PropertyDescriptor<List<String>> LIST_DESCRIPTOR =                PropertyFactory.stringListProperty("listOfStringValues")                        .desc("A list of values for testing.")                        .defaultValue(DEFAULT_LIST)                        .delim(',')                        .build();        private static final PropertyDescriptor<String> STRING_DESCRIPTOR =                PropertyFactory.stringProperty("stringValue")                        .desc("A single value for testing.")                        .defaultValue(DEFAULT_STRING)                        .build();        private TestParserOptions() {            super(DummyLanguageModule.TERSE_NAME);            defineProperty(LIST_DESCRIPTOR);            defineProperty(STRING_DESCRIPTOR);            overridePropertiesFromEnv();        }    }    /**     * SuppressMarker should be initially null and changeable.     */    @Test    public void testSuppressMarker() {        ParserOptions parserOptions = new ParserOptions();        Assert.assertEquals(PMD.SUPPRESS_MARKER, parserOptions.getSuppressMarker());        parserOptions.setSuppressMarker("foo");        Assert.assertEquals("foo", parserOptions.getSuppressMarker());    }    @Test    public void testDefaultPropertyDescriptors() {        TestParserOptions parserOptions = new TestParserOptions();        assertEquals(DEFAULT_LIST, parserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals(DEFAULT_STRING, parserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    @Test    public void testOverriddenPropertyDescriptors() {        TestParserOptions parserOptions = new TestParserOptions();        parserOptions.setProperty(TestParserOptions.LIST_DESCRIPTOR, OVERRIDDEN_LIST);        parserOptions.setProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        assertEquals(OVERRIDDEN_LIST, parserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals(OVERRIDDEN_STRING, parserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    @Test    public void testEnvOverriddenPropertyDescriptors() {        TestParserOptions parserOptions = new TestParserOptions() {            @Override            protected String getEnvValue(PropertyDescriptor<?> propertyDescriptor) {                if (propertyDescriptor.equals(TestParserOptions.LIST_DESCRIPTOR)) {                    return StringUtils.join(OVERRIDDEN_LIST, ",");                } else if (propertyDescriptor.equals(TestParserOptions.STRING_DESCRIPTOR)) {                    return OVERRIDDEN_STRING;                } else {                    throw new RuntimeException("Should not happen");                }            }        };        assertEquals(OVERRIDDEN_LIST, parserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals(OVERRIDDEN_STRING, parserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    @Test    public void testEmptyPropertyDescriptors() {        TestParserOptions vfParserOptions = new TestParserOptions() {            @Override            protected String getEnvValue(PropertyDescriptor<?> propertyDescriptor) {                if (propertyDescriptor.equals(TestParserOptions.LIST_DESCRIPTOR)                        || propertyDescriptor.equals(TestParserOptions.STRING_DESCRIPTOR)) {                    return "";                } else {                    throw new RuntimeException("Should not happen");                }            }        };        assertEquals(Collections.emptyList(), vfParserOptions.getProperty(TestParserOptions.LIST_DESCRIPTOR));        assertEquals("", vfParserOptions.getProperty(TestParserOptions.STRING_DESCRIPTOR));    }    /**     * Verify that the equals and hashCode methods work as expected.     * TODO: Consider using Guava's EqualsTester     */    @Test    public void testSuppressMarkerEqualsHashCode() {        ParserOptions options1;        ParserOptions options2;        ParserOptions options3;        ParserOptions options4;        // SuppressMarker        options1 = new ParserOptions();        options2 = new ParserOptions();        options3 = new ParserOptions();        options4 = new ParserOptions();        options1.setSuppressMarker("foo");        options2.setSuppressMarker("bar");        options3.setSuppressMarker("foo");        options4.setSuppressMarker("bar");        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // PropertyDescriptor        options1 = new ParserOptions();        options2 = new ParserOptions();        options3 = new ParserOptions();        options4 = new ParserOptions();        options1.defineProperty(TestParserOptions.LIST_DESCRIPTOR);        options2.defineProperty(TestParserOptions.STRING_DESCRIPTOR);        options3.defineProperty(TestParserOptions.LIST_DESCRIPTOR);        options4.defineProperty(TestParserOptions.STRING_DESCRIPTOR);        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // PropertyValue        options1 = new ParserOptions();        options2 = new ParserOptions();        options3 = new ParserOptions();        options4 = new ParserOptions();        options1.defineProperty(TestParserOptions.STRING_DESCRIPTOR, DEFAULT_STRING);        options2.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        options3.defineProperty(TestParserOptions.STRING_DESCRIPTOR, DEFAULT_STRING);        options4.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // Language        options1 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options2 = new ParserOptions();        options3 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options4 = new ParserOptions();        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        // SuppressMarker, PropertyDescriptor, PropertyValue, Language        options1 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options2 = new ParserOptions();        options3 = new ParserOptions(DummyLanguageModule.TERSE_NAME);        options4 = new ParserOptions();        options1.setSuppressMarker("foo");        options2.setSuppressMarker("bar");        options3.setSuppressMarker("foo");        options4.setSuppressMarker("bar");        options1.defineProperty(TestParserOptions.LIST_DESCRIPTOR, DEFAULT_LIST);        options2.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        options3.defineProperty(TestParserOptions.LIST_DESCRIPTOR, DEFAULT_LIST);        options4.defineProperty(TestParserOptions.STRING_DESCRIPTOR, OVERRIDDEN_STRING);        ParserOptionsTestUtils.verifyOptionsEqualsHashcode(options1, options2, options3, options4);        assertFalse(options1.equals(null));    }    @Test    public void testGetEnvironmentVariableName() {        ParserOptions parserOptions = new TestParserOptions();        assertEquals("PMD_DUMMY_LISTOFSTRINGVALUES",                parserOptions.getEnvironmentVariableName(TestParserOptions.LIST_DESCRIPTOR));        assertEquals("PMD_DUMMY_STRINGVALUE",                parserOptions.getEnvironmentVariableName(TestParserOptions.STRING_DESCRIPTOR));    }    @Test(expected = IllegalStateException.class)    public void testGetEnvironmentVariableNameThrowsExceptionIfLanguageIsNull() {        ParserOptions parserOptions = new ParserOptions();        parserOptions.getEnvironmentVariableName(TestParserOptions.LIST_DESCRIPTOR);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class KotlinTokenizerTest extends CpdTextComparisonTest {    public KotlinTokenizerTest() {        super(".kt");    }    @Override    protected String getResourcePrefix() {        return "../lang/kotlin/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new KotlinTokenizer();    }    @Test    public void testComments() {        doTest("comment");    }    @Test    public void testIncrement() {        doTest("increment");    }    @Test    public void testImportsIgnored() {        doTest("imports");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.internal;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import java.util.Set;import net.sourceforge.pmd.lang.java.ast.ASTAnnotation;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;import net.sourceforge.pmd.lang.java.types.JTypeMirror;import net.sourceforge.pmd.lang.java.types.TypeTestUtil;/** * Utilities for rules related to test frameworks (Junit, TestNG, etc). */public final class TestFrameworksUtil {    private static final String JUNIT3_CLASS_NAME = "junit.framework.TestCase";    private static final String JUNIT4_TEST_ANNOT = "org.junit.Test";    private static final String TESTNG_TEST_ANNOT = "org.testng.annotations.Test";    private static final Set<String> JUNIT5_ALL_TEST_ANNOTS =        setOf("org.junit.jupiter.api.Test",              "org.junit.jupiter.api.RepeatedTest",              "org.junit.jupiter.api.TestFactory",              "org.junit.jupiter.api.TestTemplate",              "org.junit.jupiter.params.ParameterizedTest"        );    private static final Set<String> ASSERT_CONTAINERS = setOf("org.junit.Assert",                                                               "org.junit.jupiter.api.Assertions",                                                               "org.hamcrest.MatcherAssert",                                                               "org.testng.Assert",                                                               "junit.framework.TestCase");    private TestFrameworksUtil() {        // utility class    }    /**     * True if this is a junit @Test method (or a junit 3 method).     */    public static boolean isJUnitMethod(ASTMethodDeclaration method) {        if (method.isStatic() || method.getBody() == null) {            return false; // skip various inapplicable method variations        }        boolean result = false;        result = result || isJUnit5Method(method);        result = result || isJUnit4Method(method);        result = result || isJUnit3Method(method);        return result;    }    /**     * Returns true if this is either a JUnit test or a TestNG test.     */    public static boolean isTestMethod(ASTMethodDeclaration method) {        return isJUnitMethod(method) || isTestNgMethod(method);    }    private static boolean isTestNgMethod(ASTMethodDeclaration method) {        return method.isAnnotationPresent(TESTNG_TEST_ANNOT);    }    public static boolean isJUnit4Method(ASTMethodDeclaration method) {        return method.isAnnotationPresent(JUNIT4_TEST_ANNOT) && method.isPublic();    }    public static boolean isJUnit5Method(ASTMethodDeclaration method) {        return method.getDeclaredAnnotations().any(            it -> {                String canonicalName = it.getTypeMirror().getSymbol().getCanonicalName();                return JUNIT5_ALL_TEST_ANNOTS.contains(canonicalName);            }        );    }    public static boolean isJUnit3Method(ASTMethodDeclaration method) {        return TypeTestUtil.isA("junit.framework.TestCase", method.getEnclosingType())            && isJunit3MethodSignature(method);    }    public static boolean isJunit4TestAnnotation(ASTAnnotation annot) {        return TypeTestUtil.isA(JUNIT4_TEST_ANNOT, annot);    }    /**     * Does not check the class (use {@link #isJUnit3Class(ASTAnyTypeDeclaration)}).     */    public static boolean isJunit3MethodSignature(ASTMethodDeclaration method) {        return method.isVoid()            && method.isPublic()            && method.getName().startsWith("test");    }    /**     * True if this is a {@code TestCase} class for Junit 3.     */    public static boolean isJUnit3Class(ASTAnyTypeDeclaration node) {        return node.isRegularClass()            && !node.isNested()            && !node.isAbstract()            && TypeTestUtil.isA(JUNIT3_CLASS_NAME, node);    }    public static boolean isExpectExceptionCall(ASTMethodCall call) {        return "expect".equals(call.getMethodName()) && TypeTestUtil.isA("org.junit.rules.ExpectedException", call.getQualifier());    }    public static boolean isCallOnAssertionContainer(ASTMethodCall call) {        return isCallOnType(call, ASSERT_CONTAINERS);    }    private static boolean isCallOnType(ASTMethodCall call, Set<String> qualifierTypes) {        JTypeMirror declaring = call.getMethodType().getDeclaringType();        JTypeDeclSymbol sym = declaring.getSymbol();        String binaryName = !(sym instanceof JClassSymbol) ? null : ((JClassSymbol) sym).getBinaryName();        return qualifierTypes.contains(binaryName);    }    public static boolean isProbableAssertCall(ASTMethodCall call) {        String name = call.getMethodName();        return name.startsWith("assert") && !isSoftAssert(call)            || name.startsWith("check")            || name.startsWith("verify")            || "fail".equals(name)            || "failWith".equals(name)            || isExpectExceptionCall(call);    }    private static boolean isSoftAssert(ASTMethodCall call) {        return TypeTestUtil.isA("org.assertj.core.api.AbstractSoftAssertions", call.getMethodType().getDeclaringType())            && !"assertAll".equals(call.getMethodName());    }    /**     * Tells if the node contains a @Test annotation with an expected exception.     */    public static boolean isExpectAnnotated(ASTMethodDeclaration method) {        return method.getDeclaredAnnotations()                     .filter(TestFrameworksUtil::isJunit4TestAnnotation)                     .flatMap(ASTAnnotation::getMembers)                     .any(it -> "expected".equals(it.getName()));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import static net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil.isJUnit3Class;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;import net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil;public class TestClassWithoutTestCasesRule extends AbstractJavaRulechainRule {    public TestClassWithoutTestCasesRule() {        super(ASTClassOrInterfaceDeclaration.class);    }    @Override    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {        if (isJUnit3Class(node)) {            boolean hasTests =                node.getDeclarations(ASTMethodDeclaration.class)                    .any(TestFrameworksUtil::isJunit3MethodSignature);            if (!hasTests) {                addViolation(data, node);            }        }        return null;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package javasymbols.testdata;public class TestCase1 {    String foo;    SomeClassA a;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.coverage;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.fail;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import org.apache.commons.io.FileUtils;import org.apache.commons.lang3.StringUtils;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardErrorStreamLog;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.PMD;public class PMDCoverageTest {    @Rule    public StandardOutputStreamLog output = new StandardOutputStreamLog();    @Rule    public StandardErrorStreamLog errorStream = new StandardErrorStreamLog();    @Rule    public TemporaryFolder folder = new TemporaryFolder();    /**     * Test some of the PMD command line options     */    @Test    public void testPmdOptions() {        runPmd("-d src/main/java/net/sourceforge/pmd/lang/java/rule/design -f text -R rulesets/internal/all-java.xml -language java -stress -benchmark");    }    /**     * Run the PMD command line tool, i.e. call PMD.main().     *     * @param commandLine     */    private void runPmd(String commandLine) {        String[] args;        args = commandLine.split("\\s");        try {            File f = folder.newFile();            int n = args.length;            String[] a = new String[n + 2 + 2];            System.arraycopy(args, 0, a, 0, n);            a[n] = "-reportfile";            a[n + 1] = f.getAbsolutePath();            a[n + 2] = "-threads";            a[n + 3] = String.valueOf(Runtime.getRuntime().availableProcessors());            args = a;            PMD.run(args);            assertEquals("Nothing should be output to stdout", 0, output.getLog().length());            assertEquals("No exceptions expected", 0, StringUtils.countMatches(errorStream.getLog(), "Exception applying rule"));            assertFalse("Wrong configuration? Ruleset not found", errorStream.getLog().contains("Ruleset not found"));            assertEquals("No usage of deprecated XPath attributes expected", 0, StringUtils.countMatches(errorStream.getLog(), "Use of deprecated attribute"));            String report = FileUtils.readFileToString(f, StandardCharsets.UTF_8);            assertEquals("No processing errors expected", 0, StringUtils.countMatches(report, "Error while processing"));            // we might have explicit examples of parsing errors, so these are maybe false positives            assertEquals("No parsing error expected", 0, StringUtils.countMatches(report, "Error while parsing"));        } catch (IOException ioe) {            fail("Problem creating temporary file: " + ioe.getLocalizedMessage());        }    }    @Test    public void runAllJavaPmdOnSourceTree() {        runPmd("-d src/main/java -f text -R rulesets/internal/all-java.xml -language java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics.impl;import org.junit.Ignore;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clment Fournier */@Ignore("Metrics tests are ignored until we stabilise the AST, like rules")public class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/java/metrics_test.xml";    @Override    public void setUp() {        addRule(RULESET, "CycloTest");        addRule(RULESET, "NcssTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "LocTest");        addRule(RULESET, "NPathTest");        addRule(RULESET, "NopaTest");        addRule(RULESET, "NoamTest");        addRule(RULESET, "WocTest");        addRule(RULESET, "TccTest");        addRule(RULESET, "AtfdTest");        addRule(RULESET, "CfoTest");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import java.util.ArrayList;import java.util.List;import java.util.Random;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;import net.sourceforge.pmd.lang.java.ast.MethodLikeNode;import net.sourceforge.pmd.lang.java.metrics.testdata.MetricsVisitorTestData;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.metrics.MetricKey;import net.sourceforge.pmd.lang.metrics.MetricOptions;import net.sourceforge.pmd.lang.metrics.MetricsUtil;/** * @author Clment Fournier */public class ProjectMemoizerTest extends BaseNonParserTest {    private MetricKey<ASTAnyTypeDeclaration> classMetricKey = MetricKey.of("null", new RandomClassMetric());    private MetricKey<MethodLikeNode> opMetricKey = MetricKey.of("null", new RandomOperationMetric());    @Test    public void memoizationTest() {        ASTCompilationUnit acu = java.parseClass(MetricsVisitorTestData.class);        List<Integer> expected = visitWith(acu, true);        List<Integer> real = visitWith(acu, false);        assertEquals(expected, real);    }    @Test    public void forceMemoizationTest() {        ASTCompilationUnit acu = java.parseClass(MetricsVisitorTestData.class);        List<Integer> reference = visitWith(acu, true);        List<Integer> real = visitWith(acu, true);        assertEquals(reference.size(), real.size());        // we force recomputation so each result should be different        for (int i = 0; i < reference.size(); i++) {            assertNotEquals(reference.get(i), real.get(i));        }    }    private List<Integer> visitWith(ASTCompilationUnit acu, final boolean force) {        final List<Integer> result = new ArrayList<>();        acu.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visitMethodOrCtor(ASTMethodOrConstructorDeclaration node, Object data) {                if (opMetricKey.supports(node)) {                    result.add((int) MetricsUtil.computeMetric(opMetricKey, node, MetricOptions.emptyOptions(), force));                }                return super.visitMethodOrCtor(node, data);            }            @Override            public Object visitTypeDecl(ASTAnyTypeDeclaration node, Object data) {                if (classMetricKey.supports(node)) {                    result.add((int) MetricsUtil.computeMetric(classMetricKey, node, MetricOptions.emptyOptions(), force));                }                return super.visitTypeDecl(node, data);            }        }, null);        return result;    }    private class RandomOperationMetric extends AbstractJavaOperationMetric {        private Random random = new Random();        @Override        public double computeFor(MethodLikeNode node, MetricOptions options) {            return random.nextInt();        }    }    private class RandomClassMetric extends AbstractJavaClassMetric {        private Random random = new Random();        @Override        public double computeFor(ASTAnyTypeDeclaration node, MetricOptions options) {            return random.nextInt();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSigMask;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.metrics.SigMask;/** * @author Clment Fournier */public class SigMaskTest extends BaseNonParserTest {    private static final String TEST_FIELDS = "class Bzaz{"        + "public String x;"        + "private int y;"        + "protected String z;"        + "int s;"        + "public final int t;"        + "private final int a;"        + "protected final double u;"        + "final long v;"        + "static int aa;"        + "static final int ab;"        + "private static int ac;"        + "protected static final int ad;"        + "public static int ag;"        + "}";    private static final String TEST_OPERATIONS = "abstract class Bzaz{ "        + "int x;"        + "int y;"        + "int z;"        // constructors        + "public Bzaz() {}"        + "private Bzaz(int x){}"        + "protected Bzaz(int x, String y){}"        // static        + "public static void main(String[] args){}"        + "protected static void makeFoo(){}"        + "private static void makeBar(){}"        // getters and setters        + "public int getX(){return 2;}"        + "int getY(){return 0;}"        + "protected void setY(int y){}"        + "private void setX(int x){}"        // methods        + "public void foo(){} "        + "void bar(){} "        + "protected void foo(int x){} "        + "private void rand(){}"        // abstract        + "protected abstract int getZ();"        + "abstract int abs2();"        + "public static abstract String abstr();"        + "abstract void setZ(int x);"        + "}";    /**     * Ensure any non-abstract method is covered by a newly created mask.     */    @Test    public void testEmptyOperationMask() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        SigMask<JavaOperationSignature> mask = new JavaOperationSigMask();        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isAbstract()) {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }    /**     * Ensure any field is covered by a newly created mask.     */    @Test    public void testEmptyFieldMask() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        SigMask<JavaFieldSignature> mask = new JavaFieldSigMask();        for (ASTFieldDeclaration node : nodes) {            assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));        }    }    @Test    public void testFinalFields() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.forbidFinal();        for (ASTFieldDeclaration node : nodes) {            if (node.isFinal()) {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testStaticFields() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.forbidStatic();        for (ASTFieldDeclaration node : nodes) {            if (node.isStatic()) {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testFieldvisibility() {        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST_FIELDS);        JavaFieldSigMask mask = new JavaFieldSigMask();        mask.restrictVisibilitiesTo(Visibility.PUBLIC);        for (ASTFieldDeclaration node : nodes) {            if (node.isPublic()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PRIVATE);        for (ASTFieldDeclaration node : nodes) {            if (node.isPrivate()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PACKAGE);        for (ASTFieldDeclaration node : nodes) {            if (node.isPackagePrivate()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PROTECTED);        for (ASTFieldDeclaration node : nodes) {            if (node.isProtected()) {                assertTrue(mask.covers(JavaFieldSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaFieldSignature.buildFor(node)));            }        }    }    @Test    public void testOperationVisibility() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        JavaOperationSigMask mask = new JavaOperationSigMask();        mask.coverAbstract();        mask.restrictVisibilitiesTo(Visibility.PUBLIC);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPublic()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PRIVATE);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPrivate()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PACKAGE);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isPackagePrivate()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictVisibilitiesTo(Visibility.PROTECTED);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isProtected()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }    @Test    public void testOperationRoles() {        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST_OPERATIONS);        JavaOperationSigMask mask = new JavaOperationSigMask();        mask.restrictRolesTo(Role.STATIC);        mask.coverAbstract();        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node.isStatic()) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.CONSTRUCTOR);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTConstructorDeclaration) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.GETTER_OR_SETTER);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTMethodDeclaration                && ((ASTMethodDeclaration) node).getName().matches("(get|set).*")) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }        mask.restrictRolesTo(Role.METHOD);        for (ASTMethodOrConstructorDeclaration node : nodes) {            if (node instanceof ASTMethodDeclaration                && !node.isStatic()                && !((ASTMethodDeclaration) node).getName().matches("(get|set).*")) {                assertTrue(mask.covers(JavaOperationSignature.buildFor(node)));            } else {                assertFalse(mask.covers(JavaOperationSignature.buildFor(node)));            }        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertTrue;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.MethodLikeNode;import net.sourceforge.pmd.lang.java.metrics.api.JavaClassMetricKey;import net.sourceforge.pmd.lang.java.metrics.api.JavaOperationMetricKey;import net.sourceforge.pmd.lang.metrics.LanguageMetricsProvider;import net.sourceforge.pmd.lang.metrics.MetricKey;/** * @author Clment Fournier */@Ignore("metrics are like rules, they've not been ported to the new grammar yet")public class JavaMetricsProviderTest {    private final JavaParsingHelper java8 = JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("1.8");    @Test    public void testComputeAllMetrics() {        LanguageMetricsProvider<?, ?> provider = java8.getHandler("1.8").getLanguageMetricsProvider();        ASTCompilationUnit acu = java8.parse("class Foo { void bar() { System.out.println(1); } }");        ASTAnyTypeDeclaration type = acu.getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> results = provider.computeAllMetricsFor(type);        for (JavaClassMetricKey key : JavaClassMetricKey.values()) {            assertTrue(results.containsKey(key));        }        MethodLikeNode op = acu.getFirstDescendantOfType(MethodLikeNode.class);        Map<MetricKey<?>, Double> opResults = provider.computeAllMetricsFor(op);        for (JavaOperationMetricKey key : JavaOperationMetricKey.values()) {            assertTrue(opResults.containsKey(key));        }    }    @Test    public void testThereIsNoMemoisation() {        LanguageMetricsProvider<?, ?> provider = java8.getHandler("1.8").getLanguageMetricsProvider();        ASTAnyTypeDeclaration tdecl1 = java8.parse("class Foo { void bar() { System.out.println(1); } }")                                            .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> reference = provider.computeAllMetricsFor(tdecl1);        // same name, different characteristics        ASTAnyTypeDeclaration tdecl2 = java8.parse("class Foo { void bar(){} \npublic void hey() { System.out.println(1); } }")                                            .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        Map<MetricKey<?>, Double> secondTest = provider.computeAllMetricsFor(tdecl2);        assertNotEquals(reference, secondTest);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;import net.sourceforge.pmd.lang.java.metrics.testdata.GetterDetection;import net.sourceforge.pmd.lang.java.metrics.testdata.SetterDetection;import net.sourceforge.pmd.lang.java.multifile.signature.JavaFieldSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaOperationSignature.Role;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature;import net.sourceforge.pmd.lang.java.multifile.signature.JavaSignature.Visibility;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;/** * Test class for {@link JavaSignature} and its subclasses. * * @author Clment Fournier */public class SignatureTest extends BaseNonParserTest {    // common to operation and field signatures    @Test    public void visibilityTest() {        final String TEST = "class Bzaz{ "            + "public int bar;"            + "String k;"            + "protected double d;"            + "private int i;"            + "protected int x;"            + "public Bzaz(){} "            + "void bar(){} "            + "protected void foo(int x){}"            + "private Bzaz(int y){}"            + "}";        List<ASTMethodOrConstructorDeclaration> operationDeclarations = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<ASTFieldDeclaration> fieldDeclarations = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : operationDeclarations) {            sigs.add(JavaOperationSignature.buildFor(node));        }        // operations        assertEquals(Visibility.PUBLIC, sigs.get(0).visibility);        assertEquals(Visibility.PACKAGE, sigs.get(1).visibility);        assertEquals(Visibility.PROTECTED, sigs.get(2).visibility);        assertEquals(Visibility.PRIVATE, sigs.get(3).visibility);        sigs.clear();        for (ASTFieldDeclaration node : fieldDeclarations) {            sigs.add(JavaFieldSignature.buildFor(node));        }        // fields        assertEquals(Visibility.PUBLIC, sigs.get(0).visibility);        assertEquals(Visibility.PACKAGE, sigs.get(1).visibility);        assertEquals(Visibility.PROTECTED, sigs.get(2).visibility);        assertEquals(Visibility.PRIVATE, sigs.get(3).visibility);    }    @Test    public void operationRoleTest() {        final String TEST = "class Bzaz{ int x; "            + "public static void foo(){} "            + "Bzaz(){} "            + "int getX(){return x;}"            + " void setX(int a){x=a;}"            + " public void doSomething(){}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<JavaOperationSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : nodes) {            sigs.add(JavaOperationSignature.buildFor(node));        }        assertEquals(Role.STATIC, sigs.get(0).role);        assertEquals(Role.CONSTRUCTOR, sigs.get(1).role);        assertEquals(Role.GETTER_OR_SETTER, sigs.get(2).role);        assertEquals(Role.GETTER_OR_SETTER, sigs.get(3).role);        assertEquals(Role.METHOD, sigs.get(4).role);    }    @Test    public void testGetterDetection() {        ASTCompilationUnit compilationUnit = JavaParsingHelper.WITH_PROCESSING.parseClass(GetterDetection.class);        compilationUnit.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertEquals(Role.GETTER_OR_SETTER, Role.get(node));                return data;            }        }, null);    }    @Test    public void testSetterDetection() {        ASTCompilationUnit compilationUnit = JavaParsingHelper.WITH_PROCESSING.parseClass(SetterDetection.class);        compilationUnit.jjtAccept(new JavaParserVisitorAdapter() {            @Override            public Object visit(ASTMethodDeclaration node, Object data) {                assertEquals(Role.GETTER_OR_SETTER, Role.get(node));                return data;            }        }, null);    }    @Test    public void isAbstractOperationTest() {        final String TEST = "abstract class Bzaz{ int x; "            + "public static abstract void foo();"            + "protected abstract int bar(int x);"            + "int getX(){return x;}"            + "void setX(int a){x=a;}"            + "public void doSomething(){}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<JavaOperationSignature> sigs = new ArrayList<>();        for (ASTMethodOrConstructorDeclaration node : nodes) {            sigs.add(JavaOperationSignature.buildFor(node));        }        assertTrue(sigs.get(0).isAbstract);        assertTrue(sigs.get(1).isAbstract);        assertFalse(sigs.get(2).isAbstract);        assertFalse(sigs.get(3).isAbstract);        assertFalse(sigs.get(4).isAbstract);    }    @Test    public void isFinalFieldTest() {        final String TEST = "class Bzaz{"            + "public String x;"            + "private int y;"            + "private final int a;"            + "protected final double u;"            + "final long v;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaFieldSignature> sigs = new ArrayList<>();        for (ASTFieldDeclaration node : nodes) {            sigs.add(JavaFieldSignature.buildFor(node));        }        assertFalse(sigs.get(0).isFinal);        assertFalse(sigs.get(1).isFinal);        assertTrue(sigs.get(2).isFinal);        assertTrue(sigs.get(3).isFinal);        assertTrue(sigs.get(4).isFinal);    }    @Test    public void isStaticFieldTest() {        final String TEST = "class Bzaz{"            + "public final String x;"            + "private int y;"            + "private static int a;"            + "protected static final double u;"            + "static long v;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<JavaFieldSignature> sigs = new ArrayList<>();        for (ASTFieldDeclaration node : nodes) {            sigs.add(JavaFieldSignature.buildFor(node));        }        assertFalse(sigs.get(0).isStatic);        assertFalse(sigs.get(1).isStatic);        assertTrue(sigs.get(2).isStatic);        assertTrue(sigs.get(3).isStatic);        assertTrue(sigs.get(4).isStatic);    }    // Ensure only one instance of a signature is created.    @Test    public void operationPoolTest() {        final String TEST = "class Bzaz{ "            + "public static void foo(){} "            + "public static void az(){} "            + "public static int getX(){return x;}}";        final String TEST2 = "class Bzaz{ "            + "void foo(){} "            + "void az(){} "            + "int rand(){return x;}}";        List<ASTMethodOrConstructorDeclaration> nodes = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST);        List<ASTMethodOrConstructorDeclaration> nodes2 = getOrderedNodes(ASTMethodOrConstructorDeclaration.class, TEST2);        List<JavaOperationSignature> sigs = new ArrayList<>();        List<JavaOperationSignature> sigs2 = new ArrayList<>();        for (int i = 0; i < sigs.size(); i++) {            sigs.add(JavaOperationSignature.buildFor(nodes.get(i)));            sigs2.add(JavaOperationSignature.buildFor(nodes2.get(i)));        }        for (int i = 0; i < sigs.size() - 1; i++) {            assertTrue(sigs.get(i) == sigs.get(i + 1));            assertTrue(sigs2.get(i) == sigs2.get(i + 1));        }    }    // Ensure only one instance of a signature is created.    @Test    public void fieldPoolTest() {        final String TEST = "class Bzaz {"            + "public int bar;"            + "public String k;"            + "public double d;"            + "}";        final String TEST2 = "class Foo {"            + "private final int i;"            + "private final int x;"            + "private final String k;"            + "}";        List<ASTFieldDeclaration> nodes = getOrderedNodes(ASTFieldDeclaration.class, TEST);        List<ASTFieldDeclaration> nodes2 = getOrderedNodes(ASTFieldDeclaration.class, TEST2);        List<JavaFieldSignature> sigs = new ArrayList<>();        List<JavaFieldSignature> sigs2 = new ArrayList<>();        for (int i = 0; i < nodes.size(); i++) {            sigs.add(JavaFieldSignature.buildFor(nodes.get(i)));            sigs2.add(JavaFieldSignature.buildFor(nodes2.get(i)));        }        for (int i = 0; i < nodes.size() - 1; i++) {            assertTrue(sigs.get(i) == sigs.get(i + 1));            assertTrue(sigs2.get(i) == sigs2.get(i + 1));        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types.internal.infer;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import org.checkerframework.checker.nullness.qual.NonNull;import org.hamcrest.BaseMatcher;import org.hamcrest.Description;import org.hamcrest.Matcher;import org.hamcrest.Matchers;import org.hamcrest.SelfDescribing;import org.junit.Assert;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;import net.sourceforge.pmd.lang.java.types.JClassType;import net.sourceforge.pmd.lang.java.types.JIntersectionType;import net.sourceforge.pmd.lang.java.types.JTypeMirror;import net.sourceforge.pmd.lang.java.types.JTypeVar;import net.sourceforge.pmd.lang.java.types.JWildcardType;import net.sourceforge.pmd.lang.java.types.TypeSystem;import net.sourceforge.pmd.lang.java.types.internal.infer.InferenceVar.BoundKind;/** * */public class BaseTypeInferenceUnitTest {    protected final TypeSystem ts = JavaParsingHelper.TEST_TYPE_SYSTEM;    protected final JClassSymbol listSym = ts.getClassSymbol(List.class);    protected InferenceContext emptyCtx() {        return emptyCtx(TypeInferenceLogger.noop());    }    protected InferenceContext emptyCtx(TypeInferenceLogger log) {        return new InferenceContext(ts, Collections.emptyList(), log);    }    protected InferenceVar newIvar(InferenceContext ctx) {        JTypeVar mock = mock(JTypeVar.class);        when(mock.getTypeSystem()).thenReturn(ts);        when(mock.getLowerBound()).thenReturn(ts.NULL_TYPE);        when(mock.getUpperBound()).thenReturn(ts.OBJECT);        return ctx.addVar(mock);    }    /**     * Note: we systematically incorporate because the order in which     * constraints are added should not be overly specified by tests.     * Eg whether {@code a.isConvertibleTo(b)} creates {@code 'a <: 'b} or     * {@code 'b >: 'a} is irrelevant, provided the incorporation phase     * properly propagates either.     */    protected void addSubtypeConstraint(InferenceContext ctx, JTypeMirror t, JTypeMirror s) {        t.isConvertibleTo(s); // nota: this captures t        ctx.incorporate();    }    protected void subtypeConstraintShouldFail(InferenceContext ctx, JTypeMirror t, JTypeMirror s) {        t.isConvertibleTo(s); // nota: this captures t        Assert.assertThrows(ResolutionFailedException.class,                            ctx::incorporate);    }    public @NonNull JTypeMirror listType(JTypeMirror t) {        return ts.parameterise(listSym, listOf(t));    }    public @NonNull JWildcardType extendsWild(JTypeMirror t) {        return ts.wildcard(true, t);    }    public @NonNull JWildcardType superWild(JTypeMirror t) {        return ts.wildcard(false, t);    }    public @NonNull JIntersectionType intersect(JTypeMirror... types) {        JTypeMirror glb = ts.glb(Arrays.asList(types));        assertThat(glb, Matchers.isA(JIntersectionType.class));        return (JIntersectionType) glb;    }    public static Matcher<InferenceVar> hasBound(BoundKind kind, JTypeMirror t) {        return new BaseMatcher<InferenceVar>() {            @Override            public void describeTo(Description description) {            }            @Override            public boolean matches(Object actual) {                if (!(actual instanceof InferenceVar)) {                    return false;                }                return ((InferenceVar) actual).getBounds(kind).contains(t);            }        };    }    /**     * Exactly, modulo the upper(OBJECT), which can be omitted.     */    public static Matcher<InferenceVar> hasBoundsExactly(Bound... bounds) {        return new BaseMatcher<InferenceVar>() {            @Override            public void describeTo(Description description) {                description.appendText("'_ ");                Bound.describeList(description, Arrays.asList(bounds));            }            @Override            public void describeMismatch(Object item, Description description) {                if (!(item instanceof InferenceVar)) {                    description.appendText("Not an ivar: ").appendValue(item);                    return;                }                InferenceVar ivar = (InferenceVar) item;                description.appendText("was ");                description.appendText(ivar.getName());                description.appendText(" ");                Bound.describeList(description, getBoundsObj(ivar));            }            @Override            public boolean matches(Object actual) {                if (!(actual instanceof InferenceVar)) {                    return false;                }                InferenceVar ivar = (InferenceVar) actual;                JClassType top = ivar.getTypeSystem().OBJECT;                // note: don't use ivar.getBounds(ALL) as this would merge 'a >: T and 'a <: T                Map<BoundKind, Set<JTypeMirror>> actualBounds = getBounds(ivar);                // note: don't use sets/ maps to put Bound instances in,                // as captureMatchers don't support hashing. Also don't                // use Set::contains                boolean expectTop = Arrays.stream(bounds).anyMatch(it -> it.kind == BoundKind.UPPER && it.t == top);                int numToTest = actualBounds.values().stream().mapToInt(Set::size).sum();                if (!expectTop) {                    numToTest--;                }                if (numToTest != bounds.length) {                    return false;                }                b:                for (Bound bound : bounds) {                    for (JTypeMirror t : actualBounds.getOrDefault(bound.kind, Collections.emptySet())) {                        if (t.equals(bound.t)) {                            numToTest--;                            continue b;                        }                    }                }                return numToTest == 0;            }        };    }    public static @NonNull Map<BoundKind, Set<JTypeMirror>> getBounds(InferenceVar actual) {        Map<BoundKind, Set<JTypeMirror>> actualBounds = new HashMap<>();        for (BoundKind kind : BoundKind.values()) {            Set<JTypeMirror> bounds = actual.getBounds(kind);            if (!bounds.isEmpty()) {                actualBounds.put(kind, bounds);            }        }        return actualBounds;    }    public static @NonNull Set<Bound> getBoundsObj(InferenceVar actual) {        Set<Bound> bounds = new LinkedHashSet<>();        for (BoundKind kind : BoundKind.values()) {            for (JTypeMirror t : actual.getBounds(kind)) {                bounds.add(new Bound(kind, t));            }        }        return bounds;    }    public static class Bound implements SelfDescribing {        final BoundKind kind;        final JTypeMirror t;        Bound(BoundKind kind, JTypeMirror t) {            this.kind = kind;            this.t = t;        }        @Override        public void describeTo(Description description) {            description.appendText("_" + kind.getSym() + t);        }        public static Bound lower(JTypeMirror t) {            return new Bound(BoundKind.LOWER, t);        }        public static Bound eqBound(JTypeMirror t) {            return new Bound(BoundKind.EQ, t);        }        public static Bound upper(JTypeMirror t) {            return new Bound(BoundKind.UPPER, t);        }        public static Description describeList(Description description, Collection<Bound> bounds) {            return description.appendList("{", ", ", "}", bounds);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import java.util.Map;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class TypesFromReflectionTest extends BaseNonParserTest {    private static final TypeSystem LOADER = JavaParsingHelper.TEST_TYPE_SYSTEM;    @Rule    public final ExpectedException expect = ExpectedException.none();    @Test    public void testNestedClass() {        JClassSymbol c = TypesFromReflection.loadSymbol(LOADER, "java.util.Map.Entry");        assertReflects(Map.Entry.class, c);    }    @Test    public void testPrimitiveArray() {        JClassSymbol c = TypesFromReflection.loadSymbol(LOADER, "int[ ]");        assertReflects(int[].class, c);    }    @Test    public void testNestedClassArray() {        JClassSymbol c = TypesFromReflection.loadSymbol(LOADER, "java.util.Map.Entry[ ]");        assertReflects(Map.Entry[].class, c);    }    @Test    public void testInvalidName() {        expect.expect(IllegalArgumentException.class);        TypesFromReflection.loadSymbol(LOADER, "java.util.Map ]");    }    @Test    public void testInvalidName2() {        expect.expect(IllegalArgumentException.class);        TypesFromReflection.loadSymbol(LOADER, "[]");    }    @Test    public void testNullName() {        expect.expect(NullPointerException.class);        TypesFromReflection.loadSymbol(LOADER, null);    }    private void assertReflects(Class<?> expected, JClassSymbol actual) {        if (expected == null) {            Assert.assertNull(actual);            return;        }        Assert.assertNotNull("Expected " + expected, actual);        Assert.assertEquals("Annot", expected.isAnnotation(), actual.isAnnotation());        Assert.assertEquals("Array", expected.isArray(), actual.isArray());        Assert.assertEquals("Modifiers", expected.getModifiers(), actual.getModifiers());        if (actual.isArray()) {            assertReflects(expected.getComponentType(), (JClassSymbol) actual.getArrayComponent());            // don't test names, the spec of Class::getName and JClassSymbol::getBinaryName            // differ for arrays            return;        }        Assert.assertEquals("Binary name", expected.getName(), actual.getBinaryName());        Assert.assertEquals("Canonical name", expected.getCanonicalName(), actual.getCanonicalName());        assertReflects(expected.getEnclosingClass(), actual.getEnclosingClass());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr.ASTNamedReferenceExpr;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.InvocationNode;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.rule.xpath.Attribute;/** * */public class TypesTreeDumpTest extends BaseTreeDumpTest {    public TypesTreeDumpTest() {        super(new JavaTypeAttrPrinter(), ".java");    }    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return JavaParsingHelper.WITH_PROCESSING.withResourceContext(getClass());    }    @Test    public void testIteratorUtilCopy() {        doTest("IteratorUtilCopy");    }    @Override    protected @NonNull String normalize(@NonNull String str) {        return super.normalize(str)                    // capture IDs are unstable from run to run                    .replaceAll("capture#-?\\d+", "capture#...");    }    /**     * Only prints the type of type nodes     */    private static class JavaTypeAttrPrinter extends RelevantAttributePrinter {        @Override        protected void fillAttributes(@NonNull Node node, @NonNull List<AttributeInfo> result) {            if (node instanceof TypeNode) {                result.add(new AttributeInfo("TypeMirror", ((TypeNode) node).getTypeMirror().toString()));            }            if (node instanceof InvocationNode) {                InvocationNode invoc = (InvocationNode) node;                result.add(new AttributeInfo("MethodName", invoc.getMethodName()));                result.add(new AttributeInfo("VarargsCall", invoc.getOverloadSelectionInfo().isVarargsCall()));                result.add(new AttributeInfo("Unchecked", invoc.getOverloadSelectionInfo().needsUncheckedConversion()));                result.add(new AttributeInfo("Failed", invoc.getOverloadSelectionInfo().isFailed()));                result.add(new AttributeInfo("Function", TypePrettyPrint.prettyPrint(invoc.getMethodType(), true)));            }            if (node instanceof ASTNamedReferenceExpr) {                result.add(new AttributeInfo("Name", ((ASTNamedReferenceExpr) node).getName()));            }            if (node instanceof ASTVariableDeclaratorId) {                result.add(new AttributeInfo("Name", ((ASTVariableDeclaratorId) node).getName()));            }        }        @Override        protected boolean ignoreAttribute(@NonNull Node node, @NonNull Attribute attribute) {            return true;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import java.io.ObjectStreamField;import java.io.Serializable;import java.lang.annotation.Annotation;import java.util.concurrent.Callable;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.java.ast.ASTAnnotation;import net.sourceforge.pmd.lang.java.ast.ASTAnnotationTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTAnonymousClassDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTEnumDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTType;import net.sourceforge.pmd.lang.java.ast.TypeNode;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.java.types.testdata.SomeClassWithAnon;public class TypeTestUtilTest extends BaseNonParserTest {    @Rule    public final ExpectedException expect = ExpectedException.none();    @Test    public void testIsAFallback() {        ASTClassOrInterfaceDeclaration klass =            java.parse("package org; import java.io.Serializable; "                           + "class FooBar implements Serializable {}")                .getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeTestUtil.isA("org.FooBar", klass));        Assert.assertTrue(TypeTestUtil.isA("java.io.Serializable", klass));        Assert.assertTrue(TypeTestUtil.isA(Serializable.class, klass));    }    @Test    public void testIsAFallbackWithUnresolvedClassReference() { // != declaration        ASTAnnotation annot =            java.parse("import a.b.Test;"                           + "class FooBar { @Test void bar() {} }")                .getFirstDescendantOfType(ASTAnnotation.class);        Assert.assertTrue(TypeTestUtil.isA("a.b.Test", annot));        Assert.assertTrue(TypeOps.isUnresolved(annot.getTypeMirror()));        Assert.assertFalse(TypeTestUtil.isA(org.junit.Test.class, annot));        Assert.assertFalse(TypeTestUtil.isA("org.junit.Test", annot));        Assert.assertFalse(TypeTestUtil.isA(Override.class, annot));        Assert.assertFalse(TypeTestUtil.isA("java.lang.Override", annot));    }    @Test    public void testIsAFallbackEnum() {        ASTEnumDeclaration klass =            java.parse("package org; "                           + "enum FooBar implements Iterable {}")                .getFirstDescendantOfType(ASTEnumDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertIsStrictSubtype(klass, Iterable.class);        assertIsStrictSubtype(klass, Enum.class);        assertIsStrictSubtype(klass, Serializable.class);        assertIsStrictSubtype(klass, Object.class);    }    @Test    public void testIsAnArrayClass() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final ObjectStreamField[] serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, ObjectStreamField[].class);        assertIsStrictSubtype(arrayT, Object[].class);        assertIsStrictSubtype(arrayT, Serializable.class);        assertIsNot(arrayT, Serializable[].class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    public void testIsAnAnnotationClass() {        ASTType arrayT =            java.parse("class Foo { org.junit.Test field; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, Test.class);        assertIsStrictSubtype(arrayT, Annotation.class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    public void testIsAPrimitiveArrayClass() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final int[] serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, int[].class);        assertIsNot(arrayT, long[].class);        assertIsNot(arrayT, Object[].class);        assertIsStrictSubtype(arrayT, Serializable.class);        assertIsStrictSubtype(arrayT, Object.class);    }    @Test    public void testIsAPrimitiveSubtype() {        ASTType arrayT =            java.parse("import java.io.ObjectStreamField; "                           + "class Foo { private static final int serialPersistentFields; }")                .getFirstDescendantOfType(ASTType.class);        assertIsExactlyA(arrayT, int.class);        assertIsNot(arrayT, long.class);        assertIsNot(arrayT, double.class);        assertIsNot(arrayT, float.class);        assertIsNot(arrayT, Object.class);    }    @Test    public void testIsAFallbackAnnotation() {        ASTAnnotationTypeDeclaration klass =            java.parse("package org; import foo.Stuff;"                           + "public @interface FooBar {}")                .getFirstDescendantOfType(ASTAnnotationTypeDeclaration.class);        Assert.assertNull(klass.getType());        Assert.assertTrue(TypeTestUtil.isA("org.FooBar", klass));        assertIsA(klass, Annotation.class);        assertIsA(klass, Object.class);    }    @Test    public void testIsATypeVarWithUnresolvedBound() {        // a type var with an unresolved bound should not be considered        // a subtype of everything        ASTType field =            java.parse("class Foo<T extends Unresolved> {\n"                           + "\tT field;\n"                           + "}")                .descendants(ASTFieldDeclaration.class)                .firstOrThrow().getTypeNode();        assertIsA(field, Object.class);        assertIsNot(field, String.class);    }    @Test    public void testIsAStringWithTypeArguments() {        ASTAnyTypeDeclaration klass =            java.parse("package org;"                           + "public class FooBar {}")                .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        expect.expect(IllegalArgumentException.class);        TypeTestUtil.isA("java.util.List<java.lang.String>", klass);    }    @Test    public void testIsAStringWithTypeArgumentsAnnotation() {        ASTAnyTypeDeclaration klass =            java.parse("package org;"                           + "public @interface FooBar {}")                .getFirstDescendantOfType(ASTAnyTypeDeclaration.class);        expect.expect(IllegalArgumentException.class);        TypeTestUtil.isA("java.util.List<java.lang.String>", klass);    }    @Test    public void testAnonClassTypeNPE() {        // #2756        ASTAnonymousClassDeclaration anon =            java.parseClass(SomeClassWithAnon.class)                .getFirstDescendantOfType(ASTAnonymousClassDeclaration.class);        Assert.assertTrue("Anon class", anon.getSymbol().isAnonymousClass());        Assert.assertTrue("Should be a Runnable", TypeTestUtil.isA(Runnable.class, anon));        // This is not a canonical name, so we give up early        Assert.assertFalse(TypeTestUtil.isA(SomeClassWithAnon.class.getName() + "$1", anon));        Assert.assertFalse(TypeTestUtil.isExactlyA(SomeClassWithAnon.class.getName() + "$1", anon));        // this is the failure case: if the binary name doesn't match, we test the canoname, which was null        Assert.assertFalse(TypeTestUtil.isA(Callable.class, anon));        Assert.assertFalse(TypeTestUtil.isA(Callable.class.getCanonicalName(), anon));        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class, anon));        Assert.assertFalse(TypeTestUtil.isExactlyA(Callable.class.getCanonicalName(), anon));    }    /**     * If we don't have the annotation on the classpath,     * we should resolve the full name via the import, if possible     * and compare then. Only after that, we should compare the     * simple names.     */    @Test    public void testIsAFallbackAnnotationSimpleNameImport() {        ASTAnnotation annotation = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                                       .getFirstDescendantOfType(ASTAnnotation.class);        Assert.assertNull(annotation.getType());        Assert.assertTrue(TypeTestUtil.isA("foo.Stuff", annotation));        Assert.assertFalse(TypeTestUtil.isA("other.Stuff", annotation));        // we know it's not Stuff, it's foo.Stuff        Assert.assertFalse(TypeTestUtil.isA("Stuff", annotation));    }    @Test    public void testNullNode() {        Assert.assertFalse(TypeTestUtil.isA(String.class, null));        Assert.assertFalse(TypeTestUtil.isA("java.lang.String", (JTypeMirror) null));        Assert.assertFalse(TypeTestUtil.isA("java.lang.String", (TypeNode) null));        Assert.assertFalse(TypeTestUtil.isExactlyA(String.class, (TypeNode) null));        Assert.assertFalse(TypeTestUtil.isExactlyA("java.lang.String", null));    }    @Test    public void testNullClass() {        final ASTAnnotation node = java.parse("package org; import foo.Stuff; @Stuff public class FooBar {}")                                       .getFirstDescendantOfType(ASTAnnotation.class);        Assert.assertNotNull(node);        Assert.assertThrows(NullPointerException.class, () -> TypeTestUtil.isA((String) null, node));        Assert.assertThrows(NullPointerException.class, () -> TypeTestUtil.isA((Class<?>) null, node));        Assert.assertThrows(NullPointerException.class, () -> TypeTestUtil.isExactlyA((Class<?>) null, node));        Assert.assertThrows(NullPointerException.class, () -> TypeTestUtil.isExactlyA((String) null, node));    }    private void assertIsA(TypeNode node, Class<?> type) {        assertIsA(node, type, false, true);    }    private void assertIsExactlyA(TypeNode node, Class<?> type) {        assertIsA(node, type, true, true);        assertIsA(node, type, false, true);    }    private void assertIsNot(TypeNode node, Class<?> type) {        assertIsA(node, type, true, false);        assertIsA(node, type, false, false);    }    private void assertIsNotExactly(TypeNode node, Class<?> type) {        assertIsA(node, type, true, false);    }    private void assertIsStrictSubtype(TypeNode node, Class<?> type) {        assertIsNotExactly(node, type);        assertIsA(node, type);    }    private void assertIsA(TypeNode node, Class<?> type, boolean exactly, boolean expectTrue) {        Assert.assertEquals("TypeTestUtil::isA with class arg: " + type.getCanonicalName(),                            expectTrue,                            exactly ? TypeTestUtil.isExactlyA(type, node)                                    : TypeTestUtil.isA(type, node));        Assert.assertEquals("TypeTestUtil::isA with string arg: " + type.getCanonicalName(),                            expectTrue,                            exactly ? TypeTestUtil.isExactlyA(type.getCanonicalName(), node)                                    : TypeTestUtil.isA(type.getCanonicalName(), node));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.types;import static net.sourceforge.pmd.lang.java.types.TypeTestUtil.InvocationMatcher.parse;import static org.hamcrest.Matchers.equalTo;import org.hamcrest.MatcherAssert;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;import net.sourceforge.pmd.lang.java.ast.InvocationNode;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class InvocationMatcherTest extends BaseNonParserTest {    @Test    public void testSimpleMatcher() {        ASTMethodCall call =            java.parse("class Foo {{ Integer.valueOf('c'); }}")                .descendants(ASTMethodCall.class).firstOrThrow();        assertMatch(call, "_#valueOf(int)");        assertMatch(call, "java.lang.Integer#valueOf(int)");        assertMatch(call, "java.lang.Integer#_(int)");        assertMatch(call, "java.lang.Integer#_(_*)");        assertNoMatch(call, "java.lang.Integer#valueOf(char)");        assertNoMatch(call, "java.lang.Integer#valueOf2(_*)");        assertNoMatch(call, "java.lang.Object#valueOf(_*)");    }    @Test    public void testCtorMatchers() {        ASTConstructorCall call =            java.parse("class Foo {{ new java.util.ArrayList('c'); }}")                .descendants(ASTConstructorCall.class).firstOrThrow();        assertMatch(call, "_#new(int)");        assertMatch(call, "java.util.ArrayList#new(int)");        assertMatch(call, "java.util.ArrayList#_(int)");        assertMatch(call, "java.util.ArrayList#_(_*)");        assertNoMatch(call, "java.util.ArrayList#new()");        assertNoMatch(call, "java.util.ArrayList#_()");        assertNoMatch(call, "java.util.List#new(_*)");        assertNoMatch(call, "java.util.List#_(_*)");        assertNoMatch(call, "java.lang.Object#new(int)");    }    @Test    public void testArray() {        ASTMethodCall call =            java.parse("class Foo {{ new int[0].toString(); }}")                .descendants(ASTMethodCall.class).firstOrThrow();        assertMatch(call, "int[]#toString()");        assertMatch(call, "_#toString()");        assertMatch(call, "int[]#_()");        assertMatch(call, "int[]#_(_*)");        assertMatch(call, "_#_(_*)");        assertNoMatch(call, "_#new(int)");        assertNoMatch(call, "_[][]#_(_*)");        // maybe we should support this one later        assertNoMatch(call, "_[]#toString()");    }    @Test    public void testWhitespaceErrorMessage() {        parse("_#_(int,int)"); // does not fail        IllegalArgumentException e = Assert.assertThrows(IllegalArgumentException.class, () -> parse("_#_(int, int)"));        MatcherAssert.assertThat(e.getMessage(), equalTo("Expected type at index 8:\n"                                                             + "    \"_#_(int, int)\"\n"                                                             + "             ^\n"));    }    private void assertMatch(InvocationNode call, String sig) {        Assert.assertTrue(sig + " should match " + call,                          parse(sig).matchesCall(call));    }    private void assertNoMatch(InvocationNode call, String s) {        Assert.assertFalse(s + " should not match " + call,                           parse(s).matchesCall(call));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.io.File;import java.util.HashSet;import java.util.Set;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.typeresolution.PMDASMClassLoader;@Ignorepublic class TypeSetTest {    private PMDASMClassLoader pmdClassLoader = PMDASMClassLoader.getInstance(TypeSetTest.class.getClassLoader());    @Test    public void testASTCompilationUnitPackage() {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("java.lang.");        assertEquals("java.lang.", t.getASTCompilationUnitPackage());    }    @Test    public void testAddImport() {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        assertEquals(1, t.getImportsCount());    }    @Test    public void testFindClassImplicitImport() throws ClassNotFoundException {        TypeSet t = new TypeSet();        Class<?> clazz = t.findClass("String");        assertEquals(String.class, clazz);    }    @Test    public void testFindClassSamePackage() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.setASTCompilationUnitPackage("net.sourceforge.pmd");        Class<?> clazz = t.findClass("PMD");        assertEquals(PMD.class, clazz);    }    @Test    public void testFindClassExplicitImport() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.addImport("java.io.File");        Class<?> clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    @Test    public void testFindClassImportOnDemand() throws ClassNotFoundException {        TypeSet t = new TypeSet();        t.addImport("java.io.*");        Class<?> clazz = t.findClass("File");        assertEquals(File.class, clazz);    }    @Test    public void testFindClassPrimitive() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(int.class, t.findClass("int"));    }    @Test    public void testFindClassVoid() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(void.class, t.findClass("void"));    }    @Test    public void testFindFullyQualified() throws ClassNotFoundException {        TypeSet t = new TypeSet();        assertEquals(String.class, t.findClass("java.lang.String"));        assertEquals(Set.class, t.findClass("java.util.Set"));    }    // inner class tests    @Test    public void testPrimitiveTypeResolver() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        assertEquals(int.class, r.resolve("int"));        assertEquals(byte.class, r.resolve("byte"));        assertEquals(long.class, r.resolve("long"));    }    @Test(expected = ClassNotFoundException.class)    public void testPrimitiveTypeResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.PrimitiveTypeResolver();        r.resolve(null);    }    @Test    public void testVoidTypeResolver() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.VoidResolver();        assertEquals(void.class, r.resolve("void"));    }    @Test(expected = ClassNotFoundException.class)    public void testVoidTypeResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.VoidResolver();        r.resolve(null);    }    @Test    public void testExplicitImportResolver() throws ClassNotFoundException {        Set<String> imports = new HashSet<>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, imports);        assertEquals(File.class, r.resolve("File"));    }    @Test(expected = ClassNotFoundException.class)    public void testExplicitImportResolverWithNull() throws ClassNotFoundException {        Set<String> imports = new HashSet<>();        imports.add("java.io.File");        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, imports);        r.resolve(null);    }    @Test(expected = ClassNotFoundException.class)    public void testExplicitImportResolverWithNullAndEmptyImports() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ExplicitImportResolver(pmdClassLoader, new HashSet<String>());        r.resolve(null);    }    @Test    public void testImplicitImportResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        assertEquals(String.class, r.resolve("String"));    }    @Test(expected = ClassNotFoundException.class)    public void testImplicitImportResolverPassFail() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        r.resolve("PMD");    }    @Test(expected = ClassNotFoundException.class)    public void testImplicitImportResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.ImplicitImportResolver(pmdClassLoader);        r.resolve(null);    }    @Test    public void testCurrentPackageResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver(pmdClassLoader, "net.sourceforge.pmd");        assertEquals(PMD.class, r.resolve("PMD"));    }    @Test(expected = ClassNotFoundException.class)    public void testCurrentPackageResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.CurrentPackageResolver(pmdClassLoader, "net.sourceforge.pmd");        r.resolve(null);    }    @Test    public void testImportOnDemandResolverPass() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        assertEquals(Set.class, r.resolve("Set"));        assertEquals(File.class, r.resolve("File"));    }    @Test(expected = ClassNotFoundException.class)    public void testImportOnDemandResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve(null);    }    @Test(expected = ClassNotFoundException.class)    public void importOnDemandResolverFail1() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve("foo");    }    @Test(expected = ClassNotFoundException.class)    public void importOnDemandResolverFail2() throws ClassNotFoundException {        TypeSet.Resolver r = getResolver();        r.resolve("String");    }    private TypeSet.Resolver getResolver() {        Set<String> imports = new HashSet<>();        imports.add("java.io.*");        imports.add("java.util.*");        TypeSet.Resolver r = new TypeSet.ImportOnDemandResolver(pmdClassLoader, imports);        return r;    }    @Test(expected = ClassNotFoundException.class)    public void testFullyQualifiedNameResolverWithNull() throws ClassNotFoundException {        TypeSet.Resolver r = new TypeSet.FullyQualifiedNameResolver(pmdClassLoader);        r.resolve(null);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.List;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;/** * Base class for tests that usually need processing stages to run when * parsing code. */public abstract class BaseNonParserTest {    protected final JavaParsingHelper java = JavaParsingHelper.WITH_PROCESSING.withResourceContext(getClass());    protected final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    protected ASTCompilationUnit parseCode(final String code) {        return java.parse(code);    }    protected <T extends Node> List<T> getOrderedNodes(Class<T> target, String code) {        return JavaParsingHelper.WITH_PROCESSING.getNodes(target, code);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.Scope;@Ignorepublic class VariableNameDeclarationTest extends BaseNonParserTest {    @Test    public void testConstructor() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        Scope s = nodes.get(0).getScope();        NameDeclaration decl = s.getDeclarations().keySet().iterator().next();        assertEquals("bar", decl.getImage());        assertEquals(3, decl.getNode().getBeginLine());    }    @Test    public void testExceptionBlkParam() {        ASTCompilationUnit acu = java.parse(EXCEPTION_PARAMETER);        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(new VariableNameDeclaration(id).isExceptionBlockParameter());    }    @Test    public void testIsArray() {        ASTCompilationUnit acu = parseCode(TEST3);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isArray());    }    @Test    public void testPrimitiveType() {        ASTCompilationUnit acu = parseCode(TEST1);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isPrimitiveType());    }    @Test    public void testArrayIsReferenceType() {        ASTCompilationUnit acu = parseCode(TEST3);        VariableNameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations(VariableNameDeclaration.class).keySet().iterator().next();        assertTrue(decl.isReferenceType());    }    @Test    public void testPrimitiveTypeImage() {        ASTCompilationUnit acu = parseCode(TEST3);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("int", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testRefTypeImage() {        ASTCompilationUnit acu = parseCode(TEST4);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("String", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testParamTypeImage() {        ASTCompilationUnit acu = parseCode(TEST5);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("String", ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordTypeImage() {        ASTCompilationUnit acu = parseCode(TEST6);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("java.util.ArrayList", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordWithPrimitiveTypeImage() {        ASTCompilationUnit acu = parseCode(TEST7);        NameDeclaration decl = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator().next();        assertEquals("long", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testVarKeywordWithIndirectReference() {        ASTCompilationUnit acu = parseCode(TEST8);        Iterator<NameDeclaration> nameDeclarationIterator = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0).getScope()                .getDeclarations().keySet().iterator();        nameDeclarationIterator.next(); // first variable 'bar'        NameDeclaration decl = nameDeclarationIterator.next(); // second variable 'foo'        assertEquals("java.lang.String", ((TypedNameDeclaration) decl).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, ((TypedNameDeclaration) decl).getTypeImage());    }    @Test    public void testLamdaParameterTypeImage() {        ASTCompilationUnit acu = parseCode(TEST9);        List<ASTVariableDeclaratorId> variableDeclaratorIds = acu.findDescendantsOfType(                ASTVariableDeclaratorId.class,                true        );        List<VariableNameDeclaration> nameDeclarations = new ArrayList<>();        for (ASTVariableDeclaratorId variableDeclaratorId : variableDeclaratorIds) {            nameDeclarations.add(variableDeclaratorId.getNameDeclaration());        }        assertEquals("Map", nameDeclarations.get(0).getTypeImage()); // variable 'bar'        assertEquals(null, nameDeclarations.get(1).getTypeImage()); // variable 'key'        assertEquals(null, nameDeclarations.get(2).getTypeImage()); // variable 'value'        // variable 'foo'        assertEquals("foo", nameDeclarations.get(3).getName());        assertEquals("long", nameDeclarations.get(3).getType().getName());        // since the type is inferred, there is no type image        assertEquals(null, nameDeclarations.get(3).getTypeImage());    }    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int bar = 42;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  try {} catch(Exception e) {}" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int[] x;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  String x;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST5 = "public class Foo {" + PMD.EOL + " void foo(String x) {}" + PMD.EOL + "}";    public static final String TEST6 = "import java.util.ArrayList; public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  var bar = new ArrayList<String>(\"param\");" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST7 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  var bar = 42L;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST8 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  var bar = \"test\";" + PMD.EOL + "  var foo = bar;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST9 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Map<String, Object> bar = new HashMap<>();" + PMD.EOL + "  bar.forEach((key, value) -> {" + PMD.EOL            + "   if (value instanceof String) {" + PMD.EOL + "    var foo = 42L;" + PMD.EOL            + "    System.out.println(value);" + PMD.EOL + "   }" + PMD.EOL + "  });" + PMD.EOL + " }" + PMD.EOL + "}";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VariableNameDeclarationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertTrue;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTBlock;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTIfStatement;@Ignorepublic class ScopeCreationVisitorTest extends BaseNonParserTest {    @Test    public void testScopesAreCreated() {        ASTCompilationUnit acu = parseCode(TEST1);        ASTBlock n = acu.getFirstDescendantOfType(ASTIfStatement.class)                .getFirstDescendantOfType(ASTBlock.class);        assertTrue(n.getScope() instanceof LocalScope);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  if (x>2) {}"            + PMD.EOL + " }" + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ScopeCreationVisitorTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTName;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.InternalApiBridge;import net.sourceforge.pmd.lang.java.ast.JavaNode;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;@Ignorepublic class ClassScopeTest extends BaseNonParserTest {    @Test    public void testEnumsClassScope() {        java5.parse(ENUM_SCOPE);    }    @Test    public void testEnumTypeParameter() {        java5.parse(ENUM_TYPE_PARAMETER);    }    @Test    public void testVarArgsEmpty() {        java5.parse("public class Foo {\n" + "  public void bar1(String s, Integer... i) {}\n"                + "  public void bar1() {}\n" + "  public void c() {\n" + "    bar1();\n" + "  }\n" + "}\n");    }    // FIXME - these will break when this goes from Anonymous$1 to Foo$1    @Test    public void testAnonymousInnerClassName() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        s = new ClassScope(classDeclaration);        assertEquals("Anonymous$1", s.getClassName());        s = new ClassScope(classDeclaration);        assertEquals("Anonymous$2", s.getClassName());    }    @Test    public void testContains() {        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(null);        ClassScope s = new ClassScope("Foo", classDeclaration);        ASTVariableDeclaratorId node = InternalApiBridge.newVarId("bar");        s.addDeclaration(new VariableNameDeclaration(node));        assertTrue(s.getDeclarations().keySet().iterator().hasNext());    }    @Test    public void testCantContainsSuperToString() {        ASTCompilationUnit cu = java.parse("class Foo { public String toString() { return super.toString(); } }");        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(cu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class));        ClassScope s = new ClassScope("Foo", classDeclaration);        JavaNode node = cu.getFirstDescendantOfType(ASTPrimaryExpression.class); // "super.toString();"        assertFalse(s.contains(new JavaNameOccurrence(node, "super.toString")));    }    @Test    public void testContainsStaticVariablePrefixedWithClassName() {        ASTCompilationUnit cu = java.parse("class Foo { static int X; public int bar() { return Foo.X; } }");        ClassNameDeclaration classDeclaration = new ClassNameDeclaration(cu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class));        ClassScope s = new ClassScope("Foo", classDeclaration);        ASTVariableDeclaratorId node = cu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        s.addDeclaration(new VariableNameDeclaration(node));        JavaNode node2 = cu.getFirstDescendantOfType(ASTName.class);        assertTrue(s.contains(new JavaNameOccurrence(node2, node2.getImage())));    }    @Test    public void testClassName() {        ASTCompilationUnit acu = parseCode(CLASS_NAME);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        assertEquals("Foo", n.getScope().getEnclosingScope(ClassScope.class).getClassName());    }    @Test    public void testMethodDeclarationRecorded() {        ASTCompilationUnit acu = parseCode(METHOD_DECLARATIONS_RECORDED);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope s = (ClassScope) n.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        assertEquals(1, m.size());        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("bar", mnd.getImage());        ASTMethodDeclaration node = (ASTMethodDeclaration) mnd.getNode().getParent();        assertTrue(node.isPrivate());    }    @Test    public void testTwoMethodsSameNameDiffArgs() {        // TODO this won't work with String and java.lang.String        ASTCompilationUnit acu = parseCode(METHODS_WITH_DIFF_ARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        assertEquals(2, m.size());        Iterator<NameDeclaration> i = m.keySet().iterator();        MethodNameDeclaration mnd = (MethodNameDeclaration) i.next();        assertEquals("bar", mnd.getImage());        assertEquals("bar", ((MethodNameDeclaration) i.next()).getImage());    }    @Test    public final void testOneParam() {        ASTCompilationUnit acu = parseCode(ONE_PARAM);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String)", mnd.getParameterDisplaySignature());    }    @Test    public final void testTwoParams() {        ASTCompilationUnit acu = parseCode(TWO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,int)", mnd.getParameterDisplaySignature());    }    @Test    public final void testNoParams() {        ASTCompilationUnit acu = parseCode(NO_PARAMS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("()", mnd.getParameterDisplaySignature());    }    @Test    public final void testOneParamVararg() {        ASTCompilationUnit acu = java5.parse(ONE_PARAM_VARARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String...)", mnd.getParameterDisplaySignature());    }    @Test    public final void testTwoParamsVararg() {        ASTCompilationUnit acu = java5.parse(TWO_PARAMS_VARARG);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        MethodNameDeclaration mnd = (MethodNameDeclaration) m.keySet().iterator().next();        assertEquals("(String,String...)", mnd.getParameterDisplaySignature());    }    @Test    public void testNestedClassesOfImportResolution() {        ASTCompilationUnit acu = parseCode(NESTED_CLASSES_OF_IMPORT);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(EnumTest.class, c.resolveType("TheInnerClass.EnumTest"));    }    @Test    public void testNestedClassesResolution() {        final ASTClassOrInterfaceDeclaration n = java.parseClass(InnerClass.class)                                                     .findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(InnerClass.class, c.resolveType("InnerClass"));        assertEquals(TheInnerClass.class, c.resolveType("InnerClass.TheInnerClass"));        assertEquals(TheInnerClass.class, c.resolveType("TheInnerClass")); // Within this scope, we can access it directly    }    @Test    public void testImportNestedClassesResolution() {        ASTCompilationUnit acu = parseCode(IMPORT_NESTED_CLASSES);        final ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        final ClassScope c = (ClassScope) n.getScope();        assertEquals(EnumTest.class, c.resolveType("EnumTest"));    }    @Test    public final void testNestedClassDeclFound() {        ASTCompilationUnit acu = parseCode(NESTED_CLASS_FOUND);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        ClassScope c = (ClassScope) n.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = c.getDeclarations();        ClassNameDeclaration cnd = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals("Buz", cnd.getImage());    }    @Test    public final void testbuz() {        parseCode(METH);        // SymbolTableViewer st = new SymbolTableViewer();        // acu.jjtAccept(st, null);    }    @Test    public void testMethodUsageSeen() {        ASTCompilationUnit acu = parseCode(METHOD_USAGE_SEEN);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Iterator<Map.Entry<NameDeclaration, List<NameOccurrence>>> i = m.entrySet().iterator();        MethodNameDeclaration mnd;        Map.Entry<NameDeclaration, List<NameOccurrence>> entry;        do {            entry = i.next();            mnd = (MethodNameDeclaration) entry.getKey();        } while (!mnd.getImage().equals("bar"));        List<NameOccurrence> usages = entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((JavaNameOccurrence) usages.get(0)).getImage());    }    @Test    public void testMethodUsageSeenWithThis() {        ASTCompilationUnit acu = parseCode(METHOD_USAGE_SEEN_WITH_THIS);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Iterator<Map.Entry<NameDeclaration, List<NameOccurrence>>> i = m.entrySet().iterator();        MethodNameDeclaration mnd;        Map.Entry<NameDeclaration, List<NameOccurrence>> entry;        do {            entry = i.next();            mnd = (MethodNameDeclaration) entry.getKey();        } while (!mnd.getImage().equals("bar"));        List<NameOccurrence> usages = entry.getValue();        assertEquals(1, usages.size());        assertEquals("bar", ((JavaNameOccurrence) usages.get(0)).getImage());    }    @Test    public void testMethodUsageSeen2() {        ASTCompilationUnit acu = parseCode(METHOD_USAGE_SEEN2);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        assertEquals(2, m.size());        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            assertEquals("baz", entry.getKey().getImage());            if (entry.getKey().getNode().getBeginLine() == 2) {                // this is the public method declaration - it is not used                // anywhere                assertEquals(0, entry.getValue().size());            } else if (entry.getKey().getNode().getBeginLine() == 5) {                // this is the private (overloaded) method                assertEquals(1, entry.getValue().size());                // it's used once in line 3                assertEquals(3, entry.getValue().get(0).getLocation().getBeginLine());            } else {                fail("unexpected name declaration");            }        }    }    /**     * Test case for bug report #2410201     */    @Test    public void testNestedClassFieldAndParameter() {        ASTCompilationUnit acu = parseCode(NESTED_CLASS_FIELD_AND_PARAM);        ASTMethodDeclaration node = acu.getFirstDescendantOfType(ASTMethodDeclaration.class);        Map<VariableNameDeclaration, List<NameOccurrence>> vd = node.getScope().getDeclarations(VariableNameDeclaration.class);        assertEquals(2, vd.size());        int paramCount = 0;        for (Map.Entry<VariableNameDeclaration, List<NameOccurrence>> entry : vd.entrySet()) {            if (entry.getKey().getDeclaratorId().isFormalParameter()) {                assertEquals("field", entry.getKey().getImage());                List<NameOccurrence> occurrences = entry.getValue();                assertEquals(2, occurrences.size());                NameOccurrence no1 = occurrences.get(0);                assertEquals(8, no1.getLocation().getBeginLine());                NameOccurrence no2 = occurrences.get(1);                assertEquals(9, no2.getLocation().getBeginLine());                paramCount++;            }        }        assertEquals(1, paramCount);    }    @Test    public void testNullType() {        ASTCompilationUnit acu = parseCode(TEST_NULL_TYPE);    }    private static final String NESTED_CLASS_FIELD_AND_PARAM = "public class Foo {" + PMD.EOL + " class Test {"            + PMD.EOL + "   public String field;" + PMD.EOL + "   public Test t;" + PMD.EOL + " }" + PMD.EOL            + " public void foo(String field) {" + PMD.EOL + "   Test t = new Test();" + PMD.EOL + "   t.field = field;"            + PMD.EOL + "   t.t.field = field;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN2 = "public class Foo {" + PMD.EOL + " public void baz() {" + PMD.EOL            + "  baz(x, y);" + PMD.EOL + " }" + PMD.EOL + " private void baz(int x, int y) {}" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN = "public class Foo {" + PMD.EOL + " private void bar() {}" + PMD.EOL            + " public void buz() {" + PMD.EOL + "  bar();" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METHOD_USAGE_SEEN_WITH_THIS = "public class Foo {" + PMD.EOL + " private void bar() {}"            + PMD.EOL + " public void buz() {" + PMD.EOL + "  this.bar();" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String METH = "public class Test {" + PMD.EOL + "  static { " + PMD.EOL + "   int y; "            + PMD.EOL + "  } " + PMD.EOL + "  void bar(int x) {} " + PMD.EOL + "  void baz(int x) {} " + PMD.EOL + "}";    private static final String NESTED_CLASS_FOUND = "public class Test {" + PMD.EOL + "  private class Buz {} "            + PMD.EOL + "}";    private static final String ONE_PARAM = "public class Test {" + PMD.EOL + "  void bar(String x) {" + PMD.EOL + "  }"            + PMD.EOL + "}";    private static final String TWO_PARAMS = "public class Test {" + PMD.EOL + "  void bar(String x, int y) {" + PMD.EOL            + "  }" + PMD.EOL + "}";    private static final String NO_PARAMS = "public class Test {" + PMD.EOL + "  void bar() {" + PMD.EOL + "  }"            + PMD.EOL + "}";    private static final String ONE_PARAM_VARARG = "public class Test {" + PMD.EOL + "  void bar(String... s) {"            + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String TWO_PARAMS_VARARG = "public class Test {" + PMD.EOL            + "  void bar(String s1, String... s2) {" + PMD.EOL + "  }" + PMD.EOL + "}";    private static final String CLASS_NAME = "public class Foo {}";    private static final String METHOD_DECLARATIONS_RECORDED = "public class Foo {" + PMD.EOL + " private void bar() {}"            + PMD.EOL + "}";    private static final String METHODS_WITH_DIFF_ARG = "public class Foo {" + PMD.EOL            + " private void bar(String x) {}" + PMD.EOL + " private void bar() {}" + PMD.EOL + "}";    private static final String ENUM_SCOPE = "public enum Foo {" + PMD.EOL + " HEAP(\"foo\");" + PMD.EOL            + " private final String fuz;" + PMD.EOL + " public String getFuz() {" + PMD.EOL + "  return fuz;" + PMD.EOL            + " }" + PMD.EOL + "}";    public static final String TEST_NULL_TYPE = "public abstract class NullTypeTest {" + PMD.EOL            + "   protected Comparator<TreeNode> nodesComparator = (o1, o2) -> StringHelper.saveCompare(getFilterableString(o1), getFilterableString(o2));"            + PMD.EOL + "   public abstract String getFilterableString(TreeNode node);" + PMD.EOL + "}";    private static final String ENUM_TYPE_PARAMETER = "public enum Foo {" + PMD.EOL            + "   BAR(isCustomer(BazEnum.FOO_BAR));" + PMD.EOL + "   Foo(boolean isCustomer) { }" + PMD.EOL            + "   private static boolean isCustomer(BazEnum baz) {" + PMD.EOL + "      return false;" + PMD.EOL + "   }"            + PMD.EOL + "}";    private static final String IMPORT_NESTED_CLASSES =            "import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass.EnumTest;" + PMD.EOL            + "public class Foo {" + PMD.EOL            + " public EnumTest e;" + PMD.EOL            + "}" + PMD.EOL;    private static final String NESTED_CLASSES_OF_IMPORT =            "import net.sourceforge.pmd.lang.java.symboltable.testdata.InnerClass.TheInnerClass;" + PMD.EOL            + "public class Foo {" + PMD.EOL            + " public TheInnerClass.EnumTest e;" + PMD.EOL            + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.List;import java.util.Set;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclarator;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;@Ignorepublic class ScopeAndDeclarationFinderTest extends BaseNonParserTest {    /**     * Unit test for https://sourceforge.net/p/pmd/bugs/1317/     */    @Test    public void testJava8LambdaScoping() {        String source = "public class MultipleLambdas {\n"            + "  Observer a = (o, arg) -> System.out.println(\"a:\" + arg);\n"            + "  Observer b = (o, arg) -> System.out.println(\"b:\" + arg);\n" + "}";        List<ASTLambdaExpression> lambdas = java.parse(source, "1.8").findDescendantsOfType(ASTLambdaExpression.class);        Assert.assertEquals(2, lambdas.size());        LocalScope scope1 = (LocalScope) lambdas.get(0).getScope();        LocalScope scope2 = (LocalScope) lambdas.get(1).getScope();        Assert.assertNotSame(scope1, scope2);        for (ASTLambdaExpression l : lambdas) {            LocalScope scope = (LocalScope) l.getScope();            Assert.assertEquals(2, scope.getVariableDeclarations().size());            Assert.assertTrue(scope.contains(new JavaNameOccurrence(null, "o")));            Assert.assertTrue(scope.contains(new JavaNameOccurrence(null, "arg")));            Set<NameDeclaration> declarations = scope.findVariableHere(new JavaNameOccurrence(null, "arg"));            Assert.assertEquals(1, declarations.size());            NameDeclaration decl = declarations.iterator().next();            Assert.assertEquals(1, scope.getVariableDeclarations().get(decl).size());        }    }    @Test    public void testAnnonInnerClassScoping() {        String source = "public class Foo {" + PMD.EOL                + "  public static final Creator<Foo> CREATOR = new Creator<Foo>() {" + PMD.EOL                + "    @Override public Foo createFromParcel(Parcel source) {" + PMD.EOL                + "      return new Foo();" + PMD.EOL                + "    }" + PMD.EOL                + "    @Override public Foo[] newArray(int size) {" + PMD.EOL                + "      return new Foo[size];" + PMD.EOL                + "    }" + PMD.EOL                + "  };" + PMD.EOL                + "}" + PMD.EOL;        ASTCompilationUnit acu = java.parse(source, "1.6");        ClassScope cs = (ClassScope) acu.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class).getScope();        Assert.assertEquals(1, cs.getClassDeclarations().size()); // There should be 1 anonymous class        List<ASTMethodDeclarator> methods = acu.getFirstDescendantOfType(ASTClassOrInterfaceBody.class) // outer class                .getFirstDescendantOfType(ASTClassOrInterfaceBody.class) // inner class                .findDescendantsOfType(ASTMethodDeclarator.class, true); // inner class methods        Assert.assertEquals(2, methods.size());        ClassScope scope1 = methods.get(0).getScope().getEnclosingScope(ClassScope.class);        ClassScope scope2 = methods.get(1).getScope().getEnclosingScope(ClassScope.class);        Assert.assertSame(scope1, scope2);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;@Ignorepublic class LocalScopeTest extends BaseNonParserTest {    @Test    public void testLocalVariableDeclarationFound() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        assertEquals(1, vars.size());        NameDeclaration decl = vars.keySet().iterator().next();        assertEquals("b", decl.getImage());    }    @Test    public void testQualifiedNameOccurrence() {        ASTCompilationUnit acu = parseCode(TEST2);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        NameDeclaration decl = vars.keySet().iterator().next();        JavaNameOccurrence occ = (JavaNameOccurrence) vars.get(decl).get(0);        assertEquals("b", occ.getImage());    }    @Test    public void testPostfixUsageIsRecorded() {        ASTCompilationUnit acu = parseCode(TEST3);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        ASTVariableDeclaratorId node = nodes.get(0);        Map<NameDeclaration, List<NameOccurrence>> vars = node.getScope().getDeclarations();        NameDeclaration decl = vars.keySet().iterator().next();        List<NameOccurrence> usages = vars.get(decl);        JavaNameOccurrence occ = (JavaNameOccurrence) usages.get(0);        assertEquals(4, occ.getLocation().getBeginLine());    }    @Test    public void testLocalVariableTypesAreRecorded() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTVariableDeclaratorId> nodes = acu.findDescendantsOfType(ASTVariableDeclaratorId.class);        Map<NameDeclaration, List<NameOccurrence>> vars = nodes.get(0).getScope().getDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("Bar", decl.getTypeImage());    }    @Test    public void testMethodArgumentTypesAreRecorded() {        ASTCompilationUnit acu = parseCode(TEST5);        List<ASTFormalParameter> nodes = acu.findDescendantsOfType(ASTFormalParameter.class);        Map<NameDeclaration, List<NameOccurrence>> vars = nodes.get(0).getScope().getDeclarations();        VariableNameDeclaration decl = (VariableNameDeclaration) vars.keySet().iterator().next();        assertEquals("String", decl.getTypeImage());    }    @Test    public void testgetEnclosingMethodScope() {        ASTCompilationUnit acu = parseCode(TEST4);        ASTLocalVariableDeclaration node = acu.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(0);        LocalScope scope = (LocalScope) node.getScope();        MethodScope ms = scope.getEnclosingScope(MethodScope.class);        assertEquals(2, ms.getDeclarations().size());    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Bar b = new Bar();" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  Bar b = new Bar();" + PMD.EOL + "  b.buz = 2;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x = 2;"            + PMD.EOL + "  x++;" + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo(String x, String z) { { int x; } }"            + PMD.EOL + "}";    public static final String TEST5 = "public class Foo {" + PMD.EOL + " void foo(String x);" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import java.util.ArrayList;import java.util.List;import java.util.Map;import javax.swing.JComponent;import javax.swing.JTextField;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;/** * Unit test for {@link SimpleTypedNameDeclaration} */@Ignorepublic class SimpleTypedNameDeclarationTest {    /**     * Tests the equal method.     */    @Test    public void testEquals() {        Assert.assertEquals(byClass(SimpleTypedNameDeclaration.class), byClass(SimpleTypedNameDeclaration.class));        Assert.assertEquals(byClass(List.class), byClass(ArrayList.class));        Assert.assertEquals(byClass(ArrayList.class), byClass(List.class));        Assert.assertEquals(byName("String"), byName("String"));        Assert.assertEquals(byClass(String.class), byName("String"));        Assert.assertEquals(byClass(JComponent.class), byClass(JTextField.class));        Assert.assertFalse(byClass(Map.class).equals(byClass(List.class)));        Assert.assertFalse(byName("A").equals(byName("B")));        Assert.assertFalse(byClass(String.class).equals(byName("A")));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "double"));        Assert.assertEquals(by(Double.class, "Double"), by(null, "double"));        Assert.assertEquals(by(Character.class, "Character"), by(null, "char"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "float"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "int"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Double.TYPE, "double"), by(null, "long"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Long.TYPE, "long"));        Assert.assertEquals(by(Double.TYPE, "double"), by(Long.class, "Long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(null, "int"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Integer.TYPE, "int"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Float.TYPE, "float"), by(null, "long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Long.TYPE, "long"));        Assert.assertEquals(by(Float.TYPE, "float"), by(Long.class, "Long"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(null, "char"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(Character.TYPE, "char"));        Assert.assertEquals(by(Integer.TYPE, "int"), by(Character.class, "Character"));        Assert.assertEquals(by(Long.TYPE, "long"), by(null, "int"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Integer.TYPE, "int"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Integer.class, "Integer"));        Assert.assertEquals(by(Long.TYPE, "long"), by(null, "char"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Character.TYPE, "char"));        Assert.assertEquals(by(Long.TYPE, "long"), by(Character.class, "Character"));        // should always equal to Object        Assert.assertEquals(by(Object.class, "Object"), by(null, "Something"));        Assert.assertEquals(withNext(byName("Foo.I"), "Foo.B"), byName("Foo.I"));        Assert.assertEquals(byName("Foo.I"), withNext(byName("Foo.I"), "Foo.B"));    }    private static SimpleTypedNameDeclaration byClass(Class<?> c) {        return new SimpleTypedNameDeclaration(c.getSimpleName(), c);    }    private static SimpleTypedNameDeclaration byName(String n) {        return new SimpleTypedNameDeclaration(n, null);    }    private static SimpleTypedNameDeclaration by(Class<?> c, String n) {        return new SimpleTypedNameDeclaration(n, c);    }    private static SimpleTypedNameDeclaration withNext(SimpleTypedNameDeclaration next, String n) {        SimpleTypedNameDeclaration t = new SimpleTypedNameDeclaration(n, null);        t.addNext(next);        return t;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;@Ignorepublic class MethodScopeTest extends BaseNonParserTest {    @Test    public void testMethodParameterOccurrenceRecorded() {        ASTCompilationUnit acu = parseCode(TEST1);        Map<NameDeclaration, List<NameOccurrence>> m = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0)                .getScope().getDeclarations();        NameDeclaration vnd = m.keySet().iterator().next();        assertEquals("bar", vnd.getImage());        List<NameOccurrence> occs = m.get(vnd);        NameOccurrence occ = occs.get(0);        assertEquals(3, occ.getLocation().getBeginLine());    }    @Test    public void testMethodName() {        ASTCompilationUnit acu = parseCode(TEST1);        ASTMethodDeclaration meth = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0);        MethodScope ms = (MethodScope) meth.getScope();        assertEquals(ms.getName(), "foo");    }    @Test    public void testGenerics() {        parseCode(TEST_GENERICS);    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo(int bar) {" + PMD.EOL + "  bar = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST_GENERICS = "public class Tree {" + PMD.EOL + "  private List<Object> subForest;"            + PMD.EOL + "  public <B> Tree<B> fmap(final F<B> f) { return Tree.<B>foo(); }" + PMD.EOL            + "  public List<Object> subForest() { return null; }" + PMD.EOL + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;@Ignorepublic class NameOccurrencesTest extends BaseNonParserTest {    @Test    public void testSuper() {        ASTCompilationUnit acu = parseCode(TEST1);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("super", occs.getNames().get(0).getImage());    }    @Test    public void testThis() {        ASTCompilationUnit acu = parseCode(TEST2);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("this", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    @Test    public void testNameLinkage() {        ASTCompilationUnit acu = parseCode(TEST2);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        JavaNameOccurrence thisNameOccurrence = occs.getNames().get(0);        assertEquals(thisNameOccurrence.getNameForWhichThisIsAQualifier(), occs.getNames().get(1));    }    @Test    public void testSimpleVariableOccurrence() {        ASTCompilationUnit acu = parseCode(TEST3);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("x", occs.getNames().get(0).getImage());        assertFalse(occs.getNames().get(0).isThisOrSuper());        assertFalse(occs.getNames().get(0).isMethodOrConstructorInvocation());        assertTrue(occs.getNames().get(0).isOnLeftHandSide());    }    @Test    public void testQualifiedOccurrence() {        ASTCompilationUnit acu = parseCode(TEST4);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(0));        assertEquals("b", occs.getNames().get(0).getImage());        assertEquals("x", occs.getNames().get(1).getImage());    }    @Test    public void testIsSelfAssignment() {        ASTCompilationUnit acu = parseCode(TEST5);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());        acu = parseCode(TEST6);        nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        occs = new NameFinder(nodes.get(2));        assertTrue(occs.getNames().get(0).isSelfAssignment());    }    @Test    public void testEnumStaticUsage() {        ASTCompilationUnit acu = parseCode(TEST_ENUM);        List<ASTPrimaryExpression> nodes = acu.findDescendantsOfType(ASTPrimaryExpression.class);        NameFinder occs = new NameFinder(nodes.get(4));        List<JavaNameOccurrence> names = occs.getNames();        assertEquals(3, names.size());        assertEquals("myEnum", names.get(0).getImage());        assertFalse(names.get(0).isMethodOrConstructorInvocation());        assertEquals("desc", names.get(1).getImage());        assertFalse(names.get(1).isMethodOrConstructorInvocation());        assertEquals("equals", names.get(2).getImage());        assertTrue(names.get(2).isMethodOrConstructorInvocation());    }    public static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  super.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  this.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  x = 2;" + PMD.EOL            + " }" + PMD.EOL + "}";    public static final String TEST4 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  b.x = 2;"            + PMD.EOL + " }" + PMD.EOL + "}";    public static final String TEST5 = "public class Foo{" + PMD.EOL + "    private int counter;" + PMD.EOL            + "    private Foo(){" + PMD.EOL + "        counter = 0;" + PMD.EOL + "    }" + PMD.EOL            + "    private int foo(){" + PMD.EOL + "        if (++counter < 3) {" + PMD.EOL + "            return 0;"            + PMD.EOL + "        }" + PMD.EOL + "        return 1;" + PMD.EOL + "    }" + PMD.EOL + "}";    public static final String TEST6 = "public class Foo{" + PMD.EOL + "    private int counter;" + PMD.EOL            + "    private Foo(){" + PMD.EOL + "        counter = 0;" + PMD.EOL + "    }" + PMD.EOL            + "    private int foo(){" + PMD.EOL + "        if (++this.counter < 3) {" + PMD.EOL            + "            return 0;" + PMD.EOL + "        }" + PMD.EOL + "        return 1;" + PMD.EOL + "    }"            + PMD.EOL + "}";    public static final String TEST_ENUM = "public enum MyEnum {" + PMD.EOL + "  A(\"a\");" + PMD.EOL            + "  private final String desc;" + PMD.EOL + "  private MyEnum(String desc) {" + PMD.EOL            + "    this.desc = desc;" + PMD.EOL + "  }" + PMD.EOL + "  public static MyEnum byDesc(String desc) {"            + PMD.EOL + "    for (MyEnum myEnum : value()) {" + PMD.EOL            + "      if (myEnum.desc.equals(desc)) return myEnum;" + PMD.EOL + "    }" + PMD.EOL + "    return null;"            + PMD.EOL + "  }" + PMD.EOL + " }";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(NameOccurrencesTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;import net.sourceforge.pmd.lang.symboltable.Scope;@Ignorepublic class GlobalScopeTest extends BaseNonParserTest {    @Test    public void testClassDeclAppears() {        ASTCompilationUnit acu = parseCode(TEST1);        Scope scope = acu.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = scope.getDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    @Test    public void testEnums() {        java5.parse(TEST2);    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "public enum Bar {" + PMD.EOL + "  FOO1 {          " + PMD.EOL            + "    private static final String FIELD_NAME = \"\";" + PMD.EOL + "  }," + PMD.EOL + "  FOO2 {          "            + PMD.EOL + "    private static final String FIELD_NAME = \"\";" + PMD.EOL + "  }" + PMD.EOL + "}"            + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;@Ignorepublic class MethodNameDeclarationTest extends BaseNonParserTest {    @Test    public void testEquality() {        // Verify proper number of nodes are not equal        ASTCompilationUnit acu = java5.parse(SIMILAR);        ASTClassOrInterfaceDeclaration n = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(0);        Map<NameDeclaration, List<NameOccurrence>> m = ((ClassScope) n.getScope()).getDeclarations();        Set<NameDeclaration> methodNameDeclarations = m.keySet();        assertEquals("Wrong number of method name declarations", methodNameDeclarations.size(), 3);    }    private static final String SIMILAR = "public class Foo {" + PMD.EOL + " public void bar() {" + PMD.EOL            + "  bar(x, y);" + PMD.EOL + " }" + PMD.EOL + " private void bar(int x, int y) {}" + PMD.EOL            + " private void bar(int x, int... y) {}" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;@Ignorepublic class SourceFileScopeTest extends BaseNonParserTest {    @Test    public void testClassDeclAppears() {        ASTCompilationUnit acu = parseCode(TEST1);        Map<NameDeclaration, List<NameOccurrence>> m = acu.getScope().getDeclarations();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) m.keySet().iterator().next();        assertEquals(classNameDeclaration.getImage(), "Foo");    }    @Test    public void testPackageIsEmptyString() {        ASTCompilationUnit acu = parseCode(TEST1);        assertEquals(acu.getScope().getEnclosingScope(SourceFileScope.class).getPackageName(), "");    }    @Test    public void testPackageNameFound() {        ASTCompilationUnit acu = parseCode(TEST2);        assertEquals(acu.getScope().getEnclosingScope(SourceFileScope.class).getPackageName(), "foo.bar");    }    @Test    public void testNestedClasses() {        ASTCompilationUnit acu = parseCode(TEST3);        Map<NameDeclaration, List<NameOccurrence>> m = acu.getScope().getDeclarations();        Iterator<NameDeclaration> iterator = m.keySet().iterator();        ClassNameDeclaration classNameDeclaration = (ClassNameDeclaration) iterator.next();        assertEquals(classNameDeclaration.getImage(), "Foo");        assertFalse(iterator.hasNext());    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "package foo.bar;" + PMD.EOL + "public class Foo {" + PMD.EOL + "}" + PMD.EOL;    private static final String TEST3 = "public class Foo {" + PMD.EOL + " public class Bar {" + PMD.EOL + " }"            + PMD.EOL + "}" + PMD.EOL;}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.List;import java.util.Map;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.ast.ASTBlock;import net.sourceforge.pmd.lang.java.ast.ASTCatchClause;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTEqualityExpression;import net.sourceforge.pmd.lang.java.ast.ASTInitializer;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;import net.sourceforge.pmd.lang.symboltable.Scope;@Ignorepublic class AcceptanceTest extends BaseNonParserTest {    @Test    public void testClashingSymbols() {        parseCode(TEST1);    }    @Test    public void testInitializer() {        ASTCompilationUnit acu = parseCode(TEST_INITIALIZERS);        ASTInitializer a = acu.findDescendantsOfType(ASTInitializer.class).get(0);        assertFalse(a.isStatic());        a = acu.findDescendantsOfType(ASTInitializer.class).get(1);        assertTrue(a.isStatic());    }    @Test    public void testCatchBlocks() {        ASTCompilationUnit acu = parseCode(TEST_CATCH_BLOCKS);        ASTCatchClause c = acu.findDescendantsOfType(ASTCatchClause.class).get(0);        ASTBlock a = c.findDescendantsOfType(ASTBlock.class).get(0);        Scope s = a.getScope();        Map<NameDeclaration, List<NameOccurrence>> vars = s.getDeclarations();        assertEquals(1, vars.size());        NameDeclaration v = vars.keySet().iterator().next();        assertEquals("e", v.getImage());        assertEquals(1, (vars.get(v)).size());    }    @Test    public void testEq() {        ASTCompilationUnit acu = parseCode(TEST_EQ);        ASTEqualityExpression e = acu.findDescendantsOfType(ASTEqualityExpression.class).get(0);        ASTMethodDeclaration method = e.getFirstParentOfType(ASTMethodDeclaration.class);        Scope s = method.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        assertEquals(2, m.size());        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            NameDeclaration vnd = entry.getKey();            List<NameOccurrence> usages = entry.getValue();            if (vnd.getImage().equals("a") || vnd.getImage().equals("b")) {                assertEquals(1, usages.size());                assertEquals(3, usages.get(0).getLocation().getBeginLine());            } else {                fail("Unknown variable " + vnd);            }        }    }    @Test    public void testFieldFinder() {        ASTCompilationUnit acu = parseCode(TEST_FIELD);        // System.out.println(TEST_FIELD);        ASTVariableDeclaratorId declaration = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(1);        assertEquals(3, declaration.getBeginLine());        assertEquals("bbbbbbbbbb", declaration.getImage());        assertEquals(1, declaration.getUsages().size());        NameOccurrence no = declaration.getUsages().get(0);        Node location = no.getLocation();        assertEquals(6, location.getBeginLine());        // System.out.println("variable " + declaration.getImage() + " is used        // here: " + location.getImage());    }    @Test    public void testDemo() {        ASTCompilationUnit acu = parseCode(TEST_DEMO);        // System.out.println(TEST_DEMO);        ASTMethodDeclaration node = acu.findDescendantsOfType(ASTMethodDeclaration.class).get(0);        Scope s = node.getScope();        Map<NameDeclaration, List<NameOccurrence>> m = s.getDeclarations();        for (Map.Entry<NameDeclaration, List<NameOccurrence>> entry : m.entrySet()) {            assertEquals("buz", entry.getKey().getImage());            assertEquals("ArrayList", ((TypedNameDeclaration) entry.getKey()).getTypeImage());            List<NameOccurrence> u = entry.getValue();            assertEquals(1, u.size());            NameOccurrence o = u.get(0);            int beginLine = o.getLocation().getBeginLine();            assertEquals(3, beginLine);            // System.out.println("Variable: " + d.getImage());            // System.out.println("Type: " + d.getTypeImage());            // System.out.println("Usages: " + u.size());            // System.out.println("Used in line " + beginLine);        }    }    @Test    public void testEnum() {        ASTCompilationUnit acu = parseCode(NameOccurrencesTest.TEST_ENUM);        ASTVariableDeclaratorId vdi = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        List<NameOccurrence> usages = vdi.getUsages();        assertEquals(2, usages.size());        assertEquals(5, usages.get(0).getLocation().getBeginLine());        assertEquals(9, usages.get(1).getLocation().getBeginLine());    }    @Test    public void testInnerOuterClass() {        ASTCompilationUnit acu = parseCode(TEST_INNER_CLASS);        ASTVariableDeclaratorId vdi = acu.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class).get(1) // get inner class                .getFirstDescendantOfType(ASTVariableDeclaratorId.class); // get first declaration        List<NameOccurrence> usages = vdi.getUsages();        assertEquals(2, usages.size());        assertEquals(5, usages.get(0).getLocation().getBeginLine());        assertEquals(10, usages.get(1).getLocation().getBeginLine());    }    /**     * Unit test for bug #1490     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1490/">#1490 [java] PMD     *      Error while processing - NullPointerException</a>     */    @Test    public void testNullPointerEnumValueOfOverloaded() {        ASTCompilationUnit acu = parseCode("public enum EsmDcVoltageSensor {\n" + "    A;\n" + "    void bar(int ... args) {\n"                + "        int idx;\n" + "        int startIdx;\n"                + "        String name = EsmDcVoltageSensor.valueOf((byte) (idx - startIdx)).getName();\n" + "    }\n"                // that's the overloaded method                + "    public EsmDCVoltageSensor valueOf(byte b) {\n"                + "    }\n" + "}\n");    }    private static final String TEST_DEMO = "public class Foo  {" + PMD.EOL + " void bar(ArrayList buz) { " + PMD.EOL            + "  buz.add(\"foo\");" + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_EQ = "public class Foo  {" + PMD.EOL + " boolean foo(String a, String b) { "            + PMD.EOL + "  return a == b; " + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST1 = "import java.io.*;" + PMD.EOL + "public class Foo  {" + PMD.EOL            + " void buz( ) {" + PMD.EOL + "  Object o = new Serializable() { int x; };" + PMD.EOL            + "  Object o1 = new Serializable() { int x; };" + PMD.EOL + " }" + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_INITIALIZERS = "public class Foo  {" + PMD.EOL + " {} " + PMD.EOL + " static {} "            + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_CATCH_BLOCKS = "public class Foo  {" + PMD.EOL + " void foo() { " + PMD.EOL            + "  try { " + PMD.EOL + "  } catch (Exception e) { " + PMD.EOL + "   e.printStackTrace(); " + PMD.EOL            + "  } " + PMD.EOL + " } " + PMD.EOL + "}" + PMD.EOL;    private static final String TEST_FIELD = "public class MyClass {" + PMD.EOL + " private int aaaaaaaaaa; " + PMD.EOL            + " boolean bbbbbbbbbb = MyClass.ASCENDING; " + PMD.EOL + " private int zzzzzzzzzz;" + PMD.EOL            + " private void doIt() {" + PMD.EOL + "  if (bbbbbbbbbb) {" + PMD.EOL + "  }" + PMD.EOL + " }" + PMD.EOL            + "}" + PMD.EOL;    public static final String TEST_INNER_CLASS = "public class Outer {" + PMD.EOL + "  private static class Inner {"            + PMD.EOL + "    private int i;" + PMD.EOL + "    private Inner(int i) {" + PMD.EOL + "      this.i = i;"            + PMD.EOL + "    }" + PMD.EOL + "  }" + PMD.EOL + "  public int modify(int i) {" + PMD.EOL            + "    Inner in = new Inner(i);" + PMD.EOL + "    return in.i;" + PMD.EOL + "  }" + PMD.EOL + "}" + PMD.EOL;    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(AcceptanceTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.symboltable;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.ast.InternalApiBridge;import net.sourceforge.pmd.lang.symboltable.ImageFinderFunction;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;@Ignorepublic class ImageFinderFunctionTest {    @Test    public void testSingleImage() {        ImageFinderFunction f = new ImageFinderFunction("foo");        // These tests were completely broken, they built a PrimaryPrefix        // that is a child of a Name (not the reverse)        // This is an example of why tests should never build nodes manually        ASTVariableDeclaratorId node = InternalApiBridge.newVarId("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.test(decl);        assertEquals(decl, f.getDecl());    }    @Test    public void testSeveralImages() {        List<String> imgs = new ArrayList<>();        imgs.add("Foo.foo");        imgs.add("foo");        ImageFinderFunction f = new ImageFinderFunction(imgs);        ASTVariableDeclaratorId node = InternalApiBridge.newVarId("foo");        NameDeclaration decl = new VariableNameDeclaration(node);        f.test(decl);        assertEquals(decl, f.getDecl());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ImageFinderFunctionTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class HardCodedCryptoKeyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class InsecureCryptoIvTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MissingSerialVersionUIDTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryCaseChangeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class OverrideBothEqualsAndHashcodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidLiteralsInIfConditionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryConversionTemporaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class FinalizeShouldBeProtectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidCallingFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CallSuperFirstTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MisplacedNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class StringBufferInstantiationWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CloneMethodMustBePublicTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptySwitchStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseLocaleWithCaseConversionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseEqualsToCompareStringsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DontImportSunTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class FinalizeOnlyCallsSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidCatchingThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AssignmentInOperandTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DoNotTerminateVMTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CloneMethodMustImplementCloneableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TestClassWithoutTestCasesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ReturnEmptyArrayRatherThanNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class BadComparisonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class JumbledIncrementerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DoNotHardCodeSDCardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AssignmentToNonFinalStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitStaticSuiteTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseCorrectExceptionLoggingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class JUnitSpellingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class FinalizeOverloadedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MoreThanOneLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class StaticEJBFieldShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DetachedTestCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SuspiciousEqualsMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseProperClassLoaderTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DoNotCallGarbageCollectionExplicitlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EqualsNullTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DoNotExtendJavaLangThrowableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class NonStaticInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CloneThrowsCloneNotSupportedExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class BrokenNullCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ClassCastExceptionWithToArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SimpleDateFormatNeedsLocaleTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidEnumAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class InvalidLogMessageFormatTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class FinalizeDoesNotCallSuperFinalizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ReturnFromFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ProperCloneImplementationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CloseResourceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidDuplicateLiteralsTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CallSuperLastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ImportFromSamePackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CloneMethodReturnTypeMustMatchClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyFinalizerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidAssertAsIdentifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class IdempotentOperationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyTryBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CompareObjectsWithEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DoNotThrowExceptionInFinallyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SingleMethodSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class BeanMembersShouldSerializeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnconditionalIfStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class NonCaseLabelInSwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ProperLoggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidLosingExceptionInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MissingStaticMethodInNonInstantiatableClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidInstanceofChecksInCatchClauseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class NullAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidBranchingStatementAsLastInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidMultipleUnaryOperatorsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDecimalLiteralsInBigDecimalConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidFieldNameMatchingMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnusedNullCheckInEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DontUseFloatTypeForLoopIndicesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptySynchronizedBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CheckSkipResultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidUsingOctalValuesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class InstantiationToGetClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidFieldNameMatchingTypeNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementNotInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessOperationOnImmutableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidCatchingNPETest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SuspiciousOctalEscapeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SingletonClassReturningNewInstanceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SuspiciousHashcodeMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MissingBreakInSwitchTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ConstructorCallsOverridableMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ExcessiveImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SignatureDeclareThrowsExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidThrowingNullPointerExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AbstractClassWithoutAnyMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseObjectForClearerAPITest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ExceptionAsFlowControlTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SwitchDensityTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidUncheckedExceptionsInSignaturesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ExcessiveMethodLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UselessOverridingMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SimplifiedTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ClassWithOnlyPrivateConstructorsShouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class GodClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CyclomaticComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class TooManyMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DoNotExtendJavaLangErrorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CouplingBetweenObjectsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseUtilityClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidRethrowingExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ImmutableFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidThrowingRawExceptionTypesTest extends PmdRuleTst {    public static class Throwable extends java.lang.Throwable {        private static final long serialVersionUID = 1798165250043760600L;    }    public static class Exception extends java.lang.Throwable {        private static final long serialVersionUID = -2518308549741147689L;    }    public static class RuntimeException extends java.lang.Throwable {        private static final long serialVersionUID = 6341520923058239682L;    }    public static class Error extends java.lang.Throwable {        private static final long serialVersionUID = -6965602141393320558L;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DataClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SimplifyConditionalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class FinalFieldCouldBeStaticTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class NPathComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SingularFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SimplifyBooleanReturnsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidCatchingGenericExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class LawOfDemeterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class LogicInversionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyBooleanExpressionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class NcssCountTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SimplifyBooleanAssertionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidThrowingNewInstanceOfSameExceptionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CollapsibleIfStatementsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class LoosePackageCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AppendCharacterWithCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingShortTypeTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseIOStreamsWithApacheCommonsFileItemTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class OptimizableToArrayCallTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseArrayListInsteadOfVectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidFileStreamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class BigIntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ConsecutiveAppendsShouldReuseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidCalendarDateCreationTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidArrayLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SimplifyStartsWithTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AddEmptyStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidInstantiatingObjectsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ByteInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessStringValueOfTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ConsecutiveLiteralAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringToStringTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RedundantFieldInitializerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseArraysAsListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class InefficientStringBufferingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class InefficientEmptyStringCheckTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooFewBranchesForASwitchStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IntegerInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LongInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseIndexOfCharTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class InsufficientStringBufferDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class BooleanInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryWrapperObjectCreationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class StringInstantiationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseStringBufferLengthTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseStringBufferForStringAppendsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentRequiredTest extends PmdRuleTst {    @Test    public void allCommentTypesIgnored() {        CommentRequiredRule rule = new CommentRequiredRule();        assertNull("By default, the rule should be functional", rule.dysfunctionReason());        List<PropertyDescriptor<?>> propertyDescriptors = getProperties(rule);        // remove  deprecated properties        propertyDescriptors.removeIf(property -> property.description().startsWith("Deprecated!"));        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Ignored");        }        assertNotNull("All properties are ignored, rule should be dysfunctional", rule.dysfunctionReason());        // now, try out combinations: only one of the properties is required.        for (PropertyDescriptor<?> property : propertyDescriptors) {            setPropertyValue(rule, property, "Required");            assertNull("The property " + property.name() + " is set to required, the rule should be functional.",                rule.dysfunctionReason());            setPropertyValue(rule, property, "Ignored");        }    }    private static List<PropertyDescriptor<?>> getProperties(Rule rule) {        List<PropertyDescriptor<?>> result = new ArrayList<>();        for (PropertyDescriptor<?> property : rule.getPropertyDescriptors()) {            if (property != Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR                    && property != Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR) {                result.add(property);            }        }        return result;    }    private static <T> void setPropertyValue(Rule rule, PropertyDescriptor<T> property, String value) {        rule.setProperty(property, property.valueFrom(value));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentSizeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CommentContentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UncommentedEmptyMethodBodyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UncommentedEmptyConstructorTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryfullyqualifiedname;@org.junit.Ignore("Rule has not been updated yet")public class TestClass {    protected class SomeInnerClass {        public void alsoDoSomething() {            System.out.println("alsoDoSomething");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MDBAndSessionBeanNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalHomeNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ControlStatementBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyStaticImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CommentDefaultAccessModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class OnlyOneReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDollarSignsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class PrematureDeclarationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingNativeCodeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DefaultPackageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExtendsObjectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CallSuperInConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopShouldBeWhileLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseDiamondOperatorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryFullyQualifiedNameTest extends PmdRuleTst {    // Do not delete these two enums - it is needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1436 UnnecessaryFullyQualifiedName false positive on clashing static    // imports with enums    public enum ENUM1 {        A, B;    }    public enum ENUM2 {        C, D;    }    // Do not delete these classes - it is needed for a test case    // see: /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/UnnecessaryFullyQualifiedName.xml    // #1546 part 1 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    // #1546 part 2 UnnecessaryFullyQualifiedName doesn't take into consideration conflict resolution    public static class PhonyMockito {        public static final int TWO = 2;        public static <T> T mock(Class<T> clazz) {            return null;        }    }    public static class PhonyPowerMockito {        public static <T> T mock(Class<T> clazz) {            return null;        }    }    public static class MockitoInherited extends PhonyMockito {        // static method PhonyMockito::mock is static imported        // if MockitoInherited is imported on demand    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class FieldDeclarationsShouldBeAtStartOfClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryAnnotationValueElementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortClassNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseShortArrayInitializerTest extends PmdRuleTst {  // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RemoteInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessQualifiedThisTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class IdenticalCatchBranchesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class DuplicateImportsTest extends PmdRuleTst {    /**     * This is just for testing DuplicateImports for static imports and     * disambiguation.     */    // Do not delete this method, its needed for a test case    // see:    // /pmd-java/src/test/resources/net/sourceforge/pmd/lang/java/rule/codestyle/xml/DuplicateImports.xml    // #1306 False positive on duplicate when using static imports    public static void assertTrue(String message, boolean condition) {        if (!condition) {            System.out.println(message);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import org.junit.Test;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.function.Executable;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTExpression;import net.sourceforge.pmd.lang.java.rule.codestyle.UselessParenthesesRule.Necessity;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UselessParenthesesTest extends PmdRuleTst {    Executable testImpl(String expression, Necessity necessity) {        return () -> {            String file = "class Foo {{ int a,b,c,d; float f1, f2, f3; String s; Object e = " + expression + ";}}";            ASTCompilationUnit acu = JavaParsingHelper.WITH_PROCESSING.parse(file);            ASTExpression paren = acu.descendants(ASTExpression.class).crossFindBoundaries().first(ASTExpression::isParenthesized);            Assertions.assertNotNull(paren, "No parenthesized expression in " + expression);            UselessParenthesesRule.Necessity result = UselessParenthesesRule.needsParentheses(paren, paren.getParent());            Assertions.assertEquals(necessity, result, "In " + expression);        };    }    Executable clarifying(String expression) {        return testImpl(expression, Necessity.CLARIFYING);    }    Executable balancing(String expression) {        return testImpl(expression, Necessity.BALANCING);    }    Executable necessary(String expression) {        return testImpl(expression, Necessity.ALWAYS);    }    Executable unnecessary(String expression) {        return testImpl(expression, Necessity.NEVER);    }    @Test    public void testOuterLambdas() {        Assertions.assertAll(            unnecessary("() -> (a + b)"),            unnecessary("() -> (() -> b)"),            unnecessary("() -> (a ? b : c)"), // clarifying?            necessary("a ? () -> (a ? b : c) : d")        );    }    @Test    public void testInnerLambda() {        Assertions.assertAll(            necessary("(() -> 1) + 2"),            unnecessary("((() -> 1)) + 2"),            necessary("(() -> 1) * 2"),            // necessary("(() -> 1) = 2"), (impossible)            unnecessary("a = (() -> 1)")        );    }    @Test    public void testAssignments() {        //  (a = b) = c          (impossible)        Assertions.assertAll(            necessary("a * (b = c)"),            unnecessary("a * ((b = c))"),            necessary("a ? (b = c) : d"),            unnecessary("a = (b = c)")        );    }    @Test    public void testConditionals() {        Assertions.assertAll(            unnecessary("a ? b : (c ? d : e)"),            necessary("a ? (b ? c : d) : e"),            unnecessary("a ? ((b ? c : d)) : e"),            necessary("(a ? b : c) ? d : e"),            clarifying("(a == b) ? c : d"),            unnecessary("(s.toString()) ? c : d")        );    }    @Test    public void testAdditiveMul() {        // remember, a,b,c,d are ints        // fp1,2,3 are floats        Assertions.assertAll(            unnecessary("a + (b + c)"),            unnecessary("a + (b - c)"),            clarifying("a + (b * c)"),            unnecessary("(a + b) + c"),            unnecessary("(f1 + f1) + f2"),            unnecessary("(a + b) - c"),            necessary("(a + b) * c"),            necessary("(a + b) / c"),            necessary("x / (a + d)"),            // those mix floating-point operations            necessary("a + (f1 + b)"),            necessary("a + (f1 - b)"),            necessary("a + (b + f1)"),            necessary("a + (b - f1)"),            necessary("f1 + (f1 + b)"),            necessary("f1 + (f1 - b)"),            necessary("f1 + (b + f1)"),            necessary("f1 + (b - f1)")        );    }    @Test    public void testMultiplicative() {        Assertions.assertAll(            unnecessary("(a * b) * c"),            unnecessary("a * (b * c)"),            necessary("a * (b / c)"),            necessary("a * (b % c)"),            necessary("a / (b * c)"),            necessary("a / (b / c)"),            necessary("a / (b % c)"),            necessary("a % (b * c)"),            necessary("a % (b / c)"),            necessary("a % (b % c)")        );    }    @Test    public void testConcatenation() {        Assertions.assertAll(            necessary("\"\" + (1 + 4)"),            unnecessary("\"\" + (\"\" + 4)"),            unnecessary("\"\" + (4 + \"\")"),            clarifying("(1 + 4) + \"\"")        );    }    @Test    public void testEquality() {        Assertions.assertAll(            necessary("a == null == (b == null)"),            unnecessary("a == null == ((b == null))"),            balancing("(a == null) == (b == null)"),            unnecessary("(a == true) == b == true"),            // the same with some !=            necessary("a == null != (b == null)"),            unnecessary("a == null != ((b == null))"),            balancing("(a == null) == (b != null)"),            unnecessary("(a != true) == b == true")        );    }    @Test    public void testRelational() {        Assertions.assertAll(            clarifying("a <= b == (b <= c)"),            clarifying("(a <= b) == (b <= c)"),            necessary("(a == b) >= 0"),            clarifying("(a + b) >= 0")        );    }    @Test    public void testUnaries() {        Assertions.assertAll(            unnecessary("(String) ((String) c)"),            unnecessary("(String) (+1)"),            unnecessary("a + +((char) 1)"),            unnecessary("a + ~((char) 1)"),            clarifying("a + ((char) 1)"),            clarifying("a * ((char) 1)"),            clarifying("((char) 1) * a"),            unnecessary("-(-1)"),            unnecessary("-(+1)")        );    }    @Test    public void testSwitches() {        Assertions.assertAll(            unnecessary(" a + (switch (1) { })"),            unnecessary("(switch (1) { }) + 1")        );    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidProtectedFieldInFinalClassTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryCastTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidProtectedMethodInFinalClassNotExtendingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyMethodInAbstractClassShouldBeAbstractTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class GenericsNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LongVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class LocalVariableCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PackageCaseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontImportJavaLangTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AtLeastOneConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseUnderscoresInNumericLiteralsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalInterfaceSessionNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class RemoteSessionInterfaceNamingConventionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class LinguisticNamingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnnecessaryLocalBeforeReturnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConfusingTernaryTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class BooleanGetMethodNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnnecessaryConstructorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ShortVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MethodArgumentCouldBeFinalTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoubleBraceInitializationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AbstractClassWithoutAbstractMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseVarargsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedAssignmentTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitUseExpectedTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ForLoopCanBeForeachTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertNullInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class JUnit4TestShouldUseAfterAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MissingOverrideTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnusedPrivateMethodTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertSameInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertEqualsInsteadOfAssertTrueTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ReplaceVectorWithListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DefaultLabelNotLastInSwitchStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidReassigningCatchVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidMessageDigestFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopVariableCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnusedFormalParameterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AccessorMethodGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class CheckResultSetTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConstantsInInterfaceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ReplaceEnumerationWithIteratorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class JUnit4TestShouldUseTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidStringBufferFieldTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ReplaceHashtableWithMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidReassigningLoopVariablesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnusedImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UseTryWithResourcesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class LooseCouplingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidReassigningParametersTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class PreserveStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopWithLiteralBooleanTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class SystemPrintlnTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LiteralsFirstInComparisonsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnusedPrivateFieldTest extends PmdRuleTst {    /**     * This test will fail, as soon Lombok classes are on the test classpath.     * The test classpath is used as auxclasspath during unit tests.     * If lombok is present, then the test case for #1952 will never fail     * and won't reproduce the false-negative case anymore.     */    @Test    public void makeSureLombokIsNotOnClasspath() {        try {            Class.forName("lombok.Value");            Assert.fail();        } catch (ClassNotFoundException e) {            // this is ok        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class AvoidUsingHardCodedIPTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class ArrayIsStoredDirectlyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitTestsShouldIncludeAssertTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseAssertTrueInsteadOfAssertEqualsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseCollectionIsEmptyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JUnitTestContainsTooManyAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class JUnit4SuitesShouldUseSuiteAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class GuardLogStatementTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class JUnit4TestShouldUseBeforeAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AccessorClassGenerationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidPrintStackTraceTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class MethodReturnsInternalArrayTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class SwitchStmtsShouldHaveDefaultTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseConcurrentHashMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class UnsynchronizedStaticFormatterTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;@org.junit.Ignore("Rule has not been updated yet")public class NonThreadSafeSingletonTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidUsingVolatileTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontCallThreadRunTest extends PmdRuleTst {    // Used by DontCallThreadRun test cases    public static class TestThread extends Thread {        @Override        public void run() {            System.out.println("test");        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoubleCheckedLockingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSynchronizedAtMethodLevelTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidThreadGroupTest extends PmdRuleTst {    // Used by AvoidThreadGroup test cases    public static class ThreadGroup {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UseNotifyAllInsteadOfNotifyTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.multithreading;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DoNotUseThreadsTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.junit.Assert.assertEquals;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException.Phase;/** * @author Clment Fournier * @since 7.0.0 */public class MatchesSignatureXPathTest extends BaseXPathFunctionTest {    @Test    public void testMatchSig1() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('_#equals(java.lang.Object)')]");        assertFinds(rule, 1, "class O { { this.equals(\"\"); } }");        assertFinds(rule, 0, "class O { { this.equals(\"\", 2); }  void equals(String i, int a) {}}");    }    @Test    public void testMatchSigWithReceiver() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('java.lang.Enum#equals(java.lang.Object)')]");        assertFinds(rule, 1, "enum O {; { this.equals(\"\"); } }");        assertFinds(rule, 0, "enum O {; { \"\".equals(\"\"); } }");    }    @Test    public void testMatchSigUnresolved() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('java.lang.String#foobar()')]");        assertFinds(rule, 0, "enum O {; { \"\".foobar(); } }");    }    @Test    public void testMatchSigNoName() {        Rule rule = makeXpathRuleFromXPath("//MethodCall[pmd-java:matchesSig('_#_(int,int)')]");        assertFinds(rule, 2, "enum O {; { \"\".substring(1, 2); this.foo(1, 'c');} void foo(int a, int b) {} }");    }    @Test    public void testMatchSigWrongTypeReturnsFalse() {        Rule rule = makeXpathRuleFromXPath("//EnumDeclaration[pmd-java:matchesSig('_#_(int,int)')]");        assertFinds(rule, 0, "enum O {; { \"\".substring(1, 2); this.foo(1, 'c');} void foo(int a, int b) {} }");    }    @Test    public void testMatchInvalidSig() {        Rule rule = makeXpathRuleFromXPath("//*[pmd-java:matchesSig('_#')]");        PmdXPathException e = Assert.assertThrows(PmdXPathException.class, rule::getTargetSelector);        assertEquals(Phase.INITIALIZATION, e.getPhase());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.Test;import net.sourceforge.pmd.Rule;/** * @author Clment Fournier * @since 6.0.0 */public class XPathMetricFunctionTest extends BaseXPathFunctionTest {    @Test    public void testWellFormedClassMetricRule() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:metric('NCSS') > 0]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    public void testWellFormedOperationMetricRule() {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[pmd-java:metric('CYCLO') > 1]");        String code = "class Goo { Goo() {if(true){}} }";        assertFinds(rule, 1, code);    }    @Test    public void testBadCase() {        Rule rule = makeXpathRuleFromXPath("//ConstructorDeclaration[pmd-java:metric('cYclo') > 1]");        String code = "class Hoo { Hoo() {if(true){}} }";        assertFinds(rule, 1, code);    }    @Test    public void testNonexistentMetric() {        testWithExpectedException(            "//ConstructorDeclaration[pmd-java:metric('FOOBAR') > 1]",            "class Joo { Joo() {if(true){}} }",            e -> assertThat(e.getMessage(), containsString(MetricFunction.badOperationMetricKeyMessage("FOOBAR"))));    }    @Test    public void testWrongNodeTypeGeneric() {        testWithExpectedException(            "//IfStatement[pmd-java:metric('NCSS') > 1]",            "class Koo { Koo() {if(true){}} }",            e -> assertThat(e.getMessage(), containsString(MetricFunction.genericBadNodeMessage())));    }    @Test    public void testWrongMetricKeyForTypeDeclaration() {        testWithExpectedException(            "//EnumDeclaration[pmd-java:metric('CYCLO') > 1]",            "enum Loo { FOO; }",            e -> assertThat(e.getMessage(), containsString(MetricFunction.badClassMetricKeyMessage("CYCLO"))));    }    @Test    public void testWrongMetricKeyForOperationDeclaration() {        testWithExpectedException(            "//MethodDeclaration[pmd-java:metric('WMC') > 1]",            "class Moo { void foo() {if(true){}} }",            e -> assertThat(e.getMessage(), containsString(MetricFunction.badOperationMetricKeyMessage("WMC"))));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import org.junit.Test;import net.sourceforge.pmd.Rule;/** * @author Clment Fournier * @since 7.0.0 */public class TypeIsFunctionTest extends BaseXPathFunctionTest {    @Test    public void testHasAnnotation() {        Rule rule = makeXpathRuleFromXPath("//Annotation[pmd-java:typeIs('java.lang.Override')]");        assertFinds(rule, 1, "interface O { @Override void foo(); }");    }    @Test    public void testHasAnnotationNonQual() {        Rule rule = makeXpathRuleFromXPath("//Annotation[pmd-java:typeIs('Override')]");        //does not match        assertFinds(rule, 0, "interface O { @Override void foo(); }");    }    @Test    public void testTypeIsArray() {        Rule rule = makeXpathRuleFromXPath("//*[pmd-java:typeIs('int[]')]");        // ArrayType + VariableDeclaratorId        assertFinds(rule, 2, "class K { int[] i; }");    }    @Test    public void testWrongTypeReturnsFalse() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceBody[pmd-java:typeIs('java.lang.Override')]");        assertFinds(rule, 0, "interface O { @Override void foo(); }");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import org.junit.Test;import net.sourceforge.pmd.Rule;/** * @author Clment Fournier * @since 7.0.0 */public class HasAnnotationXPathTest extends BaseXPathFunctionTest {    @Test    public void testHasAnnotation() {        Rule rule = makeXpathRuleFromXPath("//MethodDeclaration[pmd-java:hasAnnotation('java.lang.Override')]");        String code = "interface O { @Override void foo(); }";        assertFinds(rule, 1, code);    }    @Test    public void testHasAnnotationNonQual() {        Rule rule = makeXpathRuleFromXPath("//MethodDeclaration[pmd-java:hasAnnotation('Override')]");        String code = "interface O { @Override void foo(); }";        //does not match        assertFinds(rule, 0, code);    }    @Test    public void testWrongTypeReturnsFalse() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceBody[pmd-java:hasAnnotation('java.lang.Override')]");        String code = "interface O { @Override void foo(); }";        assertFinds(rule, 0, code);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException.Phase;/** * @author Clment Fournier * @since 7.0.0 */public class GetModifiersFunctionsTest extends BaseXPathFunctionTest {    @Test    public void testEffectiveModifiers() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:modifiers() = ('public', 'abstract')]");        String code = "interface O { class Foo { } }";        assertFinds(rule, 2, code);    }    @Test    public void testExplicitModifiers() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:explicitModifiers() = ('public', 'abstract')]");        String code = "interface O { class Foo { } }";        assertFinds(rule, 0, code);    }    @Test    public void testNotAccessNodeReturnsEmptySequence() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceBody[pmd-java:modifiers()]");        String code = "interface O { class Foo { } }";        assertFinds(rule, 0, code);    }    @Test    public void testStaticTypeError() {        testWithExpectedException(            "//MethodDeclaration[(., .) is pmd-java:modifiers()]",            "class Moo { void foo() {if(true){}} }",            e -> {                assertThat(e.getMessage(), containsString("Type error"));                assertThat(e.getPhase(), equalTo(Phase.INITIALIZATION));            });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import java.util.function.Consumer;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Assert;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;/** * @author Clment Fournier * @since 7.0.0 */public class BaseXPathFunctionTest extends BaseNonParserTest {    private static final String VIOLATION_MESSAGE = "violation";    private static final String RULE_NAME_PLACEHOLDER = "$rule_name";    private @NonNull Report executeRule(Rule rule, String code) {        return java.executeRule(rule, code);    }    protected Rule makeXpathRuleFromXPath(String xpath) {        XPathRule rule = new XPathRule(XPathVersion.DEFAULT, xpath);        rule.setName("$rule_name");        rule.setMessage(VIOLATION_MESSAGE);        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        return rule;    }    protected void assertFinds(Rule rule, int numViolations, String code) {        Report report = executeRule(rule, code);        TestUtilsKt.assertSize(report, numViolations);    }    protected void testWithExpectedException(String xpath,                                             String code,                                             Consumer<? super PmdXPathException> exceptionSpec) {        Rule rule = makeXpathRuleFromXPath(xpath);        PmdXPathException thrown = Assert.assertThrows(PmdXPathException.class, () -> executeRule(rule, code));        exceptionSpec.accept(thrown);        assertThat(thrown.getRuleName(), equalTo(RULE_NAME_PLACEHOLDER));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule.xpath.internal;import static org.hamcrest.CoreMatchers.containsString;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.MatcherAssert.assertThat;import org.junit.Test;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException.Phase;/** * @author Clment Fournier * @since 7.0.0 */public class NodeIsFunctionTest extends BaseXPathFunctionTest {    @Test    public void testWellFormedNodeName() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:nodeIs('ClassOrInterfaceDeclaration')]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    public void testNodeNameStaticallyUnknown() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:nodeIs(name())]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    public void testWellFormedNodeNameForSupertype() {        Rule rule = makeXpathRuleFromXPath("//ClassOrInterfaceDeclaration[pmd-java:nodeIs('AnyTypeDeclaration')]");        String code = "class Foo { Foo() {} void bar() {}}";        assertFinds(rule, 1, code);    }    @Test    public void testNonExistentNodeName() {        // note that this would fail with a type error (boolean > integer)        // if nodeIs fails to fail        testWithExpectedException(            "//MethodDeclaration[pmd-java:nodeIs('ohio') > 1]",            "class Moo { void foo() {if(true){}} }",            e -> {                assertThat(e.getMessage(), containsString("ASTohio"));                assertThat(e.getPhase(), equalTo(Phase.INITIALIZATION));            });    }    @Test    public void testNonExistentNodeNameStaticallyUnknown() {        testWithExpectedException(            "//MethodDeclaration[pmd-java:nodeIs(name() || 'qqq')]",            "class Moo { void foo() {if(true){}} }",            e -> {                assertThat(e.getMessage(), containsString("MethodDeclarationqqq"));                assertThat(e.getPhase(), equalTo(Phase.EVALUATION));            });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.Assert.assertEquals;import java.util.HashMap;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.JavaNode;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.lang.rule.xpath.impl.XPathHandler;import net.sourceforge.pmd.lang.rule.xpath.internal.DeprecatedAttrLogger;import net.sourceforge.pmd.lang.rule.xpath.internal.SaxonXPathRuleQuery;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sourceforge.pmd.testframework.RuleTst;/** * @author daniels */public class XPathRuleTest extends RuleTst {    private XPathRule makeXPath(String expression) {        XPathRule rule = new XPathRule(XPathVersion.XPATH_2_0, expression);        rule.setLanguage(LanguageRegistry.getLanguage(JavaLanguageModule.NAME));        rule.setMessage("XPath Rule Failed");        return rule;    }    @Test    public void testPluginname() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[string-length(@Name) < 3]");        rule.setMessage("{0}");        Report report = getReportForTestString(rule, TEST1);        RuleViolation rv = report.getViolations().get(0);        assertEquals("a", rv.getDescription());    }    @Test    public void testXPathMultiProperty() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[@Name=$forbiddenNames]");        rule.setMessage("Avoid vars");        PropertyDescriptor<List<String>> varDescriptor            = PropertyFactory.stringListProperty("forbiddenNames")                             .desc("Forbidden names")                             .defaultValues("forbid1", "forbid2")                             .delim('$')                             .build();        rule.definePropertyDescriptor(varDescriptor);        Report report = getReportForTestString(rule, TEST3);        assertEquals(2, report.getViolations().size());    }    @Test    public void testVariables() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[@Name=$var]");        rule.setMessage("Avoid vars");        PropertyDescriptor<String> varDescriptor =            PropertyFactory.stringProperty("var").desc("Test var").defaultValue("").build();        rule.definePropertyDescriptor(varDescriptor);        rule.setProperty(varDescriptor, "fiddle");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.getViolations().get(0);        assertEquals(3, rv.getBeginLine());    }    @Test    public void testFnPrefixOnSaxon() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[fn:matches(@Name, 'fiddle')]");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.getViolations().get(0);        assertEquals(3, rv.getBeginLine());    }    @Test    public void testNoFnPrefixOnSaxon() throws Exception {        XPathRule rule = makeXPath("//VariableDeclaratorId[matches(@Name, 'fiddle')]");        Report report = getReportForTestString(rule, TEST2);        RuleViolation rv = report.getViolations().get(0);        assertEquals(3, rv.getBeginLine());    }    /**     * Following sibling check: See https://sourceforge.net/p/pmd/bugs/1209/     *     * @throws Exception any error     */    @Test    public void testFollowingSibling() throws Exception {        final String source = "public interface dummy extends Foo, Bar, Baz {}";        ASTCompilationUnit cu = JavaParsingHelper.WITH_PROCESSING.parse(source);        String xpath = "//ExtendsList/ClassOrInterfaceType/following-sibling::ClassOrInterfaceType";        SaxonXPathRuleQuery xpathRuleQuery = new SaxonXPathRuleQuery(xpath,                                                                     XPathVersion.DEFAULT,                                                                     new HashMap<>(),                                                                     XPathHandler.noFunctionDefinitions(),                                                                     DeprecatedAttrLogger.noop());        List<Node> nodes = xpathRuleQuery.evaluate(cu);        assertEquals(2, nodes.size());        assertEquals("Bar", ((JavaNode) nodes.get(0)).getText().toString());        assertEquals("Baz", ((JavaNode) nodes.get(1)).getText().toString());    }    private static Report getReportForTestString(Rule r, String test) {        return JavaParsingHelper.WITH_PROCESSING.executeRule(r, test);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " int a;" + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " int faddle;" + PMD.EOL + " int fiddle;"            + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " int forbid1; int forbid2; int forbid1$forbid2;" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.rule;import static org.junit.Assert.assertEquals;import java.util.List;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;import net.sourceforge.pmd.lang.java.ast.JavaNode;/** * @author Philip Graf */public class JavaRuleViolationTest {    // TODO there are no tests for anon or local classes    /**     * Verifies that {@link JavaRuleViolation} sets the variable name for an     * {@link ASTFormalParameter} node.     */    @Test    public void testASTFormalParameterVariableName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        final ASTFormalParameter node = ast.getFirstDescendantOfType(ASTFormalParameter.class);        final RuleViolation violation = violationAt(node);        assertEquals("x", violation.getVariableName());    }    private ASTCompilationUnit parse(final String code) {        return JavaParsingHelper.WITH_PROCESSING.parse(code);    }    /**     * Tests that the method name is taken correctly from the given node.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1250/">#1250</a>     */    @Test    public void testMethodName() {        ASTCompilationUnit ast = parse("class Foo { void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        assertEquals("bar", violationAt(md).getMethodName());    }    @NonNull    public RuleViolation violationAt(JavaNode md) {        return new JavaRuleViolation(new FooRule(), md, "", "");    }    /**     * Tests that the enum name is taken correctly from the given node.     */    @Test    public void testEnumName() {        ASTCompilationUnit ast = parse("enum Foo {FOO; void bar(int x) {} }");        ASTMethodDeclaration md = ast.getFirstDescendantOfType(ASTMethodDeclaration.class);        assertEquals("Foo", violationAt(md).getClassName());    }    /**     * Tests that the class name is taken correctly, even if the node is outside     * of a class scope, e.g. a import declaration.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1529/">#1529</a>     */    @Test    public void testPackageAndClassNameForImport() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndClassNameForField() {        ASTCompilationUnit ast = parse("package pkg; public class Foo { int a; }");        ASTClassOrInterfaceDeclaration classDeclaration = ast.getFirstDescendantOfType(ASTClassOrInterfaceDeclaration.class);        ASTFieldDeclaration field = ast.getFirstDescendantOfType(ASTFieldDeclaration.class);        RuleViolation violation = violationAt(classDeclaration);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());        violation = violationAt(field);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndEnumName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; public enum FooE { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("FooE", violation.getClassName());    }    @Test    public void testDefaultPackageAndClassName() {        ASTCompilationUnit ast = parse("import java.util.List; public class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    @Test    public void testPackageAndMultipleClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { } public class Bar { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("Bar", violation.getClassName());    }    @Test    public void testPackageAndPackagePrivateClassesName() {        ASTCompilationUnit ast = parse("package pkg; import java.util.List; class Foo { }");        ASTImportDeclaration importNode = ast.getFirstDescendantOfType(ASTImportDeclaration.class);        RuleViolation violation = violationAt(importNode);        assertEquals("pkg", violation.getPackageName());        assertEquals("Foo", violation.getClassName());    }    /**     * Test that the name of the inner class is taken correctly.     * Also check fields.     */    @Test    public void testInnerClass() {        ASTCompilationUnit ast = parse("class Foo { int a; class Bar { int a; } }");        List<ASTClassOrInterfaceDeclaration> classes = ast.findDescendantsOfType(ASTClassOrInterfaceDeclaration.class);        assertEquals(2, classes.size());        RuleViolation fooViolation = violationAt(classes.get(0));        assertEquals("Foo", fooViolation.getClassName());        RuleViolation barViolation = violationAt(classes.get(1));        assertEquals("Foo$Bar", barViolation.getClassName());        List<ASTFieldDeclaration> fields = ast.findDescendantsOfType(ASTFieldDeclaration.class, true);        assertEquals(2, fields.size());        RuleViolation fieldViolation = violationAt(fields.get(0));        assertEquals("Foo", fieldViolation.getClassName());        RuleViolation innerFieldViolation = violationAt(fields.get(1));        assertEquals("Foo$Bar", innerFieldViolation.getClassName());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.ArrayList;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * Tests new java14 preview features. */public class Java14PreviewTest {    private final JavaParsingHelper java14 =        JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("14")                                         .withResourceContext(getClass(), "jdkversiontests/java14/");    private final JavaParsingHelper java14p = java14.withDefaultVersion("14-preview");    private final JavaParsingHelper java13 = java14.withDefaultVersion("13");    @Test    public void textBlocks() {        ASTCompilationUnit compilationUnit = java14p.parseResource("TextBlocks.java");        List<ASTStringLiteral> literals = compilationUnit.findDescendantsOfType(ASTStringLiteral.class);        Assert.assertEquals(22, literals.size());        Assert.assertFalse(literals.get(2).isTextBlock());        Assert.assertFalse(literals.get(12).isTextBlock());        Assert.assertFalse(literals.get(17).isTextBlock());        Assert.assertFalse(literals.get(18).isTextBlock());        Assert.assertFalse(literals.get(20).isTextBlock());        Assert.assertFalse(literals.get(21).isTextBlock());        List<ASTStringLiteral> textBlocks = new ArrayList<>();        for (ASTStringLiteral literal : literals) {            if (literal.isTextBlock()) {                textBlocks.add(literal);            }        }        Assert.assertEquals(16, textBlocks.size());        Assert.assertEquals("\"\"\"\n"                                + "                      <html>   \n"                                + "                          <body>\n"                                + "                              <p>Hello, world</p>    \n"                                + "                          </body> \n"                                + "                      </html>   \n"                                + "                      \"\"\"",                            textBlocks.get(0).getImage());        Assert.assertEquals("<html>\n"                          + "    <body>\n"                          + "        <p>Hello, world</p>\n"                          + "    </body>\n"                          + "</html>\n", textBlocks.get(0).getConstValue());        // Note: More tests are in ASTLiteralTest.    }    @Test(expected = ParseException.class)    public void textBlocksBeforeJava14PreviewShouldFail() {        java13.parseResource("TextBlocks.java");    }    @Test(expected = ParseException.class)    public void stringEscapeSequenceShouldFail() {        java14.parse("class Foo { String s =\"a\\sb\"; }");    }    @Test    public void recordPoint() {        ASTCompilationUnit compilationUnit = java14p.parseResource("Point.java");        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);        Assert.assertEquals("Point", recordDecl.getImage());        Assert.assertFalse(recordDecl.isNested());        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)                                                        .findChildrenOfType(ASTRecordComponent.class);        Assert.assertEquals(2, components.size());        Assert.assertEquals("x", components.get(0).getVarId().getImage());        Assert.assertEquals("y", components.get(1).getVarId().getImage());        // TODO: type resolution for record components        // Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());        // Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());        // Assert.assertEquals("int", components.get(0).getVarId().getNameDeclaration().getTypeImage());    }    @Test(expected = ParseException.class)    public void recordPointBeforeJava14PreviewShouldFail() {        java14.parseResource("Point.java");    }    @Test(expected = ParseException.class)    public void recordCtorWithThrowsShouldFail() {        java14p.parse("  record R {"                          + "   R throws IOException {}"                          + "  }");    }    @Test    public void innerRecords() {        ASTCompilationUnit compilationUnit = java14p.parseResource("Records.java");        List<ASTRecordDeclaration> recordDecls = compilationUnit.findDescendantsOfType(ASTRecordDeclaration.class, true);        Assert.assertEquals(7, recordDecls.size());        ASTRecordDeclaration complex = recordDecls.get(0);        Assert.assertEquals("MyComplex", complex.getSimpleName());        Assert.assertTrue(complex.isNested());        Assert.assertEquals(0, getComponent(complex, 0).getDeclaredAnnotations().count());        Assert.assertEquals(1, getComponent(complex, 1).getDeclaredAnnotations().count());        Assert.assertEquals(2, complex.getDeclarations().count());        Assert.assertTrue(complex.getDeclarations().get(0) instanceof ASTConstructorDeclaration);        Assert.assertTrue(complex.getDeclarations().get(1) instanceof ASTRecordDeclaration);        ASTRecordDeclaration nested = recordDecls.get(1);        Assert.assertEquals("Nested", nested.getSimpleName());        Assert.assertTrue(nested.isNested());        ASTRecordDeclaration range = recordDecls.get(2);        Assert.assertEquals("Range", range.getSimpleName());        Assert.assertEquals(2, range.getRecordComponents().size());        List<ASTRecordConstructorDeclaration> rangeConstructors = range.findDescendantsOfType(ASTRecordConstructorDeclaration.class);        Assert.assertEquals(1, rangeConstructors.size());        Assert.assertEquals("Range", rangeConstructors.get(0).getImage());        JavaNode mods = rangeConstructors.get(0).getChild(0);        Assert.assertTrue(mods instanceof ASTModifierList);        Assert.assertEquals(1, mods.getNumChildren());        Assert.assertEquals(2, range.getDeclarations().count());        ASTRecordDeclaration varRec = recordDecls.get(3);        Assert.assertEquals("VarRec", varRec.getSimpleName());        Assert.assertEquals("x", getComponent(varRec, 0).getVarId().getImage());        Assert.assertTrue(getComponent(varRec, 0).isVarargs());        Assert.assertEquals(2, getComponent(varRec, 0).getDeclaredAnnotations().count());        Assert.assertEquals(1, getComponent(varRec, 0).getTypeNode().descendants(ASTAnnotation.class).count());        ASTRecordDeclaration arrayRec = recordDecls.get(4);        Assert.assertEquals("ArrayRec", arrayRec.getSimpleName());        Assert.assertEquals("x", getComponent(arrayRec, 0).getVarId().getImage());        Assert.assertTrue(getComponent(arrayRec, 0).getVarId().hasArrayType());        ASTRecordDeclaration emptyRec = recordDecls.get(5);        Assert.assertEquals("EmptyRec", emptyRec.getSimpleName());        Assert.assertEquals(0, emptyRec.getRecordComponents().size());        ASTRecordDeclaration personRec = recordDecls.get(6);        Assert.assertEquals("PersonRecord", personRec.getSimpleName());        ASTImplementsList impl = personRec.getFirstChildOfType(ASTImplementsList.class);        Assert.assertEquals(2, impl.findChildrenOfType(ASTClassOrInterfaceType.class).size());    }    private ASTRecordComponent getComponent(ASTRecordDeclaration arrayRec, int index) {        return arrayRec.getRecordComponents().getChild(index);    }    @Test(expected = ParseException.class)    public void recordIsARestrictedIdentifier() {        java14p.parse("public class record {}");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;public class ASTImportDeclarationTest extends BaseParserTest {    @Test    public void testImportOnDemand() {        List<ASTImportDeclaration> ops = java.getNodes(ASTImportDeclaration.class, TEST1);        assertTrue(ops.get(0).isImportOnDemand());    }    @Test    public void testGetImportedNameNode() {        ASTImportDeclaration i = java.getNodes(ASTImportDeclaration.class, TEST2).get(0);        assertEquals("foo.bar.Baz", i.getImportedName());    }    @Test    public void testStaticImport() {        List<ASTImportDeclaration> ops = java.getNodes(ASTImportDeclaration.class, TEST3);        ASTImportDeclaration i = ops.get(0);        assertTrue(i.isStatic());    }    @Test(expected = ParseException.class)    public void testStaticImportFailsWithJDK14() {        java.parse(TEST3, "1.4");    }    private static final String TEST1 = "import foo.bar.*;\npublic class Foo {}";    private static final String TEST2 = "import foo.bar.Baz;\npublic class Foo {}";    private static final String TEST3 = "import static foo.bar.Baz;\npublic class Foo {}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Test;public class ASTVariableDeclaratorIdTest extends BaseParserTest {    @Test    public void testIsExceptionBlockParameter() {        ASTCompilationUnit acu = java.parse(EXCEPTION_PARAMETER);        ASTVariableDeclaratorId id = acu.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertTrue(id.isExceptionBlockParameter());    }    @Test    public void testTypeNameNode() {        ASTCompilationUnit acu = java.parse(TYPE_NAME_NODE);        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNameNode();        assertEquals("String", name.getSimpleName());    }    @Test    public void testAnnotations() {        ASTCompilationUnit acu = java.parse(TEST_ANNOTATIONS);        ASTVariableDeclaratorId id = acu.findDescendantsOfType(ASTVariableDeclaratorId.class).get(0);        ASTClassOrInterfaceType name = (ASTClassOrInterfaceType) id.getTypeNode();        assertEquals("String", name.getSimpleName());    }    @Test    public void testLambdaWithType() throws Exception {        ASTCompilationUnit acu = java8.parse(TEST_LAMBDA_WITH_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertEquals("File", f.getTypeNode().getTypeImage());    }    @Test    public void testLambdaWithoutType() throws Exception {        ASTCompilationUnit acu = java8.parse(TEST_LAMBDA_WITHOUT_TYPE);        ASTLambdaExpression lambda = acu.getFirstDescendantOfType(ASTLambdaExpression.class);        ASTVariableDeclaratorId f = lambda.getFirstDescendantOfType(ASTVariableDeclaratorId.class);        assertNull(f.getTypeNode());    }    private static final String TYPE_NAME_NODE = "public class Test {\n  private String bar;\n}";    private static final String EXCEPTION_PARAMETER = "public class Test { { try {} catch(Exception ie) {} } }";    private static final String TEST_ANNOTATIONS = "public class Foo {\n    public void bar(@A1 @A2 String s) {}\n}";    private static final String TEST_LAMBDA_WITH_TYPE =        "public class Foo {\n    public void bar() {\n        FileFilter java = (File f) -> f.getName().endsWith(\".java\");\n    }\n}\n";    private static final String TEST_LAMBDA_WITHOUT_TYPE =        "public class Foo {\n    public void bar() {\n        FileFilter java2 = f -> f.getName().endsWith(\".java\");\n    }\n}\n";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ASTVariableDeclaratorIdTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTModuleDeclarationTest extends BaseParserTest {    @Test    public final void jdk9ModuleInfo() {        ASTCompilationUnit ast = java9.parseResource("jdkversiontests/jdk9_module_info.java");        List<ASTModuleDeclaration> modules = ast.findDescendantsOfType(ASTModuleDeclaration.class);        assertEquals(1, modules.size());        ASTModuleDeclaration module = modules.get(0);        assertTrue(module.isOpen());        assertEquals("com.example.foo", module.getImage());        assertEquals(7, module.getNumChildren());        List<ASTModuleDirective> directives = module.findChildrenOfType(ASTModuleDirective.class);        assertEquals(7, directives.size());        // requires com.example.foo.http;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(0).getType());        assertNull(directives.get(0).getRequiresModifier());        assertEquals("com.example.foo.http", directives.get(0).getFirstChildOfType(ASTModuleName.class).getImage());        // requires java.logging;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(1).getType());        assertNull(directives.get(1).getRequiresModifier());        assertEquals("java.logging", directives.get(1).getFirstChildOfType(ASTModuleName.class).getImage());        // requires transitive com.example.foo.network;        assertEquals(ASTModuleDirective.DirectiveType.REQUIRES.name(), directives.get(2).getType());        assertEquals(ASTModuleDirective.RequiresModifier.TRANSITIVE.name(), directives.get(2).getRequiresModifier());        assertEquals("com.example.foo.network", directives.get(2).getFirstChildOfType(ASTModuleName.class).getImage());        // exports com.example.foo.bar;        assertEquals(ASTModuleDirective.DirectiveType.EXPORTS.name(), directives.get(3).getType());        assertNull(directives.get(3).getRequiresModifier());        assertEquals("com.example.foo.bar", directives.get(3).getFirstChildOfType(ASTName.class).getImage());        // exports com.example.foo.internal to com.example.foo.probe;        assertEquals(ASTModuleDirective.DirectiveType.EXPORTS.name(), directives.get(4).getType());        assertNull(directives.get(4).getRequiresModifier());        assertEquals("com.example.foo.internal", directives.get(4).getFirstChildOfType(ASTName.class).getImage());        assertEquals("com.example.foo.probe", directives.get(4).getFirstChildOfType(ASTModuleName.class).getImage());        // uses com.example.foo.spi.Intf;        assertEquals(ASTModuleDirective.DirectiveType.USES.name(), directives.get(5).getType());        assertNull(directives.get(5).getRequiresModifier());        assertEquals("com.example.foo.spi.Intf", directives.get(5).getFirstChildOfType(ASTName.class).getImage());        // provides com.example.foo.spi.Intf with com.example.foo.Impl;        assertEquals(ASTModuleDirective.DirectiveType.PROVIDES.name(), directives.get(6).getType());        assertNull(directives.get(6).getRequiresModifier());        assertEquals("com.example.foo.spi.Intf", directives.get(6).getFirstChildOfType(ASTName.class).getImage());        assertEquals("com.example.foo.Impl", directives.get(6).findChildrenOfType(ASTName.class).get(1).getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.List;import java.util.Map;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Assert;import org.junit.Ignore;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.TokenMgrError;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.symboltable.NameDeclaration;import net.sourceforge.pmd.lang.symboltable.NameOccurrence;public class ParserCornersTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java = JavaParsingHelper.WITH_PROCESSING.withResourceContext(getClass());    private final JavaParsingHelper java4 = java.withDefaultVersion("1.4");    private final JavaParsingHelper java7 = java.withDefaultVersion("1.7");    private final JavaParsingHelper java8 = java.withDefaultVersion("1.8");    private final JavaParsingHelper java5 = java.withDefaultVersion("1.7");    @Rule    public ExpectedException expect = ExpectedException.none();    @Override    public @NonNull BaseParsingHelper<?, ?> getParser() {        return java4;    }    @Test    public void testInvalidUnicodeEscape() {        expect.expect(TokenMgrError.class); // previously Error        expect.expectMessage("Lexical error at line 1, column 2.  Encountered: Invalid unicode escape");        java.parse("\\u00k0");    }    /**     * #1107 PMD 5.0.4 couldn't parse call of parent outer java class method     * from inner class.     */    @Test    public void testInnerOuterClass() {        java7.parse("/**\n" + " * @author azagorulko\n" + " *\n" + " */\n"                        + "public class TestInnerClassCallsOuterParent {\n" + "\n" + "    public void test() {\n"                        + "        new Runnable() {\n" + "            @Override\n" + "            public void run() {\n"                        + "                TestInnerClassCallsOuterParent.super.toString();\n" + "            }\n"                        + "        };\n" + "    }\n" + "}\n");    }    /**     * #888 PMD 6.0.0 can't parse valid <> under 1.8.     */    @Test    public void testDiamondUsageJava8() {        java8.parse("public class PMDExceptionTest {\n"                        + "  private Component makeUI() {\n"                        + "    String[] model = {\"123456\", \"7890\"};\n"                        + "    JComboBox<String> comboBox = new JComboBox<>(model);\n"                        + "    comboBox.setEditable(true);\n"                        + "    comboBox.setEditor(new BasicComboBoxEditor() {\n"                        + "      private Component editorComponent;\n"                        + "      @Override public Component getEditorComponent() {\n"                        + "        if (editorComponent == null) {\n"                        + "          JTextField tc = (JTextField) super.getEditorComponent();\n"                        + "          editorComponent = new JLayer<>(tc, new ValidationLayerUI<>());\n"                        + "        }\n"                        + "        return editorComponent;\n"                        + "      }\n"                        + "    });\n"                        + "    JPanel p = new JPanel();\n"                        + "    p.add(comboBox);\n"                        + "    return p;\n"                        + "  }\n"                        + "}");    }    @Test    public final void testGetFirstASTNameImageNull() {        java4.parse(ABSTRACT_METHOD_LEVEL_CLASS_DECL);    }    @Test    public final void testCastLookaheadProblem() {        java4.parse(CAST_LOOKAHEAD_PROBLEM);    }    /**     * Tests a specific generic notation for calling methods. See:     * https://jira.codehaus.org/browse/MPMD-139     */    @Test    public void testGenericsProblem() {        java5.parse(GENERICS_PROBLEM);        java7.parse(GENERICS_PROBLEM);    }    @Test    public void testParsersCases15() {        doTest("ParserCornerCases", java5);    }    @Test    public void testParsersCases17() {        doTest("ParserCornerCases17", java7);    }    @Test    public void testParsersCases18() {        doTest("ParserCornerCases18", java8);    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1333/     */    @Test    public void testLambdaBug1333() {        doTest("LambdaBug1333", java8);    }    @Test    public void testLambdaBug1470() {        doTest("LambdaBug1470", java8);    }    /**     * Test for https://sourceforge.net/p/pmd/bugs/1355/     */    @Test    public void emptyFileJustComment() {        getParser().parse("// just a comment");    }    @Test    public void testBug1429ParseError() {        doTest("Bug1429", java8);    }    @Test    public void testBug1530ParseError() {        doTest("Bug1530", java8);    }    @Test    public void testGitHubBug207() {        doTest("GitHubBug207", java8);    }    @Test    public void testLambda2783() {        java8.parseResource("LambdaBug2783.java");    }    @Test    public void testGitHubBug2767() {        // PMD fails to parse an initializer block.        // PMD 6.26.0 parses this code just fine.        java.withDefaultVersion("15-preview")            .parse("class Foo {\n"                       + "    {final int I;}\n"                       + "}\n");    }    @Test    public void testBug206() {        doTest("LambdaBug206", java8);    }    @Test    public void testGitHubBug208ParseError() {        doTest("GitHubBug208", java5);    }    @Test    public void testGitHubBug309() {        doTest("GitHubBug309", java8);    }    /**     * Empty statements should be allowed.     *     * @see <a href="https://github.com/pmd/pmd/issues/378">github issue 378</a>     */    @Test    public void testEmptyStatements1() {        doTest("EmptyStmts1");    }    @Test    public void testEmptyStatements2() {        doTest("EmptyStmts2");    }    @Test    public void testEmptyStatements3() {        doTest("EmptyStmts3");    }    @Test    @Ignore("this test depends on usage resolution")    public void testMethodReferenceConfused() {        ASTCompilationUnit compilationUnit = java.parseResource("MethodReferenceConfused.java", "10");        Assert.assertNotNull(compilationUnit);        ASTBlock firstBlock = compilationUnit.getFirstDescendantOfType(ASTBlock.class);        Map<NameDeclaration, List<NameOccurrence>> declarations = firstBlock.getScope().getDeclarations();        boolean foundVariable = false;        for (Map.Entry<NameDeclaration, List<NameOccurrence>> declaration : declarations.entrySet()) {            String varName = declaration.getKey().getImage();            if ("someVarNameSameAsMethodReference".equals(varName)) {                foundVariable = true;                Assert.assertTrue("no usages expected", declaration.getValue().isEmpty());            } else if ("someObject".equals(varName)) {                Assert.assertEquals("1 usage expected", 1, declaration.getValue().size());                Assert.assertEquals(6, declaration.getValue().get(0).getLocation().getBeginLine());            }        }        Assert.assertTrue("Test setup wrong - variable 'someVarNameSameAsMethodReference' not found anymore!", foundVariable);    }    @Test    public void testSwitchWithFallthrough() {        doTest("SwitchWithFallthrough");    }    @Test    public void testSwitchStatements() {        doTest("SwitchStatements");    }    @Test    public void testSynchronizedStatements() {        doTest("SynchronizedStmts");    }    private static final String GENERICS_PROBLEM =        "public class Test {\n public void test() {\n   String o = super.<String> doStuff(\"\");\n }\n}";    private static final String ABSTRACT_METHOD_LEVEL_CLASS_DECL =        "public class Test {\n"            + "  void bar() {\n"            + "   abstract class X { public abstract void f(); }\n"            + "   class Y extends X { public void f() { new Y().f(); } }\n"            + "  }\n"            + "}";    private static final String CAST_LOOKAHEAD_PROBLEM =        "public class BadClass {\n  public Class foo() {\n    return (byte[].class);\n  }\n}";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.List;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java15PreviewTreeDumpTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java15p =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("15-preview")                    .withResourceContext(Java15PreviewTreeDumpTest.class, "jdkversiontests/java15p/");    private final JavaParsingHelper java15 = java15p.withDefaultVersion("15");    @Override    public BaseParsingHelper<?, ?> getParser() {        return java15p;    }    @Test    public void patternMatchingInstanceof() {        doTest("PatternMatchingInstanceof");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java15p.parseResource("PatternMatchingInstanceof.java");        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);        for (ASTInstanceOfExpression expr : instanceOfExpressions) {            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);            Assert.assertEquals(String.class, variable.getType());            // Note: these variables are not part of the symbol table            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)            Assert.assertNull(variable.getNameDeclaration());        }    }    @Test(expected = ParseException.class)    public void patternMatchingInstanceofBeforeJava15PreviewShouldFail() {        java15.parseResource("PatternMatchingInstanceof.java");    }    @Test    @Ignore("Ignored, this will be reactivated on the typeresolution branch")    public void recordPoint() {        doTest("Point");        // extended tests for type resolution etc.        ASTCompilationUnit compilationUnit = java15p.parseResource("Point.java");        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);        List<ASTRecordComponent> components = recordDecl.getRecordComponents().toList();        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());        Assert.assertEquals("int", components.get(0).getVarId().getNameDeclaration().getTypeImage());    }    @Test(expected = ParseException.class)    public void recordPointBeforeJava15PreviewShouldFail() {        java15.parseResource("Point.java");    }    @Test(expected = ParseException.class)    public void recordCtorWithThrowsShouldFail() {        java15p.parse("  record R {"                + "   R throws IOException {}"                + "  }");    }    @Test(expected = ParseException.class)    public void recordMustNotExtend() {        java15p.parse("record RecordEx(int x) extends Number { }");    }    @Test    public void innerRecords() {        doTest("Records");    }    @Test(expected = ParseException.class)    public void recordIsARestrictedIdentifier() {        java15p.parse("public class record {}");    }    @Test    public void localRecords() {        doTest("LocalRecords");    }    @Test(expected = ParseException.class)    public void sealedClassBeforeJava15Preview() {        java15.parseResource("geometry/Shape.java");    }    @Test    public void sealedClass() {        doTest("geometry/Shape");    }    @Test    public void nonSealedClass() {        doTest("geometry/Square");    }    @Test(expected = ParseException.class)    public void sealedInterfaceBeforeJava15Preview() {        java15.parseResource("expression/Expr.java");    }    @Test    public void sealedInterface() {        doTest("expression/Expr");    }    @Test    public void localInterfaceAndEnums() {        doTest("LocalInterfacesAndEnums");    }    @Test(expected = ParseException.class)    public void localInterfacesAndEnumsBeforeJava15PreviewShouldFail() {        java15.parseResource("LocalInterfacesAndEnums.java");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Assert;import org.junit.Test;public class ASTSwitchStatementTest extends BaseParserTest {    @Test    public void exhaustiveEnumSwitchWithDefault() {        ASTSwitchStatement switchStatement = getNodes(ASTSwitchStatement.class,                "import java.nio.file.AccessMode; class Foo { void bar(AccessMode m) {"                + "switch (m) { case READ: break; default: break; } } }")                .get(0);        Assert.assertFalse(switchStatement.isExhaustiveEnumSwitch()); // this should not throw a NPE...        Assert.assertTrue(switchStatement.hasDefaultCase());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;public class ASTInitializerTest extends BaseParserTest {    @Test    public void testDontCrashOnBlockStatement() {        java.parse(TEST1);    }    private static final String TEST1 = "public class Foo {\n {\n   x = 5;\n }\n}";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.instanceOf;import static org.junit.Assert.assertEquals;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class CommentAssignmentTest extends BaseNonParserTest {    /**     * Blank lines in comments should not raise an exception. See bug #1048.     */    @Test    public void testFilteredCommentIn() {        ASTCompilationUnit node = java.parse("public class Foo {\n"                                                 + "     /* multi line comment with blank lines\n\n\n */\n"                                                 + "        /** a formal comment with blank lines\n\n\n */"                                                 + "}");        Comment comment = node.getComments().get(0);        assertThat(comment, instanceOf(MultiLineComment.class));        assertEquals("multi line comment with blank lines", comment.getFilteredComment());        comment = node.getComments().get(1);        assertThat(comment, instanceOf(FormalComment.class));        assertEquals("a formal comment with blank lines", comment.getFilteredComment());    }    @Test    public void testCommentAssignments() {        ASTCompilationUnit node = java.parse("public class Foo {\n"                                                 + "     /** Comment 1 */\n"                                                 + "        public void method1() {}\n"                                                 + "    \n"                                                 + "        /** Comment 2 */\n"                                                 + "    \n"                                                 + "        /** Comment 3 */\n"                                                 + "        public void method2() {}" + "}");        List<ASTMethodDeclaration> methods = node.findDescendantsOfType(ASTMethodDeclaration.class);        assertCommentEquals(methods.get(0), "/** Comment 1 */");        assertCommentEquals(methods.get(1), "/** Comment 3 */");    }    @Test    public void testCommentAssignmentsWithAnnotation() {        ASTCompilationUnit node = java.parse("public class Foo {\n"                                                 + "     /** Comment 1 */\n"                                                 + "        @Oha public void method1() {}\n"                                                 + "    \n"                                                 + "        /** Comment 2 */\n"                                                 + "    @Oha\n"                                                 // note that since this is the first token, the prev comment gets selected                                                 + "        /** Comment 3 */\n"                                                 + "        public void method2() {}" + "}");        List<ASTMethodDeclaration> methods = node.findDescendantsOfType(ASTMethodDeclaration.class);        assertCommentEquals(methods.get(0), "/** Comment 1 */");        assertCommentEquals(methods.get(1), "/** Comment 2 */");    }    @Test    public void testCommentAssignmentOnPackage() {        ASTCompilationUnit node = java.parse("/** Comment 1 */\n"                                                 + "package bar;\n");        assertCommentEquals(node.descendants(ASTPackageDeclaration.class).firstOrThrow(),                            "/** Comment 1 */");    }    @Test    public void testCommentAssignmentOnClass() {        ASTCompilationUnit node = java.parse("/** outer */\n"                                                 + "class Foo { "                                                 + " /** inner */ class Nested { } "                                                 + " { /** local */ class Local {}} "                                                 + " /** enum */enum NestedEnum {}"                                                 + "}");        List<ASTAnyTypeDeclaration> types = node.descendants(ASTAnyTypeDeclaration.class).toList();        assertCommentEquals(types.get(0), "/** outer */");        assertCommentEquals(types.get(1), "/** inner */");        assertCommentEquals(types.get(2), "/** local */");        assertCommentEquals(types.get(3), "/** enum */");    }    @Test    public void testCommentAssignmentOnEnum() {        ASTCompilationUnit node = java.parse("enum Foo { "                                                 + " /** A */ A,"                                                 + " /** B */ @Oha B,"                                                 + " C,"                                                 + " /* not javadoc */ D,"                                                 + "}");        List<ASTEnumConstant> constants = node.descendants(ASTEnumConstant.class).toList();        assertCommentEquals(constants.get(0), "/** A */");        assertCommentEquals(constants.get(1), "/** B */");        assertHasNoComment(constants.get(2));        assertHasNoComment(constants.get(3));    }    private void assertCommentEquals(JavadocCommentOwner pack, String expected) {        Assert.assertNotNull("null comment on " + pack, pack.getJavadocComment());        Assert.assertEquals(expected, pack.getJavadocComment().getText().toString());    }    private void assertHasNoComment(JavadocCommentOwner pack) {        Assert.assertNull("Expected null comment on " + pack, pack.getJavadocComment());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java8Test {    private final JavaParsingHelper java8 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("8")                                             .withResourceContext(Java8Test.class);    @Test    public void interfaceMethodShouldBeParseable() {        java8.parse("interface WithStaticAndDefaultMethod {\n"                        + "        static void performOn() {\n"                        + "        }\n"                        + "\n"                        + "        default void myToString() {\n"                        + "        }\n"                        + "    }\n");    }    @Test    public void repeatableAnnotationsMethodShouldBeParseable() {        java8.parse("@Multitude(\"1\")\n"                        + "@Multitude(\"2\")\n"                        + "@Multitude(\"3\")\n"                        + "@Multitude(\"4\")\n"                        + "public class UsesRepeatableAnnotations {\n"                        + "\n"                        + "    @Repeatable(Multitudes.class)\n"                        + "    @Retention(RetentionPolicy.RUNTIME)\n"                        + "    @interface Multitude {\n"                        + "        String value();\n"                        + "    }\n"                        + "\n"                        + "    @Retention(RetentionPolicy.RUNTIME)\n"                        + "    @interface Multitudes {\n"                        + "        Multitude[] value();\n"                        + "    }\n"                        + "\n"                        + "}");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class ASTPackageDeclarationTest extends BaseParserTest {    private static final String PACKAGE_INFO_ANNOTATED = "@Deprecated\npackage net.sourceforge.pmd.foobar;\n";    /**     * Regression test for bug 3524607.     */    @Test    public void testPackageName() {        ASTCompilationUnit nodes = java.parse(PACKAGE_INFO_ANNOTATED);        assertEquals("net.sourceforge.pmd.foobar", nodes.getPackageDeclaration().getName());        assertEquals("net.sourceforge.pmd.foobar", nodes.getPackageName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class EncodingTest extends BaseParserTest {    @Test    public void testDecodingOfUTF8() {        ASTCompilationUnit acu = java.parse(TEST_UTF8);        String methodName = acu.getFirstDescendantOfType(ASTMethodDeclaration.class).getImage();        assertEquals("", methodName);    }    private static final String TEST_UTF8 = "class Foo {\n  void () {}\n  void fiddle() {}\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.io.FileInputStream;import java.util.ArrayList;import java.util.List;import java.util.stream.Stream;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Test;import net.sourceforge.pmd.lang.java.JavaParsingHelper;import net.sourceforge.pmd.lang.java.types.JClassType;import net.sourceforge.pmd.lang.java.types.TypeSystem;import net.sourceforge.pmd.lang.java.types.TypeTestUtil;public class Java10Test {    private final JavaParsingHelper java10 =        JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("10")                                         .withResourceContext(Java10Test.class, "jdkversiontests/java10/");    private final JavaParsingHelper java9 = java10.withDefaultVersion("9");    @Test    public void testLocalVarInferenceBeforeJava10() {        // note, it can be parsed, but we'll have a ReferenceType of "var"        List<ASTLocalVariableDeclaration> localVars = java9.parseResource("LocalVariableTypeInference.java")                                                           .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        ASTVariableDeclaratorId varId = localVars.get(0).getVarIds().firstOrThrow();        // first: var list = new ArrayList<String>();        assertTrue(varId.getTypeNode() instanceof ASTClassOrInterfaceType);        // in that case, we don't have a class named "var", so the type will be null        assertTrue(varId.getTypeMirror().getSymbol().isUnresolved());        // check the type of the variable initializer's expression        ASTExpression initExpression = varId.getInitializer();        assertTrue("type should be ArrayList", TypeTestUtil.isA(ArrayList.class, initExpression));    }    @Test    public void testLocalVarInferenceCanBeParsedJava10() {        ASTCompilationUnit compilationUnit = java10.parseResource("LocalVariableTypeInference.java");        List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(3, localVars.size());        TypeSystem ts = compilationUnit.getTypeSystem();        JClassType stringT = (JClassType) ts.typeOf(ts.getClassSymbol(String.class), false);        // first: var list = new ArrayList<String>();        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();        assertEquals("type should be ArrayList<String>", ts.parameterise(ts.getClassSymbol(ArrayList.class), listOf(stringT)), varDecl.getTypeMirror());        // second: var stream = list.stream();        assertNull(localVars.get(1).getTypeNode());        ASTVariableDeclaratorId varDecl2 = localVars.get(1).getVarIds().firstOrThrow();        assertEquals("type should be Stream<String>",                     ts.parameterise(ts.getClassSymbol(Stream.class), listOf(stringT)),                     varDecl2.getTypeMirror());        // third: var s = "Java 10";        assertNull(localVars.get(2).getTypeNode());        ASTVariableDeclaratorId varDecl3 = localVars.get(2).getVarIds().firstOrThrow();        assertEquals("type should be String", stringT, varDecl3.getTypeMirror());    }    @Test    public void testForLoopWithVar() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoop.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();        assertSame("type should be int", varDecl.getTypeSystem().INT, varDecl.getTypeMirror());    }    @Test    public void testForLoopEnhancedWithVar() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoopEnhanced.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(1, localVars.size());        assertNull(localVars.get(0).getTypeNode());        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();        assertTrue("type should be String", TypeTestUtil.isA(String.class, varDecl));    }    @Test    public void testForLoopEnhancedWithVar2() {        List<ASTLocalVariableDeclaration> localVars = java10.parseResource("LocalVariableTypeInferenceForLoopEnhanced2.java")                                                            .findDescendantsOfType(ASTLocalVariableDeclaration.class);        assertEquals(4, localVars.size());        assertNull(localVars.get(1).getTypeNode());        @NonNull ASTVariableDeclaratorId varDecl2 = localVars.get(1).getVarIds().firstOrThrow();        assertTrue("type should be String", TypeTestUtil.isA(String.class, varDecl2));        assertNull(localVars.get(3).getTypeNode());        ASTVariableDeclaratorId varDecl4 = localVars.get(3).getVarIds().firstOrThrow();        assertSame("type should be int", varDecl2.getTypeSystem().INT, varDecl4.getTypeMirror());    }    @Test    public void testTryWithResourcesWithVar() {        List<ASTResource> resources = java10.parseResource("LocalVariableTypeInferenceTryWithResources.java")                                            .findDescendantsOfType(ASTResource.class);        assertEquals(1, resources.size());        assertNull(resources.get(0).asLocalVariableDeclaration().getTypeNode());        ASTVariableDeclaratorId varId = resources.get(0).asLocalVariableDeclaration().getVarIds().firstOrThrow();        assertTrue("type should be FileInputStream", TypeTestUtil.isA(FileInputStream.class, varId));    }    @Test    public void testTypeResNullPointer() {        java10.parseResource("LocalVariableTypeInference_typeres.java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class CommentTest extends BaseNonParserTest {    @Test    public void testMultiLinesInSingleLine() {        String comment = "/* single line. */";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInSingleLineSimple() {        String comment = "// single line.";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInSingleLineFormal() {        String comment = "/** single line. */";        String filtered = filter(comment);        Assert.assertEquals(1, lineCount(filtered));        Assert.assertEquals("single line.", filtered);    }    @Test    public void testMultiLinesInMultiLine() {        String comment =                  "/*\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineCrLf() {        String comment =                  "/*\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineFormal() {        String comment =                  "/**\n"                + " * line 1\n"                + " * line 2\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineFormalCrLf() {        String comment =                  "/**\r\n"                + " * line 1\r\n"                + " * line 2\r\n"                + " */\r\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    @Test    public void testMultiLinesInMultiLineNoAsteriskEmpty() {        String comment =                  "/**\n"                + " * line 1\n"                + "line 2\n"                + "\n"                + " */\n";        String filtered = filter(comment);        Assert.assertEquals(2, lineCount(filtered));        Assert.assertEquals("line 1" + PMD.EOL + "line 2", filtered);    }    private String filter(String comment) {        return java.parse(comment).getComments().get(0).getFilteredComment();    }    private int lineCount(String filtered) {        return StringUtils.countMatches(filtered, PMD.EOL) + 1;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTBooleanLiteralTest extends BaseParserTest {    @Test    public void testTrue() {        List<ASTBooleanLiteral> ops = java.getNodes(ASTBooleanLiteral.class, TEST1);        ASTBooleanLiteral b = ops.get(0);        assertTrue(b.isTrue());    }    @Test    public void testFalse() {        List<ASTBooleanLiteral> ops = java.getNodes(ASTBooleanLiteral.class, TEST2);        ASTBooleanLiteral b = ops.get(0);        assertFalse(b.isTrue());    }    private static final String TEST1 = "class Foo { \n boolean bar = true; \n} ";    private static final String TEST2 = "class Foo { \n boolean bar = false; \n} ";}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.hamcrest.Matchers.instanceOf;import java.util.ArrayList;import java.util.List;import org.hamcrest.MatcherAssert;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * Tests new java14 standard features. */@Ignore("Needs to be fixed for new AST structure. All of this is already much better tested in Kotlin, I don't want to port these tests...")public class Java14Test {    private final JavaParsingHelper java14 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("14")                                             .withResourceContext(Java14Test.class, "jdkversiontests/java14/");    private final JavaParsingHelper java14p = java14.withDefaultVersion("14-preview");    private final JavaParsingHelper java13 = java14.withDefaultVersion("13");    /**     * Tests switch expressions with yield.     */    @Test    public void switchExpressions() {        parseAndCheckSwitchExpression(java14);        parseAndCheckSwitchExpression(java14p);    }    /**     * In java13, switch expressions are only available with preview.     */    @Test(expected = ParseException.class)    public void switchExpressions13ShouldFail() {        parseAndCheckSwitchExpression(java13);    }    private void parseAndCheckSwitchExpression(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("SwitchExpressions.java");        List<ASTSwitchStatement> switchStatements = compilationUnit.findDescendantsOfType(ASTSwitchStatement.class);        Assert.assertEquals(2, switchStatements.size());        Assert.assertTrue(switchStatements.get(0).getChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatements.get(0).getChild(1) instanceof ASTSwitchArrowBranch);        Assert.assertTrue(switchStatements.get(0).getChild(1).getChild(0) instanceof ASTSwitchLabel);        Assert.assertEquals(3, switchStatements.get(0).getChild(1).getChild(0).getNumChildren());        Assert.assertTrue(switchStatements.get(0).getChild(2).getChild(0) instanceof ASTSwitchLabel);        Assert.assertFalse(((ASTSwitchLabel) switchStatements.get(0).getChild(2).getChild(0)).isDefault());        Assert.assertEquals(1, switchStatements.get(0).getChild(2).getChild(0).getNumChildren());        Assert.assertTrue(switchStatements.get(1).getChild(3) instanceof ASTSwitchArrowBranch);        Assert.assertTrue(switchStatements.get(1).getChild(3).getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(((ASTSwitchLabel) switchStatements.get(1).getChild(3).getChild(0)).isDefault());        List<ASTSwitchExpression> switchExpressions = compilationUnit.findDescendantsOfType(ASTSwitchExpression.class);        Assert.assertEquals(4, switchExpressions.size());        Assert.assertEquals(Integer.TYPE, switchExpressions.get(0).getType());        Assert.assertEquals(4, switchExpressions.get(0).findChildrenOfType(ASTSwitchArrowBranch.class).size());        Assert.assertEquals(Integer.TYPE, switchExpressions.get(0).getFirstChildOfType(ASTSwitchArrowBranch.class)                                                           .getFirstChildOfType(ASTExpression.class).getType());        Assert.assertTrue(switchExpressions.get(1).getChild(3) instanceof ASTSwitchArrowBranch);        Assert.assertEquals(Integer.TYPE, switchExpressions.get(2).getType());        List<ASTYieldStatement> yields = switchExpressions.get(2).findDescendantsOfType(ASTYieldStatement.class);        Assert.assertEquals(4, yields.size());        Assert.assertEquals("SwitchExpressions.BAZ", yields.get(2).getImage());        Assert.assertEquals(String.class, switchExpressions.get(3).getType());    }    @Test    public void checkYieldConditionalBehaviour() {        checkYieldStatements(java14);    }    private void checkYieldStatements(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("YieldStatements.java");        List<ASTBlockStatement> blockStmts = compilationUnit.findDescendantsOfType(ASTBlockStatement.class);        List<JavaNode> stmts = new ArrayList<>();        // fetch the interesting node, on the java-grammar branch this is not needed        for (int i = 0; i < blockStmts.size(); i++) {            JavaNode child = blockStmts.get(i).getChild(0);            if (child instanceof ASTStatement) {                stmts.add(child.getChild(0));            } else {                stmts.add(child);            }        }        Assert.assertEquals(18, stmts.size());        int i = 0;        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTLocalVariableDeclaration.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTIfStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTStatementExpression.class));        MatcherAssert.assertThat(stmts.get(i++), instanceOf(ASTYieldStatement.class));        Assert.assertEquals(i, stmts.size());    }    @Test    public void multipleCaseLabels() {        multipleCaseLabels(java14);        multipleCaseLabels(java14p);    }    private void multipleCaseLabels(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("MultipleCaseLabels.java");        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertTrue(switchStatement.getChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatement.getChild(1) instanceof ASTSwitchLabel);        ASTSwitchLabel switchLabel = switchStatement.getFirstChildOfType(ASTSwitchLabel.class);        Assert.assertEquals(3, switchLabel.findChildrenOfType(ASTExpression.class).size());    }    @Test    public void switchRules() {        switchRules(java14);        switchRules(java14p);    }    private void switchRules(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("SwitchRules.java");        ASTSwitchStatement switchStatement = compilationUnit.getFirstDescendantOfType(ASTSwitchStatement.class);        Assert.assertTrue(switchStatement.getChild(0) instanceof ASTExpression);        Assert.assertTrue(switchStatement.getChild(1) instanceof ASTSwitchArrowBranch);        ASTSwitchArrowBranch switchLabeledExpression = (ASTSwitchArrowBranch) switchStatement.getChild(1);        Assert.assertEquals(2, switchLabeledExpression.getNumChildren());        Assert.assertTrue(switchLabeledExpression.getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledExpression.getChild(1) instanceof ASTExpression);        ASTSwitchArrowBranch switchLabeledBlock = (ASTSwitchArrowBranch) switchStatement.getChild(4);        Assert.assertEquals(2, switchLabeledBlock.getNumChildren());        Assert.assertTrue(switchLabeledBlock.getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledBlock.getChild(1) instanceof ASTBlock);        ASTSwitchArrowBranch switchLabeledThrowStatement = (ASTSwitchArrowBranch) switchStatement.getChild(5);        Assert.assertEquals(2, switchLabeledThrowStatement.getNumChildren());        Assert.assertTrue(switchLabeledThrowStatement.getChild(0) instanceof ASTSwitchLabel);        Assert.assertTrue(switchLabeledThrowStatement.getChild(1) instanceof ASTThrowStatement);    }    @Test    public void simpleSwitchExpressions() {        simpleSwitchExpressions(java14);        simpleSwitchExpressions(java14p);    }    private void simpleSwitchExpressions(JavaParsingHelper parser) {        ASTCompilationUnit compilationUnit = parser.parseResource("SimpleSwitchExpressions.java");        ASTSwitchExpression switchExpression = compilationUnit.getFirstDescendantOfType(ASTSwitchExpression.class);        Assert.assertEquals(6, switchExpression.getNumChildren());        Assert.assertTrue(switchExpression.getChild(0) instanceof ASTExpression);        Assert.assertEquals(5, switchExpression.findChildrenOfType(ASTSwitchArrowBranch.class).size());        ASTLocalVariableDeclaration localVar = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class).get(1);        ASTVariableDeclarator localVarDecl = localVar.getFirstChildOfType(ASTVariableDeclarator.class);        Assert.assertEquals(Integer.TYPE, localVarDecl.getType());        Assert.assertEquals(Integer.TYPE, switchExpression.getType());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.impl.javacc.JavaccToken;public class FormalCommentTest extends BaseParserTest {    @Test    public void testJavadocTagsAsChildren() {        ASTCompilationUnit acu = java.parse(            "interface Metric {"                + "   /**\n"                + "     * Checks if the metric can be computed on the node.\n"                + "     *\n"                + "     * @param node The node to check\n"                + "     *\n"                + "     * @return True if the metric can be computed\n"                + "     */\n"                + "    boolean supports(N node);\n"                + "}");        ASTType booleanT = acu.descendants(ASTType.class).firstOrThrow();        JavaccToken firstToken = booleanT.getFirstToken();        assertEquals("Boolean", JavaTokenKinds.BOOLEAN, firstToken.kind);        JavaccToken comment = firstToken.getPreviousComment();        assertEquals("Implicit modifier list", JavaccToken.IMPLICIT_TOKEN, comment.kind);        comment = comment.getPreviousComment();        assertEquals("Whitespace", JavaTokenKinds.WHITESPACE, comment.kind);        assertEquals("\n    ", comment.getImage());        comment = comment.getPreviousComment();        assertEquals("Formal comment", JavaTokenKinds.FORMAL_COMMENT, comment.kind);        FormalComment commentNode = new FormalComment(comment);        Assert.assertEquals(2, commentNode.getNumChildren());        JavadocElement paramTag = (JavadocElement) commentNode.getChild(0);        Assert.assertEquals("param", paramTag.tag().label);        JavadocElement returnTag = (JavadocElement) commentNode.getChild(1);        Assert.assertEquals("return", returnTag.tag().label);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTSwitchLabelTest extends BaseParserTest {    @Test    public void testDefaultOff() {        List<ASTSwitchLabel> ops = java.getNodes(ASTSwitchLabel.class, TEST1);        assertFalse(ops.get(0).isDefault());    }    @Test    public void testDefaultSet() {        List<ASTSwitchLabel> ops = java.getNodes(ASTSwitchLabel.class, TEST2);        assertTrue(ops.get(0).isDefault());    }    private static final String TEST1 = "public class Foo {\n void bar() {\n  switch (x) {\n   case 1: y = 2;\n  }\n }\n}";    private static final String TEST2 = "public class Foo {\n void bar() {\n  switch (x) {\n   default: y = 2;\n  }\n }\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;public class TextBlockEscapeTest extends BaseParserTest {    @Test    public void testTextBlockContent() {        assertEquals("empty text block", "",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n                       \"\"\""));        assertEquals("single line text block", "winter",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n                winter\"\"\""));        assertEquals("single line text block with LF", "winter\n",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                              + "                        winter\n"                                                              + "                        \"\"\""));        assertEquals("basic text block example with html",                     "<html>\n"                         + "    <body>\n"                         + "        <p>Hello, world</p>\n"                         + "    </body>\n"                         + "</html>\n",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                              + "                      <html>   \n"                                                              + "                          <body>\n"                                                              + "                              <p>Hello, world</p>    \n"                                                              + "                          </body> \n"                                                              + "                      </html>   \n"                                                              + "                      \"\"\""));        assertEquals("text block with escapes",                     "<html>\r\n"                         + "    <body>\r\n"                         + "        <p>Hello, world</p>\r\n"                         + "    </body>\r\n"                         + "</html>\r\n",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                              + "                      <html>\\r\n"                                                              + "                          <body>\\r\n"                                                              + "                              <p>Hello, world</p>\\r\n"                                                              + "                          </body>\\r\n"                                                              + "                      </html>\\r\n"                                                              + "                      \"\"\""));        assertEquals("escaped text block in inside text block",                     "String text = \"\"\"\n"                         + "    A text block inside a text block\n"                         + "\"\"\";\n",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                              + "            String text = \\\"\"\"\n"                                                              + "                A text block inside a text block\n"                                                              + "            \\\"\"\";\n"                                                              + "            \"\"\""));        assertEquals("new escape: line continuation",                     "Lorem ipsum dolor sit amet, consectetur adipiscing "                         + "elit, sed do eiusmod tempor incididunt ut labore "                         + "et dolore magna aliqua.",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                              + "                      Lorem ipsum dolor sit amet, consectetur adipiscing \\\n"                                                              + "                      elit, sed do eiusmod tempor incididunt ut labore \\\n"                                                              + "                      et dolore magna aliqua.\\\n"                                                              + "                      \"\"\""));        assertEquals("new escape: space escape",                     "red   \n"                         + "green \n"                         + "blue  \n",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                              + "                        red  \\s\n"                                                              + "                        green\\s\n"                                                              + "                        blue \\s\n"                                                              + "                        \"\"\""));        assertEquals("with crlf line endings",                     "<html>\n"                         + "    <body>\n"                         + "        <p>Hello, world</p>\n"                         + "    </body>\n"                         + "</html>\n", ASTStringLiteral.determineTextBlockContent("\"\"\"\r\n"                                                                                 + "                      <html>   \r\n"                                                                                 + "                          <body>\r\n"                                                                                 + "                              <p>Hello, world</p>    \r\n"                                                                                 + "                          </body> \r\n"                                                                                 + "                      </html>   \r\n"                                                                                 + "                      \"\"\""));        assertEquals("with cr line endings",                     "<html>\n"                         + "    <body>\n"                         + "        <p>Hello, world</p>\n"                         + "    </body>\n"                         + "</html>\n", ASTStringLiteral.determineTextBlockContent("\"\"\"\r"                                                                                 + "                      <html>   \r"                                                                                 + "                          <body>\r"                                                                                 + "                              <p>Hello, world</p>    \r"                                                                                 + "                          </body> \r"                                                                                 + "                      </html>   \r"                                                                                 + "                      \"\"\""));        assertEquals("empty line directly after opening",                     "\ntest\n", ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                                          + "    \n"                                                                          + "    test\n"                                                                          + "    \"\"\""));        assertEquals("empty crlf line directly after opening",                     "\ntest\n", ASTStringLiteral.determineTextBlockContent("\"\"\"\r\n"                                                                          + "    \r\n"                                                                          + "    test\r\n"                                                                          + "    \"\"\""));        assertEquals("empty line directly after opening without indentation",                     "\ntest\n", ASTStringLiteral.determineTextBlockContent("\"\"\"\n"                                                                          + "\n"                                                                          + "test\n"                                                                          + "\"\"\""));        assertEquals("empty crlf line directly after opening without indentation",                     "\ntest\n", ASTStringLiteral.determineTextBlockContent("\"\"\"\r\n"                                                                          + "\r\n"                                                                          + "test\r\n"                                                                          + "\"\"\""));        assertEquals("text block with backslash escape", "\\test\n",                     ASTStringLiteral.determineTextBlockContent("\"\"\"\n                \\\\test\n                \"\"\""));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.java.BaseJavaTreeDumpTest;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class Java15TreeDumpTest extends BaseJavaTreeDumpTest {    private final JavaParsingHelper java15 =            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("15")                    .withResourceContext(Java15TreeDumpTest.class, "jdkversiontests/java15/");    private final JavaParsingHelper java15p = java15.withDefaultVersion("15-preview");    private final JavaParsingHelper java14 = java15.withDefaultVersion("14");    @Override    public BaseParsingHelper<?, ?> getParser() {        return java15;    }    @Test    public void textBlocks() {        doTest("TextBlocks");        java15p.parseResource("TextBlocks.java"); // make sure we can parse it with preview as well    }    @Test(expected = net.sourceforge.pmd.lang.ast.ParseException.class)    public void textBlocksBeforeJava15ShouldFail() {        java14.parseResource("TextBlocks.java");    }    @Test(expected = ParseException.class)    public void stringEscapeSequenceShouldFail() {        java14.parse("class Foo { String s =\"a\\sb\"; }");    }    @Test    public void sealedAndNonSealedIdentifiers() {        doTest("NonSealedIdentifier");        java15p.parseResource("NonSealedIdentifier.java"); // make sure we can parse it with preview as well    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;@Ignore("This test is Java specific even though parts of it should apply to any language implementation")// The Java specific parts depend on the grammar and are subject to breaking during the grammar update process// Most of it is just garbage thoughpublic class SimpleNodeTest extends BaseParserTest {    @Test    public void testMethodDiffLines() {        List<ASTMethodDeclaration> methods = java.getNodes(ASTMethodDeclaration.class, METHOD_DIFF_LINES);        verifyNode(methods.iterator().next(), 2, 9, 4, 3);    }    @Test    public void testMethodSameLine() {        List<ASTMethodDeclaration> methods = java.getNodes(ASTMethodDeclaration.class, METHOD_SAME_LINE);        verifyNode(methods.iterator().next(), 2, 9, 2, 22);    }    @Test    public void testNoLookahead() {        List<ASTClassOrInterfaceDeclaration> uCD = java.getNodes(ASTClassOrInterfaceDeclaration.class, NO_LOOKAHEAD);        verifyNode(uCD.iterator().next(), 1, 8, 1, 21);    }    @Test    public void testHasExplicitExtends() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, HAS_EXPLICIT_EXTENDS).iterator().next();        assertTrue(ucd.getChild(0) instanceof ASTExtendsList);    }    @Test    public void testNoExplicitExtends() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, NO_EXPLICIT_EXTENDS).iterator().next();        assertFalse(ucd.getChild(0) instanceof ASTExtendsList);    }    @Test    public void testHasExplicitImplements() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, HAS_EXPLICIT_IMPLEMENTS).iterator().next();        assertTrue(ucd.getChild(0) instanceof ASTImplementsList);    }    @Test    public void testNoExplicitImplements() {        ASTClassOrInterfaceDeclaration ucd = java.getNodes(ASTClassOrInterfaceDeclaration.class, NO_EXPLICIT_IMPLEMENTS).iterator().next();        assertFalse(ucd.getChild(0) instanceof ASTImplementsList);    }    @Test    public void testColumnsOnQualifiedName() {        for (Node node : java.getNodes(ASTName.class, QUALIFIED_NAME)) {            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 1, 20);            }        }    }    @Test    public void testLineNumbersForNameSplitOverTwoLines() {        for (Node node : java.getNodes(ASTName.class, BROKEN_LINE_IN_NAME)) {            if (node.getImage().equals("java.io.File")) {                verifyNode(node, 1, 8, 2, 5);            }            if (node.getImage().equals("Foo")) {                verifyNode(node, 2, 15, 2, 19);            }        }    }    //    @Test    //    public void testLineNumbersAreSetOnAllSiblings() {    //        for (ASTBlock b : java.getNodes(ASTBlock.class, LINE_NUMBERS_ON_SIBLINGS)) {    //            assertTrue(b.getBeginLine() > 0);    //        }    //        for (ASTVariableInitializer b : java.getNodes(ASTVariableInitializer.class, LINE_NUMBERS_ON_SIBLINGS)) {    //            assertTrue(b.getBeginLine() > 0);    //        }    //        for (ASTExpression b : java.getNodes(ASTExpression.class, LINE_NUMBERS_ON_SIBLINGS)) {    //            assertTrue(b.getBeginLine() > 0);    //        }    //    }    //    //    @Test    //    public void testFindDescendantsOfType() {    //        ASTBlock block = new ASTBlock(2);    //        block.addChild(new ASTReturnStatement(1), 0);    //        assertEquals(1, block.findDescendantsOfType(ASTReturnStatement.class).size());    //    }    //    //    @Test    //    public void testFindDescendantsOfTypeMultiple() {    //        ASTBlock block = new ASTBlock(1);    //        block.addChild(new ASTBlockStatement(2), 0);    //        block.addChild(new ASTBlockStatement(3), 1);    //        List<ASTBlockStatement> nodes = block.findDescendantsOfType(ASTBlockStatement.class);    //        assertEquals(2, nodes.size());    //    }    //    //    @Test    //    public void testFindDescendantsOfTypeRecurse() {    //        ASTBlock block = new ASTBlock(1);    //        ASTBlock childBlock = new ASTBlock(2);    //        block.addChild(childBlock, 0);    //        childBlock.addChild(new ASTMethodDeclaration(3), 0);    //        List<ASTMethodDeclaration> nodes = block.findDescendantsOfType(ASTMethodDeclaration.class);    //        assertEquals(1, nodes.size());    //    }    //    //    @Test    //    public void testGetFirstChild() {    //        ASTBlock block = new ASTBlock(1);    //        ASTStatement x = new ASTStatement(2);    //        block.addChild(x, 0);    //        block.addChild(new ASTStatement(3), 1);    //    //        Node n = block.getFirstDescendantOfType(ASTStatement.class);    //        assertNotNull(n);    //        assertTrue(n instanceof ASTStatement);    //        assertEquals(x, n);    //    }    //    //    @Test    //    public void testGetFirstChildNested() {    //        ASTBlock block = new ASTBlock(1);    //        ASTStatement x = new ASTStatement(2);    //        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);    //        x.addChild(x1, 0);    //        block.addChild(x, 0);    //        block.addChild(new ASTStatement(3), 1);    //    //        Node n = block.getFirstDescendantOfType(ASTAssignmentOperator.class);    //        assertNotNull(n);    //        assertTrue(n instanceof ASTAssignmentOperator);    //        assertEquals(x1, n);    //    }    //    //    @Test    //    public void testGetFirstChildNestedDeeper() {    //        ASTBlock block = new ASTBlock(1);    //        ASTStatement x = new ASTStatement(2);    //        ASTAssignmentOperator x1 = new ASTAssignmentOperator(4);    //        ASTName x2 = new ASTName(5);    //    //        x.addChild(x1, 0);    //        x1.addChild(x2, 0);    //        block.addChild(x, 0);    //        block.addChild(new ASTStatement(3), 1);    //    //        Node n = block.getFirstDescendantOfType(ASTName.class);    //        assertNotNull(n);    //        assertTrue(n instanceof ASTName);    //        assertEquals(x2, n);    //    }    @Test    public void testParentMethods() {        ASTCompilationUnit u = JavaParsingHelper.JUST_PARSE.parse(TEST1);        ASTMethodDeclarator d = u.getFirstDescendantOfType(ASTMethodDeclarator.class);        assertSame("getFirstParentOfType ASTMethodDeclaration", d.getParent(),                d.getFirstParentOfType(ASTMethodDeclaration.class));        assertNull("getFirstParentOfType ASTName", d.getFirstParentOfType(ASTName.class));        assertSame("getNthParent 1", d.getParent(), d.getNthParent(1));        assertSame("getNthParent 2", d.getParent().getParent(), d.getNthParent(2));        assertSame("getNthParent 6", u, d.getNthParent(6));        assertNull("getNthParent 7", d.getNthParent(7));        assertNull("getNthParent 8", d.getNthParent(8));    }    private static final String TEST1 = "public class Test {\n  void bar(String s) {\n   s = s.toLowerCase();\n  }\n}";    @Ignore    @Test    public void testContainsNoInner() {        ASTCompilationUnit c = java.getNodes(ASTCompilationUnit.class, CONTAINS_NO_INNER).iterator().next();        List<ASTFieldDeclaration> res = c.findDescendantsOfType(ASTFieldDeclaration.class);        assertTrue(res.isEmpty());        /*         * String expectedXml =         * "<CompilationUnit BeginColumn=\"1\" BeginLine=\"5\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<TypeDeclaration BeginColumn=\"1\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"8\" BeginLine=\"1\" EndColumn=\"1\" "         * +         * "EndLine=\"5\" Final=\"false\" Image=\"Test\" Interface=\"false\" Native=\"false\" Nested=\"false\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">"         * +         * "<ClassOrInterfaceBody BeginColumn=\"19\" BeginLine=\"1\" EndColumn=\"1\" EndLine=\"5\">"         * +         * "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"3\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">"         * +         * "<ClassOrInterfaceDeclaration Abstract=\"false\" BeginColumn=\"10\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\" Final=\"false\" "         * +         * "Image=\"Inner\" Interface=\"false\" Native=\"false\" Nested=\"true\" PackagePrivate=\"false\" Private=\"false\" Protected=\"false\" "         * +         * "Public=\"true\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" Volatile=\"false\">"         * +         * "<ClassOrInterfaceBody BeginColumn=\"22\" BeginLine=\"2\" EndColumn=\"3\" EndLine=\"4\">"         * +         * "<ClassOrInterfaceBodyDeclaration AnonymousInnerClass=\"false\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\">"         * +         * "<FieldDeclaration Abstract=\"false\" Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"11\" EndLine=\"3\" Final=\"false\" Native=\"false\" PackagePrivate=\"true\" Private=\"false\" Protected=\"false\" Public=\"false\" Static=\"false\" Strictfp=\"false\" Synchronized=\"false\" Transient=\"false\" VariableName=\"foo\" Volatile=\"false\"><Type Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" EndColumn=\"6\" EndLine=\"3\">"         * +         * "<PrimitiveType Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"4\" BeginLine=\"3\" Boolean=\"false\" EndColumn=\"6\" EndLine=\"3\" Image=\"int\"/>"         * + "</Type>" +         * "<VariableDeclarator BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\">"         * +         * "<VariableDeclaratorId Array=\"false\" ArrayDepth=\"0\" BeginColumn=\"8\" BeginLine=\"3\" EndColumn=\"10\" EndLine=\"3\" ExceptionBlockParameter=\"false\" Image=\"foo\"/>"         * +         * "</VariableDeclarator></FieldDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody>"         * +         * "</ClassOrInterfaceDeclaration></ClassOrInterfaceBodyDeclaration></ClassOrInterfaceBody></ClassOrInterfaceDeclaration>"         * + "</TypeDeclaration></CompilationUnit>"; assertEquals( expectedXml,         * getXmlString( c ) );         */ }    @Test    public void testContainsNoInnerWithAnonInner() {        ASTCompilationUnit c = java.parse(CONTAINS_NO_INNER_WITH_ANON_INNER);        List<ASTFieldDeclaration> res = c.findDescendantsOfType(ASTFieldDeclaration.class);        assertTrue(res.isEmpty());    }    @Test    public void testContainsChildOfType() {        ASTClassOrInterfaceDeclaration c = java.getNodes(ASTClassOrInterfaceDeclaration.class, CONTAINS_CHILDREN_OF_TYPE)                .iterator().next();        assertTrue(c.hasDescendantOfType(ASTFieldDeclaration.class));    }    @Test    public void testXPathNodeSelect() {        ASTClassOrInterfaceDeclaration c = java.getNodes(ASTClassOrInterfaceDeclaration.class, TEST_XPATH).iterator().next();        List<Node> nodes = c.findChildNodesWithXPath("//FieldDeclaration");        assertEquals(2, nodes.size());        assertTrue(nodes.get(0) instanceof ASTFieldDeclaration);    }    private void verifyNode(Node node, int beginLine, int beginCol, int endLine, int endCol) {        assertEquals("Unexpected beginning line: ", beginLine, node.getBeginLine());        assertEquals("Unexpected beginning column: ", beginCol, node.getBeginColumn());        assertEquals("Unexpected ending line:", endLine, node.getEndLine());        assertEquals("Unexpected ending column:", endCol, node.getEndColumn());    }    private static final String HAS_EXPLICIT_EXTENDS = "public class Test extends Foo {}";    private static final String NO_EXPLICIT_EXTENDS = "public class Test {}";    private static final String HAS_EXPLICIT_IMPLEMENTS = "public class Test implements Foo {}";    private static final String NO_EXPLICIT_IMPLEMENTS = "public class Test {}";    private static final String METHOD_SAME_LINE = "public class Test {\n public void foo() {}\n}";    private static final String QUALIFIED_NAME = "import java.io.File;\npublic class Foo{}";    private static final String BROKEN_LINE_IN_NAME = "import java.io.\nFile;\npublic class Foo{}";    //    private static final String LINE_NUMBERS_ON_SIBLINGS =    //        "public class Foo {\n void bar() {\n  try {\n  } catch (Exception1 e) {\n   int x =2;\n  }\n if (x != null) {}\n }\n}";    private static final String NO_LOOKAHEAD = "public class Foo { }";    private static final String METHOD_DIFF_LINES = "public class Test {\n public void foo() {\n  int x;\n }\n}";    private static final String CONTAINS_CHILDREN_OF_TYPE = "public class Test {\n  int x;\n}";    private static final String CONTAINS_NO_INNER = "public class Test {\n  public class Inner {\n   int foo;\n  }\n}";    private static final String CONTAINS_NO_INNER_WITH_ANON_INNER = "public class Test {\n  void bar() {\n   foo(new Fuz() { int x = 2;});\n  }\n}";    private static final String TEST_XPATH = "public class Test {\n  int x = 2;\n  int y = 42;\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class JDKVersionTest {    private final JavaParsingHelper java3 = JavaParsingHelper.JUST_PARSE        .withDefaultVersion("1.3")        .withResourceContext(JDKVersionTest.class, "jdkversiontests/");    private final JavaParsingHelper java4 = java3.withDefaultVersion("1.4");    private final JavaParsingHelper java5 = java3.withDefaultVersion("1.5");    private final JavaParsingHelper java7 = java3.withDefaultVersion("1.7");    private final JavaParsingHelper java8 = java3.withDefaultVersion("1.8");    private final JavaParsingHelper java9 = java3.withDefaultVersion("9");    // enum keyword/identifier    @Test(expected = ParseException.class)    public void testEnumAsKeywordShouldFailWith14() {        java5.parseResource("jdk14_enum.java");    }    @Test    public void testEnumAsIdentifierShouldPassWith14() {        java4.parseResource("jdk14_enum.java");    }    @Test    public void testEnumAsKeywordShouldPassWith15() {        java5.parseResource("jdk15_enum.java");    }    @Test(expected = ParseException.class)    public void testEnumAsIdentifierShouldFailWith15() {        java5.parseResource("jdk14_enum.java");    }    // enum keyword/identifier    // assert keyword/identifier    @Test    public void testAssertAsKeywordVariantsSucceedWith14() {        java4.parseResource("assert_test1.java");        java4.parseResource("assert_test2.java");        java4.parseResource("assert_test3.java");        java4.parseResource("assert_test4.java");    }    @Test(expected = ParseException.class)    public void testAssertAsVariableDeclIdentifierFailsWith14() {        java4.parseResource("assert_test5.java");    }    @Test(expected = ParseException.class)    public void testAssertAsMethodNameIdentifierFailsWith14() {        java4.parseResource("assert_test7.java");    }    @Test    public void testAssertAsIdentifierSucceedsWith13() {        java3.parseResource("assert_test5.java");    }    @Test(expected = ParseException.class)    public void testAssertAsKeywordFailsWith13() {        java3.parseResource("assert_test6.java");    }    // assert keyword/identifier    @Test    public void testVarargsShouldPassWith15() {        java5.parseResource("jdk15_varargs.java");    }    @Test(expected = ParseException.class)    public void testVarargsShouldFailWith14() {        java4.parseResource("jdk15_varargs.java");    }    @Test    public void testJDK15ForLoopSyntaxShouldPassWith15() {        java5.parseResource("jdk15_forloop.java");    }    @Test    public void testJDK15ForLoopSyntaxWithModifiers() {        java5.parseResource("jdk15_forloop_with_modifier.java");    }    @Test(expected = ParseException.class)    public void testJDK15ForLoopShouldFailWith14() {        java4.parseResource("jdk15_forloop.java");    }    @Test    public void testJDK15GenericsSyntaxShouldPassWith15() {        java5.parseResource("jdk15_generics.java");    }    @Test    public void testVariousParserBugs() {        java5.parseResource("fields_bug.java");        java5.parseResource("gt_bug.java");        java5.parseResource("annotations_bug.java");        java5.parseResource("constant_field_in_annotation_bug.java");        java5.parseResource("generic_in_field.java");    }    @Test    public void testNestedClassInMethodBug() {        java5.parseResource("inner_bug.java");        java5.parseResource("inner_bug2.java");    }    @Test    public void testGenericsInMethodCall() {        java5.parseResource("generic_in_method_call.java");    }    @Test    public void testGenericINAnnotation() {        java5.parseResource("generic_in_annotation.java");    }    @Test    public void testGenericReturnType() {        java5.parseResource("generic_return_type.java");    }    @Test    public void testMultipleGenerics() {        // See java/lang/concurrent/CopyOnWriteArraySet        java5.parseResource("funky_generics.java");        // See java/lang/concurrent/ConcurrentHashMap        java5.parseResource("multiple_generics.java");    }    @Test    public void testAnnotatedParams() {        java5.parseResource("annotated_params.java");    }    @Test    public void testAnnotatedLocals() {        java5.parseResource("annotated_locals.java");    }    @Test    public void testAssertAsIdentifierSucceedsWith13Test2() {        java3.parseResource("assert_test5_a.java");    }    @Test    public final void testBinaryAndUnderscoresInNumericalLiterals() {        java7.parseResource("jdk17_numerical_literals.java");    }    @Test    public final void testStringInSwitch() {        java7.parseResource("jdk17_string_in_switch.java");    }    @Test    public final void testGenericDiamond() {        java7.parseResource("jdk17_generic_diamond.java");    }    @Test    public final void testTryWithResources() {        java7.parseResource("jdk17_try_with_resources.java");    }    @Test    public final void testTryWithResourcesSemi() {        java7.parseResource("jdk17_try_with_resources_semi.java");    }    @Test    public final void testTryWithResourcesMulti() {        java7.parseResource("jdk17_try_with_resources_multi.java");    }    @Test    public final void testTryWithResourcesWithAnnotations() {        java7.parseResource("jdk17_try_with_resources_with_annotations.java");    }    @Test    public final void testMulticatch() {        java7.parseResource("jdk17_multicatch.java");    }    @Test    public final void testMulticatchWithAnnotations() {        java7.parseResource("jdk17_multicatch_with_annotations.java");    }    @Test(expected = ParseException.class)    public final void jdk9PrivateInterfaceMethodsInJava18() {        java8.parseResource("jdk9_private_interface_methods.java");    }    @Test    public final void testPrivateMethods() {        java8.parse("public class Foo { private void bar() { } }");    }    @Test    public final void testNestedPrivateMethods() {        java8.parse("public interface Baz { public static class Foo { private void bar() { } } }");    }    @Test    public final void jdk9PrivateInterfaceMethods() {        java9.parseResource("jdk9_private_interface_methods.java");    }    @Test    public final void jdk9InvalidIdentifierInJava18() {        java8.parseResource("jdk9_invalid_identifier.java");    }    @Test(expected = ParseException.class)    public final void jdk9InvalidIdentifier() {        java9.parseResource("jdk9_invalid_identifier.java");    }    @Test(expected = ParseException.class)    public final void jdk9AnonymousDiamondInJava8() {        java8.parseResource("jdk9_anonymous_diamond.java");    }    @Test    public final void jdk9AnonymousDiamond() {        java9.parseResource("jdk9_anonymous_diamond.java");    }    @Test(expected = ParseException.class)    public final void jdk9ModuleInfoInJava8() {        java8.parseResource("jdk9_module_info.java");    }    @Test    public final void jdk9ModuleInfo() {        java9.parseResource("jdk9_module_info.java");    }    @Test    public void testAnnotatedModule() {        java9.parseResource("jdk9_module_info_with_annot.java");    }    @Test(expected = ParseException.class)    public final void jdk9TryWithResourcesInJava8() {        java8.parseResource("jdk9_try_with_resources.java");    }    @Test    public final void jdk9TryWithResources() {        java9.parseResource("jdk9_try_with_resources.java");    }    @Test    public final void jdk7PrivateMethodInnerClassInterface1() {        ASTCompilationUnit acu = java7.parseResource("private_method_in_inner_class_interface1.java");        List<ASTMethodDeclaration> methods = acu.findDescendantsOfType(ASTMethodDeclaration.class, true);        assertEquals(3, methods.size());        for (ASTMethodDeclaration method : methods) {            assertFalse(method.getEnclosingType().isInterface());        }    }    @Test    public final void jdk7PrivateMethodInnerClassInterface2() {        try {            ASTCompilationUnit acu = java7.parseResource("private_method_in_inner_class_interface2.java");            fail("Expected exception");        } catch (ParseException e) {            assertTrue(e.getMessage().startsWith("Line 19"));        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import java.util.List;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * Base class for tests that usually need processing stages to run when * parsing code. */public abstract class BaseParserTest {    protected final JavaParsingHelper java = JavaParsingHelper.JUST_PARSE.withResourceContext(getClass());    protected final JavaParsingHelper java5 = java.withDefaultVersion("1.5");    protected final JavaParsingHelper java8 = java.withDefaultVersion("1.8");    protected final JavaParsingHelper java9 = java.withDefaultVersion("9");    protected ASTCompilationUnit parseCode(final String code) {        return java.parse(code);    }    protected <T extends Node> List<T> getNodes(Class<T> target, String code) {        return JavaParsingHelper.WITH_PROCESSING.getNodes(target, code);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.java.JavaParsingHelper;/** * @author Clment Fournier */public class JavaQualifiedNameTest {    private <T extends Node> List<T> getNodes(Class<T> target, String code) {        return JavaParsingHelper.WITH_PROCESSING.withDefaultVersion("15-preview").getNodes(target, code);    }    @Test    public void testEmptyPackage() {        final String TEST = "class Foo {}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            assertEquals("Foo", coid.getBinaryName());            assertEquals("", coid.getPackageName());        }    }    @Test    public void testPackage() {        final String TEST = "package foo.bar; class Bzaz{}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            assertEquals("foo.bar.Bzaz", coid.getBinaryName());        }    }    @Test    public void testNestedClass() {        final String TEST = "package foo.bar; class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            if ("Foo".equals(coid.getImage())) {                assertEquals("foo.bar.Bzaz$Bor$Foo", coid.getBinaryName());            }        }    }    @Test    public void testNestedEnum() {        final String TEST = "package foo.bar; class Foo { enum Bzaz{HOO;}}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            assertEquals("foo.bar.Foo$Bzaz", coid.getBinaryName());            assertEquals("Bzaz", coid.getSimpleName());            assertEquals("foo.bar", coid.getPackageName());        }    }    @Test    public void testEnum() {        final String TEST = "package foo.bar; enum Bzaz{HOO;}";        List<ASTEnumDeclaration> nodes = getNodes(ASTEnumDeclaration.class, TEST);        for (ASTEnumDeclaration coid : nodes) {            assertEquals("foo.bar.Bzaz", coid.getBinaryName());            assertEquals("Bzaz", coid.getSimpleName());            assertEquals("foo.bar", coid.getPackageName());        }    }    @Test    public void testNestedEmptyPackage() {        final String TEST = "class Bzaz{ class Bor{ class Foo{}}}";        List<ASTClassOrInterfaceDeclaration> nodes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        for (ASTClassOrInterfaceDeclaration coid : nodes) {            if ("Foo".equals(coid.getSimpleName())) {                assertEquals("Bzaz$Bor$Foo", coid.getBinaryName());                assertEquals("", coid.getPackageName());            }        }    }    @Test    public void testSimpleLocalClass() {        final String TEST = "package bar; class Boron { public void foo(String j) { class Local {} } }";        List<ASTClassOrInterfaceDeclaration> classes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertEquals("bar.Boron$1Local", classes.get(1).getBinaryName());    }    @Test    public void testLocalClassNameClash() {        final String TEST = "package bar; class Bzaz{ void foo() { class Local {} } {// initializer\n class Local {}}}";        List<ASTClassOrInterfaceDeclaration> classes            = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertEquals("bar.Bzaz$1Local", classes.get(1).getBinaryName());        assertEquals("bar.Bzaz$2Local", classes.get(2).getBinaryName());    }    @Test    public void testLocalClassDeepNesting() {        final String TEST            = "class Bzaz{ void foo() { "            + "  class Local { "            + "    class Nested {"            + "      {"            + "        class InnerLocal{}"            + "      }"            + "    }"            + "  }"            + "}}";        List<ASTClassOrInterfaceDeclaration> classes            = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertEquals("Bzaz$1Local", classes.get(1).getBinaryName());        assertEquals("Local", classes.get(1).getSimpleName());        assertTrue(classes.get(1).isLocal());        assertFalse(classes.get(1).isNested());        assertEquals("Bzaz$1Local$Nested", classes.get(2).getBinaryName());        assertFalse(classes.get(2).isLocal());        assertTrue(classes.get(2).isNested());        assertEquals("Bzaz$1Local$Nested$1InnerLocal", classes.get(3).getBinaryName());        assertTrue(classes.get(3).isLocal());        assertFalse(classes.get(3).isNested());    }    @Test    public void testAnonymousClass() {        final String TEST            = "class Bzaz{ void foo() { "            + "  new Runnable() {"            + "      public void run() {}"            + "  };"            + "}}";        List<ASTAnonymousClassDeclaration> classes = getNodes(ASTAnonymousClassDeclaration.class, TEST);        assertEquals(("Bzaz$1"), classes.get(0).getBinaryName());        assertFalse(classes.get(0).isLocal());        assertTrue(classes.get(0).isAnonymous());        assertEquals("", classes.get(0).getSimpleName());    }    @Test    public void testMultipleAnonymousClasses() {        final String TEST            = "class Bzaz{ void foo() { "            + "  new Runnable() {"            + "      public void run() {}"            + "  };"            + "  new Runnable() {"            + "      public void run() {}"            + "  };"            + "}}";        List<ASTAnonymousClassDeclaration> classes = getNodes(ASTAnonymousClassDeclaration.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals("Bzaz$1", classes.get(0).getBinaryName());        assertEquals("Bzaz$2", classes.get(1).getBinaryName());    }    @Test    public void testNestedAnonymousClass() {        final String TEST            = "class Bzaz{ void foo() {"            + "  new Runnable() {"            + "    public void run() {"            + "      new Runnable() {"            + "        public void run() {}"            + "      };"            + "    }"            + "  };"            + "}}";        List<ASTAnonymousClassDeclaration> classes = getNodes(ASTAnonymousClassDeclaration.class, TEST);        assertNotEquals(classes.get(0), classes.get(1));        assertEquals("Bzaz$1", classes.get(0).getBinaryName());        assertEquals("Bzaz$1$1", classes.get(1).getBinaryName());    }    @Test    public void testLocalInAnonymousClass() {        final String TEST                = "class Bzaz{ void foo() {"                + "  new Runnable() {"                + "    public void run() {"                + "      class FooRunnable {}"                + "    }"                + "  };"                + "}}";        List<ASTClassOrInterfaceDeclaration> classes = getNodes(ASTClassOrInterfaceDeclaration.class, TEST);        assertTrue(classes.get(1).isLocal());        assertEquals("Bzaz$1$1FooRunnable", classes.get(1).getBinaryName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Test;public class ASTFormalParameterTest extends BaseParserTest {    @Test    public void testVarargs() {        int nrOfVarArgs = 0;        int nrOfNoVarArgs = 0;        List<ASTFormalParameter> ops = java.getNodes(ASTFormalParameter.class, TEST1, "1.5");        for (ASTFormalParameter b : ops) {            ASTVariableDeclaratorId variableDeclId = b.getFirstDescendantOfType(ASTVariableDeclaratorId.class);            if (!"x".equals(variableDeclId.getImage())) {                assertTrue(b.isVarargs());                nrOfVarArgs++;            } else {                assertFalse(b.isVarargs());                nrOfNoVarArgs++;            }        }        // Ensure that both possibilities are tested        assertEquals(1, nrOfVarArgs);        assertEquals(1, nrOfNoVarArgs);    }    private static final String TEST1 = "class Foo {\n void bar(int x, int... others) {}\n}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;public class PMD5RulesetTest {    @Test    public void loadRuleset() {        RuleSet ruleset = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/lang/java/pmd5ruleset.xml");        Assert.assertNotNull(ruleset);        Assert.assertNull(ruleset.getRuleByName("GuardLogStatementJavaUtil"));        Assert.assertNull(ruleset.getRuleByName("GuardLogStatement"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import java.util.logging.Handler;import java.util.logging.LogRecord;import java.util.logging.Logger;import org.junit.After;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;public class QuickstartRulesetTest {    @Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    @After    public void cleanup() {        Handler[] handlers = Logger.getLogger(RuleSetLoader.class.getName()).getHandlers();        for (Handler handler : handlers) {            Logger.getLogger(RuleSetLoader.class.getName()).removeHandler(handler);        }    }    @Test    public void noDeprecations() {        Logger.getLogger(RuleSetLoader.class.getName()).addHandler(new Handler() {            @Override            public void publish(LogRecord record) {                Assert.fail("No Logging expected: " + record.getMessage());            }            @Override            public void flush() {            }            @Override            public void close() throws SecurityException {            }        });        RuleSetLoader ruleSetFactory = new RuleSetLoader().enableCompatibility(false);        RuleSet quickstart = ruleSetFactory.loadFromResource("rulesets/java/quickstart.xml");        Assert.assertFalse(quickstart.getRules().isEmpty());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;/** * Special tweak to remove deprecated attributes of AccessNode */public abstract class BaseJavaTreeDumpTest extends BaseTreeDumpTest {    protected BaseJavaTreeDumpTest() {        super(new JavaAttributesPrinter(), ".java");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.java;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration;import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;public class SuppressWarningsTest {    private final JavaParsingHelper java = JavaParsingHelper.WITH_PROCESSING;    public static class BarRule extends AbstractJavaRule {        public BarRule() {            setMessage("fooMessage");        }        @Override        public Object visit(ASTCompilationUnit cu, Object ctx) {            // Convoluted rule to make sure the violation is reported for the            // ASTCompilationUnit node            for (ASTClassOrInterfaceDeclaration c : cu.descendants(ASTClassOrInterfaceDeclaration.class)) {                if ("bar".equalsIgnoreCase(c.getSimpleName())) {                    addViolation(ctx, cu);                }            }            return super.visit(cu, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    public void testClassLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST1);        assertSize(rpt, 0);        rpt = java.executeRule(new FooRule(), TEST2);        assertSize(rpt, 0);    }    @Test    public void testInheritedSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST3);        assertSize(rpt, 0);    }    @Test    public void testMethodLevelSuppression() {        Report rpt;        rpt = java.executeRule(new FooRule(), TEST4);        assertSize(rpt, 1);    }    @Test    public void testConstructorLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST5);        assertSize(rpt, 0);    }    @Test    public void testFieldLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST6);        assertSize(rpt, 1);    }    @Test    public void testParameterLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST7);        assertSize(rpt, 1);    }    @Test    public void testLocalVariableLevelSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST8);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppression() {        Report rpt = java.executeRule(new FooRule(), TEST9);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppressionValue1() {        Report rpt = java.executeRule(new FooRule(), TEST9_VALUE1);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppressionValue2() {        Report rpt = java.executeRule(new FooRule(), TEST9_VALUE2);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppressionValue3() {        Report rpt = java.executeRule(new FooRule(), TEST9_VALUE3);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppressionMulitpleValues1() {        Report rpt = java.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES_1);        assertSize(rpt, 0);    }    @Test    public void testSpecificSuppressionMulitpleValues2() {        Report rpt = java.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES_2);        assertSize(rpt, 0);    }    @Test    public void testNoSuppressionBlank() {        Report rpt = java.executeRule(new FooRule(), TEST10);        assertSize(rpt, 2);    }    @Test    public void testNoSuppressionSomethingElseS() {        Report rpt = java.executeRule(new FooRule(), TEST11);        assertSize(rpt, 2);    }    @Test    public void testSuppressAll() {        Report rpt = java.executeRule(new FooRule(), TEST12);        assertSize(rpt, 0);    }    @Test    public void testSpecificSuppressionAtTopLevel() {        Report rpt = java.executeRule(new BarRule(), TEST13);        assertSize(rpt, 0);    }    @Test    public void testConstExpr() {        testAboutConstExpr(true, 0); // with the annotation, we should get no violation        testAboutConstExpr(false, 1); // without the annotation, we should get a violation    }    private void testAboutConstExpr(boolean hasAnnotation, int numExpectedViolations) {        Report rpt = java.executeRule(new FooRule(), constExprTest(hasAnnotation));        assertSize(rpt, numExpectedViolations);    }    private static final String TEST1 = "@SuppressWarnings(\"PMD\")\npublic class Foo {}";    private static final String TEST2 = "@SuppressWarnings(\"PMD\")\npublic class Foo {\n void bar() {\n  int foo;\n }\n}";    private static final String TEST3 = "public class Baz {\n @SuppressWarnings(\"PMD\")\n public class Bar {\n  void bar() {\n   int foo;\n  }\n }\n}";    private static final String TEST4 = "public class Foo {\n @SuppressWarnings(\"PMD\")\n void bar() {\n  int foo;\n }\n}";    private static final String TEST5 = "public class Bar {\n @SuppressWarnings(\"PMD\")\n public Bar() {\n  int foo;\n }\n}";    private static final String TEST6 = "public class Bar {\n @SuppressWarnings(\"PMD\")\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST7 = "public class Bar {\n int foo;\n void bar(@SuppressWarnings(\"PMD\") int foo) {}\n}";    private static final String TEST8 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"PMD\") int foo;\n }\n}";    private static final String TEST9 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"PMD.NoFoo\") int foo;\n }\n}";    private static final String TEST9_VALUE1 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(value = \"PMD.NoFoo\") int foo;\n }\n}";    private static final String TEST9_VALUE2 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings({\"PMD.NoFoo\"}) int foo;\n }\n}";    private static final String TEST9_VALUE3 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(value = {\"PMD.NoFoo\"}) int foo;\n }\n}";    private static final String TEST9_MULTIPLE_VALUES_1 = "@SuppressWarnings({\"PMD.NoFoo\", \"PMD.NoBar\"})\npublic class Bar {\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST9_MULTIPLE_VALUES_2 = "@SuppressWarnings(value = {\"PMD.NoFoo\", \"PMD.NoBar\"})\npublic class Bar {\n int foo;\n void bar() {\n  int foo;\n }\n}";    private static final String TEST10 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"\") int foo;\n }\n}";    private static final String TEST11 = "public class Bar {\n int foo;\n void bar() {\n  @SuppressWarnings(\"SomethingElse\") int foo;\n }\n}";    private static final String TEST12 = "public class Bar {\n @SuppressWarnings(\"all\") int foo;\n}";    private static final String TEST13 = "@SuppressWarnings(\"PMD.NoBar\")\npublic class Bar {\n}";    private static @NonNull String constExprTest(boolean withAnnot) {        return "public class NewClass {\n"            + "    private final static String SUPPRESS_PMD = \"PMD.\";\n"            + "\n"            + (withAnnot ? "    @SuppressWarnings(SUPPRESS_PMD + \"NoFoo\")\n" : "")            + "    public void someMethod1(Object Foo) {\n"            + "        System.out.println(\"someMethod1\");\n"            + "    }\n"            + "}";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;@Ignore("Needs to be enabled after java-grammar changes are finalized")public class JavaTokenizerTest extends CpdTextComparisonTest {    public JavaTokenizerTest() {        super(".java");    }    @Override    public Tokenizer newTokenizer(Properties properties) {        JavaTokenizer javaTokenizer = new JavaTokenizer();        javaTokenizer.setProperties(properties);        return javaTokenizer;    }    @Override    protected String getResourcePrefix() {        return "../lang/java/cpd/testdata";    }    @Test    public void testCommentsIgnored() {        doTest("simpleClassWithComments");    }    @Test    public void testDiscardedElements() {        doTest("discardedElements", "_ignore_annots", ignoreAnnotations());    }    @Test    public void testDiscardedElementsExceptAnnots() {        doTest("discardedElements", "_no_ignore_annots");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testIgnoreBetweenSpecialAnnotation() {        doTest("ignoreSpecialAnnotations");    }    @Test    public void testIgnoreBetweenSpecialAnnotationAndIgnoreAnnotations() {        doTest("ignoreSpecialAnnotations", "_ignore_annots", ignoreAnnotations());    }    @Test    public void testIgnoreIdentifiersDontAffectConstructors() {        doTest("ignoreIdentsPreservesCtor", "", ignoreIdents());    }    @Test    public void testIgnoreIdentifiersHandlesEnums() {        doTest("ignoreIdentsPreservesEnum", "", ignoreIdents());    }    @Test    public void testIgnoreIdentifiersWithClassKeyword() {        doTest("ignoreIdentsPreservesClassLiteral", "", ignoreIdents());    }    @Test    public void testIgnoreLiterals() {        doTest("ignoreLiterals", "", ignoreLiterals());    }    @Test    public void testNoIgnoreLiterals() {        doTest("ignoreLiterals", "_noignore");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    private static Properties ignoreAnnotations() {        return properties(true, false, false);    }    private static Properties ignoreIdents() {        return properties(false, false, true);    }    private static Properties ignoreLiterals() {        return properties(false, true, false);    }    @Override    public Properties defaultProperties() {        return properties(false, false, false);    }    private static Properties properties(boolean ignoreAnnotations,                                         boolean ignoreLiterals,                                         boolean ignoreIdents) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.IGNORE_ANNOTATIONS, Boolean.toString(ignoreAnnotations));        properties.setProperty(Tokenizer.IGNORE_IDENTIFIERS, Boolean.toString(ignoreIdents));        properties.setProperty(Tokenizer.IGNORE_LITERALS, Boolean.toString(ignoreLiterals));        return properties;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.IOException;import java.util.regex.Pattern;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cli.BaseCPDCLITest;/** * Unit test for {@link CPDCommandLineInterface}. * */public class CPDCommandLineInterfaceTest extends BaseCPDCLITest {    /**     * Test ignore identifiers argument.     */    @Test    public void testIgnoreIdentifiers() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 7 line (36 tokens) duplication"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * Test ignore identifiers argument with failOnViolation=false     */    @Test    public void testIgnoreIdentifiersFailOnViolationFalse() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--failOnViolation",                "false");        String out = getOutput();        Assert.assertTrue(out.contains("Found a 7 line (36 tokens) duplication"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * Test excludes option.     */    @Test    public void testExcludes() throws Exception {        runCPD("--minimum-tokens", "34", "--language", "java", "--ignore-identifiers", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--exclude",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/File2.java");        String out = getOutput();        Assert.assertFalse(out.contains("Found a 7 line (34 tokens) duplication"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * #1144 CPD encoding argument has no effect     */    @Test    public void testEncodingOption() throws Exception {        String origEncoding = System.getProperty("file.encoding");        // set the default encoding under Windows        System.setProperty("file.encoding", "Cp1252");        runCPD("--minimum-tokens", "34", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--ignore-identifiers", "--format", "xml",                // request UTF-8 for CPD                "--encoding", "UTF-8");        // reset default encoding        System.setProperty("file.encoding", origEncoding);        String out = getOutput();        Assert.assertTrue(out.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));        Assert.assertTrue(Pattern.compile("System\\.out\\.println\\([ij] \\+ \"\"\\);").matcher(out).find());        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    /**     * See: https://sourceforge.net/p/pmd/bugs/1178/     *     * @throws IOException     *             any error     */    @Test    public void testBrokenAndValidFile() throws IOException {        runCPD("--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/badandgood/", "--format", "text", "--skip-lexical-errors");        String out = getOutput();        Assert.assertTrue(                Pattern.compile("Skipping .*?BadFile\\.java\\. Reason: Lexical error in file").matcher(out).find());        Assert.assertTrue(out.contains("Found a 5 line (13 tokens) duplication"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    @Test    public void testFormatXmlWithoutEncoding() throws Exception {        runCPD("--minimum-tokens", "10", "--language", "java", "--files",                "src/test/resources/net/sourceforge/pmd/cpd/clitest/", "--format", "xml");        String out = getOutput();        Assert.assertTrue(out.contains("<duplication lines=\"3\" tokens=\"10\">"));        Assert.assertEquals(4, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }    @Test    public void testCSVFormat() throws Exception {        runCPD("--minimum-tokens", "100", "--files", "src/test/resources/net/sourceforge/pmd/cpd/badandgood/",                "--language", "c", "--format", "csv");        String out = getOutput();        Assert.assertFalse(out.contains("Couldn't instantiate renderer"));        Assert.assertEquals(0, Integer.parseInt(System.getProperty(CPDCommandLineInterface.STATUS_CODE_PROPERTY)));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import java.io.IOException;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.junit.Test;public class MatchAlgorithmTest {    private static final String LINE_1 = "public class Foo { ";    private static final String LINE_2 = " public void bar() {";    private static final String LINE_3 = "  System.out.println(\"hello\");";    private static final String LINE_4 = "  System.out.println(\"hello\");";    private static final String LINE_5 = "  int i = 5";    private static final String LINE_6 = "  System.out.print(\"hello\");";    private static final String LINE_7 = " }";    private static final String LINE_8 = "}";    private static String getSampleCode() {        return LINE_1 + "\n" + LINE_2 + "\n" + LINE_3 + "\n" + LINE_4 + "\n" + LINE_5 + "\n" + LINE_6                + "\n" + LINE_7 + "\n" + LINE_8;    }    @Test    public void testSimple() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        assertEquals(41, tokens.size());        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        Mark mark1 = marks.next();        Mark mark2 = marks.next();        assertFalse(marks.hasNext());        assertEquals(3, mark1.getBeginLine());        assertEquals("Foo.java", mark1.getFilename());        assertEquals(LINE_3, mark1.getSourceCodeSlice());        assertEquals(4, mark2.getBeginLine());        assertEquals("Foo.java", mark2.getFilename());        assertEquals(LINE_4, mark2.getSourceCodeSlice());    }    @Test    public void testIgnore() throws IOException {        JavaTokenizer tokenizer = new JavaTokenizer();        tokenizer.setIgnoreLiterals(true);        tokenizer.setIgnoreIdentifiers(true);        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(getSampleCode(), "Foo.java"));        Tokens tokens = new Tokens();        TokenEntry.clearImages();        tokenizer.tokenize(sourceCode, tokens);        Map<String, SourceCode> codeMap = new HashMap<>();        codeMap.put("Foo.java", sourceCode);        MatchAlgorithm matchAlgorithm = new MatchAlgorithm(codeMap, tokens, 5);        matchAlgorithm.findMatches();        Iterator<Match> matches = matchAlgorithm.matches();        Match match = matches.next();        assertFalse(matches.hasNext());        Iterator<Mark> marks = match.iterator();        marks.next();        marks.next();        marks.next();        assertFalse(marks.hasNext());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.io.UnsupportedEncodingException;import java.nio.charset.Charset;import java.util.Locale;import org.apache.commons.io.FileUtils;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.ExternalResource;import org.junit.rules.TestRule;public class PMDTaskTest extends AbstractAntTestHelper {    public PMDTaskTest() {        super.antTestScriptFilename = "pmdtasktest.xml";    }    @Test    public void testNoFormattersValidation() {        executeTarget("testNoFormattersValidation");        assertOutputContaining("Fields should be declared at the top of the class");    }    @Test    public void testNestedRuleset() {        executeTarget("testNestedRuleset");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testFormatterWithProperties() {        executeTarget("testFormatterWithProperties");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");        assertOutputContaining("link_prefix");        assertOutputContaining("line_prefix");    }    @Test    public void testAbstractNames() {        executeTarget("testAbstractNames");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testAbstractNamesInNestedRuleset() {        executeTarget("testAbstractNamesInNestedRuleset");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testCommaInRulesetfiles() {        executeTarget("testCommaInRulesetfiles");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testRelativeRulesets() {        executeTarget("testRelativeRulesets");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at the");    }    @Test    public void testRelativeRulesetsInRulesetfiles() {        executeTarget("testRelativeRulesetsInRulesetfiles");        assertOutputContaining("Avoid really long methods");        assertOutputContaining("Fields should be declared at");    }    @Test    public void testExplicitRuleInRuleSet() {        executeTarget("testExplicitRuleInRuleSet");        assertOutputContaining("Avoid really long methods");    }    @Test    public void testClasspath() {        executeTarget("testClasspath");    }    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @Rule    public final TestRule restoreLocale = new ExternalResource() {        private Locale originalLocale;        @Override        protected void before() throws Throwable {            originalLocale = Locale.getDefault();        }        @Override        protected void after() {            Locale.setDefault(originalLocale);        }    };    private static void setDefaultCharset(String charsetName) {        System.setProperty("file.encoding", charsetName);    }    @Rule    public final TestRule restoreDefaultCharset = new ExternalResource() {        private Charset defaultCharset;        @Override        protected void before() throws Throwable {            defaultCharset = Charset.defaultCharset();        }        @Override        protected void after() {            setDefaultCharset(defaultCharset.name());        }    };    @Test    public void testFormatterEncodingWithXML() throws Exception {        Locale.setDefault(Locale.FRENCH);        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXML");        String report = FileUtils.readFileToString(currentTempFile(), "UTF-8");        assertTrue(report.contains("unusedVariableWithmlaut"));    }    private static String convert(String report) {        // reinterpret output as cp1252 - ant BuildFileRule can only unicode        StringBuilder sb = new StringBuilder(report.length());        for (int i = 0; i < report.length(); i++) {            char c = report.charAt(i);            if (c > 0x7f) {                sb.append((char) (c & 0xff));            } else {                sb.append(c);            }        }        return sb.toString();    }    @Test    public void testFormatterEncodingWithXMLConsole() throws UnsupportedEncodingException {        setDefaultCharset("cp1252");        executeTarget("testFormatterEncodingWithXMLConsole");        String report = convert(buildRule.getOutput());        assertTrue(report.startsWith("<?xml version=\"1.0\" encoding=\"windows-1252\"?>"));        assertTrue(report.contains("unusedVariableWithmlaut"));    }    @Test    public void testMissingCacheLocation() {        executeTarget("testMissingCacheLocation");        assertOutputContaining("Avoid really long methods");        assertContains(buildRule.getLog(), "This analysis could be faster");    }    @Test    public void testAnalysisCache() {        executeTarget("testAnalysisCache");        assertOutputContaining("Avoid really long methods");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertTrue(currentTempFile().exists());    }    @Test    public void testDisableIncrementalAnalysis() {        executeTarget("testDisableIncrementalAnalysis");        assertOutputContaining("Avoid really long methods");        assertDoesntContain(buildRule.getLog(), "This analysis could be faster");        assertFalse(currentTempFile().exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.regex.Pattern;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.util.FileUtil;/** * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CLITest extends BaseCLITest {    @Test    public void minimalArgs() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/bestpractices.xml,category/java/design.xml", };        runTest(args, "minimalArgs");    }    @Test    public void minimumPriority() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-min", "1", };        runTest(args, "minimumPriority");    }    @Test    public void usingDebug() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-debug", };        runTest(args, "minimalArgsWithDebug");    }    @Test    public void changeJavaVersion() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", "-version", "1.5", "-language",            "java", "-debug", };        String resultFilename = runTest(args, "chgJavaVersion");        assertTrue("Invalid Java version",                FileUtil.findPatternInFile(new File(resultFilename), "Using Java version: Java 1.5"));    }    @Test    public void exitStatusNoViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml", };        runTest(args, "exitStatusNoViolations");    }    @Test    public void exitStatusWithViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/errorprone.xml", };        String resultFilename = runTest(args, "exitStatusWithViolations", 4);        assertTrue(FileUtil.findPatternInFile(new File(resultFilename), "Avoid empty if"));    }    @Test    public void exitStatusWithViolationsAndWithoutFailOnViolations() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/errorprone.xml", "-failOnViolation", "false", };        String resultFilename = runTest(args, "exitStatusWithViolationsAndWithoutFailOnViolations", 0);        assertTrue(FileUtil.findPatternInFile(new File(resultFilename), "Avoid empty if"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRuleset() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename),                "Can't find resource 'category/java/designn.xml' for rule 'null'." + "  Make sure the resource is a valid file"));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulesetWithRulename() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/designn.xml/UseCollectionIsEmpty", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename),                "Can't find resource 'category/java/designn.xml' for rule " + "'UseCollectionIsEmpty'."));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRulename() {        String[] args = { "-d", SOURCE_FOLDER, "-f", "text", "-R", "category/java/design.xml/ThisRuleDoesNotExist", };        String filename = TEST_OUPUT_DIRECTORY + "testWrongRuleset.txt";        createTestOutputFile(filename);        runPMDWith(args);        Assert.assertEquals(1, getStatusCode());        assertTrue(FileUtil.findPatternInFile(new File(filename), Pattern                .quote("No rules found. Maybe you misspelled a rule name?" + " (category/java/design.xml/ThisRuleDoesNotExist)")));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on Java file with default options.     */    @Test    public void testJavaFileUsingDefaults() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals("LanguageVersion must be Java 15 !",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("15"), languageVersion);    }    /**     * Test on Java file with Java version set to 1.4.     */    @Test    public void testJavaFileUsing14() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        discoverer.setDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"));        File javaFile = new File("/path/to/MyClass.java");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(javaFile);        assertEquals("LanguageVersion must be Java 1.4!",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), languageVersion);    }    @Test    public void testLanguageVersionDiscoverer() {        PMDConfiguration configuration = new PMDConfiguration();        LanguageVersionDiscoverer languageVersionDiscoverer = configuration.getLanguageVersionDiscoverer();        assertEquals("Default Java version", LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("15"),                languageVersionDiscoverer                        .getDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)));        configuration                .setDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"));        assertEquals("Modified Java version", LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"),                languageVersionDiscoverer                        .getDefaultLanguageVersion(LanguageRegistry.getLanguage(JavaLanguageModule.NAME)));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.java.JavaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.3",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.3"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.4",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.4"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.5",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.6",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.6"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.7",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.7"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "1.8",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.8"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "9",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("9"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "10",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("10"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "11",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("11"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("12"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "12-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("12-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "13-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("13-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "14",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("14"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "14-preview",                LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("14-preview"), },            { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "15",                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("15"), },                { JavaLanguageModule.NAME, JavaLanguageModule.TERSE_NAME, "15-preview",                    LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("15-preview"), },            // this one won't be found: case sensitive!            { "JAVA", "JAVA", "1.7", null, },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import static org.junit.Assert.assertFalse;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.java.JavaLanguageModule;import net.sourceforge.pmd.lang.java.JavaParsingHelper;public class ReportTest {    private final JavaParsingHelper java = JavaParsingHelper.WITH_PROCESSING;    @Test    public void testBasic() {        Report r = java.executeRule(new FooRule(), TEST1);        assertFalse(r.getViolations().isEmpty());    }    @Test    public void testExclusionsInReportWithRuleViolationSuppressRegex() {        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_REGEX_DESCRIPTOR, ".*No Foo.*");        Report rpt = java.executeRule(rule, TEST1);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    public void testExclusionsInReportWithRuleViolationSuppressXPath() {        Rule rule = new FooRule();        rule.setProperty(Rule.VIOLATION_SUPPRESS_XPATH_DESCRIPTOR, ".[@SimpleName = 'Foo']");        Report rpt = java.executeRule(rule, TEST1);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    public void testExclusionsInReportWithAnnotations() {        LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5");        Report rpt =            java.executeRule(new FooRule(), TEST2);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    public void testExclusionsInReportWithAnnotationsFullName() {        LanguageRegistry.getLanguage(JavaLanguageModule.NAME).getVersion("1.5");        Report rpt = java.executeRule(new FooRule(), TEST2_FULL);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    public void testExclusionsInReportWithNOPMD() {        Report rpt = java.executeRule(new FooRule(), TEST3);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    private static final String TEST1 = "public class Foo {}" + PMD.EOL;    private static final String TEST2 = "@SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST2_FULL = "@java.lang.SuppressWarnings(\"PMD\")" + PMD.EOL + "public class Foo {}";    private static final String TEST3 = "public class Foo {} // NOPMD";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertNull;import org.junit.Test;/** * Test java's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    @Test    public void testExclusionOfUselessParantheses() {        RuleSet ruleset = new RuleSetLoader().loadFromString("",                "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                        + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                        + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                        + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                        + "  <description>Custom ruleset for tests</description>\n"                        + "  <rule ref=\"category/java/codestyle.xml\">\n"                        + "    <exclude name=\"UselessParentheses\"/>\n" + "  </rule>\n" + "</ruleset>\n");        Rule rule = ruleset.getRuleByName("UselessParentheses");        assertNull(rule);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import org.junit.Test;import net.sourceforge.pmd.lang.ParserOptions;import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;public class ExcludeLinesTest extends BaseNonParserTest {    @Test    public void testAcceptance() {        assertSize(java.executeRule(getRule(), TEST1), 0);        assertSize(java.executeRule(getRule(), TEST2), 1);    }    public Rule getRule() {        return new AbstractJavaRule() {            {                setMessage("!");            }            @Override            public Object visit(ASTVariableDeclaratorId node, Object data) {                addViolation(data, node);                return data;            }        };    }    @Test    public void testAlternateMarker() {        ParserOptions options = new ParserOptions();        options.setSuppressMarker("FOOBAR");        Report rpt = java.withParserOptions(options).executeRule(getRule(), TEST3);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    private static final String TEST1 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x; //NOPMD "            + PMD.EOL + " } " + PMD.EOL + "}";    private static final String TEST2 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL + "  int x;"            + PMD.EOL + " } " + PMD.EOL + "}";    private static final String TEST3 = "public class Foo {" + PMD.EOL + " void foo() {" + PMD.EOL            + "  int x; // FOOBAR" + PMD.EOL + " } " + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoUnsanitizedJSPExpressionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IframeMissingSrcAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class JspEncodingTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoScriptletsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineStyleInformationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoLongScriptsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoInlineScriptTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DuplicateJspImportsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DontNestJsfInJstlIterationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoHtmlCommentsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoJspForwardTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NoClassAttributeTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Iterator;import java.util.List;import org.junit.Ignore;import org.junit.Test;/** * Test parsing of a JSP in document style, by checking the generated AST. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be * */public class JspDocStyleTest extends AbstractJspNodesTst {    /**     * Smoke test for JSP parser.     */    @Test    public void testSimplestJsp() {        List<ASTElement> nodes = jsp.getNodes(ASTElement.class, TEST_SIMPLEST_HTML);        assertEquals("Exactly " + 1 + " element(s) expected", 1, nodes.size());    }    /**     * Test the information on a Element and Attribute.     */    @Test    public void testElementAttributeAndNamespace() {        ASTCompilationUnit root = jsp.parse(TEST_ELEMENT_AND_NAMESPACE);        List<ASTElement> elementNodes = root.findDescendantsOfType(ASTElement.class);        assertEquals("One element node expected!", 1, elementNodes.size());        ASTElement element = elementNodes.get(0);        assertEquals("Correct name expected!", "h:html", element.getName());        assertTrue("Has namespace prefix!", element.isHasNamespacePrefix());        assertTrue("Element is empty!", element.isEmpty());        assertEquals("Correct namespace prefix of element expected!", "h", element.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "html", element.getLocalName());        List<ASTAttribute> attributeNodes = root.findDescendantsOfType(ASTAttribute.class);        assertEquals("One attribute node expected!", 1, attributeNodes.size());        ASTAttribute attribute = attributeNodes.get(0);        assertEquals("Correct name expected!", "MyNsPrefix:MyAttr", attribute.getName());        assertTrue("Has namespace prefix!", attribute.isHasNamespacePrefix());        assertEquals("Correct namespace prefix of element expected!", "MyNsPrefix", attribute.getNamespacePrefix());        assertEquals("Correct local name of element expected!", "MyAttr", attribute.getLocalName());    }    /**     * Test exposing a bug of parsing error when having a hash as last character     * in an attribute value.     *     */    @Test    public void testAttributeValueContainingHash() {        ASTCompilationUnit root = jsp.parse(TEST_ATTRIBUTE_VALUE_CONTAINING_HASH);        List<ASTAttribute> attrsList = root.findDescendantsOfType(ASTAttribute.class);        assertEquals("Three attributes expected!", 3, attrsList.size());        ASTAttribute attr = attrsList.get(0);        assertEquals("Correct attribute name expected!", "something", attr.getName());        assertEquals("Correct attribute value expected!", "#yes#",                     attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());        attr = attrsList.get(1);        assertEquals("Correct attribute name expected!", "foo", attr.getName());        assertEquals("Correct attribute value expected!", "CREATE",                     attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());        attr = attrsList.get(2);        assertEquals("Correct attribute name expected!", "href", attr.getName());        assertEquals("Correct attribute value expected!", "#",                     attr.getFirstDescendantOfType(ASTAttributeValue.class).getImage());    }    /**     * Test correct parsing of CDATA.     */    @Test    public void testCData() {        List<ASTCData> cdataNodes = jsp.getNodes(ASTCData.class, TEST_CDATA);        assertEquals("One CDATA node expected!", 1, cdataNodes.size());        ASTCData cdata = cdataNodes.get(0);        assertEquals("Content incorrectly parsed!", " some <cdata> ]] ]> ", cdata.getImage());    }    /**     * Test parsing of Doctype declaration.     */    @Test    public void testDoctype() {        ASTCompilationUnit root = jsp.parse(TEST_DOCTYPE);        List<ASTDoctypeDeclaration> docTypeDeclarations = root.findDescendantsOfType(ASTDoctypeDeclaration.class);        assertEquals("One doctype declaration expected!", 1, docTypeDeclarations.size());        ASTDoctypeDeclaration docTypeDecl = docTypeDeclarations.iterator().next();        assertEquals("Correct doctype-name expected!", "html", docTypeDecl.getName());        List<ASTDoctypeExternalId> externalIds = root.findDescendantsOfType(ASTDoctypeExternalId.class);        assertEquals("One doctype external id expected!", 1, externalIds.size());        ASTDoctypeExternalId externalId = externalIds.iterator().next();        assertEquals("Correct external public id expected!", "-//W3C//DTD XHTML 1.1//EN", externalId.getPublicId());        assertEquals("Correct external uri expected!", "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd",                externalId.getUri());    }    /**     * Test parsing of a XML comment.     *     */    @Test    public void testComment() {        List<ASTCommentTag> comments = jsp.getNodes(ASTCommentTag.class, TEST_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTCommentTag comment = comments.iterator().next();        assertEquals("Correct comment content expected!", "comment", comment.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScript() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Correct script content expected!", "Script!", script.getImage());    }    /**     * Test parsing of HTML &lt;script src="x"/&gt; element. It might not be valid     * html but it is likely to appear in .JSP files.     */    @Test    public void testImportHtmlScript() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_IMPORT_JAVASCRIPT);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        List<ASTAttributeValue> value = script.findDescendantsOfType(ASTAttributeValue.class);        assertEquals("filename.js", value.get(0).getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testHtmlScriptWithAttribute() {        List<ASTHtmlScript> scripts = jsp.getNodes(ASTHtmlScript.class, TEST_HTML_SCRIPT_WITH_ATTRIBUTE);        assertEquals("One script expected!", 1, scripts.size());        ASTHtmlScript script = scripts.iterator().next();        assertEquals("Correct script content expected!", "Script!", script.getImage());        List<ASTAttributeValue> attrs = script.findDescendantsOfType(ASTAttributeValue.class);        assertTrue("text/javascript".equals(attrs.get(0).getImage()));    }    /**     * A complex script containing HTML comments, escapes, quotes, etc.     */    @Test    public void testComplexHtmlScript() {        List<ASTHtmlScript> script = jsp.getNodes(ASTHtmlScript.class, TEST_COMPLEX_SCRIPT);        assertEquals("One script expected!", 1, script.size());        ASTHtmlScript next = script.iterator().next();        assertTrue(next.getImage().contains("<!--"));        List<ASTCommentTag> comments = jsp.getNodes(ASTCommentTag.class, TEST_COMPLEX_SCRIPT);        assertEquals("One comment expected!", 1, comments.size());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void testInlineCss() {        List<ASTElement> scripts = jsp.getNodes(ASTElement.class, TEST_INLINE_STYLE);        assertEquals("Three elements expected!", 3, scripts.size());    }    /**     * Test parsing of HTML text within element.     */    @Test    public void testTextInTag() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TEXT_IN_TAG);        assertEquals("One text chunk expected!", 1, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML with no spaces between tags. Parser is likely in     * this scenario.     */    @Test    public void noSpacesBetweenTags() {        List<ASTElement> elmts = jsp.getNodes(ASTElement.class, TEST_TAGS_NO_SPACE);        assertEquals("Two tags expected!", 2, elmts.size());        assertEquals("Correct content expected!", "a", elmts.get(0).getName());        assertEquals("Correct content expected!", "b", elmts.get(1).getName());    }    /**     * the $ sign might trick the parser into thinking an EL is next. He should     * be able to treat it as plain text     */    @Test    public void unclosedTagsWithDollar() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TAGS_WITH_DOLLAR);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " $ ", script.getImage());    }    /**     * Make sure EL expressions aren't treated as plain text when they are     * around unclosed tags.     */    @Test    public void unclosedTagsWithELWithin() {        List<ASTElExpression> scripts = jsp.getNodes(ASTElExpression.class, TEST_TAGS_WITH_EL_WITHIN);        assertEquals("Two EL expressions expected!", 2, scripts.size());        assertEquals("Correct content expected!", "expr1", scripts.get(0).getImage());        assertEquals("Correct content expected!", "expr2", scripts.get(1).getImage());    }    /**     * Make sure mixed expressions don't confuse the parser     */    @Test    public void mixedExpressions() {        List<ASTJspExpression> exprs = jsp.getNodes(ASTJspExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("One JSP expression expected!", 1, exprs.size());        assertEquals("Image of expression should be \"expr\"", "expr", exprs.iterator().next().getImage());        List<ASTElExpression> els = jsp.getNodes(ASTElExpression.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("Two EL expression expected!", 2, els.size());        assertEquals("Image of el should be \"expr\"", "expr", els.iterator().next().getImage());        List<ASTUnparsedText> unparsedtexts = jsp.getNodes(ASTUnparsedText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("Two unparsed texts expected!", 2, unparsedtexts.size());        assertEquals("Image of text should be \" aaa \"", " aaa ", unparsedtexts.get(0).getImage());        assertEquals("Image of text should be \"\\${expr}\"", " \\${expr} ", unparsedtexts.get(1).getImage());        // ASTText should contain the text between two tags.        List<ASTText> texts = jsp.getNodes(ASTText.class, TEST_TAGS_WITH_MIXED_EXPRESSIONS);        assertEquals("Two regular texts expected!", 2, texts.size());        assertEquals("Image of text should be \"\\${expr}\"", " \\${expr} ", texts.get(1).getImage());        assertEquals("Image of text should be all text between two nodes" + " \"  aaa ${expr}#{expr} \"",                " aaa ${expr}#{expr}", texts.get(0).getImage());    }    /**     * Make sure JSP expressions are properly detected when they are next to     * unclosed tags.     */    @Test    public void unclosedTagsWithJspExpressionWithin() {        List<ASTJspExpression> scripts = jsp.getNodes(ASTJspExpression.class, TEST_TAGS_WITH_EXPRESSION_WITHIN);        assertEquals("Two JSP expressions expected!", 2, scripts.size());        ASTJspExpression script = scripts.iterator().next();        assertEquals("Correct content expected!", "expr", script.getImage());    }    /**     * A dangling unopened ( just &lt;/closed&gt; ) tag should not influence the     * parsing.     */    @Test    @Ignore // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    public void textBetweenUnopenedTag() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_TEXT_WITH_UNOPENED_TAG);        assertEquals("Two text chunks expected!", 2, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", "$", script.getImage());    }    /**     * Parser should be able to handle documents which start or end with     * unparsed text     */    @Test    @Ignore // sadly the number of    // <opening> tags has to be >= then the number of </closing> tags    public void textMultipleClosingTags() {        List<ASTText> scripts = jsp.getNodes(ASTText.class, TEST_MULTIPLE_CLOSING_TAGS);        assertEquals("Four text chunks expected!", 4, scripts.size());        ASTText script = scripts.iterator().next();        assertEquals("Correct content expected!", " some text ", script.getImage());    }    /**     * Test parsing of HTML &lt;script&gt; element.     */    @Test    public void textAfterOpenAndClosedTag() {        List<ASTElement> nodes = jsp.getNodes(ASTElement.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two elements expected!", 2, nodes.size());        assertEquals("First element should be a", "a", nodes.get(0).getName());        assertFalse("first element should be closed", nodes.get(0).isUnclosed());        assertEquals("Second element should be b", "b", nodes.get(1).getName());        assertTrue("Second element should not be closed", nodes.get(1).isUnclosed());        List<ASTText> text = jsp.getNodes(ASTText.class, TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG);        assertEquals("Two text chunks expected!", 2, text.size());    }    @Test    public void quoteEL() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_EL);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "${something}", attr.getImage());    }    @Test    public void quoteExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_EXPRESSION);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something%>", attr.getImage());    }    @Test    @Ignore // tags contain quotes and break attribute parsing    public void quoteTagInAttribute() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<bean:write name=\"x\" property=\"z\">",                attr.getImage());    }    /**     * smoke test for a non-quoted attribute value     */    @Test    public void noQuoteAttrValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "yes|", attr.getImage());    }    /**     * tests whether JSP el is properly detected as attribute value     */    @Test    public void noQuoteAttrWithJspEL() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EL);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr2 = iterator.next();        if ("url".equals(attr2.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr2 = iterator.next();        }        assertEquals("Expected to detect proper value for EL in attribute!", "${something}", attr2.getImage());    }    /**     * tests whether parse correctly detects presence of JSP expression &lt;%= %&gt;     * within an non-quoted attribute value     */    @Test    public void noQuoteAttrWithJspExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_EXPRESSION);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something%>", attr.getImage());    }    /**     * tests whether parse correctly interprets empty non quote attribute     */    @Test    public void noQuoteAttrEmpty() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_EMPTY_ATTR);        assertEquals("two attributes expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", "", attr.getImage());    }    /**     * tests whether parse correctly interprets an cr lf instead of an attribute     */    @Test    public void noQuoteAttrCrLf() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_CR_LF_ATTR);        assertEquals("One attribute expected!", 2, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        if ("http://someHost:/some_URL".equals(attr.getImage())) {            // we have to employ this nasty work-around            // in order to ensure that we check the proper attribute            attr = iterator.next();        }        assertEquals("Expected to detect proper value for attribute!", "\r\n", attr.getImage());    }    /**     * tests whether parse correctly interprets an tab instead of an attribute     */    @Test    public void noQuoteAttrTab() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAB_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        Iterator<ASTAttributeValue> iterator = attributes.iterator();        ASTAttributeValue attr = iterator.next();        assertEquals("Expected to detect proper value for attribute!", "\t", attr.getImage());    }    /**     * tests whether parse does not fail in the presence of unclosed JSP     * expression &lt;%= within an non-quoted attribute value     */    @Test    public void noQuoteAttrWithMalformedJspExpression() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<%=something", attr.getImage());    }    /**     * test a no quote attribute value which contains a scriptlet &lt;% %&gt; within     * its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithScriptletInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a no quote attribute value can contain a tag (e.g.     * attr=&lt;bean:write property="value" /&gt;)     *     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithBeanWriteTagAsValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a quote attribute value can contain a tag (e.g.     * attr="&lt;bean:write property="value" /&gt;" ) Not sure if it's legal JSP code     * but most JSP engine accept and properly treat this value at runtime     */    @Test    @Ignore // nice test for future development    public void quoteAttrWithBeanWriteTagAsValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_TAG_IN_ATTR);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "<% String a = \"1\";%>", attr.getImage());    }    /**     * test a no quote attribute value which contains the EL dollar sign $     * within its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithDollarSignInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_DOLLAR);        assertEquals("One attribute expected!", 2, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "${something", attr.getImage());    }    /**     * test a no quote attribute value which contains the EL sharp sign # within     * its value     */    @Test    @Ignore // nice test for future development    public void noQuoteAttrWithSharpSymbolInValue() {        List<ASTAttributeValue> attributes = jsp.getNodes(ASTAttributeValue.class, TEST_NO_QUOTE_ATTR_WITH_HASH);        assertEquals("One attribute expected!", 1, attributes.size());        ASTAttributeValue attr = attributes.iterator().next();        assertEquals("Expected to detect proper value for attribute!", "#{something", attr.getImage());    }    @Test    public void unclosedTag() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_SIMPLE);        assertEquals("2 tags expected", 2, elements.size());        assertEquals("First element should be tag:someTag", "tag:someTag", elements.get(0).getName());        assertEquals("Second element should be sorted tag:if", "tag:if", elements.get(1).getName());        assertFalse(elements.get(0).isEmpty());        assertFalse(elements.get(0).isUnclosed());        assertTrue(elements.get(1).isEmpty());        assertTrue(elements.get(1).isUnclosed());    }    @Test    public void unclosedTagAndNoQuotesForAttribute() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_NO_QUOTE_ATTR);        assertEquals("2 tags expected", 2, elements.size());        ASTElement ifTag = elements.get(1);        ASTElement someTag = elements.get(0);        assertEquals("tag:if", ifTag.getName());        assertEquals("tag:someTag", someTag.getName());        assertTrue(ifTag.isEmpty());        assertTrue(ifTag.isUnclosed());        assertFalse(someTag.isEmpty());        assertFalse(someTag.isUnclosed());    }    @Test    public void unclosedTagMultipleLevels() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_MULTIPLE_LEVELS);        assertEquals("3 tags expected", 3, elements.size());        ASTElement xtag = elements.get(0);        ASTElement outerTag = elements.get(1);        ASTElement innerTag = elements.get(2);        assertEquals("tag:someTag", innerTag.getName());        assertEquals("tag:someTag", outerTag.getName());        assertEquals("tag:x", xtag.getName());        assertFalse(innerTag.isEmpty());        assertFalse(innerTag.isUnclosed());        assertTrue(outerTag.isEmpty());        assertTrue(outerTag.isUnclosed());        assertFalse(xtag.isEmpty());        assertFalse(xtag.isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2/&gt; &lt;b/&gt; &lt;/a1&gt; &lt;/html&gt;     */    @Test    public void nestedEmptyTags() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_MULTIPLE_EMPTY_TAGS);        assertEquals("4 tags expected", 4, elements.size());        ASTElement a1Tag = elements.get(1);        ASTElement a2Tag = elements.get(2);        ASTElement bTag = elements.get(3);        ASTElement htmlTag = elements.get(0);        assertEquals("a1", a1Tag.getName());        assertEquals("a2", a2Tag.getName());        assertEquals("b", bTag.getName());        assertEquals("html", htmlTag.getName());        // a1        assertFalse(a1Tag.isEmpty());        assertFalse(a1Tag.isUnclosed());        // a2        assertTrue(a2Tag.isEmpty());        assertFalse(a2Tag.isUnclosed());        // b        assertTrue(bTag.isEmpty());        assertFalse(bTag.isUnclosed());        // html        assertFalse(htmlTag.isEmpty());        assertFalse(htmlTag.isUnclosed());    }    /**     * &lt;html&gt; &lt;a1&gt; &lt;a2&gt; &lt;a3&gt; &lt;/a2&gt; &lt;/a1&gt; &lt;b/&gt; &lt;a4/&gt; &lt;/html&gt;     */    @Test    public void nestedMultipleTags() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_MULTIPLE_NESTED_TAGS);        ASTElement html = elements.get(0);        ASTElement a1 = elements.get(1);        ASTElement a2 = elements.get(2);        ASTElement a3 = elements.get(3);        ASTElement b = elements.get(4);        ASTElement a4 = elements.get(5);        assertEquals("4 tags expected", 6, elements.size());        assertEquals("a1", a1.getName());        assertEquals("a2", a2.getName());        assertEquals("a3", a3.getName());        assertEquals("a4", a4.getName());        assertEquals("b", b.getName());        assertEquals("html", html.getName());        // a1 not empty and closed        assertFalse(a1.isEmpty());        assertFalse(a1.isUnclosed());        // a2 not empty and closed        assertFalse(a2.isEmpty());        assertFalse(a2.isUnclosed());        // a3 empty and not closed        assertTrue(a3.isEmpty());        assertTrue(a3.isUnclosed());        // a4 empty but closed        assertTrue(a4.isEmpty());        assertFalse(a4.isUnclosed());        // b empty but closed        assertTrue(b.isEmpty());        assertFalse(b.isUnclosed());        // html not empty and closed        assertFalse(html.isEmpty());        assertFalse(html.isUnclosed());    }    /**     * will test &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt; .     * Here x is the first tag to be closed thus rendering the next close of a (&lt;/a&gt;)     * to be disregarded.     */    @Test    public void unclosedParentTagClosedBeforeChild() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_END_AFTER_PARENT_CLOSE);        assertEquals("4 tags expected", 4, elements.size());        ASTElement x = elements.get(0);        ASTElement a = elements.get(1);        ASTElement b = elements.get(2);        ASTElement b2 = elements.get(3);        assertEquals("a", a.getName());        assertEquals("b", b.getName());        assertEquals("b", b2.getName());        assertEquals("x", x.getName());        // a        assertTrue(a.isEmpty());        assertTrue(a.isUnclosed());        // b        assertTrue(b.isEmpty());        assertTrue(b.isUnclosed());        // b        assertTrue(b2.isEmpty());        assertTrue(b2.isUnclosed());        // x        assertFalse(x.isEmpty());        assertFalse(x.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt; An unmatched closing of 'z' appears     * randomly in the document. This should be disregarded and structure of     * children and parents should not be influenced. in other words &lt;/a&gt; should     * close the first &lt;a&gt; tag , &lt;/x&gt; should close the first &lt;x&gt;, etc.     */    @Test    public void unmatchedTagDoesNotInfluenceStructure() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_UNMATCHED_CLOSING_TAG);        assertEquals("4 tags expected", 4, elements.size());        ASTElement x = elements.get(0);        ASTElement a = elements.get(1);        ASTElement b1 = elements.get(2);        ASTElement b2 = elements.get(3);        assertEquals("a", a.getName());        assertEquals("b", b1.getName());        assertEquals("b", b2.getName());        assertEquals("x", x.getName());        // a is not empty and closed        assertFalse(a.isEmpty());        assertFalse(a.isUnclosed());        // b empty and unclosed        assertTrue(b1.isEmpty());        assertTrue(b1.isUnclosed());        // b empty and unclosed        assertTrue(b2.isEmpty());        assertTrue(b2.isUnclosed());        // x not empty and closed        assertFalse(x.isEmpty());        assertFalse(x.isUnclosed());    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     * An unmatched closing of 'z' appears randomly in the document. This     * should be disregarded and structure of children and parents should not be influenced.     * Also un unclosed &lt;a&gt; tag appears at the start of the document     */    @Test    public void unclosedStartTagWithUnmatchedCloseOfDifferentTag() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE);        assertEquals("5 tags expected", 5, elements.size());        ASTElement a1 = elements.get(0);        ASTElement x = elements.get(1);        ASTElement a2 = elements.get(2);        ASTElement b1 = elements.get(3);        ASTElement b2 = elements.get(4);        assertEquals("a", a1.getName());        assertEquals("a", a2.getName());        assertEquals("b", b1.getName());        assertEquals("b", b2.getName());        assertEquals("x", x.getName());        // first a is empty and unclosed        assertTrue(a1.isEmpty());        assertTrue(a1.isUnclosed());        // second a not empty and closed        assertFalse(a2.isEmpty());        assertFalse(a2.isUnclosed());        // b empty and unclosed        assertTrue(b1.isEmpty());        assertTrue(b1.isUnclosed());        // b empty and unclosed        assertTrue(b2.isEmpty());        assertTrue(b2.isUnclosed());        // x not empty and closed        assertFalse(x.isEmpty());        assertFalse(x.isUnclosed());    }    /**     * {@link #TEST_UNCLOSED_END_OF_DOC}     * &lt;tag:x&gt; &lt;tag:y&gt;     * Tests whether parser breaks on no closed tags at all     */    // This is yet to be improved. If a closing tag does not    // exist no tags will be marked as empty :(    @Ignore    @Test    public void unclosedEndOfDoc() {        List<ASTElement> elements = jsp.getNodes(ASTElement.class, TEST_UNCLOSED_END_OF_DOC);        assertEquals("2 tags expected", 2, elements.size());        ASTElement x = elements.get(0);        ASTElement y = elements.get(1);        assertEquals("tag:x", x.getName());        assertEquals("tag:y", y.getName());        // b        // assertTrue(sortedElmnts.get(0).isEmpty());        assertTrue(x.isUnclosed());        // b        assertTrue(y.isEmpty());        assertTrue(y.isUnclosed());    }    private static final String TEST_SIMPLEST_HTML = "<html/>";    private static final String TEST_ELEMENT_AND_NAMESPACE = "<h:html MyNsPrefix:MyAttr='MyValue'/>";    private static final String TEST_CDATA = "<html><![CDATA[ some <cdata> ]] ]> ]]></html>";    private static final String TEST_DOCTYPE = "<?xml version=\"1.0\" standalone='yes'?>\n"            + "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" "            + "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n" + "<greeting>Hello, world!</greeting>";    private static final String TEST_COMMENT = "<html><!-- comment --></html>";    private static final String TEST_ATTRIBUTE_VALUE_CONTAINING_HASH = "<tag:if something=\"#yes#\" foo=\"CREATE\">  <a href=\"#\">foo</a> </tag:if>";    private static final String TEST_HTML_SCRIPT = "<html><head><script>Script!</script></head></html>";    private static final String TEST_IMPORT_JAVASCRIPT = "<html><head><script src=\"filename.js\" type=\"text/javascript\"/></head></html>";    private static final String TEST_HTML_SCRIPT_WITH_ATTRIBUTE = "<html><head><script type=\"text/javascript\">Script!</script></head></html>";    private static final String TEST_COMPLEX_SCRIPT = "<HTML><BODY><!--Java Script-->"            + "<SCRIPT language='JavaScript' type='text/javascript'>" + "<!--function calcDays(){"            + " date1 = date1.split(\"-\");  date2 = date2.split(\"-\");"            + " var sDate = new Date(date1[0]+\"/\"+date1[1]+\"/\"+date1[2]);"            + " var eDate = new Date(date2[0]+\"/\"+date2[1]+\"/\"+date2[2]);" + " onload=calcDays;//-->"            + "</SCRIPT></BODY></HTML>;";    private static final String TEST_INLINE_STYLE = "<html><head><style> div { color:red; } </style></head></html>";    private static final String TEST_TEXT_IN_TAG = "<a> some text </a>";    private static final String TEST_TAGS_NO_SPACE = "<a><b></a>";    private static final String TEST_TAGS_WITH_DOLLAR = "<a> $ <b> $ </a>";    private static final String TEST_TAGS_WITH_EL_WITHIN = "<a>#{expr1}<b>${expr2}</a>";    private static final String TEST_TAGS_WITH_MIXED_EXPRESSIONS = "<a> aaa ${expr} #{expr} <%=expr%> <b> \\${expr} </a>";    private static final String TEST_TAGS_WITH_EXPRESSION_WITHIN = "<a> <%=expr%> <b> <%=expr%> </a>";    private static final String TEST_TEXT_AFTER_OPEN_AND_CLOSED_TAG = "<a> some text <b> some text </a>";    private static final String TEST_TEXT_WITH_UNOPENED_TAG = "<a> some text </b> some text </a>";    private static final String TEST_MULTIPLE_CLOSING_TAGS = "<a> some text </b> </b> </b> some text </a>";    private static final String TEST_QUOTE_EL = "<tag:if something=\"${something}\" > </tag:if>";    private static final String TEST_QUOTE_EXPRESSION = "<tag:if something=\"<%=something%>\" >  </tag:if>";    private static final String TEST_QUOTE_TAG_IN_ATTR = "<tag:if something=\"<bean:write name=\"x\" property=\"z\">\" >  "            + "<a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR = "<tag:if something=yes| > </tag:if>";    private static final String TEST_NO_QUOTE_EMPTY_ATTR = "<tag:if something= >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAG_IN_ATTR = "<tag:if something=<bean:write name=\"x\" property=\"z\"> >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_CR_LF_ATTR = "<tag:if something=\r\n >  <a href=http://someHost:/some_URL >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_TAB_ATTR = "<tag:if something=\t >   </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EL = "<tag:if something=${something} >  <a href=url >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_EXPRESSION = "<tag:if something=<%=something%> >  </tag:if>";    /**     * same as {@link #TEST_NO_QUOTE_ATTR_WITH_EXPRESSION} only expression is     * not properly closed     */    private static final String TEST_NO_QUOTE_ATTR_WITH_MALFORMED_EXPR = "<tag:if something=<%=something >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_SCRIPTLET = "<tag:if something=<% String a = \"1\";%>x >  </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_DOLLAR = "<tag:if something=${something >  <a href=${ >foo</a> </tag:if>";    private static final String TEST_NO_QUOTE_ATTR_WITH_HASH = "<tag:if something=#{something >  <a href=#{url} >foo</a> </tag:if>";    private static final String TEST_UNCLOSED_SIMPLE = "<tag:someTag> <tag:if something=\"x\" > </tag:someTag>";    /**     * someTag is closed just once     */    private static final String TEST_UNCLOSED_MULTIPLE_LEVELS = "<tag:x> <tag:someTag> <tag:someTag something=\"x\" > </tag:someTag> </tag:x>";    /**     * nested empty tags     */    private static final String TEST_MULTIPLE_EMPTY_TAGS = "<html> <a1> <a2/> <b/> </a1> </html>";    /**     * multiple nested tags with some tags unclosed     */    private static final String TEST_MULTIPLE_NESTED_TAGS = "<html> <a1> <a2> <a3> </a2> </a1> <b/> <a4/> </html>";    /**     * </x> will close before </a>, thus leaving <a> to remain unclosed     */    private static final String TEST_UNCLOSED_END_AFTER_PARENT_CLOSE = "<x> <a> <b> <b> </x> </a> aa </x> bb </x>";    /**     * </z> is just a dangling closing tag not matching any parent. The parser     * should disregard it     */    private static final String TEST_UNCLOSED_UNMATCHED_CLOSING_TAG = "<x> <a> <b> <b> </z> </a> </x>";    /**     * First <a> tag does not close. The first closing of </a> will match the     * second opening of a. Another rogue </z> is there for testing compliance     */    private static final String TEST_UNCLOSED_START_TAG_WITH_UNMATCHED_CLOSE = "<a> <x> <a> <b> <b> </z> </a> </x>";    private static final String TEST_UNCLOSED_END_OF_DOC = "<tag:x> <tag:y>";    private static final String TEST_UNCLOSED_NO_QUOTE_ATTR = "<tag:someTag> <tag:if something=x > </tag:someTag>";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import java.util.List;import org.junit.Test;public class JspPageStyleTest extends AbstractJspNodesTst {    /**     * Test parsing of a JSP comment.     */    @Test    public void testComment() {        List<ASTJspComment> comments = jsp.getNodes(ASTJspComment.class, JSP_COMMENT);        assertEquals("One comment expected!", 1, comments.size());        ASTJspComment comment = comments.iterator().next();        assertEquals("Correct comment content expected!", "some comment", comment.getImage());    }    /**     * Test parsing a JSP directive.     */    @Test    public void testDirective() {        ASTCompilationUnit root = jsp.parse(JSP_DIRECTIVE);        List<ASTJspDirective> directives = root.findDescendantsOfType(ASTJspDirective.class);        assertEquals("One directive expected!", 1, directives.size());        ASTJspDirective directive = directives.iterator().next();        assertEquals("Correct directive name expected!", "page", directive.getName());        List<ASTJspDirectiveAttribute> directiveAttrs = root.findDescendantsOfType(ASTJspDirectiveAttribute.class);        assertEquals("Two directive attributes expected!", 2, directiveAttrs.size());        ASTJspDirectiveAttribute attr = directiveAttrs.get(0);        assertEquals("Correct directive attribute name expected!", "language", attr.getName());        assertEquals("Correct directive attribute value expected!", "java", attr.getValue());        attr = directiveAttrs.get(1);        assertEquals("Correct directive attribute name expected!", "session", attr.getName());        assertEquals("Correct directive attribute value expected!", "true", attr.getValue());    }    /**     * Test parsing of a JSP declaration.     */    @Test    public void testDeclaration() {        List<ASTJspDeclaration> declarations = jsp.getNodes(ASTJspDeclaration.class, JSP_DECLARATION);        assertEquals("One declaration expected!", 1, declarations.size());        ASTJspDeclaration declaration = declarations.iterator().next();        assertEquals("Correct declaration content expected!", "String someString = \"s\";", declaration.getImage());    }    /**     * Test parsing of a JSP scriptlet.     */    @Test    public void testScriptlet() {        List<ASTJspScriptlet> scriptlets = jsp.getNodes(ASTJspScriptlet.class, JSP_SCRIPTLET);        assertEquals("One scriptlet expected!", 1, scriptlets.size());        ASTJspScriptlet scriptlet = scriptlets.iterator().next();        assertEquals("Correct scriptlet content expected!", "someString = someString + \"suffix\";",                scriptlet.getImage());    }    /**     * Test parsing of a JSP expression.     */    @Test    public void testExpression() {        List<ASTJspExpression> expressions = jsp.getNodes(ASTJspExpression.class, JSP_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "someString", expression.getImage());    }    /**     * Test parsing of a JSP expression in an attribute.     */    @Test    public void testExpressionInAttribute() {        List<ASTJspExpressionInAttribute> expressions = jsp.getNodes(ASTJspExpressionInAttribute.class, JSP_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTJspExpressionInAttribute expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "style.getClass()", expression.getImage());    }    /**     * Test parsing of a EL expression.     */    @Test    public void testElExpression() {        List<ASTElExpression> expressions = jsp.getNodes(ASTElExpression.class, JSP_EL_EXPRESSION);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "myBean.get(\"${ World }\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testElExpressionInAttribute() {        List<ASTElExpression> expressions = jsp.getNodes(ASTElExpression.class, JSP_EL_EXPRESSION_IN_ATTRIBUTE);        assertEquals("One expression expected!", 1, expressions.size());        ASTElExpression expression = expressions.iterator().next();        assertEquals("Correct expression content expected!", "myValidator.find(\"'jsp'\")", expression.getImage());    }    /**     * Test parsing of a EL expression in an attribute.     */    @Test    public void testJsfValueBinding() {        List<ASTValueBinding> valueBindings = jsp.getNodes(ASTValueBinding.class, JSF_VALUE_BINDING);        assertEquals("One value binding expected!", 1, valueBindings.size());        ASTValueBinding valueBinding = valueBindings.iterator().next();        assertEquals("Correct expression content expected!", "myValidator.find(\"'jsf'\")", valueBinding.getImage());    }    private static final String JSP_COMMENT = "<html> <%-- some comment --%> </html>";    private static final String JSP_DIRECTIVE = "<html> <%@ page language=\"java\" session='true'%> </html>";    private static final String JSP_DECLARATION = "<html><%! String someString = \"s\"; %></html>";    private static final String JSP_SCRIPTLET = "<html> <% someString = someString + \"suffix\"; %> </html>";    private static final String JSP_EXPRESSION = "<html><head><title> <%= someString %> </title></head></html>";    private static final String JSP_EXPRESSION_IN_ATTRIBUTE = "<html> <body> <p class='<%= style.getClass() %>'> Hello </p> </body> </html>";    private static final String JSP_EL_EXPRESSION = "<html><title>Hello ${myBean.get(\"${ World }\") } .jsp</title></html>";    private static final String JSP_EL_EXPRESSION_IN_ATTRIBUTE = "<html> <f:validator type=\"get('type').${myValidator.find(\"'jsp'\")}\" /> </html>";    private static final String JSF_VALUE_BINDING = "<html> <body> <p class='#{myValidator.find(\"'jsf'\")}'> Hello </p> </body> </html>";    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(JspPageStyleTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertEquals;import java.io.StringReader;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.testframework.RuleTst;public class XPathJspRuleTest extends RuleTst {    /**     * Test matching a XPath expression against a JSP source.     * @throws PMDException     */    @Test    public void testExpressionMatching() throws PMDException {        Rule rule = new XPathRule(XPathVersion.XPATH_3_1, XPATH_EXPRESSION);        rule.setMessage("Test");        rule.setLanguage(LanguageRegistry.getLanguage(JspLanguageModule.NAME));        RuleSet rules = RuleSet.forSingleRule(rule);        RuleContext ctx = new RuleContext();        Report report = new Report();        ctx.setReport(report);        ctx.setSourceCodeFilename("n/a");        ctx.setLanguageVersion(LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion());        PMD p = new PMD();        p.getSourceCodeProcessor().processSourceCode(new StringReader(MATCH), new RuleSets(rules), ctx);        assertEquals("One violation expected!", 1, report.getViolations().size());        RuleViolation rv = report.getViolations().get(0);        assertEquals(1, rv.getBeginLine());    }    private static final String MATCH = "<html><hr/></html>";    private static final String XPATH_EXPRESSION = "//Element [@Name='hr']";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp.ast;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Before;import org.junit.Test;public class OpenTagRegisterTest {    private OpenTagRegister tagList;    private int elmId = 0;    @Before    public void newRegister() {        tagList = new OpenTagRegister();    }    /**     * &lt;a&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void testSimpleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());    }    /**     * &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/a&gt;     */    @Test    public void doubleNesting() {        ASTElement elm = element("a");        ASTElement elm2 = element("b");        ASTElement elm3 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/x&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void unopenedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4);        tagList.closeTag(elm);        tagList.closeTag(elm2);        tagList.closeTag(elm3);        tagList.closeTag(elm);        assertFalse(elm.isUnclosed());        assertTrue(elm2.isUnclosed());        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());    }    /**     * &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     *     */    @Test    public void interleavedTags() {        ASTElement elm = element("x");        ASTElement elm2 = element("a");        ASTElement elm3 = element("b");        ASTElement elm4 = element("b");        ASTElement elm5 = element("z");        tagList.openTag(elm);        tagList.openTag(elm2);        tagList.openTag(elm3);        tagList.openTag(elm4); // open b        tagList.closeTag(elm5); // close z        tagList.closeTag(elm2); // close a        tagList.closeTag(elm); // close x        assertFalse(elm.isUnclosed()); // x is closed        assertFalse(elm2.isUnclosed()); // a is closed        assertTrue(elm3.isUnclosed());        assertTrue(elm4.isUnclosed());        // elm5 ???    }    /**     * &lt;a&gt; &lt;x&gt; &lt;a&gt; &lt;b&gt; &lt;b&gt; &lt;/z&gt; &lt;/a&gt; &lt;/x&gt;     */    @Test    public void openedIsolatedTag() {        ASTElement a = element("a");        ASTElement x = element("x");        ASTElement a2 = element("a");        ASTElement b = element("b");        ASTElement b2 = element("b");        ASTElement z = element("z");        tagList.openTag(a);        tagList.openTag(x);        tagList.openTag(a2);        tagList.openTag(b);        tagList.openTag(b2);        tagList.closeTag(z); // close z        tagList.closeTag(a2); // close second a        tagList.closeTag(x); // close x        assertTrue(a.isUnclosed()); // first a is unclosed        assertFalse(x.isUnclosed()); // x is closed        assertFalse(a2.isUnclosed()); // a is closed        assertTrue(b.isUnclosed());        assertTrue(b2.isUnclosed());    }    private ASTElement element(String name) {        ASTElement elm = new ASTElement(elmId++);        elm.setName(name);        return elm;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.jsp;import java.io.File;import java.nio.file.Paths;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.jsp.ast.AbstractJspNodesTst;/** * Unit test for JSP parsing. * */public class JspParserTest extends AbstractJspNodesTst {    /**     * Verifies bug #939 Jsp parser fails on $     */    @Test    public void testParseDollar() {    }    @Test    public void testParseELAttribute() {        jsp.parse("<div ${something ? 'class=\"red\"' : ''}> Div content here.</div>");    }    @Test    public void testParseELAttributeValue() {        jsp.parse("<div class=\"${something == 0 ? 'zero_something' : something == 1 ? 'one_something' : 'other_something'}\">Div content here.</div>");    }    /**     * Verifies bug #311 Jsp parser fails on boolean attribute     */    @Test    public void testParseBooleanAttribute() {        jsp.parse("<label><input type='checkbox' checked name=cheese disabled=''> Cheese</label>");    }    @Test    public void testParseJsp() {        testInternalJspFile(Paths.get("sample.jsp").toFile());        testInternalJspFile(Paths.get("sample.jspx").toFile());    }    @Test    public void testParseTag() {        testInternalJspFile(Paths.get("sample.tag").toFile());    }    @Test(expected = AssertionError.class)    public void testParseWrong() {        testInternalJspFile(Paths.get("sample.xxx").toFile());    }    private void testInternalJspFile(File jspFile) {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(jspFile);        Assert.assertEquals("LanguageVersion must be JSP!",                LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class JSPTokenizerTest extends CpdTextComparisonTest {    public JSPTokenizerTest() {        super(".jsp");    }    @Override    protected String getResourcePrefix() {        return "../lang/jsp/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new JSPTokenizer();    }    @Test    public void scriptletWithString() {        doTest("scriptletWithString");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.LanguageVersionDiscoverer;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionDiscovererTest {    /**     * Test on JSP file.     */    @Test    public void testJspFile() {        LanguageVersionDiscoverer discoverer = new LanguageVersionDiscoverer();        File jspFile = new File("/path/to/MyPage.jsp");        LanguageVersion languageVersion = discoverer.getDefaultLanguageVersionForFile(jspFile);        assertEquals("LanguageVersion must be JSP!",                LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), languageVersion);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.jsp.JspLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] { { JspLanguageModule.NAME, JspLanguageModule.TERSE_NAME, "",            LanguageRegistry.getLanguage(JspLanguageModule.NAME).getDefaultVersion(), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;/** * Test jsp's rulesets */public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;/** * @author rpelisse * */public class FortranTokenizerTest extends CpdTextComparisonTest {    public FortranTokenizerTest() {        super(".for");    }    @Override    protected String getResourcePrefix() {        return "../lang/fortran/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new FortranLanguage().getTokenizer();    }    @Test    public void testSample() {        doTest("sample");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.FileSystems;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.SystemUtils;import org.junit.Before;import org.junit.Test;import org.yaml.snakeyaml.DumperOptions;import org.yaml.snakeyaml.DumperOptions.FlowStyle;import org.yaml.snakeyaml.DumperOptions.LineBreak;import org.yaml.snakeyaml.Yaml;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;public class SidebarGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    @Before    public void setup() {        writer.reset();    }    @Test    public void testSidebar() throws IOException {        Map<Language, List<RuleSet>> rulesets = new HashMap<>();        RuleSet ruleSet1 = RuleSet.create("test", "test", "bestpractices.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        RuleSet ruleSet2 = RuleSet.create("test2", "test", "codestyle.xml", Collections.emptyList(), Collections.emptyList(), Collections.emptyList());        rulesets.put(LanguageRegistry.findLanguageByTerseName("java"), Arrays.asList(ruleSet1, ruleSet2));        rulesets.put(LanguageRegistry.findLanguageByTerseName("ecmascript"), Arrays.asList(ruleSet1));        SidebarGenerator generator = new SidebarGenerator(writer, FileSystems.getDefault().getPath(".."));        List<Map<String, Object>> result = generator.generateRuleReferenceSection(rulesets);        DumperOptions options = new DumperOptions();        options.setDefaultFlowStyle(FlowStyle.BLOCK);        if (SystemUtils.IS_OS_WINDOWS) {            options.setLineBreak(LineBreak.WIN);        }        String yaml = new Yaml(options).dump(result);        String expected = MockedFileWriter.normalizeLineSeparators(                IOUtils.toString(SidebarGeneratorTest.class.getResourceAsStream("sidebar.yml"), StandardCharsets.UTF_8));        assertEquals(expected, yaml);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.Arrays;import java.util.List;import org.apache.commons.io.FilenameUtils;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.docs.MockedFileWriter.FileEntry;public class RuleDocGeneratorTest {    private MockedFileWriter writer = new MockedFileWriter();    private Path root;    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Before    public void setup() throws IOException {        writer.reset();        root = folder.newFolder().toPath();        Files.createDirectories(root.resolve("docs/_data/sidebars"));        List<String> mockedSidebar = Arrays.asList(                "entries:",                "- title: sidebar",                "  folders:",                "  - title: 1",                "  - title: 2",                "  - title: 3",                "  - title: Rules");        Files.write(root.resolve("docs/_data/sidebars/pmd_sidebar.yml"), mockedSidebar);    }    private static String loadResource(String name) throws IOException {        return MockedFileWriter.normalizeLineSeparators(                IOUtils.toString(RuleDocGeneratorTest.class.getResourceAsStream(name), StandardCharsets.UTF_8));    }    @Test    public void testSingleRuleset() throws IOException {        RuleDocGenerator generator = new RuleDocGenerator(writer, root);        RuleSetLoader rsf = new RuleSetLoader().includeDeprecatedRuleReferences(true);        RuleSet ruleset = rsf.loadFromResource("rulesets/ruledoctest/sample.xml");        generator.generate(Arrays.asList(ruleset),                Arrays.asList(                        "rulesets/ruledoctest/sample-deprecated.xml",                        "rulesets/ruledoctest/other-ruleset.xml"));        assertEquals(3, writer.getData().size());        FileEntry languageIndex = writer.getData().get(0);        assertTrue(FilenameUtils.normalize(languageIndex.getFilename(), true).endsWith("docs/pages/pmd/rules/java.md"));        assertEquals(loadResource("/expected/java.md"), languageIndex.getContent());        FileEntry ruleSetIndex = writer.getData().get(1);        assertTrue(FilenameUtils.normalize(ruleSetIndex.getFilename(), true).endsWith("docs/pages/pmd/rules/java/sample.md"));        assertEquals(loadResource("/expected/sample.md"), ruleSetIndex.getContent());        FileEntry sidebar = writer.getData().get(2);        assertTrue(FilenameUtils.normalize(sidebar.getFilename(), true).endsWith("docs/_data/sidebars/pmd_sidebar.yml"));        assertEquals(loadResource("/expected/pmd_sidebar.yml"), sidebar.getContent());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import java.nio.file.FileSystems;import java.nio.file.Path;import java.util.Iterator;import java.util.List;import org.apache.commons.io.FilenameUtils;import org.junit.Test;import net.sourceforge.pmd.RuleSetLoader;public class RuleSetResolverTest {    private static final List<String> EXCLUDED_RULESETS = listOf(        FilenameUtils.normalize("pmd-test/src/main/resources/rulesets/dummy/basic.xml")    );    @Test    public void resolveAllRulesets() {        Path basePath = FileSystems.getDefault().getPath(".").resolve("..").toAbsolutePath().normalize();        List<String> additionalRulesets = GenerateRuleDocsCmd.findAdditionalRulesets(basePath);        filterRuleSets(additionalRulesets);        for (String filename : additionalRulesets) {            new RuleSetLoader().loadFromResource(filename); // will throw if invalid        }    }    private void filterRuleSets(List<String> additionalRulesets) {        Iterator<String> it = additionalRulesets.iterator();        while (it.hasNext()) {            String filename = it.next();            for (String exclusion : EXCLUDED_RULESETS) {                if (filename.endsWith(exclusion)) {                    it.remove();                    break;                }            }        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import java.nio.file.FileSystems;import java.util.List;import org.junit.Assert;import org.junit.Test;public class RuleTagCheckerTest {    @Test    public void testAllChecks() throws Exception {        RuleTagChecker checker = new RuleTagChecker(FileSystems.getDefault().getPath("src/test/resources/ruletagchecker"));        List<String> issues = checker.check();        Assert.assertEquals(7, issues.size());        Assert.assertEquals("ruletag-examples.md: 9: Rule tag for \"java/bestpractices/AvoidPrintStackTrace\" is not closed properly",                issues.get(0));        Assert.assertEquals("ruletag-examples.md:12: Rule \"java/notexistingcategory/AvoidPrintStackTrace\" is not found",                issues.get(1));        Assert.assertEquals("ruletag-examples.md:14: Rule \"java/bestpractices/NotExistingRule\" is not found",                issues.get(2));        Assert.assertEquals("ruletag-examples.md:16: Rule tag for \"java/bestpractices/OtherRule has a missing quote",                issues.get(3));        Assert.assertEquals("ruletag-examples.md:17: Rule tag for java/bestpractices/OtherRule\" has a missing quote",                issues.get(4));        Assert.assertEquals("ruletag-examples.md:21: Rule tag for \"OtherRule has a missing quote", issues.get(5));        Assert.assertEquals("ruletag-examples.md:22: Rule tag for OtherRule\" has a missing quote", issues.get(6));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.docs;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.List;import org.junit.Test;public class EscapeUtilsTest {    @Test    public void testEscapeMarkdown() {        assertEquals("This is a \\\\backslash", EscapeUtils.escapeMarkdown("This is a \\backslash"));        assertEquals("This \"\\*\" is not a emphasis", EscapeUtils.escapeMarkdown("This \"*\" is not a emphasis"));        assertEquals("This \"\\*\\*\" is not a strong style", EscapeUtils.escapeMarkdown("This \"**\" is not a strong style"));        assertEquals("This \"\\[foo\\]\" does not start a link", EscapeUtils.escapeMarkdown("This \"[foo]\" does not start a link"));        assertEquals("This \"\\~bar\\~\" is not a strike-through", EscapeUtils.escapeMarkdown("This \"~bar~\" is not a strike-through"));        assertEquals("That's \"\\|\" just a bar", EscapeUtils.escapeMarkdown("That's \"|\" just a bar"));        assertEquals("This \"\\_\" is just a underscore", EscapeUtils.escapeMarkdown("This \"_\" is just a underscore"));    }    @Test    public void testEscapeHtmlWithinMarkdownSingleLine() {        assertEquals("a &lt;script&gt; tag outside of `<script>` backticks should be escaped",                EscapeUtils.escapeSingleLine("a <script> tag outside of `<script>` backticks should be escaped"));        assertEquals("a &lt;script&gt; &quot;tag&quot; outside of `<script>` backticks should be escaped &lt;multiple&gt; times `<strong>`.",                EscapeUtils.escapeSingleLine("a <script> \"tag\" outside of `<script>` backticks should be escaped <multiple> times `<strong>`."));        assertEquals("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links",                EscapeUtils.escapeSingleLine("URLS: a https://pmd.github.io or a <https://pmd.github.io> are turned into links"));        assertEquals("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links",                EscapeUtils.escapeSingleLine("multiple URLS: <https://pmd.github.io> and <https://pmd.github.io> are two links"));        assertEquals("URL: <http://www.google.com> is a url without ssl",                EscapeUtils.escapeSingleLine("URL: <http://www.google.com> is a url without ssl"));        assertEquals("> this is a quote line",                EscapeUtils.escapeSingleLine("> this is a quote line"));        assertEquals("combination of URLs and backticks: <https://pmd.github.io> but `<script>` &lt;strong&gt;escaped&lt;/strong&gt;",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: <https://pmd.github.io> but `<script>` <strong>escaped</strong>"));        assertEquals("combination of URLs and backticks: `<script>` &lt;strong&gt;escaped&lt;/strong&gt; but <https://pmd.github.io>",                EscapeUtils.escapeSingleLine("combination of URLs and backticks: `<script>` <strong>escaped</strong> but <https://pmd.github.io>"));    }    @Test    public void testEscapeHtmlWithinMarkdownBlocks() {        String text = "paragraph\n\n> quote <script>\n> quote line \"2\"\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        String expected = "paragraph\n\n> quote &lt;script&gt;\n> quote line &quot;2&quot;\n>quote line `<script>` 3\n\n"                + "next paragraph\n\n    code <script> \"a < b\"\n    code line 2\n\n"                + "next paragraph\n\n```\ncode <script> \"a < b\"\ncode line 2\n```\n\n"                + "next paragraph\n\n```java\nString = \"code <script> with syntax highlighting\";\ncode line 2\n```\n";        List<String> escaped = EscapeUtils.escapeLines(Arrays.asList(text.split("\n")));        assertEquals(Arrays.asList(expected.split("\n")), escaped);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import javax.xml.transform.Source;import org.junit.Assert;import org.junit.Test;/** * * @author sturton */public class ResourceResolverTest {    /**     * Test of resolve method, of class ResourceResolver.     */    @Test    public void testResolve() throws Exception {        System.out.println("resolve");        String href = "";        String base = "";        ResourceResolver instance = new ResourceResolver();        Source expResult = null;        Source result = instance.resolve(href, base);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.File;import java.io.FileOutputStream;import java.io.PrintStream;import java.util.Map.Entry;import java.util.Properties;import java.util.ResourceBundle;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;/** * * @author sturton */public class DBTypeTest {    private File absoluteFile;    private Properties testProperties;    private Properties includeProperties;    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Before    public void setUp() throws Exception {        testProperties = new Properties();        testProperties.put("prop1", "value1");        testProperties.put("prop2", "value2");        testProperties.put("prop3", "value3");        includeProperties = new Properties();        includeProperties.putAll(testProperties);        includeProperties.put("prop3", "include3");        absoluteFile = folder.newFile();        try (FileOutputStream fileOutputStream = new FileOutputStream(absoluteFile);             PrintStream printStream = new PrintStream(fileOutputStream)) {            for (Entry<?, ?> entry : testProperties.entrySet()) {                printStream.printf("%s=%s\n", entry.getKey(), entry.getValue());            }        }    }    @After    public void tearDown() throws Exception {        testProperties = null;    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetPropertiesFromFile() throws Exception {        System.out.println("getPropertiesFromFile");        DBType instance = new DBType(absoluteFile.getAbsolutePath());        Properties expResult = testProperties;        Properties result = instance.getProperties();        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetProperties() throws Exception {        System.out.println("testGetProperties");        DBType instance = new DBType("test");        Properties expResult = testProperties;        System.out.println("testGetProperties: expected results " + testProperties);        Properties result = instance.getProperties();        System.out.println("testGetProperties: actual results " + result);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getProperties method, of class DBType.     */    @Test    public void testGetIncludeProperties() throws Exception {        System.out.println("testGetIncludeProperties");        DBType instance = new DBType("include");        Properties expResult = includeProperties;        System.out.println("testGetIncludeProperties: expected results " + includeProperties);        Properties result = instance.getProperties();        System.out.println("testGetIncludeProperties: actual results " + result);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getResourceBundleAsProperties method, of class DBType.     */    @Test    public void testAsProperties() {        System.out.println("asProperties");        ResourceBundle bundle = ResourceBundle.getBundle(DBType.class.getPackage().getName() + ".test");        Properties expResult = testProperties;        Properties result = DBType.getResourceBundleAsProperties(bundle);        Assert.assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.InputStream;import org.junit.Assert;import org.junit.Test;/** * * @author sturton */public class ResourceLoaderTest {    /**     * Test of getResourceStream method, of class ResourceLoader.     */    @Test    public void testGetResourceStream() throws Exception {        System.out.println("getResourceStream");        String path = "";        ResourceLoader instance = new ResourceLoader();        InputStream expResult = null;        InputStream result = instance.getResourceStream(path);        Assert.assertNotNull(result);        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import static org.junit.Assert.assertEquals;import java.net.URI;import java.net.URISyntaxException;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Test;/** * * @author sturton */public class DBURITest {    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    /*     * Expected values from testdefaults.properties     */    static final String C_DEFAULT_USER = "scott";    static final String C_DEFAULT_PASSWORD = "tiger";    static final String C_DEFAULT_LANGUAGES = "java,plsql";    static final String C_DEFAULT_SCHEMAS = "scott,system";    static final String C_DEFAULT_SOURCE_CODE_TYPES = "table,view";    static final String C_DEFAULT_SOURCE_CODE_NAMES = "emp,dept";    static final String C_DEFAULT_CHARACTERSET = "utf8";    /**     * Fully specified URI, overriding defaults in testdefaults.properties     */    static final String C_TEST_EXPLICIT = "jdbc:oracle:testdefault:system/oracle@//192.168.100.21:1521/ORCL?characterset=us7ascii&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    /*     * Expected values from testdefaults.properties, with values overridden by     * URI query parameters     */    static final String C_EXPLICIT_USER = "system";    static final String C_EXPLICIT_PASSWORD = "oracle";    static final String C_EXPLICIT_LANGUAGES = "plsql,java";    static final String C_EXPLICIT_SCHEMAS = "scott,hr,sh,system";    static final String C_EXPLICIT_SOURCE_CODE_TYPES = "procedures,functions,triggers,package,types";    static final String C_EXPLICIT_SOURCE_CODE_NAMES = "PKG_%%,PRC_%%";    static final String C_EXPLICIT_CHARACTERSET = "us7ascii";    static final String C_TEST_URI = "test?param1=x%261&param2=&param3=";    static final String C_ORACLE_OCI_1 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_OCI_2 = "jdbc:oracle:oci:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_OCI_3 = "jdbc:oracle:oci:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL";    static final String C_ORACLE_THIN_2 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:system/oracle@//myserver.com:1521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java&sourcecodenames=PKG_%25%25,PRC_%25%25";    static final String C_POSTGRES_1 = "jdbc:postgresql://host/database";    static final String C_HTTP = "http://localhost:80?characterset=utf8&schemas=scott,hr,sh,system&sourcecodetypes=procedures,functions,triggers,package,types&languages=plsql,java";    static void dump(String description, URI dburi) {        System.err.printf(                "Test %s\n: isOpaque=%s, isAbsolute=%s Scheme=%s,\n SchemeSpecificPart=%s,\n Host=%s,\n Port=%s,\n Path=%s,\n Fragment=%s,\n Query=%s\n",                description, dburi.isOpaque(), dburi.isAbsolute(), dburi.getScheme(), dburi.getSchemeSpecificPart(),                dburi.getHost(), dburi.getPort(), dburi.getPath(), dburi.getFragment(), dburi.getQuery());        String query = dburi.getQuery();        if (null != query && !"".equals(query)) {            String[] params = query.split("&");            Map<String, String> map = new HashMap<>();            for (String param : params) {                String[] splits = param.split("=");                String name = splits[0];                String value = null;                if (splits.length > 1) {                    value = splits[1];                }                map.put(name, value);                System.err.printf("name=%s,value=%s\n", name, value);            }        }        // return map;    }    /**     * Test of dump method, of class DBURI.     */    @Test    public void testDump() throws URISyntaxException, Exception {        System.out.println("dump");        String description = "";        DBURI dburi = new DBURI(C_TEST_URI);        DBURI.dump(description, dburi.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getUri method, of class DBURI.     */    @Test    public void testGetUri() throws URISyntaxException, Exception {        System.out.println("getUri");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        URI expResult = new URI(C_ORACLE_OCI_1);        URI result = instance.getUri();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setUri method, of class DBURI.     */    @Test    public void testSetUri() throws URISyntaxException, Exception {        System.out.println("setUri");        URI uri = new URI(C_ORACLE_OCI_1);        DBURI instance = new DBURI(C_TEST_URI);        instance.setUri(uri);        assertEquals(uri, instance.getUri());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    public void testGetDbType() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_POSTGRES_1);        DBType expResult = new DBType("postgresql");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDbType method, of class DBURI.     */    @Test    public void testGetDbType2() throws URISyntaxException, Exception {        System.out.println("getDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        DBType expResult = new DBType("oci");        DBType result = instance.getDbType();        // assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDbType method, of class DBURI.     */    @Test    public void testSetDbType() throws URISyntaxException, Exception {        System.out.println("setDbType");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        DBType dbType = new DBType("postgresql");        instance.setDbType(dbType);        assertEquals(dbType, instance.getDbType());        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSchemasList method, of class DBURI.     */    @Test    public void testGetSchemasList() throws URISyntaxException, Exception {        System.out.println("getSchemasList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult;        expResult = Arrays.asList("scott,hr,sh,system".split(","));        List<String> result = instance.getSchemasList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSchemasList method, of class DBURI.     */    @Test    public void testSetSchemasList() throws URISyntaxException, Exception {        System.out.println("setSchemasList");        List<String> schemasList = Arrays.asList("scott,hr,sh,system".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSchemasList(schemasList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeTypesList method, of class DBURI.     */    @Test    public void testGetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeTypesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("procedures,functions,triggers,package,types".split(","));        List<String> result = instance.getSourceCodeTypesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeTypesList method, of class DBURI.     */    @Test    public void testSetSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeTypesList");        List<String> sourcecodetypesList = Arrays.asList("procedures,functions,triggers,package,types".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeTypesList(sourcecodetypesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeNamesList method, of class DBURI.     */    @Test    public void testGetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("getSourceCodeNamesList");        DBURI instance = new DBURI(C_ORACLE_OCI_3);        List<String> expResult = Arrays.asList("PKG_%%,PRC_%%".split(","));        List<String> result = instance.getSourceCodeNamesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeNamesList method, of class DBURI.     */    @Test    public void testSetSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("setSourceCodeNamesList");        List<String> sourceCodeNamesList = Arrays.asList("PKG_%%,TRG_%%".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSourceCodeNamesList(sourceCodeNamesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getLanguagesList method, of class DBURI.     */    @Test    public void testGetLanguagesList() throws URISyntaxException, Exception {        System.out.println("getLanguagesList");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        List<String> expResult = Arrays.asList("plsql,java".split(","));        List<String> result = instance.getLanguagesList();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setLanguagesList method, of class DBURI.     */    @Test    public void testSetLanguagesList() throws URISyntaxException, Exception {        System.out.println("setLanguagesList");        List<String> languagesList = Arrays.asList("plsql,java".split(","));        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setLanguagesList(languagesList);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    public void testGetDriverClass() throws URISyntaxException, Exception {        System.out.println("getDriverClass");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetDriverClass: driverClass=" + result);        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getDriverClass method, of class DBURI.     */    @Test    public void testGetThinDriverClass() throws URISyntaxException, Exception {        System.out.println("getThinDriverClass");        DBURI instance = new DBURI(C_ORACLE_THIN_1);        String expResult = "oracle.jdbc.OracleDriver";        String result = instance.getDriverClass();        System.out.println("testGetThinDriverClass: driverClass=" + result);        System.out.println("testGetThinDriverClass: getDbType().getProperties() follows");        System.out                .println("testGetThinDriverClass: getDbType().getProperties()=" + instance.getDbType().getProperties());        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setDriverClass method, of class DBURI.     */    @Test    public void testSetDriverClass() throws URISyntaxException, Exception {        System.out.println("setDriverClass");        String driverClass = "oracle.jdbc.driver.OracleDriver";        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setDriverClass(driverClass);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getCharacterSet method, of class DBURI.     */    @Test    public void testGetCharacterSet() throws URISyntaxException, Exception {        System.out.println("getCharacterSet");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "utf8";        String result = instance.getCharacterSet();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setCharacterSet method, of class DBURI.     */    @Test    public void testSetCharacterSet() throws URISyntaxException, Exception {        System.out.println("setCharacterSet");        String characterSet = "utf8";        DBURI instance = new DBURI(C_POSTGRES_1);        instance.setCharacterSet(characterSet);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCodeType method, of class DBURI.     */    @Test    public void testGetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("getSourceCodeType");        DBURI instance = new DBURI(C_ORACLE_OCI_1);        int expResult = 2005; // CLOB        int result = instance.getSourceCodeType();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSourceCodeType method, of class DBURI.     */    @Test    public void testSetSourceCodeType() throws URISyntaxException, Exception {        System.out.println("setSourceCodeType");        int sourceCodeType = 5;        DBURI instance = new DBURI(C_ORACLE_OCI_1);        instance.setSourceCodeType(sourceCodeType);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubprotocol method, of class DBURI.     */    @Test    public void testGetSubprotocol() throws URISyntaxException, Exception {        System.out.println("getSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oracle";        String result = instance.getSubprotocol();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubprotocol method, of class DBURI.     */    public void testSetSubprotocol() throws URISyntaxException, Exception {        System.out.println("setSubprotocol");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String subprotocol = "oracle";        instance.setSubprotocol(subprotocol);        String result = instance.getSubprotocol();        assertEquals(subprotocol, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSubnamePrefix method, of class DBURI.     */    @Test    public void testGetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("getSubnamePrefix");        DBURI instance = new DBURI(C_ORACLE_OCI_2);        String expResult = "oci";        String result = instance.getSubnamePrefix();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setSubnamePrefix method, of class DBURI.     */    @Test    public void testSetSubnamePrefix() throws URISyntaxException, Exception {        System.out.println("setSubnamePrefix");        String subnamePrefix = "oci8";        DBURI instance = new DBURI(C_ORACLE_OCI_2);        instance.setSubnamePrefix(subnamePrefix);        String result = instance.getSubnamePrefix();        assertEquals(subnamePrefix, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getParameters method, of class DBURI.     */    @Test    public void testGetParameters() throws URISyntaxException, Exception {        System.out.println("getParameters");        DBURI instance = new DBURI(C_TEST_URI);        Map<String, String> expResult = new HashMap<>();        expResult.put("param1", "x&1");        expResult.put("param2", null);        expResult.put("param3", null);        Map<String, String> result = instance.getParameters();        assertEquals(expResult, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of setParameters method, of class DBURI.     */    @Test    public void testSetParameters() throws URISyntaxException, Exception {        System.out.println("setParameters");        Map<String, String> parameters = new HashMap<>();        parameters.put("param1", "x%FFF");        parameters.put("param2", "IAmParameter2");        parameters.put("param3", "IAmParameter3");        DBURI instance = new DBURI(C_TEST_URI);        instance.setParameters(parameters);        // TODO review the generated test code and remove the default call to        // fail.        assertEquals(parameters, instance.getParameters());    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultLanguagesList() throws URISyntaxException, Exception {        System.out.println("testDefaultLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_DEFAULT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default CharacterSet are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultCharacterSet() throws URISyntaxException, Exception {        System.out.println("testDefaultCharacterSet");        DBURI instance = new DBURI(C_TEST_DEFAULTS);        String result = instance.getCharacterSet();        assertEquals(C_DEFAULT_CHARACTERSET, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultSchemasList() throws URISyntaxException, Exception {        System.out.println("testDefaultSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_DEFAULT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default Source Code Types are returned if non are provided in     * the DBURI.     */    @Test    public void testDefaultSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that default languages are returned if non are provided in the     * DBURI.     */    @Test    public void testDefaultSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testDefaultSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_DEFAULT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_DEFAULTS);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitLanguagesList() throws URISyntaxException, Exception {        System.out.println("testExplicitLanguagesList");        List<String> defaultLanguagesList = Arrays.asList(C_EXPLICIT_LANGUAGES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getLanguagesList();        assertEquals(defaultLanguagesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that CharacterSet are returned if provided in the DBURI.     */    @Test    public void testExplicitCharacterSet() throws URISyntaxException, Exception {        System.out.println("testExplicitCharacterSet");        DBURI instance = new DBURI(C_TEST_EXPLICIT);        String result = instance.getCharacterSet();        assertEquals(C_EXPLICIT_CHARACTERSET, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitSchemasList() throws URISyntaxException, Exception {        System.out.println("testExplicitSchemasList");        List<String> defaultSchemasList = Arrays.asList(C_EXPLICIT_SCHEMAS.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSchemasList();        assertEquals(defaultSchemasList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that Source Code Types are returned if provided in the DBURI.     */    @Test    public void testExplicitSourceCodeTypesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeTypesList");        List<String> defaultSourceCodeTypesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_TYPES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeTypesList();        assertEquals(defaultSourceCodeTypesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }    /**     * Verify that languages are returned if provided in the DBURI.     */    @Test    public void testExplicitSourceCodeNamesList() throws URISyntaxException, Exception {        System.out.println("testExplicitSourceCodeNamesList");        List<String> defaultSourceCodeNamesList = Arrays.asList(C_EXPLICIT_SOURCE_CODE_NAMES.split(","));        DBURI instance = new DBURI(C_TEST_EXPLICIT);        List<String> result = instance.getSourceCodeNamesList();        assertEquals(defaultSourceCodeNamesList, result);        // TODO review the generated test code and remove the call to fail.        // fail("The test case is a prototype.");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.database;import java.io.IOException;import java.io.Reader;import java.net.URISyntaxException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.ResultSetMetaData;import java.sql.SQLException;import java.util.List;import java.util.Properties;import java.util.logging.Level;import java.util.logging.Logger;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;/** * * @author sturton */@Ignorepublic class DBMSMetadataTest {    static final String C_ORACLE_THIN_1 = "jdbc:oracle:thin:scott/tiger@//192.168.100.21:5521/customer_db?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_3 = "jdbc:oracle:thin:scott/oracle@//192.168.100.21:1521/orcl?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_4 = "jdbc:oracle:thin:system/oracle@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25";    static final String C_ORACLE_THIN_5 = "jdbc:oracle:thin:@//192.168.100.21:1521/ORCL?characterset=utf8&schemas=scott,hr,sh,system&objectTypes=procedures,functions,triggers,package,types&languages=plsql,java&name=PKG_%25%7C%7CPRC_%25&amp;user=system&amp;password=oracle";    /**     * URI with minimum information, relying on defaults in     * testdefaults.properties     */    static final String C_TEST_DEFAULTS = "jdbc:oracle:testdefault://192.168.100.21:1521/ORCL";    private DBURI dbURI;    private DBURI dbURI4;    private DBURI dbURI5;    private DBURI dbURIDefault;    public DBMSMetadataTest() throws URISyntaxException, Exception {        dbURI = new DBURI(C_ORACLE_THIN_3);        dbURI4 = new DBURI(C_ORACLE_THIN_4);        dbURI5 = new DBURI(C_ORACLE_THIN_5);        dbURIDefault = new DBURI(C_TEST_DEFAULTS);    }    /**     * Convert Readers to Strings for eay output and comparison.     */    private static String getStringFromReader(Reader reader) throws IOException {        StringBuilder stringBuilder = new StringBuilder(1024);        char[] charArray = new char[1024];        int readChars;        while ((readChars = reader.read(charArray)) > 0) {            System.out.println("Reader.read(CharArray)==" + readChars);            stringBuilder.append(charArray, 0, readChars);        }        reader.close();        return stringBuilder.toString();    }    /**     * Dump ResultSet     */    private static void dumpResultSet(ResultSet resultSet, String description) {        try {            ResultSetMetaData metaData = resultSet.getMetaData();            int columnCount = metaData.getColumnCount();            System.out.format("ResultSet \"%s\" has %d columns and contains ...\n[", description, columnCount);            /*             * Walk through the column names, writing out a header line             */            for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                System.out.format("%s%s", ((columnNumber > 1) ? "," : ""), metaData.getColumnName(columnNumber));            }            System.out.format("\n");            // Output each row            while (resultSet.next()) {                /*                 * Walk through the columns of this row, writing out a row line                 */                for (int columnNumber = 1; columnNumber <= columnCount; columnNumber++) {                    System.out.format("%s%s", ((columnNumber > 0) ? "," : ""), resultSet.getString(columnNumber));                }                System.out.format("\n");            }        } catch (SQLException ex) {            Logger.getLogger(DBMSMetadataTest.class.getName()).log(Level.SEVERE, null, ex);        }        System.out.format("...\n]\n");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @org.junit.Test    public void testGetConnection() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(dbURI.getURL()).connect(dbURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getConnection method, of class DBMSMetadata.     */    @Test    public void testGetConnectionWithConnectionParameters() throws Exception {        System.out.println("getConnection");        String driverClass = dbURI5.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + dbURI5.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(dbURI5.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.putAll(dbURI5.getParameters());        Connection expResult = DriverManager.getDriver(dbURI5.getURL()).connect(dbURI5.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(dbURI5);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Test of getSourceCode method, of class DBMSMetadata.     */    @Test    public void testGetSourceCode() throws Exception {        System.out.println("getSourceCode");        // String objectType = "PACKAGE";        // String name = "DBMS_REPCAT_AUTH";        // String schema = "SYSTEM";        String objectType = "TABLE";        String name = "EMP";        String schema = "SCOTT";        System.out.println("dbURI.driverClass==" + dbURI.getDriverClass());        System.out.println("dbURI.URL==" + dbURI.getURL());        System.out.println("dbURI.getDBType.getProperties()==" + dbURI.getDbType().getProperties());        System.out.println("dbURI.getDBType.getSourceCodeReturnType()==" + dbURI.getDbType().getSourceCodeReturnType());        System.out.println("dbURI.getDBType.getProperties()=="                + dbURI.getDbType().getProperties().getProperty("getSourceCodeStatement"));        DBMSMetadata instance = new DBMSMetadata(dbURI);        Reader expResult = null;        Reader result = instance.getSourceCode(objectType, name, schema);        /*         * StringBuilder stringBuilder = new StringBuilder(1024); char[]         * charArray = new char[1024]; int readChars = 0; while(( readChars =         * result.read(charArray)) > 0 ) {         * System.out.println("Reader.read(CharArray)=="+readChars);         * stringBuilder.append(charArray, 0, readChars); } result.close();         *         * System.out.println("getSourceCode()==\""+stringBuilder.toString()+         * "\"" );         *         * assertTrue(stringBuilder.toString().startsWith("\n  CREATE "));         */        String resultString = getStringFromReader(result);        System.out.println("getSourceCode()==\"" + resultString);        // TODO review the generated test code and remove the default call to        // fail.        // fail("The test case is a prototype.");    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    public void testGetSchemas() throws Exception {        System.out.println("getSchemas");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        ResultSet allSchemas = result.getMetaData().getSchemas();        dumpResultSet(allSchemas, "All Schemas");        ResultSet allCatalogues = result.getMetaData().getCatalogs();        dumpResultSet(allCatalogues, "All Catalogues");        String catalog = null;        String schemasPattern = "PHPDEMO";        String tablesPattern = null;        String proceduresPattern = null;        // Not until Java6 ResultSet matchedSchemas =        // result.getMetaData().getSchemas(catalog, schemasPattern) ;        // Not until Java6 dumpResultSet (matchedSchemas, "Matched Schemas") ;        ResultSet matchedTables = result.getMetaData().getTables(catalog, schemasPattern, tablesPattern, null);        dumpResultSet(matchedTables, "Matched Tables");        ResultSet matchedProcedures = result.getMetaData().getProcedures(catalog, schemasPattern, proceduresPattern);        dumpResultSet(matchedProcedures, "Matched Procedures");        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());    }    /**     * Verify getSchemas method, of class DBMSMetadata.     */    @Test    public void testGetSourceObjectList() throws Exception {        System.out.println("getConnection");        DBURI testURI = dbURI4;        String driverClass = testURI.getDriverClass();        System.out.println("driverClass==" + driverClass);        System.out.println("URL==" + testURI.getURL());        Class.forName(driverClass);        Object object = DriverManager.getDriver(testURI.getURL());        // Object object = DriverManager.getDriver(C_ORACLE_OCI_3) ;        Properties properties = new Properties();        properties.put("user", "system");        properties.put("password", "oracle");        Connection expResult = DriverManager.getDriver(testURI.getURL()).connect(testURI.getURL(), properties);        DBMSMetadata instance = new DBMSMetadata(testURI);        Connection result = instance.getConnection();        Assert.assertNotNull(result);        List<SourceObject> sourceObjectList = instance.getSourceObjectList();        Assert.assertNotNull(sourceObjectList);        System.out.format("testURI=%s,\ngetParameters()=%s\n", C_ORACLE_THIN_4, testURI.getParameters());        System.out.format(                "testURI=%s,\ngetSchemasList()=%s\n,getSourceCodeTypesList()=%s\n,getSourceCodeNmesList()=%s\n",                testURI, testURI.getSchemasList(), testURI.getSourceCodeTypesList(), testURI.getSourceCodeNamesList());        System.out.print("sourceObjectList ...\n");        for (SourceObject sourceObject : sourceObjectList) {            System.out.printf("sourceObject=%s\n", sourceObject);            System.out.printf("sourceCode=[%s]\n", getStringFromReader(instance.getSourceCode(sourceObject)));        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.hamcrest.MatcherAssert;import org.hamcrest.Matchers;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertySource;/** * */public class TreeRenderersTest {    @Rule    public ExpectedException expect = ExpectedException.none();    @Test    public void testStandardRenderersAreRegistered() {        Assert.assertEquals(TreeRenderers.XML, TreeRenderers.findById(TreeRenderers.XML.id()));    }    @Test    public void testXmlPropertiesAvailable() {        PropertySource properties = TreeRenderers.XML.newPropertyBundle();        MatcherAssert.assertThat(properties.getPropertyDescriptors(),                          Matchers.<PropertyDescriptor<?>>containsInAnyOrder(TreeRenderers.XML_LINE_SEPARATOR,                                                                             TreeRenderers.XML_RENDER_COMMON_ATTRIBUTES,                                                                             TreeRenderers.XML_RENDER_PROLOG,                                                                             TreeRenderers.XML_USE_SINGLE_QUOTES));    }    @Test    public void testXmlDescriptorDump() throws IOException {        PropertySource bundle = TreeRenderers.XML.newPropertyBundle();        bundle.setProperty(TreeRenderers.XML_RENDER_PROLOG, false);        bundle.setProperty(TreeRenderers.XML_USE_SINGLE_QUOTES, false);        bundle.setProperty(TreeRenderers.XML_LINE_SEPARATOR, "\n");        TreeRenderer renderer = TreeRenderers.XML.produceRenderer(bundle);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummyTree1(), out);        Assert.assertEquals("<dummyNode foo=\"bar\" ohio=\"4\">\n"                                + "    <dummyNode o=\"ha\" />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    public MyDummyNode dummyTree1() {        MyDummyNode dummy = new MyDummyNode();        dummy.setXPathAttribute("foo", "bar");        dummy.setXPathAttribute("ohio", "4");        MyDummyNode dummy1 = new MyDummyNode();        dummy1.setXPathAttribute("o", "ha");        MyDummyNode dummy2 = new MyDummyNode();        dummy.addChild(dummy1, 0);        dummy.addChild(dummy2, 1);        return dummy;    }    private static class MyDummyNode extends DummyNode {        private final Map<String, String> attributes = new HashMap<>();        public void setXPathAttribute(String name, String value) {            attributes.put(name, value);        }        @Override        public Iterator<Attribute> getXPathAttributesIterator() {            List<Attribute> attrs = new ArrayList<>();            for (String name : attributes.keySet()) {                attrs.add(new Attribute(this, name, attributes.get(name)));            }            return attrs.iterator();        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.treeexport;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.util.treeexport.XmlTreeRenderer.XmlRenderingConfig;/** */public class XmlTreeRendererTest {    @Rule    public ExpectedException expect = ExpectedException.none();    @Test    public void testRenderWithAttributes() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig();        strat.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testRenderWithCustomLineSep() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig();        strat.lineSeparator("\r\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\r\n"                                + "<dummyNode foo='bar' ohio='4'>\r\n"                                + "    <dummyNode o='ha' />\r\n"                                + "    <dummyNode />\r\n"                                + "</dummyNode>\r\n", out.toString());    }    @Test    public void testRenderWithCustomIndent() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("").indentWith("");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>"                                + "<dummyNode foo='bar' ohio='4'>"                                + "<dummyNode o='ha' />"                                + "<dummyNode />"                                + "</dummyNode>", out.toString());    }    @Test    public void testRenderWithNoAttributes() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig() {            @Override            public boolean takeAttribute(Node node, Attribute attribute) {                return false;            }        }.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode>\n"                                + "    <dummyNode />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testRenderFilterAttributes() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strategy = new XmlRenderingConfig() {            @Override            public boolean takeAttribute(Node node, Attribute attribute) {                return attribute.getName().equals("ohio");            }        }.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strategy);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode ohio='4'>\n"                                + "    <dummyNode />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testInvalidAttributeName() throws IOException {        MyDummyNode dummy = dummyTree1();        dummy.setXPathAttribute("&notAName", "foo");        XmlRenderingConfig config = new XmlRenderingConfig();        config.lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(config);        StringBuilder out = new StringBuilder();        expect.expect(IllegalArgumentException.class);        renderer.renderSubtree(dummy, out);    }    @Test    public void testEscapeAttributes() throws IOException {        MyDummyNode dummy = dummyTree1();        dummy.setXPathAttribute("eh", " 'a &> b\" ");        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n");        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>\n"                                + "<dummyNode eh=' &apos;a &amp;> b\" ' foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testEscapeDoubleAttributes() throws IOException {        MyDummyNode dummy = dummyTree1();        dummy.setXPathAttribute("eh", " 'a &> b\" ");        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n").singleQuoteAttributes(false);        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"                                + "<dummyNode eh=\" 'a &amp;> b&quot; \" foo=\"bar\" ohio=\"4\">\n"                                + "    <dummyNode o=\"ha\" />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testNoProlog() throws IOException {        DummyNode dummy = dummyTree1();        XmlRenderingConfig strat = new XmlRenderingConfig().lineSeparator("\n").renderProlog(false);        XmlTreeRenderer renderer = new XmlTreeRenderer(strat);        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<dummyNode foo='bar' ohio='4'>\n"                                + "    <dummyNode o='ha' />\n"                                + "    <dummyNode />\n"                                + "</dummyNode>\n", out.toString());    }    @Test    public void testDefaultLineSep() throws IOException {        DummyNode dummy = dummyTree1();        XmlTreeRenderer renderer = new XmlTreeRenderer();        StringBuilder out = new StringBuilder();        renderer.renderSubtree(dummy, out);        Assert.assertEquals("<?xml version='1.0' encoding='UTF-8' ?>" + System.lineSeparator()                                + "<dummyNode foo='bar' ohio='4'>" + System.lineSeparator()                                + "    <dummyNode o='ha' />" + System.lineSeparator()                                + "    <dummyNode />" + System.lineSeparator()                                + "</dummyNode>" + System.lineSeparator(), out.toString());    }    public MyDummyNode dummyTree1() {        MyDummyNode dummy = new MyDummyNode();        dummy.setXPathAttribute("foo", "bar");        dummy.setXPathAttribute("ohio", "4");        MyDummyNode dummy1 = new MyDummyNode();        dummy1.setXPathAttribute("o", "ha");        MyDummyNode dummy2 = new MyDummyNode();        dummy.addChild(dummy1, 0);        dummy.addChild(dummy2, 1);        return dummy;    }    private static class MyDummyNode extends DummyNode {        private final Map<String, String> attributes = new HashMap<>();        public void setXPathAttribute(String name, String value) {            attributes.put(name, value);        }        @Override        public Iterator<Attribute> getXPathAttributesIterator() {            List<Attribute> attrs = new ArrayList<>();            for (String name : attributes.keySet()) {                attrs.add(new Attribute(this, name, attributes.get(name)));            }            return attrs.iterator();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util.datasource;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.IOException;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class FileDataSourceTest {    @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();    private static final String SOMEFILE_DIR = "path/";    private static final String SOMEFILE_TXT = "somefile.txt";    private static final String SOMEFILE_TXT_FULL_PATH = SOMEFILE_DIR + SOMEFILE_TXT;    private FileDataSource ds;    private File someFile;    private File someFolder;    @Before    public void setup() throws IOException {        someFolder = tempFolder.newFolder(SOMEFILE_DIR);        someFile = tempFolder.newFile(SOMEFILE_TXT_FULL_PATH);        ds = new FileDataSource(someFile);    }    @Test    public void testShortNamesSingleFile() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFile.getAbsolutePath()));    }    @Test    public void testShortNamesSingleDir() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, someFolder.getAbsolutePath()));    }    @Test    public void testShortNamesNullBase() {        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, null));    }    @Test    public void testShortNamesCommaSeparatedDirs() {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }    @Test    public void testShortNamesCommaSeparatedFiles() {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }    @Test    public void testShortNamesCommaSeparatedMixed() {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(SOMEFILE_TXT, ds.getNiceFileName(true, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }    @Test    public void testLongNamesSingleFile() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFile.getAbsolutePath()));    }    @Test    public void testLongNamesSingleDir() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, someFolder.getAbsolutePath()));    }    @Test    public void testLongNamesNullBase() throws IOException {        assertEquals(someFile.getCanonicalFile().getAbsolutePath(), ds.getNiceFileName(false, null));    }    @Test    public void testLongNamesCommaSeparatedDirs() throws IOException {        // use 2 dirs, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_DIR + "," + someFolder.getAbsolutePath()));    }    @Test    public void testLongNamesCommaSeparatedFiles() throws IOException {        // use 2 files, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFile.getAbsolutePath()));    }    @Test    public void testLongNamesCommaSeparatedMixed() throws IOException {        // use a file and a dir, one relative (similar, but not resolving to the same location) and one absolute        assertEquals(someFile.getCanonicalFile().getAbsolutePath(),                ds.getNiceFileName(false, SOMEFILE_TXT_FULL_PATH + "," + someFolder.getAbsolutePath()));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static net.sourceforge.pmd.util.OptionalBool.NO;import static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;import static net.sourceforge.pmd.util.OptionalBool.YES;import static net.sourceforge.pmd.util.OptionalBool.definitely;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import org.junit.Test;public class OptionalBoolTest {    @Test    public void testDefinitely() {        assertEquals(YES, definitely(true));        assertEquals(NO, definitely(false));    }    @Test    public void testIsKnown() {        assertTrue(YES.isKnown());        assertTrue(NO.isKnown());        assertFalse(UNKNOWN.isKnown());    }    @Test    public void testIsTrue() {        assertTrue(YES.isTrue());        assertFalse(NO.isTrue());        assertFalse(UNKNOWN.isTrue());    }    @Test    public void testComplement() {        assertEquals(YES, NO.complement());        assertEquals(NO, YES.complement());        assertEquals(UNKNOWN, UNKNOWN.complement());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.util;import static org.junit.Assert.assertEquals;import org.junit.Test;public class StringUtilTest {    @Test    public void testColumnNumber() {        assertEquals(-1, StringUtil.columnNumberAt("f\rah\nb", -1));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 0));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 1));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 2));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 3));        assertEquals(3, StringUtil.columnNumberAt("f\rah\nb", 4));        assertEquals(1, StringUtil.columnNumberAt("f\rah\nb", 5));        assertEquals(2, StringUtil.columnNumberAt("f\rah\nb", 6));        assertEquals(-1, StringUtil.columnNumberAt("f\rah\nb", 7));    }    @Test    public void testColumnNumberCrLf() {        assertEquals(-1, StringUtil.columnNumberAt("f\r\nb", -1));        assertEquals(1, StringUtil.columnNumberAt("f\r\nb", 0));        assertEquals(2, StringUtil.columnNumberAt("f\r\nb", 1));        assertEquals(3, StringUtil.columnNumberAt("f\r\nb", 2));        assertEquals(1, StringUtil.columnNumberAt("f\r\nb", 3));        assertEquals(2, StringUtil.columnNumberAt("f\r\nb", 4));        assertEquals(-1, StringUtil.columnNumberAt("f\r\nb", 5));    }    @Test    public void testColumnNumberTrailing() {        assertEquals(1, StringUtil.columnNumberAt("\n", 0));        assertEquals(2, StringUtil.columnNumberAt("\n", 1));        assertEquals(-1, StringUtil.columnNumberAt("\n", 2));    }    @Test    public void testColumnNumberEmpty() {        assertEquals(1, StringUtil.columnNumberAt("", 0));        assertEquals(-1, StringUtil.columnNumberAt("", 1));    }    @Test    public void testUTF8NotSupported() {        StringBuilder sb = new StringBuilder();        String test = "";        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#xe9;", sb.toString());    }    @Test    public void testUTF8NotSupportedSurrogates() {        // D8 34 DD 1E -> U+1D11E        StringBuilder sb = new StringBuilder();        String test = new String(new char[] {0xd834, 0xdd1e});        StringUtil.appendXmlEscaped(sb, test, false);        assertEquals("&#x1d11e;", sb.toString());    }    @Test    public void testUTF8Supported() {        StringBuilder sb = new StringBuilder();        String test = "";        StringUtil.appendXmlEscaped(sb, test, true);        assertEquals("", sb.toString());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.internal.util;import static java.util.Collections.emptyIterator;import static org.hamcrest.collection.IsIterableContainingInOrder.contains;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertThat;import static org.junit.Assert.assertTrue;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.NoSuchElementException;import java.util.Objects;import java.util.function.Consumer;import java.util.function.Function;import java.util.function.Predicate;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;public class IteratorUtilTest {    @Rule    public ExpectedException exception = ExpectedException.none();    @Test    public void testAnyMatchPos() {        Iterator<String> iter = iterOf("a", "b", "cd");        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    public void testAnyMatchNeg() {        Iterator<String> iter = iterOf("a", "b", "");        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    public void testAnyMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.anyMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    public void testAllMatchPos() {        Iterator<String> iter = iterOf("ap", "bcd", "cd");        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    public void testAllMatchNeg() {        Iterator<String> iter = iterOf("a", "bcd", "");        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertFalse(match);    }    @Test    public void testAllMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.allMatch(iter, it -> it.length() > 1);        assertTrue(match);    }    @Test    public void testNoneMatchPos() {        Iterator<String> iter = iterOf("ap", "bcd", "cd");        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertTrue(match);    }    @Test    public void testNoneMatchNeg() {        Iterator<String> iter = iterOf("a", "bcd", "");        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertFalse(match);    }    @Test    public void testNoneMatchEmpty() {        Iterator<String> iter = emptyIterator();        boolean match = IteratorUtil.noneMatch(iter, it -> it.length() < 1);        assertTrue(match);    }    @Test    public void testFlatmap() {        Iterator<String> iter = iterOf("ab", "cd", "e", "", "f");        Function<String, Iterator<String>> fun = s -> s.chars().mapToObj(i -> (char) i).map(String::valueOf).iterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertThat(() -> mapped, contains("a", "b", "c", "d", "e", "f"));    }    @Test    public void testFlatmapEmpty() {        Iterator<String> iter = emptyIterator();        Function<String, Iterator<String>> fun = s -> s.chars().mapToObj(i -> (char) i).map(String::valueOf).iterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    public void testFlatmapEmpty2() {        Iterator<String> iter = iterOf("ab", "cd", "e", "", "f");        Function<String, Iterator<String>> fun = s -> emptyIterator();        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    public void testFlatmapIsLazy() {        Iterator<String> iter = iterOf("a", "b");        Function<String, Iterator<String>> fun = s -> {            if (s.equals("a")) {                return iterOf("a");            } else {                throw new AssertionError("This statement shouldn't be reached");            }        };        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertTrue(mapped.hasNext());        assertEquals("a", mapped.next());        exception.expect(AssertionError.class);        assertTrue(mapped.hasNext());    }    @Test    public void testFlatmapWithSelf() {        Iterator<String> iter = iterOf("ab", "e", null, "f");        Function<String, Iterator<String>> fun = s -> s == null ? null // test null safety                                                                : iterOf(s + "1", s + "2");        Iterator<String> mapped = IteratorUtil.flatMapWithSelf(iter, fun);        assertThat(IteratorUtil.toList(mapped), contains("ab", "ab1", "ab2", "e", "e1", "e2", null, "f", "f1", "f2"));    }    @Test    public void testMapNotNull() {        Iterator<String> iter = iterOf("ab", "cdde", "e", "", "f", "fe");        Function<String, Integer> fun = s -> s.length() < 2 ? null : s.length();        Iterator<Integer> mapped = IteratorUtil.mapNotNull(iter, fun);        assertThat(() -> mapped, contains(2, 4, 2));    }    @Test    public void testMapNotNullEmpty() {        Iterator<String> iter = emptyIterator();        Function<String, Integer> fun = s -> s.length() < 2 ? null : s.length();        Iterator<Integer> mapped = IteratorUtil.mapNotNull(iter, fun);        assertExhausted(mapped);    }    @Test    public void testMapNotNullEmpty2() {        Iterator<String> iter = iterOf("a", "b");        Function<String, Iterator<String>> fun = s -> null;        Iterator<String> mapped = IteratorUtil.flatMap(iter, fun);        assertExhausted(mapped);    }    @Test    public void testFilterNotNull() {        Iterator<String> iter = iterOf("ab", null, "e", null, "", "fe");        Iterator<String> mapped = IteratorUtil.filterNotNull(iter);        assertThat(() -> mapped, contains("ab", "e", "", "fe"));        assertExhausted(iter);    }    @Test    public void testDistinct() {        Iterator<String> iter = iterOf("ab", null, "e", null, "fe", "ab", "c");        Iterator<String> mapped = IteratorUtil.distinct(iter);        assertThat(() -> mapped, contains("ab", null, "e", "fe", "c"));        assertExhausted(iter);    }    @Test    public void testTakeWhile() {        Iterator<String> iter = iterOf("ab", "null", "e", null, "", "fe");        Predicate<String> predicate = Objects::nonNull;        Iterator<String> mapped = IteratorUtil.takeWhile(iter, predicate);        assertThat(() -> mapped, contains("ab", "null", "e"));        assertExhausted(mapped);    }    @Test    public void testTakeWhileWithEmpty() {        Iterator<String> iter = iterOf();        Predicate<String> predicate = Objects::nonNull;        Iterator<String> mapped = IteratorUtil.takeWhile(iter, predicate);        assertExhausted(mapped);    }    @Test    public void testPeek() {        Iterator<String> iter = iterOf("ab", null, "c");        List<String> seen = new ArrayList<>();        Consumer<String> action = seen::add;        Iterator<String> mapped = IteratorUtil.peek(iter, action);        assertEquals("ab", mapped.next());        assertThat(seen, contains("ab"));        assertNull(mapped.next());        assertThat(seen, contains("ab", null));        assertEquals("c", mapped.next());        assertThat(seen, contains("ab", null, "c"));        assertExhausted(mapped);    }    @Test    public void testTakeNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        exception.expect(IllegalArgumentException.class);        IteratorUtil.take(iter, -5);    }    @Test    public void testTake0() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 0);        assertExhausted(mapped);    }    @Test    public void testTake() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 1);        assertThat(() -> mapped, contains("a"));        assertExhausted(mapped);    }    @Test    public void testTakeOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.take(iter, 12);        assertThat(() -> mapped, contains("a", "b", "c"));        assertExhausted(mapped);    }    @Test    public void testDropNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        exception.expect(IllegalArgumentException.class);        IteratorUtil.advance(iter, -5);    }    @Test    public void testDrop0() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 0);        assertThat(() -> mapped, contains("a", "b", "c"));        assertExhausted(mapped);    }    @Test    public void testDrop() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 1);        assertThat(() -> mapped, contains("b", "c"));        assertExhausted(mapped);    }    @Test    public void testDropOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        Iterator<String> mapped = IteratorUtil.drop(iter, 12);        assertExhausted(mapped);    }    @Test    public void testGetNegative() {        Iterator<String> iter = iterOf("a", "b", "c");        exception.expect(IllegalArgumentException.class);        IteratorUtil.getNth(iter, -5);    }    @Test    public void testGet0() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 0);        assertEquals("a", elt);    }    @Test    public void testGetNth() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 1);        assertEquals("b", elt);    }    @Test    public void testGetOverflow() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.getNth(iter, 12);        assertNull(elt);    }    @Test    public void testLast() {        Iterator<String> iter = iterOf("a", "b", "c");        String elt = IteratorUtil.last(iter);        assertEquals("c", elt);        assertExhausted(iter);    }    @Test    public void testLastEmpty() {        Iterator<String> iter = emptyIterator();        String elt = IteratorUtil.last(iter);        assertNull(elt);    }    @Test    public void testCount() {        Iterator<String> iter = iterOf("a", "b", "c");        int size = IteratorUtil.count(iter);        assertEquals(size, 3);        assertExhausted(iter);    }    @Test    public void testCountEmpty() {        Iterator<String> iter = emptyIterator();        int size = IteratorUtil.count(iter);        assertEquals(size, 0);    }    @Test    public void testToList() {        Iterator<String> iter = iterOf("a", "b", "c");        List<String> lst = IteratorUtil.toList(iter);        assertEquals(lst, listOf("a", "b", "c"));        assertExhausted(iter);    }    @Test    public void testAsReversed() {        List<String> iter = listOf("a", "b", "c");        Iterable<String> mapped = IteratorUtil.asReversed(iter);        assertThat(mapped, contains("c", "b", "a"));    }    @Test    public void testAsReversedIsRepeatable() {        List<String> iter = listOf("a", "b", "c");        Iterable<String> mapped = IteratorUtil.asReversed(iter);        // doesn't exhaust iterator        assertThat(mapped, contains("c", "b", "a"));        assertThat(mapped, contains("c", "b", "a"));        assertThat(mapped, contains("c", "b", "a"));    }    private void assertExhausted(Iterator<?> mapped) {        assertFalse(mapped.hasNext());        exception.expect(NoSuchElementException.class);        mapped.next();    }    static <T> Iterator<T> iterOf(T... ts) {        return Arrays.asList(ts).iterator();    }    static <T> List<T> listOf(T... ts) {        return Arrays.asList(ts);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.internal;import java.io.StringReader;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.PMDException;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.Parser;import net.sourceforge.pmd.lang.ast.AstProcessingStage;import net.sourceforge.pmd.lang.ast.DummyAstStages;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.rule.AbstractRule;public class StageDependencyTest {    private final LanguageVersion version = LanguageRegistry.findLanguageByTerseName("dummy").getVersion("1.0");    private DummyNode process(String source, RuleSets ruleSets) {        PMDConfiguration configuration = new PMDConfiguration();        return process(source, ruleSets, new RulesetStageDependencyHelper(configuration), configuration);    }    private DummyNode process(String source, RuleSets ruleSets, RulesetStageDependencyHelper helper, PMDConfiguration configuration) {        RuleContext context = new RuleContext();        Parser parser = PMD.parserFor(version, configuration);        context.setLanguageVersion(version);        RootNode rootNode = (RootNode) parser.parse("dummyfile.dummy", new StringReader(source));        helper.runLanguageSpecificStages(ruleSets, version, rootNode);        return (DummyNode) rootNode;    }    @Test    public void testSimpleDependency() throws PMDException {        DummyNode root = process("foo bar", withRules(new PredicateTestRule(DummyAstStages.FOO)));        Assert.assertTrue(DummyAstStages.FOO.hasProcessed(root));        Assert.assertFalse(DummyAstStages.BAR.hasProcessed(root));    }    @Test    public void testNoDependency() throws PMDException {        DummyNode root = process("foo bar", withRules(new PredicateTestRule()));        Assert.assertFalse(DummyAstStages.FOO.hasProcessed(root));        Assert.assertFalse(DummyAstStages.BAR.hasProcessed(root));    }    @Test    public void testDependencyUnion() throws PMDException {        DummyNode root =            process("foo bar",                    withRules(                        new PredicateTestRule(DummyAstStages.FOO),                        new PredicateTestRule(DummyAstStages.BAR)                    )            );        Assert.assertTrue(DummyAstStages.FOO.hasProcessed(root));        Assert.assertTrue(DummyAstStages.BAR.hasProcessed(root));    }    @Test    public void testTransitiveDependency() throws PMDException {        DummyNode root = process("foo bar", withRules(new PredicateTestRule(DummyAstStages.RUNS_FOO)));        Assert.assertTrue(DummyAstStages.FOO.hasProcessed(root));        Assert.assertFalse(DummyAstStages.BAR.hasProcessed(root));        Assert.assertTrue(DummyAstStages.RUNS_FOO.hasProcessed(root));    }    @Test    public void testNoRecomputation() throws PMDException {        PMDConfiguration configuration = new PMDConfiguration();        RulesetStageDependencyHelper helper = new RulesetStageDependencyHelper(configuration);        RuleSets ruleSets = withRules(new PredicateTestRule(DummyAstStages.RUNS_FOO));        List<AstProcessingStage<?>> stages1 = helper.testOnlyGetDependencies(ruleSets, version);        process("foo bar", ruleSets);        List<AstProcessingStage<?>> stages2 = helper.testOnlyGetDependencies(ruleSets, version);        Assert.assertSame(stages1, stages2);    }    @Test    public void testDependencyOrdering() throws PMDException {        PMDConfiguration configuration = new PMDConfiguration();        RulesetStageDependencyHelper helper = new RulesetStageDependencyHelper(configuration);        RuleSets ruleSets = withRules(            new PredicateTestRule(DummyAstStages.FOO),            new PredicateTestRule(DummyAstStages.BAR)        );        RuleSets ruleSets2 = withRules(            new PredicateTestRule(DummyAstStages.BAR),            new PredicateTestRule(DummyAstStages.FOO)        );        List<AstProcessingStage<?>> stages1 = helper.testOnlyGetDependencies(ruleSets, version);        List<AstProcessingStage<?>> stages2 = helper.testOnlyGetDependencies(ruleSets2, version);        Assert.assertNotSame(stages1, stages2);        Assert.assertEquals(stages1, stages2);    }    private static RuleSets withRules(Rule r, Rule... rs) {        List<RuleSet> rsets = new ArrayList<>();        rsets.add(RuleSet.forSingleRule(r));        for (Rule rule : rs) {            rsets.add(RuleSet.forSingleRule(rule));        }        return new RuleSets(rsets);    }    private static class PredicateTestRule extends AbstractRule {        private final List<DummyAstStages> dependencies;        PredicateTestRule(DummyAstStages... dependencies) {            this.dependencies = Arrays.asList(dependencies);        }        @Override        public Language getLanguage() {            return LanguageRegistry.findLanguageByTerseName("dummy");        }        @Override        public boolean dependsOn(AstProcessingStage<?> stage) {            return dependencies.contains(stage);        }        @Override        public void apply(Node target, RuleContext ctx) {        }        @Override        public int hashCode() {            return 0;        }        @Override        public boolean equals(Object o) {            return this == o;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.processor;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleSetLoader;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.ThreadSafeReportListener;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.renderers.AbstractAccumulatingRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.util.datasource.DataSource;import net.sourceforge.pmd.util.datasource.internal.AbstractDataSource;public class MultiThreadProcessorTest {    private RuleContext ctx;    private MultiThreadProcessor processor;    private RuleSets ruleSets;    private List<DataSource> files;    private SimpleReportListener reportListener;    public void setUpForTest(final String ruleset) {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setThreads(2);        files = new ArrayList<>();        files.add(new StringDataSource("file1-violation.dummy", "ABC"));        files.add(new StringDataSource("file2-foo.dummy", "DEF"));        reportListener = new SimpleReportListener();        ctx = new RuleContext();        ctx.getReport().addListener(reportListener);        processor = new MultiThreadProcessor(configuration);        ruleSets = new RuleSets(new RuleSetLoader().loadFromResources(ruleset));    }    @Test    public void testRulesDysnfunctionalLog() throws IOException {        setUpForTest("rulesets/MultiThreadProcessorTest/dysfunctional.xml");        final SimpleRenderer renderer = new SimpleRenderer(null, null);        renderer.start();        processor.processFiles(ruleSets, files, ctx, Collections.<Renderer>singletonList(renderer));        renderer.end();        final Iterator<ConfigurationError> configErrors = renderer.getReport().getConfigurationErrors().iterator();        final ConfigurationError error = configErrors.next();        Assert.assertEquals("Dysfunctional rule message not present",                DysfunctionalRule.DYSFUNCTIONAL_RULE_REASON, error.issue());        Assert.assertEquals("Dysfunctional rule is wrong",                DysfunctionalRule.class, error.rule().getClass());        Assert.assertFalse("More configuration errors found than expected", configErrors.hasNext());    }    @Test    public void testRulesThreadSafety() {        setUpForTest("rulesets/MultiThreadProcessorTest/basic.xml");        processor.processFiles(ruleSets, files, ctx, Collections.<Renderer>emptyList());        // if the rule is not executed, then maybe a        // ConcurrentModificationException happened        Assert.assertEquals("Test rule has not been executed", 2, NotThreadSafeRule.count.get());        // if the violation is not reported, then the rule instances have been        // shared between the threads        Assert.assertEquals("Missing violation", 1, reportListener.violations.get());    }    private static class StringDataSource extends AbstractDataSource {        private final String data;        private final String name;        StringDataSource(String name, String data) {            this.name = name;            this.data = data;        }        @Override        public InputStream getInputStream() throws IOException {            return new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));        }        @Override        public String getNiceFileName(boolean shortNames, String inputFileName) {            return name;        }    }    public static class NotThreadSafeRule extends AbstractRule {        public static AtomicInteger count = new AtomicInteger(0);        private boolean hasViolation; // this variable will be overridden        // between the threads        @Override        public void apply(Node target, RuleContext ctx) {            count.incrementAndGet();            if (ctx.getSourceCodeFilename().contains("violation")) {                hasViolation = true;            } else {                letTheOtherThreadRun(10);                hasViolation = false;            }            letTheOtherThreadRun(100);            if (hasViolation) {                addViolation(ctx, target);            }        }        private void letTheOtherThreadRun(int millis) {            try {                Thread.yield();                Thread.sleep(millis);            } catch (InterruptedException e) {                // ignored            }        }    }    public static class DysfunctionalRule extends AbstractRule {        public static final String DYSFUNCTIONAL_RULE_REASON = "dysfunctional rule is dysfunctional";        @Override        public void apply(Node target, RuleContext ctx) {            // noop        }        @Override        public String dysfunctionReason() {            return DYSFUNCTIONAL_RULE_REASON;        }    }    private static class SimpleReportListener implements ThreadSafeReportListener {        public AtomicInteger violations = new AtomicInteger(0);        @Override        public void ruleViolationAdded(RuleViolation ruleViolation) {            violations.incrementAndGet();        }    }    private static class SimpleRenderer extends AbstractAccumulatingRenderer {        /* default */ SimpleRenderer(String name, String description) {            super(name, description);        }        @Override        public String defaultFileExtension() {            return null;        }        @Override        public void end() throws IOException {        }        public Report getReport() {            return report;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.document;import static org.junit.Assert.assertEquals;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class DocumentFileTest {    private static final String FILE_PATH = "psvm.java";    @Rule    public TemporaryFolder temporaryFolder = new TemporaryFolder();    private File temporaryFile;    @Before    public void setUpTemporaryFiles() throws IOException {        temporaryFile = temporaryFolder.newFile(FILE_PATH);    }    @Test    public void insertAtStartOfTheFileShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void shouldPreserveNewlines() throws IOException {        final String testFileContent = IOUtils.toString(                DocumentFileTest.class.getResource("ShouldPreserveNewlines.java"), StandardCharsets.UTF_8);        writeContentToTemporaryFile(testFileContent);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public " + testFileContent, actualContent);        }    }    private byte[] readAllBytes(final FileInputStream stream) throws IOException {        final int defaultBufferSize = 8192;        final int maxBufferSize = Integer.MAX_VALUE - 8;        byte[] buf = new byte[defaultBufferSize];        int capacity = buf.length;        int nread = 0;        int n;        while (true) {            // read to EOF which may read more or less than initial buffer size            while ((n = stream.read(buf, nread, capacity - nread)) > 0) {                nread += n;            }            // if the last call to read returned -1, then we're done            if (n < 0) {                break;            }            // need to allocate a larger buffer            if (capacity <= maxBufferSize - capacity) {                capacity = capacity << 1;            } else {                if (capacity == maxBufferSize) {                    throw new OutOfMemoryError("Required array size too large");                }                capacity = maxBufferSize;            }            buf = Arrays.copyOf(buf, capacity);        }        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);    }    @Test    public void insertVariousTokensIntoTheFileShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.insert(0, 17, "final ");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(final String[] args) {}", actualContent);        }    }    @Test    public void insertAtTheEndOfTheFileShouldSucceed() throws IOException {        final String code = "public static void main(String[] args)";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, code.length(), "{}");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args){}", actualContent);        }    }    @Test    public void removeTokenShouldSucceed() throws IOException {        final String code = "public static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.delete(new RegionByLineImp(0, 0, 24, 30));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndRemoveTokensShouldSucceed() throws IOException {        final String code = "static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.delete(new RegionByLineImp(0, 0, 17, 23));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndDeleteVariousTokensShouldSucceed() throws IOException {        final String code = "void main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public ");            documentFile.insert(0, 0, "static ");            documentFile.delete(new RegionByLineImp(0, 0, 0, 4));            documentFile.insert(0, 10, "final ");            documentFile.delete(new RegionByLineImp(0, 0, 25, 28));        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static  main(final String[] args) ", actualContent);        }    }    @Test    public void replaceATokenShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.replace(new RegionByLineImp(0, 0, 0, 3), "void");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void main(String[] args) {}", actualContent);        }    }    @Test    public void replaceVariousTokensShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.replace(new RegionByLineImp(0, 0, 0, "int".length()), "void");            documentFile.replace(new RegionByLineImp(0, 0, 4, 4 + "main".length()), "foo");            documentFile.replace(new RegionByLineImp(0, 0, 9, 9 + "String".length()), "CharSequence");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void foo(CharSequence[] args) {}", actualContent);        }    }    @Test    public void insertDeleteAndReplaceVariousTokensShouldSucceed() throws IOException {        final String code = "static int main(CharSequence[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            documentFile.insert(0, 0, "public");            documentFile.delete(new RegionByLineImp(0, 0, 0, 6));            documentFile.replace(new RegionByLineImp(0, 0, 7, 7 + "int".length()), "void");            documentFile.insert(0, 16, "final ");            documentFile.replace(new RegionByLineImp(0, 0, 16, 16 + "CharSequence".length()), "String");        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public void main(final String[] args) {}", actualContent);        }    }    @Test    public void lineToOffsetMappingWithLineFeedShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + '\n'                + "int var;" + '\n'                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(40);        expectedLineToOffset.add(49);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    @Test    public void lineToOffsetMappingWithCarriageReturnFeedLineFeedShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + "\r\n"                + "int var;" + "\r\n"                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(41);        expectedLineToOffset.add(51);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    @Test    public void lineToOffsetMappingWithMixedLineSeparatorsShouldSucceed() throws IOException {        final String code = "public static int main(String[] args) {" + "\r\n"                + "int var;" + "\n"                + "}";        writeContentToTemporaryFile(code);        final List<Integer> expectedLineToOffset = new ArrayList<>();        expectedLineToOffset.add(0);        expectedLineToOffset.add(41);        expectedLineToOffset.add(50);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            assertEquals(expectedLineToOffset, documentFile.getLineToOffset());        }    }    private void writeContentToTemporaryFile(final String content) throws IOException {        try (BufferedWriter writer = Files.newBufferedWriter(temporaryFile.toPath(), StandardCharsets.UTF_8)) {            writer.write(content);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.document;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.Collections;import java.util.LinkedList;import java.util.List;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;public class DocumentOperationsApplierForNonOverlappingRegionsWithDocumentFileTest {    private static final String FILE_PATH = "psvm.java";    @Rule    public TemporaryFolder temporaryFolder = new TemporaryFolder();    private File temporaryFile;    private DocumentOperationsApplierForNonOverlappingRegions applier;    @Before    public void setUpTemporaryFiles() throws IOException {        temporaryFile = temporaryFolder.newFile(FILE_PATH);    }    @Test    public void insertAtStartOfTheDocumentShouldSucceed() throws IOException {        writeContentToTemporaryFile("static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    private byte[] readAllBytes(final FileInputStream stream) throws IOException {        final int defaultBufferSize = 8192;        final int maxBufferSize = Integer.MAX_VALUE - 8;        byte[] buf = new byte[defaultBufferSize];        int capacity = buf.length;        int nread = 0;        int n;        while (true) {            // read to EOF which may read more or less than initial buffer size            while ((n = stream.read(buf, nread, capacity - nread)) > 0) {                nread += n;            }            // if the last call to read returned -1, then we're done            if (n < 0) {                break;            }            // need to allocate a larger buffer            if (capacity <= maxBufferSize - capacity) {                capacity = capacity << 1;            } else {                if (capacity == maxBufferSize) {                    throw new OutOfMemoryError("Required array size too large");                }                capacity = maxBufferSize;            }            buf = Arrays.copyOf(buf, capacity);        }        return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);    }    @Test    public void removeTokenShouldSucceed() throws IOException {        writeContentToTemporaryFile("public static void main(String[] args) {}");        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 7, 13));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public  void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndRemoveTokensShouldSucceed() throws IOException {        final String code = "static void main(final String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 17, 23));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static void main(String[] args) {}", actualContent);        }    }    @Test    public void insertAndDeleteVariousTokensShouldSucceed() throws IOException {        final String code = "void main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "public "));            applier.addDocumentOperation(new InsertDocumentOperation(0, 0, "static "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 0, 4));            applier.addDocumentOperation(new InsertDocumentOperation(0, 10, "final "));            applier.addDocumentOperation(new DeleteDocumentOperation(0, 0, 25, 27));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public static  main(final String[] args) ", actualContent);        }    }    @Test    public void replaceATokenShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            applier.addDocumentOperation(new ReplaceDocumentOperation(0, 0, 0, "int".length(), "void"));            applier.apply();        }        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void main(String[] args) {}", actualContent);        }    }    @Test    public void replaceVariousTokensShouldSucceed() throws IOException {        final String code = "int main(String[] args) {}";        writeContentToTemporaryFile(code);        final List<DocumentOperation> documentOperations = new LinkedList<>();        documentOperations.add(new ReplaceDocumentOperation(0, 0, 0, "int".length(), "void"));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 4, 4 + "main".length(), "foo"));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 9, 9 + "String".length(), "CharSequence"));        shuffleAndApplyOperations(documentOperations);        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("void foo(CharSequence[] args) {}", actualContent);        }    }    private void shuffleAndApplyOperations(List<DocumentOperation> documentOperations) throws IOException {        try (DocumentFile documentFile = new DocumentFile(temporaryFile, StandardCharsets.UTF_8)) {            applier = new DocumentOperationsApplierForNonOverlappingRegions(documentFile);            Collections.shuffle(documentOperations);            for (final DocumentOperation operation : documentOperations) {                applier.addDocumentOperation(operation);            }            applier.apply();        }    }    @Test    public void insertDeleteAndReplaceVariousTokensShouldSucceed() throws IOException {        final String code = "static int main(CharSequence[] args) {}";        writeContentToTemporaryFile(code);        final List<DocumentOperation> documentOperations = new LinkedList<>();        documentOperations.add(new InsertDocumentOperation(0, 0, "public"));        documentOperations.add(new DeleteDocumentOperation(0, 0, 0, 6));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 7, 7 + "int".length(), "void"));        documentOperations.add(new InsertDocumentOperation(0, 16, "final "));        documentOperations.add(new ReplaceDocumentOperation(0, 0, 16, 16 + "CharSequence".length(), "String"));        shuffleAndApplyOperations(documentOperations);        try (FileInputStream stream = new FileInputStream(temporaryFile)) {            final String actualContent = new String(readAllBytes(stream));            assertEquals("public void main(final String[] args) {}", actualContent);        }    }    private void writeContentToTemporaryFile(final String content) throws IOException {        try (FileWriter writer = new FileWriter(temporaryFile)) {            writer.write(content);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cache;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.when;import java.io.File;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.net.URLClassLoader;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Collections;import java.util.List;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TemporaryFolder;import org.mockito.Mockito;import net.sourceforge.pmd.RuleSets;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.Language;public class FileAnalysisCacheTest {    @Rule    public TemporaryFolder tempFolder = new TemporaryFolder();    @Rule    public RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    private File unexistingCacheFile;    private File newCacheFile;    private File emptyCacheFile;    private File sourceFile;    @Before    public void setUp() throws IOException {        unexistingCacheFile = new File(tempFolder.getRoot(), "non-existing-file.cache");        newCacheFile = new File(tempFolder.getRoot(), "pmd-analysis.cache");        emptyCacheFile = tempFolder.newFile();        sourceFile = tempFolder.newFile("Source.java");    }    @Test    public void testLoadFromNonExistingFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        assertNotNull("Cache creation from non existing file failed.", cache);    }    @Test    public void testLoadFromEmptyFile() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        assertNotNull("Cache creation from empty file failed.", cache);    }    @Test    public void testLoadFromDirectoryShouldntThrow() throws IOException {        new FileAnalysisCache(tempFolder.getRoot());    }    @Test    public void testLoadFromUnreadableFileShouldntThrow() throws IOException {        emptyCacheFile.setReadable(false);        new FileAnalysisCache(emptyCacheFile);    }    @Test    public void testStoreCreatesFile() {        final FileAnalysisCache cache = new FileAnalysisCache(unexistingCacheFile);        cache.persist();        assertTrue("Cache file doesn't exist after store", unexistingCacheFile.exists());    }    @Test    public void testStoreOnUnwritableFileShouldntThrow() {        emptyCacheFile.setWritable(false);        final FileAnalysisCache cache = new FileAnalysisCache(emptyCacheFile);        cache.persist();    }    @Test    public void testStorePersistsFilesWithViolations() {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        cache.isUpToDate(sourceFile);        final RuleViolation rv = mock(RuleViolation.class);        when(rv.getFilename()).thenReturn(sourceFile.getPath());        final net.sourceforge.pmd.Rule rule = mock(net.sourceforge.pmd.Rule.class, Mockito.RETURNS_SMART_NULLS);        when(rule.getLanguage()).thenReturn(mock(Language.class));        when(rv.getRule()).thenReturn(rule);        cache.ruleViolationAdded(rv);        cache.persist();        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        assertTrue("Cache believes unmodified file with violations is not up to date",                reloadedCache.isUpToDate(sourceFile));        final List<RuleViolation> cachedViolations = reloadedCache.getCachedViolations(sourceFile);        assertEquals("Cached rule violations count mismatch", 1, cachedViolations.size());    }    @Test    public void testCacheValidityWithNoChanges() {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date without ruleset / classpath changes",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testRulesetChangeInvalidatesCache() {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(rs.getChecksum()).thenReturn(1L);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes unmodified file is up to date after ruleset changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathNonExistingAuxclasspathEntriesIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { new File(tempFolder.getRoot(), "non-existing-dir").toURI().toURL(), });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache analysisCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] {});        analysisCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date after non-existing auxclasspath entry removed",                analysisCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathChangeWithoutDFAorTypeResolutionDoesNotInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        when(cl.getURLs()).thenReturn(new URL[] { tempFolder.newFile().toURI().toURL(), });        reloadedCache.checkValidity(rs, cl);        assertTrue("Cache believes unmodified file is not up to date after auxclasspath changed when no rule cares",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        when(cl.getURLs()).thenReturn(new URL[] { });        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        final File classpathFile = tempFolder.newFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        // Make sure the auxclasspath file is not empty        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());        final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes unmodified file is up to date after auxclasspath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testAuxClasspathJarContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final URLClassLoader cl = mock(URLClassLoader.class);        final File classpathFile = tempFolder.newFile();        when(cl.getURLs()).thenReturn(new URL[] { classpathFile.toURI().toURL(), });        final net.sourceforge.pmd.Rule r = mock(net.sourceforge.pmd.Rule.class);        when(r.getLanguage()).thenReturn(mock(Language.class));        when(rs.getAllRules()).thenReturn(Collections.singleton(r));        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Edit the auxclasspath referenced file        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when a auxclasspath file changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testClasspathNonExistingEntryIsIgnored() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator                + tempFolder.getRoot().getAbsolutePath() + File.separator + "non-existing-dir");        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        try {            reloadedCache.checkValidity(rs, cl);        } catch (final Exception e) {            fail("Validity check failed when classpath includes non-existing directories");        }    }    @Test    public void testClasspathChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        final File classpathFile = tempFolder.newFile();        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Edit the classpath referenced file        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testClasspathContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        final File classpathFile = tempFolder.newFile();        // Add a file to classpath        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some text".getBytes());        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + classpathFile.getAbsolutePath());        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Change the file's contents        Files.write(Paths.get(classpathFile.getAbsolutePath()), "some other text".getBytes());        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when a classpath file changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testWildcardClasspath() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Prepare two jar files        final File classpathJar1 = tempFolder.newFile("mylib1.jar");        Files.write(classpathJar1.toPath(), "content of mylib1.jar".getBytes(StandardCharsets.UTF_8));        final File classpathJar2 = tempFolder.newFile("mylib2.jar");        Files.write(classpathJar2.toPath(), "content of mylib2.jar".getBytes(StandardCharsets.UTF_8));        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.getRoot().getAbsolutePath() + "/*");        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testWildcardClasspathContentsChangeInvalidatesCache() throws MalformedURLException, IOException {        final RuleSets rs = mock(RuleSets.class);        final ClassLoader cl = mock(ClassLoader.class);        // Prepare two jar files        final File classpathJar1 = tempFolder.newFile("mylib1.jar");        Files.write(classpathJar1.toPath(), "content of mylib1.jar".getBytes(StandardCharsets.UTF_8));        final File classpathJar2 = tempFolder.newFile("mylib2.jar");        Files.write(classpathJar2.toPath(), "content of mylib2.jar".getBytes(StandardCharsets.UTF_8));        System.setProperty("java.class.path", System.getProperty("java.class.path") + File.pathSeparator + tempFolder.getRoot().getAbsolutePath() + "/*");        setupCacheWithFiles(newCacheFile, rs, cl, sourceFile);        // Change one file's contents        Files.write(Paths.get(classpathJar2.getAbsolutePath()), "some other text".getBytes(StandardCharsets.UTF_8));        final FileAnalysisCache reloadedCache = new FileAnalysisCache(newCacheFile);        reloadedCache.checkValidity(rs, cl);        assertFalse("Cache believes cache is up to date when the classpath changed",                reloadedCache.isUpToDate(sourceFile));    }    @Test    public void testUnknownFileIsNotUpToDate() throws IOException {        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse("Cache believes an unknown file is up to date",                cache.isUpToDate(sourceFile));    }    @Test    public void testFileIsUpToDate() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertTrue("Cache believes a known, unchanged file is not up to date",                cache.isUpToDate(sourceFile));    }    @Test    public void testFileIsNotUpToDateWhenEdited() throws IOException {        setupCacheWithFiles(newCacheFile, mock(RuleSets.class), mock(ClassLoader.class), sourceFile);        // Edit the file        Files.write(Paths.get(sourceFile.getAbsolutePath()), "some text".getBytes());        final FileAnalysisCache cache = new FileAnalysisCache(newCacheFile);        assertFalse("Cache believes a known, changed file is up to date",                cache.isUpToDate(sourceFile));    }    private void setupCacheWithFiles(final File cacheFile, final RuleSets ruleSets,            final ClassLoader classLoader, final File... files) {        // Setup a cache file with an entry for an empty Source.java with no violations        final FileAnalysisCache cache = new FileAnalysisCache(cacheFile);        cache.checkValidity(ruleSets, classLoader);        for (final File f : files) {            cache.isUpToDate(f);        }        cache.persist();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.metrics;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;public class ParameterizedMetricKeyTest {    private static final MetricOptions DUMMY_VERSION_1 = MetricOptions.ofOptions(Options.DUMMY1, Options.DUMMY2);    private static final MetricOptions DUMMY_VERSION_2 = MetricOptions.ofOptions(Options.DUMMY2);    @Test    public void testIdentity() {        MetricKey<DummyNode> key = MetricKey.of("metric", new DummyMetric());        ParameterizedMetricKey<DummyNode> key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);        ParameterizedMetricKey<DummyNode> key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);        assertEquals(key1, key2);        assertSame(key1, key2);    }    @Test    public void testVersioning() {        MetricKey<DummyNode> key = MetricKey.of("metric", new DummyMetric());        ParameterizedMetricKey<DummyNode> key1 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_1);        ParameterizedMetricKey<DummyNode> key2 = ParameterizedMetricKey.getInstance(key, DUMMY_VERSION_2);        assertNotEquals(key1, key2);        assertNotSame(key1, key2);    }    @Test    public void testToString() {        MetricKey<DummyNode> adHocKey = MetricKey.of("metric", new DummyMetric());        ParameterizedMetricKey<DummyNode> key1 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        assertTrue(key1.toString().contains(key1.key.name()));        assertTrue(key1.toString().contains(key1.options.toString()));    }    @Test    public void testAdHocMetricKey() {        MetricKey<DummyNode> adHocKey = MetricKey.of("metric", new DummyMetric());        ParameterizedMetricKey<DummyNode> key1 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        ParameterizedMetricKey<DummyNode> key2 = ParameterizedMetricKey.getInstance(adHocKey, DUMMY_VERSION_1);        assertNotNull(key1);        assertNotNull(key2);        assertSame(key1, key2);        assertEquals(key1, key2);        assertTrue(key1.toString().contains(key1.key.name()));        assertTrue(key1.toString().contains(key1.options.toString()));    }    private enum Options implements MetricOption {        DUMMY1,        DUMMY2;        @Override        public String valueName() {            return null;        }    }    class DummyMetric extends AbstractMetric<DummyNode> {        @Override        public boolean supports(DummyNode node) {            return true;        }        @Override        public double computeFor(DummyNode node, MetricOptions options) {            return 0;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.symboltable;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;import org.junit.Test;public class ApplierTest {    private static class MyFunction implements Predicate<Object> {        private int numCallbacks = 0;        private final int maxCallbacks;        MyFunction(int maxCallbacks) {            this.maxCallbacks = maxCallbacks;        }        @Override        public boolean test(Object o) {            this.numCallbacks++;            return numCallbacks < maxCallbacks;        }        public int getNumCallbacks() {            return this.numCallbacks;        }    }    @Test    public void testSimple() {        MyFunction f = new MyFunction(Integer.MAX_VALUE);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(l.size(), f.getNumCallbacks());    }    @Test    public void testLimit() {        MyFunction f = new MyFunction(2);        List<Object> l = new ArrayList<>();        l.add(new Object());        l.add(new Object());        l.add(new Object());        Applier.apply(f, l.iterator());        assertEquals(2, f.getNumCallbacks());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(ApplierTest.class);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.internal;import static java.util.Collections.emptyList;import static java.util.Collections.emptySet;import static java.util.Collections.singletonList;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.HashSet;import java.util.List;import java.util.Objects;import java.util.Set;import java.util.function.Predicate;import java.util.stream.Collectors;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import org.pcollections.HashTreePSet;import org.pcollections.PSet;import net.sourceforge.pmd.internal.util.PredicateUtil;public class LatticeRelationTest {    @Rule    public ExpectedException expect = ExpectedException.none();    @Test    public void testCustomTopo() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(PredicateUtil.always());        lattice.put(setOf(1, 2, 3), "123");        lattice.put(setOf(4), "4");        lattice.put(setOf(4, 3), "43");        // http://bit.ly/39J3KOu        assertEquals(setOf("123"), lattice.get(setOf(1, 2, 3)));        assertEquals(setOf("4", "43"), lattice.get(setOf(4)));        assertEquals(setOf("43", "123"), lattice.get(setOf(3)));        assertEquals(setOf("43", "123", "4"), lattice.get(emptySet()));        assertEquals(emptySet(), lattice.get(setOf(5)));    }    @Test    public void testClearing() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(PredicateUtil.always());        lattice.put(setOf(1, 2), "12");        lattice.put(setOf(1), "1");        lattice.put(setOf(3), "3");        assertEquals(setOf("12"), lattice.get(setOf(2)));        assertEquals(setOf("12", "1"), lattice.get(setOf(1)));        assertEquals(setOf("12"), lattice.get(setOf(1, 2)));        assertEquals(setOf("3"), lattice.get(setOf(3)));        assertEquals(emptySet(), lattice.get(setOf(5)));        assertEquals(setOf("1", "12", "3"), lattice.get(emptySet()));        lattice.clearValues();        assertEquals(emptySet(), lattice.get(setOf(2)));        assertEquals(emptySet(), lattice.get(setOf(1)));        assertEquals(emptySet(), lattice.get(setOf(1, 2)));        assertEquals(emptySet(), lattice.get(setOf(3)));        assertEquals(emptySet(), lattice.get(setOf(5)));        assertEquals(emptySet(), lattice.get(emptySet()));    }    @Test    public void testTopoFilter() {        // filter out sets with size 2        // this cuts out one level of the graph        // goal of the test is to ensure, that their predecessors (sets with size > 2)        // are still connected to successors (size < 2)        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(it -> it.size() != 2);        lattice.put(setOf(1, 2, 3), "123");        lattice.put(setOf(4), "4");        lattice.put(setOf(4, 3), "43");        lattice.put(setOf(4, 3, 5), "435");        // before filter:        // http://bit.ly/38vRsce        // after filter:        // http://bit.ly/2SxejyC        assertEquals(setOf("123"), lattice.get(setOf(1, 2, 3)));        assertEquals(setOf("4", "43", "435"), lattice.get(setOf(4)));        assertEquals(setOf("123", "43", "435"), lattice.get(setOf(3)));        assertEquals(setOf("123", "4", "43", "435"), lattice.get(emptySet()));        lattice.put(setOf(4, 3, 6), "436");        assertEquals(setOf("4", "43", "435", "436"), lattice.get(setOf(4)));    }    @Test    public void testInitialSetFilter() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice =            new LatticeRelation<>(                setTopoOrder(),                setOf(setOf(1, 2), setOf(1, 2, 3), setOf(2, 3), emptySet()),                Objects::toString,                Collectors.toSet()            );        lattice.put(setOf(1, 2, 3), "123");        lattice.put(setOf(1, 2), "12");        lattice.put(setOf(1), "1");        lattice.put(setOf(2, 3, 4), "234");        lattice.put(setOf(4, 3, 5, 6), "435");        assertEquals(setOf("123"), lattice.get(setOf(1, 2, 3)));        assertEquals(setOf("12", "123"), lattice.get(setOf(1, 2)));        assertEquals(setOf("123", "234"), lattice.get(setOf(2, 3)));        assertEquals(setOf("1", "12", "123", "234", "435"), lattice.get(emptySet()));        assertEquals(emptySet(), lattice.get(setOf(4))); // not in initial set        assertEquals(emptySet(), lattice.get(setOf(4, 5))); // not in initial set        assertEquals(emptySet(), lattice.get(setOf(2, 3, 4))); // not in initial set        lattice.put(setOf(2, 3, 4), "234*");        assertEquals(setOf("123", "234", "234*"), lattice.get(setOf(2, 3))); // value "43" has been pruned    }    @Test    public void testDiamond() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(PredicateUtil.always());        lattice.put(setOf(1, 2), "12");        // We have        //    {1,2}        //    /   \        //  {1}   {2}        //    \   /        //     { }        // Goal is to assert, that when we ask first for the value of { },        // the value of every node is correctly computed, even if they're        // reachable from several paths        assertEquals(setOf("12"), lattice.get(emptySet()));        assertEquals(setOf("12"), lattice.get(setOf(1)));        assertEquals(setOf("12"), lattice.get(setOf(2)));        assertEquals(setOf("12"), lattice.get(setOf(1, 2)));    }    @Test    public void testFilterOnChainSetup() {        // setup for the next test (difference here is no filter)        LatticeRelation<String, String, Set<String>> lattice = stringLattice(PredicateUtil.always());        lattice.put("abc", "val");        // We have "abc" <: "bc" <: "c" <: ""        assertEquals(setOf("val"), lattice.get(""));        assertEquals(setOf("val"), lattice.get("abc"));        assertEquals(setOf("val"), lattice.get("bc"));        assertEquals(setOf("val"), lattice.get("c"));        assertEquals(emptySet(), lattice.get("d"));    }    @Test    public void testFilterOnChain() {        LatticeRelation<String, String, Set<String>> lattice = stringLattice(s -> s.length() != 2 && s.length() != 1);        lattice.put("abc", "val");        // We have "abc" <: "bc" <: "c" <: ""        // We filter out both "bc" and "c"        // "abc" should still be connected to ""        assertEquals(setOf("val"), lattice.get(""));        assertEquals(setOf("val"), lattice.get("abc"));        assertEquals(emptySet(), lattice.get("bc"));        assertEquals(emptySet(), lattice.get("c"));        assertEquals(emptySet(), lattice.get("d"));    }    @Test    public void testTransitiveSucc() {        LatticeRelation<String, String, Set<String>> lattice =            stringLattice(s -> s.equals("c") || s.equals("bc"));        lattice.put("abc", "val");        lattice.put("bc", "v2");        // We have "abc" <: "bc" <: "c" <: ""        assertEquals(emptySet(), lattice.transitiveQuerySuccs(""));        assertEquals(emptySet(), lattice.get(""));        assertEquals(setOf("c", "bc"), lattice.transitiveQuerySuccs("abc"));        assertEquals(emptySet(), lattice.get("abc"));        assertEquals(setOf("c"), lattice.transitiveQuerySuccs("bc"));        assertEquals(setOf("val", "v2"), lattice.get("bc"));        assertEquals(emptySet(), lattice.transitiveQuerySuccs("c"));        assertEquals(setOf("val", "v2"), lattice.get("c"));        assertEquals(emptySet(), lattice.transitiveQuerySuccs("d"));        assertEquals(emptySet(), lattice.get("d"));    }    @Test    public void testTransitiveSuccWithHoleInTheMiddle() {        LatticeRelation<String, String, Set<String>> lattice =            stringLattice(setOf("abc", "bbc", "c")::contains);        lattice.put("abc", "v1");        lattice.put("bbc", "v2");        // We have "abc" <: "bc" <: "c" <: ""        // We have "bbc" <: "bc" <: "c" <: ""        // Only "abc", "bbc" and "c" are query nodes        // When adding "abc" we add its successors and link "abc" to "c"        // When adding "bbc" it must be linked to "c" even if on its        // path to "c" there is "bc", which is not a QNode and was already added        assertEquals(emptySet(), lattice.transitiveQuerySuccs(""));        assertEquals(emptySet(), lattice.get(""));        assertEquals(setOf("c"), lattice.transitiveQuerySuccs("abc"));        assertEquals(setOf("v1"), lattice.get("abc"));        assertEquals(setOf("c"), lattice.transitiveQuerySuccs("bbc"));        assertEquals(setOf("v2"), lattice.get("bbc"));        assertEquals(emptySet(), lattice.get("bc"));        assertEquals(emptySet(), lattice.transitiveQuerySuccs("c"));        assertEquals(setOf("v1", "v2"), lattice.get("c"));    }    @Test    public void testToString() {        LatticeRelation<Set<Integer>, String, Set<String>> lattice = setLattice(set -> set.size() < 2);        lattice.put(setOf(1, 2), "12");        //    {1,2}        //    /   \        //  {1}   {2}        //    \   /        //     { }        // all {1}, {2}, and { } are query nodes, not {1,2}        assertEquals("strict digraph {\n"                         + "n0 [ shape=box, color=green, label=\"[]\" ];\n"                         + "n1 [ shape=box, color=green, label=\"[1]\" ];\n"                         + "n2 [ shape=box, color=green, label=\"[2]\" ];\n"                         + "n3 [ shape=box, color=black, label=\"[1, 2]\" ];\n"                         + "n1 -> n0;\n" // {1}   -> { }                         + "n2 -> n0;\n" // {2}   -> { }                         + "n3 -> n0;\n" // {1,2} -> { }                         + "n3 -> n1;\n" // {1,2} -> {1}                         + "n3 -> n2;\n" // {1,2} -> {2}                         + "}", lattice.toString());    }    @Test    public void testCycleDetection() {        List<String> cycle = Arrays.asList("a", "b", "c", "d");        TopoOrder<String> cyclicOrder = str -> {            int i = cycle.indexOf(str);            return singletonList(cycle.get((i + 1) % cycle.size()));        };        LatticeRelation<String, String, Set<String>> lattice =            new LatticeRelation<>(cyclicOrder, PredicateUtil.always(), Objects::toString, Collectors.toSet());        expect.expect(IllegalStateException.class);        expect.expectMessage("a -> b -> c -> d -> a");        lattice.put("a", "1");    }    @NonNull    private LatticeRelation<String, String, Set<String>> stringLattice(Predicate<String> filter) {        return new LatticeRelation<>(stringTopoOrder(), filter, Objects::toString, Collectors.toSet());    }    @NonNull    private LatticeRelation<Set<Integer>, String, Set<String>> setLattice(Predicate<Set<Integer>> filter) {        return new LatticeRelation<>(setTopoOrder(), filter, Objects::toString, Collectors.toSet());    }    /**     * Direct successors of a set are all the sets that have exactly     * one less element. For example:     * <pre>{@code     *     * {1, 2, 3} <: {1, 2}, {1, 3}, {2, 3}     * {2, 3} <: {2}, {3}     * {2} <: {}     * etc     *     * }</pre>     *     * See eg http://bit.ly/31Xve0v     */    private static <T> TopoOrder<Set<T>> setTopoOrder() {        return node -> {            Set<Set<T>> successors = new HashSet<>();            for (T s : node) {                PSet<T> minus = HashTreePSet.<T>empty().plusAll(node).minus(s);                successors.add(minus);            }            return successors;        };    }    /**     * Generates a linear topo order according to suffix order. This     * can never form diamonds, as any string has at most one successor.     * Eg     * <pre>{@code     * "abc" <: "bc" <: "c" <: ""     * }</pre>     */    private static TopoOrder<String> stringTopoOrder() {        return str -> str.isEmpty() ? emptyList()                                    : singletonList(str.substring(1));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.internal;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sf.saxon.Configuration;import net.sf.saxon.type.Type;public class ElementNodeTest {    @Test    public void testCompareOrder() {        DummyRoot root = new DummyRoot();        DummyNode c0 = new DummyNode(false, "foo");        c0.setCoords(1, 1, 2, 2);        root.addChild(c0, 0);        DummyNode c1 = new DummyNode(false, "foo");        c1.setCoords(2, 1, 2, 2);        root.addChild(c1, 1);        Configuration configuration = Configuration.newConfiguration();        AstTreeInfo treeInfo = new AstTreeInfo(root, configuration);        Assert.assertSame(root, treeInfo.getRootNode().getUnderlyingNode());        Assert.assertEquals(Type.DOCUMENT, treeInfo.getRootNode().getNodeKind());        AstElementNode rootElt = treeInfo.getRootNode().getRootElement();        Assert.assertSame(root, rootElt.getUnderlyingNode());        Assert.assertEquals(Type.ELEMENT, rootElt.getNodeKind());        Assert.assertSame(rootElt, treeInfo.findWrapperFor(root));        AstElementNode elementFoo0 = rootElt.getChildren().get(0);        Assert.assertSame(c0, elementFoo0.getUnderlyingNode());        Assert.assertSame(elementFoo0, treeInfo.findWrapperFor(c0));        AstElementNode elementFoo1 = rootElt.getChildren().get(1);        Assert.assertSame(c1, elementFoo1.getUnderlyingNode());        Assert.assertSame(elementFoo1, treeInfo.findWrapperFor(c1));        Assert.assertFalse(elementFoo0.isSameNodeInfo(elementFoo1));        Assert.assertFalse(elementFoo1.isSameNodeInfo(elementFoo0));        Assert.assertTrue(elementFoo0.compareOrder(elementFoo1) < 0);        Assert.assertTrue(elementFoo1.compareOrder(elementFoo0) > 0);        Assert.assertEquals(0, elementFoo0.compareOrder(elementFoo0));        Assert.assertEquals(0, elementFoo1.compareOrder(elementFoo1));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.internal;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.followPath;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.nodeB;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.junit.Assert.assertEquals;import java.util.HashMap;import java.util.List;import java.util.Map;import org.checkerframework.checker.nullness.qual.NonNull;import org.hamcrest.CoreMatchers;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.lang.ast.DummyNodeWithListAndEnum;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;import net.sourceforge.pmd.lang.rule.xpath.impl.AbstractXPathFunctionDef;import net.sourceforge.pmd.lang.rule.xpath.impl.XPathHandler;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;import net.sf.saxon.expr.Expression;import net.sf.saxon.expr.XPathContext;import net.sf.saxon.lib.ExtensionFunctionCall;import net.sf.saxon.om.Sequence;import net.sf.saxon.trans.XPathException;import net.sf.saxon.value.BooleanValue;import net.sf.saxon.value.SequenceType;public class SaxonXPathRuleQueryTest {    @Rule    public final ExpectedException expected = ExpectedException.none();    //    Unsupported: https://github.com/pmd/pmd/issues/2451    //    @Test    //    public void testListAttribute() {    //        RootNode dummy = new DummyNodeWithListAndEnum();    //    //        assertQuery(1, "//dummyNode[@List = \"A\"]", dummy);    //        assertQuery(1, "//dummyNode[@List = \"B\"]", dummy);    //        assertQuery(0, "//dummyNode[@List = \"C\"]", dummy);    //        assertQuery(1, "//dummyNode[@Enum = \"FOO\"]", dummy);    //        assertQuery(0, "//dummyNode[@Enum = \"BAR\"]", dummy);    //        assertQuery(1, "//dummyNode[@EnumList = \"FOO\"]", dummy);    //        assertQuery(1, "//dummyNode[@EnumList = \"BAR\"]", dummy);    //        assertQuery(1, "//dummyNode[@EnumList = (\"FOO\", \"BAR\")]", dummy);    //        assertQuery(0, "//dummyNode[@EmptyList = (\"A\")]", dummy);    //    }    @Test    public void testHigherOrderFuns() { // XPath 3.1        DummyRoot tree = tree(() -> root(            node()        ));        tree.setImage("[oha]");        assertQuery(1, "//dummyRootNode["            + "(@Image => substring-after('[') => substring-before(']')) "            //                --------------------    ---------------------            //                       Those are higher order functions,            //                the arrow operator applies it to the left expression            + "! . = 'oha']", tree);        //     ^ This is the mapping operator, it applies a function on        //     the right to every element of the sequence on the left        // Together this says,        // for r in dummyRootNode:        //    tmp = atomize(r/@Image)        //    tmp = substring-after('[', tmp)        //    tmp = substring-before(']', tmp)        //    if tmp == 'oha':        //      yield r    }    @Test    public void testListProperty() {        RootNode dummy = new DummyNodeWithListAndEnum();        PropertyDescriptor<List<String>> prop = PropertyFactory.stringListProperty("prop")                                                               .defaultValues("FOO", "BAR")                                                               .desc("description").build();        assertQuery(1, "//dummyRootNode[@Enum = $prop]", dummy, prop);    }    @Test    public void testInvalidReturn() {        DummyNodeWithListAndEnum dummy = new DummyNodeWithListAndEnum();        expected.expect(PmdXPathException.class);        expected.expectMessage(CoreMatchers.containsString("XPath rule expression returned a non-node"));        expected.expectMessage(CoreMatchers.containsString("Int64Value"));        createQuery("1+2").evaluate(dummy);    }    @Test    public void testRootExpression() {        DummyRoot dummy = new DummyRoot();        List<Node> result = assertQuery(1, "/", dummy);        Assert.assertEquals(dummy, result.get(0));    }    @Test    public void testRootExpressionIsADocumentNode() {        DummyRoot dummy = new DummyRoot();        List<Node> result = assertQuery(1, "(/)[self::document-node()]", dummy);        Assert.assertEquals(dummy, result.get(0));    }    @Test    public void testRootExpressionWithName() {        DummyRoot dummy = new DummyRoot();        String xpathName = dummy.getXPathNodeName();        List<Node> result = assertQuery(1, "(/)[self::document-node(element(" + xpathName + "))]", dummy);        Assert.assertEquals(dummy, result.get(0));        assertQuery(0, "(/)[self::document-node(element(DummyNodeX))]", dummy);    }    @Test    public void ruleChainVisits() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Image='baz']/foo | //bar[@Public = 'true'] | //dummyNode[@Public = false()] | //dummyNode");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(2, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        Assert.assertTrue(ruleChainVisits.contains("bar"));        assertEquals(3, query.nodeNameToXPaths.size());        assertExpression("(self::node()[(string(data(@Image))) eq \"baz\"])/child::element(foo)", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("self::node()[(boolean(data(@Public))) eq false()]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(1));        assertExpression("self::node()", query.getExpressionsForLocalNameOrDefault("dummyNode").get(2));        assertExpression("self::node()[(string(data(@Public))) eq \"true\"]", query.getExpressionsForLocalNameOrDefault("bar").get(0));        assertExpression("(((docOrder((((/)/descendant::element(dummyNode))[(string(data(@Image))) eq \"baz\"])/child::element(foo))) | (((/)/descendant::element(bar))[(string(data(@Public))) eq \"true\"])) | (((/)/descendant::element(dummyNode))[(boolean(data(@Public))) eq false()])) | ((/)/descendant::element(dummyNode))", query.getFallbackExpr());    }    @Test    public void ruleChainVisitsMultipleFilters() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[@Test1 = false()][@Test2 = true()]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(self::node()[(boolean(data(@Test1))) eq false()])[(boolean(data(@Test2))) eq true()]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("(((/)/descendant::element(dummyNode))[(boolean(data(@Test1))) eq false()])[(boolean(data(@Test2))) eq true()]", query.getFallbackExpr());    }    @Test    public void ruleChainVisitsCustomFunctions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[pmd-dummy:imageIs(@Image)]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("self::node()[Q{http://pmd.sourceforge.net/pmd-dummy}imageIs(exactly-one(convertUntyped(data(@Image))))]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("((/)/descendant::element(Q{}dummyNode))[Q{http://pmd.sourceforge.net/pmd-dummy}imageIs(exactly-one(convertUntyped(data(@Image))))]", query.getFallbackExpr());    }    /**     * If a query contains another unbounded path expression other than the first one, it must be     * excluded from rule chain execution. Saxon itself optimizes this quite good already.     */    @Test    public void ruleChainVisitsUnboundedPathExpressions() {        SaxonXPathRuleQuery query = createQuery("//dummyNode[//ClassOrInterfaceType]");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());        assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("let $Q{http://saxon.sf.net/generated-variable}v0 := (/)/descendant::element(Q{}ClassOrInterfaceType) return (((/)/descendant::element(Q{}dummyNode))[exists($Q{http://saxon.sf.net/generated-variable}v0)])", query.getFallbackExpr());        // second sample, more complex        query = createQuery("//dummyNode[ancestor::ClassOrInterfaceDeclaration[//ClassOrInterfaceType]]");        ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());        assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("let $Q{http://saxon.sf.net/generated-variable}v0 := (/)/descendant::element(Q{}ClassOrInterfaceType) return (((/)/descendant::element(Q{}dummyNode))[exists(ancestor::element(Q{}ClassOrInterfaceDeclaration)[exists($Q{http://saxon.sf.net/generated-variable}v0)])])", query.getFallbackExpr());        // third example, with boolean expr        query = createQuery("//dummyNode[//ClassOrInterfaceType or //OtherNode]");        ruleChainVisits = query.getRuleChainVisits();        assertEquals(0, ruleChainVisits.size());        assertEquals(1, query.nodeNameToXPaths.size());        assertExpression("let $Q{http://saxon.sf.net/generated-variable}v0 := (exists((/)/descendant::element(Q{}ClassOrInterfaceType))) or (exists((/)/descendant::element(Q{}OtherNode))) return (((/)/descendant::element(Q{}dummyNode))[$Q{http://saxon.sf.net/generated-variable}v0])", query.getFallbackExpr());    }    @Test    public void ruleChainVisitsNested() {        SaxonXPathRuleQuery query = createQuery("//dummyNode/foo/*/bar[@Test = 'false']");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(((self::node()/child::element(foo))/child::element())/child::element(bar))[(string(data(@Test))) eq \"false\"]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("docOrder(((docOrder((((/)/descendant::element(dummyNode))/child::element(foo))/child::element()))/child::element(bar))[(string(data(@Test))) eq \"false\"])", query.getFallbackExpr());    }    @Test    public void ruleChainVisitsNested2() {        SaxonXPathRuleQuery query = createQuery("//dummyNode/foo[@Baz = 'a']/*/bar[@Test = 'false']");        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("((((self::node()/child::element(foo))[(string(data(@Baz))) eq \"a\"])/child::element())/child::element(bar))[(string(data(@Test))) eq \"false\"]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("docOrder(((docOrder(((((/)/descendant::element(dummyNode))/child::element(foo))[(string(data(@Baz))) eq \"a\"])/child::element()))/child::element(bar))[(string(data(@Test))) eq \"false\"])", query.getFallbackExpr());    }    @Test    public void unionBeforeSlash() {        SaxonXPathRuleQuery query = createQuery("(//dummyNode | //dummyNodeB)/dummyNode[@Image = '10']");        DummyRoot tree = tree(() -> root(            node(                node()            ),            nodeB(                node()            )        ));        tree.descendantsOrSelf().forEach(n -> {            List<Node> results = query.evaluate(n);            assertEquals(1, results.size());            assertEquals(followPath(tree, "10"), results.get(0));        });        assertExpression("docOrder((((/)/descendant::(element(dummyNode) | element(dummyNodeB)))/child::element(dummyNode))[(string(data(@Image))) eq \"10\"])", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));    }    @Test    public void unionBeforeSlashWithFilter() {        SaxonXPathRuleQuery query = createQuery("(//dummyNode[@Image='0'] | //dummyNodeB[@Image='1'])/dummyNode[@Image = '10']");        DummyRoot tree = tree(() -> root(            node(                node()            ),            nodeB(                node()            )        ));        assertEquals(0, query.getRuleChainVisits().size());        assertExpression("docOrder((((((/)/descendant::element(dummyNode))[(string(data(@Image))) eq \"0\"]) | (((/)/descendant::element(dummyNodeB))[(string(data(@Image))) eq \"1\"]))/child::element(dummyNode))[(string(data(@Image))) eq \"10\"])", query.getFallbackExpr());        tree.descendantsOrSelf().forEach(n -> {            List<Node> results = query.evaluate(n);            assertEquals(1, results.size());            assertEquals(followPath(tree, "10"), results.get(0));        });    }    @Test    public void unionBeforeSlashDeeper() {        SaxonXPathRuleQuery query = createQuery("(//dummyNode | //dummyNodeB)/dummyNode/dummyNode");        DummyRoot tree = tree(() -> root(            node(                node(                    node()                )            ),            nodeB(                node()            )        ));        assertEquals(0, query.getRuleChainVisits().size());        assertExpression("docOrder((((/)/descendant::(element(dummyNode) | element(dummyNodeB)))/child::element(dummyNode))/child::element(dummyNode))", query.getFallbackExpr());        tree.descendantsOrSelf().forEach(n -> {            List<Node> results = query.evaluate(n);            assertEquals(1, results.size());            assertEquals(followPath(tree, "000"), results.get(0));        });    }    @Test    public void ruleChainVisitWithVariable() {        PropertyDescriptor<String> testClassPattern = PropertyFactory.stringProperty("testClassPattern").desc("test").defaultValue("a").build();        SaxonXPathRuleQuery query = createQuery("//dummyNode[matches(@SimpleName, $testClassPattern)]", testClassPattern);        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("self::node()[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")]", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("((/)/descendant::element(Q{}dummyNode))[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")]", query.getFallbackExpr());    }    @Test    public void ruleChainVisitWithVariable2() {        PropertyDescriptor<String> testClassPattern = PropertyFactory.stringProperty("testClassPattern").desc("test").defaultValue("a").build();        SaxonXPathRuleQuery query = createQuery("//dummyNode[matches(@SimpleName, $testClassPattern)]/foo", testClassPattern);        List<String> ruleChainVisits = query.getRuleChainVisits();        assertEquals(1, ruleChainVisits.size());        Assert.assertTrue(ruleChainVisits.contains("dummyNode"));        assertEquals(2, query.nodeNameToXPaths.size());        assertExpression("(self::node()[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")])/child::element(Q{}foo)", query.getExpressionsForLocalNameOrDefault("dummyNode").get(0));        assertExpression("docOrder((((/)/descendant::element(Q{}dummyNode))[matches(convertUntyped(data(@SimpleName)), \"a\", \"\")])/child::element(Q{}foo))", query.getFallbackExpr());    }    private static void assertExpression(String expected, Expression actual) {        assertEquals(normalizeExprDump(expected),                     normalizeExprDump(actual.toString()));    }    private static String normalizeExprDump(String dump) {        return dump.replaceAll("Q\\{[^}]*+}", "") // remove namespaces                   // generated variable ids                   .replaceAll("\\$qq:qq-?\\d+", "\\$qq:qq000")                   .replaceAll("\\$zz:zz-?\\d+", "\\$zz:zz000");    }    private static List<Node> assertQuery(int resultSize, String xpath, Node node, PropertyDescriptor<?>... descriptors) {        SaxonXPathRuleQuery query = createQuery(xpath, descriptors);        List<Node> result = query.evaluate(node);        assertEquals("Wrong number of matched nodes", resultSize, result.size());        return result;    }    private static SaxonXPathRuleQuery createQuery(String xpath, PropertyDescriptor<?>... descriptors) {        Map<PropertyDescriptor<?>, Object> props = new HashMap<>();        if (descriptors != null) {            for (PropertyDescriptor<?> prop : descriptors) {                props.put(prop, prop.defaultValue());            }        }        return new SaxonXPathRuleQuery(            xpath,            XPathVersion.DEFAULT,            props,            XPathHandler.getHandlerForFunctionDefs(imageIsFunction()),            DeprecatedAttrLogger.noop()        );    }    @NonNull    private static AbstractXPathFunctionDef imageIsFunction() {        return new AbstractXPathFunctionDef("imageIs", "dummy") {            @Override            public SequenceType[] getArgumentTypes() {                return new SequenceType[] {SequenceType.SINGLE_STRING};            }            @Override            public SequenceType getResultType(SequenceType[] suppliedArgumentTypes) {                return SequenceType.SINGLE_BOOLEAN;            }            @Override            public ExtensionFunctionCall makeCallExpression() {                return new ExtensionFunctionCall() {                    @Override                    public Sequence call(XPathContext context, Sequence[] arguments) throws XPathException {                        Node contextNode = ((AstElementNode) context.getContextItem()).getUnderlyingNode();                        return BooleanValue.get(arguments[0].head().getStringValue().equals(contextNode.getImage()));                    }                };            }        };    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath.impl;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import static org.junit.Assert.assertEquals;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.util.CollectionUtil;/** * Unit test for {@link AttributeAxisIterator} */public class AttributeAxisIteratorTest {    private static final Set<String> DEFAULT_ATTRS = setOf("BeginColumn", "BeginLine", "Image", "EndColumn", "EndLine");    /**     * Test hasNext and next.     */    @Test    public void testAttributeAxisIterator() {        DummyNode dummyNode = new DummyNode();        dummyNode.setCoords(1, 1, 2, 2);        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        assertEquals(DEFAULT_ATTRS, toMap(it).keySet());    }    @Test    public void testAttributeAxisIteratorWithEnum() {        DummyNodeWithEnum dummyNode = new DummyNodeWithEnum();        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        Set<String> expected = CollectionUtil.setUnion(DEFAULT_ATTRS, "Enum");        assertEquals(expected, toMap(it).keySet());    }    @Test    public void testAttributeAxisIteratorWithList() {        // list attributes are not supported anymore        DummyNodeWithList dummyNode = new DummyNodeWithList();        AttributeAxisIterator it = new AttributeAxisIterator(dummyNode);        assertEquals(DEFAULT_ATTRS, toMap(it).keySet());    }    private Map<String, Attribute> toMap(AttributeAxisIterator it) {        Map<String, Attribute> atts = new HashMap<>();        while (it.hasNext()) {            Attribute attribute = it.next();            atts.put(attribute.getName(), attribute);        }        return atts;    }    public static class DummyNodeWithEnum extends DummyNode {        public enum MyEnum {            FOO, BAR        }        public MyEnum getEnum() {            return MyEnum.FOO;        }    }    public static class DummyNodeWithList extends DummyNode {        public List<String> getList() {            return Arrays.asList("A", "B");        }        public List<Node> getNodeList() {            return Collections.emptyList();        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html *//* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule.xpath;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Set;import java.util.stream.Collectors;import org.junit.Test;import net.sourceforge.pmd.internal.util.IteratorUtil;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.NoAttribute.NoAttrScope;/** * @author Clment Fournier */public class NoAttributeTest {    @Test    public void testNoAttrInherited() {        Node child = new NodeNoInherited();        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        assertTrue(attrNames.contains("SomeInt"));        assertTrue(attrNames.contains("Child"));        // from Node        assertTrue(attrNames.contains("BeginLine"));        assertFalse(attrNames.contains("SomeLong"));        assertFalse(attrNames.contains("Image"));        assertFalse(attrNames.contains("SomeName"));    }    @Test    public void testNoAttrAll() {        assertTrue(0 < IteratorUtil.count(new NodeAllAttr(12).getXPathAttributesIterator()));        NodeNoAttrAll child = new NodeNoAttrAll();        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        // from Noded, so not suppressed        assertTrue(attrNames.contains("Image"));        assertFalse(attrNames.contains("MySuppressedAttr"));    }    @Test    public void testNoAttrAllIsNotInherited() {        NodeNoAttrAllChild child = new NodeNoAttrAllChild();        Set<String> attrNames = IteratorUtil.toList(child.getXPathAttributesIterator()).stream().map(Attribute::getName).collect(Collectors.toSet());        // suppressed because the parent has NoAttribute(scope = ALL)        assertFalse(attrNames.contains("MySuppressedAttr"));        // not suppressed because defined in the class, which has no annotation        assertTrue(attrNames.contains("NotSuppressedAttr"));    }    private static class DummyNodeParent extends DummyNode {        DummyNodeParent() {            super();        }        public String getSomeName() {            return "Foo";        }        public int getSomeInt() {            return 42;        }        public long getSomeLong() {            return 42;        }        public long getSomeLong2() {            return 42;        }    }    @NoAttribute(scope = NoAttrScope.INHERITED)    private static class NodeNoInherited extends DummyNodeParent {        // getSomeName is inherited and filtered out by NoAttrScope.INHERITED        // getSomeInt is inherited but overridden here, so NoAttrScope.INHERITED has no effect        // getSomeLong is inherited and overridden here,        //      and even with scope INHERITED its @NoAttribute takes precedence        // isChild overrides nothing so with INHERITED it's not filtered out        @Override        public int getSomeInt() {            return 43;        }        @NoAttribute // Notice        @Override        public long getSomeLong() {            return 43;        }        @NoAttribute(scope = NoAttrScope.INHERITED)        @Override        public String getImage() {            return super.getImage();        }        public boolean isChild() {            return true;        }    }    private static class NodeAllAttr extends DummyNodeParent {        NodeAllAttr(int id) {            super();        }    }    @NoAttribute(scope = NoAttrScope.ALL)    private static class NodeNoAttrAll extends DummyNodeParent {        public int getMySuppressedAttr() {            return 12;        }    }    private static class NodeNoAttrAllChild extends NodeNoAttrAll {        public int getNotSuppressedAttr() {            return 12;        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import static org.hamcrest.MatcherAssert.assertThat;import static org.junit.Assert.assertEquals;import org.hamcrest.Matchers;import org.junit.Rule;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleContextTest;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNodeWithDeprecatedAttribute;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;public class XPathRuleTest {    @Rule    public JavaUtilLoggingRule loggingRule = new JavaUtilLoggingRule(Attribute.class.getName());    @Test    public void testAttributeDeprecation10() throws Exception {        testDeprecation(XPathVersion.XPATH_1_0);    }    @Test    public void testAttributeDeprecation20() throws Exception {        testDeprecation(XPathVersion.XPATH_2_0);    }    public void testDeprecation(XPathVersion version) throws Exception {        XPathRule xpr = makeRule(version, "SomeRule");        loggingRule.clear();        DummyNode firstNode = newNode();        // with another rule forked from the same one (in multithreaded processor)        Report report = RuleContextTest.getReportForRuleApply(xpr, firstNode);        assertEquals(1, report.getViolations().size());        String log = loggingRule.getLog();        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Size' by XPath rule 'SomeRule'"));        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Name' by XPath rule 'SomeRule', please use @Image instead"));        loggingRule.clear();        // with another node        report = RuleContextTest.getReportForRuleApply(xpr, newNode());        assertEquals(1, report.getViolations().size());        assertEquals("", loggingRule.getLog()); // no additional warnings        // with another rule forked from the same one (in multithreaded processor)        report = RuleContextTest.getReportForRuleApply(xpr.deepCopy(), newNode());        assertEquals(1, report.getViolations().size());        assertEquals("", loggingRule.getLog()); // no additional warnings        // with another rule on the same node, new warnings        XPathRule otherRule = makeRule(version, "OtherRule");        otherRule.setRuleSetName("rset.xml");        report = RuleContextTest.getReportForRuleApply(otherRule, firstNode);        assertEquals(1, report.getViolations().size());        log = loggingRule.getLog();        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Size' by XPath rule 'OtherRule' (in ruleset 'rset.xml')"));        assertThat(log, Matchers.containsString("Use of deprecated attribute 'dummyNode/@Name' by XPath rule 'OtherRule' (in ruleset 'rset.xml'), please use @Image instead"));    }    public XPathRule makeRule(XPathVersion version, String name) {        XPathRule xpr = new XPathRule(version, "//dummyNode[@Size >= 2 and @Name='foo']");        xpr.setName(name);        xpr.setLanguage(LanguageRegistry.getLanguage("Dummy"));        xpr.setMessage("gotcha");        return xpr;    }    public DummyNode newNode() {        DummyRoot root = new DummyRoot();        DummyNode dummy = new DummyNodeWithDeprecatedAttribute(2);        dummy.setCoords(1, 1, 1, 2);        root.addChild(dummy, 0);        return root;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.rule;import java.io.File;import org.apache.commons.io.FilenameUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil;import net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;public class DefaultRuleViolationFactoryTest {    private static class TestRule extends AbstractRule {        @Override        public void apply(Node target, RuleContext ctx) {            throw new UnsupportedOperationException("not implemented");        }    }    @Test    public void testMessage() {        RuleViolation violation = makeViolation("Some message");        Assert.assertEquals("Some message", violation.getDescription());    }    @Test    public void testMessageEscaping() {        RuleViolation violation = makeViolation("message with \"'{'\"");        Assert.assertEquals("message with \"{\"", violation.getDescription());    }    @Test    public void testMessageEscaping2() {        RuleViolation violation = makeViolation("message with ${ohio}");        Assert.assertEquals("message with ${ohio}", violation.getDescription());    }    private RuleViolation makeViolation(String unescapedMessage, Object... args) {        return DefaultRuleViolationFactory.defaultInstance().formatViolation(new TestRule(),                DummyTreeUtil.tree(DummyRoot::new), "file", unescapedMessage, args);    }    /**     * Note: although this test tests a deprecated method, the test is needed.     * Where ever the logic goes to pass the filename to the violation, the test     * needs to follow. That means, whoever will call     * {@link RuleViolationFactory#formatViolation(net.sourceforge.pmd.Rule, Node, String, String, Object[])}     * need to pass the full filename.     */    @Test    public void violationShouldHaveFullPathname() {        String filename = "full/path/name.ext";        RuleContext ruleContext = new RuleContext();        ruleContext.setSourceCodeFile(new File(filename));        DummyRoot node = DummyTreeUtil.tree(DummyRoot::new);        node.setCoords(1, 1, 1, 10);        DefaultRuleViolationFactory.defaultInstance().addViolation(ruleContext, new TestRule(),                node, "message", new Object[0]);        RuleViolation violation = ruleContext.getReport().getViolations().get(0);        Assert.assertEquals(filename, FilenameUtils.normalize(violation.getFilename(), true));    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.internal;import static junit.framework.TestCase.assertEquals;import static junit.framework.TestCase.assertSame;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.nodeB;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.function.Predicate;import java.util.stream.Collectors;import java.util.stream.Stream;import org.junit.Assert;import org.junit.Assume;import org.junit.Rule;import org.junit.Test;import org.junit.rules.ExpectedException;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyNodeTypeB;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;/** * Asserts invariants independent of the NodeStream implementation. Error * messages are not great but coverage is. */@RunWith(Parameterized.class)public class NodeStreamBlanketTest<T extends Node> {    private static final List<Node> ASTS = Arrays.asList(        tree(            () ->                root(                    node(                        node(),                        nodeB(                            node(                                nodeB()                            )                        ),                        node(),                        nodeB()                    ),                    node()                )        ),        tree(            () ->                root(                    node(),                    node(),                    nodeB(                        node()                    ),                    node()                )        )    );    @Rule    public ExpectedException expect = ExpectedException.none();    private final NodeStream<T> stream;    public NodeStreamBlanketTest(NodeStream<T> stream) {        this.stream = stream;    }    @Test    public void testToListConsistency() {        List<T> toList = stream.toList();        List<T> collected = stream.collect(Collectors.toList());        List<T> fromStream = stream.toStream().collect(Collectors.toList());        List<T> cached = stream.cached().toList();        assertEquals(toList, collected);        assertEquals(toList, fromStream);        assertEquals(toList, cached);    }    @Test    public void testToListSize() {        List<T> toList = stream.toList();        assertEquals(toList.size(), stream.count());    }    @Test    public void testLast() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("last() == toList().last()", it -> it.last() == it.toList().get(it.count() - 1))        );    }    @Test    public void testFirst() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("first() == toList().get(0)", it -> it.first() == it.toList().get(0))        );    }    @Test    public void testDrop() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("drop(0) == this", it -> it.drop(0) == it),            prop("drop(1).count() == count() - 1", it -> it.drop(1).count() == it.count() - 1),            prop("drop(1).toList() == toList().tail()", it -> it.drop(1).toList().equals(tail(it.toList())))        );    }    @Test    public void testDropMoreThan1() {        assertImplication(            stream,            prop("count() > 1", it -> it.count() > 1),            prop("drop(2).toList() == toList().tail().tail()", it -> it.drop(2).toList().equals(tail(tail(it.toList())))),            prop("drop(1).drop(1) == drop(2)", it -> it.drop(1).drop(1).toList().equals(it.drop(2).toList()))        );    }    @Test    public void testTake() {        assertImplication(            stream,            prop("nonEmpty", NodeStream::nonEmpty),            prop("it.take(0).count() == 0", it -> it.take(0).count() == 0),            prop("it.take(1).count() == 1", it -> it.take(1).count() == 1),            prop("it.take(it.count()).count() == it.count()", it -> it.take(it.count()).count() == it.count())        );    }    @Test    public void testGet() {        for (int i = 0; i < 100; i++) {            assertSame("stream.get(i) == stream.drop(i).first()", stream.get(i), stream.drop(i).first());        }    }    @Test    public void testGetNegative() {        expect.expect(IllegalArgumentException.class);        stream.get(-1);    }    @Test    public void testDropNegative() {        expect.expect(IllegalArgumentException.class);        stream.drop(-1);    }    @Test    public void testTakeNegative() {        expect.expect(IllegalArgumentException.class);        stream.take(-1);    }    @Test    public void testEmpty() {        assertEquivalence(            stream,            prop("isEmpty", NodeStream::isEmpty),            prop("!nonEmpty", it -> !it.nonEmpty()),            prop("last() == null", it -> it.last() == null),            prop("first() == null", it -> it.first() == null),            prop("first(_ -> true) == null", it -> it.first(i -> true) == null),            prop("first(Node.class) == null", it -> it.first(Node.class) == null),            prop("count() == 0", it -> it.count() == 0),            prop("any(_) == false", it -> !it.any(i -> true)),            prop("all(_) == true", it -> it.all(i -> false)),            prop("none(_) == true", it -> it.none(i -> true))        );    }    @Parameterized.Parameters(name = "{index} On {0}")    public static Collection<?> primeNumbers() {        return ASTS.stream().flatMap(            root -> Stream.of(                root.asStream(),                root.children().first().asStream(),                NodeStream.empty()            )        ).flatMap(            // add some transformations on each of them            stream -> Stream.of(                stream,                stream.drop(1),                stream.take(2),                stream.filter(n -> !n.getImage().isEmpty()),                stream.firstChild(DummyNodeTypeB.class),                stream.children(DummyNodeTypeB.class),                stream.descendants(DummyNodeTypeB.class),                stream.ancestors(DummyNodeTypeB.class),                stream.descendants(),                stream.ancestors(),                stream.ancestorsOrSelf(),                stream.followingSiblings(),                stream.precedingSiblings(),                stream.descendantsOrSelf(),                stream.children(),                stream.children().filter(c -> c.getImage().equals("0")),                stream.children(DummyNode.class)            )        ).flatMap(            // add some transformations on each of them            stream -> Stream.of(                stream,                stream.filterIs(DummyNode.class),                stream.take(1),                stream.drop(1),                stream.filter(n -> !n.getImage().isEmpty()),                stream.cached()            )        ).collect(Collectors.toCollection(ArrayList::new));    }    @SafeVarargs    private static <T> void assertEquivalence(T input, Prop<? super T>... properties) {        for (Prop<? super T> prop1 : properties) {            for (Prop<? super T> prop2 : properties) {                boolean p1 = prop1.test(input);                Assert.assertEquals(                    "Expected (" + prop1.description + ") === (" + prop2.description                        + "), but the LHS was " + p1 + " and the RHS was " + !p1,                    p1, prop2.test(input)                );            }        }    }    @SafeVarargs    private static <T> void assertImplication(T input, Prop<? super T> precond, Prop<? super T>... properties) {        Assume.assumeTrue(precond.test(input));        for (Prop<? super T> prop2 : properties) {            Assert.assertTrue(                "Expected (" + precond.description + ") to entail (" + prop2.description                    + "), but the latter was false",                prop2.test(input)            );        }    }    static <T> Prop<T> prop(String desc, Predicate<? super T> pred) {        return new Prop<>(pred, desc);    }    static <T> List<T> tail(List<T> ts) {        return ts.subList(1, ts.size());    }    static class Prop<T> {        final Predicate<? super T> property;        final String description;        Prop(Predicate<? super T> property, String description) {            this.property = property;            this.description = description;        }        boolean test(T t) {            return property.test(t);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.internal;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.followPath;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.nodeB;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.pathsOf;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.collection.IsIterableContainingInOrder.contains;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertThat;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.Optional;import org.apache.commons.lang3.mutable.MutableInt;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyNode.DummyNodeTypeB;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.NodeStream;import net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream;/** * @author Clment Fournier */public class NodeStreamTest {    private final DummyNode tree1 = tree(        () ->            root(// ""                 nodeB(// 0                       node(), // 00                       nodeB(// 01                             node(), // 010                             node(// 011                                     node() // 0110                             ),                             node(), // 012                             node()  // 013                       )                 ),                 node() // 1            )    );    private final DummyNode tree2 = tree(        () ->            root(                node(),                node(),                node(                    node()                ),                node()            )    );    @Test    public void testStreamConstructionIsNullSafe() {        assertTrue(NodeStream.of((Node) null).isEmpty());        assertThat(NodeStream.of(null, null, tree1).count(), equalTo(1));        assertThat(NodeStream.fromIterable(Arrays.asList(tree1, null, null)).count(), equalTo(1));        assertThat(NodeStream.ofOptional(Optional.empty()).count(), equalTo(0));    }    @Test    public void testMapIsNullSafe() {        assertTrue(tree1.descendantsOrSelf().map(n -> null).isEmpty());    }    @Test    public void testFlatMapIsNullSafe() {        assertTrue(tree1.descendantsOrSelf().flatMap(n -> null).isEmpty());    }    @Test    public void testChildrenStream() {        assertThat(pathsOf(tree1.children()), contains("0", "1"));        assertThat(pathsOf(tree1.asStream().children()), contains("0", "1"));    }    @Test    public void testChildrenEagerEvaluation() {        NodeStream<? extends Node> children = tree1.children();        assertEquals(AxisStream.ChildrenStream.class, children.getClass());        NodeStream<Node> children1 = children.children();        assertEquals(GreedyNStream.GreedyKnownNStream.class, children1.getClass());        assertEquals(SingletonNodeStream.class, children1.filter(it -> it.getImage().endsWith("1")).getClass());    }    @Test    public void testDescendantStream() {        assertThat(pathsOf(tree1.descendants()), contains("0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(tree1.asStream().descendants()), contains("0", "00", "01", "010", "011", "0110", "012", "013", "1"));    }    @Test    public void testSingletonStream() {        assertThat(pathsOf(tree1.asStream()), contains(""));        assertThat(pathsOf(NodeStream.of(tree1)), contains(""));    }    @Test    public void testDescendantOrSelfStream() {        assertThat(pathsOf(tree1.descendantsOrSelf()), contains("", "0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(NodeStream.of(tree1).descendantsOrSelf()), contains("", "0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(followPath(tree1, "0110").descendantsOrSelf()), contains("0110")); // with a leaf node    }    @Test    public void testAncestors() {        // 010        Node node = tree1.children().children().children().first();        assertEquals("010", node.getImage());        assertThat(pathsOf(node.ancestors()), contains("01", "0", ""));        assertThat(pathsOf(node.ancestorsOrSelf()), contains("010", "01", "0", ""));        assertEquals("01", node.getNthParent(1).getImage());        assertEquals("0", node.getNthParent(2).getImage());        assertEquals("", node.getNthParent(3).getImage());        assertNull(node.getNthParent(4));    }    @Test    public void testAncestorsFiltered() {        // 0110        Node node = tree1.children().children().children().children().first();        assertEquals("0110", node.getImage());        assertThat(pathsOf(node.ancestors(DummyNodeTypeB.class)), contains("01", "0"));        assertThat(pathsOf(node.ancestorsOrSelf().filterIs(DummyNodeTypeB.class)), contains("01", "0"));    }    @Test    public void testAncestorsFilteredDrop() {        // 0110        Node node = tree1.children().children().children().children().first();        assertEquals("0110", node.getImage());        assertThat(pathsOf(node.ancestors(DummyNodeTypeB.class).drop(1)), contains("0"));        assertThat(pathsOf(node.ancestorsOrSelf().filterIs(DummyNodeTypeB.class).drop(1)), contains("0"));    }    @Test    public void testFollowingSiblings() {        assertThat(pathsOf(followPath(tree2, "2").asStream().followingSiblings()), contains("3"));        assertThat(pathsOf(followPath(tree2, "0").asStream().followingSiblings()), contains("1", "2", "3"));        assertTrue(pathsOf(followPath(tree2, "3").asStream().followingSiblings()).isEmpty());    }    @Test    public void testPrecedingSiblings() {        assertThat(pathsOf(followPath(tree2, "2").asStream().precedingSiblings()), contains("0", "1"));        assertThat(pathsOf(followPath(tree2, "3").asStream().precedingSiblings()), contains("0", "1", "2"));        assertTrue(pathsOf(followPath(tree2, "0").asStream().precedingSiblings()).isEmpty());    }    @Test    public void testRootSiblings() {        assertTrue(tree2.asStream().precedingSiblings().isEmpty());        assertTrue(tree2.asStream().followingSiblings().isEmpty());    }    @Test    public void testAncestorStream() {        assertThat(pathsOf(followPath(tree1, "01").ancestors()), contains("0", ""));        assertThat(pathsOf(followPath(tree1, "01").asStream().ancestors()), contains("0", ""));    }    @Test    public void testParentStream() {        assertThat(pathsOf(followPath(tree1, "01").asStream().parents()), contains("0"));    }    @Test    public void testAncestorStreamUnion() {        assertThat(pathsOf(NodeStream.union(followPath(tree1, "01").ancestors(),                                            tree2.children().ancestors())), contains("0", "", "", "", "", ""));    }    @Test    public void testDistinct() {        assertThat(pathsOf(NodeStream.union(followPath(tree1, "01").ancestors(),                                            tree2.children().ancestors()).distinct()), contains("0", "", "")); // roots of both trees    }    @Test    public void testGet() {        // ("0", "00", "01", "010", "011", "0110", "012", "013", "1")        DescendantNodeStream<DummyNode> stream = tree1.descendants();        assertEquals("0", stream.get(0).getImage());        assertEquals("00", stream.get(1).getImage());        assertEquals("010", stream.get(3).getImage());        assertEquals("011", stream.get(4).getImage());        assertEquals("0110", stream.get(5).getImage());        assertNull(stream.get(9));    }    @Test    public void testNodeStreamsCanBeIteratedSeveralTimes() {        DescendantNodeStream<DummyNode> stream = tree1.descendants();        assertThat(stream.count(), equalTo(9));        assertThat(stream.count(), equalTo(9));        assertThat(pathsOf(stream), contains("0", "00", "01", "010", "011", "0110", "012", "013", "1"));        assertThat(pathsOf(stream.filter(n -> n.getNumChildren() == 0)),                   contains("00", "010", "0110", "012", "013", "1"));    }    @Test    public void testNodeStreamPipelineIsLazy() {        MutableInt numEvals = new MutableInt();        tree1.descendants().filter(n -> {            numEvals.increment();            return true;        });        assertThat(numEvals.getValue(), equalTo(0));    }    @Test    public void testForkJoinUpstreamPipelineIsExecutedAtMostOnce() {        MutableInt numEvals = new MutableInt();        NodeStream<Node> stream =            NodeStream                .forkJoin(                    hook(numEvals::increment, tree1.descendants()),                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo("0")),                    n -> NodeStream.of(n).filter(m -> m.hasImageEqualTo("1"))                );        // assertThat(numEvals.getValue(), equalTo(0)); // not evaluated yet        assertThat(stream.count(), equalTo(2));        assertThat(numEvals.getValue(), equalTo(9)); // evaluated *once* every element of the upper stream        assertThat(stream.count(), equalTo(2));        assertThat(numEvals.getValue(), equalTo(9)); // not reevaluated    }    @Test    public void testCachedStreamUpstreamPipelineIsExecutedAtMostOnce() {        MutableInt upstreamEvals = new MutableInt();        MutableInt downstreamEvals = new MutableInt();        NodeStream<DummyNode> stream =            tree1.descendants()                 .filter(n -> n.getImage().matches("0.*"))                 .take(4)                 .peek(n -> upstreamEvals.increment())                 .cached()                 .filter(n -> true)                 .peek(n -> downstreamEvals.increment());        // assertThat(upstreamEvals.getValue(), equalTo(0));   // not evaluated yet        assertThat(stream.count(), equalTo(4));        assertThat(upstreamEvals.getValue(), equalTo(4));   // evaluated once        assertThat(downstreamEvals.getValue(), equalTo(4)); // evaluated once        assertThat(stream.count(), equalTo(4));        assertThat(upstreamEvals.getValue(), equalTo(4));   // upstream was not reevaluated        assertThat(downstreamEvals.getValue(), equalTo(4)); // downstream was not reevaluated    }    @Test    public void testUnionIsLazy() {        MutableInt tree1Evals = new MutableInt();        MutableInt tree2Evals = new MutableInt();        NodeStream<Node> unionStream = NodeStream.union(tree1.descendantsOrSelf().peek(n -> tree1Evals.increment()),                                                        tree2.descendantsOrSelf().peek(n -> tree2Evals.increment()));        assertThat(tree1Evals.getValue(), equalTo(0));   // not evaluated yet        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated yet        assertSame(unionStream.first(), tree1);        assertThat(tree1Evals.getValue(), equalTo(1));   // evaluated once        assertThat(tree2Evals.getValue(), equalTo(0));   // not evaluated    }    @Test    public void testSomeOperationsAreLazy() {        MutableInt tree1Evals = new MutableInt();        NodeStream<DummyNode> unionStream = tree1.descendantsOrSelf().peek(n -> tree1Evals.increment());        int i = 0;        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated yet        unionStream.first();        assertThat(tree1Evals.getValue(), equalTo(++i));    // evaluated once        unionStream.nonEmpty();        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation        unionStream.isEmpty();        assertThat(tree1Evals.getValue(), equalTo(i));     // not evaluated, because of optimised implementation        // those don't trigger any evaluation        unionStream.map(p -> p);        unionStream.filter(p -> true);        unionStream.append(tree2.descendantsOrSelf());        unionStream.prepend(tree2.descendantsOrSelf());        unionStream.flatMap(Node::descendantsOrSelf);        unionStream.iterator();        // unionStream.cached();        unionStream.descendants();        unionStream.ancestors();        unionStream.followingSiblings();        unionStream.precedingSiblings();        unionStream.children();        unionStream.distinct();        unionStream.take(4);        unionStream.drop(4);        assertThat(tree1Evals.getValue(), equalTo(i));      // not evaluated    }    @Test    public void testFollowingSiblingsNonEmpty() {        DummyNode node = followPath(tree1, "012");        NodeStream<Node> nodes = node.asStream().followingSiblings();        assertTrue(nodes instanceof SingletonNodeStream);        assertEquals("013", nodes.first().getImage());    }    @Test    public void testPrecedingSiblingsNonEmpty() {        DummyNode node = followPath(tree1, "011");        NodeStream<Node> nodes = node.asStream().precedingSiblings();        assertTrue(nodes instanceof SingletonNodeStream);        assertEquals("010", nodes.first().getImage());    }    @Test    public void testPrecedingSiblingsDrop() {        DummyNode node = followPath(tree1, "012");        NodeStream<Node> nodes = node.asStream().precedingSiblings().drop(1);        assertThat(pathsOf(nodes), contains("011"));    }    @Test    public void testFollowingSiblingsDrop() {        DummyNode node = followPath(tree1, "011");        NodeStream<Node> nodes = node.asStream().followingSiblings().drop(1);        assertThat(pathsOf(nodes), contains("013"));    }    private static <T extends Node> NodeStream<T> hook(Runnable hook, NodeStream<T> stream) {        return stream.filter(t -> {            hook.run();            return true;        });    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast.impl;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.node;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.root;import static net.sourceforge.pmd.lang.ast.impl.DummyTreeUtil.tree;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import static org.junit.Assert.fail;import java.util.List;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.runner.RunWith;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.xpath.Attribute;import junitparams.JUnitParamsRunner;import junitparams.Parameters;/** * Unit test for {@link AbstractNode}. */@RunWith(JUnitParamsRunner.class)public class AbstractNodeTest {    private static final int NUM_CHILDREN = 3;    private static final int NUM_GRAND_CHILDREN = 3;    @Rule    public JavaUtilLoggingRule loggingRule = new JavaUtilLoggingRule(Attribute.class.getName());    // Note that in order to successfully run JUnitParams, we need to explicitly use `Integer` instead of `int`    private Integer[] childrenIndexes() {        return getIntRange(NUM_CHILDREN);    }    private Integer[] grandChildrenIndexes() {        return getIntRange(NUM_GRAND_CHILDREN);    }    private static Integer[] getIntRange(final int exclusiveLimit) {        final Integer[] childIndexes = new Integer[exclusiveLimit];        for (int i = 0; i < exclusiveLimit; i++) {            childIndexes[i] = i;        }        return childIndexes;    }    public Object childrenAndGrandChildrenIndexes() {        final Integer[] childrenIndexes = childrenIndexes();        final Integer[] grandChildrenIndexes = grandChildrenIndexes();        final Object[] indexes = new Object[childrenIndexes.length * grandChildrenIndexes.length];        int i = 0;        for (final int childIndex : childrenIndexes) {            for (final int grandChildIndex : grandChildrenIndexes) {                indexes[i++] = new Integer[] { childIndex, grandChildIndex };            }        }        return indexes;    }    private DummyRoot rootNode;    @Before    public void setUpSampleNodeTree() {        rootNode = tree(            () -> {                DummyRoot root = root();                for (int i = 0; i < NUM_CHILDREN; i++) {                    final DummyNode child = node();                    for (int j = 0; j < NUM_GRAND_CHILDREN; j++) {                        child.addChild(node(), j);                    }                    root.addChild(child, i);                }                return root;            }        );    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method     */    @Test    @Parameters(method = "childrenIndexes")    public void testRemoveChildOfRootNode(final int childIndex) {        final DummyNode child = rootNode.getChild(childIndex);        final List<? extends DummyNode> grandChildren = child.children().toList();        // Do the actual removal        child.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.getNumChildren());        assertNull(child.getParent());        // The child node is expected to still have all its children and vice versa        assertEquals(NUM_GRAND_CHILDREN, child.getNumChildren());        for (final Node grandChild : grandChildren) {            assertEquals(child, grandChild.getParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * This is a border case as the root node does not have any parent.     */    @Test    public void testRemoveRootNode() {        // Check that the root node has the expected properties        final List<? extends DummyNode> children = rootNode.children().toList();        // Do the actual removal        rootNode.remove();        // Check that conditions have been successfully changed, i.e.,        //  the root node is expected to still have all its children and vice versa        assertEquals(NUM_CHILDREN, rootNode.getNumChildren());        assertNull(rootNode.getParent());        for (final Node aChild : children) {            assertEquals(rootNode, aChild.getParent());        }    }    /**     * Explicitly tests the {@code remove} method, and implicitly the {@code removeChildAtIndex} method.     * These are border cases as grandchildren nodes do not have any child.     */    @Test    @Parameters(method = "childrenAndGrandChildrenIndexes")    public void testRemoveGrandChildNode(final int childIndex, final int grandChildIndex) {        final DummyNode child = rootNode.getChild(childIndex);        final DummyNode grandChild = child.getChild(grandChildIndex);        // Do the actual removal        grandChild.remove();        // Check that conditions have been successfully changed        assertEquals(NUM_GRAND_CHILDREN - 1, child.getNumChildren());        assertEquals(0, grandChild.getNumChildren());        assertNull(grandChild.getParent());    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     */    @Test    @Parameters(method = "childrenIndexes")    public void testRemoveRootNodeChildAtIndex(final int childIndex) {        final List<? extends DummyNode> originalChildren = rootNode.children().toList();        // Do the actual removal        rootNode.removeChildAtIndex(childIndex);        // Check that conditions have been successfully changed        assertEquals(NUM_CHILDREN - 1, rootNode.getNumChildren());        int j = 0;        for (int i = 0; i < rootNode.getNumChildren(); i++) {            if (j == childIndex) { // Skip the removed child                j++;            }            // Check that the nodes have been rightly shifted            assertEquals(originalChildren.get(j), rootNode.getChild(i));            // Check that the child index has been updated            assertEquals(i, rootNode.getChild(i).getIndexInParent());            j++;        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * Test that invalid indexes cases are handled without exception.     */    @Test    public void testRemoveChildAtIndexWithInvalidIndex() {        try {            rootNode.removeChildAtIndex(-1);            rootNode.removeChildAtIndex(rootNode.getNumChildren());        } catch (final Exception e) {            fail("No exception was expected.");        }    }    /**     * Explicitly tests the {@code removeChildAtIndex} method.     * This is a border case as the method invocation should do nothing.     */    @Test    @Parameters(method = "grandChildrenIndexes")    public void testRemoveChildAtIndexOnNodeWithNoChildren(final int grandChildIndex) {        // grandChild does not have any child        final DummyNode grandChild = rootNode.getChild(grandChildIndex).getChild(grandChildIndex);        // Do the actual removal        grandChild.removeChildAtIndex(0);        // If here, no exception has been thrown        // Check that this node still does not have any children        assertEquals(0, grandChild.getNumChildren());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import org.junit.Test;/** * Unit test for {@link SourceCodePositioner}. */public class SourceCodePositionerTest {    private static final String SOURCE_CODE = "abcd\ndefghi\n\njklmn\nopq";    /**     * Tests whether the lines and columns are calculated correctly.     */    @Test    public void testLineNumberFromOffset() {        SourceCodePositioner positioner = new SourceCodePositioner(SOURCE_CODE);        int offset;        offset = SOURCE_CODE.indexOf('a');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(1, positioner.columnFromOffset(1, offset));        offset = SOURCE_CODE.indexOf('b');        assertEquals(1, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(1, offset));        offset = SOURCE_CODE.indexOf('e');        assertEquals(2, positioner.lineNumberFromOffset(offset));        assertEquals(2, positioner.columnFromOffset(2, offset));        offset = SOURCE_CODE.indexOf('q');        assertEquals(5, positioner.lineNumberFromOffset(offset));        assertEquals(3, positioner.columnFromOffset(5, offset));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.List;import org.junit.Before;import org.junit.Test;/** * Unit test for {@link Node} tree traversal methods */public class BoundaryTraversalTest {    private DummyNode rootNode;    private DummyNode newDummyNode(boolean boundary) {        return new DummyNode(boundary);    }    private DummyNode addChild(final DummyNode parent, final DummyNode child) {        parent.addChild(child, parent.getNumChildren()); // Append child at the end        return parent;    }    @Before    public void setUpSampleNodeTree() {        rootNode = newDummyNode(false);    }    @Test    public void testBoundaryIsHonored() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.descendants(DummyNode.class).toList();        assertEquals(1, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());    }    @Test    public void testSearchFromBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.descendants(DummyNode.class).first().descendants(DummyNode.class).toList();        assertEquals(1, descendantsOfType.size());        assertFalse(descendantsOfType.get(0).isFindBoundary());    }    @Test    public void testSearchFromBoundaryFromNonOptimisedStream() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.descendants(DummyNode.class).take(1).descendants(DummyNode.class).toList();        assertEquals(1, descendantsOfType.size());        assertFalse(descendantsOfType.get(0).isFindBoundary());    }    @Test    public void testSearchIgnoringBoundary() {        addChild(rootNode, addChild(newDummyNode(true), newDummyNode(false)));        List<DummyNode> descendantsOfType = rootNode.findDescendantsOfType(DummyNode.class, true);        assertEquals(2, descendantsOfType.size());        assertTrue(descendantsOfType.get(0).isFindBoundary());        assertFalse(descendantsOfType.get(1).isFindBoundary());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;public class LanguageRegistryTest {    @Test    public void getDefaultLanguageTest() {        Language defaultLanguage = LanguageRegistry.getDefaultLanguage();        Assert.assertNotNull(defaultLanguage);        // as we don't have java language in this test, we get the first        // available language now -> DummyLanguage        Assert.assertSame(DummyLanguageModule.class, defaultLanguage.getClass());    }    @Test    public void getDefaultVersionLanguageTest() {        Language dummy = LanguageRegistry.findLanguageByTerseName("dummy");        LanguageVersion dummy12 = dummy.getVersion("1.2");        Assert.assertNotNull(dummy12);        LanguageVersion dummyDefault = dummy.getDefaultVersion();        Assert.assertNotNull(dummyDefault);        Assert.assertNotSame(dummy12, dummyDefault);    }    @Test    public void getLanguageVersionByAliasTest() {        Language dummy = LanguageRegistry.findLanguageByTerseName("dummy");        LanguageVersion dummy17 = dummy.getVersion("1.7");        Assert.assertNotNull(dummy17);        Assert.assertEquals("1.7", dummy17.getVersion());        LanguageVersion dummy7 = dummy.getVersion("7");        Assert.assertNotNull(dummy7);        Assert.assertEquals("1.7", dummy17.getVersion());        Assert.assertSame(dummy17, dummy7);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang;import org.junit.Assert;import org.junit.Test;public class BaseLanguageModuleTest {    @Test    public void testHashCodeEquals() {        Language l1 = new DummyLanguageModule();        Language l1a = new DummyLanguageModule();        Language l2 = new Dummy2LanguageModule();        Assert.assertEquals(l1.hashCode(), l1a.hashCode());        Assert.assertNotEquals(l1.hashCode(), l2.hashCode());        Assert.assertEquals(l1, l1a);        Assert.assertNotEquals(l1, l2);    }    @Test    public void testCompareTo() {        Language l1 = new DummyLanguageModule();        Language l2 = new Dummy2LanguageModule();        Assert.assertTrue(l1.compareTo(l2) < 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties.constraints;import org.junit.Assert;import org.junit.Test;public class NumericConstraintsTest {    @Test    public void testInRangeInteger() {        PropertyConstraint<Integer> constraint = NumericConstraints.inRange(1, 10);        Assert.assertTrue(constraint.test(1));        Assert.assertTrue(constraint.test(5));        Assert.assertTrue(constraint.test(10));        Assert.assertFalse(constraint.test(0));        Assert.assertFalse(constraint.test(-1));        Assert.assertFalse(constraint.test(11));        Assert.assertFalse(constraint.test(100));    }    @Test    public void testInRangeDouble() {        PropertyConstraint<Double> constraint = NumericConstraints.inRange(1.0, 10.0);        Assert.assertTrue(constraint.test(1.0));        Assert.assertTrue(constraint.test(5.5));        Assert.assertTrue(constraint.test(10.0));        Assert.assertFalse(constraint.test(0.0));        Assert.assertFalse(constraint.test(-1.0));        Assert.assertFalse(constraint.test(11.1));        Assert.assertFalse(constraint.test(100.0));    }    @Test    public void testPositive() {        PropertyConstraint<Number> constraint = NumericConstraints.positive();        Assert.assertTrue(constraint.test(1));        Assert.assertTrue(constraint.test(1.5f));        Assert.assertTrue(constraint.test(1.5d));        Assert.assertTrue(constraint.test(100));        Assert.assertFalse(constraint.test(0));        Assert.assertFalse(constraint.test(0.1f));        Assert.assertFalse(constraint.test(0.9d));        Assert.assertFalse(constraint.test(-1));        Assert.assertFalse(constraint.test(-100));        Assert.assertFalse(constraint.test(-0.1f));        Assert.assertFalse(constraint.test(-0.1d));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import java.util.regex.Pattern;/** * Since there's no RegexMultiProperty the base class is only partially implemented, * and some tests are overridden with no-op ones. * * @author Clment Fournier * @since 6.2.0 */@Deprecatedpublic class RegexPropertyTest extends AbstractPropertyDescriptorTester<Pattern> {    public RegexPropertyTest() {        super("Regex");    }    @Override    protected Pattern createValue() {        return Pattern.compile("abc++");    }    @Override    protected Pattern createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Pattern> createProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa)+").desc("the description").build();    }    @Override    protected PropertyDescriptor<Pattern> createBadProperty() {        return RegexProperty.named("foo").defaultValue("(ec|sa").desc("the description").build();    }    // The following are deliberately unimplemented, since they are only relevant to the tests of the multiproperty    @Override    protected PropertyDescriptor<List<Pattern>> createMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    protected PropertyDescriptor<List<Pattern>> createBadMultiProperty() {        throw new UnsupportedOperationException();    }    @Override    public void testAddAttributesMulti() {    }    @Override    public void testAsDelimitedString() {    }    @Override    public void testErrorForBadMulti() {    }    @Override    public void testErrorForCorrectMulti() {    }    @Override    public void testFactoryMultiValueDefaultDelimiter() {    }    @Override    public void testFactoryMultiValueCustomDelimiter() {    }    @Override    public void testTypeMulti() {    }    @Override    public void testIsMultiValueMulti() {    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.Test;/** * @author Brian Remedios */public class BooleanPropertyTest extends AbstractPropertyDescriptorTester<Boolean> {    public BooleanPropertyTest() {        super("Boolean");    }    @Override    protected Boolean createValue() {        return randomBool();    }    @Override    @Test    public void testErrorForBadSingle() {        // override, cannot create a 'bad' boolean per se    }    @Override    @Test    public void testErrorForBadMulti() {        // override, cannot create a 'bad' boolean per se    }    @Override    protected Boolean createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Boolean> createProperty() {        return new BooleanProperty("testBoolean", "Test boolean property", false, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createMultiProperty() {        return new BooleanMultiProperty("testBoolean", "Test boolean property",                                        new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<List<Boolean>> createBadMultiProperty() {        return new BooleanMultiProperty("", "Test boolean property", new Boolean[] {false, true, true}, 1.0f);    }    @Override    protected PropertyDescriptor<Boolean> createBadProperty() {        return new BooleanProperty("testBoolean", "", false, 1.0f);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the StringProperty descriptor by testing its * ability to catch creation errors (illegal args), flag invalid strings per any * specified expressions, and serialize/deserialize groups of strings onto/from * a string buffer. * * @author Brian Remedios */public class StringPropertyTest extends AbstractPropertyDescriptorTester<String> {    private static final int MAX_STRING_LENGTH = 52;    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    public StringPropertyTest() {        super("String");    }    @Override    protected String createValue() {        return newString();    }    /**     * Method newString.     *     * @return String     */    private String newString() {        int strLength = randomInt(1, MAX_STRING_LENGTH);        char[] chars = new char[strLength];        for (int i = 0; i < chars.length; i++) {            chars[i] = randomCharIn(CHARSET);        }        return new String(chars);    }    /**     * Method randomCharIn.     *     * @param chars char[]     *     * @return char     */    private char randomCharIn(char[] chars) {        return randomChar(chars);    }    @Override    protected String createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<String> createProperty() {        return new StringProperty("testString", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world"}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<String> createBadProperty() {        return new StringProperty("", "Test string property", "brian", 1.0f);    }    @Override    protected PropertyDescriptor<List<String>> createBadMultiProperty() {        return new StringMultiProperty("testString", "Test string property",                                       new String[] {"hello", "world", "a" + DELIMITER + "b"}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static java.util.Collections.emptyList;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.allOf;import static org.hamcrest.Matchers.hasItem;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.regex.Pattern;import java.util.regex.PatternSyntaxException;import org.apache.commons.lang3.StringUtils;import org.hamcrest.Matcher;import org.hamcrest.Matchers;import org.hamcrest.core.SubstringMatcher;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Rule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.properties.constraints.PropertyConstraint;/** * Mostly TODO, I'd rather implement tests on the final version of the framework. * * @author Clment Fournier * @since 7.0.0 */public class PropertyDescriptorTest {    @org.junit.Rule    public ExpectedException thrown = ExpectedException.none();    @Test    public void testConstraintViolationCausesDysfunctionalRule() {        PropertyDescriptor<Integer> intProperty = PropertyFactory.intProperty("fooProp")                                                                 .desc("hello")                                                                 .defaultValue(4)                                                                 .require(inRange(1, 10))                                                                 .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(intProperty);        rule.setProperty(intProperty, 1000);        RuleSet ruleSet = RuleSet.forSingleRule(rule);        List<Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    public void testConstraintViolationCausesDysfunctionalRuleMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        FooRule rule = new FooRule();        rule.definePropertyDescriptor(descriptor);        rule.setProperty(descriptor, Collections.singletonList(1000d)); // not in range        RuleSet ruleSet = RuleSet.forSingleRule(rule);        List<Rule> dysfunctional = new ArrayList<>();        ruleSet.removeDysfunctionalRules(dysfunctional);        assertEquals(1, dysfunctional.size());        assertThat(dysfunctional, hasItem(rule));    }    @Test    public void testDefaultValueConstraintViolationCausesFailure() {        PropertyConstraint<Integer> constraint = inRange(1, 10);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                                   containsIgnoreCase(constraint.getConstraintDescription())));        PropertyFactory.intProperty("fooProp")                       .desc("hello")                       .defaultValue(1000)                       .require(constraint)                       .build();    }    @Test    public void testDefaultValueConstraintViolationCausesFailureMulti() {        PropertyConstraint<Double> constraint = inRange(1d, 10d);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(allOf(containsIgnoreCase("Constraint violat"/*-ed or -ion*/),                                   containsIgnoreCase(constraint.getConstraintDescription())));        PropertyFactory.doubleListProperty("fooProp")                       .desc("hello")                       .defaultValues(2., 11.) // 11. is out of range                       .requireEach(constraint)                       .build();    }    @Test    public void testNoConstraintViolationCausesIsOkMulti() {        PropertyDescriptor<List<Double>> descriptor = PropertyFactory.doubleListProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValues(2., 11.) // 11. is in range                                                                     .requireEach(inRange(1d, 20d))                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertThat(descriptor.defaultValue(), Matchers.contains(2., 11.));    }    @Test    public void testNoConstraintViolationCausesIsOk() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("fooProp")                                                                     .desc("hello")                                                                     .defaultValue("bazooli")                                                                     .build();        assertEquals("fooProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("bazooli", descriptor.defaultValue());    }    @Test    public void testIntProperty() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        assertEquals("intProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Integer.valueOf(1), descriptor.defaultValue());        assertEquals(Integer.valueOf(5), descriptor.valueFrom("5"));        PropertyDescriptor<List<Integer>> listDescriptor = PropertyFactory.intListProperty("intListProp")                .desc("hello")                .defaultValues(1, 2)                .build();        assertEquals("intListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1, 2), listDescriptor.defaultValue());        assertEquals(Arrays.asList(5, 7), listDescriptor.valueFrom("5,7"));    }    @Test    public void testIntPropertyInvalidValue() {        PropertyDescriptor<Integer> descriptor = PropertyFactory.intProperty("intProp")                .desc("hello")                .defaultValue(1)                .build();        thrown.expect(NumberFormatException.class);        thrown.expectMessage("not a number");        descriptor.valueFrom("not a number");    }    @Test    public void testDoubleProperty() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        assertEquals("doubleProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(Double.valueOf(1.0), descriptor.defaultValue());        assertEquals(Double.valueOf(2.0), descriptor.valueFrom("2.0"));        PropertyDescriptor<List<Double>> listDescriptor = PropertyFactory.doubleListProperty("doubleListProp")                .desc("hello")                .defaultValues(1.0, 2.0)                .build();        assertEquals("doubleListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(1.0, 2.0), listDescriptor.defaultValue());        assertEquals(Arrays.asList(2.0, 3.0), listDescriptor.valueFrom("2.0,3.0"));    }    @Test    public void testDoublePropertyInvalidValue() {        PropertyDescriptor<Double> descriptor = PropertyFactory.doubleProperty("doubleProp")                .desc("hello")                .defaultValue(1.0)                .build();        thrown.expect(NumberFormatException.class);        thrown.expectMessage("this is not a number");        descriptor.valueFrom("this is not a number");    }    @Test    public void testStringProperty() {        PropertyDescriptor<String> descriptor = PropertyFactory.stringProperty("stringProp")                .desc("hello")                .defaultValue("default value")                .build();        assertEquals("stringProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("default value", descriptor.defaultValue());        assertEquals("foo", descriptor.valueFrom("foo"));        PropertyDescriptor<List<String>> listDescriptor = PropertyFactory.stringListProperty("stringListProp")                .desc("hello")                .defaultValues("v1", "v2")                .build();        assertEquals("stringListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList("v1", "v2"), listDescriptor.defaultValue());        assertEquals(Arrays.asList("foo", "bar"), listDescriptor.valueFrom("foo|bar"));    }    private enum SampleEnum { A, B, C }    private static Map<String, SampleEnum> nameMap = new LinkedHashMap<>();    static {        nameMap.put("TEST_A", SampleEnum.A);        nameMap.put("TEST_B", SampleEnum.B);        nameMap.put("TEST_C", SampleEnum.C);    }    @Test    public void testEnumProperty() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        assertEquals("enumProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals(SampleEnum.B, descriptor.defaultValue());        assertEquals(SampleEnum.C, descriptor.valueFrom("TEST_C"));        PropertyDescriptor<List<SampleEnum>> listDescriptor = PropertyFactory.enumListProperty("enumListProp", nameMap)                .desc("hello")                .defaultValues(SampleEnum.A, SampleEnum.B)                .build();        assertEquals("enumListProp", listDescriptor.name());        assertEquals("hello", listDescriptor.description());        assertEquals(Arrays.asList(SampleEnum.A, SampleEnum.B), listDescriptor.defaultValue());        assertEquals(Arrays.asList(SampleEnum.B, SampleEnum.C), listDescriptor.valueFrom("TEST_B|TEST_C"));    }    @Test    public void testEnumPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(containsIgnoreCase("null value"));        PropertyFactory.enumProperty("enumProp", map);    }    @Test    public void testEnumListPropertyNullValueFailsBuild() {        Map<String, SampleEnum> map = new HashMap<>(nameMap);        map.put("TEST_NULL", null);        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage(containsIgnoreCase("null value"));        PropertyFactory.enumListProperty("enumProp", map);    }    @Test    public void testEnumPropertyInvalidValue() {        PropertyDescriptor<SampleEnum> descriptor = PropertyFactory.enumProperty("enumProp", nameMap)                .desc("hello")                .defaultValue(SampleEnum.B)                .build();        thrown.expect(IllegalArgumentException.class);        thrown.expectMessage("Value was not in the set [TEST_A, TEST_B, TEST_C]");        descriptor.valueFrom("InvalidEnumValue");    }    @Test    public void testRegexProperty() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        assertEquals("regexProp", descriptor.name());        assertEquals("hello", descriptor.description());        assertEquals("^[A-Z].*$", descriptor.defaultValue().toString());        assertEquals("[0-9]+", descriptor.valueFrom("[0-9]+").toString());    }    @Test    public void testRegexPropertyInvalidValue() {        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("^[A-Z].*$")                .build();        thrown.expect(PatternSyntaxException.class);        thrown.expectMessage("Unclosed character class");        descriptor.valueFrom("[open class");    }    @Test    public void testRegexPropertyInvalidDefaultValue() {        thrown.expect(PatternSyntaxException.class);        thrown.expectMessage("Unclosed character class");        PropertyDescriptor<Pattern> descriptor = PropertyFactory.regexProperty("regexProp")                .desc("hello")                .defaultValue("[open class")                .build();    }    private static List<String> parseEscaped(String s, char d) {        return ValueParserConstants.parseListWithEscapes(s, d, ValueParserConstants.STRING_PARSER);    }    @Test    public void testStringParserEmptyString() {        assertEquals(emptyList(), parseEscaped("", ','));    }    @Test    public void testStringParserSimple() {        assertEquals(listOf("a", "b", "c"),                     parseEscaped("a,b,c", ','));    }    @Test    public void testStringParserEscapedChar() {        assertEquals(listOf("a", "b,c"),                     parseEscaped("a,b\\,c", ','));    }    @Test    public void testStringParserEscapedEscapedChar() {        assertEquals(listOf("a", "b\\", "c"),                     parseEscaped("a,b\\\\,c", ','));    }    @Test    public void testStringParserDelimIsBackslash() {        assertEquals(listOf("a,b", "", ",c"),                     parseEscaped("a,b\\\\,c", '\\'));    }    @Test    public void testStringParserTrailingBackslash() {        assertEquals(listOf("a", "b\\"),                     parseEscaped("a,b\\", ','));    }    private static Matcher<String> containsIgnoreCase(final String substring) {        return new SubstringMatcher("containing (ignoring case)", true, substring) {            @Override            protected boolean evalSubstringOf(String string) {                return StringUtils.indexOfIgnoreCase(string, substring) != -1;            }        };    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;import org.junit.Test;/** * Evaluates the functionality of the CharacterProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid characters, * and serialize/deserialize any default values. * * @author Brian Remedios */@Deprecatedpublic class CharacterPropertyTest extends AbstractPropertyDescriptorTester<Character> {    private static final char DELIMITER = '|';    private static final char[] CHARSET = filter(ALL_CHARS.toCharArray(), DELIMITER);    public CharacterPropertyTest() {        super("Character");    }    @Override    @Test    public void testErrorForBadSingle() {    } // not until char properties use illegal chars    @Override    @Test    public void testErrorForBadMulti() {    } // not until char properties use illegal chars    @Override    protected Character createValue() {        return randomChar(CHARSET);    }    @Override    protected Character createBadValue() {        return null;    }    @Override    protected PropertyDescriptor<Character> createProperty() {        return new CharacterProperty("testCharacter", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }    @Override    protected PropertyDescriptor<Character> createBadProperty() {        return new CharacterProperty("", "Test character property", 'a', 1.0f);    }    @Override    protected PropertyDescriptor<List<Character>> createBadMultiProperty() {        return new CharacterMultiProperty("testCharacter", "Test character property",                                          new Character[] {'a', 'b', 'c'}, 1.0f, DELIMITER);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the IntegerProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of integers onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedpublic class IntegerPropertyTest extends AbstractNumericPropertyDescriptorTester<Integer> {    private static final int MIN = 1;    private static final int MAX = 12;    private static final int SHIFT = 4;    public IntegerPropertyTest() {        super("Integer");    }    /*   @Override       @Test       public void testErrorForBadSingle() {       } // not until int properties get ranges       @Override       @Test       public void testErrorForBadMulti() {       } // not until int properties get ranges   */    @Override    protected Integer createValue() {        return randomInt(MIN, MAX);    }    @Override    protected Integer createBadValue() {        return randomBool() ? randomInt(MIN - SHIFT, MIN - 1) : randomInt(MAX + 1, MAX + SHIFT);    }    protected IntegerProperty.IntegerPBuilder singleBuilder() {        return IntegerProperty.named("test").desc("foo")                              .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected IntegerMultiProperty.IntegerMultiPBuilder multiBuilder() {        return IntegerMultiProperty.named("test").desc("foo")                                   .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Integer> createProperty() {        return new IntegerProperty("testInteger", "Test integer property", MIN, MAX, MAX - 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createMultiProperty() {        return new IntegerMultiProperty("testInteger", "Test integer property", MIN, MAX,                                        new Integer[] {MIN, MIN + 1, MAX - 1, MAX}, 1.0f);    }    @Override    protected PropertyDescriptor<Integer> createBadProperty() {        return new IntegerProperty("", "Test integer property", MIN, MAX, MAX + 1, 1.0f);    }    @Override    protected PropertyDescriptor<List<Integer>> createBadMultiProperty() {        return new IntegerMultiProperty("testInteger", "", MIN, MAX, new Integer[] {MIN - 1, MAX}, 1.0f);    }    @Override    protected Integer min() {        return MIN;    }    @Override    protected Integer max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the FloatProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of float values onto/from a string * buffer. * * @author Brian Remedios */public class FloatPropertyTest extends AbstractNumericPropertyDescriptorTester<Float> {    private static final float MIN = 1.0f;    private static final float MAX = 11.0f;    private static final float SHIFT = 3.0f;    public FloatPropertyTest() {        super("Float");    }    @Override    protected Float createValue() {        return randomFloat(MIN, MAX);    }    @Override    protected Float createBadValue() {        return randomBool() ? randomFloat(MIN - SHIFT, MIN) : randomFloat(MAX + 1, MAX + SHIFT);    }    @Override    protected FloatProperty.FloatPBuilder singleBuilder() {        return FloatProperty.named("test").desc("foo")                            .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected FloatMultiProperty.FloatMultiPBuilder multiBuilder() {        return FloatMultiProperty.named("test").desc("foo")                                 .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Float> createProperty() {        return new FloatProperty("testFloat", "Test float property", MIN, MAX, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", MIN, MAX,            new Float[]{6f, 9f, 1f, 2f}, 1.0f);    }    @Override    protected PropertyDescriptor<Float> createBadProperty() {        return new FloatProperty("testFloat", "Test float property", 5f, 4f, 9.0f, 1.0f);    }    @Override    protected PropertyDescriptor<List<Float>> createBadMultiProperty() {        return new FloatMultiProperty("testFloat", "Test float property", 0f, 5f,            new Float[]{-1f, 0f, 1f, 2f}, 1.0f);    }    @Override    protected Float min() {        return MIN;    }    @Override    protected Float max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * Evaluates the functionality of the DoubleProperty descriptor by testing its * ability to catch creation errors (illegal args), flag out-of-range test * values, and serialize/deserialize groups of double values onto/from a string * buffer. * * @author Brian Remedios */@Deprecatedpublic class DoublePropertyTest extends AbstractNumericPropertyDescriptorTester<Double> {    private static final double MIN = -10.0;    private static final double MAX = 100.0;    private static final double SHIFT = 5.0;    public DoublePropertyTest() {        super("Double");    }    @Override    protected Double createValue() {        return randomDouble(MIN, MAX);    }    @Override    protected Double createBadValue() {        return randomBool() ? randomDouble(MIN - SHIFT, MIN - 0.01) : randomDouble(MAX + 0.01, MAX + SHIFT);    }    protected DoubleProperty.DoublePBuilder singleBuilder() {        return DoubleProperty.named("test").desc("foo")                             .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    protected DoubleMultiProperty.DoubleMultiPBuilder multiBuilder() {        return DoubleMultiProperty.named("test").desc("foo")                                  .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Double> createProperty() {        return new DoubleProperty("testDouble", "Test double property", MIN, MAX, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {-1d, 0d, 1d, 2d}, 1.0f);    }    @Override    protected PropertyDescriptor<Double> createBadProperty() {        return new DoubleProperty("testDouble", "Test double property", MAX, MIN, 9.0, 1.0f);    }    @Override    protected PropertyDescriptor<List<Double>> createBadMultiProperty() {        return new DoubleMultiProperty("testDouble", "Test double property", MIN, MAX,                                       new Double[] {MIN - SHIFT, MIN, MIN + SHIFT, MAX + SHIFT}, 1.0f);    }    @Override    protected Double min() {        return MIN;    }    @Override    protected Double max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import java.util.List;/** * @author Clment Fournier */@Deprecatedpublic class LongPropertyTest extends AbstractNumericPropertyDescriptorTester<Long> {    private static final long MIN = 10L;    private static final long MAX = 11000L;    private static final long SHIFT = 300L;    public LongPropertyTest() {        super("Long");    }    @Override    protected Long createValue() {        return randomLong(MIN, MAX);    }    @Override    protected Long createBadValue() {        return randomBool() ? randomLong(MIN - SHIFT, MIN) : randomLong(MAX + 1, MAX + SHIFT);    }    @Override    protected LongProperty.LongPBuilder singleBuilder() {        return LongProperty.named("test").desc("foo")                           .range(MIN, MAX).defaultValue(createValue()).uiOrder(1.0f);    }    @Override    protected LongMultiProperty.LongMultiPBuilder multiBuilder() {        return LongMultiProperty.named("test").desc("foo")                                .range(MIN, MAX).defaultValues(createValue(), createValue()).uiOrder(1.0f);    }    @Override    protected PropertyDescriptor<Long> createProperty() {        return new LongProperty("testFloat", "Test float property", MIN, MAX, 90L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", MIN, MAX,            new Long[]{1000L, 10L, 100L, 20L}, 1.0f);    }    @Override    protected PropertyDescriptor<Long> createBadProperty() {        return new LongProperty("testFloat", "Test float property", 200L, -400L, 900L, 1.0f);    }    @Override    protected PropertyDescriptor<List<Long>> createBadMultiProperty() {        return new LongMultiProperty("testFloat", "Test float property", 0L, 5L,            new Long[]{-1000L, 0L, 100L, 20L}, 1.0f);    }    @Override    protected Long min() {        return MIN;    }    @Override    protected Long max() {        return MAX;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.properties;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;import org.junit.Assume;import org.junit.Test;import net.sourceforge.pmd.properties.SimpleEnumeratedPropertyTest.Foo;/** * Evaluates the functionality of the EnumeratedProperty descriptor by testing * its ability to catch creation errors (illegal args), flag invalid selections, * and serialize/deserialize selection options. * * @author Brian Remedios */@Deprecatedpublic class SimpleEnumeratedPropertyTest extends AbstractPropertyDescriptorTester<Foo> {    private static final String[] KEYS = {"bar", "na", "bee", "coo"};    private static final Foo[] VALUES = {Foo.BAR, Foo.NA, Foo.BEE, Foo.COO};    private static final Map<String, Foo> MAPPINGS;    static {        Map<String, Foo> map = new HashMap<>();        map.put("bar", Foo.BAR);        map.put("na", Foo.NA);        map.put("bee", Foo.BEE);        map.put("coo", Foo.COO);        MAPPINGS = Collections.unmodifiableMap(map);    }    public SimpleEnumeratedPropertyTest() {        super("Enum");    }    @Test    public void testMappings() {        EnumeratedPropertyDescriptor<Foo, Foo> prop            = (EnumeratedPropertyDescriptor<Foo, Foo>) createProperty();        EnumeratedPropertyDescriptor<Foo, List<Foo>> multi            = (EnumeratedPropertyDescriptor<Foo, List<Foo>>) createMultiProperty();        assertEquals(MAPPINGS, prop.mappings());        assertEquals(MAPPINGS, multi.mappings());    }    @Override    protected PropertyDescriptor<Foo> createProperty() {        return new EnumeratedProperty<>("testEnumerations",                                        "Test enumerations with complex types",                                        KEYS,                                        VALUES, 0, Foo.class,                                        1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations",                                             "Test enumerations with complex types",                                             KEYS,                                             VALUES,                                             new int[] {0, 1}, Foo.class, 1.0f);    }    @Test(expected = IllegalArgumentException.class)    public void testDefaultIndexOutOfBounds() {        new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                                KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Test(expected = IllegalArgumentException.class)    public void testNoMappingForDefault() {        new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                      MAPPINGS, Collections.singletonList(Foo.IGNORED), Foo.class, 1.0f);    }    @Test    public void creationTest() {        PropertyDescriptor<Foo> prop = createProperty();        PropertyDescriptor<List<Foo>> multi = createMultiProperty();        for (Map.Entry<String, Foo> e : MAPPINGS.entrySet()) {            assertEquals(e.getValue(), prop.valueFrom(e.getKey()));            assertTrue(multi.valueFrom(e.getKey()).contains(e.getValue()));        }    }    @Override    protected Foo createValue() {        return randomChoice(VALUES);    }    @Override    protected Foo createBadValue() {        return Foo.IGNORED; // not in the set of values    }    @Override    protected PropertyDescriptor<Foo> createBadProperty() {        return new EnumeratedProperty<>("testEnumerations", "Test enumerations with simple type",                                        new String[0], VALUES, -1, Foo.class, 1.0f);    }    @Override    protected PropertyDescriptor<List<Foo>> createBadMultiProperty() {        return new EnumeratedMultiProperty<>("testEnumerations", "Test enumerations with simple type",                                             KEYS, VALUES, new int[] {99}, Foo.class, 1.0f);    }    @Override    @Test    public void testFactorySingleValue() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    @Override    @Test    public void testFactoryMultiValueCustomDelimiter() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    @Override    @Test    public void testFactoryMultiValueDefaultDelimiter() {        Assume.assumeTrue("The EnumeratedProperty factory is not implemented yet", false);    }    enum Foo {        BAR, NA, BEE, COO, IGNORED    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd.token.internal;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Arrays;import java.util.Collections;import java.util.ConcurrentModificationException;import java.util.Iterator;import java.util.NoSuchElementException;import org.junit.Test;import net.sourceforge.pmd.lang.TokenManager;import net.sourceforge.pmd.lang.ast.GenericToken;public class BaseTokenFilterTest {    static class StringToken implements GenericToken<StringToken> {        private final String text;        StringToken(final String text) {            this.text = text;        }        @Override        public StringToken getNext() {            return null;        }        @Override        public StringToken getPreviousComment() {            return null;        }        @Override        public boolean isEof() {            return text == null;        }        @Override        public String getImage() {            return text;        }        @Override        public int getBeginLine() {            return 0;        }        @Override        public int getEndLine() {            return 0;        }        @Override        public int getBeginColumn() {            return 0;        }        @Override        public int getEndColumn() {            return 0;        }    }    static class StringTokenManager implements TokenManager<StringToken> {        Iterator<String> iterator = Collections.unmodifiableList(Arrays.asList("a", "b", "c")).iterator();        @Override        public StringToken getNextToken() {            if (iterator.hasNext()) {                return new StringToken(iterator.next());            } else {                return null;            }        }    }    static class DummyTokenFilter<T extends GenericToken<T>> extends BaseTokenFilter<T> {        Iterable<T> remainingTokens;        DummyTokenFilter(final TokenManager<T> tokenManager) {            super(tokenManager);        }        @Override        protected boolean shouldStopProcessing(final T currentToken) {            return currentToken == null;        }        @Override        protected void analyzeTokens(final T currentToken, final Iterable<T> remainingTokens) {            this.remainingTokens = remainingTokens;        }        public Iterable<T> getRemainingTokens() {            return remainingTokens;        }    }    @Test    public void testRemainingTokensFunctionality1() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final Iterator<StringToken> it2 = iterable.iterator();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValFirstIt = it1.next();        final StringToken firstValSecondIt = it2.next();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken secondValFirstIt = it1.next();        assertFalse(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken secondValSecondIt = it2.next();        assertFalse(it2.hasNext());        assertEquals("b", firstValFirstIt.getImage());        assertEquals("b", firstValSecondIt.getImage());        assertEquals("c", secondValFirstIt.getImage());        assertEquals("c", secondValSecondIt.getImage());    }    @Test    public void testRemainingTokensFunctionality2() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final Iterator<StringToken> it2 = iterable.iterator();        assertTrue(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValFirstIt = it1.next();        assertTrue(it1.hasNext());        final StringToken secondValFirstIt = it1.next();        assertFalse(it1.hasNext());        assertTrue(it2.hasNext());        final StringToken firstValSecondIt = it2.next();        assertTrue(it2.hasNext());        final StringToken secondValSecondIt = it2.next();        assertFalse(it2.hasNext());        assertEquals("b", firstValFirstIt.getImage());        assertEquals("b", firstValSecondIt.getImage());        assertEquals("c", secondValFirstIt.getImage());        assertEquals("c", secondValSecondIt.getImage());    }    @Test(expected = NoSuchElementException.class)    public void testRemainingTokensFunctionality3() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final Iterator<StringToken> it2 = iterable.iterator();        it1.next();        it1.next();        it2.next();        it2.next();        it1.next();    }    @Test(expected = ConcurrentModificationException.class)    public void testRemainingTokensFunctionality4() {        final TokenManager<StringToken> tokenManager = new StringTokenManager();        final DummyTokenFilter<StringToken> tokenFilter = new DummyTokenFilter<>(tokenManager);        final StringToken firstToken = tokenFilter.getNextToken();        assertEquals("a", firstToken.getImage());        final Iterable<StringToken> iterable = tokenFilter.getRemainingTokens();        final Iterator<StringToken> it1 = iterable.iterator();        final StringToken secondToken = tokenFilter.getNextToken();        assertEquals("b", secondToken.getImage());        it1.next();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertTrue;import org.junit.Test;public class LanguageFactoryTest {    @Test    public void testSimple() {        assertTrue(LanguageFactory.createLanguage("Cpddummy") instanceof CpddummyLanguage);        assertTrue(LanguageFactory.createLanguage("not_existing_language") instanceof AnyLanguage);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import java.util.Iterator;import org.junit.Test;public class MatchTest {    @Test    public void testSimple() {        int lineCount1 = 10;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount1, codeFragment1);        int lineCount2 = 20;        String codeFragment2 = "code fragment 2";        Mark mark2 = createMark("class", "/var/Foo.java", 1, lineCount2, codeFragment2);        Match match = new Match(1, mark1, mark2);        assertEquals(1, match.getTokenCount());        // Returns the line count of the first mark        assertEquals(lineCount1, match.getLineCount());        // Returns the source code of the first mark        assertEquals(codeFragment1, match.getSourceCodeSlice());        Iterator<Mark> i = match.iterator();        Mark occurrence1 = i.next();        Mark occurrence2 = i.next();        assertFalse(i.hasNext());        assertEquals(mark1, occurrence1);        assertEquals(lineCount1, occurrence1.getLineCount());        assertEquals(codeFragment1, occurrence1.getSourceCodeSlice());        assertEquals(mark2, occurrence2);        assertEquals(lineCount2, occurrence2.getLineCount());        assertEquals(codeFragment2, occurrence2.getSourceCodeSlice());    }    @Test    public void testCompareTo() {        Match m1 = new Match(1, new TokenEntry("public", "/var/Foo.java", 1),                new TokenEntry("class", "/var/Foo.java", 1));        Match m2 = new Match(2, new TokenEntry("Foo", "/var/Foo.java", 1), new TokenEntry("{", "/var/Foo.java", 1));        assertTrue(m2.compareTo(m1) < 0);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MatchTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.cpd.SourceCode.FileCodeLoader;public class SourceCodeTest {    private static final String BASE_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String SAMPLE_CODE = "Line 1\n" + "Line 2\n" + "Line 3\n" + "Line 4\n";    @Test    public void testSlice() {        SourceCode sourceCode = new SourceCode(new SourceCode.StringCodeLoader(SAMPLE_CODE, "Foo.java"));        assertEquals("Foo.java", sourceCode.getFileName());        assertEquals("Line 1", sourceCode.getSlice(1, 1));        assertEquals("Line 2", sourceCode.getSlice(2, 2));        assertEquals("Line 1\nLine 2", sourceCode.getSlice(1, 2));        sourceCode.getCodeBuffer(); // load into soft reference, must not change behavior        assertEquals("Line 1\nLine 2", sourceCode.getSlice(1, 2));    }    @Test    public void testEncodingDetectionFromBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(new File(BASE_RESOURCE_PATH + "file_with_utf8_bom.java"),                "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("UTF-8", loader.getEncoding());    }    @Test    public void testEncodingIsNotChangedWhenThereIsNoBOM() throws Exception {        FileCodeLoader loader = new SourceCode.FileCodeLoader(                new File(BASE_RESOURCE_PATH + "file_with_ISO-8859-1_encoding.java"), "ISO-8859-1");        // The encoding detection is done when the reader is created        loader.getReader();        assertEquals("ISO-8859-1", loader.getEncoding());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.contrib.java.lang.system.SystemOutRule;import org.junit.rules.TestRule;public class CPDCommandLineInterfaceTest {    @Rule    public final TestRule restoreSystemProperties = new RestoreSystemProperties();    @Rule    public final SystemOutRule log = new SystemOutRule().enableLog();    @Test    public void testEmptyResultRendering() {        System.setProperty(CPDCommandLineInterface.NO_EXIT_AFTER_RUN, "true");        CPDCommandLineInterface.main(new String[] { "--minimum-tokens", "340", "--language", "java", "--files",            "src/test/resources/net/sourceforge/pmd/cpd/files/", "--format", "xml", });        Assert.assertEquals("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "\n" + "<pmd-cpd/>", log.getLog().trim());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.HashMap;import java.util.Map;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;public class CPDConfigurationTest {    @Test    public void testRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            Renderer r = CPDConfiguration.getRendererFromString(entry.getKey(), "UTF-8");            Assert.assertNotNull(r);            Assert.assertSame(entry.getValue(), r.getClass());        }    }    @Test    public void testCPDRenderers() {        Map<String, Class<? extends CPDRenderer>> renderersToTest = new HashMap<>();        renderersToTest.put("csv", CSVRenderer.class);        renderersToTest.put("xml", XMLRenderer.class);        renderersToTest.put("csv_with_linecount_per_file", CSVWithLinecountPerFileRenderer.class);        renderersToTest.put("vs", VSRenderer.class);        renderersToTest.put("text", SimpleRenderer.class);        for (Map.Entry<String, Class<? extends CPDRenderer>> entry : renderersToTest.entrySet()) {            CPDRenderer r = CPDConfiguration.getCPDRendererFromString(entry.getKey(), "UTF-8");            Assert.assertNotNull(r);            Assert.assertSame(entry.getValue(), r.getClass());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import org.junit.Test;/** * @author Philippe T'Seyen */public class FileReporterTest {    @Test    public void testCreation() {        new FileReporter((String) null);        new FileReporter((File) null);    }    @Test    public void testEmptyReport() throws ReportException {        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");        assertTrue(reportFile.exists());        assertEquals(0L, reportFile.length());        assertTrue(reportFile.delete());    }    @Test    public void testReport() throws ReportException, IOException {        String testString = "first line\nsecond line";        File reportFile = new File("report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report(testString);        assertEquals(testString, readFile(reportFile));        assertTrue(reportFile.delete());    }    @Test(expected = ReportException.class)    public void testInvalidFile() throws ReportException {        File reportFile = new File("/invalid_folder/report.tmp");        FileReporter fileReporter = new FileReporter(reportFile);        fileReporter.report("");    }    private String readFile(File file) throws IOException {        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {            StringBuilder buffer = new StringBuilder();            String line = reader.readLine();            while (line != null) {                buffer.append(line);                line = reader.readLine();                if (line != null) {                    buffer.append('\n');                }            }            return buffer.toString();        }    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(FileReporterTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.List;import org.junit.Test;public class AnyTokenizerTest {    @Test    public void testMultiLineMacros() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        compareResult(tokenizer, TEST1, EXPECTED);    }    @Test    public void testStringEscape() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        compareResult(tokenizer, "a = \"oo\\n\"", listOf("a", "=", "\"oo\\n\"", "EOF"));    }    @Test    public void testMultilineString() {        AnyTokenizer tokenizer = new AnyTokenizer("//");        Tokens tokens = compareResult(tokenizer, "a = \"oo\n\";", listOf("a", "=", "\"oo\n\"", ";", "EOF"));        TokenEntry string = tokens.getTokens().get(2);        assertEquals("\"oo\n\"", getTokenImage(string));        assertEquals(1, string.getBeginLine());        assertEquals(5, string.getBeginColumn());        assertEquals(2, string.getEndColumn()); // ends on line 2        TokenEntry semi = tokens.getTokens().get(3);        assertEquals(";", getTokenImage(semi));        assertEquals(2, semi.getBeginLine());        assertEquals(2, semi.getBeginColumn());        assertEquals(3, semi.getEndColumn());    }    /**     * Tests that [core][cpd] AnyTokenizer doesn't count columns correctly #2760 is actually fixed.     */    @Test    public void testTokenPosition() {        AnyTokenizer tokenizer = new AnyTokenizer();        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader("a;\nbbbb\n;"));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        TokenEntry bbbbToken = tokens.getTokens().get(2);        assertEquals(2, bbbbToken.getBeginLine());        assertEquals(1, bbbbToken.getBeginColumn());        assertEquals(5, bbbbToken.getEndColumn());    }    private Tokens compareResult(AnyTokenizer tokenizer, String source, List<String> expectedImages) {        SourceCode code = new SourceCode(new SourceCode.StringCodeLoader(source));        Tokens tokens = new Tokens();        tokenizer.tokenize(code, tokens);        List<String> tokenStrings = new ArrayList<>();        for (TokenEntry token : tokens.getTokens()) {            tokenStrings.add(getTokenImage(token));        }        assertEquals(expectedImages, tokenStrings);        return tokens;    }    private String getTokenImage(TokenEntry t) {        return t.toString();    }    private static final List<String> EXPECTED = listOf(        "using", "System", ";",        "namespace", "HelloNameSpace", "{",        "public", "class", "HelloWorld", "{", // note: comment is excluded        "static", "void", "Main", "(", "string", "[", "]", "args", ")", "{",        "Console", ".", "WriteLine", "(", "\"Hello World!\"", ")", ";",        "}", "}", "}", "EOF"    );    private static final String TEST1 =        "using System;\n"            + "namespace HelloNameSpace {\n"            + "\n"            + "    public class HelloWorld { // A comment\n"            + "        static void Main(string[] args) {\n"            + "\n"            + "            Console.WriteLine(\"Hello World!\");\n"            + "        }\n"            + "    }\n"            + "\n"            + "}\n";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;public class CSVRendererTest {    @Test    public void testLineCountPerFile() throws IOException {        CPDRenderer renderer = new CSVRenderer(true);        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "tokens,occurrences" + PMD.EOL + "75,2,48,10,/var/Foo.java,73,20,/var/Bar.java"                + PMD.EOL;        assertEquals(expectedReport, report);    }    @Test    public void testFilenameEscapes() throws IOException {        CPDRenderer renderer = new CSVRenderer();        List<Match> list = new ArrayList<>();        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var,with,commas/Foo.java", 48, 10, codeFragment);        Mark mark2 = createMark("stuff", "/var,with,commas/Bar.java", 73, 20, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        String expectedReport = "lines,tokens,occurrences" + PMD.EOL                + "10,75,2,48,\"/var,with,commas/Foo.java\",73,\"/var,with,commas/Bar.java\"" + PMD.EOL;        assertEquals(expectedReport, report);    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader;public class MarkTest {    @Test    public void testSimple() {        String filename = "/var/Foo.java";        int beginLine = 1;        TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1);        Mark mark = new Mark(token);        int lineCount = 10;        mark.setLineCount(lineCount);        String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(-1, mark.getBeginColumn());        assertEquals(-1, mark.getEndColumn());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }    @Test    public void testColumns() {        final String filename = "/var/Foo.java";        final int beginLine = 1;        final int beginColumn = 2;        final int endColumn = 3;        final TokenEntry token = new TokenEntry("public", "/var/Foo.java", 1, beginColumn, beginColumn + "public".length());        final TokenEntry endToken = new TokenEntry("}", "/var/Foo.java", 5, endColumn - 1, endColumn);        final Mark mark = new Mark(token);        final int lineCount = 10;        mark.setLineCount(lineCount);        mark.setEndToken(endToken);        final String codeFragment = "code fragment";        mark.setSourceCode(new SourceCode(new StringCodeLoader(codeFragment)));        assertEquals(token, mark.getToken());        assertEquals(filename, mark.getFilename());        assertEquals(beginLine, mark.getBeginLine());        assertEquals(lineCount, mark.getLineCount());        assertEquals(beginLine + lineCount - 1, mark.getEndLine());        assertEquals(beginColumn, mark.getBeginColumn());        assertEquals(endColumn, mark.getEndColumn());        assertEquals(codeFragment, mark.getSourceCodeSlice());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(MarkTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.HashSet;import java.util.List;import java.util.Set;import org.apache.commons.io.FilenameUtils;import org.junit.Test;public class CPDFilelistTest {    @Test    public void testFilelist() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);        List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(FilenameUtils.getName(path));        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }    @Test    public void testFilelistMultipleLines() {        CPDConfiguration arguments = new CPDConfiguration();        arguments.setLanguage(new CpddummyLanguage());        arguments.setFileListPath("src/test/resources/net/sourceforge/pmd/cpd/cli/filelist2.txt");        CPD cpd = new CPD(arguments);        CPDCommandLineInterface.addSourceFilesToCPD(cpd, arguments);        List<String> paths = cpd.getSourcePaths();        assertEquals(2, paths.size());        Set<String> simpleNames = new HashSet<>();        for (String path : paths) {            simpleNames.add(FilenameUtils.getName(path));        }        assertTrue(simpleNames.contains("anotherfile.dummy"));        assertTrue(simpleNames.contains("somefile.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import org.junit.Test;public class TokenEntryTest {    @Test    public void testSimple() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());        assertEquals(-1, mark.getBeginColumn());        assertEquals(-1, mark.getEndColumn());    }    @Test    public void testColumns() {        TokenEntry.clearImages();        TokenEntry mark = new TokenEntry("public", "/var/Foo.java", 1, 2, 3);        assertEquals(1, mark.getBeginLine());        assertEquals("/var/Foo.java", mark.getTokenSrcID());        assertEquals(0, mark.getIndex());        assertEquals(2, mark.getBeginColumn());        assertEquals(3, mark.getEndColumn());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(TokenEntryTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;import javax.xml.parsers.DocumentBuilderFactory;import org.junit.Test;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import net.sourceforge.pmd.cpd.renderer.CPDRenderer;/** * @author Philippe T'Seyen * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class XMLRendererTest {    private static final String ENCODING = (String) System.getProperties().get("file.encoding");    private static final String FORM_FEED = "\u000C"; // this character is invalid in XML 1.0 documents    private static final String FORM_FEED_ENTITY = "&#12;"; // this is also not allowed in XML 1.0 documents    @Test    public void testWithNoDuplication() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList nodes = doc.getChildNodes();            Node n = nodes.item(0);            assertEquals("pmd-cpd", n.getNodeName());            assertEquals(0, doc.getElementsByTagName("duplication").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testWithOneDuplication() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList dupes = doc.getElementsByTagName("duplication");            assertEquals(1, dupes.getLength());            Node file = dupes.item(0).getFirstChild();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            if (file != null) {                assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());                assertEquals("6", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals(null, file.getAttributes().getNamedItem("column"));                assertEquals(null, file.getAttributes().getNamedItem("endcolumn"));                file = file.getNextSibling();                while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                    file = file.getNextSibling();                }            }            if (file != null) {                assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("78", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals(null, file.getAttributes().getNamedItem("column"));                assertEquals(null, file.getAttributes().getNamedItem("endcolumn"));            }            assertEquals(1, doc.getElementsByTagName("codefragment").getLength());            assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testRenderWithMultipleMatch() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount1 = 6;        String codeFragment1 = "code fragment";        Mark mark1 = createMark("public", "/var/Foo.java", 48, lineCount1, codeFragment1);        Mark mark2 = createMark("void", "/var/Foo.java", 73, lineCount1, codeFragment1);        Match match1 = new Match(75, mark1, mark2);        int lineCount2 = 7;        String codeFragment2 = "code fragment 2";        Mark mark3 = createMark("void", "/var/Foo2.java", 49, lineCount2, codeFragment2);        Mark mark4 = createMark("stuff", "/var/Foo2.java", 74, lineCount2, codeFragment2);        Match match2 = new Match(76, mark3, mark4);        list.add(match1);        list.add(match2);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            assertEquals(2, doc.getElementsByTagName("duplication").getLength());            assertEquals(4, doc.getElementsByTagName("file").getLength());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testWithOneDuplicationWithColumns() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        int lineCount = 6;        String codeFragment = "code\nfragment";        Mark mark1 = createMark("public", "/var/Foo.java", 1, lineCount, codeFragment, 2, 3);        Mark mark2 = createMark("stuff", "/var/Foo.java", 73, lineCount, codeFragment, 4, 5);        Match match = new Match(75, mark1, mark2);        list.add(match);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        try {            Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                    .parse(new ByteArrayInputStream(report.getBytes(ENCODING)));            NodeList dupes = doc.getElementsByTagName("duplication");            assertEquals(1, dupes.getLength());            Node file = dupes.item(0).getFirstChild();            while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                file = file.getNextSibling();            }            if (file != null) {                assertEquals("1", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("/var/Foo.java", file.getAttributes().getNamedItem("path").getNodeValue());                assertEquals("6", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals("2", file.getAttributes().getNamedItem("column").getNodeValue());                assertEquals("3", file.getAttributes().getNamedItem("endcolumn").getNodeValue());                file = file.getNextSibling();                while (file != null && file.getNodeType() != Node.ELEMENT_NODE) {                    file = file.getNextSibling();                }            }            if (file != null) {                assertEquals("73", file.getAttributes().getNamedItem("line").getNodeValue());                assertEquals("78", file.getAttributes().getNamedItem("endline").getNodeValue());                assertEquals("4", file.getAttributes().getNamedItem("column").getNodeValue());                assertEquals("5", file.getAttributes().getNamedItem("endcolumn").getNodeValue());            }            assertEquals(1, doc.getElementsByTagName("codefragment").getLength());            assertEquals(codeFragment, doc.getElementsByTagName("codefragment").item(0).getTextContent());        } catch (Exception e) {            e.printStackTrace();            fail(e.getMessage());        }    }    @Test    public void testRendererEncodedPath() throws IOException {        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        final String espaceChar = "&lt;";        Mark mark1 = createMark("public", "/var/A<oo.java" + FORM_FEED, 48, 6, "code fragment");        Mark mark2 = createMark("void", "/var/B<oo.java", 73, 6, "code fragment");        Match match1 = new Match(75, mark1, mark2);        list.add(match1);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertTrue(report.contains(espaceChar));        assertFalse(report.contains(FORM_FEED));        assertFalse(report.contains(FORM_FEED_ENTITY));    }    @Test    public void testRendererXMLEscaping() throws IOException {        String codefragment = "code fragment" + FORM_FEED + "\nline2\nline3\nno & escaping necessary in CDATA\nx=\"]]>\";";        CPDRenderer renderer = new XMLRenderer();        List<Match> list = new ArrayList<>();        Mark mark1 = createMark("public", "file1", 1, 5, codefragment);        Mark mark2 = createMark("public", "file2", 5, 5, codefragment);        Match match1 = new Match(75, mark1, mark2);        list.add(match1);        StringWriter sw = new StringWriter();        renderer.render(list.iterator(), sw);        String report = sw.toString();        assertFalse(report.contains(FORM_FEED));        assertFalse(report.contains(FORM_FEED_ENTITY));        assertTrue(report.contains("no & escaping necessary in CDATA"));        assertFalse(report.contains("x=\"]]>\";")); // must be escaped        assertTrue(report.contains("x=\"]]]]><![CDATA[>\";"));    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code) {        Mark result = new Mark(new TokenEntry(image, tokenSrcID, beginLine));        result.setLineCount(lineCount);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }    private Mark createMark(String image, String tokenSrcID, int beginLine, int lineCount, String code, int beginColumn, int endColumn) {        final TokenEntry beginToken = new TokenEntry(image, tokenSrcID, beginLine, beginColumn, beginColumn + 1);        final TokenEntry endToken = new TokenEntry(image, tokenSrcID, beginLine + lineCount, endColumn - 1, endColumn);        final Mark result = new Mark(beginToken);        result.setLineCount(lineCount);        result.setEndToken(endToken);        result.setSourceCode(new SourceCode(new SourceCode.StringCodeLoader(code)));        return result;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.io.File;import java.util.Iterator;import org.apache.commons.lang3.SystemUtils;import org.junit.Assert;import org.junit.Assume;import org.junit.Before;import org.junit.Test;/** * Unit test for {@link CPD} */public class CPDTest {    private static final String BASE_TEST_RESOURCE_PATH = "src/test/resources/net/sourceforge/pmd/cpd/files/";    private static final String TARGET_TEST_RESOURCE_PATH = "target/classes/net/sourceforge/pmd/cpd/files/";    private CPD cpd;    // Symlinks are not well supported under Windows - so the tests are    // simply executed only on linux.    private boolean canTestSymLinks = SystemUtils.IS_OS_UNIX;    @Before    public void setup() throws Exception {        CPDConfiguration theConfiguration = new CPDConfiguration();        theConfiguration.setLanguage(new AnyLanguage("any"));        theConfiguration.setMinimumTileSize(10);        theConfiguration.postContruct();        cpd = new CPD(theConfiguration);    }    /**     * As java doesn't support symlinks in zip files, maven does not, too. So,     * we are creating the symlinks manually here before the test.     *     * @throws Exception     *             any error     */    private void prepareSymLinks() throws Exception {        Assume.assumeTrue("Skipping unit tests with symlinks.", canTestSymLinks);        Runtime runtime = Runtime.getRuntime();        if (!new File(TARGET_TEST_RESOURCE_PATH, "symlink-for-real-file.txt").exists()) {            runtime.exec(new String[] { "ln", "-s", BASE_TEST_RESOURCE_PATH + "real-file.txt",                TARGET_TEST_RESOURCE_PATH + "symlink-for-real-file.txt", }).waitFor();        }        if (!new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test").exists()) {            runtime.exec(new String[] { "ln", "-s", "broken-sym-link",                TARGET_TEST_RESOURCE_PATH + "this-is-a-broken-sym-link-for-test", }).waitFor();        }    }    /**     * A broken symlink (which is basically a not existing file), should be     * skipped.     *     * @throws Exception     *             any error     */    @Test    public void testFileSectionWithBrokenSymlinks() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(0);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "this-is-a-broken-sym-link-for-test"));        listener.verify();    }    /**     * A file should be added only once - even if it was found twice, because of     * a sym link.     *     * @throws Exception     *             any error     */    @Test    public void testFileAddedAsSymlinkAndReal() throws Exception {        prepareSymLinks();        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "real-file.txt"));        cpd.add(new File(BASE_TEST_RESOURCE_PATH, "symlink-for-real-file.txt"));        listener.verify();    }    /**     * Add a file with a relative path - should still be added and not be     * detected as a sym link.     *     * @throws Exception     *             any error     */    @Test    public void testFileAddedWithRelativePath() throws Exception {        NoFileAssertListener listener = new NoFileAssertListener(1);        cpd.setCpdListener(listener);        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "real-file.txt"));        listener.verify();    }    /**     * The order of the duplicates is dependent on the order the files are added to CPD.     * See also https://github.com/pmd/pmd/issues/1196     * @throws Exception     */    @Test    public void testFileOrderRelevance() throws Exception {        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup2.java"));        cpd.add(new File("./" + BASE_TEST_RESOURCE_PATH, "dup1.java"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        while (matches.hasNext()) {            Match match = matches.next();            // the file added first was dup2.            Assert.assertTrue(match.getFirstMark().getFilename().endsWith("dup2.java"));            Assert.assertTrue(match.getSecondMark().getFilename().endsWith("dup1.java"));        }    }    /**     * Simple listener that fails, if too many files were added and not skipped.     */    private static class NoFileAssertListener implements CPDListener {        private int expectedFilesCount;        private int files;        NoFileAssertListener(int expectedFilesCount) {            this.expectedFilesCount = expectedFilesCount;            this.files = 0;        }        @Override        public void addedFile(int fileCount, File file) {            files++;            if (files > expectedFilesCount) {                Assert.fail("File was added! - " + file);            }        }        @Override        public void phaseUpdate(int phase) {            // not needed for this test        }        public void verify() {            Assert.assertEquals("Expected " + expectedFilesCount + " files, but " + files + " have been added.",                    expectedFilesCount, files);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.fail;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.apache.tools.ant.BuildException;import org.apache.tools.ant.BuildFileRule;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;public class PMDTaskTest {    @Rule    public final BuildFileRule buildRule = new BuildFileRule();    @Before    public void setUp() {        buildRule.configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/pmdtasktest.xml");    }    @Test    public void testFormatterWithNoToFileAttribute() {        try {            buildRule.executeTarget("testFormatterWithNoToFileAttribute");            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals("toFile or toConsole needs to be specified in Formatter", ex.getMessage());        }    }    @Test    public void testNoRuleSets() {        try {            buildRule.executeTarget("testNoRuleSets");            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals("No rulesets specified", ex.getMessage());        }    }    @Test    public void testBasic() {        buildRule.executeTarget("testBasic");    }    @Test    public void testInvalidLanguageVersion() {        try {            buildRule.executeTarget("testInvalidLanguageVersion");            Assert.assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    buildRule.getLog());            fail("This should throw an exception");        } catch (BuildException ex) {            Assert.assertEquals(                    "The following language is not supported:<sourceLanguage name=\"java\" version=\"42\" />.",                    ex.getMessage());        }    }    @Test    public void testWithShortFilenames() throws IOException {        buildRule.executeTarget("testWithShortFilenames");        try (InputStream in = new FileInputStream("target/pmd-ant-test.txt")) {            String actual = IOUtils.toString(in, StandardCharsets.UTF_8);            // remove any trailing newline            actual = actual.replaceAll("\n|\r", "");            Assert.assertEquals("sample.dummy:1:\tSampleXPathRule:\tTest Rule 2", actual);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertTrue;import static org.junit.Assert.fail;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.HTMLRenderer;import net.sourceforge.pmd.renderers.TextRenderer;import net.sourceforge.pmd.renderers.XMLRenderer;public class FormatterTest {    @Test    public void testType() {        Formatter f = new Formatter();        f.setType("xml");        assertTrue(f.createRenderer() instanceof XMLRenderer);        f.setType("text");        assertTrue(f.createRenderer() instanceof TextRenderer);        f.setType("csv");        assertTrue(f.createRenderer() instanceof CSVRenderer);        f.setType("html");        assertTrue(f.createRenderer() instanceof HTMLRenderer);        try {            f.setType("FAIL");            f.createRenderer();            fail("Expected IllegalArgumentException");        } catch (IllegalArgumentException be) {            assertTrue(be.getMessage().startsWith("Can't find the custom format FAIL"));        }    }    @Test    public void testNull() {        Formatter f = new Formatter();        assertTrue("Formatter toFile should start off null!", f.isNoOutputSupplied());        f.setToFile(new File("foo"));        assertFalse("Formatter toFile should not be null!", f.isNoOutputSupplied());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.ant;import static org.junit.Assert.assertTrue;import java.io.File;import org.apache.tools.ant.BuildFileRule;import org.junit.Before;import org.junit.Rule;import org.junit.Test;/** * * @author Romain Pelisse &lt;belaran@gmail.com&gt; * */public class CPDTaskTest {    @Rule    public final BuildFileRule buildRule = new BuildFileRule();    @Before    public void setUp() {        buildRule.configureProject("src/test/resources/net/sourceforge/pmd/ant/xml/cpdtasktest.xml");    }    @Test    public void testBasic() {        buildRule.executeTarget("testBasic");        // FIXME: This clearly needs to be improved - but I don't like to write        // test, so feel free to contribute :)        assertTrue(new File("target/cpd.ant.tests").exists());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.XPathRule;import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;public class CodeClimateRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new CodeClimateRenderer();    }    @Override    public String getExpected() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    public String getExpectedWithProperties() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "stringProperty | the string value\\nsecond line with 'quotes' | simple string property\\n"                + "multiString | default1,default2 | multi string property\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL + "{\"type\":\"issue\",\"check_name\":\"Foo\",\"description\":\"blah\","                + "\"content\":{\"body\":\"## Foo\\n\\nSince: PMD null\\n\\nPriority: Low\\n\\n"                + "[Categories](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#categories): Style\\n\\n"                + "[Remediation Points](https://github.com/codeclimate/platform/blob/master/spec/analyzers/SPEC.md#remediation-points): 50000\\n\\n"                + "desc\\n\\n"                + "### [PMD properties](https://pmd.github.io/latest/pmd_userdocs_configuring_rules.html#rule-properties)\\n\\n"                + "Name | Value | Description\\n" + "--- | --- | ---\\n"                + "violationSuppressRegex | | Suppress violations with messages matching a regular expression\\n"                + "violationSuppressXPath | | Suppress violations on nodes which match a given relative XPath expression.\\n"                + "\"},\"categories\":[\"Style\"],\"location\":{\"path\":\"" + getSourceCodeFilename() + "\",\"lines\":{\"begin\":1,\"end\":1}},\"severity\":\"info\",\"remediation_points\":50000}"                + "\u0000" + PMD.EOL;    }    @Test    public void testXPathRule() throws Exception {        DummyNode node = createNode(1);        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File(getSourceCodeFilename()));        Report report = new Report();        XPathRule theRule = new XPathRule(XPathVersion.XPATH_3_1, "//dummyNode");        // Setup as FooRule        theRule.setDescription("desc");        theRule.setName("Foo");        report.addRuleViolation(new ParametricRuleViolation<Node>(theRule, ctx, node, "blah"));        String rendered = ReportTest.render(getRenderer(), report);        // Output should be the exact same as for non xpath rules        assertEquals(filter(getExpected()), filter(rendered));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.IOException;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;public class HTMLRendererTest extends AbstractRendererTest {    @Override    protected String getSourceCodeFilename() {        return "someFilename<br>thatNeedsEscaping.ext";    }    private String getEscapedFilename() {        return "someFilename&lt;br&gt;thatNeedsEscaping.ext";    }    @Override    public Renderer getRenderer() {        return new HTMLRenderer();    }    @Override    public String getExpected() {        return getExpected(null, null);    }    private String getExpected(String linkPrefix, String lineAnchor) {        String filename = getEscapedFilename();        if (linkPrefix != null) {            filename = "<a href=\"" + linkPrefix + filename + "#" + lineAnchor + "\">"                    + filename + "</a>";        }        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + filename + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader()                + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return getHeader()                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL                + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>" + PMD.EOL + "<tr> " + PMD.EOL                + "<td align=\"center\">2</td>" + PMD.EOL + "<td width=\"*%\">" + getEscapedFilename() + "</td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader()                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>file</td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader()                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL + "</table></body></html>"                + PMD.EOL;    }    private String getHeader() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL;    }    @Test    public void testLinkPrefix() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        final String linePrefix = "L";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        renderer.setProperty(HTMLRenderer.LINE_PREFIX, linePrefix);        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        Report rep = reportOneViolation();        String actual = ReportTest.render(renderer, rep);        assertEquals(filter(getExpected(linkPrefix, "L1")), filter(actual));    }    @Test    public void testLinePrefixNotSet() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        // dont set line prefix renderer.setProperty(HTMLRenderer.LINE_PREFIX, linePrefix);        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        Report rep = reportOneViolation();        String actual = ReportTest.render(renderer, rep);        assertEquals(filter(getExpected(linkPrefix, "")), filter(actual));    }    @Test    public void testEmptyLinePrefix() throws IOException {        final HTMLRenderer renderer = new HTMLRenderer();        final String linkPrefix = "https://github.com/pmd/pmd/blob/master/";        renderer.setProperty(HTMLRenderer.LINK_PREFIX, linkPrefix);        renderer.setProperty(HTMLRenderer.LINE_PREFIX, "");        renderer.setProperty(HTMLRenderer.HTML_EXTENSION, false);        Report rep = reportOneViolation();        String actual = ReportTest.render(renderer, rep);        assertEquals(filter(getExpected(linkPrefix, "1")), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.RuleWithProperties;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public abstract class AbstractRendererTest {    public abstract Renderer getRenderer();    public abstract String getExpected();    public String getExpectedWithProperties() {        return getExpected();    }    public abstract String getExpectedEmpty();    public abstract String getExpectedMultiple();    public String getExpectedError(ProcessingError error) {        return "";    }    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return getExpectedError(error);    }    public String getExpectedError(ConfigurationError error) {        return "";    }    public String filter(String expected) {        return expected;    }    protected String getSourceCodeFilename() {        return "notAvailable.ext";    }    @Test(expected = NullPointerException.class)    public void testNullPassedIn() throws Exception {        getRenderer().renderFileReport(null);    }    protected Report reportOneViolation() {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1));        return report;    }    private Report reportTwoViolations() {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1));        report.addRuleViolation(newRuleViolation(2));        return report;    }    protected RuleViolation newRuleViolation(int endColumn) {        DummyNode node = createNode(endColumn);        return new ParametricRuleViolation<Node>(new FooRule(), getSourceCodeFilename(), node, "blah");    }    protected static DummyNode createNode(int endColumn) {        DummyNode node = new DummyNode();        node.setCoords(1, 1, 1, endColumn);        return node;    }    @Test    public void testRuleWithProperties() throws Exception {        DummyNode node = createNode(1);        Report report = new Report();        RuleWithProperties theRule = new RuleWithProperties();        theRule.setProperty(RuleWithProperties.STRING_PROPERTY_DESCRIPTOR,                "the string value\nsecond line with \"quotes\"");        report.addRuleViolation(new ParametricRuleViolation<Node>(theRule, getSourceCodeFilename(), node, "blah"));        String rendered = ReportTest.render(getRenderer(), report);        assertEquals(filter(getExpectedWithProperties()), filter(rendered));    }    @Test    public void testRenderer() throws Exception {        Report rep = reportOneViolation();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpected()), filter(actual));    }    @Test    public void testRendererEmpty() throws Exception {        Report rep = new Report();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedEmpty()), filter(actual));    }    @Test    public void testRendererMultiple() throws Exception {        Report rep = reportTwoViolations();        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedMultiple()), filter(actual));    }    @Test    public void testError() throws Exception {        Report rep = new Report();        Report.ProcessingError err = new Report.ProcessingError(new RuntimeException("Error"), "file");        rep.addError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedError(err)), filter(actual));    }    @Test    public void testErrorWithoutMessage() throws Exception {        Report rep = new Report();        Report.ProcessingError err = new Report.ProcessingError(new NullPointerException(), "file");        rep.addError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedErrorWithoutMessage(err)), filter(actual));    }    @Test    public void testConfigError() throws Exception {        Report rep = new Report();        Report.ConfigurationError err = new Report.ConfigurationError(new FooRule(), "a configuration error");        rep.addConfigError(err);        String actual = ReportTest.render(getRenderer(), rep);        assertEquals(filter(getExpectedError(err)), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class IDEAJRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        Renderer result = new IDEAJRenderer();        result.setProperty(IDEAJRenderer.SOURCE_PATH, "");        result.setProperty(IDEAJRenderer.CLASS_AND_METHOD_NAME, "Foo <init>");        result.setProperty(IDEAJRenderer.FILE_NAME, "Foo.java");        return result;    }    @Override    public String getExpected() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "blah" + PMD.EOL + " at Foo <init>(Foo.java:1)" + PMD.EOL + "blah" + PMD.EOL                + " at Foo <init>(Foo.java:1)" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class TextPadRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new TextPadRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL + getSourceCodeFilename() + "(1,  Foo):  blah" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(TextPadRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.FileNotFoundException;import java.io.Reader;import java.io.StringReader;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class PapariTextRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        TextColorRenderer result = new TextColorRenderer() {            @Override            protected Reader getReader(String sourceFile) throws FileNotFoundException {                return new StringReader("public class Foo {}");            }        };        result.setProperty(TextColorRenderer.COLOR, "false");        return result;    }    @Override    public String getExpected() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL                + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 1" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "* file: " + getSourceCodeFilename() + PMD.EOL + "    src:  " + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL                + "    msg:  blah" + PMD.EOL + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + "    src:  "                + getSourceCodeFilename() + ":1:1" + PMD.EOL + "    rule: Foo" + PMD.EOL + "    msg:  blah" + PMD.EOL                + "    code: public class Foo {}" + PMD.EOL + PMD.EOL + PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL                + PMD.EOL + "* warnings: 2" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  RuntimeException: Error" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* file: file" + PMD.EOL + "    err:  NullPointerException: null" + PMD.EOL                + error.getDetail() + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return PMD.EOL + PMD.EOL + "Summary:" + PMD.EOL + PMD.EOL + "* rule: Foo" + PMD.EOL                + "    err:  a configuration error" + PMD.EOL + PMD.EOL                + "* errors:   1" + PMD.EOL + "* warnings: 0" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(PapariTextRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class XSLTRendererTest {    @Test    public void testDefaultStylesheet() throws Exception {        XSLTRenderer renderer = new XSLTRenderer();        Report report = new Report();        DummyNode node = new DummyNode();        node.setCoords(1, 1, 1, 2);        RuleViolation rv = new ParametricRuleViolation<Node>(new FooRule(), new RuleContext(), node,                "violation message");        report.addRuleViolation(rv);        String result = ReportTest.render(renderer, report);        Assert.assertTrue(result.contains("violation message"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;public class EmacsRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new EmacsRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + ":1: blah" + PMD.EOL + getSourceCodeFilename() + ":1: blah" + PMD.EOL;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.Report.SuppressedViolation;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.ViolationSuppressor;public class JsonRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new JsonRenderer();    }    @Override    public String getExpected() {        return readFile("expected.json");    }    @Override    public String getExpectedEmpty() {        return readFile("empty.json");    }    @Override    public String getExpectedMultiple() {        return readFile("expected-multiple.json");    }    @Override    public String getExpectedError(ProcessingError error) {        String expected = readFile("expected-processingerror.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    @Override    public String getExpectedError(ConfigurationError error) {        return readFile("expected-configurationerror.json");    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        String expected = readFile("expected-processingerror-no-message.json");        expected = expected.replace("###REPLACE_ME###", error.getDetail()                .replaceAll("\r", "\\\\r")                .replaceAll("\n", "\\\\n")                .replaceAll("\t", "\\\\t"));        return expected;    }    private String readFile(String name) {        try (InputStream in = JsonRendererTest.class.getResourceAsStream("json/" + name)) {            return IOUtils.toString(in, StandardCharsets.UTF_8);        } catch (IOException e) {            throw new RuntimeException(e);        }    }    @Override    public String filter(String expected) {        String result = expected                .replaceAll("\"timestamp\":\\s*\"[^\"]+\"", "\"timestamp\": \"--replaced--\"")                .replaceAll("\r\n", "\n"); // make the test run on Windows, too        return result;    }    @Test    public void suppressedViolations() throws IOException {        Report rep = new Report();        SuppressedViolation suppressed = new SuppressedViolation(newRuleViolation(1),                ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, "test");        rep.addSuppressedViolation(suppressed);        String actual = ReportTest.render(getRenderer(), rep);        String expected = readFile("expected-suppressed.json");        Assert.assertEquals(filter(expected), filter(actual));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class VBHTMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new VBHTMLRenderer();    }    @Override    public String getExpected() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL + "--></style><body><center><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;" + getSourceCodeFilename() + "</font></tr>"                + PMD.EOL                + "<tr id=RowColor2><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL                + "<tr id=RowColor1><td width=\"50\" align=\"right\"><font class=body>1&nbsp;&nbsp;&nbsp;</font></td><td><font class=body>blah</font></td></tr>"                + PMD.EOL + "</table><br></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.getFile() + "</font></td><td><font class=body><pre>" + error.getDetail() + "</pre></font></td></tr></table></center></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><style type=\"text/css\"><!--" + PMD.EOL                + "body { background-color: white; font-family:verdana, arial, helvetica, geneva; font-size: 16px; font-style: italic; color: black; }"                + PMD.EOL                + ".title { font-family: verdana, arial, helvetica,geneva; font-size: 12px; font-weight:bold; color: white; }"                + PMD.EOL                + ".body { font-family: verdana, arial, helvetica, geneva; font-size: 12px; font-weight:plain; color: black; }"                + PMD.EOL + "#TableHeader { background-color: #003366; }" + PMD.EOL                + "#RowColor1 { background-color: #eeeeee; }" + PMD.EOL + "#RowColor2 { background-color: white; }"                + PMD.EOL                + "--></style><body><center><br><table border=\"0\" width=\"80%\"><tr id=TableHeader><td colspan=\"2\"><font class=title>&nbsp;Configuration problems found</font></td></tr><tr id=RowColor2><td><font class=body>"                + error.rule().getName() + "</font></td><td><font class=body>" + error.issue() + "</font></td></tr></table></center></body></html>" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(VBHTMLRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import org.junit.Test;public class EmptyRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new EmptyRenderer();    }    // Overriding the annotation from the super class, this renderer doesn't care, so no NPE.    @Test    @Override    public void testNullPassedIn() throws Exception {        super.testNullPassedIn();    }    @Override    public String getExpected() {        return "";    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return "";    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class CSVRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new CSVRenderer();    }    @Override    public String getExpected() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader();    }    @Override    public String getExpectedMultiple() {        return getHeader()                + "\"1\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL                + "\"2\",\"\",\"" + getSourceCodeFilename() + "\",\"5\",\"1\",\"blah\",\"RuleSet\",\"Foo\"" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader();    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader();    }    private String getHeader() {        return "\"Problem\",\"Package\",\"File\",\"Priority\",\"Line\",\"Description\",\"Rule set\",\"Rule\"" + PMD.EOL;    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(CSVRendererTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;public class TextRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        return new TextRenderer();    }    @Override    public String getExpected() {        return getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "";    }    @Override    public String getExpectedMultiple() {        return getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL                + getSourceCodeFilename() + ":1:\tFoo:\tblah" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "file\t-\tRuntimeException: Error" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return "file\t-\tNullPointerException: null" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "Foo\t-\ta configuration error" + PMD.EOL;    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.StringReader;import java.nio.charset.Charset;import java.nio.charset.StandardCharsets;import javax.xml.parsers.DocumentBuilderFactory;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TemporaryFolder;import org.w3c.dom.Document;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDVersion;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class XMLRendererTest extends AbstractRendererTest {    @Rule // Restores system properties after test    public final RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Override    public Renderer getRenderer() {        return new XMLRenderer();    }    @Override    public String getExpected() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getHeader() + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return getHeader() + "<file name=\"" + getSourceCodeFilename() + "\">" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"1\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL                + "<violation beginline=\"1\" endline=\"1\" begincolumn=\"1\" endcolumn=\"2\" rule=\"Foo\" ruleset=\"RuleSet\" priority=\"5\">"                + PMD.EOL + "blah" + PMD.EOL + "</violation>" + PMD.EOL + "</file>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"RuntimeException: Error\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedErrorWithoutMessage(ProcessingError error) {        return getHeader() + "<error filename=\"file\" msg=\"NullPointerException: null\">"                + PMD.EOL + "<![CDATA[" + error.getDetail() + "]]>" + PMD.EOL + "</error>" + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return getHeader() + "<configerror rule=\"Foo\" msg=\"a configuration error\"/>"                + PMD.EOL + "</pmd>" + PMD.EOL;    }    @Override    public String filter(String expected) {        return expected.replaceAll(" timestamp=\"[^\"]+\">", " timestamp=\"\">");    }    private RuleViolation createRuleViolation(String description) {        DummyNode node = new DummyNode();        node.setCoords(1, 1, 1, 1);        return new ParametricRuleViolation<Node>(new FooRule(), getSourceCodeFilename(), node, description);    }    private void verifyXmlEscaping(Renderer renderer, String shouldContain, Charset charset) throws Exception {        renderer.setProperty(XMLRenderer.ENCODING, charset.name());        Report report = new Report();        String surrogatePair = "\ud801\udc1c";        String msg = "The String 'literal' \"Toknizr " + surrogatePair + "\" appears...";        report.addRuleViolation(createRuleViolation(msg));        String actual = renderTempFile(renderer, report, charset);        Assert.assertTrue(actual.contains(shouldContain));        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new InputSource(new StringReader(actual)));        NodeList violations = doc.getElementsByTagName("violation");        Assert.assertEquals(1, violations.getLength());        Assert.assertEquals(msg, violations.item(0).getTextContent().trim());    }    @Test    public void testXMLEscapingWithUTF8() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "\ud801\udc1c", StandardCharsets.UTF_8);    }    @Test    public void testXMLEscapingWithUTF16() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "&#x1041c;", StandardCharsets.UTF_16);    }    @Test    public void testXMLEscapingWithoutUTF8() throws Exception {        Renderer renderer = getRenderer();        verifyXmlEscaping(renderer, "&#x1041c;", StandardCharsets.ISO_8859_1);    }    public String getHeader() {        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + PMD.EOL                + "<pmd xmlns=\"http://pmd.sourceforge.net/report/2.0.0\""                + " xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""                + " xsi:schemaLocation=\"http://pmd.sourceforge.net/report/2.0.0 http://pmd.sourceforge.net/report_2_0_0.xsd\""                + " version=\"" + PMDVersion.VERSION + "\" timestamp=\"2014-10-06T19:30:51.262\">" + PMD.EOL;    }    @Test    public void testCorrectCharset() throws Exception {        System.setProperty("file.encoding", StandardCharsets.ISO_8859_1.name());        Renderer renderer = getRenderer();        Report report = new Report();        String formFeed = "\u000C";        //  = U+00E9 : can be represented in ISO-8859-1 as is        //  = U+0100 : cannot be represented in ISO-8859-1 -> would be a unmappable character, needs to be escaped        String specialChars = "";        String originalChars = formFeed + specialChars; // u000C should be removed,  should be encoded correctly as UTF-8        String msg = "The String literal \"" + originalChars + "\" appears...";        report.addRuleViolation(createRuleViolation(msg));        String actual = renderTempFile(renderer, report, StandardCharsets.UTF_8);        Assert.assertTrue(actual.contains(specialChars));        Assert.assertFalse(actual.contains(formFeed));        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder()                .parse(new InputSource(new StringReader(actual)));        NodeList violations = doc.getElementsByTagName("violation");        Assert.assertEquals(1, violations.getLength());        Assert.assertEquals(msg.replaceAll(formFeed, ""), violations.item(0).getTextContent().trim());    }    private String renderTempFile(Renderer renderer, Report report, Charset expectedCharset) throws IOException {        File reportFile = folder.newFile();        renderer.setReportFile(reportFile.getAbsolutePath());        renderer.start();        renderer.renderFileReport(report);        renderer.end();        renderer.flush();        try (FileInputStream input = new FileInputStream(reportFile)) {            return IOUtils.toString(input, expectedCharset);        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.Arrays;import java.util.regex.Pattern;import org.apache.commons.io.IOUtils;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class YAHTMLRendererTest extends AbstractRendererTest {    private File outputDir;    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Before    public void setUp() throws IOException {        outputDir = folder.newFolder("pmdtest");    }    private RuleViolation newRuleViolation(int endColumn, final String packageNameArg, final String classNameArg) {        DummyNode node = createNode(endColumn);        return new ParametricRuleViolation<Node>(new FooRule(), getSourceCodeFilename(), node, "blah") {            {                packageName = packageNameArg;                className = classNameArg;            }        };    }    @Override    protected RuleViolation newRuleViolation(int endColumn) {        return newRuleViolation(endColumn, "net.sf.pmd.test", "YAHTMLSampleClass");    }    @Test    public void testReportMultipleViolations() throws Exception {        Report report = new Report();        report.addRuleViolation(newRuleViolation(1, "net.sf.pmd.test", "YAHTMLSampleClass1"));        report.addRuleViolation(newRuleViolation(2, "net.sf.pmd.test", "YAHTMLSampleClass1"));        report.addRuleViolation(newRuleViolation(1, "net.sf.pmd.other", "YAHTMLSampleClass2"));        String actual = ReportTest.render(getRenderer(), report);        assertEquals(filter(getExpected()), filter(actual));        String[] htmlFiles = outputDir.list();        assertEquals(3, htmlFiles.length);        Arrays.sort(htmlFiles);        assertEquals("YAHTMLSampleClass1.html", htmlFiles[0]);        assertEquals("YAHTMLSampleClass2.html", htmlFiles[1]);        assertEquals("index.html", htmlFiles[2]);        for (String file : htmlFiles) {            try (FileInputStream in = new FileInputStream(new File(outputDir, file));                    InputStream expectedIn = YAHTMLRendererTest.class.getResourceAsStream("yahtml/" + file)) {                String data = IOUtils.toString(in, StandardCharsets.UTF_8);                String expected = normalizeLineSeparators(IOUtils.toString(expectedIn, StandardCharsets.UTF_8));                assertEquals("File " + file + " is different", expected, data);            }        }    }    private static String normalizeLineSeparators(String s) {        return s.replaceAll(Pattern.quote(IOUtils.LINE_SEPARATOR_WINDOWS), IOUtils.LINE_SEPARATOR_UNIX)                .replaceAll(Pattern.quote(IOUtils.LINE_SEPARATOR_UNIX), PMD.EOL);    }    @Override    public Renderer getRenderer() {        Renderer result = new YAHTMLRenderer();        result.setProperty(YAHTMLRenderer.OUTPUT_DIR, outputDir.getAbsolutePath());        return result;    }    @Override    public String getExpected() {        return "<h3 align=\"center\">The HTML files are located in '" + outputDir + "'.</h3>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return getExpected();    }    @Override    public String getExpectedMultiple() {        return getExpected();    }    @Override    public String getExpectedError(ProcessingError error) {        return getExpected();    }    @Override    public String getExpectedError(ConfigurationError error) {        return getExpected();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.renderers;import static org.junit.Assert.assertEquals;import java.util.Collections;import org.junit.Test;import net.sourceforge.pmd.FooRule;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.Report.ConfigurationError;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.ReportTest;import net.sourceforge.pmd.RuleContext;import net.sourceforge.pmd.RuleContextTest;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;public class SummaryHTMLRendererTest extends AbstractRendererTest {    @Override    public Renderer getRenderer() {        Renderer result = new SummaryHTMLRenderer();        result.setProperty(HTMLRenderer.LINK_PREFIX, "link_prefix");        result.setProperty(HTMLRenderer.LINE_PREFIX, "line_prefix");        result.setProperty(HTMLRenderer.HTML_EXTENSION, true);        return result;    }    @Override    protected String getSourceCodeFilename() {        return "notAvailable";    }    @Override    public String getExpected() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>1</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedEmpty() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedMultiple() {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL                + "<tr><td>Foo</td><td align=center>2</td></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"center\">1</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "<tr> " + PMD.EOL + "<td align=\"center\">2</td>" + PMD.EOL                + "<td width=\"*%\"><a href=\"link_prefix" + getSourceCodeFilename() + ".html#line_prefix1\">" + getSourceCodeFilename() + "</a></td>" + PMD.EOL                + "<td align=\"center\" width=\"5%\">1</td>" + PMD.EOL + "<td width=\"*\">blah</td>" + PMD.EOL + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ProcessingError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Processing errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td><a href=\"link_prefixfile.html#\">file</a></td>" + PMD.EOL + "<td><pre>" + error.getDetail() + "</pre></td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Override    public String getExpectedError(ConfigurationError error) {        return "<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>" + PMD.EOL                + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Configuration errors</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>Rule</th><th>Problem</th></tr>" + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL                + "<td>Foo</td>" + PMD.EOL + "<td>a configuration error</td>" + PMD.EOL + "</tr>" + PMD.EOL                + "</table></tr></table></body></html>" + PMD.EOL;    }    @Test    public void testShowSuppressions() throws Exception {        Report rep = createEmptyReportWithSuppression();        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(true);        String actual = ReportTest.render(renderer, rep);        assertEquals("<html><head><title>PMD</title></head><body>" + PMD.EOL + "<center><h2>Summary</h2></center>"                + PMD.EOL + "<table align=\"center\" cellspacing=\"0\" cellpadding=\"3\">" + PMD.EOL                + "<tr><th>Rule name</th><th>Number of violations</th></tr>" + PMD.EOL + "</table>" + PMD.EOL                + "<center><h2>Detail</h2></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL                + "<center><h3>PMD report</h3></center><center><h3>Problems found</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>#</th><th>File</th><th>Line</th><th>Problem</th></tr>" + PMD.EOL                + "</table><hr/><center><h3>Suppressed warnings</h3></center><table align=\"center\" cellspacing=\"0\" cellpadding=\"3\"><tr>"                + PMD.EOL + "<th>File</th><th>Line</th><th>Rule</th><th>NOPMD or Annotation</th><th>Reason</th></tr>"                + PMD.EOL + "<tr bgcolor=\"lightgrey\"> " + PMD.EOL + "<td align=\"left\"><a href=\"link_prefixtest.html#line_prefix1\">test</a></td>" + PMD.EOL                + "<td align=\"center\">1</td>" + PMD.EOL + "<td align=\"center\">Foo</td>" + PMD.EOL                         + "<td align=\"center\">//NOPMD</td>" + PMD.EOL + "<td align=\"center\">test</td>" + PMD.EOL                         + "</tr>"                + PMD.EOL + "</table></tr></table></body></html>" + PMD.EOL, actual);    }    @Test    public void testHideSuppressions() throws Exception {        Report rep = createEmptyReportWithSuppression();        Renderer renderer = getRenderer();        renderer.setShowSuppressedViolations(false);        String actual = ReportTest.render(renderer, rep);        assertEquals(getExpectedEmpty(), actual);    }    private Report createEmptyReportWithSuppression() throws Exception {        DummyRoot root = new DummyRoot(Collections.singletonMap(1, "test"));        root.setCoords(1, 10, 4, 5);        return RuleContextTest.getReportForRuleApply(new FooRule() {            @Override            public void apply(Node node, RuleContext ctx) {                addViolationWithMessage(ctx, node, "suppress test", 1, 1);            }        }, root);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.List;import java.util.Set;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.util.datasource.DataSource;public class PMDFilelistTest {    @Test    public void testGetApplicableFiles() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(2, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("anotherfile.dummy"));    }    @Test    public void testGetApplicableFilesMultipleLines() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist2.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(3, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("anotherfile.dummy"));        Assert.assertTrue(applicableFiles.get(2).getNiceFileName(false, "").endsWith("somefile.dummy"));    }    @Test    public void testGetApplicatbleFilesWithIgnores() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputFilePath("src/test/resources/net/sourceforge/pmd/cli/filelist3.txt");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(2, applicableFiles.size());        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("somefile2.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("somefile4.dummy"));    }    @Test    public void testGetApplicatbleFilesWithDirAndIgnores() {        Set<Language> languages = new HashSet<>();        languages.add(new DummyLanguageModule());        PMDConfiguration configuration = new PMDConfiguration();        configuration.setInputPaths("src/test/resources/net/sourceforge/pmd/cli/src");        configuration.setIgnoreFilePath("src/test/resources/net/sourceforge/pmd/cli/ignorelist.txt");        List<DataSource> applicableFiles = PMD.getApplicableFiles(configuration, languages);        Assert.assertEquals(4, applicableFiles.size());        Collections.sort(applicableFiles, new Comparator<DataSource>() {            @Override            public int compare(DataSource o1, DataSource o2) {                if (o1 == null && o2 != null) {                    return -1;                } else if (o1 != null && o2 == null) {                    return 1;                } else {                    return o1.getNiceFileName(false, "").compareTo(o2.getNiceFileName(false, ""));                }            }        });        Assert.assertTrue(applicableFiles.get(0).getNiceFileName(false, "").endsWith("anotherfile.dummy"));        Assert.assertTrue(applicableFiles.get(1).getNiceFileName(false, "").endsWith("somefile.dummy"));        Assert.assertTrue(applicableFiles.get(2).getNiceFileName(false, "").endsWith("somefile2.dummy"));        Assert.assertTrue(applicableFiles.get(3).getNiceFileName(false, "").endsWith("somefile4.dummy"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import static org.junit.Assert.assertTrue;import org.junit.Assert;import org.junit.Before;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.ExpectedSystemExit;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import net.sourceforge.pmd.PMDConfiguration;import net.sourceforge.pmd.cache.NoopAnalysisCache;/** * Unit test for {@link PMDCommandLineInterface} */public class PMDCommandLineInterfaceTest {    @Rule    public final ExpectedSystemExit exit = ExpectedSystemExit.none();    @Rule // Restores system properties after test    public final RestoreSystemProperties restoreSystemProperties = new RestoreSystemProperties();    @Before    public void clearSystemProperties() {        System.clearProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN);        System.clearProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY);    }    @Test    public void testProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "yahtml", "-P", "outputDir=output_folder", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        Assert.assertEquals("output_folder", params.getProperties().getProperty("outputDir"));    }    @Test    public void testMultipleProperties() {        PMDParameters params = new PMDParameters();        String[] args = { "-d", "source_folder", "-f", "ideaj", "-P", "sourcePath=/home/user/source/", "-P",            "fileName=Foo.java", "-P", "classAndMethodName=Foo.method", "-R", "java-empty", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        Assert.assertEquals("/home/user/source/", params.getProperties().getProperty("sourcePath"));        Assert.assertEquals("Foo.java", params.getProperties().getProperty("fileName"));        Assert.assertEquals("Foo.method", params.getProperties().getProperty("classAndMethodName"));    }    @Test    public void testNoCacheSwitch() {        PMDParameters params = new PMDParameters();        String[] args = {"-d", "source_folder", "-f", "ideaj", "-R", "java-empty", "-cache", "/home/user/.pmd/cache", "-no-cache", };        PMDCommandLineInterface.extractParameters(params, args, "PMD");        assertTrue(params.isIgnoreIncrementalAnalysis());        PMDConfiguration config = params.toConfiguration();        assertTrue(config.isIgnoreIncrementalAnalysis());        assertTrue(config.getAnalysisCache() instanceof NoopAnalysisCache);    }    @Test    public void testSetStatusCodeOrExitDoExit() {        exit.expectSystemExitWithStatus(0);        PMDCommandLineInterface.setStatusCodeOrExit(0);    }    @Test    public void testSetStatusCodeOrExitSetStatus() {        System.setProperty(PMDCommandLineInterface.NO_EXIT_AFTER_RUN, "1");        PMDCommandLineInterface.setStatusCodeOrExit(0);        Assert.assertEquals(System.getProperty(PMDCommandLineInterface.STATUS_CODE_PROPERTY), "0");    }    @Test    public void testBuildUsageText() {        // no exception..        Assert.assertNotNull(PMDCommandLineInterface.buildUsageText());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cli;import org.apache.commons.lang3.reflect.FieldUtils;import org.junit.Assert;import org.junit.Test;public class PMDParametersTest {    @Test    public void testVersion() throws Exception {        PMDParameters parameters = new PMDParameters();        // no language set, uses default language        Assert.assertEquals("1.7", parameters.getVersion());        // now set language        FieldUtils.writeDeclaredField(parameters, "language", "dummy2", true);        Assert.assertEquals("1.0", parameters.getVersion());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import org.junit.Assert;import org.junit.Test;public class RuleSetFactoryCompatibilityTest {    @Test    public void testCorrectOldReference() throws Exception {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n"                + " <rule ref=\"rulesets/dummy/notexisting.xml/DummyBasicMockRule\" />\n" + "</ruleset>\n";        RuleSetFactoryCompatibility compat = new RuleSetFactoryCompatibility();        compat.addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        RuleSetLoader factory = new RuleSetLoader().setCompatibility(compat);        RuleSet createdRuleSet = factory.loadFromString("dummy.xml", ruleset);        Assert.assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));    }    @Test    public void testCorrectMovedAndRename() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "OldDummyBasicMockRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldDummyBasicMockRule", "NewNameForDummyBasicMockRule");        String out = rsfc.applyRef("rulesets/dummy/notexisting.xml/OldDummyBasicMockRule");        Assert.assertEquals("rulesets/dummy/basic.xml/NewNameForDummyBasicMockRule", out);    }    @Test    public void testExclusion() {        final String ruleset = "<?xml version=\"1.0\"?>\n" + "\n" + "<ruleset name=\"Test\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Test</description>\n" + "\n" + " <rule ref=\"rulesets/dummy/basic.xml\">\n"                + "   <exclude name=\"OldNameOfSampleXPathRule\"/>\n" + " </rule>\n" + "</ruleset>\n";        RuleSetFactoryCompatibility compat = new RuleSetFactoryCompatibility();        compat.addFilterRuleRenamed("dummy", "basic", "OldNameOfSampleXPathRule", "SampleXPathRule");        RuleSetLoader factory = new RuleSetLoader().setCompatibility(compat);        RuleSet createdRuleSet = factory.loadFromString("dummy.xml", ruleset);        Assert.assertNotNull(createdRuleSet.getRuleByName("DummyBasicMockRule"));        Assert.assertNull(createdRuleSet.getRuleByName("SampleXPathRule"));    }    @Test    public void testExclusionRenamedAndMoved() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMovedAndRenamed("dummy", "oldbasic", "OldDummyBasicMockRule", "basic", "NewNameForDummyBasicMockRule");        String in = "rulesets/dummy/oldbasic.xml";        String out = rsfc.applyRef(in);        Assert.assertEquals(in, out);    }    @Test    public void testFilter() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleMoved("dummy", "notexisting", "basic", "DummyBasicMockRule");        rsfc.addFilterRuleRemoved("dummy", "basic", "DeletedRule");        rsfc.addFilterRuleRenamed("dummy", "basic", "OldNameOfBasicMockRule", "NewNameOfBasicMockRule");        Assert.assertEquals("rulesets/dummy/basic.xml/DummyBasicMockRule",                            rsfc.applyRef("rulesets/dummy/notexisting.xml/DummyBasicMockRule"));        Assert.assertEquals("rulesets/dummy/basic.xml/NewNameOfBasicMockRule",                            rsfc.applyRef("rulesets/dummy/basic.xml/OldNameOfBasicMockRule"));        Assert.assertNull(rsfc.applyRef("rulesets/dummy/basic.xml/DeletedRule"));    }    @Test    public void testExclusionFilter() {        RuleSetFactoryCompatibility rsfc = new RuleSetFactoryCompatibility();        rsfc.addFilterRuleRenamed("dummy", "basic", "AnotherOldNameOfBasicMockRule", "NewNameOfBasicMockRule");        String out = rsfc.applyExclude("rulesets/dummy/basic.xml", "AnotherOldNameOfBasicMockRule", false);        Assert.assertEquals("NewNameOfBasicMockRule", out);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import java.io.ByteArrayInputStream;import java.io.IOException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import java.util.List;import java.util.Locale;import javax.xml.XMLConstants;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;import javax.xml.transform.stream.StreamSource;import javax.xml.validation.Schema;import javax.xml.validation.SchemaFactory;import javax.xml.validation.Validator;import org.junit.Before;import org.junit.Test;import org.w3c.dom.Attr;import org.w3c.dom.Document;import org.xml.sax.EntityResolver;import org.xml.sax.ErrorHandler;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.SAXParseException;public class RuleSetSchemaTest {    private CollectingErrorHandler errorHandler;    @Before    public void setUp() {        Locale.setDefault(Locale.ROOT);        errorHandler = new CollectingErrorHandler();    }    @Test    public void verifyVersion2() throws Exception {        String ruleset = generateRuleSet("2.0.0");        Document doc = parseWithVersion2(ruleset);        assertNotNull(doc);        assertTrue(errorHandler.isValid());        assertEquals("Custom ruleset", ((Attr) doc.getElementsByTagName("ruleset").item(0).getAttributes().getNamedItem("name")).getValue());    }    @Test    public void validateOnly() throws Exception {        Validator validator = PMDRuleSetEntityResolver.getSchemaVersion2().newValidator();        validator.setErrorHandler(errorHandler);        validator.validate(new StreamSource(new ByteArrayInputStream(generateRuleSet("2.0.0").getBytes(StandardCharsets.UTF_8))));        assertTrue(errorHandler.isValid());        errorHandler.reset();    }    private Document parseWithVersion2(String ruleset) throws SAXException, ParserConfigurationException, IOException {        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        dbf.setNamespaceAware(true);        dbf.setFeature("http://apache.org/xml/features/validation/schema", true);        DocumentBuilder builder = dbf.newDocumentBuilder();        builder.setErrorHandler(errorHandler);        builder.setEntityResolver(new PMDRuleSetEntityResolver());        Document doc = builder.parse(new ByteArrayInputStream(ruleset.getBytes(StandardCharsets.UTF_8)));        return doc;    }    private String generateRuleSet(String version) {        String versionUnderscore = version.replaceAll("\\.", "_");        String ruleset = "<?xml version=\"1.0\"?>" + PMD.EOL                + "<ruleset " + PMD.EOL                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/" + version + "\"" + PMD.EOL                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"" + PMD.EOL                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/" + version + " https://pmd.sourceforge.io/ruleset_" + versionUnderscore + ".xsd\""                + "    name=\"Custom ruleset\" >" + PMD.EOL                + "  <description>" + PMD.EOL                + "  This ruleset checks my code for bad stuff" + PMD.EOL                + "  </description>" + PMD.EOL                + "  <rule name=\"DummyBasicMockRule\" language=\"dummy\" since=\"1.0\" message=\"Test Rule 1\"" + PMD.EOL                + "        class=\"net.sourceforge.pmd.lang.rule.MockRule\"" + PMD.EOL                + "        externalInfoUrl=\"${pmd.website.baseurl}/rules/dummy/basic.xml#DummyBasicMockRule\"" + PMD.EOL                + "  >" + PMD.EOL                + "        <description>" + PMD.EOL                + "           Just for test" + PMD.EOL                + "     </description>" + PMD.EOL                + "        <priority>3</priority>" + PMD.EOL                + "        <example>" + PMD.EOL                + " <![CDATA[" + PMD.EOL                + " ]]>" + PMD.EOL                + "     </example>" + PMD.EOL                + "    </rule>" + PMD.EOL                + "  <rule ref=\"rulesets/dummy/basic.xml#DummyBasicMockRule\"/>" + PMD.EOL                + "</ruleset>" + PMD.EOL;        return ruleset;    }    public static class PMDRuleSetEntityResolver implements EntityResolver {        private static URL schema2 = PMDRuleSetEntityResolver.class.getResource("/ruleset_2_0_0.xsd");        private static SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);        @Override        public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {            if ("https://pmd.sourceforge.io/ruleset_2_0_0.xsd".equals(systemId)) {                return new InputSource(schema2.toExternalForm());            }            throw new IllegalArgumentException("Unable to resolve entity (publicId=" + publicId + ", systemId=" + systemId + ")");        }        public static Schema getSchemaVersion2() throws SAXException {            return schemaFactory.newSchema(schema2);        }    }    public static class CollectingErrorHandler implements ErrorHandler {        private List<SAXParseException> warnings = new ArrayList<>();        private List<SAXParseException> errors = new ArrayList<>();        private List<SAXParseException> fatalErrors = new ArrayList<>();        public boolean isValid() {            return warnings.isEmpty() && errors.isEmpty() && fatalErrors.isEmpty();        }        public List<SAXParseException> getWarnings() {            return warnings;        }        public List<SAXParseException> getErrors() {            return errors;        }        public List<SAXParseException> getFatalErrors() {            return fatalErrors;        }        @Override        public void warning(SAXParseException exception) throws SAXException {            warnings.add(exception);        }        @Override        public void error(SAXParseException exception) throws SAXException {            errors.add(exception);        }        @Override        public void fatalError(SAXParseException exception) throws SAXException {            fatalErrors.add(exception);        }        @Override        public String toString() {            return "Warnings: " + warnings + "; Errors: " + errors + "; Fatal Errors: " + fatalErrors;        }        public void reset() {            warnings.clear();            errors.clear();            fatalErrors.clear();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import java.io.File;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageFilenameFilter;import net.sourceforge.pmd.lang.LanguageRegistry;/** * Tests on FileSelector. * * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be */public class FileSelectorTest {    /**     * Test wanted selection of a source file.     */    @Test    public void testWantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/myFile.dummy");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("This file should be selected !", true, selected);    }    /**     * Test unwanted selection of a non source file.     */    @Test    public void testUnwantedFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/myFile.txt");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("Not-source file must not be selected!", false, selected);    }    /**     * Test unwanted selection of a java file.     */    @Test    public void testUnwantedJavaFile() {        LanguageFilenameFilter fileSelector = new LanguageFilenameFilter(                LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        File javaFile = new File("/path/to/MyClass.java");        boolean selected = fileSelector.accept(javaFile.getParentFile(), javaFile.getName());        assertEquals("Unwanted java file must not be selected!", false, selected);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertSame;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;import java.util.Random;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;public class RuleViolationComparatorTest {    @Test    public void testComparator() {        Rule rule1 = new MockRule("name1", "desc", "msg", "rulesetname1");        Rule rule2 = new MockRule("name2", "desc", "msg", "rulesetname2");        // RuleViolations created in pre-sorted order        RuleViolation[] expectedOrder = new RuleViolation[12];        int index = 0;        // Different begin line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file1", 20, "desc1", 1, 20, 80);        // Different description        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file2", 10, "desc2", 1, 20, 80);        // Different begin column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file3", 10, "desc1", 10, 20, 80);        // Different end line        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file4", 10, "desc1", 1, 30, 80);        // Different end column        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule1, "file5", 10, "desc1", 1, 20, 90);        // Different rule name        expectedOrder[index++] = createJavaRuleViolation(rule1, "file6", 10, "desc1", 1, 20, 80);        expectedOrder[index++] = createJavaRuleViolation(rule2, "file6", 10, "desc1", 1, 20, 80);        // Randomize        List<RuleViolation> ruleViolations = new ArrayList<>(Arrays.asList(expectedOrder));        long seed = System.nanoTime();        Random random = new Random(seed);        Collections.shuffle(ruleViolations, random);        // Sort        Collections.sort(ruleViolations, RuleViolation.DEFAULT_COMPARATOR);        // Check        int count = 0;        for (int i = 0; i < expectedOrder.length; i++) {            count++;            assertSame("Wrong RuleViolation " + i + ", used seed: " + seed, expectedOrder[i], ruleViolations.get(i));        }        assertEquals("Missing assertion for every RuleViolation", expectedOrder.length, count);    }    private RuleViolation createJavaRuleViolation(Rule rule, String fileName, int beginLine, String description,            int beginColumn, int endLine, int endColumn) {        DummyNode simpleNode = new DummyNode();        simpleNode.setCoords(beginLine, beginColumn, endLine, endColumn);        return new ParametricRuleViolation<Node>(rule, fileName, simpleNode, description);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;public class RuleReferenceTest {    @Test    public void testRuleSetReference() {        RuleReference ruleReference = new RuleReference();        RuleSetReference ruleSetReference = new RuleSetReference("somename");        ruleReference.setRuleSetReference(ruleSetReference);        assertEquals("Not same rule set reference", ruleSetReference, ruleReference.getRuleSetReference());    }    @Test    public void testOverride() {        final PropertyDescriptor<String> PROPERTY1_DESCRIPTOR = PropertyFactory.stringProperty("property1").desc("Test property").defaultValue("").build();        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        Language dummyLang = LanguageRegistry.getLanguage(DummyLanguageModule.NAME);        rule.setLanguage(dummyLang);        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final PropertyDescriptor<String> PROPERTY2_DESCRIPTOR = PropertyFactory.stringProperty("property2").desc("Test property").defaultValue("").build();        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setMinimumLanguageVersion(dummyLang.getVersion("1.3"));        ruleReference.setMaximumLanguageVersion(dummyLang.getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverriddenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, ruleReference);    }    @Test    public void testLanguageOverrideDisallowed() {        MockRule rule = new MockRule();        Language dummyLang = LanguageRegistry.getLanguage(DummyLanguageModule.NAME);        rule.setLanguage(dummyLang);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        Assert.assertThrows(UnsupportedOperationException.class, () -> ruleReference.setLanguage(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME)));        Assert.assertEquals(dummyLang, ruleReference.getLanguage());        Assert.assertThrows(IllegalArgumentException.class, () -> ruleReference.setMaximumLanguageVersion(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME).getVersion("1.0")));        Assert.assertEquals(rule.getMaximumLanguageVersion(), ruleReference.getOverriddenMaximumLanguageVersion());        Assert.assertThrows(IllegalArgumentException.class, () -> ruleReference.setMinimumLanguageVersion(LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME).getVersion("1.0")));        Assert.assertEquals(rule.getMinimumLanguageVersion(), ruleReference.getMinimumLanguageVersion());    }    @Test    public void testDeepCopyOverride() {        final PropertyDescriptor<String> PROPERTY1_DESCRIPTOR = PropertyFactory.stringProperty("property1").desc("Test property").defaultValue("").build();        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        Language dummyLang = LanguageRegistry.getLanguage(DummyLanguageModule.NAME);        rule.setLanguage(dummyLang);        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        final PropertyDescriptor<String> PROPERTY2_DESCRIPTOR = PropertyFactory.stringProperty("property2").desc("Test property").defaultValue("").build();        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference.definePropertyDescriptor(PROPERTY2_DESCRIPTOR);        ruleReference.setLanguage(dummyLang);        ruleReference.setMinimumLanguageVersion(dummyLang.getVersion("1.3"));        ruleReference.setMaximumLanguageVersion(dummyLang.getVersion("1.7"));        ruleReference.setDeprecated(true);        ruleReference.setName("name2");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value2");        ruleReference.setProperty(PROPERTY2_DESCRIPTOR, "value3");        ruleReference.setMessage("message2");        ruleReference.setDescription("description2");        ruleReference.addExample("example2");        ruleReference.setExternalInfoUrl("externalInfoUrl2");        ruleReference.setPriority(RulePriority.MEDIUM_HIGH);        validateOverriddenValues(PROPERTY1_DESCRIPTOR, PROPERTY2_DESCRIPTOR, (RuleReference) ruleReference.deepCopy());    }    private void validateOverriddenValues(final PropertyDescriptor<String> propertyDescriptor1,                                          final PropertyDescriptor<String> propertyDescriptor2, RuleReference ruleReference) {        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME),                ruleReference.getLanguage());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getOverriddenMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getMaximumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getOverriddenMaximumLanguageVersion());        assertEquals("Override failed", false, ruleReference.getRule().isDeprecated());        assertEquals("Override failed", true, ruleReference.isDeprecated());        assertEquals("Override failed", true, ruleReference.isOverriddenDeprecated());        assertEquals("Override failed", "name2", ruleReference.getName());        assertEquals("Override failed", "name2", ruleReference.getOverriddenName());        assertEquals("Override failed", "value2", ruleReference.getProperty(propertyDescriptor1));        assertEquals("Override failed", "value3", ruleReference.getProperty(propertyDescriptor2));        assertTrue("Override failed", ruleReference.getPropertyDescriptors().contains(propertyDescriptor1));        assertTrue("Override failed", ruleReference.getPropertyDescriptors().contains(propertyDescriptor2));        assertFalse("Override failed", ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor1));        assertTrue("Override failed", ruleReference.getOverriddenPropertyDescriptors().contains(propertyDescriptor2));        assertTrue("Override failed",                ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1));        assertTrue("Override failed",                ruleReference.getPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2));        assertTrue("Override failed",                ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor1));        assertTrue("Override failed",                ruleReference.getOverriddenPropertiesByPropertyDescriptor().containsKey(propertyDescriptor2));        assertEquals("Override failed", "message2", ruleReference.getMessage());        assertEquals("Override failed", "message2", ruleReference.getOverriddenMessage());        assertEquals("Override failed", "description2", ruleReference.getDescription());        assertEquals("Override failed", "description2", ruleReference.getOverriddenDescription());        assertEquals("Override failed", 2, ruleReference.getExamples().size());        assertEquals("Override failed", "example1", ruleReference.getExamples().get(0));        assertEquals("Override failed", "example2", ruleReference.getExamples().get(1));        assertEquals("Override failed", "example2", ruleReference.getOverriddenExamples().get(0));        assertEquals("Override failed", "externalInfoUrl2", ruleReference.getExternalInfoUrl());        assertEquals("Override failed", "externalInfoUrl2", ruleReference.getOverriddenExternalInfoUrl());        assertEquals("Override failed", RulePriority.MEDIUM_HIGH, ruleReference.getPriority());        assertEquals("Override failed", RulePriority.MEDIUM_HIGH, ruleReference.getOverriddenPriority());    }    @Test    public void testNotOverride() {        final PropertyDescriptor<String> PROPERTY1_DESCRIPTOR = PropertyFactory.stringProperty("property1").desc("Test property").defaultValue("").build();        MockRule rule = new MockRule();        rule.definePropertyDescriptor(PROPERTY1_DESCRIPTOR);        rule.setLanguage(LanguageRegistry.getLanguage(DummyLanguageModule.NAME));        rule.setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        rule.setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        rule.setName("name1");        rule.setProperty(PROPERTY1_DESCRIPTOR, "value1");        rule.setMessage("message1");        rule.setDescription("description1");        rule.addExample("example1");        rule.setExternalInfoUrl("externalInfoUrl1");        rule.setPriority(RulePriority.HIGH);        RuleReference ruleReference = new RuleReference();        ruleReference.setRule(rule);        ruleReference                .setMinimumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"));        ruleReference                .setMaximumLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"));        ruleReference.setDeprecated(false);        ruleReference.setName("name1");        ruleReference.setProperty(PROPERTY1_DESCRIPTOR, "value1");        ruleReference.setMessage("message1");        ruleReference.setDescription("description1");        ruleReference.addExample("example1");        ruleReference.setExternalInfoUrl("externalInfoUrl1");        ruleReference.setPriority(RulePriority.HIGH);        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.3"),                ruleReference.getMinimumLanguageVersion());        assertNull("Override failed", ruleReference.getOverriddenMinimumLanguageVersion());        assertEquals("Override failed", LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                ruleReference.getMaximumLanguageVersion());        assertNull("Override failed", ruleReference.getOverriddenMaximumLanguageVersion());        assertEquals("Override failed", false, ruleReference.isDeprecated());        assertNull("Override failed", ruleReference.isOverriddenDeprecated());        assertEquals("Override failed", "name1", ruleReference.getName());        assertNull("Override failed", ruleReference.getOverriddenName());        assertEquals("Override failed", "value1", ruleReference.getProperty(PROPERTY1_DESCRIPTOR));        assertEquals("Override failed", "message1", ruleReference.getMessage());        assertNull("Override failed", ruleReference.getOverriddenMessage());        assertEquals("Override failed", "description1", ruleReference.getDescription());        assertNull("Override failed", ruleReference.getOverriddenDescription());        assertEquals("Override failed", 1, ruleReference.getExamples().size());        assertEquals("Override failed", "example1", ruleReference.getExamples().get(0));        assertNull("Override failed", ruleReference.getOverriddenExamples());        assertEquals("Override failed", "externalInfoUrl1", ruleReference.getExternalInfoUrl());        assertNull("Override failed", ruleReference.getOverriddenExternalInfoUrl());        assertEquals("Override failed", RulePriority.HIGH, ruleReference.getPriority());        assertNull("Override failed", ruleReference.getOverriddenPriority());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.io.ByteArrayOutputStream;import java.util.Random;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.rule.RuleReference;/** * Unit test for {@link RuleSetWriter}. * */public class RuleSetWriterTest {    private ByteArrayOutputStream out;    private RuleSetWriter writer;    /**     * Prepare the output stream.     */    @Before    public void setupOutputStream() {        out = new ByteArrayOutputStream();        writer = new RuleSetWriter(out);    }    /**     * Closes the output stream at the end.     */    @After    public void cleanupStream() {        if (writer != null) {            writer.close();        }    }    /**     * Tests the exclude rule behavior. See bug #945.     *     * @throws Exception     *             any error     */    @Test    public void testWrite() throws Exception {        RuleSet braces = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/TestRuleset1.xml");        RuleSet ruleSet = new RuleSetBuilder(new Random().nextLong())                .withName("ruleset")                .withDescription("ruleset description")                .addRuleSetByReference(braces, true, "MockRule2")                .build();        writer.write(ruleSet);        String written = out.toString("UTF-8");        Assert.assertTrue(written.contains("<exclude name=\"MockRule2\""));    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     * @throws Exception     *             any error     */    @Test    public void testRuleReferenceOverriddenName() throws Exception {        RuleSet rs = new RuleSetLoader().loadFromResource("rulesets/dummy/basic.xml");        RuleReference ruleRef = new RuleReference();        ruleRef.setRule(rs.getRuleByName("DummyBasicMockRule"));        ruleRef.setRuleSetReference(new RuleSetReference("rulesets/dummy/basic.xml"));        ruleRef.setName("Foo"); // override the name        RuleSet ruleSet = RuleSet.forSingleRule(ruleRef);        writer.write(ruleSet);        String written = out.toString("UTF-8");        Assert.assertTrue(written.contains("ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\""));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.properties.constraints.NumericConstraints.inRange;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import java.util.Collections;import java.util.Map;import org.junit.Test;import net.sourceforge.pmd.Report.SuppressedViolation;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.lang.rule.impl.DefaultRuleViolationFactory;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.properties.PropertyFactory;public class AbstractRuleTest {    public static class MyRule extends AbstractRule {        private static final PropertyDescriptor<String> FOO_PROPERTY = PropertyFactory.stringProperty("foo").desc("foo property").defaultValue("x").build();        private static final PropertyDescriptor<String> FOO_DEFAULT_PROPERTY = PropertyFactory.stringProperty("fooDefault")                .defaultValue("bar")                .desc("Property without value uses default value")                .build();        private static final PropertyDescriptor<String> XPATH_PROPERTY = PropertyFactory.stringProperty("xpath").desc("xpath property").defaultValue("").build();        public MyRule() {            definePropertyDescriptor(FOO_PROPERTY);            definePropertyDescriptor(XPATH_PROPERTY);            definePropertyDescriptor(FOO_DEFAULT_PROPERTY);            setName("MyRule");            setMessage("my rule msg");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(Node target, RuleContext ctx) {        }    }    private static class MyOtherRule extends AbstractRule {        private static final PropertyDescriptor<String> FOO_PROPERTY = PropertyFactory.stringProperty("foo").desc("foo property").defaultValue("x").build();        MyOtherRule() {            definePropertyDescriptor(FOO_PROPERTY);            setName("MyOtherRule");            setMessage("my other rule");            setPriority(RulePriority.MEDIUM);            setProperty(FOO_PROPERTY, "value");        }        @Override        public void apply(Node target, RuleContext ctx) {        }    }    @Test    public void testCreateRV() {        MyRule r = new MyRule();        r.setRuleSetName("foo");        DummyNode s = new DummyNode();        s.setCoords(5, 5, 5, 10);        RuleViolation rv = new ParametricRuleViolation<>(r, "filename", s, r.getMessage());        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule msg mismatch!", "my rule msg", rv.getDescription());        assertEquals("RuleSet name mismatch!", "foo", rv.getRule().getRuleSetName());    }    @Test    public void testCreateRV2() {        MyRule r = new MyRule();        DummyNode s = new DummyNode();        s.setCoords(5, 5, 5, 10);        RuleViolation rv = new ParametricRuleViolation<>(r, "filename", s, "specificdescription");        assertEquals("Line number mismatch!", 5, rv.getBeginLine());        assertEquals("Filename mismatch!", "filename", rv.getFilename());        assertEquals("Rule object mismatch!", r, rv.getRule());        assertEquals("Rule description mismatch!", "specificdescription", rv.getDescription());    }    @Test    public void testRuleWithVariableInMessage() throws Exception {        MyRule r = new MyRule() {            @Override            public void apply(Node target, RuleContext ctx) {                addViolation(ctx, target);            }        };        r.definePropertyDescriptor(PropertyFactory.intProperty("testInt").desc("description").require(inRange(0, 100)).defaultValue(10).build());        r.setMessage("Message ${packageName} ${className} ${methodName} ${variableName} ${testInt} ${noSuchProperty}");        DummyNode s = new DummyRoot();        s.setCoords(5, 1, 6, 1);        s.setImage("TestImage");        RuleViolation rv = RuleContextTest.getReportForRuleApply(r, s).getViolations().get(0);        assertEquals("Message foo    10 ${noSuchProperty}", rv.getDescription());    }    @Test    public void testRuleSuppress() {        Map<Integer, String> m = Collections.singletonMap(5, "");        DummyRoot n = new DummyRoot(m);        n.setCoords(5, 1, 6, 1);        RuleViolation violation = DefaultRuleViolationFactory.defaultInstance().createViolation(new MyRule(), n, "file", "specificdescription");        SuppressedViolation suppressed = DefaultRuleViolationFactory.defaultInstance().suppressOrNull(n, violation);        assertNotNull(suppressed);    }    @Test    public void testEquals1() {        MyRule r = new MyRule();        assertFalse("A rule is never equals to null!", r.equals(null));    }    @Test    public void testEquals2() {        MyRule r = new MyRule();        assertEquals("A rule must be equals to itself", r, r);    }    @Test    public void testEquals3() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        assertEquals("Two instances of the same rule are equal", r1, r2);        assertEquals("Hashcode for two instances of the same rule must be equal", r1.hashCode(), r2.hashCode());    }    @Test    public void testEquals4() {        MyRule myRule = new MyRule();        assertFalse("A rule cannot be equal to an object of another class", myRule.equals("MyRule"));    }    @Test    public void testEquals5() {        MyRule myRule = new MyRule();        MyOtherRule myOtherRule = new MyOtherRule();        assertFalse("Two rules from different classes cannot be equal", myRule.equals(myOtherRule));    }    @Test    public void testEquals6() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setName("MyRule2");        assertFalse("Rules with different names cannot be equal", r1.equals(r2));    }    @Test    public void testEquals7() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setPriority(RulePriority.HIGH);        assertFalse("Rules with different priority levels cannot be equal", r1.equals(r2));    }    @Test    public void testEquals8() {        MyRule r1 = new MyRule();        r1.setProperty(MyRule.XPATH_PROPERTY, "something");        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse("Rules with different properties values cannot be equal", r1.equals(r2));    }    @Test    public void testEquals9() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setProperty(MyRule.XPATH_PROPERTY, "something else");        assertFalse("Rules with different properties cannot be equal", r1.equals(r2));    }    @Test    public void testEquals10() {        MyRule r1 = new MyRule();        MyRule r2 = new MyRule();        r2.setMessage("another message");        assertEquals("Rules with different messages are still equal", r1, r2);        assertEquals("Rules that are equal must have the an equal hashcode", r1.hashCode(), r2.hashCode());    }    @Test    public void testDeepCopyRule() {        MyRule r1 = new MyRule();        MyRule r2 = (MyRule) r1.deepCopy();        assertEquals(r1.getDescription(), r2.getDescription());        assertEquals(r1.getExamples(), r2.getExamples());        assertEquals(r1.getExternalInfoUrl(), r2.getExternalInfoUrl());        assertEquals(r1.getLanguage(), r2.getLanguage());        assertEquals(r1.getMaximumLanguageVersion(), r2.getMaximumLanguageVersion());        assertEquals(r1.getMessage(), r2.getMessage());        assertEquals(r1.getMinimumLanguageVersion(), r2.getMinimumLanguageVersion());        assertEquals(r1.getName(), r2.getName());        assertEquals(r1.getPriority(), r2.getPriority());        assertEquals(r1.getPropertyDescriptors(), r2.getPropertyDescriptors());        assertEquals(r1.getRuleClass(), r2.getRuleClass());        assertEquals(r1.getRuleSetName(), r2.getRuleSetName());        assertEquals(r1.getSince(), r2.getSince());        assertEquals(r1.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY),                r2.isPropertyOverridden(MyRule.FOO_DEFAULT_PROPERTY));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;import static com.github.tomakehurst.wiremock.client.WireMock.findAll;import static com.github.tomakehurst.wiremock.client.WireMock.get;import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.head;import static com.github.tomakehurst.wiremock.client.WireMock.headRequestedFor;import static com.github.tomakehurst.wiremock.client.WireMock.stubFor;import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;import static com.github.tomakehurst.wiremock.client.WireMock.urlMatching;import static com.github.tomakehurst.wiremock.client.WireMock.verify;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.InputStream;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Test;import net.sourceforge.pmd.util.ResourceLoader;import com.github.tomakehurst.wiremock.junit.WireMockRule;public class RuleSetReferenceIdTest {    private static void assertRuleSetReferenceId(final boolean expectedExternal, final String expectedRuleSetFileName,            final boolean expectedAllRules, final String expectedRuleName, final String expectedToString,            final RuleSetReferenceId reference) {        assertEquals("Wrong external", expectedExternal, reference.isExternal());        assertEquals("Wrong RuleSet file name", expectedRuleSetFileName, reference.getRuleSetFileName());        assertEquals("Wrong all Rule reference", expectedAllRules, reference.isAllRules());        assertEquals("Wrong Rule name", expectedRuleName, reference.getRuleName());        assertEquals("Wrong toString()", expectedToString, reference.toString());    }    @Test(expected = IllegalArgumentException.class)    public void testCommaInSingleId() {        new RuleSetReferenceId("bad,id");    }    @Test(expected = IllegalArgumentException.class)    public void testInternalWithInternal() {        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("SomeOtherRule"));    }    @Test(expected = IllegalArgumentException.class)    public void testExternalWithExternal() {        new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test(expected = IllegalArgumentException.class)    public void testExternalWithInternal() {        new RuleSetReferenceId("someruleset.xml/SomeRule", new RuleSetReferenceId("SomeOtherRule"));    }    @Test    public void testInteralWithExternal() {        // This is okay        new RuleSetReferenceId("SomeRule", new RuleSetReferenceId("someruleset.xml/SomeOtherRule"));    }    @Test    public void testEmptyRuleSet() {        // This is representative of how the Test framework creates        // RuleSetReferenceId from static RuleSet XMLs        RuleSetReferenceId reference = new RuleSetReferenceId(null);        assertRuleSetReferenceId(true, null, true, null, "anonymous all Rule", reference);    }    @Test    public void testInternalWithExternalRuleSet() {        // This is representative of how the RuleSetFactory temporarily pairs an        // internal reference        // with an external reference.        RuleSetReferenceId internalRuleSetReferenceId = new RuleSetReferenceId("MockRuleName");        assertRuleSetReferenceId(false, null, false, "MockRuleName", "MockRuleName", internalRuleSetReferenceId);        RuleSetReferenceId externalRuleSetReferenceId = new RuleSetReferenceId("rulesets/java/basic.xml");        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                externalRuleSetReferenceId);        RuleSetReferenceId pairRuleSetReferenceId = new RuleSetReferenceId("MockRuleName", externalRuleSetReferenceId);        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "MockRuleName",                "rulesets/java/basic.xml/MockRuleName", pairRuleSetReferenceId);    }    @Test    public void testConstructorGivenHttpUrlIdSucceedsAndProcessesIdCorrectly() {        final String sonarRulesetUrlId = "http://localhost:54321/profiles/export?format=pmd&language=java&name=Sonar%2520way";        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + sonarRulesetUrlId + "  ");        assertRuleSetReferenceId(true, sonarRulesetUrlId, true, null, sonarRulesetUrlId, ruleSetReferenceId);    }    @org.junit.Rule    public WireMockRule wireMockRule = new WireMockRule(0);    @Test    public void testConstructorGivenHttpUrlInputStream() throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String rulesetUrl = "http://localhost:" + wireMockRule.port() + path;        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200)));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody("xyz")));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + rulesetUrl + "  ");        assertRuleSetReferenceId(true, rulesetUrl, true, null, rulesetUrl, ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtils.toString(inputStream, StandardCharsets.UTF_8);            assertEquals("xyz", loaded);        }        verify(1, headRequestedFor(urlEqualTo(path)));        verify(0, headRequestedFor(urlEqualTo("/profiles")));        verify(1, getRequestedFor(urlEqualTo(path)));        assertEquals(1, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    public void testConstructorGivenHttpUrlSingleRuleInputStream() throws Exception {        String path = "/profiles/export?format=pmd&language=java&name=Sonar%2520way";        String completePath = path + "/DummyBasicMockRule";        String hostpart = "http://localhost:" + wireMockRule.port();        String basicRuleSet = IOUtils                .toString(RuleSetReferenceId.class.getResourceAsStream("/rulesets/dummy/basic.xml"), StandardCharsets.UTF_8);        stubFor(head(urlEqualTo(completePath)).willReturn(aResponse().withStatus(404)));        stubFor(head(urlEqualTo(path)).willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml")));        stubFor(get(urlEqualTo(path))                .willReturn(aResponse().withStatus(200).withHeader("Content-type", "text/xml").withBody(basicRuleSet)));        RuleSetReferenceId ruleSetReferenceId = new RuleSetReferenceId("  " + hostpart + completePath + "  ");        assertRuleSetReferenceId(true, hostpart + path, false, "DummyBasicMockRule", hostpart + completePath,                ruleSetReferenceId);        try (InputStream inputStream = ruleSetReferenceId.getInputStream(new ResourceLoader())) {            String loaded = IOUtils.toString(inputStream, StandardCharsets.UTF_8);            assertEquals(basicRuleSet, loaded);        }        verify(1, headRequestedFor(urlEqualTo(completePath)));        verify(1, headRequestedFor(urlEqualTo(path)));        verify(1, getRequestedFor(urlEqualTo(path)));        verify(0, getRequestedFor(urlEqualTo(completePath)));        assertEquals(2, findAll(headRequestedFor(urlMatching(".*"))).size());        assertEquals(1, findAll(getRequestedFor(urlMatching(".*"))).size());    }    @Test    public void testOneSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));    }    @Test    public void testMultipleSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-unusedcode,dummy-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(1));    }    /**     * See https://sourceforge.net/p/pmd/bugs/1201/     */    @Test    public void testMultipleRulesWithSpaces() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic, dummy-unusedcode, dummy2-basic");        assertEquals(3, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(1));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(2));    }    @Test    public void testOneReleaseRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("50");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/releases/50.xml", true, null, "rulesets/releases/50.xml",                references.get(0));    }    @Test    public void testOneFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));    }    @Test    public void testOneFullRuleSetURL() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("file://somepath/rulesets/java/unusedcode.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", true, null,                "file://somepath/rulesets/java/unusedcode.xml", references.get(0));    }    @Test    public void testMultipleFullRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("rulesets/java/unusedcode.xml,rulesets/java/basic.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/java/unusedcode.xml", true, null, "rulesets/java/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", true, null, "rulesets/java/basic.xml",                references.get(1));    }    @Test    public void testMixRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/dummy/unusedcode.xml,dummy2-basic");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/unusedcode.xml", true, null, "rulesets/dummy/unusedcode.xml",                references.get(0));        assertRuleSetReferenceId(true, "rulesets/dummy2/basic.xml", true, null, "rulesets/dummy2/basic.xml",                references.get(1));    }    @Test    public void testUnknownRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("nonexistant.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(0));    }    @Test    public void testUnknownAndSimpleRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic,nonexistant.xml");        assertEquals(2, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", true, null, "rulesets/dummy/basic.xml",                references.get(0));        assertRuleSetReferenceId(true, "nonexistant.xml", true, null, "nonexistant.xml", references.get(1));    }    @Test    public void testSimpleRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("dummy-basic/DummyBasicMockRule");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/dummy/basic.xml", false, "DummyBasicMockRule",                "rulesets/dummy/basic.xml/DummyBasicMockRule", references.get(0));    }    @Test    public void testFullRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("rulesets/java/basic.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "rulesets/java/basic.xml", false, "EmptyCatchBlock",                "rulesets/java/basic.xml/EmptyCatchBlock", references.get(0));    }    @Test    public void testFullRuleSetURLAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId                .parse("file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "file://somepath/rulesets/java/unusedcode.xml", false, "EmptyCatchBlock",                "file://somepath/rulesets/java/unusedcode.xml/EmptyCatchBlock", references.get(0));    }    @Test    public void testInternalRuleSetAndRule() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("EmptyCatchBlock");        assertEquals(1, references.size());        assertRuleSetReferenceId(false, null, false, "EmptyCatchBlock", "EmptyCatchBlock", references.get(0));    }    @Test    public void testRelativePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "pmd/pmd-ruleset.xml", true, null, "pmd/pmd-ruleset.xml", references.get(0));    }    @Test    public void testAbsolutePathRuleSet() {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse("/home/foo/pmd/pmd-ruleset.xml");        assertEquals(1, references.size());        assertRuleSetReferenceId(true, "/home/foo/pmd/pmd-ruleset.xml", true, null, "/home/foo/pmd/pmd-ruleset.xml",                references.get(0));    }    @Test    public void testFooRules() throws Exception {        String fooRulesFile = new File("./src/test/resources/net/sourceforge/pmd/rulesets/foo-project/foo-rules")                .getCanonicalPath();        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(fooRulesFile);        assertEquals(1, references.size());        assertRuleSetReferenceId(true, fooRulesFile, true, null, fooRulesFile, references.get(0));    }    @Test    public void testNullRulesetString() throws Exception {        List<RuleSetReferenceId> references = RuleSetReferenceId.parse(null);        assertTrue(references.isEmpty());    }    public static junit.framework.Test suite() {        return new junit.framework.JUnit4TestAdapter(RuleSetReferenceIdTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static net.sourceforge.pmd.util.CollectionUtil.listOf;import static net.sourceforge.pmd.util.CollectionUtil.setOf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.Set;import java.util.regex.Pattern;import org.apache.commons.io.FilenameUtils;import org.checkerframework.checker.nullness.qual.NonNull;import org.junit.Test;import net.sourceforge.pmd.Report.ProcessingError;import net.sourceforge.pmd.RuleSet.RuleSetBuilder;import net.sourceforge.pmd.lang.Dummy2LanguageModule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.DummyRoot;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.lang.rule.RuleTargetSelector;public class RuleSetTest {    private final Language dummyLang = LanguageRegistry.getLanguage(DummyLanguageModule.NAME);    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresName() {        new RuleSetBuilder(new Random().nextLong())            .withName(null);    }    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresDescription() {        new RuleSetBuilder(new Random().nextLong())            .withName("some name")            .withDescription(null);    }    @Test(expected = NullPointerException.class)    public void testRuleSetRequiresName2() {        new RuleSetBuilder(new Random().nextLong()).build();    }    @Test    public void testAccessors() {        RuleSet rs = new RuleSetBuilder(new Random().nextLong())                .withFileName("baz")                .withName("foo")                .withDescription("bar")                .build();        assertEquals("file name mismatch", "baz", rs.getFileName());        assertEquals("name mismatch", "foo", rs.getName());        assertEquals("description mismatch", "bar", rs.getDescription());    }    @Test    public void testGetRuleByName() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = RuleSet.forSingleRule(mock);        assertEquals("unable to fetch rule by name", mock, rs.getRuleByName("name"));    }    @Test    public void testGetRuleByName2() {        MockRule mock = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet rs = RuleSet.forSingleRule(mock);        assertNull("the rule FooRule must not be found!", rs.getRuleByName("FooRule"));    }    @Test    public void testRuleList() {        MockRule rule = new MockRule("name", "desc", "msg", "rulesetname");        RuleSet ruleset = RuleSet.forSingleRule(rule);        assertEquals("Size of RuleSet isn't one.", 1, ruleset.size());        Collection<Rule> rules = ruleset.getRules();        Iterator<Rule> i = rules.iterator();        assertTrue("Empty Set", i.hasNext());        assertEquals("Returned set of wrong size.", 1, rules.size());        assertEquals("Rule isn't in ruleset.", rule, i.next());    }    private RuleSetBuilder createRuleSetBuilder(String name) {        return new RuleSetBuilder(new Random().nextLong())                .withName(name)                .withDescription("Description for " + name);    }    @Test    public void testAddRuleSet() {        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet set2 = createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSet(set1)                .build();        assertEquals("ruleset size wrong", 2, set2.size());    }    @Test(expected = RuntimeException.class)    public void testAddRuleSetByReferenceBad() {        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        createRuleSetBuilder("ruleset2")                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .addRuleSetByReference(set1, false)                .build();    }    @Test    public void testAddRuleSetByReferenceAllRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")                .withFileName("foo")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, true)                .build();        assertEquals("wrong rule size", 2, set1.getRules().size());        for (Rule rule : set1.getRules()) {            assertTrue("not a rule reference", rule instanceof RuleReference);            RuleReference ruleReference = (RuleReference) rule;            assertEquals("wrong ruleset file name", "foo", ruleReference.getRuleSetReference().getRuleSetFileName());            assertTrue("not all rule reference", ruleReference.getRuleSetReference().isAllRules());        }    }    @Test    public void testAddRuleSetByReferenceSingleRule() {        RuleSet set2 = createRuleSetBuilder("ruleset2")                .withFileName("foo")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .addRule(new MockRule("name2", "desc", "msg", "rulesetname"))                .build();        RuleSet set1 = createRuleSetBuilder("ruleset1")                .addRuleSetByReference(set2, false)                .build();        assertEquals("wrong rule size", 2, set1.getRules().size());        for (Rule rule : set1.getRules()) {            assertTrue("not a rule reference", rule instanceof RuleReference);            RuleReference ruleReference = (RuleReference) rule;            assertEquals("wrong ruleset file name", "foo", ruleReference.getRuleSetReference().getRuleSetFileName());            assertFalse("should not be all rule reference", ruleReference.getRuleSetReference().isAllRules());        }    }    @Test    public void testApply0Rules() {        RuleSet ruleset = createRuleSetBuilder("ruleset").build();        verifyRuleSet(ruleset, 0, new HashSet<RuleViolation>());    }    @Test    public void testEquals1() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertFalse("A ruleset cannot be equals to null", s.equals(null));    }    @Test    @SuppressWarnings("PMD.UseAssertEqualsInsteadOfAssertTrue")    public void testEquals2() {        RuleSet s = createRuleSetBuilder("ruleset").build();        assertTrue("A rulset must be equals to itself", s.equals(s));    }    @Test    public void testEquals3() {        RuleSet s = new RuleSetBuilder(new Random().nextLong())                .withName("basic rules")                .withDescription("desc")                .build();        assertFalse("A ruleset cannot be equals to another kind of object", s.equals("basic rules"));    }    @Test    public void testEquals4() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        assertEquals("2 rulesets with same name and rules must be equals", s1, s2);        assertEquals("Equals rulesets must have the same hashcode", s1.hashCode(), s2.hashCode());    }    @Test    public void testEquals5() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my other ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        assertFalse("2 rulesets with different name but same rules must not be equals", s1.equals(s2));    }    @Test    public void testEquals6() {        RuleSet s1 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("name", "desc", "msg", "rulesetname"))                .build();        RuleSet s2 = createRuleSetBuilder("my ruleset")                .addRule(new MockRule("other rule", "desc", "msg", "rulesetname"))                .build();        assertFalse("2 rulesets with same name but different rules must not be equals", s1.equals(s2));    }    @Test    public void testLanguageApplies() {        Rule rule = new MockRule();        assertFalse("Different languages should not apply",                RuleSet.applies(rule, LanguageRegistry.getLanguage(Dummy2LanguageModule.NAME).getDefaultVersion()));        assertTrue("Same language with no min/max should apply",                RuleSet.applies(rule, dummyLang.getVersion("1.5")));        rule.setMinimumLanguageVersion(dummyLang.getVersion("1.5"));        assertTrue("Same language with valid min only should apply",                RuleSet.applies(rule, dummyLang.getVersion("1.5")));        rule.setMaximumLanguageVersion(dummyLang.getVersion("1.6"));        assertTrue("Same language with valid min and max should apply",                RuleSet.applies(rule, dummyLang.getVersion("1.5")));        assertFalse("Same language with outside range of min/max should not apply",                RuleSet.applies(rule, dummyLang.getVersion("1.4")));        assertFalse("Same language with outside range of min/max should not apply",                RuleSet.applies(rule, dummyLang.getVersion("1.7")));    }    @Test    public void testAddExcludePattern() {        RuleSet ruleSet =            createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertEquals("Invalid number of patterns", 1, ruleSet.getExcludePatterns().size());    }    @Test    public void testExcludePatternAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(Pattern.compile(".*"))                .withFileExclusions(Pattern.compile(".*ha"))                .build();        assertEquals("Exclude pattern", Arrays.asList(".*", ".*ha"), ruleSet2.getExcludePatterns());    }    @Test    public void testIncludePatternsAreOrdered() {        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileInclusions(Pattern.compile(".*"))                .withFileInclusions(Arrays.asList(Pattern.compile(".*ha"), Pattern.compile(".*hb")))                .build();        assertEquals("Exclude pattern", Arrays.asList(".*", ".*ha", ".*hb"), ruleSet2.getIncludePatterns());    }    @Test    public void testAddExcludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")                .withFileExclusions(Pattern.compile(".*"))                .build();        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of patterns", 1, ruleSet.getFileExclusions().size());        RuleSet ruleSet2 = createRuleSetBuilder("ruleset2")                .withFileExclusions(ruleSet.getFileExclusions())                .build();        assertNotNull("Exclude patterns", ruleSet2.getFileExclusions());        assertEquals("Invalid number of patterns", 1, ruleSet2.getFileExclusions().size());    }    @Test    public void testSetExcludePatterns() {        List<Pattern> excludePatterns = new ArrayList<>();        excludePatterns.add(Pattern.compile("ah*"));        excludePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset").replaceFileExclusions(excludePatterns).build();        assertNotNull("Exclude patterns", ruleSet.getExcludePatterns());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 2, ruleSet.getFileExclusions().size());        assertEquals("Exclude pattern", "ah*", ruleSet.getFileExclusions().get(0).pattern());        assertEquals("Exclude pattern", ".*", ruleSet.getFileExclusions().get(1).pattern());        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of include patterns", 0, ruleSet.getFileInclusions().size());    }    @Test    public void testAddIncludePattern() {        RuleSet ruleSet = createRuleSetBuilder("ruleset")                .withFileInclusions(Pattern.compile(".*"))                .build();        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of patterns", 1, ruleSet.getFileInclusions().size());        assertEquals("Include pattern", ".*", ruleSet.getFileInclusions().get(0).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testAddIncludePatterns() {        RuleSet ruleSet = createRuleSetBuilder("ruleset1")                .withFileInclusions(Pattern.compile("ah*"), Pattern.compile(".*"))                .build();        RuleSet ruleSet2 = createRuleSetBuilder("ruleset1")                .withFileInclusions(ruleSet.getFileInclusions())                .build();        assertNotNull("Include patterns", ruleSet2.getFileInclusions());        assertEquals("Invalid number of patterns", 2, ruleSet2.getFileInclusions().size());        assertEquals("Include pattern", "ah*", ruleSet2.getFileInclusions().get(0).pattern());        assertEquals("Include pattern", ".*", ruleSet2.getFileInclusions().get(1).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testSetIncludePatterns() {        List<Pattern> includePatterns = new ArrayList<>();        includePatterns.add(Pattern.compile("ah*"));        includePatterns.add(Pattern.compile(".*"));        RuleSet ruleSet = createRuleSetBuilder("ruleset")            .replaceFileInclusions(includePatterns)            .build();        assertEquals("Include patterns", includePatterns, ruleSet.getFileInclusions());        assertNotNull("Exclude patterns", ruleSet.getFileInclusions());        assertEquals("Invalid number of exclude patterns", 0, ruleSet.getFileExclusions().size());    }    @Test    public void testIncludeExcludeApplies() {        File file = new File("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java");        RuleSet ruleSet = createRuleSetBuilder("ruleset").build();        assertTrue("No patterns", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .build();        assertTrue("Non-matching exclude", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"), Pattern.compile(".*/package/.*"))                .build();        assertFalse("Matching exclude", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .build();        assertFalse("Non-matching include", ruleSet.applies(file));        ruleSet = createRuleSetBuilder("ruleset")                .withFileExclusions(Pattern.compile("nomatch"))                .withFileExclusions(Pattern.compile(".*/package/.*"))                .withFileInclusions(Pattern.compile(".*/randomX/.*"))                .withFileInclusions(Pattern.compile(".*/random/.*"))                .build();        assertTrue("Matching include", ruleSet.applies(file));    }    @Test    public void testIncludeExcludeMultipleRuleSetWithRuleChainApplies() throws PMDException {        File file = new File("C:\\myworkspace\\project\\some\\random\\package\\RandomClass.java");        Rule rule = new FooRule();        rule.setName("FooRule1");        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")                .addRule(rule)                .build();        RuleSet ruleSet2 = createRuleSetBuilder("RuleSet2")                .addRule(rule)                .build();        RuleSets ruleSets = new RuleSets(listOf(ruleSet1, ruleSet2));        // Two violations        RuleContext ctx = new RuleContext();        Report r = new Report();        ctx.setReport(r);        ctx.setSourceCodeFile(file);        ctx.setLanguageVersion(dummyLang.getDefaultVersion());        ruleSets.apply(makeCompilationUnits(), ctx);        assertEquals("Violations", 2, r.getViolations().size());        // One violation        ruleSet1 = createRuleSetBuilder("RuleSet1")                .withFileExclusions(Pattern.compile(".*/package/.*"))                .addRule(rule)                .build();        ruleSets = new RuleSets(listOf(ruleSet1, ruleSet2));        r = new Report();        ctx.setReport(r);        ruleSets.apply(makeCompilationUnits(), ctx);        assertEquals("Violations", 1, r.getViolations().size());    }    @Test    public void copyConstructorDeepCopies() {        Rule rule = new FooRule();        rule.setName("FooRule1");        RuleSet ruleSet1 = createRuleSetBuilder("RuleSet1")                .addRule(rule)                .build();        RuleSet ruleSet2 = new RuleSet(ruleSet1);        assertEquals(ruleSet1, ruleSet2);        assertNotSame(ruleSet1, ruleSet2);        assertEquals(rule, ruleSet2.getRuleByName("FooRule1"));        assertNotSame(rule, ruleSet2.getRuleByName("FooRule1"));    }    private void verifyRuleSet(RuleSet ruleset, int size, Set<RuleViolation> values) {        RuleContext context = new RuleContext();        Set<RuleViolation> reportedValues = new HashSet<>();        context.setReport(new Report());        new RuleSets(ruleset).apply(makeCompilationUnits(), context);        assertEquals("Invalid number of Violations Reported", size, context.getReport().getViolations().size());        for (RuleViolation violation : context.getReport().getViolations()) {            reportedValues.add(violation);            assertTrue("Unexpected Violation Returned: " + violation, values.contains(violation));        }        for (RuleViolation violation : values) {            assertTrue("Expected Violation not Returned: " + violation, reportedValues.contains(violation));        }    }    private List<Node> makeCompilationUnits() {        List<Node> nodes = new ArrayList<>();        DummyNode node = new DummyRoot();        node.setCoords(1, 1, 10, 1);        node.setImage("Foo");        nodes.add(node);        return nodes;    }    @Test    public void ruleExceptionShouldBeReported() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")                .addRule(new MockRule() {                    @Override                    public void apply(Node nodes, RuleContext ctx) {                        throw new RuntimeException("Test exception while applying rule");                    }                })                .build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(dummyLang.getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        ruleset.apply(makeCompilationUnits(), context);        List<ProcessingError> errors = context.getReport().getProcessingErrors();        assertTrue("Report should have processing errors", !errors.isEmpty());        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);    }    @Test(expected = RuntimeException.class)    public void ruleExceptionShouldBeThrownIfNotIgnored() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported")                .addRule(new MockRule() {                    @Override                    public void apply(Node target, RuleContext ctx) {                        throw new RuntimeException("Test exception while applying rule");                    }                })                .build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(dummyLang.getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeThrownIfNotIgnored"));        context.setIgnoreExceptions(false);        ruleset.apply(makeCompilationUnits(), context);    }    @Test    public void ruleExceptionShouldNotStopProcessingFile() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            @Override            public void apply(Node target, RuleContext ctx) {                throw new RuntimeException("Test exception while applying rule");            }        }).addRule(new MockRule() {            @Override            public void apply(Node target, RuleContext ctx) {                addViolationWithMessage(ctx, target, "Test violation of the second rule in the ruleset");            }        }).build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(dummyLang.getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName(), "ruleExceptionShouldBeReported.java"));        context.setIgnoreExceptions(true); // the default        ruleset.apply(makeCompilationUnits(), context);        List<ProcessingError> errors = context.getReport().getProcessingErrors();        assertFalse("Report should have processing errors", errors.isEmpty());        assertEquals("Errors expected", 1, errors.size());        ProcessingError processingError = errors.get(0);        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", processingError.getMsg());        assertTrue("Should be a RuntimeException", processingError.getError() instanceof RuntimeException);        assertEquals("Wrong filename in processing error",                "net.sourceforge.pmd.RuleSetTest/ruleExceptionShouldBeReported.java",                FilenameUtils.normalize(processingError.getFile(), true));        assertEquals("There should be a violation", 1, context.getReport().getViolations().size());    }    @Test    public void ruleExceptionShouldNotStopProcessingFileWithRuleChain() {        RuleSet ruleset = createRuleSetBuilder("ruleExceptionShouldBeReported").addRule(new MockRule() {            @Override            protected @NonNull RuleTargetSelector buildTargetSelector() {                return RuleTargetSelector.forXPathNames(setOf("dummyRootNode"));            }            @Override            public void apply(Node target, RuleContext ctx) {                throw new RuntimeException("Test exception while applying rule");            }        }).addRule(new MockRule() {            @Override            protected @NonNull RuleTargetSelector buildTargetSelector() {                return RuleTargetSelector.forXPathNames(setOf("dummyRootNode"));            }            @Override            public void apply(Node target, RuleContext ctx) {                addViolationWithMessage(ctx, target, "Test violation of the second rule in the ruleset");            }        }).build();        RuleContext context = new RuleContext();        context.setReport(new Report());        context.setLanguageVersion(dummyLang.getDefaultVersion());        context.setSourceCodeFile(new File(RuleSetTest.class.getName() + ".ruleExceptionShouldBeReported"));        context.setIgnoreExceptions(true); // the default        RuleSets rulesets = new RuleSets(ruleset);        rulesets.apply(makeCompilationUnits(), context);        List<ProcessingError> errors = context.getReport().getProcessingErrors();        assertEquals("Errors expected", 1, errors.size());        assertEquals("Wrong error message", "RuntimeException: Test exception while applying rule", errors.get(0).getMsg());        assertTrue("Should be a RuntimeException", errors.get(0).getError() instanceof RuntimeException);        assertEquals("There should be a violation", 1, context.getReport().getViolations().size());    }    class MockRule extends net.sourceforge.pmd.lang.rule.MockRule {        MockRule() {            super();            setLanguage(dummyLang);        }        MockRule(String name, String description, String message, String ruleSetName, RulePriority priority) {            super(name, description, message, ruleSetName, priority);            setLanguage(dummyLang);        }        MockRule(String name, String description, String message, String ruleSetName) {            super(name, description, message, ruleSetName);            setLanguage(dummyLang);        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.IOException;import java.io.StringWriter;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.renderers.XMLRenderer;public class ReportTest {    // Files are grouped together now.    @Test    public void testSortedReportFile() throws IOException {        Report r = new Report();        Node s = getNode(10, 5);        Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule1, "foo", s, rule1.getMessage()));        Node s1 = getNode(10, 5);        Rule rule2 = new MockRule("name", "desc", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule2, "bar", s1, rule2.getMessage()));        Renderer rend = new XMLRenderer();        String result = render(rend, r);        assertTrue("sort order wrong", result.indexOf("bar") < result.indexOf("foo"));    }    @Test    public void testSortedReportLine() throws IOException {        Report r = new Report();        Node node1 = getNode(20, 5); // line 20: after rule2 violation        Rule rule1 = new MockRule("rule1", "rule1", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule1, "foo1", node1, rule1.getMessage()));        Node node2 = getNode(10, 5); // line 10: before rule1 violation        Rule rule2 = new MockRule("rule2", "rule2", "msg", "rulesetname");        r.addRuleViolation(new ParametricRuleViolation<>(rule2, "foo1", node2, rule2.getMessage())); // same file!!        Renderer rend = new XMLRenderer();        String result = render(rend, r);        assertTrue("sort order wrong", result.indexOf("rule2") < result.indexOf("rule1"));    }    @Test    public void testListener() {        class MyListener implements ThreadSafeReportListener {            boolean hasViolation = false;            @Override            public void ruleViolationAdded(RuleViolation ruleViolation) {                hasViolation = true;            }        }        Report rpt = new Report();        MyListener listener = new MyListener();        rpt.addListener(listener);        Node s = getNode(5, 5);        Rule rule1 = new MockRule("name", "desc", "msg", "rulesetname");        rpt.addRuleViolation(new ParametricRuleViolation<>(rule1, "filename", s, rule1.getMessage()));        assertTrue(listener.hasViolation);    }    @Test    public void testIterator() {        Report r = new Report();        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Node node1 = getNode(5, 5, true);        r.addRuleViolation(new ParametricRuleViolation<>(rule, "", node1, rule.getMessage()));        Node node2 = getNode(5, 6, true);        r.addRuleViolation(new ParametricRuleViolation<>(rule, "", node2, rule.getMessage()));        assertEquals(2, r.getViolations().size());    }    private static Node getNode(int line, int column) {        DummyNode s = new DummyNode();        DummyNode parent = new DummyNode();        parent.setCoords(line, column, line, column + 1);        parent.addChild(s, 0);        s.setCoords(line, column, line, column + 1);        return s;    }    private static Node getNode(int line, int column, boolean nextLine) {        DummyNode s = (DummyNode) getNode(line, column);        if (nextLine) {            s.setCoords(line + 1, column + 4, line + 4, 1);        }        return s;    }    public static String render(Renderer renderer, Report report) throws IOException {        StringWriter writer = new StringWriter();        renderer.setWriter(writer);        renderer.start();        renderer.renderFileReport(report);        renderer.end();        return writer.toString();    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.io.StringReader;import java.util.Arrays;import java.util.List;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.contrib.java.lang.system.RestoreSystemProperties;import org.junit.rules.TestRule;import net.sourceforge.pmd.internal.SystemProps;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.Language;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.AbstractRule;public class SourceCodeProcessorTest {    @org.junit.Rule    public TestRule restoreSystemProperties = new RestoreSystemProperties();    private SourceCodeProcessor processor;    private StringReader sourceCode;    private RuleContext ctx;    private List<RuleSet> rulesets;    private LanguageVersion dummyThrows;    private LanguageVersion dummyDefault;    @Before    public void prepare() {        Language dummyLanguage = LanguageRegistry.findLanguageByTerseName(DummyLanguageModule.TERSE_NAME);        dummyDefault = dummyLanguage.getDefaultVersion();        dummyThrows = dummyLanguage.getVersion("1.9-throws");        processor = new SourceCodeProcessor(new PMDConfiguration());        sourceCode = new StringReader("test");        Rule rule = new RuleThatThrows();        rulesets = Arrays.asList(RuleSet.forSingleRule(rule));        ctx = new RuleContext();    }    @Test    public void inErrorRecoveryModeErrorsShouldBeLoggedByParser() {        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, "");        ctx.setLanguageVersion(dummyThrows);        Assert.assertThrows(PMDException.class, () -> {            processor.processSourceCode(sourceCode, new RuleSets(rulesets), ctx);        });        // the error is actually logged by PmdRunnable    }    @Test    public void inErrorRecoveryModeErrorsShouldBeLoggedByRule() throws Exception {        System.setProperty(SystemProps.PMD_ERROR_RECOVERY, "");        ctx.setLanguageVersion(dummyDefault);        processor.processSourceCode(sourceCode, new RuleSets(rulesets), ctx);        Assert.assertEquals(1, ctx.getReport().getProcessingErrors().size());        Assert.assertSame(AssertionError.class, ctx.getReport().getProcessingErrors().get(0).getError().getClass());    }    @Test    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByParser() {        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));        ctx.setLanguageVersion(dummyThrows);        Assert.assertThrows(AssertionError.class, () -> {            processor.processSourceCode(sourceCode, new RuleSets(rulesets), ctx);        });    }    @Test    public void withoutErrorRecoveryModeProcessingShouldBeAbortedByRule() {        Assert.assertNull(System.getProperty(SystemProps.PMD_ERROR_RECOVERY));        ctx.setLanguageVersion(dummyDefault);        Assert.assertThrows(AssertionError.class, () -> {            processor.processSourceCode(sourceCode, new RuleSets(rulesets), ctx);        });    }    private static class RuleThatThrows extends AbstractRule {        RuleThatThrows() {            Language dummyLanguage = LanguageRegistry.findLanguageByTerseName(DummyLanguageModule.TERSE_NAME);            setLanguage(dummyLanguage);        }        @Override        public void apply(Node target, RuleContext ctx) {            throw new AssertionError("test");        }    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertTrue;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.junit.LocaleRule;public class RuleSetFactoryDuplicatedRuleLoggingTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    @org.junit.Rule    public LocaleRule localeRule = LocaleRule.en();    @org.junit.Rule    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetLoader.class.getName());    @Test    public void duplicatedRuleReferenceShouldWarn() {        RuleSet ruleset = loadRuleSet("duplicatedRuleReference.xml");        assertEquals(1, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.MEDIUM, mockRule.getPriority());        assertTrue(logging.getLog().contains("The rule DummyBasicMockRule is referenced multiple times in \"Custom Rules\". "                + "Only the last rule configuration is used."));    }    @Test    public void duplicatedRuleReferenceWithOverrideShouldNotWarn() {        RuleSet ruleset = loadRuleSet("duplicatedRuleReferenceWithOverride.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    @Test    public void duplicatedRuleReferenceWithOverrideBeforeShouldNotWarn() {        RuleSet ruleset = loadRuleSet("duplicatedRuleReferenceWithOverrideBefore.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    @Test    public void multipleDuplicates() {        RuleSet ruleset = loadRuleSet("multipleDuplicates.xml");        assertEquals(2, ruleset.getRules().size());        Rule mockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertNotNull(mockRule);        assertEquals(RulePriority.MEDIUM_HIGH, mockRule.getPriority());        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().contains("The rule DummyBasicMockRule is referenced multiple times in \"Custom Rules\". "                + "Only the last rule configuration is used."));        assertTrue(logging.getLog().contains("The ruleset rulesets/dummy/basic.xml is referenced multiple times in \"Custom Rules\"."));    }    private RuleSet loadRuleSet(String ruleSetFilename) {        return new RuleSetLoader().loadFromResource("net/sourceforge/pmd/rulesets/duplicatedRuleLoggingTest/" + ruleSetFilename);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertSame;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.nio.charset.StandardCharsets;import java.util.Properties;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.cache.FileAnalysisCache;import net.sourceforge.pmd.cache.NoopAnalysisCache;import net.sourceforge.pmd.renderers.CSVRenderer;import net.sourceforge.pmd.renderers.Renderer;import net.sourceforge.pmd.util.ClasspathClassLoader;public class ConfigurationTest {    @Rule    public TemporaryFolder folder = new TemporaryFolder();    @Test    public void testSuppressMarker() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default suppress marker", PMD.SUPPRESS_MARKER, configuration.getSuppressMarker());        configuration.setSuppressMarker("CUSTOM_MARKER");        assertEquals("Changed suppress marker", "CUSTOM_MARKER", configuration.getSuppressMarker());    }    @Test    public void testThreads() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default threads", Runtime.getRuntime().availableProcessors(), configuration.getThreads());        configuration.setThreads(0);        assertEquals("Changed threads", 0, configuration.getThreads());    }    @Test    public void testClassLoader() throws IOException {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default ClassLoader", PMDConfiguration.class.getClassLoader(), configuration.getClassLoader());        configuration.prependClasspath("some.jar");        assertEquals("Prepended ClassLoader class", ClasspathClassLoader.class,                configuration.getClassLoader().getClass());        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        assertEquals("urls length", 1, urls.length);        assertTrue("url[0]", urls[0].toString().endsWith("/some.jar"));        assertEquals("parent classLoader", PMDConfiguration.class.getClassLoader(),                configuration.getClassLoader().getParent());        configuration.setClassLoader(null);        assertEquals("Revert to default ClassLoader", PMDConfiguration.class.getClassLoader(),                configuration.getClassLoader());    }    @Test    public void auxClasspathWithRelativeFileEmpty() throws IOException {        String relativeFilePath = "src/test/resources/net/sourceforge/pmd/cli/auxclasspath-empty.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        Assert.assertEquals(0, urls.length);    }    @Test    public void auxClasspathWithRelativeFileEmpty2() throws IOException {        String relativeFilePath = "./src/test/resources/net/sourceforge/pmd/cli/auxclasspath-empty.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        Assert.assertEquals(0, urls.length);    }    @Test    public void auxClasspathWithRelativeFile() throws IOException, URISyntaxException {        final String FILE_SCHEME = "file";        String currentWorkingDirectory = new File("").getAbsoluteFile().toURI().getPath();        String relativeFilePath = "src/test/resources/net/sourceforge/pmd/cli/auxclasspath.cp";        PMDConfiguration configuration = new PMDConfiguration();        configuration.prependClasspath("file:" + relativeFilePath);        URL[] urls = ((ClasspathClassLoader) configuration.getClassLoader()).getURLs();        URI[] uris = new URI[urls.length];        for (int i = 0; i < urls.length; i++) {            uris[i] = urls[i].toURI();        }        URI[] expectedUris = new URI[] {            new URI(FILE_SCHEME, null, currentWorkingDirectory + "lib1.jar", null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "other/directory/lib2.jar", null),            new URI(FILE_SCHEME, null, new File("/home/jondoe/libs/lib3.jar").getAbsoluteFile().toURI().getPath(), null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "classes", null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "classes2", null),            new URI(FILE_SCHEME, null, new File("/home/jondoe/classes").getAbsoluteFile().toURI().getPath(), null),            new URI(FILE_SCHEME, null, currentWorkingDirectory, null),            new URI(FILE_SCHEME, null, currentWorkingDirectory + "relative source dir/bar", null),        };        Assert.assertArrayEquals(expectedUris, uris);    }    @Test    public void testRuleSets() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default RuleSets", null, configuration.getRuleSets());        configuration.setRuleSets("/rulesets/basic.xml");        assertEquals("Changed RuleSets", "/rulesets/basic.xml", configuration.getRuleSets());    }    @Test    public void testMinimumPriority() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default minimum priority", RulePriority.LOW, configuration.getMinimumPriority());        configuration.setMinimumPriority(RulePriority.HIGH);        assertEquals("Changed minimum priority", RulePriority.HIGH, configuration.getMinimumPriority());    }    @Test    public void testSourceEncoding() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default source encoding", System.getProperty("file.encoding"), configuration.getSourceEncoding().name());        configuration.setSourceEncoding(StandardCharsets.UTF_16LE.name());        assertEquals("Changed source encoding", StandardCharsets.UTF_16LE, configuration.getSourceEncoding());    }    @Test    public void testInputPaths() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default input paths", null, configuration.getInputPaths());        configuration.setInputPaths("a,b,c");        assertEquals("Changed input paths", "a,b,c", configuration.getInputPaths());    }    @Test    public void testReportShortNames() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report short names", false, configuration.isReportShortNames());        configuration.setReportShortNames(true);        assertEquals("Changed report short names", true, configuration.isReportShortNames());    }    @Test    public void testReportFormat() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report format", null, configuration.getReportFormat());        configuration.setReportFormat("csv");        assertEquals("Changed report format", "csv", configuration.getReportFormat());    }    @Test    public void testCreateRenderer() {        PMDConfiguration configuration = new PMDConfiguration();        configuration.setReportFormat("csv");        Renderer renderer = configuration.createRenderer();        assertEquals("Renderer class", CSVRenderer.class, renderer.getClass());        assertEquals("Default renderer show suppressed violations", false, renderer.isShowSuppressedViolations());        configuration.setShowSuppressedViolations(true);        renderer = configuration.createRenderer();        assertEquals("Renderer class", CSVRenderer.class, renderer.getClass());        assertEquals("Changed renderer show suppressed violations", true, renderer.isShowSuppressedViolations());    }    @Test    public void testReportFile() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report file", null, configuration.getReportFile());        configuration.setReportFile("somefile");        assertEquals("Changed report file", "somefile", configuration.getReportFile());    }    @Test    public void testShowSuppressedViolations() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default show suppressed violations", false, configuration.isShowSuppressedViolations());        configuration.setShowSuppressedViolations(true);        assertEquals("Changed show suppressed violations", true, configuration.isShowSuppressedViolations());    }    @Test    public void testReportProperties() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default report properties size", 0, configuration.getReportProperties().size());        configuration.getReportProperties().put("key", "value");        assertEquals("Changed report properties size", 1, configuration.getReportProperties().size());        assertEquals("Changed report properties value", "value", configuration.getReportProperties().get("key"));        configuration.setReportProperties(new Properties());        assertEquals("Replaced report properties size", 0, configuration.getReportProperties().size());    }    @Test    public void testDebug() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default debug", false, configuration.isDebug());        configuration.setDebug(true);        assertEquals("Changed debug", true, configuration.isDebug());    }    @Test    public void testStressTest() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default stress test", false, configuration.isStressTest());        configuration.setStressTest(true);        assertEquals("Changed stress test", true, configuration.isStressTest());    }    @Test    public void testBenchmark() {        PMDConfiguration configuration = new PMDConfiguration();        assertEquals("Default benchmark", false, configuration.isBenchmark());        configuration.setBenchmark(true);        assertEquals("Changed benchmark", true, configuration.isBenchmark());    }    @Test    public void testAnalysisCache() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        assertNotNull("Default cache is null", configuration.getAnalysisCache());        assertTrue("Default cache is not a noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setAnalysisCache(null);        assertNotNull("Default cache was set to null", configuration.getAnalysisCache());        final File cacheFile = folder.newFile();        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertSame("Configured cache not stored", analysisCache, configuration.getAnalysisCache());    }    @Test    public void testAnalysisCacheLocation() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        configuration.setAnalysisCacheLocation(null);        assertNotNull("Null cache location accepted", configuration.getAnalysisCache());        assertTrue("Null cache location accepted", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setAnalysisCacheLocation("pmd.cache");        assertNotNull("Not null cache location produces null cache", configuration.getAnalysisCache());        assertTrue("File cache location doesn't produce a file cache",                configuration.getAnalysisCache() instanceof FileAnalysisCache);    }    @Test    public void testIgnoreIncrementalAnalysis() throws IOException {        final PMDConfiguration configuration = new PMDConfiguration();        // set dummy cache location        final File cacheFile = folder.newFile();        final FileAnalysisCache analysisCache = new FileAnalysisCache(cacheFile);        configuration.setAnalysisCache(analysisCache);        assertNotNull("Null cache location accepted", configuration.getAnalysisCache());        assertFalse("Non null cache location, cache should not be noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);        configuration.setIgnoreIncrementalAnalysis(true);        assertTrue("Ignoring incremental analysis should turn the cache into a noop", configuration.getAnalysisCache() instanceof NoopAnalysisCache);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.Matchers.containsString;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertFalse;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNotSame;import static org.junit.Assert.assertNull;import static org.junit.Assert.assertThrows;import static org.junit.Assert.assertTrue;import java.io.InputStream;import java.util.Arrays;import java.util.HashSet;import java.util.Set;import org.apache.commons.lang3.StringUtils;import org.junit.Assert;import org.junit.Test;import org.junit.rules.ExpectedException;import net.sourceforge.pmd.junit.JavaUtilLoggingRule;import net.sourceforge.pmd.junit.LocaleRule;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.RuleReference;import net.sourceforge.pmd.properties.PropertyDescriptor;import net.sourceforge.pmd.util.ResourceLoader;public class RuleSetFactoryTest {    @org.junit.Rule    public ExpectedException ex = ExpectedException.none();    @org.junit.Rule    public LocaleRule localeRule = LocaleRule.en();    @org.junit.Rule    public JavaUtilLoggingRule logging = new JavaUtilLoggingRule(RuleSetLoader.class.getName());    @Test    public void testRuleSetFileName() {        RuleSet rs = new RuleSetLoader().loadFromString("dummyRuleset.xml", EMPTY_RULESET);        assertEquals("dummyRuleset.xml", rs.getFileName());        rs = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/TestRuleset1.xml");        assertEquals("wrong RuleSet file name", rs.getFileName(), "net/sourceforge/pmd/TestRuleset1.xml");    }    @Test    public void testRefs() {        RuleSet rs = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/TestRuleset1.xml");        assertNotNull(rs.getRuleByName("TestRuleRef"));    }    @Test    public void testExtendedReferences() throws Exception {        InputStream in = new ResourceLoader().loadClassPathResourceAsStream("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        assertNotNull("Test ruleset not found - can't continue with test!", in);        in.close();        RuleSet rs = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/rulesets/reference-ruleset.xml");        // added by referencing a complete ruleset (TestRuleset1.xml)        assertNotNull(rs.getRuleByName("MockRule1"));        assertNotNull(rs.getRuleByName("MockRule2"));        assertNotNull(rs.getRuleByName("MockRule3"));        assertNotNull(rs.getRuleByName("TestRuleRef"));        // added by specific reference        assertNotNull(rs.getRuleByName("TestRule"));        // this is from TestRuleset2.xml, but not referenced        assertNull(rs.getRuleByName("TestRule2Ruleset2"));        Rule mockRule3 = rs.getRuleByName("MockRule3");        assertEquals("Overridden message", mockRule3.getMessage());        assertEquals(2, mockRule3.getPriority().getPriority());        Rule mockRule2 = rs.getRuleByName("MockRule2");        assertEquals("Just combine them!", mockRule2.getMessage());        // assert that MockRule2 is only once added to the ruleset, so that it        // really        // overwrites the configuration inherited from TestRuleset1.xml        assertNotNull(rs.getRuleByName("MockRule2"));        Rule mockRule1 = rs.getRuleByName("MockRule1");        assertNotNull(mockRule1);        PropertyDescriptor<?> prop = mockRule1.getPropertyDescriptor("testIntProperty");        Object property = mockRule1.getProperty(prop);        assertEquals("5", String.valueOf(property));        // included from TestRuleset3.xml        assertNotNull(rs.getRuleByName("Ruleset3Rule2"));        // excluded from TestRuleset3.xml        assertNull(rs.getRuleByName("Ruleset3Rule1"));        // overridden to 5        Rule ruleset4Rule1 = rs.getRuleByName("Ruleset4Rule1");        assertNotNull(ruleset4Rule1);        assertEquals(5, ruleset4Rule1.getPriority().getPriority());        assertNotNull(rs.getRuleByName("Ruleset4Rule1"));        // priority overridden for whole TestRuleset4 group        Rule ruleset4Rule2 = rs.getRuleByName("Ruleset4Rule2");        assertNotNull(ruleset4Rule2);        assertEquals(2, ruleset4Rule2.getPriority().getPriority());    }    @Test    public void testRuleSetNotFound() {        assertThrows(RuleSetLoadException.class, () -> new RuleSetLoader().loadFromResource("fooooo"));    }    @Test    public void testCreateEmptyRuleSet() {        RuleSet rs = loadRuleSet(EMPTY_RULESET);        assertEquals("test", rs.getName());        assertEquals(0, rs.size());    }    @Test    public void testSingleRule() {        RuleSet rs = loadRuleSet(SINGLE_RULE);        assertEquals(1, rs.size());        Rule r = rs.getRules().iterator().next();        assertEquals("MockRuleName", r.getName());        assertEquals("net.sourceforge.pmd.lang.rule.MockRule", r.getRuleClass());        assertEquals("avoid the mock rule", r.getMessage());    }    @Test    public void testMultipleRules() {        RuleSet rs = loadRuleSet(MULTIPLE_RULES);        assertEquals(2, rs.size());        Set<String> expected = new HashSet<>();        expected.add("MockRuleName1");        expected.add("MockRuleName2");        for (Rule rule : rs.getRules()) {            assertTrue(expected.contains(rule.getName()));        }    }    @Test    public void testSingleRuleWithPriority() {        assertEquals(RulePriority.MEDIUM, loadFirstRule(PRIORITY).getPriority());    }    @Test    public void testProps() {        Rule r = loadFirstRule(PROPERTIES);        assertEquals("bar", r.getProperty(r.getPropertyDescriptor("fooString")));        assertEquals(3, r.getProperty(r.getPropertyDescriptor("fooInt")));        assertEquals(true, r.getProperty(r.getPropertyDescriptor("fooBoolean")));        assertEquals(3.0d, (Double) r.getProperty(r.getPropertyDescriptor("fooDouble")), 0.05);        assertNull(r.getPropertyDescriptor("BuggleFish"));        assertNotSame(r.getDescription().indexOf("testdesc2"), -1);    }    @Test    public void testStringMultiPropertyDefaultDelimiter() {        Rule r = loadFirstRule(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ruleset name=\"the ruleset\">\n  <description>Desc</description>\n"                + "     <rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s instead.\" \n"                + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                + " value=\"com.aptsssss|com.abc\" \ntype=\"List[String]\" "                + "description=\"valid packages\"/>\n         </properties></rule></ruleset>");        Object propValue = r.getProperty(r.getPropertyDescriptor("packageRegEx"));        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), propValue);    }    @Test    public void testStringMultiPropertyDelimiter() {        Rule r = loadFirstRule("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n "                                   + " <description>ruleset desc</description>\n     "                                   + "<rule name=\"myRule\" message=\"Do not place to this package. Move to \n{0} package/s"                                   + " instead.\" \n"                                   + "class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">\n"                                   + "         <description>Please move your class to the right folder(rest \nfolder)</description>\n"                                   + "         <priority>2</priority>\n         <properties>\n             <property name=\"packageRegEx\""                                   + " value=\"com.aptsssss,com.abc\" \ntype=\"List[String]\" delimiter=\",\" "                                   + "description=\"valid packages\"/>\n"                                   + "         </properties></rule>" + "</ruleset>");        Object propValue = r.getProperty(r.getPropertyDescriptor("packageRegEx"));        assertEquals(Arrays.asList("com.aptsssss", "com.abc"), propValue);    }    @Test    public void testRuleSetWithDeprecatedRule() {        RuleSet rs = loadRuleSet("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"ruleset\">\n"                                     + "  <description>ruleset desc</description>\n"                                     + "     <rule deprecated=\"true\" ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\"/>"                                     + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("DummyBasicMockRule");        assertNotNull(rule);    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole, we shouldn't get a deprecation warning. The deprecated     * rule reference should be ignored, so at the end, we only have the new rule name in the ruleset.     * This is because the deprecated reference points to a rule in the same ruleset.     *     */    @Test    public void testRuleSetWithDeprecatedButRenamedRule() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                + "         <description>d</description>\n" + "         <priority>2</priority>\n" + "     </rule>"                + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("NewName");        assertNotNull(rule);        assertNull(rs.getRuleByName("OldName"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a category (built-in) ruleset, which contains a rule, that has been renamed.     * This means: a rule definition for "NewName" and a rule reference "OldName", that is deprecated     * and exists for backwards compatibility.     *     * <p>When loading this ruleset at a whole for generating the documentation, we should still     * include the deprecated rule reference, so that we can create a nice documentation.     *     */    @Test    public void testRuleSetWithDeprecatedRenamedRuleForDoc() {        RuleSetLoader loader = new RuleSetLoader().includeDeprecatedRuleReferences(true);        RuleSet rs = loader.loadFromString("",                                           "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                                               + "  <description>ruleset desc</description>\n"                                               + "     <rule deprecated=\"true\" ref=\"NewName\" name=\"OldName\"/>"                                               + "     <rule name=\"NewName\" message=\"m\" class=\"net.sourceforge.pmd.lang.rule.XPathRule\" language=\"dummy\">"                                               + "         <description>d</description>\n"                                               + "         <priority>2</priority>\n"                                               + "     </rule>"                                               + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("NewName"));        assertNotNull(rs.getRuleByName("OldName"));    }    /**     * This is an example of a custom user ruleset, that references a rule, that has been renamed.     * The user should get a deprecation warning.     */    @Test    public void testRuleSetReferencesADeprecatedRenamedRule() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule\"/>" + "</ruleset>");        assertEquals(1, rs.getRules().size());        Rule rule = rs.getRuleByName("OldNameOfDummyBasicMockRule");        assertNotNull(rule);        assertEquals(1,                     StringUtils.countMatches(logging.getLog(),                                              "WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic.xml/OldNameOfDummyBasicMockRule."));    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Although the referenced ruleset contains     * a deprecated rule, there should be no warning about it, because all deprecated rules are ignored,     * if a whole ruleset is referenced.     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     */    @Test    public void testRuleSetReferencesRulesetWithADeprecatedRenamedRule() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"/>" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule. The deprecated     * rule is excluded.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset. Since the deprecated rule is excluded,     * there should be no deprecation warning at all, although the deprecated ruleset would have been     * excluded by default (without explictly excluding it).     *     * <p>     * In the end, we should get all non-deprecated rules of the referenced ruleset.     *     */    @Test    public void testRuleSetReferencesRulesetWithAExcludedDeprecatedRule() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"DeprecatedRule\"/></rule>"                + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertTrue(logging.getLog().isEmpty());    }    /**     * This is an example of a custom user ruleset, that references a complete (e.g. category) ruleset,     * that contains a renamed (deprecated) rule and two normal rules and one deprecated rule.     * There is a exclusion of a rule, that no longer exists.     *     * <p>     * The user should not get a deprecation warning for the whole ruleset,     * since not all rules are deprecated in the referenced ruleset.     * Since the rule to be excluded doesn't exist, there should be a warning about that.     *     */    @Test    public void testRuleSetReferencesRulesetWithAExcludedNonExistingRule() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic.xml\"><exclude name=\"NonExistingRule\"/></rule>"                + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertEquals(0,                     StringUtils.countMatches(logging.getLog(),                                              "WARNING: Discontinue using Rule rulesets/dummy/basic.xml/DeprecatedRule as it is scheduled for removal from PMD."));        assertEquals(1,                StringUtils.countMatches(logging.getLog(),                    "WARNING: Unable to exclude rules [NonExistingRule] from ruleset reference rulesets/dummy/basic.xml; perhaps the rule name is misspelled or the rule doesn't exist anymore?"));    }    /**     * When a custom ruleset references a ruleset that only contains deprecated rules, then this ruleset itself is     * considered deprecated and the user should get a deprecation warning for the ruleset.     */    @Test    public void testRuleSetReferencesDeprecatedRuleset() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/deprecated.xml\" />" + "</ruleset>");        assertEquals(2, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasicMockRule"));        assertNotNull(rs.getRuleByName("SampleXPathRule"));        assertEquals(1,                     StringUtils.countMatches(logging.getLog(),                                              "WARNING: The RuleSet rulesets/dummy/deprecated.xml has been deprecated and will be removed in PMD"));    }    /**     * When a custom ruleset references a ruleset that contains both rules and rule references, that are left     * for backwards compatibility, because the rules have been moved to a different ruleset, then there should be     * no warning about deprecation - since the deprecated rules are not used.     */    @Test    public void testRuleSetReferencesRulesetWithAMovedRule() {        RuleSet rs = loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset name=\"test\">\n"                + "  <description>ruleset desc</description>\n"                + "     <rule ref=\"rulesets/dummy/basic2.xml\" />" + "</ruleset>");        assertEquals(1, rs.getRules().size());        assertNotNull(rs.getRuleByName("DummyBasic2MockRule"));        assertEquals(0,                     StringUtils.countMatches(logging.getLog(),                                              "WARNING: Use Rule name rulesets/dummy/basic.xml/DummyBasicMockRule instead of the deprecated Rule name rulesets/dummy/basic2.xml/DummyBasicMockRule. PMD"));    }    @Test    @SuppressWarnings("unchecked")    public void testXPath() {        Rule r = loadFirstRule(XPATH);        PropertyDescriptor<String> xpathProperty = (PropertyDescriptor<String>) r.getPropertyDescriptor("xpath");        assertNotNull("xpath property descriptor", xpathProperty);        assertNotSame(r.getProperty(xpathProperty).indexOf(" //Block "), -1);    }    @Test    public void testExternalReferenceOverride() {        Rule r = loadFirstRule(REF_OVERRIDE);        assertEquals("TestNameOverride", r.getName());        assertEquals("Test message override", r.getMessage());        assertEquals("Test description override", r.getDescription());        assertEquals("Test that both example are stored", 2, r.getExamples().size());        assertEquals("Test example override", r.getExamples().get(1));        assertEquals(RulePriority.MEDIUM, r.getPriority());        PropertyDescriptor<?> test2Descriptor = r.getPropertyDescriptor("test2");        assertNotNull("test2 descriptor", test2Descriptor);        assertEquals("override2", r.getProperty(test2Descriptor));        PropertyDescriptor<?> test3Descriptor = r.getPropertyDescriptor("test3");        assertNotNull("test3 descriptor", test3Descriptor);        assertEquals("override3", r.getProperty(test3Descriptor));    }    @Test    public void testExternalReferenceOverrideNonExistent() {        RuleSetLoadException ex = assertCannotParse(REF_OVERRIDE_NONEXISTENT);        assertThat(ex.getCause().getMessage(), containsString("Cannot set non-existent property 'test4' on Rule TestNameOverride"));    }    private RuleSetLoadException assertCannotParse(String xmlContent) {        return assertThrows(RuleSetLoadException.class, () -> loadFirstRule(xmlContent));    }    @Test    public void testReferenceInternalToInternal() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull("Could not find Rule MockRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull("Could not find Rule MockRuleNameRef", ruleRef);    }    @Test    public void testReferenceInternalToInternalChain() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_INTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("MockRuleName");        assertNotNull("Could not find Rule MockRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("MockRuleNameRef");        assertNotNull("Could not find Rule MockRuleNameRef", ruleRef);        Rule ruleRefRef = ruleSet.getRuleByName("MockRuleNameRefRef");        assertNotNull("Could not find Rule MockRuleNameRefRef", ruleRefRef);    }    @Test    public void testReferenceInternalToExternal() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull("Could not find Rule ExternalRefRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRef", ruleRef);    }    @Test    public void testReferenceInternalToExternalChain() {        RuleSet ruleSet = loadRuleSet(REF_INTERNAL_TO_EXTERNAL_CHAIN);        Rule rule = ruleSet.getRuleByName("ExternalRefRuleName");        assertNotNull("Could not find Rule ExternalRefRuleName", rule);        Rule ruleRef = ruleSet.getRuleByName("ExternalRefRuleNameRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRef", ruleRef);        Rule ruleRefRef = ruleSet.getRuleByName("ExternalRefRuleNameRefRef");        assertNotNull("Could not find Rule ExternalRefRuleNameRefRef", ruleRefRef);    }    @Test    public void testReferencePriority() {        RuleSetLoader config = new RuleSetLoader().warnDeprecated(false).enableCompatibility(true);        RuleSetLoader rsf = config.filterAbovePriority(RulePriority.LOW);        RuleSet ruleSet = rsf.loadFromString("", REF_INTERNAL_TO_INTERNAL_CHAIN);        assertEquals("Number of Rules", 3, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleName"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.MEDIUM_HIGH);        ruleSet = rsf.loadFromString("", REF_INTERNAL_TO_INTERNAL_CHAIN);        assertEquals("Number of Rules", 2, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.HIGH);        ruleSet = rsf.loadFromString("", REF_INTERNAL_TO_INTERNAL_CHAIN);        assertEquals("Number of Rules", 1, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("MockRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.LOW);        ruleSet = rsf.loadFromString("", REF_INTERNAL_TO_EXTERNAL_CHAIN);        assertEquals("Number of Rules", 3, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleName"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.MEDIUM_HIGH);        ruleSet = rsf.loadFromString("", REF_INTERNAL_TO_EXTERNAL_CHAIN);        assertEquals("Number of Rules", 2, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRef"));        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));        rsf = config.filterAbovePriority(RulePriority.HIGH);        ruleSet = rsf.loadFromString("", REF_INTERNAL_TO_EXTERNAL_CHAIN);        assertEquals("Number of Rules", 1, ruleSet.getRules().size());        assertNotNull(ruleSet.getRuleByName("ExternalRefRuleNameRefRef"));    }    @Test    public void testOverridePriorityLoadWithMinimum() {        RuleSetLoader rsf = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_LOW).warnDeprecated(true).enableCompatibility(true);        RuleSet ruleset = rsf.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        // only one rule should remain, since we filter out the other rule by minimum priority        assertEquals("Number of Rules", 1, ruleset.getRules().size());        // Priority is overridden and applied, rule is missing        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));        // now, load with default minimum priority        rsf = new RuleSetLoader();        ruleset = rsf.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority.xml");        assertEquals("Number of Rules", 2, ruleset.getRules().size());        Rule dummyBasicMockRule = ruleset.getRuleByName("DummyBasicMockRule");        assertEquals("Wrong Priority", RulePriority.LOW, dummyBasicMockRule.getPriority());    }    @Test    public void testExcludeWithMinimumPriority() {        RuleSetLoader rsf = new RuleSetLoader().filterAbovePriority(RulePriority.HIGH);        RuleSet ruleset = rsf.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // no rules should be loaded        assertEquals("Number of Rules", 0, ruleset.getRules().size());        // now, load with default minimum priority        rsf = new RuleSetLoader().filterAbovePriority(RulePriority.LOW);        ruleset = rsf.loadFromResource("net/sourceforge/pmd/rulesets/ruleset-minimum-priority-exclusion.xml");        // only one rule, we have excluded one...        assertEquals("Number of Rules", 1, ruleset.getRules().size());        // rule is excluded        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        // this is the remaining rule        assertNotNull(ruleset.getRuleByName("SampleXPathRule"));    }    @Test    public void testOverrideMessage() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test    public void testOverrideMessageOneElem() {        Rule r = loadFirstRule(REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM);        assertEquals("TestMessageOverride", r.getMessage());    }    @Test    public void testIncorrectExternalRef() {        assertCannotParse(REF_MISSPELLED_XREF);    }    @Test    public void testSetPriority() {        RuleSetLoader rsf = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_HIGH).warnDeprecated(false);        assertEquals(0, rsf.loadFromString("", SINGLE_RULE).size());        rsf = new RuleSetLoader().filterAbovePriority(RulePriority.MEDIUM_LOW).warnDeprecated(false);        assertEquals(1, rsf.loadFromString("", SINGLE_RULE).size());    }    @Test    public void testLanguage() {        Rule r = loadFirstRule(LANGUAGE);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME), r.getLanguage());    }    @Test    public void testIncorrectLanguage() {        assertCannotParse(INCORRECT_LANGUAGE);    }    @Test    public void testMinimumLanguageVersion() {        Rule r = loadFirstRule(MINIMUM_LANGUAGE_VERSION);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.4"),                     r.getMinimumLanguageVersion());    }    @Test    public void testIncorrectMinimumLanguageVersion() {        RuleSetLoadException ex = assertCannotParse(INCORRECT_MINIMUM_LANGUAGE_VERSION);        assertThat(ex.getCause().getMessage(), containsString("1.0, 1.1, 1.2")); // and not "dummy 1.0, dummy 1.1, ..."    }    @Test    public void testIncorrectMinimumLanguageVersionWithLanguageSetInJava() {        assertCannotParse("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                              + "<ruleset name=\"TODO\">\n"                              + "    <description>TODO</description>\n"                              + "\n"                              + "    <rule name=\"TODO\"\n"                              + "          message=\"TODO\"\n"                              + "          class=\"net.sourceforge.pmd.util.FooRuleWithLanguageSetInJava\"\n"                              + "          minimumLanguageVersion=\"12\">\n"                              + "        <description>TODO</description>\n"                              + "        <priority>2</priority>\n"                              + "    </rule>\n"                        + "\n"                        + "</ruleset>");    }    @Test    public void testMaximumLanguageVersion() {        Rule r = loadFirstRule(MAXIMUM_LANGUAGE_VERSION);        assertEquals(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getVersion("1.7"),                     r.getMaximumLanguageVersion());    }    @Test    public void testIncorrectMaximumLanguageVersion() {        RuleSetLoadException ex = assertCannotParse(INCORRECT_MAXIMUM_LANGUAGE_VERSION);        assertThat(ex.getCause().getMessage(), containsString("1.0, 1.1, 1.2")); // and not "dummy 1.0, dummy 1.1, ..."    }    @Test    public void testInvertedMinimumMaximumLanguageVersions() {        assertCannotParse(INCORRECT_MAXIMUM_LANGUAGE_VERSION);    }    @Test    public void testDirectDeprecatedRule() {        Rule r = loadFirstRule(DIRECT_DEPRECATED_RULE);        assertNotNull("Direct Deprecated Rule", r);        assertTrue(r.isDeprecated());    }    @Test    public void testReferenceToDeprecatedRule() {        Rule r = loadFirstRule(REFERENCE_TO_DEPRECATED_RULE);        assertNotNull("Reference to Deprecated Rule", r);        assertTrue("Rule Reference", r instanceof RuleReference);        assertFalse("Not deprecated", r.isDeprecated());        assertTrue("Original Rule Deprecated", ((RuleReference) r).getRule().isDeprecated());        assertEquals("Rule name", r.getName(), DEPRECATED_RULE_NAME);    }    @Test    public void testRuleSetReferenceWithDeprecatedRule() {        RuleSet ruleSet = loadRuleSet(REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE);        assertNotNull("RuleSet", ruleSet);        assertFalse("RuleSet empty", ruleSet.getRules().isEmpty());        // No deprecated Rules should be loaded when loading an entire RuleSet        // by reference - unless it contains only deprecated rules - then all rules would be added        Rule r = ruleSet.getRuleByName(DEPRECATED_RULE_NAME);        assertNull("Deprecated Rule Reference", r);        for (Rule rule : ruleSet.getRules()) {            assertFalse("Rule not deprecated", rule.isDeprecated());        }    }    @Test    public void testDeprecatedRuleSetReference() {        RuleSet ruleSet = new RuleSetLoader().loadFromResource("net/sourceforge/pmd/rulesets/ruleset-deprecated.xml");        assertEquals(2, ruleSet.getRules().size());    }    @Test    public void testExternalReferences() {        RuleSet rs = loadRuleSet(EXTERNAL_REFERENCE_RULE_SET);        assertEquals(1, rs.size());        assertEquals(MockRule.class.getName(), rs.getRuleByName("MockRule").getRuleClass());    }    @Test    public void testIncludeExcludePatterns() {        RuleSet ruleSet = loadRuleSet(INCLUDE_EXCLUDE_RULESET);        assertNotNull("Include patterns", ruleSet.getFileInclusions());        assertEquals("Include patterns size", 2, ruleSet.getFileInclusions().size());        assertEquals("Include pattern #1", "include1", ruleSet.getFileInclusions().get(0).pattern());        assertEquals("Include pattern #2", "include2", ruleSet.getFileInclusions().get(1).pattern());        assertNotNull("Exclude patterns", ruleSet.getFileExclusions());        assertEquals("Exclude patterns size", 3, ruleSet.getFileExclusions().size());        assertEquals("Exclude pattern #1", "exclude1", ruleSet.getFileExclusions().get(0).pattern());        assertEquals("Exclude pattern #2", "exclude2", ruleSet.getFileExclusions().get(1).pattern());        assertEquals("Exclude pattern #3", "exclude3", ruleSet.getFileExclusions().get(2).pattern());    }    /**     * Rule reference can't be resolved - ref is used instead of class and the     * class is old (pmd 4.3 and not pmd 5).     */    @Test    public void testBug1202() {        Assert.assertThrows(            RuleSetLoadException.class,            () -> new RuleSetLoader().loadFromString("", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "<ruleset>\n"                + "  <rule ref=\"net.sourceforge.pmd.rules.XPathRule\">\n" + "    <priority>1</priority>\n"                + "    <properties>\n" + "      <property name=\"xpath\" value=\"//TypeDeclaration\" />\n"                + "      <property name=\"message\" value=\"Foo\" />\n" + "    </properties>\n" + "  </rule>\n"                + "</ruleset>\n")        );    }    /**     * See https://sourceforge.net/p/pmd/bugs/1225/     */    @Test    public void testEmptyRuleSetFile() {        RuleSet ruleset = new RuleSetLoader().loadFromString("", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "\n"            + "<ruleset name=\"Custom ruleset\" xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"            + "    xmlns:xsi=\"http:www.w3.org/2001/XMLSchema-instance\"\n"            + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"            + "    <description>PMD Ruleset.</description>\n" + "\n"            + "    <exclude-pattern>.*Test.*</exclude-pattern>\n" + "\n" + "</ruleset>\n");        assertEquals(0, ruleset.getRules().size());    }    /**     * See https://github.com/pmd/pmd/issues/782     * Empty ruleset should be interpreted as deprecated.     */    @Test    public void testEmptyRuleSetReferencedShouldNotBeDeprecated() {        RuleSet ruleset = new RuleSetLoader().loadFromString("", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + "\n"            + "<ruleset name=\"Custom ruleset\" xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"            + "    xmlns:xsi=\"http:www.w3.org/2001/XMLSchema-instance\"\n"            + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"            + "    <description>Ruleset which references a empty ruleset</description>\n" + "\n"            + "    <rule ref=\"rulesets/dummy/empty-ruleset.xml\" />\n"            + "</ruleset>\n");        assertEquals(0, ruleset.getRules().size());        assertTrue(logging.getLog().isEmpty());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     */    @Test    public void testWrongRuleNameReferenced() {        assertCannotParse("<?xml version=\"1.0\"?>\n"                              + "<ruleset name=\"Custom ruleset for tests\"\n"                              + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                              + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                              + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                              + "  <description>Custom ruleset for tests</description>\n"                              + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/ThisRuleDoesNotExist\"/>\n"                              + "</ruleset>\n");    }    /**     * Unit test for #1312 see https://sourceforge.net/p/pmd/bugs/1312/     *     */    @Test    public void testRuleReferenceWithNameOverridden() {        RuleSet rs = loadRuleSet("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"                                     + "<ruleset xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                     + "         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                     + "         name=\"pmd-eclipse\"\n"                                     + "         xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                     + "   <description>PMD Plugin preferences rule set</description>\n"                                     + "<rule name=\"OverriddenDummyBasicMockRule\"\n"                                     + "    ref=\"rulesets/dummy/basic.xml/DummyBasicMockRule\">\n" + "</rule>\n" + "\n"                                     + "</ruleset>");        Rule r = rs.getRules().iterator().next();        assertEquals("OverriddenDummyBasicMockRule", r.getName());        RuleReference ruleRef = (RuleReference) r;        assertEquals("DummyBasicMockRule", ruleRef.getRule().getName());    }    /**     * See https://sourceforge.net/p/pmd/bugs/1231/     *     * <p>See https://github.com/pmd/pmd/issues/1978 - with that, it should not be an error anymore.     *     */    @Test    public void testWrongRuleNameExcluded() {        RuleSet ruleset = loadRuleSet("<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                                          + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                          + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                          + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                          + "  <description>Custom ruleset for tests</description>\n"                                          + "  <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml\">\n"                                          + "    <exclude name=\"ThisRuleDoesNotExist\"/>\n" + "  </rule>\n"                                          + "</ruleset>\n");        assertEquals(4, ruleset.getRules().size());    }    /**     * This unit test manifests the current behavior - which might change in the     * future. See #1537.     *     * Currently, if a ruleset is imported twice, the excludes of the first     * import are ignored. Duplicated rules are silently ignored.     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1537/">#1537 Implement     *      strict ruleset parsing</a>     * @see <a href=     *      "http://stackoverflow.com/questions/40299075/custom-pmd-ruleset-not-working">stackoverflow     *      - custom ruleset not working</a>     */    @Test    public void testExcludeAndImportTwice() {        RuleSet ruleset = loadRuleSet("<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                                          + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                          + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                          + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                          + "  <description>Custom ruleset for tests</description>\n"                                          + "  <rule ref=\"rulesets/dummy/basic.xml\">\n"                                          + "    <exclude name=\"DummyBasicMockRule\"/>\n"                                          + "  </rule>\n" + "</ruleset>\n");        assertNull(ruleset.getRuleByName("DummyBasicMockRule"));        RuleSet ruleset2 = loadRuleSet("<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                                           + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                           + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                           + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                           + "  <description>Custom ruleset for tests</description>\n"                                           + "  <rule ref=\"rulesets/dummy/basic.xml\">\n"                                           + "    <exclude name=\"DummyBasicMockRule\"/>\n"                                           + "  </rule>\n" + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                                           + "</ruleset>\n");        assertNotNull(ruleset2.getRuleByName("DummyBasicMockRule"));        RuleSet ruleset3 = loadRuleSet("<?xml version=\"1.0\"?>\n" + "<ruleset name=\"Custom ruleset for tests\"\n"                                           + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                                           + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                                           + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                                           + "  <description>Custom ruleset for tests</description>\n"                                           + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                                           + "  <rule ref=\"rulesets/dummy/basic.xml\">\n"                                           + "    <exclude name=\"DummyBasicMockRule\"/>\n" + "  </rule>\n"                                           + "</ruleset>\n");        assertNotNull(ruleset3.getRuleByName("DummyBasicMockRule"));    }    @Test    public void testMissingRuleSetNameIsWarning() {        loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\"?>\n" + "<ruleset \n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <description>Custom ruleset for tests</description>\n"                + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                + "  </ruleset>\n"        );        assertTrue(logging.getLog().contains("RuleSet name is missing."));    }    @Test    public void testMissingRuleSetDescriptionIsWarning() {        loadRuleSetWithDeprecationWarnings(            "<?xml version=\"1.0\"?>\n" + "<ruleset name=\"then name\"\n"                + "    xmlns=\"http://pmd.sourceforge.net/ruleset/2.0.0\"\n"                + "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"                + "    xsi:schemaLocation=\"http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd\">\n"                + "  <rule ref=\"rulesets/dummy/basic.xml\"/>\n"                + "  </ruleset>\n"        );        assertTrue(logging.getLog().contains("RuleSet description is missing."));    }    private static final String REF_OVERRIDE_ORIGINAL_NAME = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "\n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"> \n"        + "\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_MISSPELLED_XREF = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/FooMockRule1\"> \n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_OVERRIDE_ORIGINAL_NAME_ONE_ELEM = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\" message=\"TestMessageOverride\"/> \n"        + "\n"        + "</ruleset>";    private static final String REF_OVERRIDE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" \n"        + "  name=\"TestNameOverride\" \n"        + "\n"        + "  message=\"Test message override\"> \n"        + "  <description>Test description override</description>\n"        + "  <example>Test example override</example>\n"        + "  <priority>3</priority>\n"        + "  <properties>\n"        + "   <property name=\"test2\" description=\"test2\" type=\"String\" value=\"override2\"/>\n"        + "   <property name=\"test3\" type=\"String\" description=\"test3\"><value>override3</value></property>\n"        + "\n"        + "  </properties>\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_OVERRIDE_NONEXISTENT = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + " <description>testdesc</description>\n"        + " <rule \n"        + "  ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule4\" \n"        + "  name=\"TestNameOverride\" \n"        + "\n"        + "  message=\"Test message override\"> \n"        + "  <description>Test description override</description>\n"        + "  <example>Test example override</example>\n"        + "  <priority>3</priority>\n"        + "  <properties>\n"        + "   <property name=\"test4\" description=\"test4\" type=\"String\" value=\"new property\"/>\n"        + "  </properties>\n"        + " </rule>\n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "</rule>\n"        + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"/> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_INTERNAL_CHAIN = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "</rule>\n"        + " <rule ref=\"MockRuleName\" name=\"MockRuleNameRef\"><priority>2</priority></rule> \n"        + " <rule ref=\"MockRuleNameRef\" name=\"MockRuleNameRefRef\"><priority>1</priority></rule> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "name=\"ExternalRefRuleName\" \n"        + "ref=\"net/sourceforge/pmd/TestRuleset1.xml/MockRule1\"/>\n"        + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"/> \n"        + "</ruleset>";    private static final String REF_INTERNAL_TO_EXTERNAL_CHAIN = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + " <description>testdesc</description>\n"        + "<rule \n"        + "\n"        + "name=\"ExternalRefRuleName\" \n"        + "ref=\"net/sourceforge/pmd/TestRuleset2.xml/TestRule\"/>\n"        + " <rule ref=\"ExternalRefRuleName\" name=\"ExternalRefRuleNameRef\"><priority>2</priority></rule> \n"        + "\n"        + " <rule ref=\"ExternalRefRuleNameRef\" name=\"ExternalRefRuleNameRefRef\"><priority>1</priority></rule> \n"        + "\n"        + "</ruleset>";    private static final String EMPTY_RULESET = "<?xml version=\"1.0\"?>\n<ruleset name=\"test\">\n<description>testdesc</description>\n</ruleset>";    private static final String SINGLE_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "</rule></ruleset>";    private static final String MULTIPLE_RULES = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + "<description>testdesc</description>\n"        + "<rule name=\"MockRuleName1\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "\n"        + "</rule>\n"        + "<rule name=\"MockRuleName2\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "\n"        + "</rule></ruleset>";    private static final String PROPERTIES = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule name=\"MockRuleName\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "\n"        + "<description>testdesc2</description>\n"        + "<properties>\n"        + "<property name=\"fooBoolean\" description=\"test\" type=\"Boolean\" value=\"true\" />\n"        + "<property name=\"fooChar\" description=\"test\" type=\"Character\" value=\"B\" />\n"        + "<property name=\"fooInt\" description=\"test\" type=\"Integer\" min=\"1\" max=\"10\" value=\"3\" />\n"        + "\n"        + "<property name=\"fooFloat\" description=\"test\" type=\"Float\" min=\"1.0\" max=\"1.0\" value=\"1.0\"  />\n"        + "\n"        + "<property name=\"fooDouble\" description=\"test\" type=\"Double\" min=\"1.0\" max=\"9.0\" value=\"3.0\"  />\n"        + "\n"        + "<property name=\"fooString\" description=\"test\" type=\"String\" value=\"bar\" />\n"        + "</properties>\n"        + "</rule></ruleset>";    private static final String XPATH = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule name=\"MockRuleName\" \n"        + "language=\"dummy\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "\n"        + "<description>testdesc2</description>\n"        + "<properties>\n"        + "<property name=\"xpath\" description=\"test\" type=\"String\">\n"        + "<value>\n"        + "<![CDATA[ //Block ]]>\n"        + "</value>\n"        + "</property>\n"        + "</properties>\n"        + "</rule></ruleset>";    private static final String PRIORITY = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\">\n"        + "<priority>3</priority>\n"        + "</rule></ruleset>";    private static final String LANGUAGE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" "        + "language=\"dummy\">\n"        + "</rule></ruleset>";    private static final String INCORRECT_LANGUAGE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "\n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"bogus\">\n"        + "</rule></ruleset>";    private static final String MINIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " minimumLanguageVersion=\"1.4\">\n"        + "</rule></ruleset>";    private static final String INCORRECT_MINIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " minimumLanguageVersion=\"bogus\">\n"        + "</rule></ruleset>";    private static final String MAXIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " maximumLanguageVersion=\"1.7\">\n"        + "</rule></ruleset>";    private static final String INCORRECT_MAXIMUM_LANGUAGE_VERSION = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"\n"        + " language=\"dummy\"\n"        + " maximumLanguageVersion=\"bogus\">\n"        + "</rule></ruleset>";    private static final String INVERTED_MINIMUM_MAXIMUM_LANGUAGE_VERSIONS = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" \n"        + "language=\"dummy\"\n"        + " minimumLanguageVersion=\"1.7\"\n"        + "maximumLanguageVersion=\"1.4\">\n"        + "</rule></ruleset>";    private static final String DIRECT_DEPRECATED_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\" deprecated=\"true\">\n"        + "</rule></ruleset>";    // Note: Update this RuleSet name to a different RuleSet with deprecated    // Rules when the Rules are finally removed.    private static final String DEPRECATED_RULE_RULESET_NAME = "net/sourceforge/pmd/TestRuleset1.xml";    // Note: Update this Rule name to a different deprecated Rule when the one    // listed here is finally removed.    private static final String DEPRECATED_RULE_NAME = "MockRule3";    private static final String REFERENCE_TO_DEPRECATED_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule " + "ref=\"" + DEPRECATED_RULE_RULESET_NAME + "/" + DEPRECATED_RULE_NAME + "\" />\n"        + "</ruleset>";    private static final String REFERENCE_TO_RULESET_WITH_DEPRECATED_RULE = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule " + "ref=\"" + DEPRECATED_RULE_RULESET_NAME + "\" />\n"        + "</ruleset>";    private static final String DFA = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule \n"        + "language=\"dummy\" \n"        + "name=\"MockRuleName\" \n"        + "message=\"avoid the mock rule\" \n"        + "dfa=\"true\" \n"        + "class=\"net.sourceforge.pmd.lang.rule.MockRule\"><priority>3</priority>\n"        + "</rule></ruleset>";    private static final String INCLUDE_EXCLUDE_RULESET = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<include-pattern>include1</include-pattern>\n"        + "<include-pattern>include2</include-pattern>\n"        + "\n"        + "<exclude-pattern>exclude1</exclude-pattern>\n"        + "<exclude-pattern>exclude2</exclude-pattern>\n"        + "<exclude-pattern>exclude3</exclude-pattern>\n"        + "\n"        + "</ruleset>";    private static final String EXTERNAL_REFERENCE_RULE_SET = "<?xml version=\"1.0\"?>\n"        + "<ruleset name=\"test\">\n"        + "<description>testdesc</description>\n"        + "<rule ref=\"net/sourceforge/pmd/external-reference-ruleset.xml/MockRule\"/>\n"        + "</ruleset>";    private Rule loadFirstRule(String ruleSetXml) {        RuleSet rs = loadRuleSet(ruleSetXml);        return rs.getRules().iterator().next();    }    private RuleSet loadRuleSet(String ruleSetXml) {        return new RuleSetLoader().loadFromString("dummyRuleset.xml", ruleSetXml);    }    private RuleSet loadRuleSetWithDeprecationWarnings(String ruleSetXml) {        return new RuleSetLoader().warnDeprecated(true).enableCompatibility(false).loadFromString("testRuleset.xml", ruleSetXml);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNull;import java.io.File;import java.util.Collections;import java.util.function.BiConsumer;import java.util.function.Consumer;import org.junit.Test;import net.sourceforge.pmd.lang.DummyLanguageModule;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.ast.RootNode;import junit.framework.JUnit4TestAdapter;public class RuleContextTest {    public static Report getReport(Consumer<RuleContext> sideEffects) throws Exception {        Report report = new Report();        RuleContext ctx = new RuleContext();        ctx.setSourceCodeFile(new File("test.dummy"));        ctx.setReport(report);        ctx.setLanguageVersion(LanguageRegistry.getLanguage(DummyLanguageModule.NAME).getDefaultVersion());        sideEffects.accept(ctx);        return report;    }    public static Report getReport(Rule rule, BiConsumer<Rule, RuleContext> sideEffects) throws Exception {        return getReport(ctx -> sideEffects.accept(rule, ctx));    }    public static Report getReportForRuleApply(Rule rule, Node node) throws Exception {        return getReport(rule, (r, ctx) -> r.apply(node, ctx));    }    public static Report getReportForRuleSetApply(RuleSet ruleset, RootNode node) throws Exception {        return getReport(ctx -> new RuleSets(ruleset).apply(Collections.singletonList(node), ctx));    }    @Test    public void testReport() {        RuleContext ctx = new RuleContext();        assertEquals(0, ctx.getReport().getViolations().size());        Report r = new Report();        ctx.setReport(r);        Report r2 = ctx.getReport();        assertEquals("report object mismatch", r, r2);    }    @Test    public void testSourceCodeFilename() {        RuleContext ctx = new RuleContext();        assertEquals("filename should be empty", "", ctx.getSourceCodeFilename());        ctx.setSourceCodeFile(new File("dir/foo.java"));        assertEquals("filename mismatch", "foo.java", ctx.getSourceCodeFilename());    }    @Test    public void testSourceCodeFile() {        RuleContext ctx = new RuleContext();        assertNull("file should be null", ctx.getSourceCodeFile());        ctx.setSourceCodeFile(new File("somefile.java"));        assertEquals("filename mismatch", new File("somefile.java"), ctx.getSourceCodeFile());    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(RuleContextTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.util.Comparator;import org.junit.Ignore;import org.junit.Test;import net.sourceforge.pmd.lang.ast.DummyNode;import net.sourceforge.pmd.lang.ast.Node;import net.sourceforge.pmd.lang.rule.MockRule;import net.sourceforge.pmd.lang.rule.ParametricRuleViolation;import junit.framework.JUnit4TestAdapter;public class RuleViolationTest {    @Test    public void testConstructor1() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        DummyNode s = new DummyNode();        s.setCoords(2, 1, 2, 3);        RuleViolation r = new ParametricRuleViolation<Node>(rule, "filename", s, rule.getMessage());        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());    }    @Test    public void testConstructor2() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        DummyNode s = new DummyNode();        s.setCoords(2, 1, 2, 3);        RuleViolation r = new ParametricRuleViolation<Node>(rule, "filename", s, "description");        assertEquals("object mismatch", rule, r.getRule());        assertEquals("line number is wrong", 2, r.getBeginLine());        assertEquals("filename is wrong", "filename", r.getFilename());        assertEquals("description is wrong", "description", r.getDescription());    }    @Test    public void testComparatorWithDifferentFilenames() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        DummyNode s = new DummyNode();        s.setCoords(10, 1, 11, 3);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, "filename1", s, "description");        DummyNode s1 = new DummyNode();        s1.setCoords(10, 1, 11, 3);        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, "filename2", s1, "description");        assertEquals(-1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    @Test    public void testComparatorWithSameFileDifferentLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        DummyNode s = new DummyNode();        s.setCoords(10, 1, 15, 10);        DummyNode s1 = new DummyNode();        s1.setCoords(20, 1, 25, 10);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, "filename", s, "description");        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, "filename", s1, "description");        assertTrue(comp.compare(r1, r2) < 0);        assertTrue(comp.compare(r2, r1) > 0);    }    @Ignore    @Test    public void testComparatorWithSameFileSameLines() {        Rule rule = new MockRule("name", "desc", "msg", "rulesetname");        Comparator<RuleViolation> comp = RuleViolation.DEFAULT_COMPARATOR;        DummyNode s = new DummyNode();        s.setCoords(10, 1, 15, 10);        DummyNode s1 = new DummyNode();        s.setCoords(10, 1, 15, 10);        RuleViolation r1 = new ParametricRuleViolation<Node>(rule, "filename", s, "description");        RuleViolation r2 = new ParametricRuleViolation<Node>(rule, "filename", s1, "description");        assertEquals(1, comp.compare(r1, r2));        assertEquals(1, comp.compare(r2, r1));    }    public static junit.framework.Test suite() {        return new JUnit4TestAdapter(RuleViolationTest.class);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.resolver;import java.util.List;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.modelica.ModelicaParsingHelper;import net.sourceforge.pmd.lang.modelica.ast.ASTExtendsClause;import net.sourceforge.pmd.lang.modelica.ast.ASTStoredDefinition;import net.sourceforge.pmd.lang.modelica.ast.ModelicaClassSpecifierNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaNode;import net.sourceforge.pmd.lang.modelica.ast.ModelicaParserVisitorAdapter;public class ModelicaResolverTest {    private final ModelicaParsingHelper modelica = ModelicaParsingHelper.DEFAULT;    private static class NodeFinder extends ModelicaParserVisitorAdapter {        private ModelicaNode result;        private Class<?> nodeClass;        private String nodeName;        NodeFinder(Class<?> nodeClass, String nodeName) {            this.nodeClass = nodeClass;            this.nodeName = nodeName;        }        @Override        public Object visitModelicaNode(ModelicaNode node, Object data) {            if (nodeClass.isInstance(node) && node.getImage().equals(nodeName)) {                Assert.assertNull(result);                result = node;            }            return super.visitModelicaNode(node, data);        }        ModelicaNode getResult() {            return result;        }    }    private ModelicaNode findNodeByClassAndImage(ASTStoredDefinition ast, Class<?> clazz, String image) {        NodeFinder vis = new NodeFinder(clazz, image);        ast.acceptVisitor(vis, null);        return vis.getResult();    }    private void ensureCounts(ResolutionResult result, int best, int hidden) {        Assert.assertFalse(result.wasTimedOut());        Assert.assertEquals(best, result.getBestCandidates().size());        Assert.assertEquals(hidden, result.getHiddenCandidates().size());    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, SubcomponentResolver resolver, boolean absolute, String[] names) {        ResolutionResult<ResolvableEntity> result = resolver.safeResolveComponent(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> resolveIn(int best, int hidden, ResolutionState state, ModelicaScope resolver, boolean absolute, String[] names) {        ResolutionResult<ResolvableEntity> result = resolver.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, SubcomponentResolver scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedTypeCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forType(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testResolvedComponentCount(int best, int hidden, ModelicaScope scope, boolean absolute, String... names) {        return resolveIn(best, hidden, ResolutionState.forComponentReference(), scope, absolute, names);    }    private ResolutionResult<ResolvableEntity> testLexicallyResolvedComponents(int best, int hidden, ModelicaClassScope scope, boolean absolute, String... names) {        ResolutionState state = ResolutionState.forComponentReference();        ResolutionResult<ResolvableEntity> result = scope.safeResolveLexically(ResolvableEntity.class, state, CompositeName.create(absolute, names));        ensureCounts(result, best, hidden);        return result;    }    @Test    public void verySimpleScopeTest() {        String contents =              "model TestPackage"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        Assert.assertNotNull(ast);        Assert.assertTrue(ast.getMostSpecificScope() instanceof ModelicaSourceFileScope);        ModelicaSourceFileScope scope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        Assert.assertTrue(scope.getParent() instanceof RootScope);        Assert.assertNull(scope.getParent().getParent());    }    @Test    public void simpleScopeTest() {        String contents =              "package TestPackage"            + "  connector TestConnector"            + "  end TestConnector;"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        ModelicaSourceFileScope sourceFileScope = (ModelicaSourceFileScope) ast.getMostSpecificScope();        Assert.assertEquals(1, sourceFileScope.getContainedDeclarations().size());        ModelicaNode testSubmodel = findNodeByClassAndImage(ast, ModelicaClassSpecifierNode.class, "TestSubmodel");        Assert.assertNotNull(testSubmodel);        Assert.assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:TestSubmodel",                ((AbstractModelicaScope) testSubmodel.getMostSpecificScope()).getNestingRepresentation()        );        ModelicaScope testPackage = testSubmodel.getMostSpecificScope().getParent().getParent();        Assert.assertTrue(testPackage instanceof ModelicaClassScope);        Assert.assertEquals("TestPackage", ((ModelicaClassScope) testPackage).getClassDeclaration().getSimpleTypeName());        Assert.assertEquals(3, testPackage.getContainedDeclarations().size());    }    @Test    public void extendsScopeTest() {        String contents =                  "package Test"                + "  model A"                + "    extends B;"                + "  end A;"                + "  model B"                + "  end B;"                + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ASTExtendsClause> extendsClauses = ast.findDescendantsOfType(ASTExtendsClause.class);        Assert.assertEquals(1, extendsClauses.size());        ASTExtendsClause extendsB = extendsClauses.get(0);        Assert.assertEquals("#ROOT#FILE#Class:Test#Class:A", ((AbstractModelicaScope) extendsB.getMostSpecificScope()).getNestingRepresentation());    }    @Test    public void absoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    public void nonAbsoluteResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model TestSubmodel"            + "    end TestSubmodel;"            + "  end TestModel;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "TestPackage", "TestModel", "TestSubmodel");    }    @Test    public void multipleResolutionTest() {        String contents =              "package TestPackage"            + "  model TestModel"            + "    model A"            + "    end A;"            + "  end TestModel;"            + "  model A"            + "  end A;"            + "  Real x;"            + "end TestPackage;";        ASTStoredDefinition ast = modelica.parse(contents);        ResolutionResult<ResolvableEntity> testModelCandidates = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "TestPackage", "TestModel");        ModelicaClassScope testModelScope = ((ModelicaClassType) testModelCandidates.getBestCandidates().get(0)).getClassScope();        Assert.assertEquals(                "#ROOT#FILE#Class:TestPackage#Class:TestModel",                testModelScope.getNestingRepresentation()        );        ResolutionResult<ResolvableEntity> aCandidates = testLexicallyResolvedComponents(1, 1, testModelScope, false, "A");        ModelicaClassType aBest = (ModelicaClassType) aCandidates.getBestCandidates().get(0);        ModelicaClassType aHidden = (ModelicaClassType) aCandidates.getHiddenCandidates().get(0);        Assert.assertEquals("#ROOT#FILE#Class:TestPackage#Class:TestModel#Class:A",                aBest.getClassScope().getNestingRepresentation());        Assert.assertEquals("#ROOT#FILE#Class:TestPackage#Class:A",                aHidden.getClassScope().getNestingRepresentation());    }    @Test    public void constantComponentResolutionTest() {        String contents =              "model Test"            + "  model A"            + "    constant Real x = 1;"            + "  end A;"            + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ResolvableEntity> xs = testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "A", "x").getBestCandidates();        Assert.assertEquals(            "#ROOT#FILE#Class:Test#Class:A",                ((ModelicaComponentDeclaration) xs.get(0)).getContainingScope().getNestingRepresentation()        );    }    @Test    public void nestedStoredDefinitionTest() {        String contents =              "within TestPackage.SubPackage;\n"            + "model Test\n"            + "end Test;\n";        ASTStoredDefinition ast = modelica.parse(contents);        RootScope rootScope = (RootScope) ast.getMostSpecificScope().getParent();        List<ResolvableEntity> nestedTest = testResolvedTypeCount(1, 0, rootScope, false, "TestPackage", "SubPackage", "Test").getBestCandidates();        Assert.assertEquals(                "#ROOT#FILE#Class:Test",                ((ModelicaClassType) nestedTest.get(0)).getClassScope().getNestingRepresentation()        );        // Simple names are visible from within the same file        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test");        // ... but from other files they should be resolved w.r.t. the within clause        testResolvedTypeCount(0, 0, rootScope, false, "Test");    }    @Test    public void extendsTest() {        String contents =              "model A\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "B", "X");    }    @Test    public void importTest() {        String contents =              "model I\n"            + "  model Z\n"            + "  end Z;\n"            + "end I;\n"            + "model A\n"            + "  import I.Z;\n"            + "  model X\n"            + "  end X;\n"            + "end A;\n"            + "model B\n"            + "  extends A;"            + "end B;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "A", "Z");        testResolvedTypeCount(0, 0, ast.getMostSpecificScope(), false, "B", "Z");    }    @Test    public void builtinTest() {        String contents =              "model A"            + "  encapsulated model B"            + "    Real x;"            + "  end B;"            + "end A;";        ASTStoredDefinition ast = modelica.parse(contents);        List<ResolvableEntity> xs = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), true, "A", "B", "x").getBestCandidates();        ModelicaComponentDeclaration x = (ModelicaComponentDeclaration) xs.get(0);        ResolutionResult<ModelicaType> xTypes = x.getTypeCandidates();        ensureCounts(xTypes, 1, 0);        ResolvableEntity tpe = xTypes.getBestCandidates().get(0);        Assert.assertTrue(tpe instanceof ModelicaBuiltinType);        Assert.assertEquals(ModelicaBuiltinType.BaseType.REAL, ((ModelicaBuiltinType) tpe).getBaseType());    }    @Test    public void testRepeatingNameResolution() {        String contents =                  "package Test"                + "  model X"                + "    model X"                + "    end X;"                + "    Test.X.X mdl;"                + "  end X;"                + "end Test;";        ASTStoredDefinition ast = modelica.parse(contents);        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), true, "Test", "X", "X");        testResolvedTypeCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "X");        ResolutionResult<ResolvableEntity> result = testResolvedComponentCount(1, 0, ast.getMostSpecificScope(), false, "Test", "X", "mdl");        ModelicaComponentDeclaration mdl = (ModelicaComponentDeclaration) result.getBestCandidates().get(0);        ensureCounts(mdl.getTypeCandidates(), 1, 0);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ConnectUsingNonConnectorTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassStartNameEqualsEndNameTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AmbiguousResolutionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.modelica;import org.junit.Test;public class ModelicaParserTest {    @Test    public void testParsingGrapgical() {        ModelicaParsingHelper.DEFAULT.parseResource("ParserTestGraphical.mo");    }    @Test    public void testParsingTextual() {        ModelicaParsingHelper.DEFAULT.parseResource("ParserTestTextual.mo");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;import net.sourceforge.pmd.lang.modelica.ModelicaLanguageModule;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameterized.Parameters    public static Collection<Object[]> data() {        return Arrays.asList(new Object[][] {            { ModelicaLanguageModule.NAME, ModelicaLanguageModule.TERSE_NAME, "",                LanguageRegistry.getLanguage(ModelicaLanguageModule.NAME).getDefaultVersion(),            },        });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {    // no additional tests yet}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class MatlabTokenizerTest extends CpdTextComparisonTest {    public MatlabTokenizerTest() {        super(".m");    }    @Override    protected String getResourcePrefix() {        return "../lang/matlab/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new MatlabTokenizer();    }        @Test    public void testLongSample() {        doTest("sample-matlab");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testComments() {        doTest("comments");    }    @Test    public void testBlockComments() {        doTest("multilineComments");    }    @Test    public void testQuestionMark() {        doTest("questionMark");    }    @Test    public void testDoubleQuotedStrings() {        doTest("doubleQuotedStrings");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class LuaTokenizerTest extends CpdTextComparisonTest {    public LuaTokenizerTest() {        super(".lua");    }    @Override    protected String getResourcePrefix() {        return "../lang/lua/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new LuaTokenizer();    }    @Test    public void testSimple() {        doTest("helloworld");    }    @Test    public void testFactorial() {        doTest("factorial");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class RubyTokenizerTest extends CpdTextComparisonTest {    public RubyTokenizerTest() {        super(".rb");    }    @Override    protected String getResourcePrefix() {        return "../lang/ruby/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        return new RubyLanguage().getTokenizer();    }    @Test    public void testSimple() {        doTest("server");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.cpp.ast;import static org.junit.Assert.assertEquals;import java.io.IOException;import java.io.StringReader;import org.junit.Test;public class CppCharStreamTest {    @Test    public void testContinuationUnix() throws IOException {        CppCharStream stream = CppCharStream.newCppCharStream(new StringReader("a\\\nb"));        assertStream(stream, "ab");    }    @Test    public void testContinuationWindows() throws IOException {        CppCharStream stream = CppCharStream.newCppCharStream(new StringReader("a\\\r\nb"));        assertStream(stream, "ab");    }    @Test    public void testBackup() throws IOException {        CppCharStream stream = CppCharStream.newCppCharStream(new StringReader("a\\b\\\rc"));        assertStream(stream, "a\\b\\\rc");    }    private void assertStream(CppCharStream stream, String token) throws IOException {        char c = stream.BeginToken();        assertEquals(token.charAt(0), c);        for (int i = 1; i < token.length(); i++) {            c = stream.readChar();            assertEquals(token.charAt(i), c);        }        assertEquals(token, stream.GetImage());        assertEquals(token, new String(stream.GetSuffix(token.length())));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class CPPTokenizerTest extends CpdTextComparisonTest {    public CPPTokenizerTest() {        super(".cpp");    }    @Override    protected String getResourcePrefix() {        return "../lang/cpp/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties props) {        CPPTokenizer tok = new CPPTokenizer();        tok.setProperties(props);        return tok;    }    @Override    public Properties defaultProperties() {        return dontSkipBlocks();    }    @Test    public void testUTFwithBOM() {        Tokenizer tokenizer = newTokenizer(dontSkipBlocks());        Tokens tokens = tokenize(tokenizer, "\ufeffint start()\n{ int ret = 1;\nreturn ret;\n}\n");        assertEquals(15, tokens.size());    }    @Test    public void testContinuation() {        doTest("continuation");    }    @Test    public void testContinuationInIdent() {        doTest("continuation_intra_token");    }    @Test    public void testContinuationBetweenTokens() {        doTest("continuation_inter_token");    }    @Test    public void testUnicodeStringSupport() {        doTest("unicodeStrings");    }    @Test    public void testIgnoreBetweenSpecialComments() {        doTest("specialComments");    }    @Test    public void testMultiLineMacros() {        doTest("multilineMacros");    }    @Test    public void testIdentifierValidChars() {        doTest("identifierChars");    }    @Test    public void testWrongUnicodeInIdentifier() {        expectTokenMgrError(" void main() { int  = __; }");    }    @Test    public void testTokenizerWithSkipBlocks() {        doTest("simpleSkipBlocks", "_skipDefault", skipBlocks());    }    @Test    public void testTokenizerWithSkipBlocksPattern() {        doTest("simpleSkipBlocks", "_skipDebug", skipBlocks("#if debug|#endif"));    }    @Test    public void testTokenizerWithoutSkipBlocks() {        doTest("simpleSkipBlocks", "_noSkip", dontSkipBlocks());    }    @Test    public void testAsm() {        // ASM code containing the '@' character        doTest("asm", "", dontSkipBlocks());    }    @Test    public void testPreprocessingDirectives() {        doTest("preprocessorDirectives");    }    @Test    public void testLiterals() {        doTest("literals");    }    @Test    public void testLexicalErrorFilename() {        expectTokenMgrError(sourceText("issue-1559"), dontSkipBlocks());    }    @Test    public void testRawStringLiterals() {        doTest("issue-1784");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    private static Properties skipBlocks(String skipPattern) {        return properties(true, skipPattern);    }    private static Properties skipBlocks() {        return skipBlocks(null);    }    private static Properties dontSkipBlocks() {        return properties(false, null);    }    private static Properties properties(boolean skipBlocks, String skipPattern) {        Properties properties = new Properties();        properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS, Boolean.toString(skipBlocks));        if (skipPattern != null) {            properties.setProperty(Tokenizer.OPTION_SKIP_BLOCKS_PATTERN, skipPattern);        }        return properties;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestAccessEvaluator.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import java.util.HashSet;import java.util.Objects;import java.util.Set;import apex.jorje.semantic.compiler.Namespace;import apex.jorje.semantic.compiler.StructuredVersion;import apex.jorje.semantic.compiler.sfdc.AccessEvaluator;import apex.jorje.semantic.compiler.sfdc.PlaceholderOrgPerm;import apex.jorje.semantic.symbol.type.SObjectTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfo;import apex.jorje.semantic.symbol.type.StandardTypeInfoImpl;import apex.jorje.semantic.symbol.type.TypeInfo;import com.google.common.collect.HashMultimap;import com.google.common.collect.Iterables;import com.google.common.collect.SetMultimap;/** * For now everything returns false. * If you actually need to override something, it would be easier to probably mock and adjust what you needed. * Otherwise this is simply to create a concrete representation and not force a mockito init. * * @author jspagnola */class TestAccessEvaluator implements AccessEvaluator {    private final SetMultimap<Namespace, StructuredVersion> validPageVersions;    private final SetMultimap<SObjectTypeInfo, TypeInfo> visibleSetupEntitiesToTypes;    private final Set<Namespace> accessibleSystemNamespaces;    private final Set<PlaceholderOrgPerm> orgPerm;    private final Set<AllowedPermGuard> allowedPermGuards;    private final Set<Namespace> reservedNamespaces;    private final Set<String> globalComponents;    private final Set<Namespace> managedPackagesNotInstalled;    private final Set<String> typesWithConnectApiDeserializers;    private boolean hasInternalSfdc;    private boolean isRunningTests;    private boolean hasPrivateApi;    private boolean isTrustedApplication;    private boolean hasLocalizedTranslation;    private boolean isSfdc;    private boolean isReallyRunningTests;    private boolean hasApexGenericTypes;    private boolean hasRemoteActionPerm;    private boolean hasPersonAccountApiAvailable;    TestAccessEvaluator() {        validPageVersions = HashMultimap.create();        visibleSetupEntitiesToTypes = HashMultimap.create();        managedPackagesNotInstalled = new HashSet<>();        accessibleSystemNamespaces = new HashSet<>();        orgPerm = new HashSet<>();        allowedPermGuards = new HashSet<>();        reservedNamespaces = new HashSet<>();        globalComponents = new HashSet<>();        typesWithConnectApiDeserializers = new HashSet<>();        hasRemoteActionPerm = true;        hasPersonAccountApiAvailable = true;    }    @Override    public boolean hasPermission(final PlaceholderOrgPerm orgPerm) {        return this.orgPerm.contains(orgPerm);    }    @Override    public boolean hasPermissionForPermGuard(final Namespace referencingNamespace, final String orgPerm) {        return allowedPermGuards.contains(new AllowedPermGuard(referencingNamespace, orgPerm));    }    @Override    public boolean hasPersonAccountApiAvailable() {        return hasPersonAccountApiAvailable;    }    @Override    public boolean hasPrivateApi() {        return hasPrivateApi;    }    @Override    public boolean hasLocalizedTranslation() {        return hasLocalizedTranslation;    }    @Override    public boolean hasInternalSfdc() {        return hasInternalSfdc;    }    @Override    public boolean isTrustedApplication(TypeInfo arg0) {        return isTrustedApplication;    }    @Override    public boolean isReservedNamespace(final Namespace namespace) {        return reservedNamespaces.contains(namespace);    }    @Override    public boolean isReservedNamespace(final Namespace namespace, final boolean excludePackages) {        return reservedNamespaces.contains(namespace);    }    /**     * See {@link #isAccessibleOrTrustedNamespace(Namespace)}     */    @Override    public boolean isAccessibleSystemNamespace(final Namespace namespace) {        return accessibleSystemNamespaces.contains(namespace);    }    /**     * Okay so this check and its partner isAccessibleSystemNamespace are used slightly differently.     * This is like a black list check, that prevents referencing code from seeing things in a reserved namespace.     * The other check allows code to see certain things if the code's namespace is a reserved namespace.     * <p>     * Hence here we return true by default, and the {@link #isAccessibleSystemNamespace(Namespace)} returns false     * by default.     */    @Override    public boolean isAccessibleOrTrustedNamespace(final Namespace namespace) {        return true;    }    @Override    public boolean isRunningTests() {        return isRunningTests;    }    @Override    public boolean isReallyRunningTests() {        return isReallyRunningTests;    }    @Override    public boolean isSfdc() {        return isSfdc;    }    @Override    public boolean hasApexParameterizedTypes() {        return hasApexGenericTypes;    }    @Override    public boolean isValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        return validPageVersions.containsEntry(namespace, version);    }    /**     * @return 'true' for everything EXCEPT namespaces you've added through {@link #addManagedPackageNotInstalled(Namespace)}     */    @Override    public boolean isManagedPackageInstalled(final Namespace namespace) {        return !managedPackagesNotInstalled.contains(namespace);    }    @Override    public boolean isSetupEntityVisibleToType(final SObjectTypeInfo type, final TypeInfo referencingType) {        final TypeInfo visibleReferencingType = Iterables.getFirst(visibleSetupEntitiesToTypes.get(type), null);        return visibleReferencingType != null            && visibleReferencingType.getBytecodeName().equals(referencingType.getBytecodeName());    }    @Override    public boolean hasConnectDeserializer(final TypeInfo type) {        return typesWithConnectApiDeserializers.contains(type.getApexName());    }    @Override    public boolean hasRemoteAction(final TypeInfo type) {        return false;    }    @Override    public boolean hasRemoteActionPerm() {        return hasRemoteActionPerm;    }    @Override    public boolean isGlobalComponent(final TypeInfo type) {        return globalComponents.contains(type.getApexName());    }    /**     * Things isManagedPackageInstalled will say 'false' to.     */    public TestAccessEvaluator addManagedPackageNotInstalled(final Namespace namespace) {        managedPackagesNotInstalled.add(namespace);        return this;    }    public TestAccessEvaluator addReservedNamespace(final Namespace namespace) {        reservedNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator addPermission(final PlaceholderOrgPerm orgPerm) {        this.orgPerm.add(orgPerm);        return this;    }    public TestAccessEvaluator setHasInternalSfdc(final boolean hasInternalSfdc) {        this.hasInternalSfdc = hasInternalSfdc;        return this;    }    public TestAccessEvaluator addValidPackageVersion(final Namespace namespace, final StructuredVersion version) {        validPageVersions.put(namespace, version);        return this;    }    public TestAccessEvaluator addSetupEntityVisibleToType(        final SObjectTypeInfo type,        final String typeName    ) {        final StandardTypeInfo typeInfo = StandardTypeInfoImpl.builder()            .setApexName(typeName)            .setBytecodeName(typeName)            .buildResolved();        visibleSetupEntitiesToTypes.put(type, typeInfo);        return this;    }    public TestAccessEvaluator setIsRunningTests(final boolean isRunningTests) {        this.isRunningTests = isRunningTests;        return this;    }    public TestAccessEvaluator setHasPrivateApi(final boolean hasPrivateApi) {        this.hasPrivateApi = hasPrivateApi;        return this;    }    public TestAccessEvaluator setIsTrustedApplication(final boolean isTrustedApplication) {        this.isTrustedApplication = isTrustedApplication;        return this;    }    public TestAccessEvaluator setHasLocalizedTranslation(final boolean hasLocalizedTranslation) {        this.hasLocalizedTranslation = hasLocalizedTranslation;        return this;    }    public TestAccessEvaluator setIsSfdc(final boolean isSfdc) {        this.isSfdc = isSfdc;        return this;    }    public TestAccessEvaluator setIsReallyRunningTests(final boolean isReallyRunningTests) {        this.isReallyRunningTests = isReallyRunningTests;        return this;    }    public TestAccessEvaluator setAccessibleSystemNamespace(final Namespace namespace) {        accessibleSystemNamespaces.add(namespace);        return this;    }    public TestAccessEvaluator setHasApexGenericType(final boolean hasApexGenericTypes) {        this.hasApexGenericTypes = hasApexGenericTypes;        return this;    }    public TestAccessEvaluator allowPermGuard(final Namespace namespace, final String permGuard) {        allowedPermGuards.add(new AllowedPermGuard(namespace, permGuard));        return this;    }    /**     * It appears that remote action is enabled by default in most orgs, at least test orgs.     * So we will behave the same.     */    public TestAccessEvaluator setHasRemoteActionPerm(final boolean hasRemoteActionPerm) {        this.hasRemoteActionPerm = hasRemoteActionPerm;        return this;    }    public TestAccessEvaluator setTypeWithConnectApiDeserializer(final String typeName) {        typesWithConnectApiDeserializers.add(typeName);        return this;    }    public void setGlobalComponent(final String globalComponent) {        globalComponents.add(globalComponent);    }    private static class AllowedPermGuard {        private final Namespace referencingNamespace;        private final String permGuard;        AllowedPermGuard(final Namespace namespace, final String permGuard) {            referencingNamespace = namespace;            this.permGuard = permGuard;        }        @Override        public int hashCode() {            return Objects.hash(referencingNamespace, permGuard);        }        @Override        public boolean equals(final Object obj) {            if (this == obj) {                return true;            }            if (obj == null || getClass() != obj.getClass()) {                return false;            }            final AllowedPermGuard other = (AllowedPermGuard) obj;            return Objects.equals(referencingNamespace, other.referencingNamespace)                && Objects.equals(permGuard, other.permGuard);        }    }    @Override    public boolean isSecondGenerationPackagingNamespace(Namespace namespace) {        return false;    }    @Override    public boolean useTestValueForAnonymousScriptLengthLimit() {        return false;    }    @Override    public boolean hasNamespaceGuardedAccess(Namespace namespace, String arg1) {        return false;    }    @Override    public boolean isNamespaceGuardNamespace(Namespace arg0) {        return false;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */// Note: taken from https://github.com/forcedotcom/idecore/blob/3083815933c2d015d03417986f57bd25786d58ce/com.salesforce.ide.apex.core/src/apex/jorje/semantic/common/TestQueryValidators.java/* * Copyright 2016 salesforce.com, inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package net.sourceforge.pmd.lang.apex.ast;import apex.jorje.semantic.ast.expression.SoqlExpression;import apex.jorje.semantic.ast.expression.SoslExpression;import apex.jorje.semantic.ast.visitor.ValidationScope;import apex.jorje.semantic.compiler.sfdc.QueryValidator;import apex.jorje.semantic.symbol.resolver.SymbolResolver;/** * The test query validators will return back the query it was given. The real implementation actually creates its own * query. * * @author jspagnola */@SuppressWarnings("PMD.MissingStaticMethodInNonInstantiatableClass") // this class provides utility classesfinal class TestQueryValidators {    private TestQueryValidators() {    }    public static class Noop implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope typeInfo,            final SoslExpression sosl        ) {            return sosl.getCanonicalQuery();        }    }    public static class Error implements QueryValidator {        @Override        public String validateSoql(            final SymbolResolver symbols,            final ValidationScope scope,            final SoqlExpression soql        ) {            scope.getErrors().markInvalid(soql, "Bad Soql");            return soql.getCanonicalQuery();        }        @Override        public String validateSosl(            final SymbolResolver symbols,            final ValidationScope scope,            final SoslExpression sosl        ) {            scope.getErrors().markInvalid(sosl, "Bad Sosl");            return sosl.getCanonicalQuery();        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.metrics.impl;import net.sourceforge.pmd.testframework.SimpleAggregatorTst;/** * Executes the metrics testing rules. * * @author Clment Fournier */public class AllMetricsTest extends SimpleAggregatorTst {    private static final String RULESET = "rulesets/apex/metrics_test.xml";    @Override    public void setUp() {        addRule(RULESET, "CycloTest");        addRule(RULESET, "WmcTest");        addRule(RULESET, "CognitiveComplexityTest");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexBadCryptoTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexXSSFromURLParamTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexCRUDViolationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexInsecureEndpointTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexXSSFromEscapeFalseTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import static org.junit.Assert.assertEquals;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.stream.Collectors;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.RuleViolation;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;/** * <p>Sharing settings are not inherited by inner classes. Sharing settings need to be declared on the class that * contains the Database method, DML, SOQL, or SOSL.</p> * * <p>This test runs against Apex code that has an Outer class and and Inner class. Different Apex code is generated * based on the boolean permutations. Any classes that includes data access cod, but doesn't declare a sharing setting * should trigger a violation.</p> */@RunWith(Parameterized.class)public class ApexSharingViolationsNestedClassTest extends ApexParserTestBase {    /**     * Type of operation that may require a sharing declaration.     */    private enum Operation {        NONE(null),        DML_DELETE("Contact c = new Contact(); delete c;"),        DML_INSERT("Contact c = new Contact(); insert c;"),        DML_MERGE("Contact c1 = new Contact(); Contact c2 = new Contact(); merge c1 c2;"),        DML_UNDELETE("Contact c = new Contact(); undelete c;"),        DML_UPDATE("Contact c = new Contact(); update c;"),        DML_UPSERT("Contact c = new Contact(); upsert c;"),        METHOD_DATABASE("Database.query('Select Id from Contact LIMIT 100');"),        SOQL("[SELECT Name FROM Contact];"),        SOSL("[FIND 'Foo' IN ALL FIELDS RETURNING Account(Name)];");        final boolean requiresSharingDeclaration;        final String codeSnippet;        Operation(String codeSnippet) {            this.requiresSharingDeclaration = codeSnippet != null;            this.codeSnippet = codeSnippet;        }    }    /**     * The permutations used for class generation. See {@link #generateClass(boolean, Operation, boolean, Operation)}     */    private final boolean outerSharingDeclared;    private final Operation outerOperation;    private final boolean innerSharingDeclared;    private final Operation innerOperation;    /**     * Track the expected violations based on the permutations.     */    private final int expectedViolations;    private final List<Integer> expectedLineNumbers;    public ApexSharingViolationsNestedClassTest(boolean outerSharingDeclared, Operation outerOperation,                                                boolean innerSharingDeclared, Operation innerOperation,                                                int expectedViolations, List<Integer> expectedLineNumbers) {        this.outerSharingDeclared = outerSharingDeclared;        this.outerOperation = outerOperation;        this.innerSharingDeclared = innerSharingDeclared;        this.innerOperation = innerOperation;        this.expectedViolations = expectedViolations;        this.expectedLineNumbers = expectedLineNumbers;    }    @Test    public void testSharingPermutation() {        String apexClass = generateClass(outerSharingDeclared, outerOperation, innerSharingDeclared, innerOperation);        ApexSharingViolationsRule rule = new ApexSharingViolationsRule();        rule.setMessage("gotcha!");        Report rpt = apex.executeRule(rule, apexClass);        List<RuleViolation> violations = rpt.getViolations();        assertEquals("Unexpected Violation Size\n" + apexClass, expectedViolations, violations.size());        List<Integer> lineNumbers = violations.stream().map(v -> v.getBeginLine()).collect(Collectors.toList());        assertEquals("Unexpected Line Numbers\n" + apexClass, expectedLineNumbers, lineNumbers);    }    /**     * Parameter provider that covers are all permutations     */    @Parameterized.Parameters    public static Collection<?> data() {        List<Object[]> data = new ArrayList<>();        boolean[] boolPermutations = {false, true};        for (boolean outerSharingDeclared : boolPermutations) {            for (Operation outerOperation : Operation.values()) {                for (boolean innerSharingDeclared : boolPermutations) {                    for (Operation innerOperation : Operation.values()) {                        int expectedViolations = 0;                        List<Integer> expectedLineNumbers = new ArrayList<>();                        if (outerOperation.requiresSharingDeclaration && !outerSharingDeclared) {                            // The outer class contains SOQL but doesn't declare sharing                            expectedViolations++;                            expectedLineNumbers.add(1);                        }                        if (innerOperation.requiresSharingDeclaration && !innerSharingDeclared) {                            // The inner class contains SOQL but doesn't declare sharing                            expectedViolations++;                            // The location of the inner class declaration depends upon the content of the outer class                            expectedLineNumbers.add(outerOperation.requiresSharingDeclaration ? 3 : 2);                        }                        data.add(new Object[]{outerSharingDeclared, outerOperation, innerSharingDeclared, innerOperation,                                              expectedViolations, expectedLineNumbers});                    }                }            }        }        return data;    }    /**     * <p>Generate an Apex class with various Sharing/Database/DML/SOQL/SOSL permutations. An example of the class     * returned when invoked with generateClass(true, SOQL, true, SOQL).</p>     *     * <pre>     * public with sharing class Outer {     *    public void outerSOQL() {[SELECT Name FROM Contact];}     *    public with sharing class Inner {     *       public void innerSOQL() {[SELECT Name FROM Contact];}     *    }     * }     * </pre>     *     * @param outerSharing Add 'with sharing' to Outer class definition     * @param outerOperation Add a method to Outer class that performs the given operation     * @param innerSharing Add 'with sharing' to Inner class definition     * @param innerOperation Add a method to Inner class that performs the given operation     * @return String that represents Apex code     */    private static String generateClass(boolean outerSharing, Operation outerOperation, boolean innerSharing,                                        Operation innerOperation) {        StringBuilder sb = new StringBuilder();        sb.append("public ");        if (outerSharing) {            sb.append("with sharing ");        }        sb.append("class Outer {\n");        switch (outerOperation) {        case NONE:            // Do nothing            break;        default:            sb.append(String.format("\t\tpublic void outer%s(){ %s }\n", outerOperation.name(), outerOperation.codeSnippet));            break;        }        sb.append("\tpublic ");        if (innerSharing) {            sb.append("with sharing ");        }        sb.append("class Inner {\n");        switch (innerOperation) {        case NONE:            // DO Nothing            break;        default:            sb.append(String.format("\t\tpublic void inner%s(){ %s }\n", innerOperation.name(), innerOperation.codeSnippet));            break;        }        sb.append("\t}\n"); // Closes class Inner        sb.append("}\n"); // Closes class Outer        return sb.toString();    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSOQLInjectionTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexOpenRedirectTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSuggestUsingNamedCredTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexDangerousMethodsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.security;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexSharingViolationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyTryOrFinallyBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyIfStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidNonExistentAnnotationsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodWithSameNameAsEnclosingClassTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyWhileStmtTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexCSRFTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TestMethodsMustBeInTestClassesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyStatementBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class EmptyCatchBlockTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDirectAccessTriggerMapTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.errorprone;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidHardcodingIdTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveClassLengthTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessivePublicCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDeeplyNestedIfStmtsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ExcessiveParameterListTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class CyclomaticComplexityTest extends PmdRuleTst {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssConstructorCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class TooManyFieldsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssTypeCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.design;import net.sourceforge.pmd.testframework.PmdRuleTst;public class NcssMethodCountTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSoqlInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OperationWithLimitsInLoopTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidDmlStatementsInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.performance;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidSoslInLoopsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.documentation;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexDocTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldDeclarationsShouldBeAtStartTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfElseStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class IfStmtsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ClassNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class OneDeclarationPerLineTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class WhileLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class PropertyNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ForLoopsMustUseBracesTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class MethodNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FormalParameterNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class LocalVariableNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.codestyle;import net.sourceforge.pmd.testframework.PmdRuleTst;public class FieldNamingConventionsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidLogicInTriggerTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexAssertionsShouldIncludeMessageTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class UnusedLocalVariableTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestClassShouldHaveAssertsTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class AvoidGlobalModifierTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestMethodShouldHaveIsTestAnnotationTest extends PmdRuleTst {    // no additional unit tests}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class ApexUnitTestShouldNotUseSeeAllDataTrueTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule.bestpractices;import net.sourceforge.pmd.testframework.PmdRuleTst;public class DebugsShouldUseLoggingLevelTest extends PmdRuleTst {    // no additional unit tests}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.rule;import org.junit.Test;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.lang.apex.ast.ASTAnonymousClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ASTUserEnum;import net.sourceforge.pmd.lang.apex.ast.ASTUserInterface;import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;public class AbstractApexRuleTest extends ApexParserTestBase {    @Test    public void shouldVisitTopLevelClass() {        run("class Foo { }");    }    @Test    public void shouldVisitTopLevelInterface() {        run("interface Foo { }");    }    @Test    public void shouldVisitTopLevelTrigger() {        run("trigger Foo on Account (before insert, before update) { }");    }    @Test    public void shouldVisitTopLevelEnum() {        run("enum Foo { }");    }    private void run(String code) {        TopLevelRule rule = new TopLevelRule();        rule.setMessage("Message");        Report report = apex.executeRule(rule, code);        TestUtilsKt.assertSize(report, 1);    }    private static class TopLevelRule extends AbstractApexRule {        @Override        public Object visit(ASTUserClass node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserInterface node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserTrigger node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTUserEnum node, Object data) {            addViolation(data, node);            return data;        }        @Override        public Object visit(ASTAnonymousClass node, Object data) {            addViolation(data, node);            return data;        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexParserXPathTest extends ApexParserTestBase {    @Test    public void testBooleanExpressions() throws Exception {        ApexNode<Compilation> node = parse(IOUtils.toString(ApexParserXPathTest.class.getResourceAsStream("BooleanExpressions.cls"),                StandardCharsets.UTF_8));        List<ASTBooleanExpression> booleanExpressions = node.findDescendantsOfType(ASTBooleanExpression.class);        Assert.assertEquals(2, booleanExpressions.size());        Assert.assertEquals("&&", booleanExpressions.get(0).getOperator().toString());        Assert.assertEquals("!=", booleanExpressions.get(1).getOperator().toString());        List<? extends Node> xpathResult = node.findChildNodesWithXPath("//BooleanExpression[@Operator='&&']");        Assert.assertEquals(1, xpathResult.size());        Assert.assertSame(booleanExpressions.get(0), xpathResult.get(0));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserEnumTest extends ApexParserTestBase {    @Test    public void testEnumName() {        ApexNode<Compilation> node = parse("class Foo { enum Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserEnum enumNode = node.getFirstDescendantOfType(ASTUserEnum.class);        Assert.assertNotNull(enumNode);        Assert.assertEquals("Bar", enumNode.getImage());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.ParseException;public class ApexCompilerTest extends ApexParserTestBase {    @Test(expected = ParseException.class)    public void compileShouldFail() {        apex.parse("public class Foo { private String myField = \"a\"; }");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;public class ASTUserTriggerTest extends ApexParserTestBase {    @Test    public void testTriggerName() {        ApexNode<?> node = parse("trigger HelloWorldTrigger on Book__c (before insert, after update) {\n"                + "   Book__c[] books = Trigger.new;\n" + "   MyHelloWorld.applyDiscount(books);\n" + "}\n");        Assert.assertSame(ASTUserTrigger.class, node.getClass());        Assert.assertEquals("HelloWorldTrigger", node.getImage());        ASTUserTrigger trigger = (ASTUserTrigger) node;        Assert.assertEquals("Book__c", trigger.getTargetName());        Assert.assertEquals(Arrays.asList(TriggerUsage.AFTER_UPDATE, TriggerUsage.BEFORE_INSERT), trigger.getUsages());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.Arrays;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserClassTest extends ApexParserTestBase {    @Test    public void testClassName() {        ApexNode<Compilation> node = parse("class Foo { }");        Assert.assertSame(ASTUserClass.class, node.getClass());        Assert.assertEquals("Foo", node.getImage());    }    @Test    public void testInnerClassName() {        ApexNode<Compilation> node = parse("class Foo { class Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass innerNode = node.getFirstDescendantOfType(ASTUserClass.class);        Assert.assertNotNull(innerNode);        Assert.assertEquals("Bar", innerNode.getImage());    }    @Test    public void testSuperClassName() {        ApexNode<?> node = parse("public class AccountTriggerHandler extends TriggerHandler {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals("TriggerHandler", toplevel.getSuperClassName());    }    @Test    public void testSuperClassName2() {        ApexNode<?> node = parse("public class AccountTriggerHandler extends Other.TriggerHandler {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals("Other.TriggerHandler", toplevel.getSuperClassName());    }    @Test    public void testInterfaces() {        ApexNode<?> node = parse("public class AccountTriggerHandler implements TriggerHandler, Other.Interface2 {}");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserClass toplevel = (ASTUserClass) node;        Assert.assertEquals(Arrays.asList("TriggerHandler", "Other.Interface2"), toplevel.getInterfaceNames());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTTryCatchFinallyBlockStatementTest extends ApexParserTestBase {    @Test    public void testTryFinally() {        ApexNode<Compilation> node = parse("class Foo { void bar() { try { methodCall(); } finally { methodCall(); } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        Assert.assertNotNull(statement.getTryBlock());        Assert.assertEquals(0, statement.getTryBlock().getIndexInParent());        Assert.assertNotNull(statement.getFinallyBlock());        Assert.assertEquals(1, statement.getFinallyBlock().getIndexInParent());        Assert.assertEquals(0, statement.getCatchClauses().size());    }    @Test    public void testTryCatch() {        ApexNode<Compilation> node = parse("class Foo { void bar() { try { methodCall(); } catch (Exception e) { methodCall(); } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        Assert.assertNotNull(statement.getTryBlock());        Assert.assertEquals(0, statement.getTryBlock().getIndexInParent());        Assert.assertNull(statement.getFinallyBlock());        Assert.assertEquals(1, statement.getCatchClauses().size());        Assert.assertNotNull(statement.getCatchClauses().get(0).getBody());        Assert.assertEquals(1, statement.getCatchClauses().get(0).getIndexInParent());    }    @Test    public void testTryCatchFinally() {        ApexNode<Compilation> node = parse("class Foo { void bar() { try { methodCall(); } catch (Exception e) { methodCall(); } finally { } } }");        ASTTryCatchFinallyBlockStatement statement = node.getFirstDescendantOfType(ASTTryCatchFinallyBlockStatement.class);        Assert.assertNotNull(statement.getTryBlock());        Assert.assertEquals(0, statement.getTryBlock().getIndexInParent());        Assert.assertNotNull(statement.getFinallyBlock());        Assert.assertEquals(2, statement.getFinallyBlock().getIndexInParent());        Assert.assertEquals(1, statement.getCatchClauses().size());        Assert.assertNotNull(statement.getCatchClauses().get(0).getBody());        Assert.assertEquals(1, statement.getCatchClauses().get(0).getIndexInParent());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Test;import net.sourceforge.pmd.lang.ast.test.BaseParsingHelper;import net.sourceforge.pmd.lang.ast.test.BaseTreeDumpTest;import net.sourceforge.pmd.lang.ast.test.RelevantAttributePrinter;public class ApexTreeDumpTest extends BaseTreeDumpTest {    public ApexTreeDumpTest() {        super(new RelevantAttributePrinter(), ".cls");    }    @Override    public BaseParsingHelper<?, ?> getParser() {        return ApexParsingHelper.DEFAULT;    }    @Test    public void safeNavigationOperator() throws Exception {        doTest("SafeNavigationOperator");    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTFieldTest extends ApexParserTestBase {    @Test    public void testGetType() {        ApexNode<Compilation> node = parse("public class Foo { private String myField = 'a'; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertEquals("myField", field.getImage());        Assert.assertEquals("String", field.getType());        Assert.assertEquals("a", field.getValue());    }    @Test    public void testGetValue() {        ApexNode<Compilation> node = parse("public class Foo { private String myField = 'a'; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertEquals("a", field.getValue());    }    @Test    public void testGetNoValue() {        ApexNode<Compilation> node = parse("public class Foo { private String myField; }");        ASTField field = node.getFirstDescendantOfType(ASTField.class);        Assert.assertNull(field.getValue());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTSwitchStatementTest extends ApexParserTestBase {    @Test    public void testExamples() {        ApexNode<Compilation> node = parseResource("SwitchStatements.cls");        List<ASTSwitchStatement> switchStatements = node.findDescendantsOfType(ASTSwitchStatement.class);        Assert.assertEquals(4, switchStatements.size());        Assert.assertTrue(switchStatements.get(0).getChild(0) instanceof ASTVariableExpression);        Assert.assertEquals(5, switchStatements.get(0).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(3, switchStatements.get(0).findChildrenOfType(ASTValueWhenBlock.class)                .get(1).findChildrenOfType(ASTLiteralCase.class).size());        Assert.assertEquals(1, switchStatements.get(0).findChildrenOfType(ASTElseWhenBlock.class).size());        Assert.assertTrue(switchStatements.get(1).getChild(0) instanceof ASTMethodCallExpression);        Assert.assertEquals(2, switchStatements.get(1).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(1, switchStatements.get(1).findChildrenOfType(ASTElseWhenBlock.class).size());        Assert.assertTrue(switchStatements.get(2).getChild(0) instanceof ASTVariableExpression);        Assert.assertEquals(2, switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class).size());        Assert.assertEquals("Account", switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class)                .get(0).getType());        Assert.assertEquals("a", switchStatements.get(2).findChildrenOfType(ASTTypeWhenBlock.class)                .get(0).getName());        Assert.assertEquals(1, switchStatements.get(2).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(1, switchStatements.get(2).findChildrenOfType(ASTElseWhenBlock.class).size());        Assert.assertTrue(switchStatements.get(3).getChild(0) instanceof ASTVariableExpression);        Assert.assertEquals(2, switchStatements.get(3).findChildrenOfType(ASTValueWhenBlock.class).size());        Assert.assertEquals(1, switchStatements.get(3).findChildrenOfType(ASTElseWhenBlock.class).size());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.antlr.runtime.ANTLRStringStream;import org.antlr.runtime.CharStream;import org.antlr.runtime.CommonTokenStream;import org.antlr.runtime.Token;import org.junit.Assert;import org.junit.Test;import apex.jorje.data.ast.CompilationUnit;import apex.jorje.parser.impl.ApexLexer;import apex.jorje.parser.impl.ApexParser;public class ApexLexerTest {    private static final String CODE = "public class Foo {\n"            + "   public List<SObject> test1() {\n"            + "       return Database.query(\"Select Id from Account LIMIT 100\");\n"            + "   }\n"            + "}\n";    @Test    public void testLexer() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        Token token = lexer.nextToken();        int tokenCount = 0;        while (token.getType() != Token.EOF) {            tokenCount++;            token = lexer.nextToken();        }        Assert.assertEquals(43, tokenCount);    }    @Test    public void testParser() throws Exception {        CharStream in = new ANTLRStringStream(CODE);        ApexLexer lexer = new ApexLexer(in);        ApexParser parser = new ApexParser(new CommonTokenStream(lexer));        CompilationUnit compilationUnit = parser.compilationUnit();        Assert.assertNotNull(compilationUnit);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Test;public class ApexCompilerSoqlTest extends ApexParserTestBase {    private static final String CODE = "public class Foo {\n"        + "   public List<SObject> test1() {\n"        + "       return Database.query(\'Select Id from Account LIMIT 100\');\n"        + "   }\n"        + "}\n";    @Test    public void testSoqlCompilation() {        apex.parse(CODE);    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTSoqlExpressionTest extends ApexParserTestBase {    @Test    public void testQuery() {        ApexNode<Compilation> node = parse("class Foo { void test1() { Account acc = [SELECT col FROM Account]; } }");        ASTSoqlExpression soqlExpression = node.getFirstDescendantOfType(ASTSoqlExpression.class);        Assert.assertEquals("SELECT col FROM Account", soqlExpression.getQuery());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTNewKeyValueObjectExpressionTest extends ApexParserTestBase {    @Test    public void testParameterName() {        ApexNode<Compilation> node = parse("public class Foo { \n"                + "    public void foo(String newName, String tempID) { \n"                + "        if (Contact.sObjectType.getDescribe().isCreateable() && Contact.sObjectType.getDescribe().isUpdateable()) {\n"                + "            upsert new Contact(FirstName = 'First', LastName = 'Last', Phone = '414-414-4414');\n"                + "        }\n" + "    } \n" + "}");        ASTNewKeyValueObjectExpression keyValueExpr = node.getFirstDescendantOfType(ASTNewKeyValueObjectExpression.class);        Assert.assertEquals(3, keyValueExpr.getParameterCount());        List<ASTLiteralExpression> literals = keyValueExpr.findDescendantsOfType(ASTLiteralExpression.class);        Assert.assertEquals(3, literals.size());        Assert.assertEquals("FirstName", literals.get(0).getName());        Assert.assertEquals("LastName", literals.get(1).getName());        Assert.assertEquals("Phone", literals.get(2).getName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotEquals;import static org.junit.Assert.assertNotNull;import static org.junit.Assert.assertNull;import java.util.List;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;/** * @author Clment Fournier */public class ApexQualifiedNameTest extends ApexParserTestBase {    @Test    public void testClass() {        ApexNode<Compilation> root = parse("public class Foo {}");        ApexQualifiedName qname = ASTUserClass.class.cast(root).getQualifiedName();        assertEquals("c__Foo", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    public void testNestedClass() {        ApexNode<Compilation> root = parse("public class Foo { class Bar {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTUserClass.class).getQualifiedName();        assertEquals("c__Foo.Bar", qname.toString());        assertEquals(2, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertNull(qname.getOperation());    }    @Test    public void testSimpleMethod() {        ApexNode<Compilation> root = parse("public class Foo { String foo() {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTMethod.class).getQualifiedName();        assertEquals("c__Foo#foo()", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo()", qname.getOperation());    }    @Test    public void testMethodWithArguments() {        ApexNode<Compilation> root = parse("public class Foo { String foo(String h, Foo g) {}}");        ApexQualifiedName qname = root.getFirstDescendantOfType(ASTMethod.class).getQualifiedName();        assertEquals("c__Foo#foo(String,Foo)", qname.toString());        assertEquals(1, qname.getClasses().length);        assertNotNull(qname.getNameSpace());        assertEquals("foo(String,Foo)", qname.getOperation());    }    @Test    public void testOverLoads() {        ApexNode<Compilation> root = parse("public class Foo { "                                                                 + "String foo(String h) {} "                                                                 + "String foo(int c) {}"                                                                 + "String foo(Foo c) {}}");        List<ASTMethod> methods = root.findDescendantsOfType(ASTMethod.class);        for (ASTMethod m1 : methods) {            for (ASTMethod m2 : methods) {                if (m1 != m2) {                    assertNotEquals(m1.getQualifiedName(), m2.getQualifiedName());                }            }        }    }    @Test    public void testTrigger() {        ApexNode<Compilation> root = parse("trigger myAccountTrigger on Account (before insert, before update) {}");        List<ASTMethod> methods = root.findDescendantsOfType(ASTMethod.class);        for (ASTMethod m : methods) {            assertEquals("c__trigger.Account#myAccountTrigger", m.getQualifiedName().toString());        }    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import static org.hamcrest.MatcherAssert.assertThat;import static org.hamcrest.core.IsInstanceOf.instanceOf;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import org.junit.Assert;import org.junit.Test;import net.sourceforge.pmd.lang.ast.Node;import apex.jorje.semantic.ast.compilation.Compilation;public class ApexParserTest extends ApexParserTestBase {    @Test    public void understandsSimpleFile() {        // Setup        String code = "@isTest\n"            + " public class SimpleClass {\n"            + "    @isTest\n public static void testAnything() {\n"            + "        \n"            + "    }\n"            + "}";        // Exercise        ApexNode<Compilation> rootNode = parse(code);        // Verify        List<ASTMethod> methods = rootNode.findDescendantsOfType(ASTMethod.class);        assertEquals(4, methods.size());    }    private final String testCodeForLineNumbers =              "public class SimpleClass {\n" // line 1            + "    public void method1() {\n" // line 2            + "        System.out.println('abc');\n" // line 3            + "        // this is a comment\n" // line 4            + "    }\n" // line 5            + "}\n"; // line 6    @Test    public void verifyLineColumnNumbers() {        ApexNode<Compilation> rootNode = parse(testCodeForLineNumbers);        assertLineNumbersForTestCode(rootNode);    }    @Test    public void verifyLineColumnNumbersWithWindowsLineEndings() {        String windowsLineEndings = testCodeForLineNumbers.replaceAll(" \n", "\r\n");        ApexNode<Compilation> rootNode = parse(windowsLineEndings);        assertLineNumbersForTestCode(rootNode);    }    private void assertLineNumbersForTestCode(ApexNode<Compilation> rootNode) {        // whole source code, well from the beginning of the class        // name Modifier of the class - doesn't work. This node just        // sees the identifier ("SimpleClass")        // assertPosition(rootNode.getChild(0), 1, 1, 1, 6);        // "public"        assertPosition(rootNode, 1, 14, 6, 2);        // "method1" - starts with identifier until end of its block statement        Node method1 = rootNode.getChild(1);        assertPosition(method1, 2, 17, 5, 5);        // Modifier of method1 - doesn't work. This node just sees the        // identifier ("method1")        // assertPosition(method1.getChild(0), 2, 17, 2, 20); // "public" for        // method1        // BlockStatement - the whole method body        Node blockStatement = method1.getChild(1);        assertTrue(((ASTBlockStatement) blockStatement).hasCurlyBrace());        assertPosition(blockStatement, 2, 27, 5, 5);        // the expression ("System.out...")        Node expressionStatement = blockStatement.getChild(0);        assertPosition(expressionStatement, 3, 9, 3, 34);    }    @Test    public void verifyEndLine() {        String code = "public class SimpleClass {\n" // line 1                + "    public void method1() {\n" // line 2                + "    }\n" // line 3                + "    public void method2() {\n" // line 4                + "    }\n" // line 5                + "}\n"; // line 6        ApexNode<Compilation> rootNode = parse(code);        Node method1 = rootNode.getChild(1);        assertEquals("Wrong begin line", 2, method1.getBeginLine());        assertEquals("Wrong end line", 3, method1.getEndLine());        Node method2 = rootNode.getChild(2);        assertEquals("Wrong begin line", 4, method2.getBeginLine());        assertEquals("Wrong end line", 5, method2.getEndLine());    }    @Test    public void checkComments() {        String code = "public  /** Comment on Class */ class SimpleClass {\n" // line 1            + "    /** Comment on m1 */"            + "    public void method1() {\n" // line 2            + "    }\n" // line 3            + "    public void method2() {\n" // line 4            + "    }\n" // line 5            + "}\n"; // line 6        ApexNode<Compilation> root = parse(code);        assertThat(root, instanceOf(ASTUserClass.class));        ApexNode<?> comment = root.getChild(0);        assertThat(comment, instanceOf(ASTFormalComment.class));        assertPosition(comment, 1, 9, 1, 31);        assertEquals("/** Comment on Class */", ((ASTFormalComment) comment).getToken());        ApexNode<?> m1 = root.getChild(2);        assertThat(m1, instanceOf(ASTMethod.class));        ApexNode<?> comment2 = m1.getChild(0);        assertThat(comment2, instanceOf(ASTFormalComment.class));        assertEquals("/** Comment on m1 */", ((ASTFormalComment) comment2).getToken());    }    @Test    public void parsesRealWorldClasses() throws Exception {        File directory = new File("src/test/resources");        File[] fList = directory.listFiles();        for (File file : fList) {            if (file.isFile() && file.getName().endsWith(".cls")) {                String sourceCode = FileUtils.readFileToString(file, StandardCharsets.UTF_8);                ApexNode<Compilation> rootNode = parse(sourceCode);                Assert.assertNotNull(rootNode);            }        }    }    /**     * See github issue #1546     * @see <a href="https://github.com/pmd/pmd/issues/1546">[apex] PMD parsing exception for Apex classes using 'inherited sharing' keyword</a>     */    @Test    public void parseInheritedSharingClass() throws IOException {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("InheritedSharing.cls"),                StandardCharsets.UTF_8);        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);    }    /**     * See bug #1485     *     * @see <a href="https://sourceforge.net/p/pmd/bugs/1485/">#1485 [apex] Analysis of some apex classes cause a stackoverflow error</a>     */    @Test    public void stackOverflowDuringClassParsing() throws Exception {        String source = IOUtils.toString(ApexParserTest.class.getResourceAsStream("StackOverflowClass.cls"),                StandardCharsets.UTF_8);        ApexNode<Compilation> rootNode = parse(source);        Assert.assertNotNull(rootNode);        int count = visitPosition(rootNode, 0);        Assert.assertEquals(487, count);    }    private int visitPosition(Node node, int count) {        int result = count + 1;        Assert.assertTrue(node.getBeginLine() > 0);        Assert.assertTrue(node.getBeginColumn() > 0);        Assert.assertTrue(node.getEndLine() > 0);        Assert.assertTrue(node.getEndColumn() > 0);        for (int i = 0; i < node.getNumChildren(); i++) {            result = visitPosition(node.getChild(i), result);        }        return result;    }    // TEST HELPER    private static void assertPosition(Node node, int beginLine, int beginColumn, int endLine, int endColumn) {        assertEquals("Wrong begin line", beginLine, node.getBeginLine());        assertEquals("Wrong begin column", beginColumn, node.getBeginColumn());        assertEquals("Wrong end line", endLine, node.getEndLine());        assertEquals("Wrong end column", endColumn, node.getEndColumn());    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import java.util.List;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTMethodTest extends ApexParserTestBase {    @Test    public void testConstructorName() {        ApexNode<Compilation> node = parse("public class Foo { public Foo() {} public void bar() {} }");        Assert.assertSame(ASTUserClass.class, node.getClass());        List<ASTMethod> methods = node.findChildrenOfType(ASTMethod.class);        Assert.assertEquals("Foo", methods.get(0).getImage()); // constructor        Assert.assertEquals("<init>", methods.get(0).getCanonicalName());        Assert.assertEquals("bar", methods.get(1).getImage()); // normal method    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex.ast;import org.junit.Assert;import org.junit.Test;import apex.jorje.semantic.ast.compilation.Compilation;public class ASTUserInterfaceTest extends ApexParserTestBase {    @Test    public void testInterfaceName() {        ApexNode<Compilation> node = parse("interface Foo { }");        Assert.assertSame(ASTUserInterface.class, node.getClass());        Assert.assertEquals("Foo", node.getImage());    }    @Test    public void testInnerInterfaceName() {        ApexNode<Compilation> node = parse("class Foo { interface Bar { } }");        Assert.assertSame(ASTUserClass.class, node.getClass());        ASTUserInterface innerNode = node.getFirstDescendantOfType(ASTUserInterface.class);        Assert.assertNotNull(innerNode);        Assert.assertEquals("Bar", innerNode.getImage());    }    @Test    public void testSuperInterface() {        ApexNode<?> node = parse("public interface CustomInterface extends A {}");        Assert.assertSame(ASTUserInterface.class, node.getClass());        ASTUserInterface toplevel = (ASTUserInterface) node;        Assert.assertEquals("A", toplevel.getSuperInterfaceName());    }    @Test    public void testSuperInterface2() {        ApexNode<?> node = parse("public interface CustomInterface extends Other.A {}");        Assert.assertSame(ASTUserInterface.class, node.getClass());        ASTUserInterface toplevel = (ASTUserInterface) node;        Assert.assertEquals("Other.A", toplevel.getSuperInterfaceName());    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSize;import static net.sourceforge.pmd.lang.ast.test.TestUtilsKt.assertSuppressed;import static org.junit.Assert.assertEquals;import java.util.List;import org.junit.Test;import net.sourceforge.pmd.PMD;import net.sourceforge.pmd.Report;import net.sourceforge.pmd.ViolationSuppressor;import net.sourceforge.pmd.lang.apex.ast.ASTUserClass;import net.sourceforge.pmd.lang.apex.ast.ApexParserTestBase;import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;public class SuppressWarningsTest extends ApexParserTestBase {    // This could be a regular xml test    private static class BarRule extends AbstractApexRule {        @Override        public String getMessage() {            return "someMessage";        }        @Override        public Object visit(ASTUserClass clazz, Object ctx) {            if (clazz.getImage().equalsIgnoreCase("bar")) {                addViolation(ctx, clazz);            }            return super.visit(clazz, ctx);        }        @Override        public String getName() {            return "NoBar";        }    }    @Test    public void testClassLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST1);        assertSize(rpt, 0);        rpt = apex.executeRule(new FooRule(), TEST2);        assertSize(rpt, 0);    }    @Test    public void testInheritedSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST3);        assertSize(rpt, 0);    }    @Test    public void testMethodLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST4);        assertSize(rpt, 1);    }    @Test    public void testConstructorLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST5);        assertSize(rpt, 0);    }    @Test    public void testFieldLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST6);        assertSize(rpt, 1);    }    @Test    public void testParameterLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST7);        assertSize(rpt, 1);    }    @Test    public void testLocalVariableLevelSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST8);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST9);        assertSize(rpt, 1);    }    @Test    public void testSpecificSuppressionMulitpleValues() {        Report rpt = apex.executeRule(new FooRule(), TEST9_MULTIPLE_VALUES);        assertSize(rpt, 0);    }    @Test    public void testNoSuppressionBlank() {        Report rpt = apex.executeRule(new FooRule(), TEST10);        assertSize(rpt, 2);    }    @Test    public void testNoSuppressionSomethingElseS() {        Report rpt = apex.executeRule(new FooRule(), TEST11);        assertSize(rpt, 2);    }    @Test    public void testSuppressAll() {        Report rpt = apex.executeRule(new FooRule(), TEST12);        assertSize(rpt, 0);    }    @Test    public void testSpecificSuppressionAtTopLevel() {        Report rpt = apex.executeRule(new BarRule(), TEST13);        assertSize(rpt, 0);    }    @Test    public void testCommentSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST14);        assertSize(rpt, 0);        assertSuppressed(rpt, 1);    }    @Test    public void testMessageWithCommentSuppression() {        Report rpt = apex.executeRule(new FooRule(), TEST15);        assertSize(rpt, 0);        List<Report.SuppressedViolation> suppressions = assertSuppressed(rpt, 1);        Report.SuppressedViolation suppression = suppressions.get(0);        assertEquals(ViolationSuppressor.NOPMD_COMMENT_SUPPRESSOR, suppression.getSuppressor());        assertEquals("We allow foo here", suppression.getUserMessage());    }    private static final String TEST1 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {}";    private static final String TEST2 = "@SuppressWarnings('PMD')" + PMD.EOL + "public class Foo {" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST3 = "public class Baz {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public class Bar {" + PMD.EOL + "  void bar() {" + PMD.EOL + "   Integer foo;" + PMD.EOL + "  }" + PMD.EOL            + " }" + PMD.EOL + "}";    private static final String TEST4 = "public class Foo {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST5 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " public Bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST6 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('PMD')" + PMD.EOL            + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST7 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL            + " void bar(@SuppressWarnings('PMD') Integer foo) {}" + PMD.EOL + "}";    private static final String TEST8 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('PMD.NoFoo') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST9_MULTIPLE_VALUES = "@SuppressWarnings('PMD.NoFoo, PMD.NoBar')"            + PMD.EOL + "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {" + PMD.EOL            + "  Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST10 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST11 = "public class Bar {" + PMD.EOL + " Integer foo;" + PMD.EOL + " void bar() {"            + PMD.EOL + "  @SuppressWarnings('SomethingElse') Integer foo;" + PMD.EOL + " }" + PMD.EOL + "}";    private static final String TEST12 = "public class Bar {" + PMD.EOL + " @SuppressWarnings('all') Integer foo;"            + PMD.EOL + "}";    private static final String TEST13 = "@SuppressWarnings('PMD.NoBar')" + PMD.EOL + "public class Bar {" + PMD.EOL            + "}";    private static final String TEST14 = "public class Bar {" + PMD.EOL + "Integer foo; // NOPMD" + PMD.EOL + "}";    private static final String TEST15 = "public class Bar {" + PMD.EOL + "Integer foo; //NOPMD We allow foo here" + PMD.EOL + "}";}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.Arrays;import java.util.Collection;import org.junit.runners.Parameterized.Parameters;import net.sourceforge.pmd.AbstractLanguageVersionTest;import net.sourceforge.pmd.lang.LanguageRegistry;import net.sourceforge.pmd.lang.LanguageVersion;public class LanguageVersionTest extends AbstractLanguageVersionTest {    public LanguageVersionTest(String name, String terseName, String version, LanguageVersion expected) {        super(name, terseName, version, expected);    }    @Parameters    public static Collection<?> data() {        return Arrays.asList(new Object[][] { { ApexLanguageModule.NAME, ApexLanguageModule.TERSE_NAME, "35",            LanguageRegistry.getLanguage("Apex").getVersion("35"), }, });    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import java.util.logging.Handler;import java.util.logging.LogRecord;import java.util.logging.Logger;import org.junit.After;import org.junit.Assert;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.SystemErrRule;import net.sourceforge.pmd.RuleSet;import net.sourceforge.pmd.RuleSetLoader;public class DefaultRulesetTest {    @Rule    public final SystemErrRule systemErrRule = new SystemErrRule().enableLog().muteForSuccessfulTests();    @Test    public void loadDefaultRuleset() {        RuleSet ruleset = rulesetLoader().loadFromResource("rulesets/apex/ruleset.xml");        Assert.assertNotNull(ruleset);    }    @After    public void cleanup() {        Handler[] handlers = Logger.getLogger(RuleSetLoader.class.getName()).getHandlers();        for (Handler handler : handlers) {            Logger.getLogger(RuleSetLoader.class.getName()).removeHandler(handler);        }    }    @Test    public void loadQuickstartRuleset() {        Logger.getLogger(RuleSetLoader.class.getName()).addHandler(new Handler() {            @Override            public void publish(LogRecord record) {                Assert.fail("No Logging expected: " + record.getMessage());            }            @Override            public void flush() {            }            @Override            public void close() throws SecurityException {            }        });        RuleSet ruleset = rulesetLoader().loadFromResource("rulesets/apex/quickstart.xml");        Assert.assertNotNull(ruleset);    }    private RuleSetLoader rulesetLoader() {        return new RuleSetLoader().enableCompatibility(false);    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.lang.apex;import net.sourceforge.pmd.AbstractRuleSetFactoryTest;public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.IOException;import java.util.Iterator;import org.apache.commons.io.FilenameUtils;import org.junit.Before;import org.junit.Test;import net.sourceforge.pmd.lang.apex.ApexLanguageModule;public class ApexCpdTest {    private File testdir;    @Before    public void setUp() {        String path = FilenameUtils.normalize("src/test/resources/net/sourceforge/pmd/cpd/issue427");        testdir = new File(path);    }    @Test    public void testIssue427() throws IOException {        CPDConfiguration configuration = new CPDConfiguration();        configuration.setMinimumTileSize(10);        configuration.setLanguage(LanguageFactory.createLanguage(ApexLanguageModule.TERSE_NAME));        CPD cpd = new CPD(configuration);        cpd.add(new File(testdir, "SFDCEncoder.cls"));        cpd.add(new File(testdir, "SFDCEncoderConstants.cls"));        cpd.go();        Iterator<Match> matches = cpd.getMatches();        int duplications = 0;        while (matches.hasNext()) {            matches.next();            duplications++;        }        assertEquals(1, duplications);        Match firstDuplication = cpd.getMatches().next();        assertTrue(firstDuplication.getSourceCodeSlice().startsWith("global with sharing class SFDCEncoder"));    }}
/** * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.cpd;import java.util.Properties;import org.junit.Test;import net.sourceforge.pmd.cpd.test.CpdTextComparisonTest;public class ApexTokenizerTest extends CpdTextComparisonTest {    public ApexTokenizerTest() {        super(".cls");    }    @Override    protected String getResourcePrefix() {        return "../lang/apex/cpd/testdata";    }    @Override    public Tokenizer newTokenizer(Properties properties) {        ApexTokenizer tokenizer = new ApexTokenizer();        tokenizer.setProperties(properties);        return tokenizer;    }    @Test    public void testTokenize() {        doTest("Simple");    }    @Test    public void testTokenizeCaseSensitive() {        doTest("Simple", "_caseSensitive", caseSensitive());    }    /**     * Comments are ignored since using ApexLexer.     */    @Test    public void testTokenizeWithComments() {        doTest("comments");    }    @Test    public void testTabWidth() {        doTest("tabWidth");    }    private Properties caseSensitive() {        return properties(true);    }    private Properties properties(boolean caseSensitive) {        Properties properties = new Properties();        properties.setProperty(ApexTokenizer.CASE_SENSITIVE, Boolean.toString(caseSensitive));        return properties;    }}
/* * BSD-style license; for more info see http://pmd.sourceforge.net/license.html */package net.sourceforge.pmd.it;import java.io.File;import java.nio.file.Path;import org.junit.BeforeClass;import org.junit.ClassRule;import org.junit.rules.TemporaryFolder;import net.sourceforge.pmd.PMDVersion;public abstract class AbstractBinaryDistributionTest {    protected static File getBinaryDistribution() {        return new File(".", "target/pmd-bin-" + PMDVersion.VERSION + ".zip");    }    @ClassRule    public static TemporaryFolder folder = new TemporaryFolder();    /**     * The temporary directory, to which the binary distribution will be extracted.     * It will be deleted again after the test.     */    protected static Path tempDir;    @BeforeClass    public static void setupTempDirectory() throws Exception {        tempDir = folder.newFolder().toPath();        if (getBinaryDistribution().exists()) {            ZipFileExtractor.extractZipFile(getBinaryDistribution().toPath(), tempDir);        }    }}