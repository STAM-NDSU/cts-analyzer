/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * @todo add javadoc comment * @version $Revision: 1.4 $ $Date: 2004/02/18 03:24:19 $ */public class UnivariateRealFunctionUtilsTest extends TestCase {    /**     *       */    public void testLocalMaximumCentered() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.centerDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }         /**     *       */    public void testLocalMaximumForward() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.forwardDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }         /**     *      */    public void testLocalMaximumBackward() {        UnivariateRealFunction function = new SinFunction();        UnivariateRealFunction derivative = UnivariateRealFunctionUtils.backwardDifferenceDerivative(function, 1.0e-5);        testLocalMaximum(derivative);    }        /**     * Find a local extrema, i.e. f'(x) = 0.      */    private void testLocalMaximum(UnivariateRealFunction derivative) {        try {            double maximum = UnivariateRealSolverUtils.solve(derivative, Math.PI / 3.0, Math.PI * 2.0 / 3.0);            assertEquals(maximum, Math.PI / 2.0, 1.0e-5);        } catch (Exception ex) {            fail(ex.getMessage());        }    } }
/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * * To change the template for this generated type comment go to * Window>Preferences>Java>Code Generation>Code and Comments */public class DerivativeOperatorFactoryTest extends TestCase {    /**     * Constructor for DerivativeOperatorFactoryTest.     * @param arg0     */    public DerivativeOperatorFactoryTest(String arg0) {        super(arg0);    }        //UnivariateRealFunction f = new SomeUserDefinedFunction();    //FunctionOperator derivative =      //  DerivativeOperatorFactory.newInstance().getDefaultDerivativeOperator();    //UnivariateRealFunction g = derivative.evaluate( f );    // to obtain the value of f'(0.0) use    //double fprime_at_0 = g.value( 0.0 );}
/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.textui.TestRunner;/** * Test cases for the {@link CholeskySolver} class. * <p> * @author Stefan Koeberle, 11/2003 */public class CholeskySolverTest extends TestCase {            private double[][] m1 = {{1}};        private double m1Det = 1.0d;                private double[][] m2 = {{1, 0} ,                                  {0, 2}};        private double m2Det = 2.0d;                                                 private double[][] m3 = {{1, 0, 0},                                  {0, 2, 0},                                  {0, 0, 3}};        private double m3Det = 6.0d;                                         private double[][] m4 = {{1, 0, 0},                                  {2, 3, 0},                                  {4, 5, 6}};        private double m4Det = 18.0d;                private double[][] m5 = {{ 1,  0,  0,  0,  0},                                  {-2,  3,  0,  0,  0},                                  { 4, -5,  6,  0,  0},                                 { 7,  8, -9, 10,  0},                                 {11, 12, 13, 14, 15}};        private double m5Det = 2700.0d;                                         private double[][] m6 = {{1, 0,  0},                                  {2, 0,  0},                                  {4, 5,  6}};                private double[][] m7 = {{1, 2, 3},                                  {4, 5, 6}};                                    /**      * Creates a new instance of CholeskySolverTest      */    public CholeskySolverTest(String nameOfTest) {        super(nameOfTest);    }//constructor CholeskySolverTest        public void setUp()     throws java.lang.Exception {        super.setUp();    }//setUp           public void tearDown()     throws java.lang.Exception {        super.tearDown();    }//tearDown        public static Test suite() {        TestSuite suite = new TestSuite(CholeskySolverTest.class);        suite.setName("CholeskySolver Tests");        return suite;    }//suite        /**      * tests CholeskySolver.setNumericalZero()      */       public void testNumericalZero() {        CholeskySolver solver = new CholeskySolver();        double numericalZero = 77.77d;        solver.setNumericalZero(numericalZero);        assertEquals(solver.getNumericalZero(), numericalZero, 0.0d);                try {            solver.decompose(                new RealMatrixImpl(new double[][]{{numericalZero/2, 0},                                                  {0, numericalZero/2}}));            fail("testing numericalZero");        } catch (IllegalArgumentException e) {}            }//testNumericalZero            /**      * tests CholeskySolver.decompose(...)      */    public void testDecompose() {                //The following decompositions should succeed.        testDecompose(m1, "Decomposing matrix m1");        testDecompose(m2, "Decomposing matrix m2");        testDecompose(m3, "Decomposing matrix m3");        testDecompose(m4, "Decomposing matrix m4");        testDecompose(m5, "Decomposing matrix m5");                //The following decompositions will fail. An IllegalArgumentException        //should be thrown.        try {            testDecompose(m6, "Decomposing matrix m6");            fail("Decomposing matrix m6");         } catch (IllegalArgumentException e) {}                 try {             CholeskySolver solver = new CholeskySolver();             solver.decompose(new RealMatrixImpl(m7));             fail("Decomposing matrix m7");         } catch (IllegalArgumentException e) {}            }//testDecomposition            /**      * tests CholeskySolver.solve(...)      */    public void testSolve() {        //If there's no matrix, there's no linear euqitation to solve ...        try {             CholeskySolver solver = new CholeskySolver();             solver.solve(new double[] {1,2,3});             fail("solving a liniar equitation with a missing matrix should fail");         } catch (IllegalStateException e) {}        //The following operations should succeed.        testSolve(m1, "Solving matrix m1");          testSolve(m2, "Solving matrix m2");        testSolve(m3, "Solving matrix m3");        testSolve(m4, "Solving matrix m4");        testSolve(m5, "Solving matrix m5");             //The following operations will fail. An IllegalArgumentException        //should be thrown.        try {          testSolve(m6, "Solving matrix m6");          fail("Solving matrix m6");         } catch (IllegalArgumentException e) {}         try {             CholeskySolver solver = new CholeskySolver();             solver.solve(new RealMatrixImpl(m3), new double[] {1, 2, 3, 4});             fail("Solving matrix m3[3x3], v[4]");         } catch (IllegalArgumentException e) {}            }//testDecomposition            /**      * tests CholeskySolver.getDeterminant(...)      */    public void testGetDeterminant() {                //Since no matrix was decomposed, there's no determinant.        try {             CholeskySolver solver = new CholeskySolver();             solver.getDeterminant();             fail("Calculating determinant of missing matrix should fail");         } catch (IllegalStateException e) {}               //These test will suceed.        testGetDeterminant(m1, m1Det, "Calculating determinant of m1");        testGetDeterminant(m2, m2Det, "Calculating determinant of m2");        testGetDeterminant(m3, m3Det, "Calculating determinant of m3");        testGetDeterminant(m4, m4Det, "Calculating determinant of m4");        testGetDeterminant(m5, m5Det, "Calculating determinant of m5");    }//test            /**     * Generates the matrix      * <code>m = lowerTriangularMatrix * lowerTriangularMatrix^T</code>.     * If alle diagonalelements of <code>lowerTriangularMatrix</code> are     * positiv, <code>m</code> will be positiv definit.      * Decomposing <code>m</code> should result in     * <code>lowerTriangularMatrix</code> again. So there's a simple test ...     */    private void testDecompose(double[][] lowerTriangularMatrix, String message)     throws IllegalArgumentException {            RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);        RealMatrix pdMatrix =             triangularMatrix.multiply(triangularMatrix.transpose());                CholeskySolver solver = new CholeskySolver();        solver.decompose(pdMatrix);                assertTrue(message,             areEqual(triangularMatrix, solver.getDecomposition(), 1.0E-10));        }//testDecompose          /**     * Similar to <code> private testDecompose(...)</code>.     */    private void testSolve(double[][] lowerTriangularMatrix, String message)  {              RealMatrix triangularMatrix =             new RealMatrixImpl(lowerTriangularMatrix);        RealMatrixImpl pdMatrix =             (RealMatrixImpl) triangularMatrix.multiply(triangularMatrix.transpose());        CholeskySolver solver =             new CholeskySolver();                double[] c = new double[lowerTriangularMatrix.length];        for (int i=0; i<c.length; i++)             for (int j=0; j<lowerTriangularMatrix[0].length; j++)                 c[i] += lowerTriangularMatrix[i][j];                solver.decompose(pdMatrix);        RealMatrix x = new RealMatrixImpl(solver.solve(c));        assertTrue(message,             areEqual(pdMatrix.multiply(x),  new RealMatrixImpl(c), 1.0E-10));    }//testSolve        /**     * Similar to <code> private testDecompose(...)</code>.     */    private void testGetDeterminant(double[][] lowerTriangularMatrix,                                     double determinant,                                    String message)     throws IllegalArgumentException {            RealMatrix triangularMatrix = new RealMatrixImpl(lowerTriangularMatrix);        RealMatrix pdMatrix =             triangularMatrix.multiply(triangularMatrix.transpose());        double pdDeterminant = determinant * determinant;                CholeskySolver solver = new CholeskySolver();        solver.decompose(pdMatrix);        assertEquals(message, solver.getDeterminant(), pdDeterminant, 1.0E-10);    }//testGetDeterminant            /**     * Are <code>m1</code> and <code>m2</code> equal?     */    private static boolean areEqual(RealMatrix m1, RealMatrix m2, double delta) {                double[][] mv1 = m1.getData();        double[][] mv2 = m2.getData();                if (mv1.length != mv1.length  ||            mv1[0].length != mv2[0].length)             return false;                for (int i=0; i<mv1.length; i++)             for (int j=0; j<mv1[0].length; j++)                 if (Math.abs(mv1[i][j] -mv2[i][j]) > delta)                     return false;                return true;    }//isEqual          /**     * Executes all tests of this class     */    public static void main(String[] args) {        System.out.println("Start");        TestRunner runner = new TestRunner();        runner.doRun(CholeskySolverTest.suite());        System.out.println("End");    }//main    }//class CholeskySolverTest
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.stat.StatUtils;import junit.framework.TestCase;/** * This class contains test cases for the ExpandableDoubleArray. *  * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:18 $ */public abstract class DoubleArrayAbstractTest extends TestCase {protected DoubleArray da = null;// Array used to test rollingprotected DoubleArray ra = null;public DoubleArrayAbstractTest(String name) {super(name);}public void testAdd1000() {for (int i = 0; i < 1000; i++) {da.addElement(i);}assertEquals("Number of elements should be equal to 1000 after adding 1000 values",1000,da.getNumElements());assertEquals("The element at the 56th index should be 56",56.0,da.getElement(56),Double.MIN_VALUE);}public void testGetValues() {double[] controlArray = { 2.0, 4.0, 6.0 };da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);double[] testArray = da.getElements();for (int i = 0; i < da.getNumElements(); i++) {assertEquals("The testArray values should equal the controlArray values, index i: "+ i+ " does not match",testArray[i],controlArray[i],Double.MIN_VALUE);}}public void testAddElementRolling() {ra.addElement(0.5);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElementRolling(2.0);assertEquals("There should be 6 elements in the eda",6,ra.getNumElements());assertEquals("The max element should be 2.0",2.0,            StatUtils.max(ra.getElements()),Double.MIN_VALUE);assertEquals("The min element should be 1.0",1.0,            StatUtils.min(ra.getElements()),Double.MIN_VALUE);for (int i = 0; i < 1024; i++) {ra.addElementRolling(i);}assertEquals("We just inserted 1024 rolling elements, num elements should still be 6",6,ra.getNumElements());}public void testMinMax() {da.addElement(2.0);da.addElement(22.0);da.addElement(-2.0);da.addElement(21.0);da.addElement(22.0);da.addElement(42.0);da.addElement(62.0);da.addElement(22.0);da.addElement(122.0);da.addElement(1212.0);assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE);assertEquals("Max should be 1212.0",1212.0,            StatUtils.max(da.getElements()),Double.MIN_VALUE);}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.8 $ $Date: 2004/02/21 21:35:18 $ */public class ContinuedFractionTest extends TestCase {/** * Constructor for ContinuedFractionTest. * @param name */public ContinuedFractionTest(String name) {super(name);}public void testGoldenRation(){        ContinuedFraction cf = new ContinuedFraction() {public double getA(int n, double x) {return 1.0;}public double getB(int n, double x) {return 1.0;}};                try {            double gr = cf.evaluate(0.0, 10e-9);            assertEquals(1.61803399, gr, 10e-9);        } catch (MathException e) {            fail(e.getMessage());        }}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the MathUtils class. * * @version $Revision: 1.12 $ $Date: 2004/04/12 04:22:09 $ */public final class MathUtilsTest extends TestCase {    public MathUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(MathUtilsTest.class);        suite.setName("MathUtils Tests");        return suite;    }        public void testBinomialCoefficient() {        long[] bcoef5 = {1,5,10,10,5,1};        long[] bcoef6 = {1,6,15,20,15,6,1};        for (int i = 0; i < 6; i++) {            assertEquals("5 choose " + i, bcoef5[i],                 MathUtils.binomialCoefficient(5,i));        }        for (int i = 0; i < 7; i++) {            assertEquals("6 choose " + i, bcoef6[i],                 MathUtils.binomialCoefficient(6,i));        }                for (int n = 1; n < 10; n++) {            for (int k = 0; k <= n; k++) {                assertEquals(n + " choose " + k, binomialCoefficient(n, k),                     MathUtils.binomialCoefficient(n, k));                assertEquals(n + " choose " + k,(double) binomialCoefficient(n, k),                     MathUtils.binomialCoefficientDouble(n, k),Double.MIN_VALUE);                assertEquals(n + " choose " + k,                    Math.log((double) binomialCoefficient(n, k)),                     MathUtils.binomialCoefficientLog(n, k),10E-12);            }        }            /*        * Takes a long time for recursion to unwind, but succeeds        * and yields exact value = 2,333,606,220                assertEquals(MathUtils.binomialCoefficient(34,17),            binomialCoefficient(34,17));       */    }        public void testBinomialCoefficientFail() {        try {            long x = MathUtils.binomialCoefficient(0,0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = MathUtils.binomialCoefficient(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientDouble(0,0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientDouble(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientLog(0,0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.binomialCoefficientLog(4,5);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = MathUtils.binomialCoefficient(67,34);            fail ("expecting ArithmeticException");        } catch (ArithmeticException ex) {            ;        }        double x = MathUtils.binomialCoefficientDouble(1030,515);        assertTrue("expecting infinite binomial coefficient",            Double.isInfinite(x));    }    public void testFactorial() {        for (int i = 1; i < 10; i++) {            assertEquals(i + "! ",factorial(i),MathUtils.factorial(i));            assertEquals(i + "! ",(double)factorial(i),                MathUtils.factorialDouble(i),Double.MIN_VALUE);            assertEquals(i + "! ",Math.log((double)factorial(i)),                MathUtils.factorialLog(i),10E-12);        }    }    public void testFactorialFail() {        try {            long x = MathUtils.factorial(0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorialDouble(0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorialLog(0);            fail ("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = MathUtils.factorial(21);            fail ("expecting ArithmeticException");        } catch (ArithmeticException ex) {            ;        }        assertTrue("expecting infinite factorial value",            Double.isInfinite(MathUtils.factorialDouble(171)));    }    /**     * Exact recursive implementation to test against     */    private long binomialCoefficient(int n, int k) {        if ((n == k) || (k == 0)) {            return 1;        }        if ((k == 1) || (k == n - 1)) {            return n;        }        return binomialCoefficient(n - 1, k - 1) +            binomialCoefficient(n - 1, k);    }    /**     * Finds the largest values of n for which binomialCoefficient and     * binomialCoefficientDouble will return values that fit in a long, double,     * resp.  Remove comments around test below to get this in test-report     *        public void testLimits() {            findBinomialLimits();        }     */    private void findBinomialLimits() {        /**         * will kick out 66 as the limit for long         */        boolean foundLimit = false;        int test = 10;        while (!foundLimit) {            try {                double x = MathUtils.binomialCoefficient(test, test / 2);            } catch (ArithmeticException ex) {                foundLimit = true;                System.out.println                    ("largest n for binomialCoefficient = " + (test - 1) );            }            test++;        }       /**        * will kick out 1029 as the limit for double        */        foundLimit = false;        test = 10;        while (!foundLimit) {            double x = MathUtils.binomialCoefficientDouble(test, test / 2);            if (Double.isInfinite(x)) {                foundLimit = true;                System.out.println                    ("largest n for binomialCoefficientD = " + (test - 1) );            }            test++;        }    }    /**     * Finds the largest values of n for which factiorial and     * factorialDouble will return values that fit in a long, double,     * resp.  Remove comments around test below to get this in test-report        public void testFactiorialLimits() {            findFactorialLimits();        }     */    private void findFactorialLimits() {        /**         * will kick out 20 as the limit for long         */        boolean foundLimit = false;        int test = 10;        while (!foundLimit) {            try {                double x = MathUtils.factorial(test);            } catch (ArithmeticException ex) {                foundLimit = true;                System.out.println                    ("largest n for factorial = " + (test - 1) );            }            test++;        }       /**        * will kick out 170 as the limit for double        */        foundLimit = false;        test = 10;        while (!foundLimit) {            double x = MathUtils.factorialDouble(test);            if (Double.isInfinite(x)) {                foundLimit = true;                System.out.println                    ("largest n for factorialDouble = " + (test - 1) );            }            test++;        }    }    /**     * Exact direct multiplication implementation to test against     */    private long factorial(int n) {        long result = 1;        for (int i = 2; i <= n; i++) {            result *= i;        }        return result;    }    public void testSignDouble() {        double delta = 0.0 ;        assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;        assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;    }    public void testSignFloat() {        float delta = 0.0F ;        assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;        assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;    }    public void testSignByte() {        assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;        assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;    }    public void testSignShort() {        assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;        assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;    }    public void testSignInt() {        assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;        assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;    }    public void testSignLong() {        assertEquals( 1L, MathUtils.indicator( 2L ) ) ;        assertEquals( -1L, MathUtils.indicator( -2L ) ) ;    }       public void testIndicatorDouble() {        double delta = 0.0 ;        assertEquals( 1.0, MathUtils.indicator( 2.0 ), delta ) ;        assertEquals( 1.0, MathUtils.indicator( 0.0 ), delta ) ;        assertEquals( -1.0, MathUtils.indicator( -2.0 ), delta ) ;    }        public void testIndicatorFloat() {        float delta = 0.0F ;        assertEquals( 1.0F, MathUtils.indicator( 2.0F ), delta ) ;        assertEquals( 1.0F, MathUtils.indicator( 0.0F ), delta ) ;        assertEquals( -1.0F, MathUtils.indicator( -2.0F ), delta ) ;    }        public void testIndicatorByte() {        assertEquals( (byte)1, MathUtils.indicator( (byte)2 ) ) ;        assertEquals( (byte)1, MathUtils.indicator( (byte)0 ) ) ;        assertEquals( (byte)(-1), MathUtils.indicator( (byte)(-2) ) ) ;    }        public void testIndicatorShort() {        assertEquals( (short)1, MathUtils.indicator( (short)2 ) ) ;        assertEquals( (short)1, MathUtils.indicator( (short)0 ) ) ;        assertEquals( (short)(-1), MathUtils.indicator( (short)(-2) ) ) ;    }        public void testIndicatorInt() {        assertEquals( (int)1, MathUtils.indicator( (int)(2) ) ) ;        assertEquals( (int)1, MathUtils.indicator( (int)(0) ) ) ;        assertEquals( (int)(-1), MathUtils.indicator( (int)(-2) ) ) ;    }        public void testIndicatorLong() {        assertEquals( 1L, MathUtils.indicator( 2L ) ) ;        assertEquals( 1L, MathUtils.indicator( 0L ) ) ;        assertEquals( -1L, MathUtils.indicator( -2L ) ) ;    }        public void testCosh() {        double x = 3.0;        double expected = 10.06766;        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);    }           public void testSinh() {        double x = 3.0;        double expected = 10.01787;        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);    }           public void testCoshNaN() {        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));    }           public void testSinhNaN() {        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));    }   }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import java.math.BigDecimal;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:18 $ */public class DefaultTransformerTest extends TestCase {    /**     *      */    public void testTransformDouble(){        double expected = 1.0;        Double input = new Double(expected);        DefaultTransformer t = new DefaultTransformer();        try {assertEquals(expected, t.transform(input), 1.0e-4);} catch (MathException e) {// TODO Auto-generated catch blocke.printStackTrace();}    }        /**     *      */    public void testTransformNull(){        DefaultTransformer t = new DefaultTransformer();        try {t.transform(null);fail("Expection MathException");} catch (MathException e) {// expected}    }        /**     *      */    public void testTransformInteger(){        double expected = 1.0;        Integer input = new Integer(1);        DefaultTransformer t = new DefaultTransformer();        try {assertEquals(expected, t.transform(input), 1.0e-4);} catch (MathException e) {// TODO Auto-generated catch blocke.printStackTrace();}    }                /**     *      */    public void testTransformBigDecimal(){        double expected = 1.0;        BigDecimal input = new BigDecimal("1.0");        DefaultTransformer t = new DefaultTransformer();        try {assertEquals(expected, t.transform(input), 1.0e-4);} catch (MathException e) {// TODO Auto-generated catch blocke.printStackTrace();}    }                /**     *      */    public void testTransformString(){        double expected = 1.0;        String input = "1.0";        DefaultTransformer t = new DefaultTransformer();        try {assertEquals(expected, t.transform(input), 1.0e-4);} catch (MathException e) {// TODO Auto-generated catch blocke.printStackTrace();}    }        /**     *      */    public void testTransformObject(){        Boolean input = Boolean.TRUE;        DefaultTransformer t = new DefaultTransformer();        try {t.transform(input);fail("Expecting MathException");} catch (MathException e) {    // expected}    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;/** * This class contains test cases for the ExpandableDoubleArray. *  * @version $Revision: 1.9 $ $Date: 2004/05/04 13:15:47 $ */public class ContractableDoubleArrayTest extends ExpandableDoubleArrayTest {public ContractableDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new ContractableDoubleArray();ra = new ContractableDoubleArray();}    protected ExpandableDoubleArray newInstance(int initialCapacity) {        return new ContractableDoubleArray(initialCapacity);    }    protected ExpandableDoubleArray newInstance() {        return new ContractableDoubleArray();    }        protected ExpandableDoubleArray newInstance(int initialCapacity, float expansionFactor) {        if (expansionFactor < 2.5f) {            return new ContractableDoubleArray(initialCapacity, expansionFactor);        } else {            return newInstance(initialCapacity, expansionFactor, expansionFactor + 1.0f);        }    }    protected ExpandableDoubleArray newInstance(int initialCapacity, float expansionFactor, float contractionFactor) {        return new ContractableDoubleArray(initialCapacity, expansionFactor, contractionFactor);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;/** * This class contains test cases for the ExpandableDoubleArray. *  * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class FixedDoubleArrayTest extends DoubleArrayAbstractTest {public FixedDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new FixedDoubleArray(4000);}/* (non-Javadoc) * @see junit.framework.TestCase#tearDown() */protected void tearDown() throws Exception {da = null;}/** TEST NORMAL OPERATIONS - calling super class test and then checking internal *   storage **/public void testAddElementRolling() {ra = new FixedDoubleArray(6);super.testAddElementRolling();assertEquals( "FixedDoubleArray should have 6 size internal storage", 6, ((FixedDoubleArray) ra).getValues().length);}public void testExceedingElements() {for( int i = 0; i < 3999; i++) {da.addElement( 1.0 );}da.addElement( 1.0 );try {da.addElement( 2.0 );fail( " Adding more than 4000 elements should cause an exception ");} catch( Exception e ) {}da.addElementRolling(2.0);assertEquals( "This is the first rolling add, the first element should be 2.0",2.0, da.getElement(0), Double.MIN_VALUE);}public void testGetExceeding() {try {da.getElement(100);fail( "I haven't added 100 elements to the list yet, trying to getElement(100) should " +"thrown an error");} catch (Exception e ){ }}public void testSetElement() {da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.setElement( 2, 4.0 );assertEquals( "Index 2 should be 4.0", 4.0, da.getElement(2), Double.MIN_VALUE);try {da.setElement(2000, 45.0);fail( "The array does not contain 2000 elements yet, setting this element should" +" cause an excpetion");} catch(Exception e) {}}public void testOnlyRolling() {for( int i = 0; i < 8000; i++) {da.addElementRolling( i );}assertEquals( "The 2000th element should equal 6000",6000.0, da.getElement(2000), Double.MIN_VALUE);}public void testClear() {for( int i = 0; i < 10; i++) {da.addElementRolling(1.0);}assertEquals( "There should be ten elements in the array",10, da.getNumElements() );da.clear();assertEquals( "There should be zero elements in the array",0, da.getNumElements() );for( int i = 0; i < 10; i++) {da.addElementRolling(1.0);}assertEquals( "There should be ten elements in the array",10, da.getNumElements() );}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import junit.framework.TestCase;/** * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:18 $ */public class TransformerMapTest extends TestCase {    /**     *      */    public void testPutTransformer(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertEquals(expected, map.getTransformer(TransformerMapTest.class));    }        /**     *      */    public void testContainsClass(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));    }        /**     *      */    public void testContainsTransformer(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsTransformer(expected));    }    /**     *      */    public void testRemoveTransformer(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        assertTrue(map.containsTransformer(expected));        map.removeTransformer(TransformerMapTest.class);        assertFalse(map.containsClass(TransformerMapTest.class));        assertFalse(map.containsTransformer(expected));    }    /**     *      */    public void testClear(){        NumberTransformer expected = new DefaultTransformer();                TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.containsClass(TransformerMapTest.class));        map.clear();        assertFalse(map.containsClass(TransformerMapTest.class));    }        /**     *      */    public void testClasses(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.classes().contains(TransformerMapTest.class));    }        /**     *      */    public void testTransformers(){        NumberTransformer expected = new DefaultTransformer();        TransformerMap map = new TransformerMap();        map.putTransformer(TransformerMapTest.class, expected);        assertTrue(map.transformers().contains(expected));    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;/** * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:18 $ */public class TestBean {    private Double x = new Double(1.0);        private String y = "1.0";        private Double z = new Double(2.0);        /**     *      */    public Double getX() {        return x;    }    /**     *      */    public String getY() {        return y;    }    /**     *      */    public void setX(Double double1) {        x = double1;    }    /**     *      */    public void setY(String string) {        y = string;    }        /**     *      */    public Double getZ() {        throw new RuntimeException();    }    /**     *      */    public void setZ(Double double1) {        z = double1;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;/** * This class contains test cases for the ExpandableDoubleArray. *  * @version $Revision: 1.10 $ $Date: 2004/05/04 13:15:47 $ */public class ExpandableDoubleArrayTest extends DoubleArrayAbstractTest {public ExpandableDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = newInstance();ra = newInstance();}/* (non-Javadoc) * @see junit.framework.TestCase#tearDown() */protected void tearDown() throws Exception {da = null;ra = null;}/** TEST NORMAL OPERATIONS - calling super class test and then checking internal *   storage **/public void testSetElementArbitraryExpansion() {double[] controlArray = {2.0, 4.0, 6.0};da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);da.setElement(1, 3.0);// Expand the array arbitrarily to 1000 itemsda.setElement(1000, 3.4);assertEquals( "The number of elements should now be 1001, it isn't", da.getNumElements(), 1001);assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,da.getElement( 760 ), Double.MIN_VALUE );assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), Double.MIN_VALUE );assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), Double.MIN_VALUE);}public void testAdd1000() {super.testAdd1000();assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +"16 and an expansion factor of 2.0",1024, ((ExpandableDoubleArray) da).getInternalLength());}public void testAddElementRolling() {super.testAddElementRolling();}public void testSetNumberOfElements() {da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);((ExpandableDoubleArray) da).setNumElements( 3 );assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);try {((ExpandableDoubleArray) da).setNumElements( -3 );fail( "Setting number of elements to negative should've thrown an exception");} catch( IllegalArgumentException iae ) {}((ExpandableDoubleArray) da).setNumElements(1024);assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);}/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */public void testWithInitialCapacity() {ExpandableDoubleArray eDA2 = newInstance(2);assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());int iterations = (int) Math.pow(2.0, 15.0);for( int i = 0; i < iterations; i++) {eDA2.addElement( i );}assertEquals("Number of elements should be equal to 2^15", (int) Math.pow(2.0, 15.0), eDA2.getNumElements());eDA2.addElement( 2.0 );assertEquals("Number of elements should be equals to 2^15 + 1",        ( (int) Math.pow(2.0, 15.0) + 1 ), eDA2.getNumElements() );}public void testWithInitialCapacityAndExpansionFactor() {ExpandableDoubleArray eDA3 = newInstance(3, 3.0f);assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );int iterations = (int) Math.pow(3.0, 7.0);for( int i = 0; i < iterations; i++) {eDA3.addElement( i );}assertEquals("Number of elements should be equal to 3^7", (int) Math.pow(3.0, 7.0), eDA3.getNumElements());eDA3.addElement( 2.0 );assertEquals("Number of elements should be equals to 3^7 + 1",( (int) Math.pow(3.0, 7.0) + 1 ), eDA3.getNumElements() );   assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);}public void testDiscard() {da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);assertEquals( "Number of elements should be 11", 11, da.getNumElements());((ExpandableDoubleArray)da).discardFrontElements(5);assertEquals( "Number of elements should be 6", 6, da.getNumElements());try {            ((ExpandableDoubleArray)da).discardFrontElements(-1);fail( "Trying to discard a negative number of element is not allowed");} catch( Exception e ){}try {            ((ExpandableDoubleArray)da).discardFrontElements( 10000 );fail( "You can't discard more elements than the array contains");} catch( Exception e ){}}/** TEST ERROR CONDITIONS **/public void testIllegalInitialCapacity() {try {ExpandableDoubleArray eDA = newInstance(-3, 2.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the initialCapacity was negative, if it didn't then" +" the range checking of initialCapacity is not working properly" );} catch( IllegalArgumentException iae ) {}try {ExpandableDoubleArray eDA = newInstance(0, 2.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the initialCapacity was ZERO if it didn't then" +" the range checking of initialCapacity is not working properly" );} catch( IllegalArgumentException iae ) {}}public void testIllegalExpansionFactor() {try {ExpandableDoubleArray eDA = newInstance(3, 0.66f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for 0.66 which would shrink the array instead of expand the array");} catch( IllegalArgumentException iae ) {}try {ExpandableDoubleArray eDA = newInstance(3, 0.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for 0.0");} catch( IllegalArgumentException iae) {}try {ExpandableDoubleArray eDA = newInstance(3, -4.35f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for -4.35");} catch( IllegalArgumentException iae) {}}public void testSetOutOfBounds() {try {da.setElement( -1, 2.0);fail( "Cannot set a negative index");} catch( Exception e ){}}public void testGetOutOfBounds() {try {da.getElement(10000);fail( "Cannot get an element that is larger than the number of elements");} catch( Exception e ) {}try {da.getElement(-3);fail("Cannot get a negative index");} catch( Exception e ){}}    protected ExpandableDoubleArray newInstance(int initialCapacity) {        return new ExpandableDoubleArray(initialCapacity);    }    protected ExpandableDoubleArray newInstance() {        return new ExpandableDoubleArray();    }        protected ExpandableDoubleArray newInstance(int initialCapacity, float expansionFactor) {        return new ExpandableDoubleArray(initialCapacity, expansionFactor);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.util;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:18 $ */public class BeanTransformerTest extends TestCase {        /**     *     */    public void testConstructor(){        BeanTransformer b = new BeanTransformer();        assertNull(b.getPropertyName());    }        /**     *     */    public void testConstructorString(){        String name = "property";        BeanTransformer b = new BeanTransformer(name);        assertEquals(name, b.getPropertyName());    }        /**     *     */    public void testSetPropertyName(){        String name = "property";        BeanTransformer b = new BeanTransformer();        b.setPropertyName(name);        assertEquals(name, b.getPropertyName());    }        /**     *      */    public void testTransformNoSuchMethod(){        BeanTransformer b = new BeanTransformer("z");        TestBean target = new TestBean();try {    b.transform(target);fail("Expecting MathException");} catch (MathException e) {// expected}    }        /**     *      */    public void testTransform() {        BeanTransformer b = new BeanTransformer("x");        TestBean target = new TestBean();double value = Double.NaN;try {value = b.transform(target);} catch (MathException e) {// TODO Auto-generated catch blocke.printStackTrace();}TestUtils.assertEquals(1.0, value, 1.0e-2);    }        /**     *      */    public void testTransformInvalidType(){        BeanTransformer b = new BeanTransformer("y");        TestBean target = new TestBean();        try {            try {b.transform(target);} catch (MathException e) {// TODO Auto-generated catch blocke.printStackTrace();}            fail("Expecting ClassCastException");        } catch(ClassCastException ex){            // success        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision: 1.8 $ $Date: 2004/02/21 21:35:17 $ */public class BetaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public BetaTest(String name) {        super(name);    }    private void testRegularizedBeta(double expected, double x, double a,        double b)    {        try {            double actual = Beta.regularizedBeta(x, a, b);            TestUtils.assertEquals(expected, actual, 10e-5);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogBeta(double expected, double a, double b) {        double actual = Beta.logBeta(a, b);        TestUtils.assertEquals(expected, actual, 10e-5);    }    public void testRegularizedBetaNanPositivePositive() {        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);    }    public void testRegularizedBetaPositiveNanPositive() {        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);    }    public void testRegularizedBetaPositivePositiveNan() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);    }        public void testRegularizedBetaNegativePositivePositive() {        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);    }        public void testRegularizedBetaPositiveNegativePositive() {        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);    }        public void testRegularizedBetaPositivePositiveNegative() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);    }        public void testRegularizedBetaZeroPositivePositive() {        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);    }        public void testRegularizedBetaPositiveZeroPositive() {        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);    }        public void testRegularizedBetaPositivePositiveZero() {        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);    }        public void testRegularizedBetaPositivePositivePositive() {        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);    }        public void testLogBetaNanPositive() {        testLogBeta(Double.NaN, Double.NaN, 2.0);    }        public void testLogBetaPositiveNan() {        testLogBeta(Double.NaN, 1.0, Double.NaN);    }        public void testLogBetaNegativePositive() {        testLogBeta(Double.NaN, -1.0, 2.0);    }        public void testLogBetaPositiveNegative() {        testLogBeta(Double.NaN, 1.0, -2.0);    }        public void testLogBetaZeroPositive() {        testLogBeta(Double.NaN, 0.0, 2.0);    }        public void testLogBetaPositiveZero() {        testLogBeta(Double.NaN, 1.0, 0.0);    }        public void testLogBetaPositivePositive() {        testLogBeta(-0.693147, 1.0, 2.0);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.special;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:17 $ */public class GammaTest extends TestCase {    /**     * Constructor for BetaTest.     * @param name     */    public GammaTest(String name) {        super(name);    }    private void testRegularizedGamma(double expected, double a, double x) {        try {            double actual = Gamma.regularizedGammaP(a, x);            TestUtils.assertEquals(expected, actual, 10e-5);        } catch(MathException ex){            fail(ex.getMessage());        }    }    private void testLogGamma(double expected, double x) {        double actual = Gamma.logGamma(x);        TestUtils.assertEquals(expected, actual, 10e-5);    }    public void testRegularizedGammaNanPositive() {        testRegularizedGamma(Double.NaN, Double.NaN, 1.0);    }    public void testRegularizedGammaPositiveNan() {        testRegularizedGamma(Double.NaN, 1.0, Double.NaN);    }        public void testRegularizedGammaNegativePositive() {        testRegularizedGamma(Double.NaN, -1.5, 1.0);    }        public void testRegularizedGammaPositiveNegative() {        testRegularizedGamma(Double.NaN, 1.0, -1.0);    }        public void testRegularizedGammaZeroPositive() {        testRegularizedGamma(Double.NaN, 0.0, 1.0);    }        public void testRegularizedGammaPositiveZero() {        testRegularizedGamma(0.0, 1.0, 0.0);    }        public void testRegularizedGammaPositivePositive() {        testRegularizedGamma(0.632121, 1.0, 1.0);    }        public void testLogGammaNan() {        testLogGamma(Double.NaN, Double.NaN);    }        public void testLogGammaNegative() {        testLogGamma(Double.NaN, -1.0);    }        public void testLogGammaZero() {        testLogGamma(Double.NaN, 0.0);    }        public void testLogGammaPositive() {        testLogGamma(0.693147, 3.0);    }}
/* * * Copyright 2004 The Apache Software Foundation * *  Licensed under the Apache License, Version 2.0 (the "License"); *  you may not use this file except in compliance with the License. *  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * *  Unless required by applicable law or agreed to in writing, software *  distributed under the License is distributed on an "AS IS" BASIS, *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *  See the License for the specific language governing permissions and *  limitations under the License. */package org.apache.commons.math.analysis;import junit.framework.TestCase;/** * @version $Revision: 1.1 $ $Date: 2004/04/27 16:42:32 $ */public class UnivariateRealSolverFactoryImplTest extends TestCase {        /** solver factory */    private UnivariateRealSolverFactory factory;        /** function */    private DifferentiableUnivariateRealFunction function;    /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    protected void setUp() throws Exception {        super.setUp();        factory = new UnivariateRealSolverFactoryImpl();        function = new SinFunction();    }        /**     * @throws java.lang.Exception     * @see junit.framework.TestCase#tearDown()     */    protected void tearDown() throws Exception {        factory = null;        function = null;        super.tearDown();    }    public void testNewBisectionSolverNull() {        try {            UnivariateRealSolver solver = factory.newBisectionSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewBisectionSolverValid() {        UnivariateRealSolver solver = factory.newBisectionSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof BisectionSolver);    }    public void testNewNewtonSolverNull() {        try {            UnivariateRealSolver solver = factory.newNewtonSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewNewtonSolverValid() {        UnivariateRealSolver solver = factory.newNewtonSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof NewtonSolver);    }    public void testNewBrentSolverNull() {        try {            UnivariateRealSolver solver = factory.newBrentSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewBrentSolverValid() {        UnivariateRealSolver solver = factory.newBrentSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof BrentSolver);    }    public void testNewSecantSolverNull() {        try {            UnivariateRealSolver solver = factory.newSecantSolver(null);            fail();        } catch(IllegalArgumentException ex) {            // success        }    }    public void testNewSecantSolverValid() {        UnivariateRealSolver solver = factory.newSecantSolver(function);        assertNotNull(solver);        assertTrue(solver instanceof SecantSolver);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:16 $ */public class UnivariateRealSolverUtilsTest extends TestCase {    /**     *      */    public void testSolveNull(){        try {            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);            fail();        } catch(MathException ex){            fail("math exception should no be thrown.");        } catch(IllegalArgumentException ex){            // success        }    }        /**     *      */    public void testSolveSin(){        try {            double x = UnivariateRealSolverUtils.solve(new SinFunction(), 1.0,                4.0);            assertEquals(Math.PI, x, 1.0e-4);        } catch(MathException ex){            fail("math exception should no be thrown.");        }    }    /**     *      */    public void testSolveAccuracyNull(){        try {            double accuracy = 1.0e-6;            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);            fail();        } catch(MathException ex){            fail("math exception should no be thrown.");        } catch(IllegalArgumentException ex){            // success        }    }        /**     *      */    public void testSolveAccuracySin(){        try {            double accuracy = 1.0e-6;            double x = UnivariateRealSolverUtils.solve(new SinFunction(), 1.0,                4.0, accuracy);            assertEquals(Math.PI, x, accuracy);        } catch(MathException ex){            fail("math exception should no be thrown.");        }    }}
/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;// commons-mathimport org.apache.commons.math.MathException;// junitimport junit.framework.TestCase;/** * Tests the PolynomialFunction implementation of a UnivariateRealFunction. * * @version $Revision: 1.6 $ * @author Matt Cliff <matt@mattcliff.com> */public final class PolynomialFunctionTest extends TestCase {    /** Error tolerance for tests */    protected double tolerance = 1.0e-12;    /**     * tests the value of a constant polynomial.     *     * <p>value of this is 2.5 everywhere.</p>     */    public void testConstants() throws MathException {        double[] c = { 2.5 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] at several (nonsymmetric) places        assertEquals( f.value( 0.0), c[0], tolerance );        assertEquals( f.value( -1.0), c[0], tolerance );        assertEquals( f.value( -123.5), c[0], tolerance );        assertEquals( f.value( 3.0), c[0], tolerance );        assertEquals( f.value( 456.89), c[0], tolerance );                assertEquals(f.degree(), 0);        assertEquals(f.derivative().value(0), 0, tolerance);                assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);    }    /**     * tests the value of a linear polynomial.     *     * <p>This will test the function f(x) = 3*x - 1.5</p>     * <p>This will have the values      *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,     *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>     * </p>     */    public void testLinear() throws MathException {        double[] c = { -1.5, 3.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( -4.5, f.value( -1.0), tolerance );        assertEquals( -9.0, f.value( -2.5), tolerance );        assertEquals( 0.0, f.value( 0.5), tolerance );        assertEquals( 3.0, f.value( 1.5), tolerance );        assertEquals( 7.5, f.value( 3.0), tolerance );                assertEquals(f.degree(), 1);                assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);        }    /**     * Tests a second order polynomial.     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>     *     */    public void testQuadratic() throws MathException {        double[] c = { -2.0, -3.0, 2.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( -0.5), tolerance );        assertEquals( 0.0, f.value( 2.0), tolerance );        assertEquals( -2.0, f.value( 1.5), tolerance );        assertEquals( 7.0, f.value( -1.5), tolerance );        assertEquals( 265.5312, f.value( 12.34), tolerance );        }        /**      * This will test the quintic function      *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>     *     */    public void testQuintic() throws MathException {        double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };        PolynomialFunction f = new PolynomialFunction( c );        // verify that we are equal to c[0] when x=0        assertEquals( f.value( 0.0), c[0], tolerance );        // now check a few other places        assertEquals( 0.0, f.value( 5.0), tolerance );        assertEquals( 0.0, f.value( 1.0), tolerance );        assertEquals( 0.0, f.value( -3.0), tolerance );        assertEquals( 54.84375, f.value( -1.5), tolerance );        assertEquals( -8.06637, f.value( 1.3), tolerance );                assertEquals(f.degree(), 5);        }        /**     * tests the firstDerivative function by comparision     *     * <p>This will test the functions      * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>     * and <tt>h(x) = 6x - 4</tt>     */    public void testfirstDerivativeComparision() throws MathException {        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };        double[] g_coeff = { 6.0, -4.0, 3.0 };        double[] h_coeff = { -4.0, 6.0 };        PolynomialFunction f = new PolynomialFunction( f_coeff );        PolynomialFunction g = new PolynomialFunction( g_coeff );        PolynomialFunction h = new PolynomialFunction( h_coeff );        // compare f' = g        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );        // compare g' = h        // compare f'' = h    }}
/* *  * Copyright (c) 2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test the SplineInterpolator. * * @version $Revision: 1.1 $ $Date: 2004/04/02 20:58:59 $  */public class SplineInterpolatorTest extends TestCase {        /** error tolerance for spline interpolator value at knot points */    protected double knotTolerance = 1E-12;       /** error tolerance for interpolating polynomial coefficients */    protected double coefficientTolerance = 1E-6;        /** error tolerance for interpolated values -- high value is from sin test */    protected double interpolationTolerance = 1E-2;    public SplineInterpolatorTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SplineInterpolatorTest.class);        suite.setName("UnivariateRealInterpolator Tests");        return suite;    }    public void testInterpolateLinearDegenerateTwoSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 1.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);                // Check interpolation        assertEquals(0.4,f.value(0.4), interpolationTolerance);        }    public void testInterpolateLinearDegenerateThreeSegment()        throws Exception {        double x[] = { 0.0, 0.5, 1.0, 1.5 };        double y[] = { 0.0, 0.5, 1.0, 1.5 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1d, 0d, 0d};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);                // Check interpolation        assertEquals(1.4,f.value(1.4), interpolationTolerance);        }    public void testInterpolateLinear() throws Exception {        double x[] = { 0.0, 0.5, 1.0 };        double y[] = { 0.0, 0.5, 0.0 };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                // Verify coefficients using analytical values        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.5d, 0d, -2d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 0d, -3d, 2d};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        }        public void testInterpolateSin() throws Exception {        double x[] =            {                0.0,                Math.PI / 6d,                Math.PI / 2d,                5d * Math.PI / 6d,                Math.PI,                7d * Math.PI / 6d,                3d * Math.PI / 2d,                11d * Math.PI / 6d,                2.d * Math.PI };        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };        UnivariateRealInterpolator i = new SplineInterpolator();        UnivariateRealFunction f = i.interpolate(x, y);        verifyInterpolation(f, x, y);        verifyConsistency((PolynomialSplineFunction) f, x);                /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)         *          * To replicate in R:         *     x[1] <- 0         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)         *     g <- splinefun(x, y, "natural")         *     splinecoef <- eval(expression(z), envir = environment(g))         *     print(splinecoef)          */        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);                 //Check interpolation        assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);         }        public void testIllegalArguments() throws MathException {        // Data set arrays of different size.        UnivariateRealInterpolator i = new SplineInterpolator();        try {            double xval[] = { 0.0, 1.0 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            fail("Failed to detect data set array with different sizes.");        } catch (IllegalArgumentException iae) {        }        // X values not sorted.        try {            double xval[] = { 0.0, 1.0, 0.5 };            double yval[] = { 0.0, 1.0, 2.0 };            i.interpolate(xval, yval);            fail("Failed to detect unsorted arguments.");        } catch (IllegalArgumentException iae) {        }    }        /**     * verifies that f(x[i]) = y[i] for i = 0..n -1 where n is common length -- skips last point.     */    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])      throws Exception{        for (int i = 0; i < x.length - 1; i++) {            assertEquals(f.value(x[i]), y[i], knotTolerance);        }         }        /**     * Verifies that interpolating polynomials satisfy consistency requirement:     *    adjacent polynomials must agree through two derivatives at knot points     */    protected void verifyConsistency(PolynomialSplineFunction f, double x[])     throws Exception {        PolynomialFunction polynomials[] = f.getPolynomials();        for (int i = 1; i < x.length - 2; i++) {            // evaluate polynomials and derivatives at x[i + 1]              assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);             assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),                     polynomials[i + 1].derivative().value(0), 0.5);             assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),                     polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);         }    }    }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Testcase for UnivariateRealSolver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. *  * @version $Revision: 1.11 $ $Date: 2004/02/21 21:35:16 $  */public final class RealSolverTest extends TestCase {    public RealSolverTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(RealSolverTest.class);        suite.setName("UnivariateRealSolver Tests");        return suite;    }    public void testSinZero() throws MathException {        // The sinus function is behaved well around the root at #pi. The second        // order derivative is zero, which means linar approximating methods will        // still converge quadratically.         UnivariateRealFunction f = new SinFunction();        double result;        UnivariateRealSolver solver = new BrentSolver(f);        // Somewhat benign interval. The function is monotone.        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        // Larger and somewhat less benign interval. The function is grows first.        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        solver = new SecantSolver(f);        result = solver.solve(3, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 4 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 5);        result = solver.solve(1, 4);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);    }    public void testQuinticZero() throws MathException {        // The quintic function has zeros at 0, +-0.5 and +-1.        // Around the root of 0 the function is well behaved, with a second derivative        // of zero a 0.        // The other roots are less well to find, in particular the root at 1, because        // the function grows fast for x>1.        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,        // intervals containing these values are harder for the solvers.        UnivariateRealFunction f = new QuinticFunction();        double result;        // Brent-Dekker solver.        UnivariateRealSolver solver = new BrentSolver(f);        // Symmetric bracket around 0. Test whether solvers can handle hitting        // the root in the first iteration.        result = solver.solve(-0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        assertTrue(solver.getIterationCount() <= 2);        // 1 iterations on i586 JDK 1.4.1.        // Asymmetric bracket around 0, just for fun. Contains extremum.        result = solver.solve(-0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        // Large bracket around 0. Contains two extrema.        result = solver.solve(-0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Benign bracket around 0.5, function is monotonous.        result = solver.solve(0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Less benign bracket around 0.5, contains one extremum.        result = solver.solve(0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        // Large, less benign bracket around 0.5, contains both extrema.        result = solver.solve(0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1        // is still a problem.        result = solver.solve(0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Less benign bracket around 1 with extremum.        result = solver.solve(0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        // Large bracket around 1. Monotonous.        result = solver.solve(0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        // Large bracket around 1. Interval contains extremum.        result = solver.solve(0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        // Very large bracket around 1 for testing fast growth behaviour.        result = solver.solve(0.85, 5);        //System.out.println(       //     "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 12 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 13);        // Secant solver.        solver = new SecantSolver(f);        result = solver.solve(-0.2, 0.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 1 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 2);        result = solver.solve(-0.1, 0.3);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 5 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 6);        result = solver.solve(-0.3, 0.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(0.3, 0.7);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(0.2, 0.6);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 6 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 7);        result = solver.solve(0.05, 0.95);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(0.85, 1.25);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 10 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 11);        result = solver.solve(0.8, 1.2);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 8 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 9);        result = solver.solve(0.85, 1.75);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // The followig is especially slow because the solver first has to reduce        // the bracket to exclude the extremum. After that, convergence is rapide.        result = solver.solve(0.55, 1.45);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 7 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 8);        result = solver.solve(0.85, 5);        //System.out.println(        //    "Root: " + result + " Iterations: " + solver.getIterationCount());        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        // 14 iterations on i586 JDK 1.4.1.        assertTrue(solver.getIterationCount() <= 15);        // Static solve method        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);        assertEquals(result, 0, 1E-8);        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);        assertEquals(result, 0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);        assertEquals(result, 0.5, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);        assertEquals(result, 1.0, 1E-6);        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);        assertEquals(result, 1.0, 1E-6);    }}
/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.10 $ $Date: 2004/02/18 03:24:20 $ */public final class BisectionSolverTest extends TestCase {    /**     *     */    public void testSinZero() throws MathException {        UnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }    /**     *     */    public void testQuinticZero() throws MathException {        UnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(-0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }        /**     *      */    public void testSetFunctionValueAccuracy(){        double expected = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        try {            solver.setFunctionValueAccuracy(expected);            assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);        } catch (MathException ex) {            fail(ex.getMessage());        }    }                /**     *      */    public void testResetFunctionValueAccuracy(){        double newValue = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        try {            double oldValue = solver.getFunctionValueAccuracy();            solver.setFunctionValueAccuracy(newValue);            solver.resetFunctionValueAccuracy();            assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);        } catch(MathException ex){            fail(ex.getMessage());        }    }                /**     *      */    public void testSetAbsoluteAccuracy(){        double expected = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        try {            solver.setAbsoluteAccuracy(expected);            assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);        } catch(MathException ex){            fail(ex.getMessage());        }    }                /**     *      */    public void testResetAbsoluteAccuracy(){        double newValue = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        try {            double oldValue = solver.getAbsoluteAccuracy();            solver.setAbsoluteAccuracy(newValue);            solver.resetAbsoluteAccuracy();            assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);        } catch(MathException ex){            fail(ex.getMessage());        }    }                /**     *      */    public void testSetMaximalIterationCount(){        int expected = 100;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        solver.setMaximalIterationCount(expected);        assertEquals(expected, solver.getMaximalIterationCount());    }                /**     *      */    public void testResetMaximalIterationCount(){        int newValue = 10000;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        int oldValue = solver.getMaximalIterationCount();        solver.setMaximalIterationCount(newValue);        solver.resetMaximalIterationCount();        assertEquals(oldValue, solver.getMaximalIterationCount());    }                /**     *      */    public void testSetRelativeAccuracy(){        double expected = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        try {            solver.setRelativeAccuracy(expected);            assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);        } catch(MathException ex){            fail(ex.getMessage());        }    }                /**     *      */    public void testResetRelativeAccuracy(){        double newValue = 1.0e-2;                UnivariateRealFunction f = new QuinticFunction();        UnivariateRealSolver solver = new BisectionSolver(f);        try {            double oldValue = solver.getRelativeAccuracy();            solver.setRelativeAccuracy(newValue);            solver.resetRelativeAccuracy();            assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);        } catch(MathException ex){            fail(ex.getMessage());        }    }        }
/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;import org.apache.commons.math.ConvergenceException;import junit.framework.TestCase;/** * @version $Revision: 1.8 $ $Date: 2004/02/18 03:24:20 $ */public class ConvergenceExceptionTest extends TestCase {    /**     *      */    public void testConstructor(){        ConvergenceException ex = new ConvergenceException();        assertNull(ex.getCause());        assertNull(ex.getMessage());    }        /**     *      */    public void testConstructorMessage(){        String msg = "message";        ConvergenceException ex = new ConvergenceException(msg);        assertNull(ex.getCause());        assertEquals(msg, ex.getMessage());    }        /**     *      */    public void testConstructorMessageCause(){        String outMsg = "outer message";        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(outMsg, cause);        assertEquals(outMsg, ex.getMessage());        assertEquals(cause, ex.getCause());    }        /**     *      */    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        ConvergenceException ex = new ConvergenceException(cause);        assertEquals(cause, ex.getCause());    }}
/* *  * Copyright (c) 2003-2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.analysis;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.1 $ $Date: 2004/04/08 21:19:17 $ */public final class NewtonSolverTest extends TestCase {    /**     *     */    public void testSinZero() throws MathException {        DifferentiableUnivariateRealFunction f = new SinFunction();        double result;                UnivariateRealSolver solver = new NewtonSolver(f);        result = solver.solve(3, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());        result = solver.solve(1, 4);        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());    }    /**     *     */    public void testQuinticZero() throws MathException {        DifferentiableUnivariateRealFunction f = new QuinticFunction();        double result;        UnivariateRealSolver solver = new BisectionSolver(f);        result = solver.solve(-0.2, 0.2);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.1, 0.3);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(-0.3, 0.45);        assertEquals(result, 0, solver.getAbsoluteAccuracy());        result = solver.solve(0.3, 0.7);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.2, 0.6);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.05, 0.95);        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.25);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.8, 1.2);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 1.75);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.55, 1.45);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());        result = solver.solve(0.85, 5);        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());    }}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.SummaryStatistics;/** * Test cases for the TTestImpl class. * * @version $Revision: 1.1 $ $Date: 2004/05/03 03:04:54 $ */public final class TTestTest extends TestCase {    private TTestImpl testStatistic = new TTestImpl();    public TTestTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(TTestTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testT() throws Exception {        double[] observed =            {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0,  88.0, 98.0, 94.0, 101.0, 92.0, 95.0 };        double mu = 100.0;        SummaryStatistics sampleStats = null;        sampleStats = SummaryStatistics.newInstance();        for (int i = 0; i < observed.length; i++) {            sampleStats.addValue(observed[i]);        }        assertEquals("t statistic", -2.82, testStatistic.t(mu, observed), 10E-3);        assertEquals("t statistic", -2.82, testStatistic.t(mu, sampleStats), 10E-3);        double[] nullObserved = null;        try {            testStatistic.t(mu, nullObserved);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        SummaryStatistics nullStats = null;           try {            testStatistic.t(mu, nullStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        double[] emptyObs = {};        try {            testStatistic.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        SummaryStatistics emptyStats =SummaryStatistics.newInstance();           try {            testStatistic.t(mu, emptyStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        double[] tooShortObs = { 1.0 };        try {            testStatistic.t(mu, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }        try {            testStatistic.tTest(mu, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }          SummaryStatistics tooShortStats = SummaryStatistics.newInstance();             tooShortStats.addValue(0d);        tooShortStats.addValue(2d);        try {            testStatistic.t(mu, tooShortStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }        try {            testStatistic.tTest(mu, tooShortStats);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }          double[] oneSidedP =            {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };        SummaryStatistics oneSidedPStats = SummaryStatistics.newInstance();            for (int i = 0; i < oneSidedP.length; i++) {            oneSidedPStats.addValue(oneSidedP[i]);        }        assertEquals("one sample t stat", 3.86, testStatistic.t(0d, oneSidedP), 0.01);        assertEquals("one sample t stat", 3.86, testStatistic.t(0d, oneSidedPStats), 0.01);        assertEquals("one sample p value", 0.00052, testStatistic.tTest(0d, oneSidedP) / 2d, 10E-5);        assertEquals("one sample p value", 0.00052, testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5);        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01));        assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001));        assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));                 try {            testStatistic.tTest(0d, oneSidedP, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }                  try {            testStatistic.tTest(0d, oneSidedPStats, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }          double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };        double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };        SummaryStatistics sampleStats1 = SummaryStatistics.newInstance();          for (int i = 0; i < sample1.length; i++) {            sampleStats1.addValue(sample1[i]);        }        SummaryStatistics sampleStats2 = SummaryStatistics.newInstance();            for (int i = 0; i < sample2.length; i++) {            sampleStats2.addValue(sample2[i]);        }                 // Target comparison values computed using R version 1.8.1 (Linux version)        assertEquals("two sample t stat", 1.6037, testStatistic.t(sample1, sample2), 10E-4);        assertEquals("two sample t stat", 1.6037, testStatistic.t(sampleStats1, sampleStats2), 10E-4);        assertEquals("two sample p value", 0.0644, testStatistic.tTest(sample1, sample2) / 2d, 10E-4);        assertEquals("two sample p value", 0.0644, testStatistic.tTest(sampleStats1, sampleStats2) / 2d, 10E-4);                assertTrue("two sample t-test reject", testStatistic.tTest(sample1, sample2, 0.2));        assertTrue("two sample t-test reject", testStatistic.tTest(sampleStats1, sampleStats2, 0.2));        assertTrue("two sample t-test accept", !testStatistic.tTest(sample1, sample2, 0.1));        assertTrue("two sample t-test accept", !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));             try {            testStatistic.tTest(sample1, sample2, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // exptected        }                 try {            testStatistic.tTest(sampleStats1, sampleStats2, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected         }                  try {            testStatistic.tTest(sample1, tooShortObs, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(sampleStats1, tooShortStats, .01);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.tTest(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }                  try {            testStatistic.tTest(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                  try {            testStatistic.t(sample1, tooShortObs);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                try {            testStatistic.t(sampleStats1, tooShortStats);            fail("insufficient data, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {           // expected        }    }}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the ChiSquareTestImpl class. * * @version $Revision: 1.1 $ $Date: 2004/05/03 03:04:54 $ */public final class ChiSquareTestTest extends TestCase {    private ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();    public ChiSquareTestTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(ChiSquareTestTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testChiSquare() throws Exception {         // Target values computed using R version 1.8.1         // Some assembly required ;-)          //      Use sum((obs - exp)^2/exp) for the chi-square statistic and        //      1 - pchisq(sum((obs - exp)^2/exp), obs.length - 1) for the p-value                long[] observed = {10, 9, 11};        double[] expected = {10, 10, 10};        assertEquals("chi-square statistic", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);        assertEquals("chi-square p-value", 0.9048374, testStatistic.chiSquareTest(expected, observed), 1E-7);                long[] observed1 = { 500, 623, 72, 70, 31 };        double[] expected1 = { 485, 541, 82, 61, 37 };        assertEquals( "chi-square test statistic", 16.41311, testStatistic.chiSquare(expected1, observed1), 1E-5);        assertEquals("chi-square p-value", 0.002512096, testStatistic.chiSquareTest(expected1, observed1), 1E-9);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.003));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.002));        try {            testStatistic.chiSquareTest(expected1, observed1, 95);            fail("alpha out of range, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }                   long[] tooShortObs = { 0 };        double[] tooShortEx = { 1 };        try {            testStatistic.chiSquare(tooShortEx, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        long[] unMatchedObs = { 0, 1, 2, 3 };        double[] unMatchedEx = { 1, 1, 2 };        try {            testStatistic.chiSquare(unMatchedEx, unMatchedObs);            fail("arrays have different lengths, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }        expected[0] = 0;        try {            testStatistic.chiSquareTest(expected, observed, .01);            fail("bad expected count, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            // expected        }      }    public void testChiSquareIndependence() throws Exception {                // Target values computed using R version 1.8.1                 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};        assertEquals( "chi-square test statistic", 22.709, testStatistic.chiSquare(counts), 1E-3);        assertEquals("chi-square p-value", 0.0001448, testStatistic.chiSquareTest(counts), 1E-7);        assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002));        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001));                    long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };        assertEquals( "chi-square test statistic", 0.169, testStatistic.chiSquare(counts2), 1E-3);        assertEquals("chi-square p-value", 0.919, testStatistic.chiSquareTest(counts2), 1E-3);        assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1));                 // ragged input array        long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};        try {            testStatistic.chiSquare(counts3);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }                // insufficient data        long[][] counts4 = {{40, 22, 43}};        try {            testStatistic.chiSquare(counts4);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          }    }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class MaxTest extends StorelessUnivariateStatisticAbstractTest{    protected Max stat;        /**     * @param name     */    public MaxTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MaxTest.class);        suite.setName("Max  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Max();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.max;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.UnivariateStatistic;import org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.12 $ $Date: 2004/03/21 04:26:54 $ */public class PercentileTest extends UnivariateStatisticAbstractTest{    protected Percentile stat;        /**     * @param name     */    public PercentileTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(PercentileTest.class);        suite.setName("Percentile Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Percentile(95.0);                 return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.percentile95;    }    public void testHighPercentile(){        double[] d = new double[]{1, 2, 3};        Percentile p = new Percentile(75);        assertEquals(3.0, p.evaluate(d), 1.0e-5);    }        public void testPercentile() {        double[] d = new double[] {1, 3, 2, 4};        Percentile p = new Percentile(30);        assertEquals(1.5, p.evaluate(d), 1.0e-5);        p.setQuantile(25);        assertEquals(1.25, p.evaluate(d), 1.0e-5);        p.setQuantile(75);        assertEquals(3.75, p.evaluate(d), 1.0e-5);        p.setQuantile(50);        assertEquals(2.5, p.evaluate(d), 1.0e-5);    }        public void testNISTExample() {        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,                 95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682        };        Percentile p = new Percentile(90);         assertEquals(95.1981, p.evaluate(d), 1.0e-4);    }        public void test5() {        Percentile percentile = new Percentile(5);        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.UnivariateStatistic;import org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:18 $ */public class MedianTest extends UnivariateStatisticAbstractTest{    protected Median stat;        /**     * @param name     */    public MedianTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MedianTest.class);        suite.setName("Median  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Median();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.median;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.rank;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class MinTest extends StorelessUnivariateStatisticAbstractTest{    protected Min stat;        /**     * @param name     */    public MinTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MinTest.class);        suite.setName("Min  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Min();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.min;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{    protected StandardDeviation stat;        /**     * @param name     */    public StandardDeviationTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new StandardDeviation();                    return stat;    }    public static Test suite() {        TestSuite suite = new TestSuite(StandardDeviationTest.class);        suite.setName("StandardDeviation Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.std;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{    protected Kurtosis stat;        /**     * @param name     */    public KurtosisTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(KurtosisTest.class);        suite.setName("Kurtosis  Tests");        return suite;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Kurtosis();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.kurt;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{    protected Skewness stat;        /**     * @param name     */    public SkewnessTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Skewness();                    return stat;    }    public static Test suite() {        TestSuite suite = new TestSuite(SkewnessTest.class);        suite.setName("Skewness Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.skew;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. *  * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{    protected Variance stat;        /**     * @param name     */    public VarianceTest(String name) {        super(name);    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Variance();                    return stat;    }    public static Test suite() {        TestSuite suite = new TestSuite(VarianceTest.class);        suite.setName("Variance Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.var;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.1 $ $Date: 2004/04/27 16:42:33 $ */public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{    /** descriptive statistic. */    protected FirstMoment stat;        /**     * @param name     */    public FirstMomentTest(String name) {        super(name);    }        /**     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new FirstMoment();                    return stat;    }    /**     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.mean;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:18 $ */public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{    protected GeometricMean stat;        /**     * @param name     */    public GeometricMeanTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(GeometricMeanTest.class);        suite.setName("Mean  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new GeometricMean();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.geoMean;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.moment;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class MeanTest extends StorelessUnivariateStatisticAbstractTest{    protected Mean stat;        /**     * @param name     */    public MeanTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(MeanTest.class);        suite.setName("Mean  Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Mean();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.mean;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class SumTest extends StorelessUnivariateStatisticAbstractTest{    protected Sum stat;        /**     * @param name     */    public SumTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumTest.class);        suite.setName("Sum Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Sum();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.sum;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfLogs stat;        /**     * @param name     */    public SumLogTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumLogTest.class);        suite.setName("SumLog Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new SumOfLogs();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.sumLog;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.11 $ $Date: 2004/03/21 04:29:20 $ */public class ProductTest extends StorelessUnivariateStatisticAbstractTest{    protected Product stat;        /**     * @param name     */    public ProductTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(ProductTest.class);        suite.setName("Product Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new Product();                    return stat;    }    public double getTolerance() {        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.product;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate.summary;import junit.framework.Test;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.StorelessUnivariateStatisticAbstractTest;import org.apache.commons.math.stat.univariate.UnivariateStatistic;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:18 $ */public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{    protected SumOfSquares stat;        /**     * @param name     */    public SumSqTest(String name) {        super(name);    }    public static Test suite() {        TestSuite suite = new TestSuite(SumSqTest.class);        suite.setName("SumSq Tests");        return suite;    }        /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#getUnivariateStatistic()     */    public UnivariateStatistic getUnivariateStatistic() {               if(stat == null)            stat = new SumOfSquares();                    return stat;    }    /* (non-Javadoc)     * @see org.apache.commons.math.stat.univariate.UnivariateStatisticAbstractTest#expectedValue()     */    public double expectedValue() {        return this.sumSq;    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import java.util.ArrayList;import java.util.List;import org.apache.commons.math.util.NumberTransformer;import org.apache.commons.math.util.TransformerMap;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @version $Revision: 1.1 $ $Date: 2004/04/12 02:27:50 $ */public final class MixedListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = DescriptiveStatistics.LEPTOKURTIC;    private double tolerance = 10E-15;    private TransformerMap transformers = new TransformerMap();        public MixedListUnivariateImplTest(String name) {        super(name);        transformers = new TransformerMap();        transformers.putTransformer(Foo.class, new NumberTransformer() {            public double transform(Object o) {                return Double.parseDouble(((Foo) o).heresFoo());            }        });        transformers.putTransformer(Bar.class, new NumberTransformer() {            public double transform(Object o) {                return Double.parseDouble(((Bar) o).heresBar());            }        });    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);        suite.setName("Mixed List Tests");        return suite;    }    /** test stats */    public void testStats() {        List externalList = new ArrayList();        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);        assertEquals("total count", 0, u.getN(), tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N", n, u.getN(), tolerance);        assertEquals("sum", sum, u.getSum(), tolerance);        assertEquals("sumsq", sumSq, u.getSumsq(), tolerance);        assertEquals("var", var, u.getVariance(), tolerance);        assertEquals("std", std, u.getStandardDeviation(), tolerance);        assertEquals("mean", mean, u.getMean(), tolerance);        assertEquals("min", min, u.getMin(), tolerance);        assertEquals("max", max, u.getMax(), tolerance);        u.clear();        assertEquals("total count", 0, u.getN(), tolerance);    }    public void testN0andN1Conditions() throws Exception {        List list = new ArrayList();        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(u.getMean()));        assertTrue(            "Standard Deviation of n = 0 set should be NaN",            Double.isNaN(u.getStandardDeviation()));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(u.getVariance()));        u.addValue(one);        assertTrue(            "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() ,            u.getMean() == one);                    assertTrue(            "StdDev of n = 1 set should be zero, instead it is: "                + u.getStandardDeviation(),            u.getStandardDeviation() == 0);        assertTrue(            "Variance of n = 1 set should be zero",            u.getVariance() == 0);    }    public void testSkewAndKurtosis() {        ListUnivariateImpl u =            new ListUnivariateImpl(new ArrayList(), transformers);        u.addObject("12.5");        u.addObject(new Integer(12));        u.addObject("11.8");        u.addObject("14.2");        u.addObject(new Foo());        u.addObject("14.5");        u.addObject(new Long(21));        u.addObject("8.2");        u.addObject("10.3");        u.addObject("11.3");        u.addObject(new Float(14.1));        u.addObject("9.9");        u.addObject("12.2");        u.addObject(new Bar());        u.addObject("12.1");        u.addObject("11");        u.addObject(new Double(19.8));        u.addObject("11");        u.addObject("10");        u.addObject("8.8");        u.addObject("9");        u.addObject("12.3");        assertEquals("mean", 12.40455, u.getMean(), 0.0001);        assertEquals("variance", 10.00236, u.getVariance(), 0.0001);        assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);        assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);        u.setWindowSize(10);        u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        assertEquals(            "Geometric mean not expected",            2.213364,            u.getGeometricMean(),            0.00001);        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for (int i = 0; i < 10; i++) {            u.addValue(i + 2);        }        // Values should be (2,3,4,5,6,7,8,9,10,11)        assertEquals(            "Geometric mean not expected",            5.755931,            u.getGeometricMean(),            0.00001);    }    public final class Foo {        public String heresFoo() {            return "14.9";        }    }    public final class Bar {        public String heresBar() {            return "12.0";        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import junit.framework.TestCase;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.11 $ $Date: 2004/03/21 04:24:17 $ */public abstract class UnivariateStatisticAbstractTest extends TestCase {    protected double mean = 12.404545454545455d;    protected double geoMean = 12.070589161633011d;    protected double var = 10.00235930735931d;    protected double std = Math.sqrt(var);    protected double skew = 1.437423729196190d;    protected double kurt = 2.377191264804700d;    protected double min = 8.2d;    protected double max = 21d;    protected double median = 12d;    protected double percentile5 = 8.29d;    protected double percentile95 = 20.82d;    protected double product = 628096400563833396009676.9200400128d;    protected double sumLog = 54.7969806116451507d;    protected double sumSq = 3595.250d;    protected double sum = 272.90d;    protected double tolerance = 10E-12;    protected double[] testArray =        {            12.5,            12,            11.8,            14.2,            14.9,            14.5,            21,            8.2,            10.3,            11.3,            14.1,            9.9,            12.2,            12,            12.1,            11,            19.8,            11,            10,            8.8,            9,            12.3 };    public UnivariateStatisticAbstractTest(String name) {        super(name);    }    public abstract UnivariateStatistic getUnivariateStatistic();    public abstract double expectedValue();    public double getTolerance() {        return tolerance;    }    public void testEvaluation() throws Exception {           assertEquals(            expectedValue(),            getUnivariateStatistic().evaluate(testArray),            getTolerance());    }    }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;/** * Test cases for the {@link Univariate} class. * * @version $Revision: 1.1 $ $Date: 2004/04/12 02:27:50 $ */public final class StoreUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = DescriptiveStatistics.LEPTOKURTIC;    private double tolerance = 10E-15;        public StoreUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(StoreUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();                     assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );            assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );            assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );            u.addValue(one);            assertTrue( "Mean of n = 1 set should be value of single item n1",                u.getMean() == one);            assertTrue( "StdDev of n = 1 set should be zero, instead it is: "                 + u.getStandardDeviation(), u.getStandardDeviation() == 0);            assertTrue( "Variance of n = 1 set should be zero",                 u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();         double[] testArray =         { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();         u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        //assertEquals( "Product not expected",         //    24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected",             2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                //assertEquals( "Product not expected", 39916800.0,         //    u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }        public void testGetSortedValues() {        double[] test1 = {5,4,3,2,1};        double[] test2 = {5,2,1,3,4,0};        double[] test3 = {1};        int[] testi = null;        double[] test4 = null;        RandomData rd = new RandomDataImpl();        tstGetSortedValues(test1);        tstGetSortedValues(test2);        tstGetSortedValues(test3);        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,6);            test4 = new double[6];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,5);            test4 = new double[5];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }            }                private void tstGetSortedValues(double[] test) {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        double[] sorted = u.getSortedValues();        if (sorted.length != test.length) {            fail("wrong length for sorted values array");        }        for (int i = 0; i < sorted.length-1; i++) {            if (sorted[i] > sorted[i+1]) {                fail("sorted values out of sequence");            }        }    }        public void testPercentiles() {        double[] test = {5,4,3,2,1};        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        assertEquals("expecting min",1,u.getPercentile(5),10E-12);        assertEquals("expecting max",5,u.getPercentile(99),10E-12);        assertEquals("expecting middle",3,u.getPercentile(50),10E-12);        try {            double x = u.getPercentile(0);            fail("expecting IllegalArgumentException for getPercentile(0)");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = u.getPercentile(120);            fail("expecting IllegalArgumentException for getPercentile(120)");        } catch (IllegalArgumentException ex) {            ;        }                u.clear();        double[] test2 = {1,2,3,4};        for (int i = 0; i < test2.length; i++) {            u.addValue(test2[i]);        }        assertEquals("Q1",1.25,u.getPercentile(25),10E-12);        assertEquals("Q3",3.75,u.getPercentile(75),10E-12);        assertEquals("Q2",2.5,u.getPercentile(50),10E-12);                u.clear();        double[] test3 = {1};        for (int i = 0; i < test3.length; i++) {            u.addValue(test3[i]);        }        assertEquals("Q1",1,u.getPercentile(25),10E-12);        assertEquals("Q3",1,u.getPercentile(75),10E-12);        assertEquals("Q2",1,u.getPercentile(50),10E-12);                u.clear();        RandomData rd = new RandomDataImpl();        int[] testi = rd.nextPermutation(100,100); // will contain 0-99        for (int j = 0; j < testi.length; j++) {            u.addValue((double) testi[j]);  //OK, laugh at me for the cast        }        for (int i = 1; i < 100; i++) {            assertEquals("percentile " + i,                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);        }                u.clear();        double[] test4 = {1,2,3,4,100};        for (int i = 0; i < test4.length; i++) {            u.addValue(test4[i]);        }        assertEquals("80th",80.8,u.getPercentile(80),10E-12);                u.clear();        assertTrue("empty value set should return NaN",            Double.isNaN(u.getPercentile(50)));    }                                     }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import org.apache.commons.math.analysis.UnivariateRealFunction;import org.apache.commons.math.analysis.UnivariateRealSolverFactory;import org.apache.commons.math.analysis.UnivariateRealSolverUtils;import org.apache.commons.math.random.RandomData;import org.apache.commons.math.random.RandomDataImpl;/** * Test cases for the {@link Univariate} class. * * @version $Revision: 1.4 $ $Date: 2004/05/03 23:16:39 $ */public final class DescriptiveStatisticsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = DescriptiveStatistics.LEPTOKURTIC;    private double tolerance = 10E-15;        public DescriptiveStatisticsTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);        suite.setName("Descriptive Statistics Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();                    assertTrue("Mean of n = 0 set should be NaN",                 Double.isNaN( u.getMean() ) );            assertTrue("Standard Deviation of n = 0 set should be NaN",                 Double.isNaN( u.getStandardDeviation() ) );            assertTrue("Variance of n = 0 set should be NaN",                Double.isNaN(u.getVariance() ) );            u.addValue(one);            assertTrue( "Mean of n = 1 set should be value of single item n1",                u.getMean() == one);            assertTrue( "StdDev of n = 1 set should be zero, instead it is: "                 + u.getStandardDeviation(), u.getStandardDeviation() == 0);            assertTrue( "Variance of n = 1 set should be zero",                 u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();        double[] testArray =         { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        //assertEquals( "Product not expected",         //    24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected",             2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                //assertEquals( "Product not expected", 39916800.0,         //    u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }    public void testAddValue() {double[] test1 = {5,4,3,2,1,0};double[] test2 = {5,2,1,0,4,3};DescriptiveStatistics stats = DescriptiveStatistics.newInstance();stats.setWindowSize(12);for(int i = 0; i < test1.length; i++){stats.addValue(test1[i]);}     double[] test3 = stats.getValues();for(int i = 0; i < 6; i++){assertEquals( "Added value ["+i+"] not equal", test3[i], test1[i],0.0);//System.out.println(test3[i] + " "+test1[i]);}     for(int i = 0; i < test2.length; i++){stats.addValue(test2[i]);}      test3 = stats.getValues();  for(int i = 6; i < 12; i++){assertEquals( "Added value ["+i+"] not equal", test3[i], test2[i-6],0.0);//System.out.println(test3[i] + " "+test2[i-6]);}    for(int i = 0; i < test2.length; i++){stats.addValue(test2[i]);}      test3 = stats.getValues();  for(int i = 0; i < 6; i++){assertEquals( "Added value ["+i+"] not equal", test3[i], test2[i],0.0);//System.out.println(test3[i] + " "+test2[i]);}  for(int i = 6; i < 12; i++){assertEquals( "Added value ["+i+"] not equal", test3[i], test2[i-6],0.0);//System.out.println(test3[i] + " "+test2[i-6]);}   }    public void testGetSortedValues() {        double[] test1 = {5,4,3,2,1};        double[] test2 = {5,2,1,3,4,0};        double[] test3 = {1};        int[] testi = null;        double[] test4 = null;        RandomData rd = new RandomDataImpl();        tstGetSortedValues(test1);        tstGetSortedValues(test2);        tstGetSortedValues(test3);        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,6);            test4 = new double[6];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }        for (int i = 0; i < 10; i++) {            testi = rd.nextPermutation(10,5);            test4 = new double[5];            for (int j = 0; j < testi.length; j++) {                test4[j] = (double) testi[j];            }            tstGetSortedValues(test4);        }            }                        private void tstGetSortedValues(double[] test) {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(test.length);        for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        double[] sorted = u.getSortedValues();        if (sorted.length != test.length) {            fail("wrong length for sorted values array");        }        for (int i = 0; i < sorted.length-1; i++) {            if (sorted[i] > sorted[i+1]) {                fail("sorted values out of sequence");            }        }    }        public void testPercentiles() {        double[] test = {5,4,3,2,1};        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(110);        for (int i = 0; i < test.length; i++) {            u.addValue(test[i]);        }        assertEquals("expecting min",1,u.getPercentile(5),10E-12);        assertEquals("expecting max",5,u.getPercentile(99),10E-12);        assertEquals("expecting middle",3,u.getPercentile(50),10E-12);        try {            double x = u.getPercentile(0);            fail("expecting IllegalArgumentException for getPercentile(0)");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = u.getPercentile(120);            fail("expecting IllegalArgumentException for getPercentile(120)");        } catch (IllegalArgumentException ex) {            ;        }                u.clear();        double[] test2 = {1,2,3,4};        for (int i = 0; i < test2.length; i++) {            u.addValue(test2[i]);        }        assertEquals("Q1",1.25,u.getPercentile(25),10E-12);        assertEquals("Q3",3.75,u.getPercentile(75),10E-12);        assertEquals("Q2",2.5,u.getPercentile(50),10E-12);                u.clear();        double[] test3 = {1};        for (int i = 0; i < test3.length; i++) {            u.addValue(test3[i]);        }        assertEquals("Q1",1,u.getPercentile(25),10E-12);        assertEquals("Q3",1,u.getPercentile(75),10E-12);        assertEquals("Q2",1,u.getPercentile(50),10E-12);                u.clear();        RandomData rd = new RandomDataImpl();        int[] testi = rd.nextPermutation(100,100); // will contain 0-99        for (int j = 0; j < testi.length; j++) {            u.addValue((double) testi[j]);  //OK, laugh at me for the cast        }        for (int i = 1; i < 100; i++) {            assertEquals("percentile " + i,                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);        }                u.clear();        double[] test4 = {1,2,3,4,100};        for (int i = 0; i < test4.length; i++) {            u.addValue(test4[i]);        }        assertEquals("80th",80.8,u.getPercentile(80),10E-12);                u.clear();        assertTrue("empty value set should return NaN",            Double.isNaN(u.getPercentile(50)));    }                          /** test stats */    public void testSerialization() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);                DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);          u2.addValue(two);        u2.addValue(three);                assertEquals("N",n,u2.getN(),tolerance);        assertEquals("sum",sum,u2.getSum(),tolerance);        assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance);        assertEquals("var",var,u2.getVariance(),tolerance);        assertEquals("std",std,u2.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u2.getMean(),tolerance);        assertEquals("min",min,u2.getMin(),tolerance);        assertEquals("max",max,u2.getMax(),tolerance);        u2.clear();        assertEquals("total count",0,u2.getN(),tolerance);        }           public void testNewInstanceStringNull() {        try {            DescriptiveStatistics u = DescriptiveStatistics.newInstance((String)null);            fail("null is not a valid descriptive statistics class name");        } catch (NullPointerException ex) {            // success        } catch (Exception ex) {            fail();        }            }        public void testNewInstanceStringValid() {        try {            DescriptiveStatistics u = DescriptiveStatistics.newInstance(            "org.apache.commons.math.stat.univariate.DescriptiveStatisticsImpl");            assertNotNull(u);            assertTrue(u instanceof DescriptiveStatisticsImpl);        } catch (Exception ex) {            fail();        }    }    public void testNewInstanceClassNull() {        try {            DescriptiveStatistics u = DescriptiveStatistics.newInstance((Class)null);            fail("null is not a valid descriptive statistics class");        } catch (NullPointerException ex) {            // success        } catch (Exception ex) {            fail();        }            }        public void testNewInstanceClassValid() {        try {            DescriptiveStatistics u = DescriptiveStatistics.newInstance(                DescriptiveStatisticsImpl.class);            assertNotNull(u);            assertTrue(u instanceof DescriptiveStatisticsImpl);        } catch (Exception ex) {            fail();        }    }        public void testWindowSize() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(1234);        assertEquals(1234, u.getWindowSize());                u.addValue(1.0);        u.addValue(2.0);        u.addValue(3.0);        u.addValue(4.0);        u.addValue(5.0);        assertEquals(5, u.getN());                u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);        assertEquals(5, u.getN());    }        public void testWindowing() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(2);                u.addValue(1.0);        assertEquals(1.0, u.getMean(), tolerance);                u.addValue(2.0);        assertEquals(1.5, u.getMean(), tolerance);                u.addValue(3.0);        assertEquals(2.5, u.getMean(), tolerance);                u.setWindowSize(1);        assertEquals(3.0, u.getMean(), tolerance);    }        public void testKurtosisClass() {        DescriptiveStatistics u = DescriptiveStatistics.newInstance();        u.setWindowSize(5);                u.addValue(1.0);        u.addValue(1.0);        u.addValue(2.0);        u.addValue(1.0);        u.addValue(1.0);        assertEquals(DescriptiveStatistics.LEPTOKURTIC, u.getKurtosisClass());                u.addValue(1.0);        u.addValue(2.0);        u.addValue(2.0);        u.addValue(2.0);        u.addValue(1.0);        assertEquals(DescriptiveStatistics.PLATYKURTIC, u.getKurtosisClass());//        //        u.addValue(1.0);//        u.addValue(1.5);//        u.addValue(2.0912994180548905);//        u.addValue(1.5);//        u.addValue(1.0);//        assertEquals(DescriptiveStatistics.MESOKURTIC, u.getKurtosisClass());    }}
/* *  * Copyright (c) 2004 The Apache Software Foundation. All rights reserved. *  * Licensed under the Apache License, Version 2.0 (the "License"); you may not * use this file except in compliance with the License. You may obtain a copy * of the License at *  * http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. *   */package org.apache.commons.math.stat.univariate;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.univariate.moment.Mean;/** * Tests for AbstractUnivariateStatistic  * * @version $Revision: 1.3 $ $Date: 2004/04/12 12:00:41 $ */public class AbstractUnivariateStatisticTest extends TestCase {        public AbstractUnivariateStatisticTest(String name) {        super(name);    }        public static Test suite() {        TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);        suite.setName("AbstractUnivariateStatistic Tests");        return suite;    }        protected double[] testArray = {0, 1, 2, 3, 4, 5};    protected double[] nullArray = null;    protected double[] singletonArray = {0};    protected Mean testStatistic = new Mean();        public void testTestPositive() {        for (int j = 0; j < 6; j++) {            for (int i = 1; i < (7 - j); i++) {                assertTrue(testStatistic.test(testArray, 0, i));            }          }        assertTrue(testStatistic.test(singletonArray, 0, 1));    }        public void testTestNegative() {        assertFalse(testStatistic.test(singletonArray, 0, 0));        assertFalse(testStatistic.test(testArray, 0, 0));        try {            testStatistic.test(singletonArray, 2, 1);  // start past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, 7);  // end past end            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, -1, 1);  // start negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(testArray, 0, -1);  // length negative            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }        try {            testStatistic.test(nullArray, 0, 1);  // null array            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            // expected        }          } }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @version $Revision: 1.1 $ $Date: 2004/04/12 02:27:50 $ */public final class ListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = DescriptiveStatistics.LEPTOKURTIC;    private double tolerance = 10E-15;        public ListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {    List externalList = new ArrayList();            DescriptiveStatistics u = new ListUnivariateImpl( externalList );         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    List list = new ArrayList();        DescriptiveStatistics u = new ListUnivariateImpl( list );        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );list.add( new Double(one));assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    DescriptiveStatistics u = DescriptiveStatistics.newInstance();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,     9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import org.apache.commons.math.stat.univariate.moment.FourthMoment;import org.apache.commons.math.stat.univariate.moment.Kurtosis;import org.apache.commons.math.stat.univariate.moment.Mean;import org.apache.commons.math.stat.univariate.moment.Skewness;import org.apache.commons.math.stat.univariate.moment.Variance;import junit.framework.TestCase;/** * @version $Revision: 1.9 $ $Date: 2004/02/21 21:35:17 $ */public class InteractionTest extends TestCase {    protected double mean = 12.40454545454550;    protected double var = 10.00235930735930;    protected double skew = 1.437423729196190;    protected double kurt = 2.377191264804700;    protected double tolerance = 10E-12;    protected double[] testArray =        {            12.5,            12,            11.8,            14.2,            14.9,            14.5,            21,            8.2,            10.3,            11.3,            14.1,            9.9,            12.2,            12,            12.1,            11,            19.8,            11,            10,            8.8,            9,            12.3 };    public InteractionTest(String name) {        super(name);    }    public void testInteraction() {                FourthMoment m4 = new FourthMoment();        Mean m = new Mean(m4);        Variance v = new Variance(m4);        Skewness s= new Skewness(m4);        Kurtosis k = new Kurtosis(m4);        for (int i = 0; i < testArray.length; i++){            m4.increment(testArray[i]);            m.increment(testArray[i]);            v.increment(testArray[i]);            s.increment(testArray[i]);            k.increment(testArray[i]);        }                assertEquals(mean,m.getResult(),tolerance);        assertEquals(var,v.getResult(),tolerance);        assertEquals(skew ,s.getResult(),tolerance);        assertEquals(kurt,k.getResult(),tolerance);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link DescriptiveStatistics} class. * * @version $Revision: 1.4 $ $Date: 2004/04/12 02:27:50 $ */public final class UnivariateImplTest extends TestCase {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;        public UnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(UnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        SummaryStatistics u = SummaryStatistics.newInstance();        assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    SummaryStatistics u = SummaryStatistics.newInstance();        assertTrue("Mean of n = 0 set should be NaN",             Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN",             Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN",             Double.isNaN(u.getVariance() ) );/* n=1 */u.addValue(one);assertTrue("mean should be one (n = 1)", u.getMean() == one);assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), u.getGeometricMean() == one);assertTrue("Std should be zero (n = 1)", u.getStandardDeviation() == 0.0);assertTrue("variance should be zero (n = 1)", u.getVariance() == 0.0);/* n=2 */u.addValue(twoF);assertTrue("Std should not be zero (n = 2)", u.getStandardDeviation() != 0.0);assertTrue("variance should not be zero (n = 2)", u.getVariance() != 0.0);                }    public void testProductAndGeometricMean() throws Exception {    SummaryStatistics u = SummaryStatistics.newInstance();                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Geometric mean not expected", 2.213364,             u.getGeometricMean(), 0.00001 );    }        public void testNaNContracts() {    SummaryStatistics u = SummaryStatistics.newInstance();        double nan = Double.NaN;        assertTrue("mean not NaN",Double.isNaN(u.getMean()));         assertTrue("min not NaN",Double.isNaN(u.getMin()));         assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));         assertTrue("var not NaN",Double.isNaN(u.getVariance()));         assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(1.0);                assertEquals( "mean not expected", 1.0,             u.getMean(), Double.MIN_VALUE);        assertEquals( "variance not expected", 0.0,             u.getVariance(), Double.MIN_VALUE);        assertEquals( "geometric mean not expected", 1.0,             u.getGeometricMean(), Double.MIN_VALUE);                u.addValue(-1.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(0.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                //FiXME: test all other NaN contract specs    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.stat.StatUtils;import org.apache.commons.math.beans.VitalStats;import org.apache.commons.math.beans.Patient;/** * Test cases for the {@link BeanListUnivariateImpl} class. * * @version $Revision: 1.2 $ $Date: 2004/04/24 21:43:26 $ */public final class BeanListUnivariateImplTest extends TestCase {        private List patientList = null;    private double tolerance = Double.MIN_VALUE;        public BeanListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {          patientList = new ArrayList();        // Create and add patient bean 1        VitalStats vs1 = new VitalStats( new Double(120.0),                                          new Double(96.4) );        Patient p1 = new Patient( vs1, new Integer( 35 ) );        patientList.add( p1 );        // Create and add patient bean 2        VitalStats vs2 = new VitalStats( new Double(70.0),                                          new Double(97.4) );        Patient p2 = new Patient( vs2, new Integer( 23 ) );        patientList.add( p2 );        // Create and add patient bean 3        VitalStats vs3 = new VitalStats( new Double(90.0),                                          new Double(98.6) );        Patient p3 = new Patient( vs3, new Integer( 42 ) );        patientList.add( p3 );    }        public static Test suite() {        TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test stats */    public void testStats() {        DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         double[] values = {35d, 23d, 42d};        assertEquals("total count",3,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);               u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }           public void testPropStats() {        DescriptiveStatistics heartU = new BeanListUnivariateImpl( patientList,                                          "vitalStats.heartRate" );               assertEquals( "Mean heart rate unexpected", 93.333,                       heartU.getMean(), 0.001 );        assertEquals( "Max heart rate unexpected", 120.0,                       heartU.getMax(), 0.001 );        DescriptiveStatistics ageU = new BeanListUnivariateImpl( patientList,                                                           "age" );        assertEquals( "Mean age unexpected", 33.333,                      ageU.getMean(), 0.001 );        assertEquals( "Max age unexpected", 42.0,                      ageU.getMax(), 0.001 );    }        public void testSetPropertyName(){        BeanListUnivariateImpl u = new BeanListUnivariateImpl(null);        String expected = "property";        u.setPropertyName(expected);        assertEquals(expected, u.getPropertyName());    }        public void testAddValue() {        DescriptiveStatistics u = new BeanListUnivariateImpl( patientList, "age" );         u.addValue(10);        double[] values = {35d, 23d, 42d, 10d};        assertEquals("total count",4,u.getN(),tolerance);        assertEquals("mean", StatUtils.mean(values), u.getMean(), tolerance);        assertEquals("min", StatUtils.min(values), u.getMin(), tolerance);        assertEquals("max", StatUtils.max(values), u.getMax(), tolerance);        assertEquals("var", StatUtils.variance(values), u.getVariance(), tolerance);               u.clear();        assertEquals("total count",0,u.getN(),tolerance);          }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.univariate;import org.apache.commons.math.TestUtils;/** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision: 1.12 $ $Date: 2004/04/27 16:42:32 $ */public abstract class StorelessUnivariateStatisticAbstractTest    extends UnivariateStatisticAbstractTest {    public StorelessUnivariateStatisticAbstractTest(String name) {        super(name);    }    public abstract UnivariateStatistic getUnivariateStatistic();    public abstract double expectedValue();        public void testIncrementation() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);        }        assertEquals(expectedValue(), statistic.getResult(), getTolerance());        statistic.clear();        assertTrue(Double.isNaN(statistic.getResult()));    }    public void testSerialization() throws Exception {        StorelessUnivariateStatistic statistic =            (StorelessUnivariateStatistic) getUnivariateStatistic();        statistic.clear();        for (int i = 0; i < testArray.length; i++) {            statistic.increment(testArray[i]);            if(i % 5 == 0)                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);         }                assertEquals(expectedValue(), statistic.getResult(), getTolerance());        statistic.clear();        assertTrue(Double.isNaN(statistic.getResult()));    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.apache.commons.beanutils.PropertyUtils;import org.apache.commons.lang.StringUtils;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.univariate.DescriptiveStatistics;import org.apache.commons.math.stat.univariate.SummaryStatistics;import junit.framework.TestCase;/** * @version $Revision: 1.2 $ $Date: 2004/04/12 02:27:50 $ */public abstract class CertifiedDataAbstractTest extends TestCase {private DescriptiveStatistics descriptives;private SummaryStatistics summaries;private Map certifiedValues;protected void setUp() throws Exception {descriptives = DescriptiveStatistics.newInstance();summaries = SummaryStatistics.newInstance();certifiedValues = new HashMap();loadData();}private void loadData() throws IOException {BufferedReader in = null;try {URL resourceURL = getClass().getClassLoader().getResource(getResourceName());in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));String line = in.readLine();while (line != null) {line = StringUtils.trimToNull(line);if (line == null) {// empty line} else if (line.startsWith("#")) {// comment} else {int n = line.indexOf('=');if (n == -1) {// data valuedouble value = Double.parseDouble(line);descriptives.addValue(value);summaries.addValue(value);} else {// certified valueString name = line.substring(0, n).trim();String valueString = line.substring(n + 1).trim();Double value = new Double(valueString);certifiedValues.put(name, value);}}line = in.readLine();}} finally {if (in != null) {in.close();}}}/** * @return */protected abstract String getResourceName();protected double getMaximumAbsoluteError() {return 1.0e-5;}protected void tearDown() throws Exception {descriptives.clear();descriptives = null;summaries.clear();summaries = null;certifiedValues.clear();certifiedValues = null;}public void testCertifiedValues() throws Exception {Iterator iter = certifiedValues.keySet().iterator();while (iter.hasNext()) {String name = iter.next().toString();Double expectedValue = (Double)certifiedValues.get(name);try {Double summariesValue = (Double)PropertyUtils.getProperty(summaries, name);TestUtils.assertEquals("summary value for " + name + " is incorrect.",summariesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());} catch (Exception ex) {}try {Double descriptivesValue = (Double)PropertyUtils.getProperty(descriptives, name);TestUtils.assertEquals("descriptive value for " + name + " is incorrect.",descriptivesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError());} catch (Exception ex) {}} }}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision: 1.1 $ $Date: 2004/03/18 05:52:37 $ */public class LotteryTest extends CertifiedDataAbstractTest {protected String getResourceName() {return "org/apache/commons/math/stat/data/Lottery.txt";}}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.data;/** * @version $Revision: 1.1 $ $Date: 2004/03/18 05:52:37 $ */public class LewTest extends CertifiedDataAbstractTest {protected String getResourceName() {return "org/apache/commons/math/stat/data/Lew.txt";}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.multivariate;import java.util.Random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @version $Revision: 1.2 $ $Date: 2004/04/25 19:38:17 $ */public final class BivariateRegressionTest extends TestCase {    /*      * NIST "Norris" refernce data set from      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },             {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },             {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },             {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },             {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },             {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },             {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },             {449.2, 448.9 }, {0.2, 0.5 }    };    /*      * Correlation example from      * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },             {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },             {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },             {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }    };    /*     * From Moore and Mcabe, "Introduction to the Practice of Statistics"     * Example 10.3      */    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }    };    /*     * From http://www.xycoon.com/simple_linear_regression.htm     */    private double[][] infData2 = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};    public BivariateRegressionTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(BivariateRegressionTest.class);        suite.setName("BivariateRegression Tests");        return suite;    }    public void testNorris() {        BivariateRegression regression = new BivariateRegression();        for (int i = 0; i < data.length; i++) {            regression.addData(data[i][1], data[i][0]);        }        assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12);        assertEquals("slope std err", 0.429796848199937E-03,                regression.getSlopeStdErr(),10E-12);        assertEquals("number of observations", 36, regression.getN());        assertEquals( "intercept", -0.262323073774029,            regression.getIntercept(),10E-12);        assertEquals("std err intercept", 0.232818234301152,            regression.getInterceptStdErr(),10E-12);        assertEquals("r-square", 0.999993745883712,            regression.getRSquare(), 10E-12);        assertEquals("SSR", 4255954.13232369,            regression.getRegressionSumSquares(), 10E-9);        assertEquals("MSE", 0.782864662630069,            regression.getMeanSquareError(), 10E-10);        assertEquals("SSE", 26.6173985294224,            regression.getSumSquaredErrors(),10E-9);        assertEquals( "predict(0)",  -0.262323073774029,            regression.predict(0), 10E-12);        assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029,            regression.predict(1), 10E-12);    }    public void testCorr() {        BivariateRegression regression = new BivariateRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        assertEquals("r", -.946638, regression.getR(), 10E-6);    }    public void testNaNs() {        BivariateRegression regression = new BivariateRegression();        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        regression.addData(1, 2);        regression.addData(1, 3);        // No x variation, so these should still blow...        assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN", Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN", Double.isNaN(regression.getR()));        assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("predict not NaN", Double.isNaN(regression.predict(0)));        // but SSTO should be OK        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        regression = new BivariateRegression();        regression.addData(1, 2);        regression.addData(3, 3);        // All should be OK except MSE, s(b0), s(b1) which need one more df         assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept()));        assertTrue("slope NaN", !Double.isNaN(regression.getSlope()));        assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError()));        assertTrue("r NaN", !Double.isNaN(regression.getR()));        assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare()));        assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict NaN", !Double.isNaN(regression.predict(0)));        regression.addData(1, 4);        // MSE, MSE, s(b0), s(b1) should all be OK now        assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError()));        assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr()));    }    public void testClear() {        BivariateRegression regression = new BivariateRegression();        regression.addData(corrData);        assertEquals("number of observations", 17, regression.getN());        regression.clear();        assertEquals("number of observations", 0, regression.getN());        regression.addData(corrData);        assertEquals("r-square", .896123, regression.getRSquare(), 10E-6);        regression.addData(data);        assertEquals("number of observations", 53, regression.getN());    }    public void testInference() throws Exception {        BivariateRegression regression = new BivariateRegression();        regression.addData(infData);                assertEquals("slope confidence interval",  0.0271,                regression.getSlopeConfidenceInterval(), 0.0001);        assertEquals("slope std err",0.01146,                regression.getSlopeStdErr(), 0.0001);           regression = new BivariateRegression();        regression.addData(infData2);        assertEquals("significance",0.023331,                regression.getSignificance(),0.0001);                //FIXME: get a real example to test against with alpha = .01        assertTrue("tighter means wider",                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));             try {            double x = regression.getSlopeConfidenceInterval(1);            fail("expecting IllegalArgumentException for alpha = 1");        } catch (IllegalArgumentException ex) {            ;        }      }    public void testPerfect() throws Exception {        BivariateRegression regression = new BivariateRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), i);        }        assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() > 0.0);    }    public void testPerfectNegative() throws Exception {        BivariateRegression regression = new BivariateRegression();        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(- ((double) i) / (n - 1), i);        }           assertEquals(0.0, regression.getSignificance(), 1.0e-5);        assertTrue(regression.getSlope() < 0.0);       }    public void testRandom() throws Exception {        BivariateRegression regression = new BivariateRegression();        Random random = new Random(1);        int n = 100;        for (int i = 0; i < n; i++) {            regression.addData(((double) i) / (n - 1), random.nextDouble());        }        assertTrue( 0.0 < regression.getSignificance()                    && regression.getSignificance() < 1.0);           }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStreamReader;import org.apache.commons.logging.LogFactory;import org.apache.commons.logging.Log;import org.apache.commons.math.stat.univariate.SummaryStatistics;import org.apache.commons.math.stat.univariate.SummaryStatisticsImpl;import org.apache.commons.math.stat.univariate.DescriptiveStatistics;/** * Certified data test cases. * @version $Revision: 1.17 $ $Date: 2004/04/12 02:27:49 $ */public class CertifiedDataTest extends TestCase  {protected double mean = Double.NaN;protected double std = Double.NaN;protected Log log = LogFactory.getLog(this.getClass());/** * Certified Data Test Constructor * @param name */public CertifiedDataTest(String name) {super(name);}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */public void setUp() {}/** * @return The test suite */public static Test suite() {TestSuite suite = new TestSuite(CertifiedDataTest.class);suite.setName("Certified Tests");return suite;}/** * Test StorelessDescriptiveStatistics*/public void testUnivariateImpl() throws Exception {SummaryStatistics u = SummaryStatistics.newInstance(SummaryStatisticsImpl.class);loadStats("data/PiDigits.txt", u);assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);loadStats("data/Mavro.txt", u);assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);//loadStats("data/Michelso.txt");//assertEquals("Michelso: std", std, u.getStandardDeviation(), .00000000000001);//assertEquals("Michelso: mean", mean, u.getMean(), .00000000000001);loadStats("data/NumAcc1.txt", u);assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);//loadStats("data/NumAcc2.txt");//assertEquals("NumAcc2: std", std, u.getStandardDeviation(), .000000001);//assertEquals("NumAcc2: mean", mean, u.getMean(), .00000000000001);}/** * Test StorelessDescriptiveStatistics */public void testStoredUnivariateImpl() {DescriptiveStatistics u = DescriptiveStatistics.newInstance();loadStats("data/PiDigits.txt", u);assertEquals("PiDigits: std", std, u.getStandardDeviation(), .0000000000001);assertEquals("PiDigits: mean", mean, u.getMean(), .0000000000001);loadStats("data/Mavro.txt", u);assertEquals("Mavro: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("Mavro: mean", mean, u.getMean(), .00000000000001);//loadStats("data/Michelso.txt");//assertEquals("Michelso: std", std, u.getStandardDeviation(), .00000000000001);//assertEquals("Michelso: mean", mean, u.getMean(), .00000000000001);loadStats("data/NumAcc1.txt", u);assertEquals("NumAcc1: std", std, u.getStandardDeviation(), .00000000000001);assertEquals("NumAcc1: mean", mean, u.getMean(), .00000000000001);//loadStats("data/NumAcc2.txt");//assertEquals("NumAcc2: std", std, u.getStandardDeviation(), .000000001);//assertEquals("NumAcc2: mean", mean, u.getMean(), .00000000000001);}/** * loads a DescriptiveStatistics off of a test file * @param file * @param statistical summary */private void loadStats(String resource, Object u) {DescriptiveStatistics d = null;SummaryStatistics s = null;if (u instanceof DescriptiveStatistics) {d = (DescriptiveStatistics) u;} else {s = (SummaryStatistics) u;}try {u.getClass().getDeclaredMethod("clear", null).invoke(u, null);mean = Double.NaN;std = Double.NaN;BufferedReader in =new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(resource)));String line = null;for (int j = 0; j < 60; j++) {line = in.readLine();if (j == 40) {mean =Double.parseDouble(line.substring(line.lastIndexOf(":") + 1).trim());}if (j == 41) {std =Double.parseDouble(line.substring(line.lastIndexOf(":") + 1).trim());}}line = in.readLine();while (line != null) {if (d != null) {d.addValue(Double.parseDouble(line.trim()));}  else {s.addValue(Double.parseDouble(line.trim()));}line = in.readLine();}in.close();} catch (FileNotFoundException fnfe) {log.error(fnfe.getMessage(), fnfe);} catch (IOException ioe) {log.error(ioe.getMessage(), ioe);} catch (Exception ioe) {log.error(ioe.getMessage(), ioe);}}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import java.io.BufferedReader;import java.io.IOException;import java.io.StringReader;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Frequency} class. * * @version $Revision: 1.12 $ $Date: 2004/03/07 00:57:11 $ */public final class FrequencyTest extends TestCase {    private long oneL = 1;    private long twoL = 2;    private long threeL = 3;    private int oneI = 1;    private int twoI = 2;    private int threeI=3;    private String oneS = "1";    private String twoS = "2";    private double tolerance = 10E-15;    private Frequency f = null;        public FrequencyTest(String name) {        super(name);    }        public void setUp() {      f = new Frequency();    }        public static Test suite() {        TestSuite suite = new TestSuite(FrequencyTest.class);        suite.setName("Frequency Tests");        return suite;    }        /** test freq counts */    public void testCounts() {        assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(1);        f.addValue(oneI);        assertEquals("one frequency count",3,f.getCount(1));        assertEquals("two frequency count",1,f.getCount(2));        assertEquals("three frequency count",0,f.getCount(3));        assertEquals("total count",4,f.getSumFreq());        assertEquals("zero cumulative frequency", 0, f.getCumFreq(0));        assertEquals("one cumulative frequency", 3,  f.getCumFreq(1));        assertEquals("two cumulative frequency", 4,  f.getCumFreq(2));        assertEquals("five cumulative frequency", 4,  f.getCumFreq(5));        assertEquals("foo cumulative frequency", 0,  f.getCumFreq("foo"));                f.clear();        assertEquals("total count",0,f.getSumFreq());                // userguide examples -------------------------------------------------------------------        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one cumulative frequency", 1 ,  f.getCount("one"));        assertEquals("Z cumulative pct", 0.5,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct", 1.0,  f.getCumPct("z"), tolerance);        assertEquals("Ot cumulative pct", 0.25,  f.getCumPct("Ot"), tolerance);        f.clear();                f = null;        f = new Frequency(String.CASE_INSENSITIVE_ORDER);        f.addValue("one");        f.addValue("One");        f.addValue("oNe");        f.addValue("Z");        assertEquals("one count", 3 ,  f.getCount("one"));        assertEquals("Z cumulative pct -- case insensitive", 1 ,  f.getCumPct("Z"), tolerance);        assertEquals("z cumulative pct -- case insensitive", 1 ,  f.getCumPct("z"), tolerance);    }             /** test pcts */    public void testPcts() {        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue(threeL);        f.addValue(threeL);        f.addValue(3);        f.addValue(threeI);        assertEquals("one pct",0.25,f.getPct(1),tolerance);        assertEquals("two pct",0.25,f.getPct(new Long(2)),tolerance);        assertEquals("three pct",0.5,f.getPct(threeL),tolerance);        assertEquals("five pct",0,f.getPct(5),tolerance);        assertEquals("foo pct",0,f.getPct("foo"),tolerance);        assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance);        assertEquals("two cum pct",0.50,f.getCumPct(new Long(2)),tolerance);        assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance);        assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance);        assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance);        assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance);    }        /** test adding incomparable values */    public void testAdd() {    char aChar = 'a';    char bChar = 'b';    String aString = "a";    f.addValue(aChar);    f.addValue(bChar);    try {    f.addValue(aString);     fail("Expecting IllegalArgumentException");    } catch (IllegalArgumentException ex) {    // expected    }    assertEquals("a pct",0.5,f.getPct(aChar),tolerance);    assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance);    assertEquals("a string pct",0.0,f.getPct(aString),tolerance);    assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance);    }        /**     * Tests toString()      */    public void testToString(){        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);                String s = f.toString();        //System.out.println(s);        assertNotNull(s);        BufferedReader reader = new BufferedReader(new StringReader(s));        try {            String line = reader.readLine(); // header line            assertNotNull(line);                        line = reader.readLine(); // one's or two's line            assertNotNull(line);                                    line = reader.readLine(); // one's or two's line            assertNotNull(line);            line = reader.readLine(); // no more elements            assertNull(line);        } catch(IOException ex){            fail(ex.getMessage());        }            }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.TestUtils;import org.apache.commons.math.stat.univariate.DescriptiveStatistics;/** * Test cases for the {@link StatUtils} class. * @version $Revision: 1.15 $ $Date: 2004/04/27 16:42:31 $ */public final class StatUtilsTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = DescriptiveStatistics.LEPTOKURTIC;    private double tolerance = 10E-15;    public StatUtilsTest(String name) {        super(name);    }    public void setUp() {    }    public static Test suite() {        TestSuite suite = new TestSuite(StatUtilsTest.class);        suite.setName("StatUtil Tests");        return suite;    }    /** test stats */    public void testStats() {        double[] values = new double[] { one, two, two, three };        assertEquals("sum", sum, StatUtils.sum(values), tolerance);        assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance);        assertEquals("var", var, StatUtils.variance(values), tolerance);        assertEquals("mean", mean, StatUtils.mean(values), tolerance);        assertEquals("min", min, StatUtils.min(values), tolerance);        assertEquals("max", max, StatUtils.max(values), tolerance);    }    public void testN0andN1Conditions() throws Exception {        double[] values = new double[0];        assertTrue(            "Mean of n = 0 set should be NaN",            Double.isNaN(StatUtils.mean(values)));        assertTrue(            "Variance of n = 0 set should be NaN",            Double.isNaN(StatUtils.variance(values)));        values = new double[] { one };        assertTrue(            "Mean of n = 1 set should be value of single item n1",            StatUtils.mean(values) == one);        assertTrue(            "Variance of n = 1 set should be zero",            StatUtils.variance(values) == 0);    }    public void testSkewAndKurtosis() {        double[] values =            {                12.5,                12,                11.8,                14.2,                14.9,                14.5,                21,                8.2,                10.3,                11.3,                14.1,                9.9,                12.2,                12,                12.1,                11,                19.8,                11,                10,                8.8,                9,                12.3 };        assertEquals("mean", 12.40455, StatUtils.mean(values), 0.0001);        assertEquals("variance", 10.00236, StatUtils.variance(values), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        assertEquals(            "Product not expected",            24.0,            StatUtils.product(values),            Double.MIN_VALUE);    }    public void testArrayIndexConditions() throws Exception {        double[] values = { 1.0, 2.0, 3.0, 4.0 };        assertEquals(            "Sum not expected",            5.0,            StatUtils.sum(values, 1, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            3.0,            StatUtils.sum(values, 0, 2),            Double.MIN_VALUE);        assertEquals(            "Sum not expected",            7.0,            StatUtils.sum(values, 2, 2),            Double.MIN_VALUE);        try {            StatUtils.sum(values, 2, 3);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }        try {            StatUtils.sum(values, -1, 2);            assertTrue("Didn't throw exception", false);        } catch (Exception e) {            assertTrue(true);        }    }        public void testSumSq() {        double[] x = null;                // test null        try {            StatUtils.sumSq(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.sumSq(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);        TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);    }        public void testProduct() {        double[] x = null;                // test null        try {            StatUtils.product(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.product(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.product(x), tolerance);        TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(12, StatUtils.product(x), tolerance);        TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);    }        public void testSumLog() {        double[] x = null;                // test null        try {            StatUtils.sumLog(x);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.sumLog(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);        TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);    }        public void testMean() {        double[] x = null;                try {            StatUtils.mean(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);    }        public void testVariance() {        double[] x = null;                try {            StatUtils.variance(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);    }        public void testMax() {        double[] x = null;                try {            StatUtils.max(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);    }        public void testMin() {        double[] x = null;                try {            StatUtils.min(x, 0, 4);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);    }        public void testPercentile() {        double[] x = null;                // test null        try {            StatUtils.percentile(x, .25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                try {            StatUtils.percentile(x, 0, 4, 0.25);            fail("null is not a valid data array.");        } catch (IllegalArgumentException ex) {            // success        }                // test empty        x = new double[] {};        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);                // test one        x = new double[] {two};        TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);        TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);                // test many        x = new double[] {one, two, two, three};        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);        TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision: 1.1 $ $Date: 2004/04/27 16:51:52 $ */public class InvalidMatrixExceptionTest extends TestCase {    /**     *      */    public void testConstructor(){        InvalidMatrixException ex = new InvalidMatrixException();        assertNull(ex.getCause());        assertNull(ex.getMessage());    }        /**     *      */    public void testConstructorMessage(){        String msg = "message";        InvalidMatrixException ex = new InvalidMatrixException(msg);        assertNull(ex.getCause());        assertEquals(msg, ex.getMessage());    }        /**     *      */    public void testConstructorMessageCause(){        String outMsg = "outer message";        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        InvalidMatrixException ex = new InvalidMatrixException(outMsg, cause);        assertEquals(outMsg, ex.getMessage());        assertEquals(cause, ex.getCause());    }        /**     *      */    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        InvalidMatrixException ex = new InvalidMatrixException(cause);        assertEquals(cause, ex.getCause());    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.TestCase;/** * @version $Revision: 1.1 $ $Date: 2004/04/27 16:51:52 $ */public class MatrixIndexExceptionTest extends TestCase {    /**     *      */    public void testConstructor(){        MatrixIndexException ex = new MatrixIndexException();        assertNull(ex.getCause());        assertNull(ex.getMessage());    }        /**     *      */    public void testConstructorMessage(){        String msg = "message";        MatrixIndexException ex = new MatrixIndexException(msg);        assertNull(ex.getCause());        assertEquals(msg, ex.getMessage());    }        /**     *      */    public void testConstructorMessageCause(){        String outMsg = "outer message";        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MatrixIndexException ex = new MatrixIndexException(outMsg, cause);        assertEquals(outMsg, ex.getMessage());        assertEquals(cause, ex.getCause());    }        /**     *      */    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MatrixIndexException ex = new MatrixIndexException(cause);        assertEquals(cause, ex.getCause());    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.linear;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link RealMatrixImpl} class. * * @version $Revision: 1.13 $ $Date: 2004/04/08 07:08:22 $ */public final class RealMatrixImplTest extends TestCase {        private double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    private double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};    private double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };    private double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},        {-1d,0d,-8d} };    private double[] testDataRow1 = {1d,2d,3d};    private double[] testDataCol3 = {3d,3d,8d};    private double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    private double[] preMultTest = {8,12,33};    private double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    private double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};    private double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    private double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    private double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };    private double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d}, {0.33333333333333,0d,0.33333333333333} };    private double[][] singular = { {2d,3d}, {2d,3d} };    private double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd    private double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };    private double[][] detData2 = { {1d, 3d}, {2d, 4d}};    private double[] testVector = {1,2,3};    private double[] testVector2 = {1,2,3,4};    private double entryTolerance = 10E-16;    private double normTolerance = 10E-14;        public RealMatrixImplTest(String name) {        super(name);    }        public void setUp() {            }        public static Test suite() {        TestSuite suite = new TestSuite(RealMatrixImplTest.class);        suite.setName("RealMatrixImpl Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());        RealMatrixImpl m3 = new RealMatrixImpl();        m3.setData(testData);    }         /** test copy functions */    public void testCopyFunctions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        m2.setData(m.getData());        assertClose("getData",m2,m,entryTolerance);        // no dangling reference...        m2.setEntry(1,1,2000d);        RealMatrixImpl m3 = new RealMatrixImpl(testData);        assertClose("no getData side effect",m,m3,entryTolerance);        m3 = (RealMatrixImpl) m.copy();        double[][] stompMe = {{1d,2d,3d}};        m3.setDataRef(stompMe);        assertClose("no copy side effect",m,new RealMatrixImpl(testData),            entryTolerance);    }                   /** test add */    public void testAdd() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        try {            RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        /** test norm */    public void testNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);                try {            RealMatrix a = m.subtract(new RealMatrixImpl(testData2));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }       /** test multiply */     public void testMultiply() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);         try {            RealMatrix a = m.multiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }           //Additional Test for RealMatrixImplTest.testMultiply    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};    private double[][] d4 = new double[][] {{1},{2},{3},{4}};    private double[][] d5 = new double[][] {{30},{70}};         public void testMultiply2() {        RealMatrix m3 = new RealMatrixImpl(d3);          RealMatrix m4 = new RealMatrixImpl(d4);       RealMatrix m5 = new RealMatrixImpl(d5);       assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance);   }              /** test isSingular */    public void testIsSingular() {        RealMatrixImpl m = new RealMatrixImpl(singular);        assertTrue("singular",m.isSingular());        m = new RealMatrixImpl(bigSingular);        assertTrue("big singular",m.isSingular());        m = new RealMatrixImpl(id);        assertTrue("identity nonsingular",!m.isSingular());        m = new RealMatrixImpl(testData);        assertTrue("testData nonsingular",!m.isSingular());    }            /** test inverse */    public void testInverse() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix mInv = new RealMatrixImpl(testDataInv);        assertClose("inverse",mInv,m.inverse(),normTolerance);        assertClose("inverse^2",m,m.inverse().inverse(),10E-12);                // Not square        m = new RealMatrixImpl(testData2);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }                // Singular        m = new RealMatrixImpl(singular);        try {            m.inverse();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        /** test solve */    public void testSolve() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix mInv = new RealMatrixImpl(testDataInv);        // being a bit slothful here -- actually testing that X = A^-1 * B        assertClose("inverse-operate",mInv.operate(testVector),            m.solve(testVector),normTolerance);        try {            double[] x = m.solve(testVector2);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }               RealMatrix bs = new RealMatrixImpl(bigSingular);        try {            RealMatrix a = bs.solve(bs);            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }        try {            RealMatrix a = m.solve(bs);            fail("Expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        try {            RealMatrix a = (new RealMatrixImpl(testData2)).solve(bs);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }         try {            (new RealMatrixImpl(testData2)).luDecompose();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }      }        /** test determinant */    public void testDeterminant() {               RealMatrix m = new RealMatrixImpl(bigSingular);        assertEquals("singular determinant",0,m.getDeterminant(),0);        m = new RealMatrixImpl(detData);        assertEquals("nonsingular test",-3d,m.getDeterminant(),normTolerance);                // Examples verified against R (version 1.8.1, Red Hat Linux 9)        m = new RealMatrixImpl(detData2);        assertEquals("nonsingular R test 1",-2d,m.getDeterminant(),normTolerance);        m = new RealMatrixImpl(testData);        assertEquals("nonsingular  R test 2",-1d,m.getDeterminant(),normTolerance);        try {            double a = new RealMatrixImpl(testData2).getDeterminant();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            ;        }          }        /** test trace */    public void testTrace() {        RealMatrix m = new RealMatrixImpl(id);        assertEquals("identity trace",3d,m.getTrace(),entryTolerance);        m = new RealMatrixImpl(testData2);        try {            double x = m.getTrace();            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test sclarAdd */    public void testScalarAdd() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("scalar add",new RealMatrixImpl(testDataPlus2),            m.scalarAdd(2d),entryTolerance);    }                        /** test operate */    public void testOperate() {        RealMatrix m = new RealMatrixImpl(id);        double[] x = m.operate(testVector);        assertClose("identity operate",testVector,x,entryTolerance);        m = new RealMatrixImpl(bigSingular);        try {            x = m.operate(testVector);            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        /** test transpose */    public void testTranspose() {        RealMatrix m = new RealMatrixImpl(testData);         assertClose("inverse-transpose",m.inverse().transpose(),            m.transpose().inverse(),normTolerance);        m = new RealMatrixImpl(testData2);        RealMatrix mt = new RealMatrixImpl(testData2T);        assertClose("transpose",mt,m.transpose(),normTolerance);    }        /** test preMultiply by vector */    public void testPremultiplyVector() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("premultiply",m.preMultiply(testVector),preMultTest,normTolerance);        m = new RealMatrixImpl(bigSingular);        try {            m.preMultiply(testVector);            fail("expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testPremultiply() {        RealMatrix m3 = new RealMatrixImpl(d3);           RealMatrix m4 = new RealMatrixImpl(d4);        RealMatrix m5 = new RealMatrixImpl(d5);        assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance);                RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertClose("inverse multiply",m.preMultiply(mInv),                identity,entryTolerance);        assertClose("inverse multiply",mInv.preMultiply(m),                identity,entryTolerance);        assertClose("identity multiply",m.preMultiply(identity),                m,entryTolerance);        assertClose("identity multiply",identity.preMultiply(mInv),                mInv,entryTolerance);        try {            RealMatrix a = m.preMultiply(new RealMatrixImpl(bigSingular));            fail("Expecting illegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }          }        public void testGetVectors() {        RealMatrix m = new RealMatrixImpl(testData);        assertClose("get row",m.getRow(1),testDataRow1,entryTolerance);        assertClose("get col",m.getColumn(3),testDataCol3,entryTolerance);        try {            double[] x = m.getRow(10);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }        try {            double[] x = m.getColumn(-1);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }    }        public void testEntryMutators() {        RealMatrix m = new RealMatrixImpl(testData);        assertEquals("get entry",m.getEntry(1,2),2d,entryTolerance);        m.setEntry(1,2,100d);        assertEquals("get entry",m.getEntry(1,2),100d,entryTolerance);        try {            double x = m.getEntry(0,2);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }        try {            m.setEntry(1,4,200d);            fail("expecting MatrixIndexException");        } catch (MatrixIndexException ex) {            ;        }    }            public void testLUDecomposition() throws Exception {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrix lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);        verifyDecomposition(m, lu);        m = new RealMatrixImpl(luData);        lu = m.getLUMatrix();        assertClose("LU decomposition", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);        verifyDecomposition(m, lu);        m = new RealMatrixImpl(testDataMinus);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        m = new RealMatrixImpl(id);        lu = m.getLUMatrix();        verifyDecomposition(m, lu);        try {            m = new RealMatrixImpl(bigSingular); // singular            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }        try {            m = new RealMatrixImpl(testData2);  // not square            lu = m.getLUMatrix();            fail("Expecting InvalidMatrixException");        } catch (InvalidMatrixException ex) {            // expected        }    }        //--------------- -----------------Protected methods            /** verifies that two matrices are close (1-norm) */                  protected void assertClose(String msg, RealMatrix m, RealMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm() < tolerance);    }        /** verifies that two vectors are close (sup norm) */    protected void assertClose(String msg, double[] m, double[] n,        double tolerance) {        if (m.length != n.length) {            fail("vectors not same length");        }        for (int i = 0; i < m.length; i++) {            assertEquals(msg + " " +  i + " elements differ",                 m[i],n[i],tolerance);        }    }        /** extracts the l  and u matrices from compact lu representation */    protected void splitLU(RealMatrix lu, RealMatrix lower, RealMatrix upper) throws InvalidMatrixException {        if (!lu.isSquare() || !lower.isSquare() || !upper.isSquare() ||                lower.getRowDimension() != upper.getRowDimension()                 || lower.getRowDimension() != lu.getRowDimension()) {            throw new InvalidMatrixException("incorrect dimensions");        }            int n = lu.getRowDimension();        for (int i = 1; i <= n; i++) {            for (int j = 1; j <= n; j++) {                if (j < i) {                    lower.setEntry(i, j, lu.getEntry(i, j));                    upper.setEntry(i, j, 0d);                } else if (i == j) {                    lower.setEntry(i, j, 1d);                    upper.setEntry(i, j, lu.getEntry(i, j));                } else {                    lower.setEntry(i, j, 0d);                    upper.setEntry(i, j, lu.getEntry(i, j));                }               }        }    }        /** Returns the result of applying the given row permutation to the matrix */    protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {            throw new IllegalArgumentException("dimension mismatch");        }        int n = matrix.getRowDimension();        RealMatrix out = new RealMatrixImpl(n, n);        for (int i =1; i <= n; i++) {            for (int j = 1; j <= n; j++) {                out.setEntry(i, j, matrix.getEntry(permutation[i -1] + 1, j));            }        }        return out;    }        /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */    protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{        int n = matrix.getRowDimension();        RealMatrix lower = new RealMatrixImpl(n, n);        RealMatrix upper = new RealMatrixImpl(n, n);        splitLU(lu, lower, upper);        int[] permutation = ((RealMatrixImpl) matrix).getPermutation();        RealMatrix permuted = permuteRows(matrix, permutation);        assertClose("lu decomposition does not work", permuted, lower.multiply(upper), normTolerance);    }              /** Useful for debugging */    private void dumpMatrix(RealMatrix m) {          for (int i = 0; i < m.getRowDimension(); i++) {              String os = "";              for (int j = 0; j < m.getColumnDimension(); j++) {                  os += m.getEntry(i+1, j+1) + " ";              }              System.out.println(os);          }    }        }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import junit.framework.TestCase;/** * @version $Revision: 1.16 $ $Date: 2004/02/21 21:35:17 $ */public class DistributionFactoryImplTest extends TestCase {    /** */    private DistributionFactory factory;    /** * Constructor for DistributionFactoryImplTest. * @param name */public DistributionFactoryImplTest(String name) {super(name);}/** * @throws java.lang.Exception */protected void setUp() throws Exception {super.setUp();        factory = new DistributionFactoryImpl();}/** * @throws java.lang.Exception */protected void tearDown() throws Exception {        factory = null;super.tearDown();}        public void testCreateChiSquareDistributionNegative(){        try {            factory.createChiSquareDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionZero(){        try {            factory.createChiSquareDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionPositive(){        try {            factory.createChiSquareDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateFDistributionNegativePositive(){        try {            factory.createFDistribution(-1.0, 1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionZeroPositive(){        try {            factory.createFDistribution(0.0, 1.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositiveNegative(){        try {            factory.createFDistribution(1.0, -1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositiveZero(){        try {            factory.createFDistribution(1.0, 0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateFDistributionPositivePositive(){        try {            factory.createFDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateExponentialDistributionNegative(){        try {            factory.createExponentialDistribution(-1.0);            fail("negative mean.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateExponentialDistributionZero(){        try {            factory.createExponentialDistribution(0.0);            fail("zero mean.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateExponentialDistributionPositive(){        try {            factory.createExponentialDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive mean.  IllegalArgumentException is not expected");        }    }        public void testCreateGammaDistributionNegativePositive(){        try {            factory.createGammaDistribution(-1.0, 1.0);            fail("negative alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionZeroPositive(){        try {            factory.createGammaDistribution(0.0, 1.0);            fail("zero alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveNegative(){        try {            factory.createGammaDistribution(1.0, -1.0);            fail("negative beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveZero(){        try {            factory.createGammaDistribution(1.0, 0.0);            fail("zero beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositivePositive(){        try {            factory.createGammaDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive alpah and beta.  IllegalArgumentException is not expected");        }    }        public void testCreateTDistributionNegative(){        try {            factory.createTDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateTDistributionZero(){        try {            factory.createTDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateTDistributionPositive(){        try {            factory.createTDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionNegativePositive(){        try {            factory.createBinomialDistribution(-1, 0.5);            fail("negative number of trials.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex ) {        }    }        public void testBinomialDistributionZeroPositive(){        try {            factory.createBinomialDistribution(0, 0.5);        } catch (IllegalArgumentException ex ) {            fail("zero number of trials.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositivePositive(){        try {            factory.createBinomialDistribution(10, 0.5);        } catch (IllegalArgumentException ex ) {            fail("positive number of trials.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositiveNegative(){        try {            factory.createBinomialDistribution(10, -0.5);            fail("negative probability of success.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex ) {        }    }        public void testBinomialDistributionPositiveZero(){        try {            factory.createBinomialDistribution(10, 0.0);        } catch (IllegalArgumentException ex ) {            fail("zero probability of success.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositiveOne(){        try {            factory.createBinomialDistribution(10, 1.0);        } catch (IllegalArgumentException ex ) {            fail("valid probability of success.  IllegalArgumentException is not expected");        }    }        public void testBinomialDistributionPositiveTwo(){        try {            factory.createBinomialDistribution(10, 2.0);            fail("high probability of success.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex ) {        }    }        public void testHypergeometricDistributionNegativePositivePositive(){        try {            factory.createHypergeometricDistribution(-1, 10, 10);            fail("negative population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionZeroPositivePositive(){        try {            factory.createHypergeometricDistribution(0, 10, 10);            fail("zero population size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionPositiveNegativePositive(){        try {            factory.createHypergeometricDistribution(20, -1, 10);            fail("negative number of successes.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionPositiveZeroPositive(){        try {            factory.createHypergeometricDistribution(20, 0, 10);        } catch(IllegalArgumentException ex) {            fail("valid number of successes.  IllegalArgumentException is not expected");        }    }        public void testHypergeometricDistributionPositivePositiveNegative(){        try {            factory.createHypergeometricDistribution(20, 10, -1);            fail("negative sample size.  IllegalArgumentException expected");        } catch(IllegalArgumentException ex) {        }    }        public void testHypergeometricDistributionPositivePositiveZero(){        try {            factory.createHypergeometricDistribution(20, 10, 0);        } catch(IllegalArgumentException ex) {            fail("valid sample size.  IllegalArgumentException is not expected");        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.10 $ $Date: 2004/02/21 21:35:17 $ */public class HypergeometricDistributionTest extends TestCase {    private HypergeometricDistribution h;    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public HypergeometricDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        h =            DistributionFactory.newInstance().createHypergeometricDistribution(                10,                5,                5);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        h = null;        super.tearDown();    }    public void testInverseCumulativeProbability001() {        testValue(-1, .001);    }    public void testInverseCumulativeProbability010() {        testValue(0, .010);    }    public void testInverseCumulativeProbability025() {        testValue(0, .025);    }    public void testInverseCumulativeProbability050() {        testValue(0, .050);    }    public void testInverseCumulativeProbability100() {        testValue(0, .100);    }    public void testInverseCumulativeProbability999() {        testValue(4, .999);    }    public void testInverseCumulativeProbability990() {        testValue(3, .990);    }    public void testInverseCumulativeProbability975() {        testValue(3, .975);    }    public void testInverseCumulativeProbability950() {        testValue(3, .950);    }    public void testInverseCumulativeProbability900() {        testValue(3, .900);    }    public void testCumulativeProbability0() {        testProbability(0, .00400);    }    public void testCumulativeProbability1() {        testProbability(1, .10318);    }    public void testCumulativeProbability2() {        testProbability(2, .50000);    }    public void testCumulativeProbability3() {        testProbability(3, .89683);    }    public void testCumulativeProbability4() {        testProbability(4, .99603);    }    public void testCumulativeProbability5() {        testProbability(5, 1.00000);    }    private void testProbability(int x, double expected) {        try {            double actual = h.cumulativeProbability(x);            assertEquals(expected, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void testValue(int expected, double p) {        try {            int actual = h.inverseCumulativeProbability(p);            assertEquals(expected, actual);            assertTrue(h.cumulativeProbability(actual) <= p);            assertTrue(h.cumulativeProbability(actual + 1) >= p);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.13 $ $Date: 2004/02/28 21:58:33 $ */public class TDistributionTest extends TestCase {    private TDistribution t;    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public TDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        t = DistributionFactory.newInstance().createTDistribution(5.0);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        t = null;        super.tearDown();    }    public void testInverseCumulativeProbability001() {        testValue(-5.893, .001);    }    public void testInverseCumulativeProbability010() {        testValue(-3.365, .010);    }    public void testInverseCumulativeProbability025() {        testValue(-2.571, .025);    }    public void testInverseCumulativeProbability050() {        testValue(-2.015, .050);    }    public void testInverseCumulativeProbability100() {        testValue(-1.476, .100);    }    public void testInverseCumulativeProbability999() {        testValue(5.893, .999);    }    public void testInverseCumulativeProbability990() {        testValue(3.365, .990);    }    public void testInverseCumulativeProbability975() {        testValue(2.571, .975);    }    public void testInverseCumulativeProbability950() {        testValue(2.015, .950);    }    public void testInverseCumulativeProbability900() {        testValue(1.476, .900);    }    public void testCumulativeProbability001() {        testProbability(-5.893, .001);    }    public void testCumulativeProbability010() {        testProbability(-3.365, .010);    }    public void testCumulativeProbability025() {        testProbability(-2.571, .025);    }    public void testCumulativeProbability050() {        testProbability(-2.015, .050);    }    public void testCumulativeProbability100() {        testProbability(-1.476, .100);    }    public void testCumulativeProbability999() {        testProbability(5.893, .999);    }    public void testCumulativeProbability990() {        testProbability(3.365, .990);    }    public void testCumulativeProbability975() {        testProbability(2.571, .975);    }    public void testCumulativeProbability950() {        testProbability(2.015, .950);    }    public void testCumulativeProbability900() {        testProbability(1.476, .900);    }    /**     * @see <a href="http://nagoya.apache.org/bugzilla/show_bug.cgi?id=27243">     *      Bug report that prompted this unit test.</a>     */    public void testCumulativeProbabilityAgaintStackOverflow() {    try {    TDistributionImpl td = new TDistributionImpl(5.);    double est;    est = td.cumulativeProbability(.1);    est = td.cumulativeProbability(.01);    } catch(MathException ex) {    fail(ex.getMessage());    }    }        private void testProbability(double x, double expected) {        try {            double actual = t.cumulativeProbability(x);            assertEquals(expected, actual, 10e-4);        } catch (MathException e) {        fail(e.getMessage());        }    }    private void testValue(double expected, double p) {        try {            double actual = t.inverseCumulativeProbability(p);            assertEquals(expected, actual, 10e-4);        } catch (MathException e) {        fail(e.getMessage());        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.11 $ $Date: 2004/02/21 21:35:17 $ */public class FDistributionTest extends TestCase {    private FDistribution f;    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public FDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        f = DistributionFactory.newInstance().createFDistribution(5.0, 6.0);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        f = null;        super.tearDown();    }    public void testLowerTailProbability() {        testProbability(1.0 / 10.67, .010);        testProbability(1.0 / 6.98, .025);        testProbability(1.0 / 4.95, .050);        testProbability(1.0 / 3.40, .100);    }    public void testUpperTailProbability() {        testProbability(8.75, .990);        testProbability(5.99, .975);        testProbability(4.39, .950);        testProbability(3.11, .900);    }    public void testLowerTailValues() {        testValue(1.0 / 10.67, .010);        testValue(1.0 / 6.98, .025);        testValue(1.0 / 4.95, .050);        testValue(1.0 / 3.40, .100);    }    public void testUpperTailValues() {        testValue(8.75, .990);        testValue(5.99, .975);        testValue(4.39, .950);        testValue(3.11, .900);    }    private void testProbability(double x, double expected) {        try {            double actual = f.cumulativeProbability(x);            assertEquals("probability for " + x, expected, actual, 1e-3);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void testValue(double expected, double p) {        try {            double actual = f.inverseCumulativeProbability(p);            assertEquals("value for " + p, expected, actual, 1e-2);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.14 $ $Date: 2004/02/21 21:35:17 $ */public class GammaDistributionTest extends TestCase {    public void testProbabilities() {        testProbability(-1.000, 4.0, 2.0, .0000);        testProbability(15.501, 4.0, 2.0, .9499);        testProbability(0.504, 4.0, 1.0, .0018);        testProbability(10.011, 1.0, 2.0, .9933);        testProbability(5.000, 2.0, 2.0, .7127);    }    public void testValues() {        testValue(15.501, 4.0, 2.0, .9499);        testValue(0.504, 4.0, 1.0, .0018);        testValue(10.011, 1.0, 2.0, .9933);        testValue(5.000, 2.0, 2.0, .7127);    }    private void testProbability(        double x,        double a,        double b,        double expected) {        try {            double actual =                DistributionFactory                    .newInstance()                    .createGammaDistribution(a, b)                    .cumulativeProbability(x);            assertEquals("probability for " + x, expected, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void testValue(double expected, double a, double b, double p) {        try {            double actual =                DistributionFactory                    .newInstance()                    .createGammaDistribution(a, b)                    .inverseCumulativeProbability(p);            assertEquals("critical value for " + p, expected, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** *  Tests for NormalDistribution implementation *  * "True" results are taken from R - the same as in Mathematica * */public class NormalDistributionTest extends TestCase {private NormalDistribution z;private static final double PRECISION = 10e-6;private static final double M = 2.1;private static final double SD = 1.4;/** * Constructor for NormalDistributionTest. * @param arg0 */public NormalDistributionTest(String arg0) {super(arg0);}public static void main(String[] args) {junit.swingui.TestRunner.run(NormalDistributionTest.class);}protected void setUp() throws Exception {super.setUp();z = DistributionFactory.newInstance().createNormalDistribution(M, SD);}protected void tearDown() throws Exception {super.tearDown();z = null;}public void testCumulativeProbabilitydoubleM_MINUS_2SD() throws MathException {testProbability(M - 2*SD, 0.02275013);}public void testCumulativeProbabilitydoubleM_MINUS_SD() throws MathException {testProbability(M - SD, 0.1586553);}public void testCumulativeProbabilitydoubleM() throws MathException {testProbability(M, 0.5);}public void testCumulativeProbabilitydoubleM_PLUS_SD() throws MathException {testProbability(M + SD, 0.8413447);}public void testCumulativeProbabilitydoubleM_PLUS_2SD() throws MathException {testProbability(M + 2*SD, 0.9772499);}public void testCumulativeProbabilitydoubleM_PLUS_3SD() throws MathException {testProbability(M + 3*SD, 0.9986501);}public void testCumulativeProbabilitydoubleM_PLUS_4SD() throws MathException {testProbability(M + 4*SD, 0.9999683);}public void testCumulativeProbabilitydoubleM_PLUS_5SD() throws MathException {testProbability(M + 5*SD, 0.9999997);}public void testInverseCumulativeProbability0() throws MathException {assertEquals(Double.isNaN(z.inverseCumulativeProbability(0.0)), true);}public void testInverseCumulativeProbability001() throws MathException {testValue(-2.226325, .001);}public void testInverseCumulativeProbability010() throws MathException{testValue(-1.156887, .010);}public void testInverseCumulativeProbability025() throws MathException{testValue(-0.6439496, .025);}public void testInverseCumulativeProbability050() throws MathException{testValue(-0.2027951, .050);}public void testInverseCumulativeProbability100() throws MathException{testValue(0.3058278, .100);}public void testInverseCumulativeProbability900() throws MathException{testValue(3.894172, .900);}public void testInverseCumulativeProbability950() throws MathException{testValue(4.402795, .950);}public void testInverseCumulativeProbability975() throws MathException{testValue(4.84395, .975);}public void testInverseCumulativeProbability990() throws MathException{testValue(5.356887, .990);}public void testInverseCumulativeProbability999() throws MathException{testValue(6.426325, .999);}public void testInverseCumulativeProbability1() throws MathException {assertEquals(Double.isNaN(z.inverseCumulativeProbability(1.0)), true);}public void testGetMean() {assertEquals(M, z.getMean(), 0);}public void testSetMean() throws MathException {double mu = Math.random();z.setMean(mu);assertEquals(mu, z.getMean(), 0);assertEquals(0.5d, z.cumulativeProbability(mu), PRECISION);}public void testGetStandardDeviation() {assertEquals(SD, z.getStandardDeviation(), 0);}public void testSetStandardDeviation() throws MathException{double sigma = 0.1d + Math.random();z.setStandardDeviation(sigma);assertEquals(sigma, z.getStandardDeviation(), 0);assertEquals(0.84134475, z.cumulativeProbability(z.getMean() + z.getStandardDeviation()), PRECISION );}public void testGetCdfAlgorithm() {assertTrue(z.getCdfAlgorithm() != null);}public void testSetCdfAlgorithm() {z.setCdfAlgorithm(new NormalCDFFastAlgorithm());assertTrue(z.getCdfAlgorithm() instanceof NormalCDFFastAlgorithm);}private void testProbability(double x, double expected) throws MathException {double actual = Double.NaN;z.setCdfAlgorithm(new NormalCDFPreciseAlgorithm());actual =  z.cumulativeProbability(x);assertEquals(expected, actual, PRECISION);z.setCdfAlgorithm(new NormalCDFFastAlgorithm());actual =  z.cumulativeProbability(x);assertEquals(expected, actual, PRECISION);}private void testValue(double expected, double p) throws MathException {double actual = z.inverseCumulativeProbability(p);assertEquals(expected, actual, PRECISION);}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision: 1.12 $ $Date: 2004/02/21 21:35:17 $ */public class ExponentialDistributionTest extends TestCase {    private ExponentialDistribution exp;    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public ExponentialDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        exp =            DistributionFactory.newInstance().createExponentialDistribution(                5.0);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        exp = null;        super.tearDown();    }    public void testInverseCumulativeProbability001() {        testValue(.005003, .001);    }    public void testInverseCumulativeProbability010() {        testValue(0.050252, .010);    }    public void testInverseCumulativeProbability025() {        testValue(0.126589, .025);    }    public void testInverseCumulativeProbability050() {        testValue(0.256566, .050);    }    public void testInverseCumulativeProbability100() {        testValue(0.526803, .100);    }    public void testInverseCumulativeProbability999() {        testValue(34.5388, .999);    }    public void testInverseCumulativeProbability990() {        testValue(23.0259, .990);    }    public void testInverseCumulativeProbability975() {        testValue(18.4444, .975);    }    public void testInverseCumulativeProbability950() {        testValue(14.9787, .950);    }    public void testInverseCumulativeProbability900() {        testValue(11.5129, .900);    }    public void testCumulativeProbability001() {        testProbability(0.005003, .001);    }    public void testCumulativeProbability010() {        testProbability(0.050252, .010);    }    public void testCumulativeProbability025() {        testProbability(0.126589, .025);    }    public void testCumulativeProbability050() {        testProbability(0.256566, .050);    }    public void testCumulativeProbability100() {        testProbability(0.526803, .100);    }    public void testCumulativeProbability999() {        testProbability(34.5388, .999);    }    public void testCumulativeProbability990() {        testProbability(23.0259, .990);    }    public void testCumulativeProbability975() {        testProbability(18.4444, .975);    }    public void testCumulativeProbability950() {        testProbability(14.9787, .950);    }    public void testCumulativeProbability900() {        testProbability(11.5129, .900);    }    public void testCumulativeProbabilityNegative() {        testProbability(-1.0, 0.0);    }    public void testCumulativeProbabilityZero() {        testProbability(0.0, 0.0);    }    public void testInverseCumulativeProbabilityNegative() {        testValue(Double.NaN, -1.0);    }    public void testInverseCumulativeProbabilityZero() {        testValue(0.0, 0.0);    }    public void testInverseCumulativeProbabilityOne() {        testValue(Double.POSITIVE_INFINITY, 1.0);    }    public void testInverseCumulativeProbabilityPositive() {        testValue(Double.NaN, 2.0);    }    public void testCumulativeProbability2() {        try {            double actual = exp.cumulativeProbability(0.25, 0.75);            assertEquals(0.0905214, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void testProbability(double x, double expected) {        try {            double actual = exp.cumulativeProbability(x);            TestUtils.assertEquals(expected, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void testValue(double expected, double p) {        try {            double actual = exp.inverseCumulativeProbability(p);            TestUtils.assertEquals(expected, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.12 $ $Date: 2004/02/21 21:35:17 $ */public class BinomialDistributionTest extends TestCase {    private BinomialDistribution b;    /**     * Constructor for ChiSquareDistributionTest.     * @param name     */    public BinomialDistributionTest(String name) {        super(name);    }    /*     * @see TestCase#setUp()     */    protected void setUp() throws Exception {        super.setUp();        b =            DistributionFactory.newInstance().createBinomialDistribution(                10,                0.70);    }    /*     * @see TestCase#tearDown()     */    protected void tearDown() throws Exception {        b = null;        super.tearDown();    }    public void testInverseCumulativeProbability001() {        testValue(1, .001);    }    public void testInverseCumulativeProbability010() {        testValue(2, .010);    }    public void testInverseCumulativeProbability025() {        testValue(3, .025);    }    public void testInverseCumulativeProbability050() {        testValue(4, .050);    }    public void testInverseCumulativeProbability100() {        testValue(4, .100);    }    public void testInverseCumulativeProbability999() {        testValue(9, .999);    }    public void testInverseCumulativeProbability990() {        testValue(9, .990);    }    public void testInverseCumulativeProbability975() {        testValue(9, .975);    }    public void testInverseCumulativeProbability950() {        testValue(8, .950);    }    public void testInverseCumulativeProbability900() {        testValue(8, .900);    }    public void testCumulativeProbability1() {        testProbability(1, .00014);    }    public void testCumulativeProbability2() {        testProbability(2, .00159);    }    public void testCumulativeProbability3() {        testProbability(3, .01059);    }    public void testCumulativeProbability4() {        testProbability(4, .04735);    }    public void testCumulativeProbability9() {        testProbability(9, .97175);    }    public void testcumulativeProbability8() {        testProbability(8, .85069);    }    private void testProbability(int x, double expected) {        try {            double actual = b.cumulativeProbability(x);            assertEquals(expected, actual, 10e-4);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void testValue(int expected, double p) {        try {            int actual = b.inverseCumulativeProbability(p);            assertEquals(expected, actual);            assertTrue(b.cumulativeProbability(actual) <= p);            assertTrue(b.cumulativeProbability(actual + 1) >= p);        } catch (MathException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.distribution;import org.apache.commons.math.MathException;import junit.framework.TestCase;/** * @version $Revision: 1.13 $ $Date: 2004/02/21 21:35:17 $ */public class ChiSquareDistributionTest extends TestCase {    private ChiSquaredDistribution chiSquare;    /** * Constructor for ChiSquareDistributionTest. * @param name */public ChiSquareDistributionTest(String name) {super(name);}/* * @see TestCase#setUp() */protected void setUp() throws Exception {super.setUp();        chiSquare = DistributionFactory.newInstance().createChiSquareDistribution(5.0);}/* * @see TestCase#tearDown() */protected void tearDown() throws Exception {        chiSquare = null;super.tearDown();}    public void testLowerTailProbability(){        testProbability( .210, .001);        testProbability( .554, .010);        testProbability( .831, .025);        testProbability(1.145, .050);        testProbability(1.610, .100);    }    public void testUpperTailProbability(){        testProbability(20.515, .999);        testProbability(15.086, .990);        testProbability(12.833, .975);        testProbability(11.070, .950);        testProbability( 9.236, .900);    }        public void testLowerTailValues(){        testValue(.001,  .210);        testValue(.010,  .554);        testValue(.025,  .831);        testValue(.050, 1.145);        testValue(.100, 1.610);    }        public void testUpperTailValues(){        testValue(.999, 20.515);        testValue(.990, 15.086);        testValue(.975, 12.833);        testValue(.950, 11.070);        testValue(.900,  9.236);    }        private void testProbability(double x, double expected){        try {            double actual = chiSquare.cumulativeProbability(x);            assertEquals("probability for " + x, expected, actual, 10e-4);        } catch (MathException e) {            e.printStackTrace();        }            }        private void testValue(double p, double expected){        try {            double actual = chiSquare.inverseCumulativeProbability(p);            assertEquals("value for " + p, expected, actual, 10e-4);        } catch (MathException e) {            e.printStackTrace();        }            }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestSuite;import java.security.NoSuchProviderException;import java.security.NoSuchAlgorithmException;import java.util.HashSet;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.Frequency;import org.apache.commons.math.stat.inference.ChiSquareTestImpl;import org.apache.commons.math.stat.univariate.SummaryStatistics;/** * Test cases for the RandomData class. * * @version $Revision: 1.16 $ $Date: 2004/05/03 03:08:08 $ */public final class RandomDataTest extends RetryTestCase {    public RandomDataTest(String name) {        super(name);    }    private long smallSampleSize = 1000;    private double[] expected = {250,250,250,250};    private int largeSampleSize = 10000;    private int tolerance = 50;    private String[] hex =         {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};     private RandomDataImpl randomData = new RandomDataImpl();     private ChiSquareTestImpl testStatistic = new ChiSquareTestImpl();        public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(RandomDataTest.class);        suite.setName("RandomData Tests");        return suite;    }    /** test dispersion and failure modes for nextInt() */    public void testNextInt() {        try {            int x = randomData.nextInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextLong() */    public void testNextLong() {       try {            long x = randomData.nextLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }       Frequency freq = new Frequency();       long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureLong() */    public void testNextSecureLong() {        try {            long x = randomData.nextSecureLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureInt() */    public void testNextSecureInt() {        try {            long x = randomData.nextSecureInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Frequency freq = new Frequency();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        long[] observed = new long[4];        for (int i=0; i<4; i++) {            observed[i] = freq.getCount(i);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /**      * Make sure that empirical distribution of random Poisson(4)'s      * has P(X <= 5) close to actual cumulative Poisson probablity     * and that nextPoisson fails when mean is non-positive     * TODO: replace with statistical test, adding test stat to TestStatistic     */    public void testNextPoisson() {        try {            long x = randomData.nextPoisson(0);            fail("zero mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        Frequency f = new Frequency();        long v = 0;        for (int i = 0; i<largeSampleSize; i++) {            try {                f.addValue(randomData.nextPoisson(4.0d));            } catch (Exception ex) {                fail(ex.getMessage());            }        }        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2) +                         f.getCount(3) + f.getCount(4) + f.getCount(5);        long sumFreq = f.getSumFreq();        double cumPct =             new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();        assertEquals("cum Poisson(4)",cumPct,0.7851,0.2);        try {            long x = randomData.nextPoisson(-1);            fail("negative mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = randomData.nextPoisson(0);            fail("0 mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }            }        /** test dispersion and failute modes for nextHex() */    public void testNextHex() {        try {            String x = randomData.nextHexString(-1);            fail("negative length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextHexString(0);            fail("zero length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test dispersion and failute modes for nextHex() */    public void testNextSecureHex() {        try {            String x = randomData.nextSecureHexString(-1);            fail("negative length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextSecureHexString(0);            fail("zero length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextSecureHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextSecureHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextSecureHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Frequency f = new Frequency();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextSecureHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        long[] observed = new long[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test failure modes and dispersion of nextUniform() */      public void testNextUniform() {            try {            double x = randomData.nextUniform(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = randomData.nextUniform(3,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        double[] expected = {500,500};        long[] observed = {0,0};        double lower = -1d;        double upper = 20d;        double midpoint = (lower + upper)/2d;        double result = 0;        for (int i = 0; i < 1000; i++) {            result = randomData.nextUniform(lower,upper);            if ((result == lower) || (result == upper)) {                fail("generated value equal to an endpoint: " + result);            }             if (result < midpoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.64 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 10.83);      }        /** test failure modes and distribution of nextGaussian() */      public void testNextGaussian() {         try {            double x = randomData.nextGaussian(0,0);            fail("zero sigma -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        SummaryStatistics u = SummaryStatistics.newInstance();        for (int i = 0; i<largeSampleSize; i++) {            u.addValue(randomData.nextGaussian(0,1));        }        double xbar = u.getMean();        double s = u.getStandardDeviation();        double n = (double) u.getN();         /* t-test at .001-level TODO: replace with externalized t-test, with         * test statistic defined in TestStatistic         */        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);    }        /** test failure modes and distribution of nextExponential() */      public void testNextExponential() {        try {            double x = randomData.nextExponential(-1);            fail("negative mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8);         long cumFreq = 0;        double v = 0;        for (int i = 0; i < largeSampleSize; i++) {            v = randomData.nextExponential(1);            assertTrue("exponential deviate postive", v > 0);            if (v < 2) cumFreq++;        }        /* TODO: Replace with a statistical test, with statistic added to         * TestStatistic.  Check below compares observed cumulative distribution         * evaluated at 2 with exponential CDF          */        assertEquals("exponential cumulative distribution",            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);    }         /** test reseeding, algorithm/provider games */    public void testConfig() throws NoSuchProviderException,       NoSuchAlgorithmException{        randomData.reSeed(1000);        double v = randomData.nextUniform(0,1);        randomData.reSeed();        assertTrue("different seeds",             Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);        randomData.reSeed(1000);        assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12);        randomData.reSeedSecure(1000);        String hex = randomData.nextSecureHexString(40);        randomData.reSeedSecure();        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        randomData.reSeedSecure(1000);        assertTrue("same seeds",            !hex.equals(randomData.nextSecureHexString(40)));                 /* remove this test back soon,         * since it takes about 4 seconds */                 randomData.setSecureAlgorithm("SHA1PRNG","SUN");        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        try {            randomData.setSecureAlgorithm("NOSUCHTHING","SUN");            fail("expecting NoSuchAlgorithmException");        } catch (NoSuchAlgorithmException ex) {            ;        }                try {            randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");            fail("expecting NoSuchProviderException");        } catch (NoSuchProviderException ex) {            ;        }                 // test reseeding without first using the generators        RandomDataImpl rd = new RandomDataImpl();        rd.reSeed(100);        double ret = rd.nextLong(1,2);        RandomDataImpl rd2 = new RandomDataImpl();        rd2.reSeedSecure(2000);        ret = rd2.nextSecureLong(1,2);        rd = new RandomDataImpl();        rd.reSeed();        ret = rd.nextLong(1,2);        rd2 = new RandomDataImpl();        rd2.reSeedSecure();        ret = rd2.nextSecureLong(1,2);    }        /** tests for nextSample() sampling from Collection */    public void testNextSample() {       Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"},                        {"1","3"},{"1","4"},{"2","3"},{"2","4"},{"3","4"}};       long[] observed = {0,0,0,0,0,0,0,0,0,0};       double[] expected = {100,100,100,100,100,100,100,100,100,100};              HashSet cPop = new HashSet();  //{0,1,2,3,4}       for (int i = 0; i < 5; i++) {           cPop.add(Integer.toString(i));       }              Object[] sets = new Object[10]; // 2-sets from 5       for (int i = 0; i < 10; i ++) {           HashSet hs = new HashSet();           hs.add(c[i][0]);           hs.add(c[i][1]);           sets[i] = hs;       }              for (int i = 0; i < 1000; i ++) {           Object[] cSamp = randomData.nextSample(cPop,2);           observed[findSample(sets,cSamp)]++;       }               /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001         * Change to 21.67 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 27.88);                // Make sure sample of size = size of collection returns same collection       HashSet hs = new HashSet();       hs.add("one");       Object[] one = randomData.nextSample(hs,1);       String oneString = (String) one[0];       if ((one.length != 1) || !oneString.equals("one")){           fail("bad sample for set size = 1, sample size = 1");       }              // Make sure we fail for sample size > collection size       try {           one = randomData.nextSample(hs,2);           fail("sample size > set size, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }              // Make sure we fail for empty collection       try {           hs = new HashSet();           one = randomData.nextSample(hs,0);           fail("n = k = 0, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }    }        private int findSample(Object[] u, Object[] samp) {        int result = -1;        for (int i = 0; i < u.length; i++) {            HashSet set = (HashSet) u[i];            HashSet sampSet = new HashSet();            for (int j = 0; j < samp.length; j++) {                sampSet.add(samp[j]);            }            if (set.equals(sampSet)) {                                return i;           }        }        fail("sample not found:{" + samp[0] + "," + samp[1] + "}");        return -1;    }        /** tests for nextPermutation */    public void testNextPermutation() {        int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};        long[] observed = {0,0,0,0,0,0};        double[] expected = {100,100,100,100,100,100};                for (int i = 0; i < 600; i++) {            int[] perm = randomData.nextPermutation(3,3);            observed[findPerm(p,perm)]++;        }                  /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001         * Change to 15.09 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",                testStatistic.chiSquare(expected,observed) < 20.52);                 // Check size = 1 boundary case        int[] perm = randomData.nextPermutation(1,1);        if ((perm.length != 1) || (perm[0] != 0)){            fail("bad permutation for n = 1, sample k = 1");                        // Make sure we fail for k size > n             try {                perm = randomData.nextPermutation(2,3);                fail("permutation k > n, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                ;            }                        // Make sure we fail for n = 0            try {                perm = randomData.nextPermutation(0,0);                fail("permutation k = n = 0, expecting IllegalArgumentException");            } catch (IllegalArgumentException ex) {                ;            }                       }           }        private int findPerm(int[][] p, int[] samp) {        int result = -1;        for (int i = 0; i < p.length; i++) {            boolean good = true;            for (int j = 0; j < samp.length; j++) {                if (samp[j] != p[i][j]) {                    good = false;                }            }            if (good)  {                return i;            }        }                fail("permutation not found");        return -1;    }   }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.net.URL;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.univariate.SummaryStatistics; /** * Test cases for the ValueServer class. * * @version $Revision: 1.15 $ $Date: 2004/04/12 02:27:49 $ */public final class ValueServerTest extends RetryTestCase {    private ValueServer vs = new ValueServer();        public ValueServerTest(String name) {        super(name);    }    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        try {            URL url = getClass().getResource("testData.txt");            vs.setValuesFileURL(url);         } catch (Exception ex) {            fail("malformed test URL");        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ValueServerTest.class);        suite.setName("ValueServer Tests");        return suite;    }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNextDigest() throws Exception{        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        assertTrue("empirical distribution property",             vs.getEmpiricalDistribution() != null);        SummaryStatistics stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);                vs.computeDistribution(500);        stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(),             tolerance);            }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>      * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.resetReplayFile();        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        vs.closeReplayFile();        // make sure no NPE        vs.closeReplayFile();    }        /**      * Test other ValueServer modes     */    public void testModes() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(0);        assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE);        vs.setMode(ValueServer.UNIFORM_MODE);        vs.setMu(2);        double val = vs.getNext();        assertTrue(val > 0 && val < 4);        vs.setSigma(1);        vs.setMode(ValueServer.GAUSSIAN_MODE);        val = vs.getNext();        assertTrue("gaussian value close enough to mean",            val < vs.getMu() + 100*vs.getSigma());        vs.setMode(ValueServer.EXPONENTIAL_MODE);        val = vs.getNext();        assertTrue(val > 0);        try {            vs.setMode(1000);            vs.getNext();            fail("bad mode, expecting IllegalStateException");        } catch (IllegalStateException ex) {            ;        }    }        /**     * Test fill     */    public void testFill() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        vs.setMu(2);        double[] val = new double[5];        vs.fill(val);        for (int i = 0; i < 5; i++) {            assertEquals("fill test in place",2,val[i],Double.MIN_VALUE);        }        double v2[] = vs.fill(3);        for (int i = 0; i < 3; i++) {            assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE);        }    }        /**     * Test getters to make Clover happy     */    public void testProperties() throws Exception {        vs.setMode(ValueServer.CONSTANT_MODE);        assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode());        vs.setValuesFileURL("http://www.apache.org");        URL url = vs.getValuesFileURL();        assertEquals("valuesFileURL test","http://www.apache.org",url.toString());    }                          }
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.random;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStreamReader;import java.net.URL;import java.util.ArrayList;import java.util.Iterator;import org.apache.commons.math.RetryTestCase;import org.apache.commons.math.stat.univariate.SummaryStatistics;/** * Test cases for the EmpiricalDistribution class * * @version $Revision: 1.16 $ $Date: 2004/04/12 02:27:49 $ */public final class EmpiricalDistributionTest extends RetryTestCase {    protected EmpiricalDistribution empiricalDistribution = null;    protected EmpiricalDistribution empiricalDistribution2 = null;    protected File file = null;    protected URL url = null;     protected double[] dataArray = null;        public EmpiricalDistributionTest(String name) {        super(name);    }    public void setUp() throws IOException {        empiricalDistribution = new EmpiricalDistributionImpl(100);        url = getClass().getResource("testData.txt");                empiricalDistribution2 = new EmpiricalDistributionImpl(100);        BufferedReader in =                 new BufferedReader(new InputStreamReader(                        url.openStream()));        String str = null;        ArrayList list = new ArrayList();        while ((str = in.readLine()) != null) {            list.add(Double.valueOf(str));        }        in.close();        in = null;                dataArray = new double[list.size()];        int i = 0;        for (Iterator iter = list.iterator(); iter.hasNext();) {            dataArray[i] = ((Double)iter.next()).doubleValue();            i++;        }                     }    public static Test suite() {        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);        suite.setName("EmpiricalDistribution Tests");        return suite;    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testLoad() throws Exception {        empiricalDistribution.load(url);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }    /**     * Test EmpiricalDistrbution.load(double[]) using data taken from     * sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testDoubleLoad() throws Exception {        empiricalDistribution2.load(dataArray);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution2.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution2.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNext() throws Exception {        tstGen(0.1);        tstDoubleGen(0.1);    }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            empiricalDistribution2.getNextValue();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Make sure we can handle a grid size that is too fine     */    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1001);        tstGen(0.1);            empiricalDistribution2 = new EmpiricalDistributionImpl(1001);                   tstDoubleGen(0.1);    }        /**     * How about too fat?     */    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb        empiricalDistribution2 = new EmpiricalDistributionImpl(1);                   tstDoubleGen(5);               }        private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(url);           SummaryStatistics stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }    private void tstDoubleGen(double tolerance)throws Exception {        empiricalDistribution2.load(dataArray);           SummaryStatistics stats = SummaryStatistics.newInstance();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution2.getNextValue());        }        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import junit.framework.TestCase;/** * @version $Revision: 1.6 $ $Date: 2004/02/21 21:35:16 $ */public class ComplexTest extends TestCase {        public void testConstructor() {        Complex z = new Complex(3.0, 4.0);        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(4.0, z.getImaginary(), 1.0e-5);    }        public void testConstructorNaN() {        Complex z = new Complex(3.0, Double.NaN);        assertTrue(z.isNaN());        z = new Complex(Double.NaN, 4.0);        assertTrue(z.isNaN());        z = new Complex(3.0, 4.0);        assertFalse(z.isNaN());    }        public void testAbs() {        Complex z = new Complex(3.0, 4.0);        assertEquals(5.0, z.abs(), 1.0e-5);    }        public void testAbsNaN() {        assertTrue(Double.isNaN(Complex.NaN.abs()));    }        public void testAdd() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.add(y);        assertEquals(8.0, z.getReal(), 1.0e-5);        assertEquals(10.0, z.getImaginary(), 1.0e-5);    }        public void testAddNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.add(Complex.NaN);        assertTrue(z.isNaN());    }        public void testConjugate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.conjugate();        assertEquals(3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }        public void testConjugateNaN() {        Complex z = Complex.NaN.conjugate();        assertTrue(z.isNaN());    }        public void testDivide() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.divide(y);        assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);        assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);    }        public void testDivideNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.divide(Complex.NaN);        assertTrue(z.isNaN());    }        public void testMultiply() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.multiply(y);        assertEquals(-9.0, z.getReal(), 1.0e-5);        assertEquals(38.0, z.getImaginary(), 1.0e-5);    }        public void testMultiplyNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.multiply(Complex.NaN);        assertTrue(z.isNaN());    }        public void testNegate() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.negate();        assertEquals(-3.0, z.getReal(), 1.0e-5);        assertEquals(-4.0, z.getImaginary(), 1.0e-5);    }        public void testNegateNaN() {        Complex z = Complex.NaN.negate();        assertTrue(z.isNaN());    }        public void testSubtract() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(5.0, 6.0);        Complex z = x.subtract(y);        assertEquals(-2.0, z.getReal(), 1.0e-5);        assertEquals(-2.0, z.getImaginary(), 1.0e-5);    }        public void testSubtractNaN() {        Complex x = new Complex(3.0, 4.0);        Complex z = x.subtract(Complex.NaN);        assertTrue(z.isNaN());    }        public void testEqualsNull() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(null));    }        public void testEqualsClass() {        Complex x = new Complex(3.0, 4.0);        assertFalse(x.equals(this));    }        public void testEqualsSame() {        Complex x = new Complex(3.0, 4.0);        assertTrue(x.equals(x));    }        public void testEqualsTrue() {        Complex x = new Complex(3.0, 4.0);        Complex y = new Complex(3.0, 4.0);        assertTrue(x.equals(y));    }        public void testEqualsRealDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);        assertFalse(x.equals(y));    }        public void testEqualsImaginaryDifference() {        Complex x = new Complex(0.0, 0.0);        Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);        assertFalse(x.equals(y));    }}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import junit.framework.TestCase;public class ComplexFormatTest extends TestCase { ComplexFormat complexFormat = null;ComplexFormat complexFormatJ = null;    public ComplexFormatTest(String name) {        super( name );    }protected void setUp() throws Exception {complexFormat = new ComplexFormat();complexFormatJ = new ComplexFormat("j");}       public void testSimpleNoDecimals() {        Complex c = new Complex(1, 1);        assertEquals( complexFormat.format( c ), "1 + 1i" );    }public void testSimpleWithDecimals() {Complex c = new Complex(1.23, 1.43);assertEquals( complexFormat.format( c ), "1.23 + 1.43i" );}public void testSimpleWithDecimalsTrunc() {Complex c = new Complex(1.2323, 1.4343);assertEquals( complexFormat.format( c ), "1.23 + 1.43i" );}public void testNegativeReal() {Complex c = new Complex(-1.2323, 1.4343);assertEquals( complexFormat.format( c ), "-1.23 + 1.43i" );}public void testNegativeImaginary() {Complex c = new Complex(1.2323, -1.4343);assertEquals( complexFormat.format( c ), "1.23 - 1.43i" );}public void testNegativeBoth() {Complex c = new Complex(-1.2323, -1.4343);assertEquals( complexFormat.format( c ), "-1.23 - 1.43i" );}public void testZeroReal() {Complex c = new Complex(0.0, -1.4343);assertEquals( complexFormat.format( c ), "0 - 1.43i" );}public void testZeroImaginary() {Complex c = new Complex(30.233, 0);assertEquals( complexFormat.format( c ), "30.23" );}public void testDifferentImaginaryChar() {Complex c = new Complex(1, 1);assertEquals( complexFormatJ.format( c ), "1 + 1j" );}public void testStaticFormatComplex() {Complex c = new Complex(232.222, -342.33);assertEquals( ComplexFormat.formatComplex( c ), "232.22 - 342.33i" );}}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.complex;import org.apache.commons.math.TestUtils;import junit.framework.TestCase;/** * @version $Revision: 1.3 $ $Date: 2004/02/21 21:35:16 $ */public class ComplexMathTest extends TestCase {        public void testAcos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.936812, -2.30551);        TestUtils.assertEquals(expected, ComplexMath.acos(z), 1.0e-5);    }        public void testAcosNaN() {        assertTrue(ComplexMath.acos(Complex.NaN).isNaN());    }        public void testAsin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(0.633984, 2.30551);        TestUtils.assertEquals(expected, ComplexMath.asin(z), 1.0e-5);    }        public void testAsinNaN() {        assertTrue(ComplexMath.asin(Complex.NaN).isNaN());    }        public void testAtan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.44831, 0.158997);        TestUtils.assertEquals(expected, ComplexMath.atan(z), 1.0e-5);    }        public void testAtanNaN() {        assertTrue(ComplexMath.atan(Complex.NaN).isNaN());    }        public void testCos() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-27.03495, -3.851153);        TestUtils.assertEquals(expected, ComplexMath.cos(z), 1.0e-5);    }        public void testCosh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.58066, -7.58155);        TestUtils.assertEquals(expected, ComplexMath.cosh(z), 1.0e-5);    }        public void testCoshNaN() {        assertTrue(ComplexMath.cosh(Complex.NaN).isNaN());    }        public void testCosNaN() {        assertTrue(ComplexMath.cos(Complex.NaN).isNaN());    }        public void testExp() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-13.12878, -15.20078);        TestUtils.assertEquals(expected, ComplexMath.exp(z), 1.0e-5);    }        public void testExpNaN() {        assertTrue(ComplexMath.exp(Complex.NaN).isNaN());    }        public void testLog() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.60944, 0.927295);        TestUtils.assertEquals(expected, ComplexMath.log(z), 1.0e-5);    }        public void testLogNaN() {        assertTrue(ComplexMath.log(Complex.NaN).isNaN());    }        public void testPow() {        Complex x = new Complex(3, 4);        Complex y = new Complex(5, 6);        Complex expected = new Complex(-1.860893, 11.83677);        TestUtils.assertEquals(expected, ComplexMath.pow(x, y), 1.0e-5);    }        public void testPowNaNBase() {        Complex x = new Complex(3, 4);        assertTrue(ComplexMath.pow(Complex.NaN, x).isNaN());    }        public void testPowNaNExponent() {        Complex x = new Complex(3, 4);        assertTrue(ComplexMath.pow(x, Complex.NaN).isNaN());    }        public void testSin() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(3.853738, -27.01681);        TestUtils.assertEquals(expected, ComplexMath.sin(z), 1.0e-5);    }        public void testSinh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-6.54812, -7.61923);        TestUtils.assertEquals(expected, ComplexMath.sinh(z), 1.0e-5);    }        public void testSinhNaN() {        assertTrue(ComplexMath.sinh(Complex.NaN).isNaN());    }        public void testSinNaN() {        assertTrue(ComplexMath.sin(Complex.NaN).isNaN());    }        public void testSqrtRealPositive() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(2, 1);        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);    }        public void testSqrtRealZero() {        Complex z = new Complex(0.0, 4);        Complex expected = new Complex(1.41421, 1.41421);        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);    }        public void testSqrtRealNegative() {        Complex z = new Complex(-3.0, 4);        Complex expected = new Complex(1, 2);        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);    }        public void testSqrtImaginaryZero() {        Complex z = new Complex(-3.0, 0.0);        Complex expected = new Complex(0.0, 1.73205);        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);    }        public void testSqrtImaginaryNegative() {        Complex z = new Complex(-3.0, -4.0);        Complex expected = new Complex(1.0, -2.0);        TestUtils.assertEquals(expected, ComplexMath.sqrt(z), 1.0e-5);    }    public void testSqrt1z() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(4.08033, -2.94094);        TestUtils.assertEquals(expected, ComplexMath.sqrt1z(z), 1.0e-5);    }        public void testSqrt1zNaN() {        assertTrue(ComplexMath.sqrt1z(Complex.NaN).isNaN());    }        public void testSqrtNaN() {        assertTrue(ComplexMath.sqrt(Complex.NaN).isNaN());    }        public void testTan() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(-0.000187346, 0.999356);        TestUtils.assertEquals(expected, ComplexMath.tan(z), 1.0e-5);    }        public void testTanh() {        Complex z = new Complex(3, 4);        Complex expected = new Complex(1.00071, 0.00490826);        TestUtils.assertEquals(expected, ComplexMath.tanh(z), 1.0e-5);    }        public void testTanhNaN() {        assertTrue(ComplexMath.tanh(Complex.NaN).isNaN());    }        public void testTanNaN() {        assertTrue(ComplexMath.tan(Complex.NaN).isNaN());    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;/** * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:16 $ */public class MathExceptionTest extends TestCase {    /**     *      */    public void testConstructor(){        MathException ex = new MathException();        assertNull(ex.getCause());        assertNull(ex.getMessage());    }        /**     *      */    public void testConstructorMessage(){        String msg = "message";        MathException ex = new MathException(msg);        assertNull(ex.getCause());        assertEquals(msg, ex.getMessage());    }        /**     *      */    public void testConstructorMessageCause(){        String outMsg = "outer message";        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(outMsg, cause);        assertEquals(outMsg, ex.getMessage());        assertEquals(cause, ex.getCause());    }        /**     *      */    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathException ex = new MathException(cause);        assertEquals(cause, ex.getCause());    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import junit.framework.TestCase;/** * @version $Revision: 1.7 $ $Date: 2004/02/21 21:35:16 $ */public class MathConfigurationExceptionTest extends TestCase {    /**     *      */    public void testConstructor(){        MathConfigurationException ex = new MathConfigurationException();        assertNull(ex.getCause());        assertNull(ex.getMessage());    }        /**     *      */    public void testConstructorMessage(){        String msg = "message";        MathConfigurationException ex = new MathConfigurationException(msg);        assertNull(ex.getCause());        assertEquals(msg, ex.getMessage());    }        /**     *      */    public void testConstructorMessageCause(){        String outMsg = "outer message";        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(outMsg, cause);        assertEquals(outMsg, ex.getMessage());        assertEquals(cause, ex.getCause());    }        /**     *      */    public void testConstructorCause(){        String inMsg = "inner message";        Exception cause = new Exception(inMsg);        MathConfigurationException ex = new MathConfigurationException(cause);        assertEquals(cause, ex.getCause());    }}
/* * Copyright 2003-2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import junit.framework.Assert;import org.apache.commons.math.complex.Complex;/** * @version $Revision: 1.12 $ $Date: 2004/04/02 21:30:08 $ */public class TestUtils {    /**     *      */    private TestUtils() {        super();    }    public static void assertEquals(double expected, double actual, double delta) {    assertEquals(null, expected, actual, delta);    }    public static void assertEquals(String msg, double expected, double actual, double delta) {    // check for NaN    if(Double.isNaN(expected)){    Assert.assertTrue(msg, Double.isNaN(actual));    } else {    Assert.assertEquals(msg, expected, actual, delta);    }    }        /**     *      */    public static void assertEquals(Complex expected, Complex actual, double delta) {        assertEquals(expected.getReal(), actual.getReal(), delta);        assertEquals(expected.getImaginary(), actual.getImaginary(), delta);    }        /**     * Verifies that two double arrays have equal entries, up to tolerance     */    public static void assertEquals(double a[], double b[], double tolerance) {        Assert.assertEquals(a.length, b.length);        for (int i = 0; i < a.length; i++) {            Assert.assertEquals(a[i], b[i], tolerance);        }    }        public static Object serializeAndRecover(Object o){                Object result = null;                File tmp = null;                try {                        // serialize the Object            tmp = File.createTempFile("test",".ser");            FileOutputStream fo = new FileOutputStream(tmp);            ObjectOutputStream so = new ObjectOutputStream(fo);            so.writeObject(o);            so.flush();            // deserialize the Book            FileInputStream fi = new FileInputStream(tmp);            ObjectInputStream si = new ObjectInputStream(fi);              result = si.readObject();                    }catch (Exception e) {            e.printStackTrace();        }finally{            if(tmp != null) tmp.delete();        }                return result;    }}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;/** * An interface for Chi-Square tests. *  * @version $Revision: 1.1 $ $Date: 2004/05/03 03:02:25 $  */public interface ChiSquareTest {          /**     * Computes the <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code>      * freqeuncy counts.      * <p>     * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that     *  the observed counts follow the expected distribution.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(double[] expected, long[] observed)         throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> comparing the <code>observed</code>      * frequency counts to those in the <code>expected</code> array.     * <p>     * The number returned is the smallest significance level at which one can reject      * the null hypothesis that the observed counts conform to the frequency distribution      * described by the expected counts.      * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(double[] expected, long[] observed)         throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm">     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts      * conform to the frequency distribution described by the expected counts, with      * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * <strong>Example:</strong><br>     * To test the hypothesis that <code>observed</code> follows      * <code>expected</code> at the 99% level, use <p>     * <code>chiSquareTest(expected, observed, 0.01) </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts must all be positive.       * </li>     * <li>Observed counts must all be >= 0.        * </li>     * <li>The observed and expected arrays must have the same length and     * their common length must be at least 2.       * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(double[] expected, long[] observed, double alpha)         throws IllegalArgumentException, MathException;        /**     *  Computes the Chi-Square statistic associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     *  chi-square test of independence</a> based on the input <code>counts</code>     *  array, viewed as a two-way table.       * <p>     * The rows of the 2-way table are <code>count[0], ... , count[count.length - 1] </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param counts array representation of 2-way table     * @return chiSquare statistic     * @throws IllegalArgumentException if preconditions are not met     */    double chiSquare(long[][] counts)     throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or <a href=     * "http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> based on the input <code>counts</code>     * array, viewed as a two-way table.       * <p>     * The rows of the 2-way table are <code>count[0], ... , count[count.length - 1] </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param counts array representation of 2-way table     * @return p-value     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs computing the p-value     */    double chiSquareTest(long[][] counts)     throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm">     * chi-square test of independence</a> evaluating the null hypothesis that the classifications      * represented by the counts in the columns of the input 2-way table are independent of the rows,     * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected     * with 100 * (1 - alpha) percent confidence.     * <p>     * The rows of the 2-way table are <code>count[0], ... , count[count.length - 1] </code>     * <p>     * <strong>Example:</strong><br>     * To test the null hypothesis that the counts in <code>count[0], ... , count[count.length - 1] </code>     *  all correspond to the same underlying probability distribution at the 99% level, use <p>     * <code>chiSquareTest(counts, 0.01) </code>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>All counts must be >= 0.       * </li>     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).      * </li>     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and     *        at least 2 rows.     * </li>     * </li></ul><p>     * If any of the preconditions are not met, an      * <code>IllegalArgumentException</code> is thrown.     *     * @param observed array of observed frequency counts     * @param expected array of exptected frequency counts     * @param alpha significance level of the test     * @return true iff null hypothesis can be rejected with confidence     * 1 - alpha     * @throws IllegalArgumentException if preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean chiSquareTest(long[][] counts, double alpha)     throws IllegalArgumentException, MathException;}
/* * Copyright 2004 The Apache Software Foundation. *  * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *  *      http://www.apache.org/licenses/LICENSE-2.0 *  * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.math.stat.inference;import org.apache.commons.math.MathException;import org.apache.commons.math.stat.univariate.StatisticalSummary;/** * An interface for Student's t-tests. *  * @version $Revision: 1.1 $ $Date: 2004/05/03 03:03:21 $  */public interface TTest {    /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">      * t statistic </a> given observed values and a comparison constant.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 2.     * </li></ul>     *     * @param mu comparison constant     * @param observed array of values     * @return t statistic     * @throws IllegalArgumentException if input array length is less than 2     */    double t(double mu, double[] observed)     throws IllegalArgumentException;        /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * 2-sample t statistic </a>, without the assumption of equal sample variances.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 5.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if the statistic can not be computed do to a     *         convergence or other numerical error.     */    double t(double[] sample1, double[] sample2)     throws IllegalArgumentException, MathException;        /**     * Returns the <i>observed significance level</i>, or      * <a href="http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a two-sample, two-tailed t-test      * comparing the means of the input arrays.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.     * <p>     * The test does not assume that the underlying popuation variances are     * equal and it uses approximated degrees of freedom computed from the      * sample data as described      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">here</a>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 5.     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double[] sample1, double[] sample2)    throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>      * and <code>sample2</code> are drawn from populations with the same mean,      * with significance level <code>alpha</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha / 2</code>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>     * at the 99% level, first verify that the measured mean of      * <code>sample 1</code> is less than the mean of <code>sample 2</code>     * and then use <br><code>tTest(sample1, sample2, 0.005) </code>     * </li></ol>     * <p>     * The test does not assume that the underlying popuation variances are     * equal and it uses approximated degrees of freedom computed from the      * sample data as described      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">here</a>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array lengths must both be at least 5.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul>     *     * @param sample1 array of sample data values     * @param sample2 array of sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean tTest(double[] sample1, double[] sample2, double alpha)    throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from     *  which <code>sample</code> is drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be      * rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha / 2</code>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less      * than <code>mu</code> and then use      * <br><code>tTest(mu, sample, 0.005) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample      * parametric t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 5.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error computing the p-value     */    boolean tTest(double mu, double[] sample, double alpha)    throws IllegalArgumentException, MathException;        /**     * Returns the <i>observed significance level</i>, or      * <a href="http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a one-sample, two-tailed t-test      * comparing the mean of the input array with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals      * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the      * returned value by 2.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length must be at least 5.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sample array of sample data values     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double mu, double[] sample)    throws IllegalArgumentException, MathException;        /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula">     * t statistic </a> to use in comparing the dataset described by <code>sampleStats</code>     *  to <code>mu</code>.     * <p>     * This statistic can be used to perform a one sample t-test for the mean.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li><code>observed.getN() > = 2</code>.     * </li></ul>     *     * @param mu comparison constant     * @param sampleStats DescriptiveStatistics holding sample summary statitstics     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(double mu, StatisticalSummary sampleStats)     throws IllegalArgumentException;        /**     * Computes a <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">     * 2-sample t statistic </a>, comparing the means of the datasets described     * by two {@link StatisticalSummary} instances without the assumption of equal sample variances.     * <p>     * This statistic can be used to perform a two-sample t-test to compare     * sample means.     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 5 observations.     * </li></ul>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return t statistic     * @throws IllegalArgumentException if the precondition is not met     */    double t(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)     throws IllegalArgumentException;        /**     * Returns the <i>observed significance level</i>, or      * <a href="http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a two-sample, two-tailed t-test      * comparing the means of the datasets described by two Univariates.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the two means are     * equal in favor of the two-sided alternative that they are different.      * For a one-sided test, divide the returned value by 2.     * <p>     * The test does not assume that the underlying popuation variances are     * equal and it uses approximated degrees of freedom computed from the      * sample data as described      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">here</a>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the p-value depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 5 observations.     * </li></ul>     *     * @param sampleStats1 StatisticalSummary describing data from the first sample     * @param sampleStats2 StatisticalSummary describing data from the second sample     * @return p-value for t-test     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)    throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that <code>sampleStats1</code>     * and <code>sampleStats2</code> describe datasets drawn from populations with the      * same mean, with significance level <code>alpha</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis that the means are     * equal can be rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha / 2</code>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at     * the 95% level, use      * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>     * at the 99% level, first verify that the measured mean of      * <code>sample 1</code> is less than the mean of <code>sample 2</code>     * and then use <br><code>tTest(sampleStats1, sampleStats2, 0.005) </code>     * </li></ol>     * <p>     * The test does not assume that the underlying popuation variances are     * equal and it uses approximated degrees of freedom computed from the      * sample data as described      * <a href="http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm">here</a>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The datasets described by the two Univariates must each contain     * at least 5 observations.     * </li>     * <li> <code> 0 < alpha < 0.5 </code>     * </li></ul>     *     * @param sampleStats1 StatisticalSummary describing sample data values     * @param sampleStats2 StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return true if the null hypothesis can be rejected with      * confidence 1 - alpha     * @throws IllegalArgumentException if the preconditions are not met     * @throws MathException if an error occurs performing the test     */    boolean tTest(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2,             double alpha)    throws IllegalArgumentException, MathException;        /**     * Performs a <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm">     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from     * which the dataset described by <code>stats</code> is drawn equals <code>mu</code>.     * <p>     * Returns <code>true</code> iff the null hypothesis can be      * rejected with confidence <code>1 - alpha</code>.  To      * perform a 1-sided test, use <code>alpha / 2</code>     * <p>     * <strong>Examples:</strong><br><ol>     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>     * </li>     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>     * at the 99% level, first verify that the measured sample mean is less      * than <code>mu</code> and then use      * <br><code>tTest(mu, sampleStats, 0.005) </code>     * </li></ol>     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the one-sample      * parametric t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must include at least 5 observations.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data values     * @param alpha significance level of the test     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    boolean tTest(double mu, StatisticalSummary sampleStats, double alpha)    throws IllegalArgumentException, MathException;        /**     * Returns the <i>observed significance level</i>, or      * <a href="http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue">     * p-value</a>, associated with a one-sample, two-tailed t-test      * comparing the mean of the dataset described by <code>sampleStats</code>     * with the constant <code>mu</code>.     * <p>     * The number returned is the smallest significance level     * at which one can reject the null hypothesis that the mean equals      * <code>mu</code> in favor of the two-sided alternative that the mean     * is different from <code>mu</code>. For a one-sided test, divide the      * returned value by 2.     * <p>     * <strong>Usage Note:</strong><br>     * The validity of the test depends on the assumptions of the parametric     * t-test procedure, as discussed      * <a href="http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html">here</a>     * <p>     * <strong>Preconditions</strong>: <ul>     * <li>The sample must contain at least 5 observations.     * </li></ul>     *     * @param mu constant value to compare sample mean against     * @param sampleStats StatisticalSummary describing sample data     * @return p-value     * @throws IllegalArgumentException if the precondition is not met     * @throws MathException if an error occurs computing the p-value     */    double tTest(double mu, StatisticalSummary sampleStats)    throws IllegalArgumentException, MathException;}