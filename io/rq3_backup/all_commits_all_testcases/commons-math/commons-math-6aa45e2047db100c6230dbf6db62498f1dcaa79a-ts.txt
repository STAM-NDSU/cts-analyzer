/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @author Phil Steitz * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class BivariateRegressionTest extends TestCase {    /*      * NIST "Norris" refernce data set from      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat     * Strangely, order is {y,x}     */    private double[][] data = {{0.1,0.2},{338.8,337.4},{118.1,118.2},        {888.0,884.6},{9.2,10.1},{228.1,226.5},{668.5,666.3},{998.5,996.3},        {449.1,448.6},{778.9,777.0},{559.2,558.2},{0.3,0.4},{0.1,0.6},        {778.1,775.5},{668.8,666.9},{339.3,338.0},{448.9,447.5},{10.8,11.6},        {557.7,556.0},{228.3,228.1},{998.0,995.8},{888.8,887.6},{119.6,120.2},        {0.3,0.3},{0.6,0.3},{557.6,556.8},{339.3,339.1},{888.0,887.2},        {998.5,999.0},{778.9,779.0},{10.2,11.1},{117.6,118.3},{228.9,229.2},        {668.4,669.1},{449.2,448.9},{0.2,0.5}};             /*      * Correlation example from      * http://www.xycoon.com/correlation.htm     */    private double[][] corrData = {{101.0,99.2},{100.1,99.0},{100.0,100.0},        {90.6,111.6},{86.5,122.2},{89.7,117.6},{90.6,121.1},{82.8,136.0},        {70.1,154.2},{65.4,153.6},{61.3,158.5},{62.5,140.6},{63.6,136.2},        {52.6,168.0},{59.7,154.3},{59.5,149.0},{61.3,165.5}};        public BivariateRegressionTest(String name) {        super(name);    }        public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(BivariateRegressionTest.class);        suite.setName("BivariateRegression Tests");        return suite;    }        public void testNorris() {       BivariateRegression regression = new BivariateRegression();       for (int i = 0; i < data.length; i++) {           regression.addData(data[i][1],data[i][0]);       }       assertEquals("slope",1.00211681802045,             regression.getSlope(),10E-12);       assertEquals("slope std err",0.429796848199937E-03,             regression.getSlopeStdErr(),10E-12);       assertEquals("number of observations",36,regression.getN());       assertEquals("intercept", -0.262323073774029,            regression.getIntercept(),10E-12);       assertEquals("std err intercept", 0.232818234301152,             regression.getInterceptStdErr(),10E-12);       assertEquals("r-square",0.999993745883712,            regression.getRSquare(),10E-12);       assertEquals("SSR",4255954.13232369,             regression.getRegressionSumSquares(),10E-8);       assertEquals("MSE",0.782864662630069,             regression.getMeanSquareError(),10E-8);       assertEquals("SSE",26.6173985294224,             regression.getSumSquaredErrors(),10E-8);       assertEquals("predict(0)",-0.262323073774029,            regression.predict(0),10E-12);       assertEquals("predict(1)",1.00211681802045-0.262323073774029,            regression.predict(1),10E-11);    }        public void testCorr() {       BivariateRegression regression = new BivariateRegression();       regression.addData(corrData);       assertEquals("number of observations",17,regression.getN());       assertEquals("r-square",.896123,            regression.getRSquare(),10E-6);       assertEquals("r",-.946638,             regression.getR(),10E-6);    }          public void testNaNs() {                BivariateRegression regression = new BivariateRegression();                assertTrue("intercept not NaN",Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN",Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN",            Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN",            Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN",Double.isNaN(regression.getR()));        assertTrue("r-square not NaN",Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN",            Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO not NaN",Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict not NaN",Double.isNaN(regression.predict(0)));                regression.addData(1,2);        regression.addData(1,3);                // No x variation, so these should still blow...        assertTrue("intercept not NaN",Double.isNaN(regression.getIntercept()));        assertTrue("slope not NaN",Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN",            Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN",            Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));        assertTrue("e not NaN",Double.isNaN(regression.getR()));        assertTrue("r-square not NaN",Double.isNaN(regression.getRSquare()));        assertTrue("RSS not NaN",            Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("predict not NaN",Double.isNaN(regression.predict(0)));                // but SSTO should be OK         assertTrue("SSTO NaN",!Double.isNaN(regression.getTotalSumSquares()));                regression = new BivariateRegression();                regression.addData(1,2);        regression.addData(3,3);                // All should be OK except MSE, s(b0), s(b1) which need one more df         assertTrue("interceptNaN",!Double.isNaN(regression.getIntercept()));        assertTrue("slope NaN",!Double.isNaN(regression.getSlope()));        assertTrue("slope std err not NaN",            Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err not NaN",            Double.isNaN(regression.getInterceptStdErr()));        assertTrue("MSE not NaN",Double.isNaN(regression.getMeanSquareError()));        assertTrue("r NaN",!Double.isNaN(regression.getR()));        assertTrue("r-square NaN",!Double.isNaN(regression.getRSquare()));        assertTrue("RSS NaN",            !Double.isNaN(regression.getRegressionSumSquares()));        assertTrue("SSE NaN",!Double.isNaN(regression.getSumSquaredErrors()));        assertTrue("SSTO NaN",!Double.isNaN(regression.getTotalSumSquares()));        assertTrue("predict NaN",!Double.isNaN(regression.predict(0)));                regression.addData(1,4);                // MSE, MSE, s(b0), s(b1) should all be OK now        assertTrue("MSE NaN",!Double.isNaN(regression.getMeanSquareError()));        assertTrue("slope std err NaN",            !Double.isNaN(regression.getSlopeStdErr()));        assertTrue("intercept std err NaN",            !Double.isNaN(regression.getInterceptStdErr()));    }        public void testClear() {       BivariateRegression regression = new BivariateRegression();       regression.addData(corrData);       assertEquals("number of observations",17,regression.getN());       regression.clear();       assertEquals("number of observations",0,regression.getN());       regression.addData(corrData);       assertEquals("r-square",.896123,regression.getRSquare(),10E-6);       regression.addData(data);       assertEquals("number of observations",53,regression.getN());    }                    }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @author <a href="mailto:phil@steitz.com">Phil Steitz</a> * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class StoreUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = StoreUnivariate.LEPTOKURTIC;    private double tolerance = 10E-15;        public StoreUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(StoreUnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {        StoreUnivariate u = new StoreUnivariateImpl();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    StoreUnivariate u = new StoreUnivariateImpl();        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );u.addValue(one);assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    StoreUnivariate u = new StoreUnivariateImpl();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,     9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    StoreUnivariateImpl u = new StoreUnivariateImpl();        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0, u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @author <a href="mailto:phil@steitz.com">Phil Steitz</a> * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class ListUnivariateImplTest extends TestCase {    private double one = 1;    private float two = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double skewness = 0;    private double kurtosis = 0.5;    private int kClass = StoreUnivariate.LEPTOKURTIC;    private double tolerance = 10E-15;        public ListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {    List externalList = new ArrayList();            StoreUnivariate u = new ListUnivariateImpl( externalList );         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(two);        u.addValue(two);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    List list = new ArrayList();        StoreUnivariate u = new ListUnivariateImpl( list );        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );list.add( new Double(one));assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    StoreUnivariate u = new StoreUnivariateImpl();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,     9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0, u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Univariate} class. * * @author Phil Steitz * @author Tim Obrien * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class UnivariateImplTest extends TestCase {    private double one = 1;    private float twoF = 2;    private long twoL = 2;    private int three = 3;    private double mean = 2;    private double sumSq = 18;    private double sum = 8;    private double var = 0.666666666666666666667;    private double std = Math.sqrt(var);    private double n = 4;    private double min = 1;    private double max = 3;    private double tolerance = 10E-15;        public UnivariateImplTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(UnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {        UnivariateImpl u = new UnivariateImpl();         assertEquals("total count",0,u.getN(),tolerance);        u.addValue(one);        u.addValue(twoF);        u.addValue(twoL);        u.addValue(three);        assertEquals("N",n,u.getN(),tolerance);        assertEquals("sum",sum,u.getSum(),tolerance);        assertEquals("sumsq",sumSq,u.getSumsq(),tolerance);        assertEquals("var",var,u.getVariance(),tolerance);        assertEquals("std",std,u.getStandardDeviation(),tolerance);        assertEquals("mean",mean,u.getMean(),tolerance);        assertEquals("min",min,u.getMin(),tolerance);        assertEquals("max",max,u.getMax(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testN0andN1Conditions() throws Exception {    UnivariateImpl u = new UnivariateImpl();        assertTrue("Mean of n = 0 set should be NaN",             Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN",             Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN",             Double.isNaN(u.getVariance() ) );assertTrue("skew of n = 0 set should be NaN",Double.isNaN(u.getSkewness() ) );assertTrue("kurtosis of n = 0 set should be NaN", Double.isNaN(u.getKurtosis() ) );/* n=1 */u.addValue(one);assertTrue("mean should be one (n = 1)", u.getMean() == one);assertTrue("geometric should be one (n = 1)", u.getGeometricMean() == one);assertTrue("Std should be zero (n = 1)", u.getStandardDeviation() == 0.0);assertTrue("variance should be zero (n = 1)", u.getVariance() == 0.0);assertTrue("skew should be zero (n = 1)", u.getSkewness() == 0.0);assertTrue("kurtosis should be zero (n = 1)", u.getKurtosis() == 0.0);/* n=2 */u.addValue(twoF);assertTrue("Std should not be zero (n = 2)", u.getStandardDeviation() != 0.0);assertTrue("variance should not be zero (n = 2)", u.getVariance() != 0.0);assertTrue("skew should not be zero (n = 2)", u.getSkewness() == 0.0);assertTrue("kurtosis should be zero (n = 2)", u.getKurtosis() == 0.0);/* n=3 */u.addValue(twoL);assertTrue("skew should not be zero (n = 3)", u.getSkewness() != 0.0);assertTrue("kurtosis should be zero (n = 3)", u.getKurtosis() == 0.0);        /* n=4 */u.addValue(three);assertTrue("kurtosis should not be zero (n = 4)", u.getKurtosis() != 0.0);                        }    public void testProductAndGeometricMean() throws Exception {    UnivariateImpl u = new UnivariateImpl(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(),            Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364,             u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0,             u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931,             u.getGeometricMean(), 0.00001 );    }        public void testRollingMinMax() {        UnivariateImpl u = new UnivariateImpl(3);        u.addValue( 1.0 );        u.addValue( 5.0 );        u.addValue( 3.0 );        u.addValue( 4.0 ); // discarding min        assertEquals( "min not expected", 3.0,             u.getMin(), Double.MIN_VALUE);        u.addValue(1.0);  // discarding max        assertEquals( "max not expected", 4.0,             u.getMax(), Double.MIN_VALUE);    }        public void testNaNContracts() {        UnivariateImpl u = new UnivariateImpl();        double nan = Double.NaN;        assertTrue("mean not NaN",Double.isNaN(u.getMean()));         assertTrue("min not NaN",Double.isNaN(u.getMin()));         assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation()));         assertTrue("var not NaN",Double.isNaN(u.getVariance()));         assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(1.0);                assertEquals( "mean not expected", 1.0,             u.getMean(), Double.MIN_VALUE);        assertEquals( "variance not expected", 0.0,             u.getVariance(), Double.MIN_VALUE);        assertEquals( "geometric mean not expected", 1.0,             u.getGeometricMean(), Double.MIN_VALUE);                u.addValue(-1.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                u.addValue(0.0);                assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean()));                //FiXME: test all other NaN contract specs    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat;import java.util.ArrayList;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.math.beans.*;/** * Test cases for the {@link BeanListUnivariateImpl} class. * * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> * @version $Revision: 1.1 $ $Date: 2003/05/29 20:35:46 $ */public final class BeanListUnivariateImplTest extends TestCase {        private List patientList = null;    private double tolerance = Double.MIN_VALUE;        public BeanListUnivariateImplTest(String name) {        super(name);    }        public void setUp() {          patientList = new ArrayList();        // Create and add patient bean 1        VitalStats vs1 = new VitalStats( new Double(120.0),                                          new Double(96.4) );        Patient p1 = new Patient( vs1, new Integer( 35 ) );        patientList.add( p1 );        // Create and add patient bean 2        VitalStats vs2 = new VitalStats( new Double(70.0),                                          new Double(97.4) );        Patient p2 = new Patient( vs2, new Integer( 23 ) );        patientList.add( p2 );        // Create and add patient bean 3        VitalStats vs3 = new VitalStats( new Double(90.0),                                          new Double(98.6) );        Patient p3 = new Patient( vs3, new Integer( 42 ) );        patientList.add( p3 );    }        public static Test suite() {        TestSuite suite = new TestSuite(BeanListUnivariateImplTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test stats */    public void testStats() {            StoreUnivariate u = new BeanListUnivariateImpl( patientList );         assertEquals("total count",3,u.getN(),tolerance);        u.clear();        assertEquals("total count",0,u.getN(),tolerance);        }             public void testPropStats() {        StoreUnivariate heartU = new BeanListUnivariateImpl( patientList,                                          "vitalStats.heartRate" );                assertEquals( "Mean heart rate unexpected", 93.333,                       heartU.getMean(), 0.001 );        assertEquals( "Max heart rate unexpected", 120.0,                       heartU.getMax(), 0.001 );        StoreUnivariate ageU = new BeanListUnivariateImpl( patientList,                                                           "age" );        assertEquals( "Mean age unexpected", 33.333,                      ageU.getMean(), 0.001 );        assertEquals( "Max age unexpected", 42.0,                      ageU.getMax(), 0.001 );    }    /*    public void testN0andN1Conditions() throws Exception {    List list = new ArrayList();        StoreUnivariate u = new ListUnivariateImpl( list );        assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) );assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) );assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) );list.add( new Double(one));assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one);assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0);assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0);    }        public void testSkewAndKurtosis() {    StoreUnivariate u = new StoreUnivariateImpl();        double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,     9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };    for( int i = 0; i < testArray.length; i++) {    u.addValue( testArray[i]);    }    assertEquals("mean", 12.40455, u.getMean(), 0.0001);assertEquals("variance", 10.00236, u.getVariance(), 0.0001);assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001);    assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001);    }    public void testProductAndGeometricMean() throws Exception {    ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());        u.setWindowSize(10);                u.addValue( 1.0 );        u.addValue( 2.0 );        u.addValue( 3.0 );        u.addValue( 4.0 );        assertEquals( "Product not expected", 24.0, u.getProduct(), Double.MIN_VALUE );        assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 );        // Now test rolling - UnivariateImpl should discount the contribution        // of a discarded element        for( int i = 0; i < 10; i++ ) {            u.addValue( i + 2 );        }        // Values should be (2,3,4,5,6,7,8,9,10,11)                assertEquals( "Product not expected", 39916800.0, u.getProduct(), 0.00001 );        assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 );        } */}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class DistributionFactoryImplTest extends TestCase {    /** */    private DistributionFactory factory;    /** * Constructor for DistributionFactoryImplTest. * @param name */public DistributionFactoryImplTest(String name) {super(name);}/** * @throws java.lang.Exception */protected void setUp() throws Exception {super.setUp();        factory = new DistributionFactoryImpl();}/** * @throws java.lang.Exception */protected void tearDown() throws Exception {        factory = null;super.tearDown();}        public void testCreateChiSquareDistributionNegative(){        try {            factory.createChiSquareDistribution(-1.0);            fail("negative degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionZero(){        try {            factory.createChiSquareDistribution(0.0);            fail("zero degrees of freedom.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateChiSquareDistributionPositive(){        try {            factory.createChiSquareDistribution(1.0);        } catch (IllegalArgumentException ex) {            fail("positive degrees of freedom.  IllegalArgumentException is not expected");        }    }        public void testCreateGammaDistributionNegativePositive(){        try {            factory.createGammaDistribution(-1.0, 1.0);            fail("negative alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionZeroPositive(){        try {            factory.createGammaDistribution(0.0, 1.0);            fail("zero alpha.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveNegative(){        try {            factory.createGammaDistribution(1.0, -1.0);            fail("negative beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositiveZero(){        try {            factory.createGammaDistribution(1.0, 0.0);            fail("zero beta.  IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        public void testCreateGammaDistributionPositivePositive(){        try {            factory.createGammaDistribution(1.0, 1.0);        } catch (IllegalArgumentException ex) {            fail("positive alpah and beta.  IllegalArgumentException is not expected");        }    }//    //    public void testCreateTDistributionNegative(){//        try {//            factory.createTDistribution(-1.0);//            fail("negative degrees of freedom.  IllegalArgumentException expected");//        } catch (IllegalArgumentException ex) {//            ;//        }//    }//    //    public void testCreateTDistributionZero(){//        try {//            factory.createTDistribution(0.0);//            fail("zero degrees of freedom.  IllegalArgumentException expected");//        } catch (IllegalArgumentException ex) {//            ;//        }//    }//    //    public void testCreateTDistributionPositive(){//        try {//            factory.createTDistribution(1.0);//        } catch (IllegalArgumentException ex) {//            fail("positive degrees of freedom.  IllegalArgumentException is not expected");//        }//    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class GammaDistributionTest extends TestCase {/** * Constructor for ChiSquareDistributionTest. * @param name */public GammaDistributionTest(String name) {super(name);}    public void testProbabilities(){        testProbability(15.5, 4.0, 2.0, .9499);        testProbability( 0.5, 4.0, 1.0, .0018);        testProbability(10.0, 1.0, 2.0, .9933);        testProbability( 5.0, 2.0, 2.0, .7127);    }        private void testProbability(double x, double a, double b, double expected){        double actual = DistributionFactory.newInstance().createGammaDistribution(a, b).cummulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math.stat.distribution;import junit.framework.TestCase;/** * @author Brent Worden */public class ChiSquareDistributionTest extends TestCase {    private ChiSquaredDistribution chiSquare;    /** * Constructor for ChiSquareDistributionTest. * @param name */public ChiSquareDistributionTest(String name) {super(name);}/* * @see TestCase#setUp() */protected void setUp() throws Exception {super.setUp();        chiSquare = DistributionFactory.newInstance().createChiSquareDistribution(5.0);}/* * @see TestCase#tearDown() */protected void tearDown() throws Exception {        chiSquare = null;super.tearDown();}    public void testLowerTailProbability(){        testProbability( .210, .001);        testProbability( .554, .010);        testProbability( .831, .025);        testProbability(1.145, .050);        testProbability(1.610, .100);    }    public void testUpperTailProbability(){        testProbability(20.515, .999);        testProbability(15.086, .990);        testProbability(12.833, .975);        testProbability(11.070, .950);        testProbability( 9.236, .900);    }        public void testLowerTailValues(){        testValue(.001,  .210);        testValue(.010,  .554);        testValue(.025,  .831);        testValue(.050, 1.145);        testValue(.100, 1.610);    }        public void testUpperTailValues(){        testValue(.999, 20.515);        testValue(.990, 15.086);        testValue(.975, 12.833);        testValue(.950, 11.070);        testValue(.900,  9.236);    }        private void testProbability(double x, double expected){        double actual = chiSquare.cummulativeProbability(x);        assertEquals("probability for " + x, expected, actual, 10e-4);    }        private void testValue(double p, double expected){        double actual = chiSquare.inverseCummulativeProbability(p);        assertEquals("value for " + p, expected, actual, 10e-4);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.TestCase;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public abstract class DoubleArrayAbstractTest extends TestCase {protected DoubleArray da = null;// Array used to test rollingprotected DoubleArray ra = null;public DoubleArrayAbstractTest(String name) {super(name);}public void testAdd1000() {for (int i = 0; i < 1000; i++) {da.addElement(i);}assertEquals("Number of elements should be equal to 1000 after adding 1000 values",1000,da.getNumElements());assertEquals("The element at the 56th index should be 56",56.0,da.getElement(56),Double.MIN_VALUE);}public void testGetValues() {double[] controlArray = { 2.0, 4.0, 6.0 };da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);double[] testArray = da.getElements();for (int i = 0; i < da.getNumElements(); i++) {assertEquals("The testArray values should equal the controlArray values, index i: "+ i+ " does not match",testArray[i],controlArray[i],Double.MIN_VALUE);}}public void testAddElementRolling() {ra.addElement(0.5);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElement(1.0);ra.addElementRolling(2.0);assertEquals("There should be 6 elements in the eda",6,ra.getNumElements());assertEquals("The max element should be 2.0",2.0,ra.getMax(),Double.MIN_VALUE);assertEquals("The min element should be 1.0",1.0,ra.getMin(),Double.MIN_VALUE);for (int i = 0; i < 1024; i++) {ra.addElementRolling(i);}assertEquals("We just inserted 1024 rolling elements, num elements should still be 6",6,ra.getNumElements());}public void testMinMax() {da.addElement(2.0);da.addElement(22.0);da.addElement(-2.0);da.addElement(21.0);da.addElement(22.0);da.addElement(42.0);da.addElement(62.0);da.addElement(22.0);da.addElement(122.0);da.addElement(1212.0);assertEquals("Min should be -2.0", -2.0, da.getMin(), Double.MIN_VALUE);assertEquals("Max should be 1212.0",1212.0,da.getMax(),Double.MIN_VALUE);}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the TestStatistic class. * * @author Phil Steitz * @version $Revision: 1.3 $ $Date: 2003/05/26 17:29:36 $ */public final class TestStatisticTest extends TestCase {    private TestStatisticImpl testStatistic = new TestStatisticImpl();        public TestStatisticTest(String name) {        super(name);    }            public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(TestStatisticTest.class);        suite.setName("TestStatistic Tests");        return suite;    }    public void testChiSquare() {       double[] observed = {11,24,69,96};       double[] expected = {8.2,25.2,65.8,100.8};       assertEquals("chi-square statistic",            1.39743495,testStatistic.chiSquare(expected,observed),10E-5);              double[] tooShortObs = {0};       double[] tooShortEx = {1};       try {           testStatistic.chiSquare(tooShortObs,tooShortEx);           fail("arguments too short, IllegalArgumentException expected");       } catch (IllegalArgumentException ex) {           ;       }              double[] unMatchedObs = {0,1,2,3};       double[] unMatchedEx = {1,1,2};       try {           testStatistic.chiSquare(unMatchedEx,unMatchedObs);           fail("arrays have different lengths, IllegalArgumentException expected");       } catch (IllegalArgumentException ex) {           ;       }              expected[0] = 0;       assertEquals("chi-square statistic", Double.POSITIVE_INFINITY,            testStatistic.chiSquare(expected,observed),Double.MIN_VALUE);    }           public void testT(){double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0,            94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0};        double mu = 100.0;        assertEquals("t statistic", -2.82, testStatistic.t(mu, observed),            10E-3);                double[] nullObserved = null;        try {            testStatistic.t(mu, nullObserved);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }                double[] emptyObs = {};        try {            testStatistic.t(mu, emptyObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }                double[] tooShortObs = {1.0};        try {            testStatistic.t(mu, tooShortObs);            fail("arguments too short, IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public class ContractableDoubleArrayTest extends ExpandableDoubleArrayTest {public ContractableDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new ContractableDoubleArray();ra = new ContractableDoubleArray();}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public class FixedDoubleArrayTest extends DoubleArrayAbstractTest {public FixedDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new FixedDoubleArray(4000);}/* (non-Javadoc) * @see junit.framework.TestCase#tearDown() */protected void tearDown() throws Exception {da = null;}/** TEST NORMAL OPERATIONS - calling super class test and then checking internal *   storage **/public void testAddElementRolling() {ra = new FixedDoubleArray(6);super.testAddElementRolling();assertEquals( "FixedDoubleArray should have 6 size internal storage", 6, ((FixedDoubleArray) ra).internalArray.length);}public void testExceedingElements() {for( int i = 0; i < 3999; i++) {da.addElement( 1.0 );}da.addElement( 1.0 );try {da.addElement( 2.0 );fail( " Adding more than 4000 elements should cause an exception ");} catch( Exception e ) {}da.addElementRolling(2.0);assertEquals( "This is the first rolling add, the first element should be 2.0",2.0, da.getElement(0), Double.MIN_VALUE);}public void testGetExceeding() {try {da.getElement(100);fail( "I haven't added 100 elements to the list yet, trying to getElement(100) should " +"thrown an error");} catch (Exception e ){ }}public void testSetElement() {da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.setElement( 2, 4.0 );assertEquals( "Index 2 should be 4.0", 4.0, da.getElement(2), Double.MIN_VALUE);try {da.setElement(2000, 45.0);fail( "The array does not contain 2000 elements yet, setting this element should" +" cause an excpetion");} catch(Exception e) {}}public void testOnlyRolling() {for( int i = 0; i < 8000; i++) {da.addElementRolling( i );}assertEquals( "The 2000th element should equal 6000",6000.0, da.getElement(2000), Double.MIN_VALUE);}public void testClear() {for( int i = 0; i < 10; i++) {da.addElementRolling(1.0);}assertEquals( "There should be ten elements in the array",10, da.getNumElements() );da.clear();assertEquals( "There should be zero elements in the array",0, da.getNumElements() );for( int i = 0; i < 10; i++) {da.addElementRolling(1.0);}assertEquals( "There should be ten elements in the array",10, da.getNumElements() );}public void testDiscardFront() {try {da.discardFrontElements( 2 );fail( "Discard front elements should throw an exception");} catch( Exception e ) {}}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution.  * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;import java.security.NoSuchProviderException;import java.security.NoSuchAlgorithmException;import java.util.Collection;import java.util.HashSet;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl;/** * Test cases for the RandomData class. * * @author Phil Steitz * @version $Revision: 1.4 $ $Date: 2003/05/29 20:35:45 $ */public final class RandomDataTest extends TestCase {    public RandomDataTest(String name) {        super(name);    }    private long smallSampleSize = 1000;    private double[] expected = {250,250,250,250};    private int largeSampleSize = 10000;    private int tolerance = 50;    private String[] hex =         {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};     private RandomDataImpl randomData = new RandomDataImpl();     private TestStatisticImpl testStatistic = new TestStatisticImpl();            public void setUp() {     }    public static Test suite() {        TestSuite suite = new TestSuite(RandomDataTest.class);        suite.setName("RandomData Tests");        return suite;    }    /** test dispersion and failure modes for nextInt() */    public void testNextInt() {        try {            int x = randomData.nextInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Freq freq = new Freq();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextLong() */    public void testNextLong() {       try {            long x = randomData.nextLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }       Freq freq = new Freq();       long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureLong() */    public void testNextSecureLong() {        try {            long x = randomData.nextSecureLong(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Freq freq = new Freq();        long value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureLong(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /** test dispersion and failure modes for nextSecureInt() */    public void testNextSecureInt() {        try {            long x = randomData.nextSecureInt(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Freq freq = new Freq();        int value = 0;        for (int i=0;i<smallSampleSize;i++) {            value = randomData.nextSecureInt(0,3);            assertTrue("nextInt range",(value >= 0) && (value <= 3));            freq.addValue(value);          }        double[] observed = new double[4];        for (int i=0; i<4; i++) {            String iString = new Integer(i).toString();            observed[i] = freq.getCount(iString);        }                 /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001         * Change to 11.34 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 16.27);        }        /**      * Make sure that empirical distribution of random Poisson(4)'s      * has P(X <= 5) close to actual cumulative Poisson probablity     * and that nextPoisson fails when mean is non-positive     * TODO: replace with statistical test, adding test stat to TestStatistic     */    public void testNextPoisson() {        try {            long x = randomData.nextPoisson(0);            fail("zero mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        Freq f = new Freq();        long v = 0;        for (int i = 0; i<largeSampleSize; i++) {            try {                f.addValue(randomData.nextPoisson(4.0d));            } catch (Exception ex) {                fail(ex.getMessage());            }        }        long cumFreq = f.getCount("0") + f.getCount("1") + f.getCount("2") +                         f.getCount("3") + f.getCount("4") + f.getCount("5");        long sumFreq = f.getSumFreq();        double cumPct =             new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();        assertEquals("cum Poisson(4)",cumPct,0.7851,0.2);        try {            long x = randomData.nextPoisson(-1);            fail("negative mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            long x = randomData.nextPoisson(0);            fail("0 mean supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }            }        /** test dispersion and failute modes for nextHex() */    public void testNextHex() {        try {            String x = randomData.nextHexString(-1);            fail("negative length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextHexString(0);            fail("zero length supplied -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Freq f = new Freq();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        double[] observed = new double[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test dispersion and failute modes for nextHex() */    public void testNextSecureHex() {        try {            String x = randomData.nextSecureHexString(-1);            fail("negative length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            String x = randomData.nextSecureHexString(0);            fail("zero length -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        String hexString = randomData.nextSecureHexString(3);        if (hexString.length() != 3) {                fail("incorrect length for generated string");        }        hexString = randomData.nextSecureHexString(1);        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }        try {            hexString = randomData.nextSecureHexString(0);            fail("zero length requested -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        if (hexString.length() != 1) {                fail("incorrect length for generated string");        }              Freq f = new Freq();        for (int i = 0; i < smallSampleSize; i++) {            hexString = randomData.nextSecureHexString(100);            if (hexString.length() != 100) {                fail("incorrect length for generated string");            }            for (int j = 0; j < hexString.length(); j++) {                f.addValue(hexString.substring(j,j+1));            }        }        double[] expected = new double[16];        double[] observed = new double[16];        for (int i = 0; i < 16; i++) {            expected[i] = (double)smallSampleSize*100/(double)16;            observed[i] = f.getCount(hex[i]);        }        /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001         * Change to 30.58 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 37.70);        }        /** test failure modes and dispersion of nextUniform() */      public void testNextUniform() {            try {            double x = randomData.nextUniform(4,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        try {            double x = randomData.nextUniform(3,3);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        double[] expected = new double[] {500,500};        double[] observed = new double[] {0,0};        double lower = -1d;        double upper = 20d;        double midpoint = (lower + upper)/2d;        double result = 0;        for (int i = 0; i < 1000; i++) {            result = randomData.nextUniform(lower,upper);            if ((result == lower) || (result == upper)) {                fail("generated value equal to an endpoint: " + result);            }             if (result < midpoint) {                observed[0]++;            } else {                observed[1]++;            }        }        /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001         * Change to 6.64 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 10.83);      }        /** test failure modes and distribution of nextGaussian() */      public void testNextGaussian() {         try {            double x = randomData.nextGaussian(0,0);            fail("zero sigma -- IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }        Univariate u = new UnivariateImpl();        for (int i = 0; i<largeSampleSize; i++) {            u.addValue(randomData.nextGaussian(0,1));        }        double xbar = u.getMean();        double s = u.getStandardDeviation();        double n = (double) u.getN();         /* t-test at .001-level TODO: replace with externalized t-test, with         * test statistic defined in TestStatistic         */        assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29);    }        /** test failure modes and distribution of nextExponential() */      public void testNextExponential() {        try {            double x = randomData.nextExponential(-1);            fail("negative mean -- expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {            ;        }        assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8);         long cumFreq = 0;        double v = 0;        for (int i = 0; i < largeSampleSize; i++) {            v = randomData.nextExponential(1);            assertTrue("exponential deviate postive", v > 0);            if (v < 2) cumFreq++;        }        /* TODO: Replace with a statistical test, with statistic added to         * TestStatistic.  Check below compares observed cumulative distribution         * evaluated at 2 with exponential CDF          */        assertEquals("exponential cumulative distribution",            (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2);    }         /** test reseeding, algorithm/provider games */    public void testConfig() throws NoSuchProviderException,       NoSuchAlgorithmException{        randomData.reSeed(1000);        double v = randomData.nextUniform(0,1);        randomData.reSeed();        assertTrue("different seeds",             Math.abs(v - randomData.nextUniform(0,1)) > 10E-12);        randomData.reSeed(1000);        assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12);        randomData.reSeedSecure(1000);        String hex = randomData.nextSecureHexString(40);        randomData.reSeedSecure();        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        randomData.reSeedSecure(1000);        assertTrue("same seeds",            !hex.equals(randomData.nextSecureHexString(40)));                 /* TODO: probably should remove this test as the package grows,         * since it takes about 4 seconds         */        randomData.setSecureAlgorithm("SHA1PRNG","SUN");        assertTrue("different seeds",            !hex.equals(randomData.nextSecureHexString(40)));        try {            randomData.setSecureAlgorithm("NOSUCHTHING","SUN");            fail("expecting NoSuchAlgorithmException");        } catch (NoSuchAlgorithmException ex) {            ;        }                try {            randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER");            fail("expecting NoSuchProviderException");        } catch (NoSuchProviderException ex) {            ;        }          }        /** tests for nextSample() sampling from Collection */    public void testNextSample() {       Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"},                        {"1","3"},{"1","4"},{"2","3"},{"2","4"},{"3","4"}};       double[] observed = {0,0,0,0,0,0,0,0,0,0};       double[] expected = {100,100,100,100,100,100,100,100,100,100};              HashSet cPop = new HashSet();  //{0,1,2,3,4}       for (int i = 0; i < 5; i++) {           cPop.add(Integer.toString(i));       }              Object[] sets = new Object[10]; // 2-sets from 5       for (int i = 0; i < 10; i ++) {           HashSet hs = new HashSet();           hs.add(c[i][0]);           hs.add(c[i][1]);           sets[i] = hs;       }              for (int i = 0; i < 1000; i ++) {           Object[] cSamp = randomData.nextSample(cPop,2);           observed[findSample(sets,cSamp)]++;       }               /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001         * Change to 21.67 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 27.88);                // Make sure sample of size = size of collection returns same collection       HashSet hs = new HashSet();       hs.add("one");       Object[] one = randomData.nextSample(hs,1);       String oneString = (String) one[0];       if ((one.length != 1) || !oneString.equals("one")){           fail("bad sample for set size = 1, sample size = 1");       }              // Make sure we fail for sample size > collection size       try {           one = randomData.nextSample(hs,2);           fail("sample size > set size, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }              // Make sure we fail for empty collection       try {           hs = new HashSet();           one = randomData.nextSample(hs,0);           fail("n = k = 0, expecting IllegalArgumentException");       } catch (IllegalArgumentException ex) {           ;       }    }        private int findSample(Object[] u, Object[] samp) {        int result = -1;        for (int i = 0; i < u.length; i++) {            HashSet set = (HashSet) u[i];            HashSet sampSet = new HashSet();            for (int j = 0; j < samp.length; j++) {                sampSet.add(samp[j]);            }            if (set.equals(sampSet)) {                                return i;           }        }        fail("sample not found:{" + samp[0] + "," + samp[1] + "}");        return -1;    }        /** tests for nextPermutation */    public void testNextPermutation() {         int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};         double[] observed = {0,0,0,0,0,0,};         double[] expected = {100,100,100,100,100,100};                  for (int i = 0; i < 600; i++) {             int[] perm = randomData.nextPermutation(3,3);             observed[findPerm(p,perm)]++;         }                   /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001         * Change to 15.09 for alpha = .01         */        assertTrue("chi-square test -- will fail about 1 in 1000 times",            testStatistic.chiSquare(expected,observed) < 20.52);                   // Check size = 1 boundary case         int[] perm = randomData.nextPermutation(1,1);         if ((perm.length != 1) || (perm[0] != 0)){           fail("bad permutation for n = 1, sample k = 1");                   // Make sure we fail for k size > n         try {           perm = randomData.nextPermutation(2,3);           fail("permutation k > n, expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {           ;        }                   // Make sure we fail for n = 0        try {           perm = randomData.nextPermutation(0,0);           fail("permutation k = n = 0, expecting IllegalArgumentException");        } catch (IllegalArgumentException ex) {           ;        }                          }             }        private int findPerm(int[][] p, int[] samp) {        int result = -1;        for (int i = 0; i < p.length; i++) {            boolean good = true;            for (int j = 0; j < samp.length; j++) {                if (samp[j] != p[i][j]) {                    good = false;                }            }            if (good)  {                return i;            }        }                fail("permutation not found");        return -1;    }                                                               }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link Freq} class. * * @author Phil Steitz * @version $Revision: 1.1 $ $Date: 2003/05/12 19:04:38 $ */public final class FreqTest extends TestCase {    private long oneL = 1;    private long twoL = 2;    private int oneI = 1;    private int twoI = 2;    private String oneS = "1";    private String twoS = "2";    private double tolerance = 10E-15;        public FreqTest(String name) {        super(name);    }        public void setUp() {      }        public static Test suite() {        TestSuite suite = new TestSuite(FreqTest.class);        suite.setName("Freq Tests");        return suite;    }        /** test freq counts */    public void testCounts() {        Freq f = new Freq("test counts");         assertEquals("total count",0,f.getSumFreq());        f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneS);        f.addValue(oneI);        assertEquals("one frequency count",3,f.getCount("1"));        assertEquals("two frequency count",1,f.getCount("2"));        assertEquals("foo frequency count",0,f.getCount("foo"));        assertEquals("total count",4,f.getSumFreq());        f.clear();        assertEquals("total count",0,f.getSumFreq());    }             /** test pcts */    public void testPcts() {        Freq f = new Freq("test counts");         f.addValue(oneL);        f.addValue(twoL);        f.addValue(oneI);        f.addValue(twoI);        f.addValue("foo");        f.addValue("foo");        f.addValue("foo");        f.addValue("foo");        assertEquals("one pct",0.25,f.getPct("1"),tolerance);        assertEquals("two pct",0.25,f.getPct("2"),tolerance);        assertEquals("foo pct",0.5,f.getPct("foo"),tolerance);        assertEquals("bar pct",0,f.getPct("bar"),tolerance);    }      }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;/** * Test cases for the {@link RealMatrixImpl} class. * * @author Phil Steitz * @version $Revision: 1.1 $ $Date: 2003/05/12 19:02:53 $ */public final class RealMatrixImplTest extends TestCase {        private double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };    private double[][] testDataInv =         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };    private double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};    private double[][] testDataPlusInv =         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };    private double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };    private double[] testVector = {1,2,3};    private double entryTolerance = Math.pow(2,-64);    private double normTolerance = Math.pow(2,-64);        public RealMatrixImplTest(String name) {        super(name);    }        public void setUp() {            }        public static Test suite() {        TestSuite suite = new TestSuite(RealMatrixImplTest.class);        suite.setName("RealMatrixImpl Tests");        return suite;    }        /** test dimensions */    public void testDimensions() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData row dimension",3,m.getRowDimension());        assertEquals("testData column dimension",3,m.getColumnDimension());        assertTrue("testData is square",m.isSquare());        assertEquals("testData2 row dimension",m2.getRowDimension(),2);        assertEquals("testData2 column dimension",m2.getColumnDimension(),3);        assertTrue("testData2 is not square",!m2.isSquare());    }             /** test add */    public void testAdd() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);        double[][] sumEntries = mPlusMInv.getData();        for (int row = 0; row < m.getRowDimension(); row++) {            for (int col = 0; col < m.getColumnDimension(); col++) {                assertEquals("sum entry entry",                    testDataPlusInv[row][col],sumEntries[row][col],                        entryTolerance);            }        }        }        /** test add failure */    public void testAddFail() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        try {            RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(m2);            fail("IllegalArgumentException expected");        } catch (IllegalArgumentException ex) {            ;        }    }        /** test norm */    public void testNorm() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertEquals("testData norm",14d,m.getNorm(),entryTolerance);        assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance);    }         /** test m-n = m + -n */    public void testPlusMinus() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);        assertClose("m-n = m + -n",m.subtract(m2),            m2.scalarMultiply(-1d).add(m),entryTolerance);    }        /** test multiply */     public void testMultiply() {        RealMatrixImpl m = new RealMatrixImpl(testData);        RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);        RealMatrixImpl identity = new RealMatrixImpl(id);        RealMatrixImpl m2 = new RealMatrixImpl(testData2);        assertClose("inverse multiply",m.multiply(mInv),            identity,entryTolerance);        assertClose("inverse multiply",mInv.multiply(m),            identity,entryTolerance);        assertClose("identity multiply",m.multiply(identity),            m,entryTolerance);        assertClose("identity multiply",identity.multiply(mInv),            mInv,entryTolerance);        assertClose("identity multiply",m2.multiply(identity),            m2,entryTolerance);           }        private void assertClose(String msg, RealMatrix m, RealMatrix n,        double tolerance) {        assertTrue(msg,m.subtract(n).getNorm() < tolerance);    }        }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;import java.net.URL;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl; /** * Test cases for the ValueServer class. * * @author  Phil Steitz * @version $Revision: 1.3 $ */public final class ValueServerTest extends TestCase {    private ValueServer vs = new ValueServer();        public ValueServerTest(String name) {        super(name);    }    public void setUp() {        vs.setMode(ValueServer.DIGEST_MODE);        try {            URL url = getClass().getResource("testData.txt");            vs.setValuesFileURL(url.toExternalForm());         } catch (Exception ex) {            fail("malformed test URL");        }    }    public static Test suite() {        TestSuite suite = new TestSuite(ValueServerTest.class);        suite.setName("ValueServer Tests");        return suite;    }       /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNextDigest() throws Exception{        double next = 0.0;        double tolerance = 0.1;        vs.computeDistribution();        Univariate stats = new UnivariateImpl();        for (int i = 1; i < 1000; i++) {            next = vs.getNext();            stats.addValue(next);        }            assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance);        assertEquals         ("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance);    }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.      */    public void testNextDigestFail() throws Exception {        try {            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**      * Make sure exception thrown if nextReplay() is attempted      * before opening replay file.      */    public void testNextReplayFail() throws Exception {        try {            vs.setMode(ValueServer.REPLAY_MODE);            vs.getNext();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Test ValueServer REPLAY_MODE using values in testData file.<br>      * Check that the values 1,2,1001,1002 match data file values 1 and 2.     * the sample data file.     */    public void testReplay() throws Exception {        double firstDataValue = 4.038625496201205;        double secondDataValue = 3.6485326248346936;        double tolerance = 10E-15;        double compareValue = 0.0d;        vs.setMode(ValueServer.REPLAY_MODE);        vs.openReplayFile();        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);        for (int i = 3; i < 1001; i++) {           compareValue = vs.getNext();        }        compareValue = vs.getNext();        assertEquals(compareValue,firstDataValue,tolerance);        compareValue = vs.getNext();        assertEquals(compareValue,secondDataValue,tolerance);    }}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * This class contains test cases for the ExpandableDoubleArray. *  * @author <a href="mailto:tobrien@apache.org">Tim O'Brien</a> */public class ExpandableDoubleArrayTest extends DoubleArrayAbstractTest {public ExpandableDoubleArrayTest(String name) {super( name );}/* (non-Javadoc) * @see junit.framework.TestCase#setUp() */protected void setUp() throws Exception {da = new ExpandableDoubleArray();ra = new ExpandableDoubleArray();}/* (non-Javadoc) * @see junit.framework.TestCase#tearDown() */protected void tearDown() throws Exception {da = null;ra = null;}/** TEST NORMAL OPERATIONS - calling super class test and then checking internal *   storage **/public void testSetElementArbitraryExpansion() {double[] controlArray = {2.0, 4.0, 6.0};da.addElement(2.0);da.addElement(4.0);da.addElement(6.0);da.setElement(1, 3.0);// Expand the array arbitrarily to 1000 itemsda.setElement(1000, 3.4);assertEquals( "The number of elements should now be 1001, it isn't", da.getNumElements(), 1001);assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0,da.getElement( 760 ), Double.MIN_VALUE );assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), Double.MIN_VALUE );assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), Double.MIN_VALUE);}public void testAdd1000() {super.testAdd1000();assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " +"16 and an expansion factor of 2.0",1024, ((ExpandableDoubleArray) da).getInternalLength());}public void testAddElementRolling() {super.testAddElementRolling();}public void testSetNumberOfElements() {da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );da.addElement( 1.0 );assertEquals( "Number of elements should equal 6", da.getNumElements(), 6);((ExpandableDoubleArray) da).setNumElements( 3 );assertEquals( "Number of elements should equal 3", da.getNumElements(), 3);try {((ExpandableDoubleArray) da).setNumElements( -3 );fail( "Setting number of elements to negative should've thrown an exception");} catch( IllegalArgumentException iae ) {}((ExpandableDoubleArray) da).setNumElements(1024);assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024);assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE);}/** TESTS WHICH FOCUS ON ExpandableSpecific internal storage */public void testWithInitialCapacity() {ExpandableDoubleArray eDA2 = new ExpandableDoubleArray(2);assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements());int iterations = (int) Math.pow(2.0, 15.0);for( int i = 0; i < iterations; i++) {eDA2.addElement( i );}assertEquals("Number of elements should be equal to 2^15", (int) Math.pow(2.0, 15.0), eDA2.getNumElements());eDA2.addElement( 2.0 );assertEquals("Number of elements should be equals to 2^15 + 1",        ( (int) Math.pow(2.0, 15.0) + 1 ), eDA2.getNumElements() );}public void testWithInitialCapacityAndExpansionFactor() {ExpandableDoubleArray eDA3 = new ExpandableDoubleArray(3, 3.0f);assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() );int iterations = (int) Math.pow(3.0, 7.0);for( int i = 0; i < iterations; i++) {eDA3.addElement( i );}assertEquals("Number of elements should be equal to 3^7", (int) Math.pow(3.0, 7.0), eDA3.getNumElements());eDA3.addElement( 2.0 );assertEquals("Number of elements should be equals to 3^7 + 1",( (int) Math.pow(3.0, 7.0) + 1 ), eDA3.getNumElements() );   assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);}public void testDiscard() {da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);da.addElement(2.0);assertEquals( "Number of elements should be 11", 11, da.getNumElements());da.discardFrontElements(5);assertEquals( "Number of elements should be 6", 6, da.getNumElements());try {da.discardFrontElements(-1);fail( "Trying to discard a negative number of element is not allowed");} catch( Exception e ){}try {da.discardFrontElements( 10000 );fail( "You can't discard more elements than the array contains");} catch( Exception e ){}}/** TEST ERROR CONDITIONS **/public void testIllegalInitialCapacity() {try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(-3, 2.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the initialCapacity was negative, if it didn't then" +" the range checking of initialCapacity is not working properly" );} catch( IllegalArgumentException iae ) {}try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(0, 2.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the initialCapacity was ZERO if it didn't then" +" the range checking of initialCapacity is not working properly" );} catch( IllegalArgumentException iae ) {}}public void testIllegalExpansionFactor() {try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.66f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for 0.66 which would shrink the array instead of expand the array");} catch( IllegalArgumentException iae ) {}try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(3, 0.0f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for 0.0");} catch( IllegalArgumentException iae) {}try {ExpandableDoubleArray eDA = new ExpandableDoubleArray(3, -4.35f);fail( "That constructor should have thrown an IllegalArgumentException because " +"the expansionFactor for -4.35");} catch( IllegalArgumentException iae) {}}public void testSetOutOfBounds() {try {da.setElement( -1, 2.0);fail( "Cannot set a negative index");} catch( Exception e ){}}public void testGetOutOfBounds() {try {da.getElement(10000);fail( "Cannot get an element that is larger than the number of elements");} catch( Exception e ) {}try {da.getElement(-3);fail("Cannot get a negative index");} catch( Exception e ){}}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import junit.framework.AssertionFailedError;import java.io.File;import java.net.URL;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl;/** * Test cases for the EmpiricalDistribution class * * @author Phil Steitz * @version $Revision: 1.2 $ $Date: 2003/05/29 20:35:45 $ */public final class EmpiricalDistributionTest extends TestCase {    private EmpiricalDistribution empiricalDistribution = null;    private File file = null;        public EmpiricalDistributionTest(String name) {        super(name);    }    public void setUp() {        empiricalDistribution = new EmpiricalDistributionImpl(100);        URL url = getClass().getResource("testData.txt");        file = new File(url.getFile());    }    public static Test suite() {        TestSuite suite = new TestSuite(EmpiricalDistributionTest.class);        suite.setName("EmpiricalDistribution Tests");        return suite;    }    /**     * Test EmpiricalDistrbution.load() using sample data file.<br>      * Check that the sampleCount, mu and sigma match data in      * the sample data file.     */    public void testLoad() throws Exception {        empiricalDistribution.load(file);           // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1        // Make sure that loaded distribution matches this        assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);        //TODO: replace with statistical tests        assertEquals            (empiricalDistribution.getSampleStats().getMean(),                5.069831575018909,10E-7);        assertEquals          (empiricalDistribution.getSampleStats().getStandardDeviation(),                1.0173699343977738,10E-7);    }        /**       * Generate 1000 random values and make sure they look OK.<br>      * Note that there is a non-zero (but very small) probability that      * these tests will fail even if the code is working as designed.      */    public void testNext() throws Exception {        tstGen(0.1);    }        /**      * Make sure exception thrown if digest getNext is attempted      * before loading empiricalDistribution.     */    public void testNexFail() {        try {            empiricalDistribution.getNextValue();            fail("Expecting IllegalStateException");        } catch (IllegalStateException ex) {;}    }        /**     * Make sure we can handle a grid size that is too fine     */    public void testGridTooFine() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(10000);        tstGen(0.1);        }        /**     * How about too fat?     */    public void testGridTooFat() throws Exception {        empiricalDistribution = new EmpiricalDistributionImpl(1);        tstGen(5); // ridiculous tolerance; but ridiculous grid size                   // really just checking to make sure we do not bomb    }        private void tstGen(double tolerance)throws Exception {        empiricalDistribution.load(file);           Univariate stats = new UnivariateImpl();        for (int i = 1; i < 1000; i++) {            stats.addValue(empiricalDistribution.getNextValue());        }        //TODO: replace these with statistical tests -- refactor as necessary        assertEquals("mean", stats.getMean(),5.069831575018909,tolerance);        assertEquals         ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance);    }                               }
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;import org.apache.commons.math.stat.Univariate;import org.apache.commons.math.stat.UnivariateImpl;/** * Implements the following test statistics <ul> * <li> *   <a href = http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm> *   Chi-Square</a> * </li> * <li> *   <a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm"> *     One Sample t-test</a> * </li> * </ul> * @author Phil Steitz * @version $Revision: 1.3 $ $Date: 2003/05/29 20:35:44 $ *  */public class TestStatisticImpl implements TestStatistic {        /**     * Default constructor.     */    public TestStatisticImpl() {    }        /**     * Computes Chi-Square statistic given observed and expected counts <br>     * <strong>Algorithm</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm <br>     * <strong>Numerical considerations</strong>: none <br>     * @param observed array of observed frequency counts     * @param expected array of expected frequency counts     * @throws IllegalArgumentException if input arrays have different lengths     * or length is less than 2     */    public double chiSquare(double[] expected, double[] observed) {        double sumSq = 0.0d;        double dev = 0.0d;        if ((expected.length < 2) || (expected.length != observed.length)) {            throw new IllegalArgumentException                ("observed, expected array lengths incorrect");        }        for (int i = 0; i < observed.length; i++) {            dev = (observed[i] - expected[i]);            sumSq += dev * dev / expected[i];        }                return sumSq;    }               /**     * Computes t statistic given observed values<br/>     * <strong>Algorithm</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm<br/>     * <strong>Numerical considerations</strong>: none <br>     * @param mu hypothesized mean value.     * @param observed array of observed values     * @return t-test statistic for the hypothesized mean and observed values.     * @throws IllegalArgumentException if input array length is less than 2     */public double t(double mu, double[] observed) {        if((observed == null) || (observed.length < 2)) {            throw new IllegalArgumentException                ("observed array length incorrect");        }                // leverage Univariate to compute statistics        Univariate univariate = new UnivariateImpl();        for (int i = 0; i < observed.length; i++) {univariate.addValue(observed[i]);}        double n = univariate.getN();        double xbar = univariate.getMean();        double std = univariate.getStandardDeviation();        return (xbar - mu) / (std / Math.sqrt(n));}}
/* ==================================================================== * The Apache Software License, Version 1.1 * * Copyright (c) 2003 The Apache Software Foundation.  All rights * reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in *    the documentation and/or other materials provided with the *    distribution. * * 3. The end-user documentation included with the redistribution, if *    any, must include the following acknowlegement: *       "This product includes software developed by the *        Apache Software Foundation (http://www.apache.org/)." *    Alternately, this acknowlegement may appear in the software itself, *    if and wherever such third-party acknowlegements normally appear. * * 4. The names "The Jakarta Project", "Commons", and "Apache Software *    Foundation" must not be used to endorse or promote products derived *    from this software without prior written permission. For written *    permission, please contact apache@apache.org. * * 5. Products derived from this software may not be called "Apache" *    nor may "Apache" appear in their names without prior written *    permission of the Apache Software Foundation. * * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF * SUCH DAMAGE. * ==================================================================== * * This software consists of voluntary contributions made by many * individuals on behalf of the Apache Software Foundation.  For more * information on the Apache Software Foundation, please see * <http://www.apache.org/>. */package org.apache.commons.math;/** * Interfaces for the following test statistics <ul> * <li><a href = http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm> *     Chi-Square</a></li> * <li><a href="http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm"> *     One Sample t-test</a></li> * </ul> *  * @author Phil Steitz * @version $Revision: 1.2 $ $Date: 2003/05/26 17:29:36 $ *  */public interface TestStatistic {        /**     * <strong>Description</strong>:     * Computes Chi-Square statistic given observed and expected freqeuncy counts <br>     * This statistic can be used to perform Chi-Square tests for goodness     * of fit.<br>     * <strong>Definition</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm <br>     * <strong>Preconditions</strong>: <ul>     * <li>Expected counts should all be positive. If any expected     * counts are 0, the test will return INFINITY.  Negative expected or observed counts      * make the statistic meaningless.</li>     * <li>The observed and expected arrays <i>must</i> have the same length and     * their common length must be at least 2 </li>     * </ul>     * @param observed array of observed frequency counts     * @param expected array of exptected frequency counts     * @throws IllegalArgumentException if input arrays have different lengths     * or length is less than 2     */    public double chiSquare(double[] expected, double[] observed);        /**     * <strong>Description</strong>:     * Computes one sample, t-test statistic given observed values <br/>     * This statistic can be used to perform one sample tests for means.<br/>     * <strong>Definition</strong>:      * http://www.itl.nist.gov/div898/handbook/eda/section3/eda352.htm<br/>     * <strong>Preconditions</strong>: <ul>     * <li>The observed array length <i>must</i> be at least 2.</li>     * </ul>     * @param mu hypothesized mean value.     * @param observed array of observed values     * @throws IllegalArgumentException if input array length is less than 2     */    public double t(double mu, double[] observed);}